
zephyr.elf:     file format elf32-littlearm


Disassembly of section text:

0000c000 <_vector_table-0x200>:
	...

0000c200 <_vector_table>:
    c200:	200078d0 	.word	0x200078d0
    c204:	00013d51 	.word	0x00013d51
    c208:	0002a21d 	.word	0x0002a21d
    c20c:	00013c09 	.word	0x00013c09
    c210:	00013c09 	.word	0x00013c09
    c214:	00013c09 	.word	0x00013c09
    c218:	00013c09 	.word	0x00013c09
    c21c:	00013c09 	.word	0x00013c09
    c220:	00013c09 	.word	0x00013c09
    c224:	00013c09 	.word	0x00013c09
    c228:	00013c09 	.word	0x00013c09
    c22c:	00013aa1 	.word	0x00013aa1
    c230:	00013c09 	.word	0x00013c09
    c234:	00013c09 	.word	0x00013c09
    c238:	00013a4d 	.word	0x00013a4d
    c23c:	0002a20b 	.word	0x0002a20b

0000c240 <_irq_vector_table>:
    c240:	00013d11 0002be57 00013d11 00013d11     .=..W....=...=..
    c250:	00013d11 00013d11 00013d11 00013d11     .=...=...=...=..
    c260:	00013d11 00013d11 00013d11 00013d11     .=...=...=...=..
    c270:	00013d11 00013d11 00013d11 00013d11     .=...=...=...=..
    c280:	00013d11 00013d11 00013d11 00013d11     .=...=...=...=..
    c290:	00013d11 00013d11 00013d11 00013d11     .=...=...=...=..
    c2a0:	00013d11 00013d11 00013d11 00013d11     .=...=...=...=..
    c2b0:	00013d11 00013d11 00013d11 00013d11     .=...=...=...=..
    c2c0:	00013d11 00013d11 00013d11 00013d11     .=...=...=...=..
    c2d0:	00013d11 00013d11 00013d11 00013d11     .=...=...=...=..
    c2e0:	00013d11 00013d11 00013d11 00013d11     .=...=...=...=..
    c2f0:	00013d11 00013d11 00013d11 00013d11     .=...=...=...=..

Disassembly of section _TEXT_SECTION_NAME_2:

0000c300 <__aeabi_uldivmod>:
    c300:	b953      	cbnz	r3, c318 <__aeabi_uldivmod+0x18>
    c302:	b94a      	cbnz	r2, c318 <__aeabi_uldivmod+0x18>
    c304:	2900      	cmp	r1, #0
    c306:	bf08      	it	eq
    c308:	2800      	cmpeq	r0, #0
    c30a:	bf1c      	itt	ne
    c30c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
    c310:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    c314:	f000 b80c 	b.w	c330 <__aeabi_idiv0>
    c318:	f1ad 0c08 	sub.w	ip, sp, #8
    c31c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    c320:	f000 f808 	bl	c334 <__udivmoddi4>
    c324:	f8dd e004 	ldr.w	lr, [sp, #4]
    c328:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c32c:	b004      	add	sp, #16
    c32e:	4770      	bx	lr

0000c330 <__aeabi_idiv0>:
    c330:	4770      	bx	lr
    c332:	bf00      	nop

0000c334 <__udivmoddi4>:
    c334:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c338:	9f09      	ldr	r7, [sp, #36]	; 0x24
    c33a:	4615      	mov	r5, r2
    c33c:	4604      	mov	r4, r0
    c33e:	468e      	mov	lr, r1
    c340:	461e      	mov	r6, r3
    c342:	2b00      	cmp	r3, #0
    c344:	f040 80cc 	bne.w	c4e0 <__udivmoddi4+0x1ac>
    c348:	428a      	cmp	r2, r1
    c34a:	fab2 fc82 	clz	ip, r2
    c34e:	d94c      	bls.n	c3ea <__udivmoddi4+0xb6>
    c350:	f1bc 0f00 	cmp.w	ip, #0
    c354:	d00b      	beq.n	c36e <__udivmoddi4+0x3a>
    c356:	f1cc 0820 	rsb	r8, ip, #32
    c35a:	fa01 fe0c 	lsl.w	lr, r1, ip
    c35e:	fa20 f808 	lsr.w	r8, r0, r8
    c362:	fa02 f50c 	lsl.w	r5, r2, ip
    c366:	ea48 0e0e 	orr.w	lr, r8, lr
    c36a:	fa00 f40c 	lsl.w	r4, r0, ip
    c36e:	ea4f 4915 	mov.w	r9, r5, lsr #16
    c372:	fa1f f885 	uxth.w	r8, r5
    c376:	fbbe faf9 	udiv	sl, lr, r9
    c37a:	0c21      	lsrs	r1, r4, #16
    c37c:	fb09 e31a 	mls	r3, r9, sl, lr
    c380:	fb0a fb08 	mul.w	fp, sl, r8
    c384:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
    c388:	459b      	cmp	fp, r3
    c38a:	d92a      	bls.n	c3e2 <__udivmoddi4+0xae>
    c38c:	18eb      	adds	r3, r5, r3
    c38e:	f10a 30ff 	add.w	r0, sl, #4294967295	; 0xffffffff
    c392:	d204      	bcs.n	c39e <__udivmoddi4+0x6a>
    c394:	459b      	cmp	fp, r3
    c396:	d902      	bls.n	c39e <__udivmoddi4+0x6a>
    c398:	f1aa 0002 	sub.w	r0, sl, #2
    c39c:	442b      	add	r3, r5
    c39e:	eba3 030b 	sub.w	r3, r3, fp
    c3a2:	b2a4      	uxth	r4, r4
    c3a4:	fbb3 f2f9 	udiv	r2, r3, r9
    c3a8:	fb09 3312 	mls	r3, r9, r2, r3
    c3ac:	fb02 f808 	mul.w	r8, r2, r8
    c3b0:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    c3b4:	45a0      	cmp	r8, r4
    c3b6:	d916      	bls.n	c3e6 <__udivmoddi4+0xb2>
    c3b8:	192c      	adds	r4, r5, r4
    c3ba:	f102 33ff 	add.w	r3, r2, #4294967295	; 0xffffffff
    c3be:	d203      	bcs.n	c3c8 <__udivmoddi4+0x94>
    c3c0:	45a0      	cmp	r8, r4
    c3c2:	d901      	bls.n	c3c8 <__udivmoddi4+0x94>
    c3c4:	1e93      	subs	r3, r2, #2
    c3c6:	442c      	add	r4, r5
    c3c8:	eba4 0408 	sub.w	r4, r4, r8
    c3cc:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    c3d0:	b127      	cbz	r7, c3dc <__udivmoddi4+0xa8>
    c3d2:	fa24 f40c 	lsr.w	r4, r4, ip
    c3d6:	2300      	movs	r3, #0
    c3d8:	603c      	str	r4, [r7, #0]
    c3da:	607b      	str	r3, [r7, #4]
    c3dc:	4631      	mov	r1, r6
    c3de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c3e2:	4650      	mov	r0, sl
    c3e4:	e7db      	b.n	c39e <__udivmoddi4+0x6a>
    c3e6:	4613      	mov	r3, r2
    c3e8:	e7ee      	b.n	c3c8 <__udivmoddi4+0x94>
    c3ea:	b902      	cbnz	r2, c3ee <__udivmoddi4+0xba>
    c3ec:	deff      	udf	#255	; 0xff
    c3ee:	f1bc 0f00 	cmp.w	ip, #0
    c3f2:	d12e      	bne.n	c452 <__udivmoddi4+0x11e>
    c3f4:	1a8b      	subs	r3, r1, r2
    c3f6:	2601      	movs	r6, #1
    c3f8:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    c3fc:	b2aa      	uxth	r2, r5
    c3fe:	fbb3 f8fe 	udiv	r8, r3, lr
    c402:	0c21      	lsrs	r1, r4, #16
    c404:	fb0e 3318 	mls	r3, lr, r8, r3
    c408:	fb08 f902 	mul.w	r9, r8, r2
    c40c:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
    c410:	4599      	cmp	r9, r3
    c412:	d961      	bls.n	c4d8 <__udivmoddi4+0x1a4>
    c414:	18eb      	adds	r3, r5, r3
    c416:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
    c41a:	d204      	bcs.n	c426 <__udivmoddi4+0xf2>
    c41c:	4599      	cmp	r9, r3
    c41e:	d902      	bls.n	c426 <__udivmoddi4+0xf2>
    c420:	f1a8 0002 	sub.w	r0, r8, #2
    c424:	442b      	add	r3, r5
    c426:	eba3 0309 	sub.w	r3, r3, r9
    c42a:	b2a4      	uxth	r4, r4
    c42c:	fbb3 f1fe 	udiv	r1, r3, lr
    c430:	fb0e 3311 	mls	r3, lr, r1, r3
    c434:	434a      	muls	r2, r1
    c436:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
    c43a:	42a2      	cmp	r2, r4
    c43c:	d94e      	bls.n	c4dc <__udivmoddi4+0x1a8>
    c43e:	192c      	adds	r4, r5, r4
    c440:	f101 33ff 	add.w	r3, r1, #4294967295	; 0xffffffff
    c444:	d203      	bcs.n	c44e <__udivmoddi4+0x11a>
    c446:	42a2      	cmp	r2, r4
    c448:	d901      	bls.n	c44e <__udivmoddi4+0x11a>
    c44a:	1e8b      	subs	r3, r1, #2
    c44c:	442c      	add	r4, r5
    c44e:	1aa4      	subs	r4, r4, r2
    c450:	e7bc      	b.n	c3cc <__udivmoddi4+0x98>
    c452:	f1cc 0e20 	rsb	lr, ip, #32
    c456:	fa02 f50c 	lsl.w	r5, r2, ip
    c45a:	fa21 f90e 	lsr.w	r9, r1, lr
    c45e:	fa01 f30c 	lsl.w	r3, r1, ip
    c462:	fa20 fe0e 	lsr.w	lr, r0, lr
    c466:	ea4e 0303 	orr.w	r3, lr, r3
    c46a:	ea4f 4815 	mov.w	r8, r5, lsr #16
    c46e:	fa00 f40c 	lsl.w	r4, r0, ip
    c472:	fbb9 f1f8 	udiv	r1, r9, r8
    c476:	fa1f fe85 	uxth.w	lr, r5
    c47a:	fb08 9211 	mls	r2, r8, r1, r9
    c47e:	0c18      	lsrs	r0, r3, #16
    c480:	fb01 f60e 	mul.w	r6, r1, lr
    c484:	ea40 4202 	orr.w	r2, r0, r2, lsl #16
    c488:	4296      	cmp	r6, r2
    c48a:	d921      	bls.n	c4d0 <__udivmoddi4+0x19c>
    c48c:	18aa      	adds	r2, r5, r2
    c48e:	f101 30ff 	add.w	r0, r1, #4294967295	; 0xffffffff
    c492:	d203      	bcs.n	c49c <__udivmoddi4+0x168>
    c494:	4296      	cmp	r6, r2
    c496:	d901      	bls.n	c49c <__udivmoddi4+0x168>
    c498:	1e88      	subs	r0, r1, #2
    c49a:	442a      	add	r2, r5
    c49c:	1b92      	subs	r2, r2, r6
    c49e:	b29b      	uxth	r3, r3
    c4a0:	fbb2 f9f8 	udiv	r9, r2, r8
    c4a4:	fb08 2219 	mls	r2, r8, r9, r2
    c4a8:	fb09 fe0e 	mul.w	lr, r9, lr
    c4ac:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
    c4b0:	459e      	cmp	lr, r3
    c4b2:	d90f      	bls.n	c4d4 <__udivmoddi4+0x1a0>
    c4b4:	18eb      	adds	r3, r5, r3
    c4b6:	f109 36ff 	add.w	r6, r9, #4294967295	; 0xffffffff
    c4ba:	d204      	bcs.n	c4c6 <__udivmoddi4+0x192>
    c4bc:	459e      	cmp	lr, r3
    c4be:	d902      	bls.n	c4c6 <__udivmoddi4+0x192>
    c4c0:	f1a9 0602 	sub.w	r6, r9, #2
    c4c4:	442b      	add	r3, r5
    c4c6:	eba3 030e 	sub.w	r3, r3, lr
    c4ca:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
    c4ce:	e793      	b.n	c3f8 <__udivmoddi4+0xc4>
    c4d0:	4608      	mov	r0, r1
    c4d2:	e7e3      	b.n	c49c <__udivmoddi4+0x168>
    c4d4:	464e      	mov	r6, r9
    c4d6:	e7f6      	b.n	c4c6 <__udivmoddi4+0x192>
    c4d8:	4640      	mov	r0, r8
    c4da:	e7a4      	b.n	c426 <__udivmoddi4+0xf2>
    c4dc:	460b      	mov	r3, r1
    c4de:	e7b6      	b.n	c44e <__udivmoddi4+0x11a>
    c4e0:	428b      	cmp	r3, r1
    c4e2:	d905      	bls.n	c4f0 <__udivmoddi4+0x1bc>
    c4e4:	b10f      	cbz	r7, c4ea <__udivmoddi4+0x1b6>
    c4e6:	e9c7 0100 	strd	r0, r1, [r7]
    c4ea:	2600      	movs	r6, #0
    c4ec:	4630      	mov	r0, r6
    c4ee:	e775      	b.n	c3dc <__udivmoddi4+0xa8>
    c4f0:	fab3 fc83 	clz	ip, r3
    c4f4:	f1bc 0f00 	cmp.w	ip, #0
    c4f8:	d10f      	bne.n	c51a <__udivmoddi4+0x1e6>
    c4fa:	428b      	cmp	r3, r1
    c4fc:	d301      	bcc.n	c502 <__udivmoddi4+0x1ce>
    c4fe:	4282      	cmp	r2, r0
    c500:	d809      	bhi.n	c516 <__udivmoddi4+0x1e2>
    c502:	1a84      	subs	r4, r0, r2
    c504:	eb61 0e03 	sbc.w	lr, r1, r3
    c508:	2001      	movs	r0, #1
    c50a:	2f00      	cmp	r7, #0
    c50c:	d06a      	beq.n	c5e4 <__udivmoddi4+0x2b0>
    c50e:	e9c7 4e00 	strd	r4, lr, [r7]
    c512:	2600      	movs	r6, #0
    c514:	e762      	b.n	c3dc <__udivmoddi4+0xa8>
    c516:	4660      	mov	r0, ip
    c518:	e7f7      	b.n	c50a <__udivmoddi4+0x1d6>
    c51a:	f1cc 0e20 	rsb	lr, ip, #32
    c51e:	fa03 f30c 	lsl.w	r3, r3, ip
    c522:	fa22 f50e 	lsr.w	r5, r2, lr
    c526:	fa21 f40e 	lsr.w	r4, r1, lr
    c52a:	431d      	orrs	r5, r3
    c52c:	fa01 f30c 	lsl.w	r3, r1, ip
    c530:	fa20 f10e 	lsr.w	r1, r0, lr
    c534:	430b      	orrs	r3, r1
    c536:	ea4f 4a15 	mov.w	sl, r5, lsr #16
    c53a:	fa00 f60c 	lsl.w	r6, r0, ip
    c53e:	fbb4 f9fa 	udiv	r9, r4, sl
    c542:	fa1f f885 	uxth.w	r8, r5
    c546:	fb0a 4019 	mls	r0, sl, r9, r4
    c54a:	0c1c      	lsrs	r4, r3, #16
    c54c:	fb09 f108 	mul.w	r1, r9, r8
    c550:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
    c554:	42a1      	cmp	r1, r4
    c556:	fa02 f20c 	lsl.w	r2, r2, ip
    c55a:	d93f      	bls.n	c5dc <__udivmoddi4+0x2a8>
    c55c:	192c      	adds	r4, r5, r4
    c55e:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
    c562:	d204      	bcs.n	c56e <__udivmoddi4+0x23a>
    c564:	42a1      	cmp	r1, r4
    c566:	d902      	bls.n	c56e <__udivmoddi4+0x23a>
    c568:	f1a9 0002 	sub.w	r0, r9, #2
    c56c:	442c      	add	r4, r5
    c56e:	1a64      	subs	r4, r4, r1
    c570:	b29b      	uxth	r3, r3
    c572:	fbb4 f9fa 	udiv	r9, r4, sl
    c576:	fb0a 4419 	mls	r4, sl, r9, r4
    c57a:	fb09 f808 	mul.w	r8, r9, r8
    c57e:	ea43 4104 	orr.w	r1, r3, r4, lsl #16
    c582:	4588      	cmp	r8, r1
    c584:	d92c      	bls.n	c5e0 <__udivmoddi4+0x2ac>
    c586:	1869      	adds	r1, r5, r1
    c588:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
    c58c:	d204      	bcs.n	c598 <__udivmoddi4+0x264>
    c58e:	4588      	cmp	r8, r1
    c590:	d902      	bls.n	c598 <__udivmoddi4+0x264>
    c592:	f1a9 0302 	sub.w	r3, r9, #2
    c596:	4429      	add	r1, r5
    c598:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
    c59c:	eba1 0108 	sub.w	r1, r1, r8
    c5a0:	fba0 8902 	umull	r8, r9, r0, r2
    c5a4:	4549      	cmp	r1, r9
    c5a6:	46c2      	mov	sl, r8
    c5a8:	464c      	mov	r4, r9
    c5aa:	d302      	bcc.n	c5b2 <__udivmoddi4+0x27e>
    c5ac:	d106      	bne.n	c5bc <__udivmoddi4+0x288>
    c5ae:	4546      	cmp	r6, r8
    c5b0:	d204      	bcs.n	c5bc <__udivmoddi4+0x288>
    c5b2:	ebb8 0a02 	subs.w	sl, r8, r2
    c5b6:	eb69 0405 	sbc.w	r4, r9, r5
    c5ba:	3801      	subs	r0, #1
    c5bc:	b197      	cbz	r7, c5e4 <__udivmoddi4+0x2b0>
    c5be:	ebb6 030a 	subs.w	r3, r6, sl
    c5c2:	eb61 0604 	sbc.w	r6, r1, r4
    c5c6:	fa06 fe0e 	lsl.w	lr, r6, lr
    c5ca:	fa23 f30c 	lsr.w	r3, r3, ip
    c5ce:	ea4e 0303 	orr.w	r3, lr, r3
    c5d2:	fa26 f60c 	lsr.w	r6, r6, ip
    c5d6:	e9c7 3600 	strd	r3, r6, [r7]
    c5da:	e79a      	b.n	c512 <__udivmoddi4+0x1de>
    c5dc:	4648      	mov	r0, r9
    c5de:	e7c6      	b.n	c56e <__udivmoddi4+0x23a>
    c5e0:	464b      	mov	r3, r9
    c5e2:	e7d9      	b.n	c598 <__udivmoddi4+0x264>
    c5e4:	463e      	mov	r6, r7
    c5e6:	e6f9      	b.n	c3dc <__udivmoddi4+0xa8>

0000c5e8 <ll_adv_enable>:
{
	u32_t ticks_anchor;
#endif /* !CONFIG_BT_HCI_MESH_EXT */
#else /* !CONFIG_BT_CTLR_ADV_EXT || !CONFIG_BT_HCI_MESH_EXT */
u8_t ll_adv_enable(u8_t enable)
{
    c5e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c5ec:	b091      	sub	sp, #68	; 0x44
	u16_t const handle = 0;
	u32_t ticks_anchor;
#endif /* !CONFIG_BT_CTLR_ADV_EXT || !CONFIG_BT_HCI_MESH_EXT */
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
    c5ee:	2302      	movs	r3, #2
    c5f0:	930f      	str	r3, [sp, #60]	; 0x3c
	u32_t ticks_slot_offset;
	struct ll_adv_set *adv;
	struct lll_adv *lll;
	u32_t ret;

	if (!enable) {
    c5f2:	b930      	cbnz	r0, c602 <ll_adv_enable+0x1a>
		return disable(handle);
    c5f4:	f012 fee8 	bl	1f3c8 <disable.constprop.5>
    c5f8:	4606      	mov	r6, r0
		conn_release(adv);
	}
#endif /* CONFIG_BT_PERIPHERAL */

	return BT_HCI_ERR_CMD_DISALLOWED;
}
    c5fa:	4630      	mov	r0, r6
    c5fc:	b011      	add	sp, #68	; 0x44
    c5fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
static inline struct ll_adv_set *is_disabled_get(u16_t handle)
{
	struct ll_adv_set *adv;

	adv = ull_adv_set_get(handle);
	if (!adv || adv->is_enabled) {
    c602:	4f42      	ldr	r7, [pc, #264]	; (c70c <ll_adv_enable+0x124>)
    c604:	f897 60cc 	ldrb.w	r6, [r7, #204]	; 0xcc
    c608:	f016 0601 	ands.w	r6, r6, #1
    c60c:	463d      	mov	r5, r7
    c60e:	d001      	beq.n	c614 <ll_adv_enable+0x2c>
	return BT_HCI_ERR_CMD_DISALLOWED;
    c610:	260c      	movs	r6, #12
    c612:	e7f2      	b.n	c5fa <ll_adv_enable+0x12>
	lll_adv_pdu_enqueue(&lll->adv_data, idx);
}

static inline struct pdu_adv *lll_adv_data_peek(struct lll_adv *lll)
{
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
    c614:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
    c618:	232d      	movs	r3, #45	; 0x2d
    c61a:	f04f 0827 	mov.w	r8, #39	; 0x27
    c61e:	fb18 3802 	smlabb	r8, r8, r2, r3
    c622:	eb07 0b08 	add.w	fp, r7, r8
	if (pdu_adv->tx_addr) {
    c626:	f817 3008 	ldrb.w	r3, [r7, r8]
    c62a:	0658      	lsls	r0, r3, #25
    c62c:	d43c      	bmi.n	c6a8 <ll_adv_enable+0xc0>
	lll_adv_pdu_enqueue(&lll->scan_rsp, idx);
}

static inline struct pdu_adv *lll_adv_scan_rsp_peek(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
    c62e:	f895 307c 	ldrb.w	r3, [r5, #124]	; 0x7c
		ull_filter_adv_update(lll->filter_policy);
    c632:	f895 0029 	ldrb.w	r0, [r5, #41]	; 0x29
    c636:	2227      	movs	r2, #39	; 0x27
    c638:	fb02 5303 	mla	r3, r2, r3, r5
    c63c:	337d      	adds	r3, #125	; 0x7d
    c63e:	f000 0003 	and.w	r0, r0, #3
    c642:	930b      	str	r3, [sp, #44]	; 0x2c
    c644:	f017 f9d6 	bl	239f4 <ull_filter_adv_update>
		if (adv->own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
    c648:	f895 00da 	ldrb.w	r0, [r5, #218]	; 0xda
    c64c:	f010 0402 	ands.w	r4, r0, #2
    c650:	d035      	beq.n	c6be <ll_adv_enable+0xd6>
			rl_idx = ull_filter_rl_find(adv->id_addr_type,
    c652:	2200      	movs	r2, #0
    c654:	492e      	ldr	r1, [pc, #184]	; (c710 <ll_adv_enable+0x128>)
    c656:	f3c0 0080 	ubfx	r0, r0, #2, #1
    c65a:	f017 fa71 	bl	23b40 <ull_filter_rl_find>
			if (rl_idx != FILTER_IDX_NONE) {
    c65e:	28ff      	cmp	r0, #255	; 0xff
			rl_idx = ull_filter_rl_find(adv->id_addr_type,
    c660:	4681      	mov	r9, r0
			if (rl_idx != FILTER_IDX_NONE) {
    c662:	d002      	beq.n	c66a <ll_adv_enable+0x82>
				ull_filter_rpa_update(false);
    c664:	2000      	movs	r0, #0
    c666:	f017 fc95 	bl	23f94 <ull_filter_rpa_update>
			ull_filter_adv_pdu_update(adv, rl_idx, pdu_adv);
    c66a:	465a      	mov	r2, fp
    c66c:	4649      	mov	r1, r9
    c66e:	4827      	ldr	r0, [pc, #156]	; (c70c <ll_adv_enable+0x124>)
    c670:	f017 fa04 	bl	23a7c <ull_filter_adv_pdu_update>
			ull_filter_adv_pdu_update(adv, rl_idx, pdu_scan);
    c674:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    c676:	4825      	ldr	r0, [pc, #148]	; (c70c <ll_adv_enable+0x124>)
    c678:	4649      	mov	r1, r9
    c67a:	f017 f9ff 	bl	23a7c <ull_filter_adv_pdu_update>
	if ((pdu_adv->type == PDU_ADV_TYPE_ADV_IND) ||
    c67e:	f817 3008 	ldrb.w	r3, [r7, r8]
    c682:	f013 0f0e 	tst.w	r3, #14
    c686:	f040 80fb 	bne.w	c880 <ll_adv_enable+0x298>
		if (lll->conn) {
    c68a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    c68c:	2b00      	cmp	r3, #0
    c68e:	d1bf      	bne.n	c610 <ll_adv_enable+0x28>
		link = ll_rx_link_alloc();
    c690:	f011 fdae 	bl	1e1f0 <ll_rx_link_alloc>
		if (!link) {
    c694:	4682      	mov	sl, r0
    c696:	b128      	cbz	r0, c6a4 <ll_adv_enable+0xbc>
		node_rx = ll_rx_alloc();
    c698:	f011 fdb6 	bl	1e208 <ll_rx_alloc>
		if (!node_rx) {
    c69c:	bb60      	cbnz	r0, c6f8 <ll_adv_enable+0x110>
			ll_rx_link_release(link);
    c69e:	4650      	mov	r0, sl
    c6a0:	f011 fdac 	bl	1e1fc <ll_rx_link_release>
			return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
    c6a4:	2607      	movs	r6, #7
    c6a6:	e7a8      	b.n	c5fa <ll_adv_enable+0x12>
		if (!mem_nz(ll_addr_get(1, NULL), BDADDR_SIZE)) {
    c6a8:	4631      	mov	r1, r6
    c6aa:	2001      	movs	r0, #1
    c6ac:	f00f fdd0 	bl	1c250 <ll_addr_get>
    c6b0:	2106      	movs	r1, #6
    c6b2:	f01f f982 	bl	2b9ba <mem_nz>
    c6b6:	2800      	cmp	r0, #0
    c6b8:	d1b9      	bne.n	c62e <ll_adv_enable+0x46>
			return BT_HCI_ERR_INVALID_PARAM;
    c6ba:	2612      	movs	r6, #18
    c6bc:	e79d      	b.n	c5fa <ll_adv_enable+0x12>
			       ll_addr_get(pdu_adv->tx_addr, NULL),
    c6be:	f817 0008 	ldrb.w	r0, [r7, r8]
    c6c2:	4621      	mov	r1, r4
    c6c4:	f3c0 1080 	ubfx	r0, r0, #6, #1
    c6c8:	f00f fdc2 	bl	1c250 <ll_addr_get>
			memcpy(&pdu_adv->adv_ind.addr[0],
    c6cc:	2206      	movs	r2, #6
    c6ce:	4601      	mov	r1, r0
    c6d0:	f10b 0002 	add.w	r0, fp, #2
    c6d4:	f01d febb 	bl	2a44e <memcpy>
			       ll_addr_get(pdu_adv->tx_addr, NULL),
    c6d8:	f817 0008 	ldrb.w	r0, [r7, r8]
    c6dc:	4621      	mov	r1, r4
    c6de:	f3c0 1080 	ubfx	r0, r0, #6, #1
    c6e2:	f00f fdb5 	bl	1c250 <ll_addr_get>
			memcpy(&pdu_scan->scan_rsp.addr[0],
    c6e6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    c6e8:	4601      	mov	r1, r0
    c6ea:	2206      	movs	r2, #6
    c6ec:	1c98      	adds	r0, r3, #2
    c6ee:	f01d feae 	bl	2a44e <memcpy>
	u8_t   rl_idx = FILTER_IDX_NONE;
    c6f2:	f04f 09ff 	mov.w	r9, #255	; 0xff
    c6f6:	e7c2      	b.n	c67e <ll_adv_enable+0x96>
    c6f8:	900c      	str	r0, [sp, #48]	; 0x30
		conn = ll_conn_acquire();
    c6fa:	f013 ff35 	bl	20568 <ll_conn_acquire>
		if (!conn) {
    c6fe:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    c700:	4604      	mov	r4, r0
    c702:	b938      	cbnz	r0, c714 <ll_adv_enable+0x12c>
			ll_rx_release(node_rx);
    c704:	4618      	mov	r0, r3
    c706:	f011 fd85 	bl	1e214 <ll_rx_release>
    c70a:	e7c8      	b.n	c69e <ll_adv_enable+0xb6>
    c70c:	20002738 	.word	0x20002738
    c710:	20002814 	.word	0x20002814
		conn_lll = &conn->lll;
    c714:	f100 021c 	add.w	r2, r0, #28
    c718:	920c      	str	r2, [sp, #48]	; 0x30
		conn_lll->handle = 0xFFFF;
    c71a:	f64f 72ff 	movw	r2, #65535	; 0xffff
    c71e:	8582      	strh	r2, [r0, #44]	; 0x2c
		if (!conn_lll->link_tx_free) {
    c720:	6f82      	ldr	r2, [r0, #120]	; 0x78
    c722:	b912      	cbnz	r2, c72a <ll_adv_enable+0x142>
			conn_lll->link_tx_free = &conn_lll->link_tx;
    c724:	f100 0270 	add.w	r2, r0, #112	; 0x70
    c728:	6782      	str	r2, [r0, #120]	; 0x78
		memq_init(conn_lll->link_tx_free, &conn_lll->memq_tx.head,
    c72a:	f104 026c 	add.w	r2, r4, #108	; 0x6c
    c72e:	f104 0168 	add.w	r1, r4, #104	; 0x68
    c732:	6fa0      	ldr	r0, [r4, #120]	; 0x78
    c734:	930d      	str	r3, [sp, #52]	; 0x34
    c736:	f01f f94b 	bl	2b9d0 <memq_init>
		conn_lll->max_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0);
    c73a:	4ab9      	ldr	r2, [pc, #740]	; (ca20 <ll_adv_enable+0x438>)
		conn->llcp_terminate.node_rx.hdr.link = link;
    c73c:	f8c4 a12c 	str.w	sl, [r4, #300]	; 0x12c
		conn_lll->max_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0);
    c740:	f04f 111b 	mov.w	r1, #1769499	; 0x1b001b
    c744:	e9c4 1217 	strd	r1, r2, [r4, #92]	; 0x5c
		conn_lll->phy_tx = BIT(0);
    c748:	f8b4 2064 	ldrh.w	r2, [r4, #100]	; 0x64
		conn_lll->slave.latency_enabled = 0;
    c74c:	f894 1040 	ldrb.w	r1, [r4, #64]	; 0x40
		conn_lll->phy_tx = BIT(0);
    c750:	f422 62ef 	bic.w	r2, r2, #1912	; 0x778
    c754:	f022 0207 	bic.w	r2, r2, #7
    c758:	f442 7288 	orr.w	r2, r2, #272	; 0x110
    c75c:	f042 0201 	orr.w	r2, r2, #1
    c760:	f8a4 2064 	strh.w	r2, [r4, #100]	; 0x64
		conn_lll->data_chan_sel = 0;
    c764:	f894 203d 	ldrb.w	r2, [r4, #61]	; 0x3d
    c768:	f002 023f 	and.w	r2, r2, #63	; 0x3f
    c76c:	f062 027f 	orn	r2, r2, #127	; 0x7f
    c770:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
		conn_lll->data_chan_use = 0;
    c774:	2200      	movs	r2, #0
		conn_lll->slave.latency_enabled = 0;
    c776:	f362 0100 	bfi	r1, r2, #0, #1
    c77a:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
		conn->connect_expire = 6;
    c77e:	2106      	movs	r1, #6
    c780:	f8a4 10c4 	strh.w	r1, [r4, #196]	; 0xc4
		conn->common.fex_valid = 0;
    c784:	f894 10dc 	ldrb.w	r1, [r4, #220]	; 0xdc
		conn_lll->data_chan_use = 0;
    c788:	f884 203f 	strb.w	r2, [r4, #63]	; 0x3f
		conn->common.fex_valid = 0;
    c78c:	f021 0103 	bic.w	r1, r1, #3
    c790:	f884 10dc 	strb.w	r1, [r4, #220]	; 0xdc
		conn->llcp_feature.features = LL_FEAT;
    c794:	49a3      	ldr	r1, [pc, #652]	; (ca24 <ll_adv_enable+0x43c>)
    c796:	f8c4 111c 	str.w	r1, [r4, #284]	; 0x11c
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
    c79a:	f894 1122 	ldrb.w	r1, [r4, #290]	; 0x122
		conn_lll->latency_prepare = 0;
    c79e:	8662      	strh	r2, [r4, #50]	; 0x32
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
    c7a0:	f021 0103 	bic.w	r1, r1, #3
		conn_lll->latency_event = 0;
    c7a4:	6362      	str	r2, [r4, #52]	; 0x34
		conn_lll->slave.window_widening_event_us = 0;
    c7a6:	e9c4 2213 	strd	r2, r2, [r4, #76]	; 0x4c
		conn_lll->slave.window_size_prepare_us = 0;
    c7aa:	6562      	str	r2, [r4, #84]	; 0x54
		conn->supervision_expire = 0;
    c7ac:	f8a4 20c8 	strh.w	r2, [r4, #200]	; 0xc8
		conn->procedure_expire = 0;
    c7b0:	f8a4 20cc 	strh.w	r2, [r4, #204]	; 0xcc
		conn->llcp_req = conn->llcp_ack = conn->llcp_type = 0;
    c7b4:	f8a4 20e8 	strh.w	r2, [r4, #232]	; 0xe8
    c7b8:	f884 20ea 	strb.w	r2, [r4, #234]	; 0xea
		conn->llcp_rx = NULL;
    c7bc:	f8c4 2100 	str.w	r2, [r4, #256]	; 0x100
		conn->llcp_cu.req = conn->llcp_cu.ack = 0;
    c7c0:	f8a4 2104 	strh.w	r2, [r4, #260]	; 0x104
		conn->llcp_feature.req = conn->llcp_feature.ack = 0;
    c7c4:	f8a4 2118 	strh.w	r2, [r4, #280]	; 0x118
		conn->llcp_version.req = conn->llcp_version.ack = 0;
    c7c8:	f8a4 2120 	strh.w	r2, [r4, #288]	; 0x120
		conn->llcp_terminate.reason_peer = 0;
    c7cc:	f884 212b 	strb.w	r2, [r4, #299]	; 0x12b
		conn_lll->link_tx_free = NULL;
    c7d0:	67a2      	str	r2, [r4, #120]	; 0x78
		conn_lll->packet_tx_head_len = 0;
    c7d2:	f8a4 207c 	strh.w	r2, [r4, #124]	; 0x7c
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
    c7d6:	f884 1122 	strb.w	r1, [r4, #290]	; 0x122
		conn_lll->sn = 0;
    c7da:	f894 107e 	ldrb.w	r1, [r4, #126]	; 0x7e
		conn->llcp_enc.req = conn->llcp_enc.ack = 0U;
    c7de:	f8a4 2150 	strh.w	r2, [r4, #336]	; 0x150
		conn_lll->sn = 0;
    c7e2:	f021 011f 	bic.w	r1, r1, #31
    c7e6:	f884 107e 	strb.w	r1, [r4, #126]	; 0x7e
		conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
    c7ea:	f894 1152 	ldrb.w	r1, [r4, #338]	; 0x152
		conn->llcp_conn_param.req = 0;
    c7ee:	f8a4 2170 	strh.w	r2, [r4, #368]	; 0x170
		conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
    c7f2:	f021 0107 	bic.w	r1, r1, #7
    c7f6:	f884 1152 	strb.w	r1, [r4, #338]	; 0x152
		conn->llcp_conn_param.disabled = 0;
    c7fa:	f894 1172 	ldrb.w	r1, [r4, #370]	; 0x172
		conn->llcp_length.req = conn->llcp_length.ack = 0U;
    c7fe:	f8a4 2198 	strh.w	r2, [r4, #408]	; 0x198
		conn->llcp_conn_param.disabled = 0;
    c802:	f362 1104 	bfi	r1, r2, #4, #1
		conn->llcp_length.cache.tx_octets = 0U;
    c806:	f8a4 21a4 	strh.w	r2, [r4, #420]	; 0x1a4
		conn->llcp_conn_param.disabled = 0;
    c80a:	f884 1172 	strb.w	r1, [r4, #370]	; 0x172
		conn->default_tx_octets = ull_conn_default_tx_octets_get();
    c80e:	f013 ffef 	bl	207f0 <ull_conn_default_tx_octets_get>
    c812:	f8a4 00d6 	strh.w	r0, [r4, #214]	; 0xd6
		conn->default_tx_time = ull_conn_default_tx_time_get();
    c816:	f013 fff1 	bl	207fc <ull_conn_default_tx_time_get>
		conn->llcp_phy.req = conn->llcp_phy.ack = 0;
    c81a:	4983      	ldr	r1, [pc, #524]	; (ca28 <ll_adv_enable+0x440>)
		conn->default_tx_time = ull_conn_default_tx_time_get();
    c81c:	f8a4 00d8 	strh.w	r0, [r4, #216]	; 0xd8
		conn->llcp_phy.req = conn->llcp_phy.ack = 0;
    c820:	f8d4 01a8 	ldr.w	r0, [r4, #424]	; 0x1a8
    c824:	4001      	ands	r1, r0
    c826:	f8c4 11a8 	str.w	r1, [r4, #424]	; 0x1a8
		conn->phy_pref_tx = ull_conn_default_phy_tx_get();
    c82a:	f013 ffed 	bl	20808 <ull_conn_default_phy_tx_get>
    c82e:	f894 11ac 	ldrb.w	r1, [r4, #428]	; 0x1ac
    c832:	f360 0102 	bfi	r1, r0, #0, #3
    c836:	f884 11ac 	strb.w	r1, [r4, #428]	; 0x1ac
		conn->phy_pref_rx = ull_conn_default_phy_rx_get();
    c83a:	f013 ffeb 	bl	20814 <ull_conn_default_phy_rx_get>
		adv->node_rx_cc_free = node_rx;
    c83e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    c840:	f8c5 30d4 	str.w	r3, [r5, #212]	; 0xd4
		lll->conn = conn_lll;
    c844:	9b0c      	ldr	r3, [sp, #48]	; 0x30
		adv->link_cc_free = link;
    c846:	f8c5 a0d0 	str.w	sl, [r5, #208]	; 0xd0
		lll->conn = conn_lll;
    c84a:	626b      	str	r3, [r5, #36]	; 0x24
		conn->phy_pref_rx = ull_conn_default_phy_rx_get();
    c84c:	f894 11ac 	ldrb.w	r1, [r4, #428]	; 0x1ac
static inline void lll_hdr_init(void *lll, void *parent)
{
	struct lll_hdr *hdr = lll;

	hdr->parent = parent;
	hdr->is_stop = 0U;
    c850:	f894 3020 	ldrb.w	r3, [r4, #32]
	hdr->parent = parent;
    c854:	61e4      	str	r4, [r4, #28]
		conn->phy_pref_flags = 0;
    c856:	2200      	movs	r2, #0
		conn->phy_pref_rx = ull_conn_default_phy_rx_get();
    c858:	f360 1106 	bfi	r1, r0, #4, #3
		conn->phy_pref_flags = 0;
    c85c:	f362 01c3 	bfi	r1, r2, #3, #1
	hdr->is_stop = 0U;
    c860:	f362 0300 	bfi	r3, r2, #0, #1
    c864:	f884 11ac 	strb.w	r1, [r4, #428]	; 0x1ac
		conn->tx_data = conn->tx_data_last = 0;
    c868:	e9c4 226f 	strd	r2, r2, [r4, #444]	; 0x1bc
		conn->tx_head = conn->tx_ctrl = conn->tx_ctrl_last =
    c86c:	e9c4 226d 	strd	r2, r2, [r4, #436]	; 0x1b4
    c870:	f8c4 21b0 	str.w	r2, [r4, #432]	; 0x1b0
	return hdr->ref--;
}

static inline void ull_hdr_init(struct ull_hdr *hdr)
{
	hdr->disabled_cb = hdr->disabled_param = NULL;
    c874:	e9c4 2205 	strd	r2, r2, [r4, #20]
    c878:	f884 3020 	strb.w	r3, [r4, #32]
		lll_clock_wait();
    c87c:	f015 febe 	bl	225fc <lll_clock_wait>
	u8_t ch_map = lll->chan_map;
    c880:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
	adv->rl_idx = rl_idx;
    c884:	f885 90db 	strb.w	r9, [r5, #219]	; 0xdb
	u8_t ch_map = lll->chan_map;
    c888:	f3c3 0342 	ubfx	r3, r3, #1, #3
	const u8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
    c88c:	2101      	movs	r1, #1
    c88e:	f10d 003b 	add.w	r0, sp, #59	; 0x3b
	u8_t ch_map = lll->chan_map;
    c892:	f88d 303b 	strb.w	r3, [sp, #59]	; 0x3b
	const u8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
    c896:	f01f f8c7 	bl	2ba28 <util_ones_count_get>
	if (adv_chn_cnt == 0) {
    c89a:	2800      	cmp	r0, #0
    c89c:	f000 80b4 	beq.w	ca08 <ll_adv_enable+0x420>
		if (pdu_adv->type == PDU_ADV_TYPE_NONCONN_IND) {
    c8a0:	f817 4008 	ldrb.w	r4, [r7, r8]
		const u8_t rsp_data_len = pdu_scan->len;
    c8a4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
		const u8_t adv_data_len = pdu_adv->len;
    c8a6:	f89b 3001 	ldrb.w	r3, [fp, #1]
		const u8_t rsp_data_len = pdu_scan->len;
    c8aa:	7852      	ldrb	r2, [r2, #1]
		if (pdu_adv->type == PDU_ADV_TYPE_NONCONN_IND) {
    c8ac:	f004 040f 	and.w	r4, r4, #15
    c8b0:	2c02      	cmp	r4, #2
    c8b2:	f100 31ff 	add.w	r1, r0, #4294967295	; 0xffffffff
    c8b6:	d176      	bne.n	c9a6 <ll_adv_enable+0x3be>
			adv_size += adv_data_len;
    c8b8:	3310      	adds	r3, #16
			slot_us += BYTES2US(adv_size, phy) * adv_chn_cnt +
    c8ba:	00db      	lsls	r3, r3, #3
    c8bc:	4358      	muls	r0, r3
    c8be:	f500 70aa 	add.w	r0, r0, #340	; 0x154
    c8c2:	2364      	movs	r3, #100	; 0x64
			slot_us += (BYTES2US(adv_size, phy) + EVENT_IFS_MAX_US
    c8c4:	fb01 0003 	mla	r0, r1, r3, r0
    c8c8:	f895 3020 	ldrb.w	r3, [r5, #32]
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
    c8cc:	4957      	ldr	r1, [pc, #348]	; (ca2c <ll_adv_enable+0x444>)
	hdr->parent = parent;
    c8ce:	61ed      	str	r5, [r5, #28]
    c8d0:	2400      	movs	r4, #0
	hdr->is_stop = 0U;
    c8d2:	f364 0300 	bfi	r3, r4, #0, #1
    c8d6:	f885 3020 	strb.w	r3, [r5, #32]
	adv->evt.ticks_xtal_to_start =
    c8da:	2331      	movs	r3, #49	; 0x31
    c8dc:	602b      	str	r3, [r5, #0]
    c8de:	e9c5 4405 	strd	r4, r4, [r5, #20]
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
    c8e2:	a34d      	add	r3, pc, #308	; (adr r3, ca18 <ll_adv_enable+0x430>)
    c8e4:	e9d3 2300 	ldrd	r2, r3, [r3]
	adv->evt.ticks_active_to_start = 0;
    c8e8:	606c      	str	r4, [r5, #4]
	adv->evt.ticks_preempt_to_start =
    c8ea:	60ac      	str	r4, [r5, #8]
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
    c8ec:	fba0 0101 	umull	r0, r1, r0, r1
    c8f0:	f7ff fd06 	bl	c300 <__aeabi_uldivmod>
    c8f4:	60e8      	str	r0, [r5, #12]
	u16_t interval = adv->interval;
    c8f6:	f8b5 90d8 	ldrh.w	r9, [r5, #216]	; 0xd8
	ticks_anchor = ticker_ticks_now_get();
    c8fa:	f01f f9c2 	bl	2bc82 <ticker_ticks_now_get>
    c8fe:	4682      	mov	sl, r0
	lll->is_hdcd = !interval && (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND);
    c900:	f1b9 0f00 	cmp.w	r9, #0
    c904:	d106      	bne.n	c914 <ll_adv_enable+0x32c>
    c906:	f817 4008 	ldrb.w	r4, [r7, r8]
    c90a:	f004 040f 	and.w	r4, r4, #15
    c90e:	1e63      	subs	r3, r4, #1
    c910:	425c      	negs	r4, r3
    c912:	415c      	adcs	r4, r3
    c914:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
    c918:	f8df 8124 	ldr.w	r8, [pc, #292]	; ca40 <ll_adv_enable+0x458>
    c91c:	68ea      	ldr	r2, [r5, #12]
    c91e:	f364 0300 	bfi	r3, r4, #0, #1
    c922:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
	if (lll->is_hdcd) {
    c926:	f013 0401 	ands.w	r4, r3, #1
    c92a:	4b41      	ldr	r3, [pc, #260]	; (ca30 <ll_adv_enable+0x448>)
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    c92c:	9204      	str	r2, [sp, #16]
    c92e:	af0f      	add	r7, sp, #60	; 0x3c
    c930:	e9cd 8707 	strd	r8, r7, [sp, #28]
    c934:	e9cd 3505 	strd	r3, r5, [sp, #20]
	if (lll->is_hdcd) {
    c938:	d04e      	beq.n	c9d8 <ll_adv_enable+0x3f0>
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    c93a:	2000      	movs	r0, #0
    c93c:	e9cd 0200 	strd	r0, r2, [sp]
    c940:	2103      	movs	r1, #3
    c942:	e9cd 0002 	strd	r0, r0, [sp, #8]
    c946:	4653      	mov	r3, sl
    c948:	2202      	movs	r2, #2
    c94a:	f00f fbb5 	bl	1c0b8 <ticker_start>
		ret = ull_ticker_status_take(ret, &ret_cb);
    c94e:	4639      	mov	r1, r7
    c950:	f011 fd80 	bl	1e454 <ull_ticker_status_take>
		if (ret != TICKER_STATUS_SUCCESS) {
    c954:	2800      	cmp	r0, #0
    c956:	d157      	bne.n	ca08 <ll_adv_enable+0x420>
		ret_cb = TICKER_STATUS_BUSY;
    c958:	2202      	movs	r2, #2
    c95a:	920f      	str	r2, [sp, #60]	; 0x3c
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    c95c:	e9cd 8707 	strd	r8, r7, [sp, #28]
    c960:	4a34      	ldr	r2, [pc, #208]	; (ca34 <ll_adv_enable+0x44c>)
    c962:	9506      	str	r5, [sp, #24]
    c964:	e9cd 0002 	strd	r0, r0, [sp, #8]
    c968:	f24a 33d8 	movw	r3, #41944	; 0xa3d8
    c96c:	e9cd 0204 	strd	r0, r2, [sp, #16]
    c970:	9300      	str	r3, [sp, #0]
    c972:	9001      	str	r0, [sp, #4]
    c974:	4653      	mov	r3, sl
    c976:	2201      	movs	r2, #1
    c978:	2103      	movs	r1, #3
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    c97a:	f00f fb9d 	bl	1c0b8 <ticker_start>
	ret = ull_ticker_status_take(ret, &ret_cb);
    c97e:	4639      	mov	r1, r7
    c980:	f011 fd68 	bl	1e454 <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
    c984:	2800      	cmp	r0, #0
    c986:	d13f      	bne.n	ca08 <ll_adv_enable+0x420>
	adv->is_enabled = 1;
    c988:	f895 30cc 	ldrb.w	r3, [r5, #204]	; 0xcc
    c98c:	f043 0301 	orr.w	r3, r3, #1
    c990:	f885 30cc 	strb.w	r3, [r5, #204]	; 0xcc
	if (IS_ENABLED(CONFIG_BT_OBSERVER) && !ull_scan_is_enabled_get(0)) {
    c994:	f013 f98c 	bl	1fcb0 <ull_scan_is_enabled_get>
    c998:	2800      	cmp	r0, #0
    c99a:	f47f ae2e 	bne.w	c5fa <ll_adv_enable+0x12>
		ull_filter_adv_scan_state_cb(BIT(0));
    c99e:	2001      	movs	r0, #1
    c9a0:	f017 f818 	bl	239d4 <ull_filter_adv_scan_state_cb>
    c9a4:	e629      	b.n	c5fa <ll_adv_enable+0x12>
			if (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND) {
    c9a6:	2c01      	cmp	r4, #1
    c9a8:	d012      	beq.n	c9d0 <ll_adv_enable+0x3e8>
					  BYTES2US(ADVA_SIZE + rsp_data_len,
    c9aa:	00d2      	lsls	r2, r2, #3
		const u16_t scan_rsp_us  = ll_hdr_us +
    c9ac:	3280      	adds	r2, #128	; 0x80
			} else if (pdu_adv->type == PDU_ADV_TYPE_ADV_IND) {
    c9ae:	b94c      	cbnz	r4, c9c4 <ll_adv_enable+0x3dc>
				adv_size += adv_data_len;
    c9b0:	3310      	adds	r3, #16
				slot_us += scan_req_us + EVENT_IFS_MAX_US +
    c9b2:	f502 7227 	add.w	r2, r2, #668	; 0x29c
			slot_us += (BYTES2US(adv_size, phy) + EVENT_IFS_MAX_US
    c9b6:	00db      	lsls	r3, r3, #3
    c9b8:	f102 0098 	add.w	r0, r2, #152	; 0x98
    c9bc:	4418      	add	r0, r3
				  + rx_to_us + rxtx_turn_us) * (adv_chn_cnt-1)
    c9be:	f503 739a 	add.w	r3, r3, #308	; 0x134
    c9c2:	e77f      	b.n	c8c4 <ll_adv_enable+0x2dc>
			} else if (pdu_adv->type == PDU_ADV_TYPE_SCAN_IND) {
    c9c4:	2c06      	cmp	r4, #6
    c9c6:	d0f3      	beq.n	c9b0 <ll_adv_enable+0x3c8>
		u32_t adv_size		= ll_hdr_size + ADVA_SIZE;
    c9c8:	2310      	movs	r3, #16
	u32_t slot_us	= EVENT_OVERHEAD_START_US + EVENT_OVERHEAD_END_US;
    c9ca:	f44f 72aa 	mov.w	r2, #340	; 0x154
    c9ce:	e7f2      	b.n	c9b6 <ll_adv_enable+0x3ce>
				adv_size += TARGETA_SIZE;
    c9d0:	2316      	movs	r3, #22
				slot_us += conn_ind_us;
    c9d2:	f44f 722d 	mov.w	r2, #692	; 0x2b4
    c9d6:	e7ee      	b.n	c9b6 <ll_adv_enable+0x3ce>
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
    c9d8:	4817      	ldr	r0, [pc, #92]	; (ca38 <ll_adv_enable+0x450>)
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    c9da:	f64f 73ff 	movw	r3, #65535	; 0xffff
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
    c9de:	fa1f f889 	uxth.w	r8, r9
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    c9e2:	e9cd 4302 	strd	r4, r3, [sp, #8]
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
    c9e6:	fba8 0100 	umull	r0, r1, r8, r0
    c9ea:	2391      	movs	r3, #145	; 0x91
    c9ec:	fb03 1108 	mla	r1, r3, r8, r1
    c9f0:	a309      	add	r3, pc, #36	; (adr r3, ca18 <ll_adv_enable+0x430>)
    c9f2:	e9d3 2300 	ldrd	r2, r3, [r3]
    c9f6:	f7ff fc83 	bl	c300 <__aeabi_uldivmod>
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    c9fa:	4653      	mov	r3, sl
    c9fc:	e9cd 4000 	strd	r4, r0, [sp]
    ca00:	2202      	movs	r2, #2
    ca02:	2103      	movs	r1, #3
    ca04:	4620      	mov	r0, r4
    ca06:	e7b8      	b.n	c97a <ll_adv_enable+0x392>
	if (adv->lll.conn) {
    ca08:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    ca0a:	2b00      	cmp	r3, #0
    ca0c:	f43f ae00 	beq.w	c610 <ll_adv_enable+0x28>
		conn_release(adv);
    ca10:	480a      	ldr	r0, [pc, #40]	; (ca3c <ll_adv_enable+0x454>)
    ca12:	f012 fad9 	bl	1efc8 <conn_release>
    ca16:	e5fb      	b.n	c610 <ll_adv_enable+0x28>
    ca18:	1afd498d 	.word	0x1afd498d
    ca1c:	00000007 	.word	0x00000007
    ca20:	01480148 	.word	0x01480148
    ca24:	000149ff 	.word	0x000149ff
    ca28:	feff0000 	.word	0xfeff0000
    ca2c:	3b9aca00 	.word	0x3b9aca00
    ca30:	0001eee5 	.word	0x0001eee5
    ca34:	0001f0d1 	.word	0x0001f0d1
    ca38:	84e72a00 	.word	0x84e72a00
    ca3c:	20002738 	.word	0x20002738
    ca40:	0001e449 	.word	0x0001e449
    ca44:	00000000 	.word	0x00000000

0000ca48 <ull_scan_params_set>:
	return 0;
}

void ull_scan_params_set(struct lll_scan *lll, u8_t type, u16_t interval,
			 u16_t window, u8_t filter_policy)
{
    ca48:	e92d 4818 	stmdb	sp!, {r3, r4, fp, lr}
    ca4c:	4604      	mov	r4, r0
	 * 0110b - invalid
	 * 0111b - invalid
	 * 1000b - Ext. Coded passive
	 * 1001b - Ext. Coded active
	 */
	lll->type = type;
    ca4e:	7d80      	ldrb	r0, [r0, #22]
#if defined(CONFIG_BT_CTLR_ADV_EXT)
	lll->phy = type >> 1;
#endif /* CONFIG_BT_CTLR_ADV_EXT */

	lll->filter_policy = filter_policy;
	lll->interval = interval;
    ca50:	84e2      	strh	r2, [r4, #38]	; 0x26
	lll->type = type;
    ca52:	f361 10c7 	bfi	r0, r1, #7, #1
	lll->filter_policy = filter_policy;
    ca56:	f89d 1010 	ldrb.w	r1, [sp, #16]
    ca5a:	f361 00c4 	bfi	r0, r1, #3, #2
    ca5e:	75a0      	strb	r0, [r4, #22]
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
    ca60:	4809      	ldr	r0, [pc, #36]	; (ca88 <ull_scan_params_set+0x40>)
    ca62:	fa1f fb83 	uxth.w	fp, r3
    ca66:	fbab 0100 	umull	r0, r1, fp, r0
    ca6a:	2391      	movs	r3, #145	; 0x91
    ca6c:	fb03 110b 	mla	r1, r3, fp, r1
    ca70:	a303      	add	r3, pc, #12	; (adr r3, ca80 <ull_scan_params_set+0x38>)
    ca72:	e9d3 2300 	ldrd	r2, r3, [r3]
    ca76:	f7ff fc43 	bl	c300 <__aeabi_uldivmod>
    ca7a:	62a0      	str	r0, [r4, #40]	; 0x28
}
    ca7c:	e8bd 8818 	ldmia.w	sp!, {r3, r4, fp, pc}
    ca80:	1afd498d 	.word	0x1afd498d
    ca84:	00000007 	.word	0x00000007
    ca88:	84e72a00 	.word	0x84e72a00
    ca8c:	00000000 	.word	0x00000000

0000ca90 <ull_scan_enable>:

u8_t ull_scan_enable(struct ll_scan_set *scan)
{
    ca90:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
    ca94:	b08e      	sub	sp, #56	; 0x38
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
    ca96:	2302      	movs	r3, #2
{
    ca98:	4604      	mov	r4, r0
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
    ca9a:	930b      	str	r3, [sp, #44]	; 0x2c
	u32_t ticks_slot_offset;
	u32_t ticks_interval;
	u32_t ticks_anchor;
	u32_t ret;

	lll->chan = 0;
    ca9c:	f890 3032 	ldrb.w	r3, [r0, #50]	; 0x32
	lll->init_addr_type = scan->own_addr_type;
    caa0:	f890 0048 	ldrb.w	r0, [r0, #72]	; 0x48
	ll_addr_get(lll->init_addr_type, lll->init_addr);

	ull_hdr_init(&scan->ull);
	lll_hdr_init(lll, scan);

	ticks_interval = HAL_TICKER_US_TO_TICKS((u64_t)lll->interval * 625U);
    caa4:	4e4a      	ldr	r6, [pc, #296]	; (cbd0 <ull_scan_enable+0x140>)
	lll->init_addr_type = scan->own_addr_type;
    caa6:	f3c0 0040 	ubfx	r0, r0, #1, #1
    caaa:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
    caae:	f360 1386 	bfi	r3, r0, #6, #1
    cab2:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
	ll_addr_get(lll->init_addr_type, lll->init_addr);
    cab6:	f104 0135 	add.w	r1, r4, #53	; 0x35
    caba:	f00f fbc9 	bl	1c250 <ll_addr_get>
    cabe:	f894 3020 	ldrb.w	r3, [r4, #32]
	ticks_interval = HAL_TICKER_US_TO_TICKS((u64_t)lll->interval * 625U);
    cac2:	f8b4 7042 	ldrh.w	r7, [r4, #66]	; 0x42
	hdr->parent = parent;
    cac6:	61e4      	str	r4, [r4, #28]
    cac8:	2500      	movs	r5, #0
	hdr->is_stop = 0U;
    caca:	f365 0300 	bfi	r3, r5, #0, #1
    cace:	fba7 0106 	umull	r0, r1, r7, r6
    cad2:	f884 3020 	strb.w	r3, [r4, #32]
    cad6:	2391      	movs	r3, #145	; 0x91
    cad8:	fb03 1107 	mla	r1, r3, r7, r1
    cadc:	e9c4 5505 	strd	r5, r5, [r4, #20]
    cae0:	a339      	add	r3, pc, #228	; (adr r3, cbc8 <ull_scan_enable+0x138>)
    cae2:	e9d3 2300 	ldrd	r2, r3, [r3]
    cae6:	f7ff fc0b 	bl	c300 <__aeabi_uldivmod>

	/* TODO: active_to_start feature port */
	scan->evt.ticks_active_to_start = 0U;
	scan->evt.ticks_xtal_to_start =
    caea:	2331      	movs	r3, #49	; 0x31
    caec:	6023      	str	r3, [r4, #0]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US);
	scan->evt.ticks_preempt_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_PREEMPT_MIN_US);
	if ((lll->ticks_window +
    caee:	6c63      	ldr	r3, [r4, #68]	; 0x44
	scan->evt.ticks_active_to_start = 0U;
    caf0:	6065      	str	r5, [r4, #4]
	if ((lll->ticks_window +
    caf2:	3309      	adds	r3, #9
	     HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US)) <
	    (ticks_interval -
    caf4:	f1a0 0231 	sub.w	r2, r0, #49	; 0x31
	if ((lll->ticks_window +
    caf8:	4293      	cmp	r3, r2
	scan->evt.ticks_preempt_to_start =
    cafa:	60a5      	str	r5, [r4, #8]
	     HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US))) {
		scan->evt.ticks_slot =
    cafc:	bf32      	itee	cc
    cafe:	60e3      	strcc	r3, [r4, #12]
			 HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US));
	} else {
		scan->evt.ticks_slot =
			(ticks_interval -
			 HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US));
		lll->ticks_window = 0;
    cb00:	6465      	strcs	r5, [r4, #68]	; 0x44
		scan->evt.ticks_slot =
    cb02:	60e2      	strcs	r2, [r4, #12]
	ticks_interval = HAL_TICKER_US_TO_TICKS((u64_t)lll->interval * 625U);
    cb04:	4607      	mov	r7, r0
		ticks_slot_overhead = ticks_slot_offset;
	} else {
		ticks_slot_overhead = 0U;
	}

	ticks_anchor = ticker_ticks_now_get();
    cb06:	f01f f8bc 	bl	2bc82 <ticker_ticks_now_get>

#if defined(CONFIG_BT_CENTRAL) && defined(CONFIG_BT_CTLR_SCHED_ADVANCED)
	if (!lll->conn) {
    cb0a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    cb0c:	46b0      	mov	r8, r6
	ticks_anchor = ticker_ticks_now_get();
    cb0e:	4605      	mov	r5, r0
	if (!lll->conn) {
    cb10:	b9b3      	cbnz	r3, cb40 <ull_scan_enable+0xb0>
		u32_t ticks_ref = 0U;
		u32_t offset_us = 0U;

		ull_sched_after_mstr_slot_get(TICKER_USER_ID_THREAD,
    cb12:	68e1      	ldr	r1, [r4, #12]
		u32_t offset_us = 0U;
    cb14:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
		ull_sched_after_mstr_slot_get(TICKER_USER_ID_THREAD,
    cb18:	3131      	adds	r1, #49	; 0x31
    cb1a:	ab0d      	add	r3, sp, #52	; 0x34
    cb1c:	aa0c      	add	r2, sp, #48	; 0x30
    cb1e:	2003      	movs	r0, #3
    cb20:	f01f ff84 	bl	2ca2c <ull_sched_after_mstr_slot_get>

		/* Use the ticks_ref as scanner's anchor if a free time space
		 * after any master role is available (indicated by a non-zero
		 * offset_us value).
		 */
		if (offset_us) {
    cb24:	990d      	ldr	r1, [sp, #52]	; 0x34
    cb26:	b159      	cbz	r1, cb40 <ull_scan_enable+0xb0>
			ticks_anchor = ticks_ref +
				       HAL_TICKER_US_TO_TICKS(offset_us);
    cb28:	482a      	ldr	r0, [pc, #168]	; (cbd4 <ull_scan_enable+0x144>)
    cb2a:	a327      	add	r3, pc, #156	; (adr r3, cbc8 <ull_scan_enable+0x138>)
    cb2c:	e9d3 2300 	ldrd	r2, r3, [r3]
    cb30:	fba1 0100 	umull	r0, r1, r1, r0
    cb34:	f7ff fbe4 	bl	c300 <__aeabi_uldivmod>
			ticks_anchor = ticks_ref +
    cb38:	9b0c      	ldr	r3, [sp, #48]	; 0x30
				       HAL_TICKER_US_TO_TICKS(offset_us);
    cb3a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			ticks_anchor = ticks_ref +
    cb3e:	18c5      	adds	r5, r0, r3
		}
	}
#endif /* CONFIG_BT_CENTRAL && CONFIG_BT_CTLR_SCHED_ADVANCED */

	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    cb40:	4b25      	ldr	r3, [pc, #148]	; (cbd8 <ull_scan_enable+0x148>)
    cb42:	e9cd 4306 	strd	r4, r3, [sp, #24]
    cb46:	f10d 092c 	add.w	r9, sp, #44	; 0x2c
    cb4a:	4b24      	ldr	r3, [pc, #144]	; (cbdc <ull_scan_enable+0x14c>)
    cb4c:	f8cd 9020 	str.w	r9, [sp, #32]
    cb50:	9305      	str	r3, [sp, #20]
    cb52:	68e3      	ldr	r3, [r4, #12]
    cb54:	9304      	str	r3, [sp, #16]
    cb56:	2600      	movs	r6, #0
    cb58:	9603      	str	r6, [sp, #12]
			   TICKER_USER_ID_THREAD, TICKER_ID_SCAN_BASE,
			   ticks_anchor, 0, ticks_interval,
			   HAL_TICKER_REMAINDER((u64_t)lll->interval * 625U),
    cb5a:	f8b4 b042 	ldrh.w	fp, [r4, #66]	; 0x42
    cb5e:	2391      	movs	r3, #145	; 0x91
    cb60:	fbab 0108 	umull	r0, r1, fp, r8
    cb64:	fb03 110b 	mla	r1, r3, fp, r1
    cb68:	a317      	add	r3, pc, #92	; (adr r3, cbc8 <ull_scan_enable+0x138>)
    cb6a:	e9d3 2300 	ldrd	r2, r3, [r3]
    cb6e:	f7ff fbc7 	bl	c300 <__aeabi_uldivmod>
    cb72:	4610      	mov	r0, r2
    cb74:	4619      	mov	r1, r3
    cb76:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    cb7a:	2300      	movs	r3, #0
    cb7c:	f7ff fbc0 	bl	c300 <__aeabi_uldivmod>
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
    cb80:	462b      	mov	r3, r5
    cb82:	e9cd 7001 	strd	r7, r0, [sp, #4]
    cb86:	2204      	movs	r2, #4
    cb88:	2103      	movs	r1, #3
    cb8a:	9600      	str	r6, [sp, #0]
    cb8c:	4630      	mov	r0, r6
    cb8e:	f00f fa93 	bl	1c0b8 <ticker_start>
			   TICKER_NULL_LAZY,
			   (scan->evt.ticks_slot + ticks_slot_overhead),
			   ticker_cb, scan,
			   ull_ticker_status_give, (void *)&ret_cb);

	ret = ull_ticker_status_take(ret, &ret_cb);
    cb92:	4649      	mov	r1, r9
    cb94:	f011 fc5e 	bl	1e454 <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
    cb98:	4605      	mov	r5, r0
    cb9a:	b980      	cbnz	r0, cbbe <ull_scan_enable+0x12e>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	scan->is_enabled = 1U;
    cb9c:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
    cba0:	f043 0301 	orr.w	r3, r3, #1
    cba4:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48

#if defined(CONFIG_BT_CTLR_PRIVACY)
#if defined(CONFIG_BT_BROADCASTER)
	if (!ull_adv_is_enabled_get(0))
    cba8:	f012 fc00 	bl	1f3ac <ull_adv_is_enabled_get>
    cbac:	4604      	mov	r4, r0
    cbae:	b940      	cbnz	r0, cbc2 <ull_scan_enable+0x132>
#endif
	{
		ull_filter_adv_scan_state_cb(BIT(1));
    cbb0:	2002      	movs	r0, #2
    cbb2:	f016 ff0f 	bl	239d4 <ull_filter_adv_scan_state_cb>
	}
#endif

	return 0;
    cbb6:	4620      	mov	r0, r4
}
    cbb8:	b00e      	add	sp, #56	; 0x38
    cbba:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
    cbbe:	200c      	movs	r0, #12
    cbc0:	e7fa      	b.n	cbb8 <ull_scan_enable+0x128>
	return 0;
    cbc2:	4628      	mov	r0, r5
    cbc4:	e7f8      	b.n	cbb8 <ull_scan_enable+0x128>
    cbc6:	bf00      	nop
    cbc8:	1afd498d 	.word	0x1afd498d
    cbcc:	00000007 	.word	0x00000007
    cbd0:	84e72a00 	.word	0x84e72a00
    cbd4:	3b9aca00 	.word	0x3b9aca00
    cbd8:	0001e449 	.word	0x0001e449
    cbdc:	0001fb45 	.word	0x0001fb45

0000cbe0 <ll_scan_params_set>:
{
    cbe0:	b570      	push	{r4, r5, r6, lr}
    cbe2:	4605      	mov	r5, r0
	scan = ull_scan_is_disabled_get(0);
    cbe4:	2000      	movs	r0, #0
{
    cbe6:	461e      	mov	r6, r3
	scan = ull_scan_is_disabled_get(0);
    cbe8:	f013 f870 	bl	1fccc <ull_scan_is_disabled_get>
	if (!scan) {
    cbec:	4604      	mov	r4, r0
    cbee:	b300      	cbz	r0, cc32 <ll_scan_params_set+0x52>
	scan->own_addr_type = own_addr_type;
    cbf0:	f890 0048 	ldrb.w	r0, [r0, #72]	; 0x48
	lll->type = type;
    cbf4:	f894 3032 	ldrb.w	r3, [r4, #50]	; 0x32
	lll->interval = interval;
    cbf8:	f8a4 1042 	strh.w	r1, [r4, #66]	; 0x42
	scan->own_addr_type = own_addr_type;
    cbfc:	f366 0042 	bfi	r0, r6, #1, #2
    cc00:	f884 0048 	strb.w	r0, [r4, #72]	; 0x48
	lll->filter_policy = filter_policy;
    cc04:	f89d 0010 	ldrb.w	r0, [sp, #16]
	lll->type = type;
    cc08:	f365 13c7 	bfi	r3, r5, #7, #1
	lll->filter_policy = filter_policy;
    cc0c:	f360 03c4 	bfi	r3, r0, #3, #2
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
    cc10:	480b      	ldr	r0, [pc, #44]	; (cc40 <ll_scan_params_set+0x60>)
	lll->filter_policy = filter_policy;
    cc12:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
    cc16:	b295      	uxth	r5, r2
    cc18:	fba5 0100 	umull	r0, r1, r5, r0
    cc1c:	2391      	movs	r3, #145	; 0x91
    cc1e:	fb03 1105 	mla	r1, r3, r5, r1
    cc22:	a305      	add	r3, pc, #20	; (adr r3, cc38 <ll_scan_params_set+0x58>)
    cc24:	e9d3 2300 	ldrd	r2, r3, [r3]
    cc28:	f7ff fb6a 	bl	c300 <__aeabi_uldivmod>
    cc2c:	6460      	str	r0, [r4, #68]	; 0x44
	return 0;
    cc2e:	2000      	movs	r0, #0
}
    cc30:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
    cc32:	200c      	movs	r0, #12
    cc34:	e7fc      	b.n	cc30 <ll_scan_params_set+0x50>
    cc36:	bf00      	nop
    cc38:	1afd498d 	.word	0x1afd498d
    cc3c:	00000007 	.word	0x00000007
    cc40:	84e72a00 	.word	0x84e72a00
    cc44:	00000000 	.word	0x00000000

0000cc48 <isr_rx>:

	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
}

static void isr_rx(void *param)
{
    cc48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cc4c:	b085      	sub	sp, #20
    cc4e:	4604      	mov	r4, r0
	if (IS_ENABLED(CONFIG_BT_CTLR_PROFILE_ISR)) {
		lll_prof_latency_capture();
	}

	/* Read radio status and events */
	trx_done = radio_is_done();
    cc50:	f017 ff3a 	bl	24ac8 <radio_is_done>
    cc54:	b2c6      	uxtb	r6, r0
	if (trx_done) {
    cc56:	2e00      	cmp	r6, #0
    cc58:	d03a      	beq.n	ccd0 <isr_rx+0x88>
		crc_ok = radio_crc_is_valid();
    cc5a:	f017 ff4b 	bl	24af4 <radio_crc_is_valid>
    cc5e:	fa5f f980 	uxtb.w	r9, r0
		devmatch_ok = radio_filter_has_match();
    cc62:	f017 ffcf 	bl	24c04 <radio_filter_has_match>
    cc66:	fa5f f880 	uxtb.w	r8, r0
		devmatch_id = radio_filter_match_get();
    cc6a:	f017 ffd5 	bl	24c18 <radio_filter_match_get>
    cc6e:	fa5f fb80 	uxtb.w	fp, r0
		irkmatch_ok = radio_ar_has_match();
    cc72:	f018 f9b9 	bl	24fe8 <radio_ar_has_match>
    cc76:	fa5f fa80 	uxtb.w	sl, r0
		irkmatch_id = radio_ar_match_get();
    cc7a:	f018 f9a3 	bl	24fc4 <radio_ar_match_get>
    cc7e:	b2c7      	uxtb	r7, r0
		rssi_ready = radio_rssi_is_ready();
    cc80:	f017 ff88 	bl	24b94 <radio_rssi_is_ready>
    cc84:	b2c5      	uxtb	r5, r0
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready = 0U;
		devmatch_id = irkmatch_id = 0xFF;
	}

	/* Clear radio status and events */
	radio_status_reset();
    cc86:	f017 ff09 	bl	24a9c <radio_status_reset>
	radio_tmr_status_reset();
    cc8a:	f017 ffd7 	bl	24c3c <radio_tmr_status_reset>
	radio_filter_status_reset();
    cc8e:	f017 ffb1 	bl	24bf4 <radio_filter_status_reset>
	radio_ar_status_reset();
    cc92:	f018 f99d 	bl	24fd0 <radio_ar_status_reset>
	radio_rssi_status_reset();
    cc96:	f017 ff75 	bl	24b84 <radio_rssi_status_reset>
	if (IS_ENABLED(CONFIG_BT_CTLR_GPIO_PA_PIN) ||
	    IS_ENABLED(CONFIG_BT_CTLR_GPIO_LNA_PIN)) {
		radio_gpio_pa_lna_disable();
	}

	if (!trx_done) {
    cc9a:	2e00      	cmp	r6, #0
    cc9c:	d061      	beq.n	cd62 <isr_rx+0x11a>
		goto isr_rx_do_close;
	}

#if defined(CONFIG_BT_CTLR_PRIVACY)
	rl_idx = devmatch_ok ?
    cc9e:	f1b8 0f00 	cmp.w	r8, #0
    cca2:	d01c      	beq.n	ccde <isr_rx+0x96>
		 ull_filter_lll_rl_idx(!!(lll->filter_policy & 0x01),
    cca4:	7da0      	ldrb	r0, [r4, #22]
    cca6:	4659      	mov	r1, fp
    cca8:	f3c0 00c0 	ubfx	r0, r0, #3, #1
    ccac:	f017 fb10 	bl	242d0 <ull_filter_lll_rl_idx>
				       devmatch_id) :
		 irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
    ccb0:	4607      	mov	r7, r0
			       FILTER_IDX_NONE;
#else
	rl_idx = FILTER_IDX_NONE;
#endif
	if (crc_ok && isr_rx_scan_check(lll, irkmatch_ok, devmatch_ok,
    ccb2:	f1b9 0f00 	cmp.w	r9, #0
    ccb6:	d054      	beq.n	cd62 <isr_rx+0x11a>

static inline bool isr_rx_scan_check(struct lll_scan *lll, u8_t irkmatch_ok,
				     u8_t devmatch_ok, u8_t rl_idx)
{
#if defined(CONFIG_BT_CTLR_PRIVACY)
	return (((lll->filter_policy & 0x01) == 0) &&
    ccb8:	7da3      	ldrb	r3, [r4, #22]
		 (!devmatch_ok || ull_filter_lll_rl_idx_allowed(irkmatch_ok,
								rl_idx))) ||
    ccba:	071e      	lsls	r6, r3, #28
    ccbc:	d518      	bpl.n	ccf0 <isr_rx+0xa8>
		(((lll->filter_policy & 0x01) != 0) &&
    ccbe:	f1b8 0f00 	cmp.w	r8, #0
    ccc2:	d118      	bne.n	ccf6 <isr_rx+0xae>
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(rl_idx)));
    ccc4:	4638      	mov	r0, r7
    ccc6:	f017 fb85 	bl	243d4 <ull_filter_lll_irk_whitelisted>
	if (crc_ok && isr_rx_scan_check(lll, irkmatch_ok, devmatch_ok,
    ccca:	2800      	cmp	r0, #0
    cccc:	d049      	beq.n	cd62 <isr_rx+0x11a>
    ccce:	e012      	b.n	ccf6 <isr_rx+0xae>
		devmatch_id = irkmatch_id = 0xFF;
    ccd0:	27ff      	movs	r7, #255	; 0xff
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready = 0U;
    ccd2:	4635      	mov	r5, r6
    ccd4:	46b2      	mov	sl, r6
    ccd6:	46b0      	mov	r8, r6
    ccd8:	46b1      	mov	r9, r6
		devmatch_id = irkmatch_id = 0xFF;
    ccda:	46bb      	mov	fp, r7
    ccdc:	e7d3      	b.n	cc86 <isr_rx+0x3e>
	rl_idx = devmatch_ok ?
    ccde:	f1ba 0f00 	cmp.w	sl, #0
    cce2:	d003      	beq.n	ccec <isr_rx+0xa4>
		 irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
    cce4:	4638      	mov	r0, r7
    cce6:	f017 fb3b 	bl	24360 <ull_filter_lll_rl_irk_idx>
    ccea:	e7e1      	b.n	ccb0 <isr_rx+0x68>
	rl_idx = devmatch_ok ?
    ccec:	27ff      	movs	r7, #255	; 0xff
    ccee:	e7e0      	b.n	ccb2 <isr_rx+0x6a>
	return (((lll->filter_policy & 0x01) == 0) &&
    ccf0:	f1b8 0f00 	cmp.w	r8, #0
    ccf4:	d12c      	bne.n	cd50 <isr_rx+0x108>
			       u8_t devmatch_id, u8_t irkmatch_ok,
			       u8_t irkmatch_id, u8_t rl_idx, u8_t rssi_ready)
{
	struct node_rx_pdu *node_rx;
	struct pdu_adv *pdu_adv_rx;
	bool dir_report = false;
    ccf6:	2300      	movs	r3, #0

	node_rx = ull_pdu_rx_alloc_peek(1);
    ccf8:	2001      	movs	r0, #1
	bool dir_report = false;
    ccfa:	f88d 300f 	strb.w	r3, [sp, #15]
	node_rx = ull_pdu_rx_alloc_peek(1);
    ccfe:	f011 fc1d 	bl	1e53c <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
    cd02:	4606      	mov	r6, r0
    cd04:	b940      	cbnz	r0, cd18 <isr_rx+0xd0>
    cd06:	48ae      	ldr	r0, [pc, #696]	; (cfc0 <isr_rx+0x378>)
    cd08:	f01b fa1c 	bl	28144 <printk>
    cd0c:	4040      	eors	r0, r0
    cd0e:	f380 8811 	msr	BASEPRI, r0
    cd12:	f04f 0003 	mov.w	r0, #3
    cd16:	df02      	svc	2
	pdu_adv_rx = (void *)node_rx->pdu;

	if (0) {
#if defined(CONFIG_BT_CENTRAL)
	/* Initiator */
	} else if ((lll->conn) &&
    cd18:	68a3      	ldr	r3, [r4, #8]
	pdu_adv_rx = (void *)node_rx->pdu;
    cd1a:	f106 0820 	add.w	r8, r6, #32
	} else if ((lll->conn) &&
    cd1e:	b37b      	cbz	r3, cd80 <isr_rx+0x138>
}

static inline bool isr_scan_init_check(struct lll_scan *lll,
				       struct pdu_adv *pdu, u8_t rl_idx)
{
	return ((((lll->filter_policy & 0x01) != 0U) ||
    cd20:	7da3      	ldrb	r3, [r4, #22]
		 isr_scan_init_adva_check(lll, pdu, rl_idx)) &&
    cd22:	f3c3 00c0 	ubfx	r0, r3, #3, #1
    cd26:	b318      	cbz	r0, cd70 <isr_rx+0x128>
		(((pdu->type == PDU_ADV_TYPE_ADV_IND) &&
    cd28:	f896 1020 	ldrb.w	r1, [r6, #32]
		 isr_scan_init_adva_check(lll, pdu, rl_idx)) &&
    cd2c:	f011 010f 	ands.w	r1, r1, #15
    cd30:	f000 80a7 	beq.w	ce82 <isr_rx+0x23a>
		  (pdu->len <= sizeof(struct pdu_adv_adv_ind))) ||
    cd34:	2901      	cmp	r1, #1
    cd36:	d123      	bne.n	cd80 <isr_rx+0x138>
		 ((pdu->type == PDU_ADV_TYPE_DIRECT_IND) &&
    cd38:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
    cd3c:	2b0c      	cmp	r3, #12
    cd3e:	d11f      	bne.n	cd80 <isr_rx+0x138>
		  (pdu->len == sizeof(struct pdu_adv_direct_ind)) &&
		  (/* allow directed adv packets addressed to this device */
		   isr_scan_tgta_check(lll, true, pdu, rl_idx, NULL)))));
    cd40:	2300      	movs	r3, #0
    cd42:	9300      	str	r3, [sp, #0]
    cd44:	4642      	mov	r2, r8
    cd46:	463b      	mov	r3, r7
    cd48:	4620      	mov	r0, r4
    cd4a:	f01f f9dd 	bl	2c108 <isr_scan_tgta_check>
    cd4e:	e09e      	b.n	ce8e <isr_rx+0x246>
		 (!devmatch_ok || ull_filter_lll_rl_idx_allowed(irkmatch_ok,
    cd50:	4639      	mov	r1, r7
    cd52:	4650      	mov	r0, sl
    cd54:	f017 fb6a 	bl	2442c <ull_filter_lll_rl_idx_allowed>
    cd58:	2800      	cmp	r0, #0
    cd5a:	d1cc      	bne.n	ccf6 <isr_rx+0xae>
		(((lll->filter_policy & 0x01) != 0) &&
    cd5c:	7da3      	ldrb	r3, [r4, #22]
								rl_idx))) ||
    cd5e:	0718      	lsls	r0, r3, #28
    cd60:	d4c9      	bmi.n	ccf6 <isr_rx+0xae>
	radio_isr_set(isr_done, lll);
    cd62:	4621      	mov	r1, r4
    cd64:	4897      	ldr	r0, [pc, #604]	; (cfc4 <isr_rx+0x37c>)
    cd66:	f017 fd93 	bl	24890 <radio_isr_set>
	radio_disable();
    cd6a:	f017 fe85 	bl	24a78 <radio_disable>
    cd6e:	e1b1      	b.n	d0d4 <isr_rx+0x48c>
static inline bool isr_scan_init_adva_check(struct lll_scan *lll,
					    struct pdu_adv *pdu, u8_t rl_idx)
{
#if defined(CONFIG_BT_CTLR_PRIVACY)
	/* Only applies to initiator with no whitelist */
	if (rl_idx != FILTER_IDX_NONE) {
    cd70:	2fff      	cmp	r7, #255	; 0xff
    cd72:	d073      	beq.n	ce5c <isr_rx+0x214>
		return (rl_idx == lll->rl_idx);
    cd74:	7e20      	ldrb	r0, [r4, #24]
    cd76:	1bc1      	subs	r1, r0, r7
    cd78:	4248      	negs	r0, r1
    cd7a:	4148      	adcs	r0, r1
	return ((((lll->filter_policy & 0x01) != 0U) ||
    cd7c:	2800      	cmp	r0, #0
    cd7e:	d1d3      	bne.n	cd28 <isr_rx+0xe0>
	} else if (((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
    cd80:	f896 1020 	ldrb.w	r1, [r6, #32]
    cd84:	f011 030f 	ands.w	r3, r1, #15
    cd88:	d002      	beq.n	cd90 <isr_rx+0x148>
    cd8a:	2b06      	cmp	r3, #6
    cd8c:	f040 8203 	bne.w	d196 <isr_rx+0x54e>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
    cd90:	f896 2021 	ldrb.w	r2, [r6, #33]	; 0x21
    cd94:	2a25      	cmp	r2, #37	; 0x25
    cd96:	f200 81ac 	bhi.w	d0f2 <isr_rx+0x4aa>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind)) &&
    cd9a:	f994 2016 	ldrsb.w	r2, [r4, #22]
    cd9e:	2a00      	cmp	r2, #0
    cda0:	f280 81a7 	bge.w	d0f2 <isr_rx+0x4aa>
		   lll->type &&
    cda4:	68a2      	ldr	r2, [r4, #8]
    cda6:	2a00      	cmp	r2, #0
    cda8:	f040 81a3 	bne.w	d0f2 <isr_rx+0x4aa>
		err = isr_rx_scan_report(lll, rssi_ready,
    cdac:	f1ba 0f00 	cmp.w	sl, #0
    cdb0:	bf14      	ite	ne
    cdb2:	4639      	movne	r1, r7
    cdb4:	21ff      	moveq	r1, #255	; 0xff
    cdb6:	4628      	mov	r0, r5
    cdb8:	f01f fa29 	bl	2c20e <isr_rx_scan_report.isra.4>
		if (err) {
    cdbc:	2800      	cmp	r0, #0
    cdbe:	d1d0      	bne.n	cd62 <isr_rx+0x11a>
		pdu_tx = (void *)radio_pkt_scratch_get();
    cdc0:	f017 fea6 	bl	24b10 <radio_pkt_scratch_get>
		pdu_tx->type = PDU_ADV_TYPE_SCAN_REQ;
    cdc4:	7803      	ldrb	r3, [r0, #0]
    cdc6:	2203      	movs	r2, #3
    cdc8:	f362 0303 	bfi	r3, r2, #0, #4
    cdcc:	7003      	strb	r3, [r0, #0]
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
    cdce:	f896 3020 	ldrb.w	r3, [r6, #32]
    cdd2:	7802      	ldrb	r2, [r0, #0]
    cdd4:	f3c3 1380 	ubfx	r3, r3, #6, #1
    cdd8:	f363 12c7 	bfi	r2, r3, #7, #1
		pdu_tx->len = sizeof(struct pdu_adv_scan_req);
    cddc:	230c      	movs	r3, #12
    cdde:	7043      	strb	r3, [r0, #1]
		pdu_tx = (void *)radio_pkt_scratch_get();
    cde0:	4605      	mov	r5, r0
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
    cde2:	7002      	strb	r2, [r0, #0]
		lrpa = ull_filter_lll_lrpa_get(rl_idx);
    cde4:	4638      	mov	r0, r7
    cde6:	f017 fa55 	bl	24294 <ull_filter_lll_lrpa_get>
		if (lll->rpa_gen && lrpa) {
    cdea:	7de3      	ldrb	r3, [r4, #23]
		lrpa = ull_filter_lll_lrpa_get(rl_idx);
    cdec:	4601      	mov	r1, r0
		if (lll->rpa_gen && lrpa) {
    cdee:	4628      	mov	r0, r5
    cdf0:	f013 0f01 	tst.w	r3, #1
    cdf4:	f810 3b02 	ldrb.w	r3, [r0], #2
    cdf8:	f000 8171 	beq.w	d0de <isr_rx+0x496>
    cdfc:	2900      	cmp	r1, #0
    cdfe:	f000 816e 	beq.w	d0de <isr_rx+0x496>
			pdu_tx->tx_addr = 1;
    ce02:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    ce06:	702b      	strb	r3, [r5, #0]
			memcpy(&pdu_tx->scan_req.scan_addr[0], lrpa->val,
    ce08:	2206      	movs	r2, #6
			memcpy(&pdu_tx->scan_req.scan_addr[0],
    ce0a:	f01d fb20 	bl	2a44e <memcpy>
		memcpy(&pdu_tx->scan_req.adv_addr[0],
    ce0e:	2206      	movs	r2, #6
    ce10:	f106 0122 	add.w	r1, r6, #34	; 0x22
    ce14:	f105 0008 	add.w	r0, r5, #8
    ce18:	f01d fb19 	bl	2a44e <memcpy>
		lll->state = 1U;
    ce1c:	7da3      	ldrb	r3, [r4, #22]
		radio_isr_set(isr_tx, lll);
    ce1e:	486a      	ldr	r0, [pc, #424]	; (cfc8 <isr_rx+0x380>)
		lll->state = 1U;
    ce20:	f043 0301 	orr.w	r3, r3, #1
    ce24:	75a3      	strb	r3, [r4, #22]
		radio_isr_set(isr_tx, lll);
    ce26:	4621      	mov	r1, r4
    ce28:	f017 fd32 	bl	24890 <radio_isr_set>
		radio_tmr_tifs_set(EVENT_IFS_US);
    ce2c:	2096      	movs	r0, #150	; 0x96
    ce2e:	f017 ff15 	bl	24c5c <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
    ce32:	2000      	movs	r0, #0
    ce34:	f017 fe70 	bl	24b18 <radio_switch_complete_and_rx>
		radio_pkt_tx_set(pdu_tx);
    ce38:	4628      	mov	r0, r5
    ce3a:	f017 fe0b 	bl	24a54 <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
    ce3e:	f017 fe39 	bl	24ab4 <radio_is_ready>
    ce42:	b140      	cbz	r0, ce56 <isr_rx+0x20e>
    ce44:	4861      	ldr	r0, [pc, #388]	; (cfcc <isr_rx+0x384>)
    ce46:	f01b f97d 	bl	28144 <printk>
    ce4a:	4040      	eors	r0, r0
    ce4c:	f380 8811 	msr	BASEPRI, r0
    ce50:	f04f 0003 	mov.w	r0, #3
    ce54:	df02      	svc	2
		radio_tmr_end_capture();
    ce56:	f017 ffd9 	bl	24e0c <radio_tmr_end_capture>
		if (!err) {
    ce5a:	e13b      	b.n	d0d4 <isr_rx+0x48c>
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */
	return ((lll->adv_addr_type == pdu->tx_addr) &&
    ce5c:	f896 2020 	ldrb.w	r2, [r6, #32]
    ce60:	f3c3 1340 	ubfx	r3, r3, #5, #1
    ce64:	f3c2 1280 	ubfx	r2, r2, #6, #1
    ce68:	4293      	cmp	r3, r2
    ce6a:	d187      	bne.n	cd7c <isr_rx+0x134>
		!memcmp(lll->adv_addr, &pdu->adv_ind.addr[0], BDADDR_SIZE));
    ce6c:	2206      	movs	r2, #6
    ce6e:	f106 0122 	add.w	r1, r6, #34	; 0x22
    ce72:	f104 001f 	add.w	r0, r4, #31
    ce76:	f01d fac3 	bl	2a400 <memcmp>
	return ((lll->adv_addr_type == pdu->tx_addr) &&
    ce7a:	fab0 f080 	clz	r0, r0
    ce7e:	0940      	lsrs	r0, r0, #5
    ce80:	e77c      	b.n	cd7c <isr_rx+0x134>
		(((pdu->type == PDU_ADV_TYPE_ADV_IND) &&
    ce82:	f896 0021 	ldrb.w	r0, [r6, #33]	; 0x21
    ce86:	2825      	cmp	r0, #37	; 0x25
    ce88:	bf8c      	ite	hi
    ce8a:	2000      	movhi	r0, #0
    ce8c:	2001      	movls	r0, #1
	} else if ((lll->conn) &&
    ce8e:	2800      	cmp	r0, #0
    ce90:	f43f af76 	beq.w	cd80 <isr_rx+0x138>
			rx = ull_pdu_rx_alloc_peek(4);
    ce94:	2004      	movs	r0, #4
    ce96:	f011 fb51 	bl	1e53c <ull_pdu_rx_alloc_peek>
		if (!rx) {
    ce9a:	2800      	cmp	r0, #0
    ce9c:	f43f af61 	beq.w	cd62 <isr_rx+0x11a>
		pdu_end_us = radio_tmr_end_get();
    cea0:	f017 ffbc 	bl	24e1c <radio_tmr_end_get>
		if (!lll->ticks_window) {
    cea4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		pdu_end_us = radio_tmr_end_get();
    cea6:	4605      	mov	r5, r0
		if (!lll->ticks_window) {
    cea8:	b93b      	cbnz	r3, ceba <isr_rx+0x272>
			scan_interval_us = lll->interval * 625U;
    ceaa:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
    ceac:	f240 2371 	movw	r3, #625	; 0x271
    ceb0:	4353      	muls	r3, r2
			pdu_end_us %= scan_interval_us;
    ceb2:	fbb0 f2f3 	udiv	r2, r0, r3
    ceb6:	fb03 0512 	mls	r5, r3, r2, r0
		if (pdu_end_us > (HAL_TICKER_TICKS_TO_US(evt->ticks_slot) -
    ceba:	6823      	ldr	r3, [r4, #0]
    cebc:	4844      	ldr	r0, [pc, #272]	; (cfd0 <isr_rx+0x388>)
    cebe:	68db      	ldr	r3, [r3, #12]
    cec0:	2207      	movs	r2, #7
    cec2:	fba3 0100 	umull	r0, r1, r3, r0
    cec6:	fb02 1103 	mla	r1, r2, r3, r1
    ceca:	a33b      	add	r3, pc, #236	; (adr r3, cfb8 <isr_rx+0x370>)
    cecc:	e9d3 2300 	ldrd	r2, r3, [r3]
    ced0:	f7ff fa16 	bl	c300 <__aeabi_uldivmod>
				  502 - EVENT_OVERHEAD_START_US -
    ced4:	f2a0 3042 	subw	r0, r0, #834	; 0x342
		if (pdu_end_us > (HAL_TICKER_TICKS_TO_US(evt->ticks_slot) -
    ced8:	42a8      	cmp	r0, r5
    ceda:	f4ff af42 	bcc.w	cd62 <isr_rx+0x11a>
		radio_isr_set(isr_cleanup, lll);
    cede:	4621      	mov	r1, r4
    cee0:	483c      	ldr	r0, [pc, #240]	; (cfd4 <isr_rx+0x38c>)
    cee2:	f017 fcd5 	bl	24890 <radio_isr_set>
		radio_switch_complete_and_disable();
    cee6:	f017 fe2f 	bl	24b48 <radio_switch_complete_and_disable>
		lll_conn = lll->conn;
    ceea:	f8d4 8008 	ldr.w	r8, [r4, #8]
		pdu_tx = (void *)radio_pkt_scratch_get();
    ceee:	f017 fe0f 	bl	24b10 <radio_pkt_scratch_get>
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
    cef2:	f896 2020 	ldrb.w	r2, [r6, #32]
    cef6:	7803      	ldrb	r3, [r0, #0]
    cef8:	f3c2 1280 	ubfx	r2, r2, #6, #1
    cefc:	f362 13c7 	bfi	r3, r2, #7, #1
		pdu_tx->type = PDU_ADV_TYPE_CONNECT_IND;
    cf00:	f003 03d0 	and.w	r3, r3, #208	; 0xd0
    cf04:	f043 0325 	orr.w	r3, r3, #37	; 0x25
    cf08:	7003      	strb	r3, [r0, #0]
		pdu_tx->len = sizeof(struct pdu_adv_connect_ind);
    cf0a:	2322      	movs	r3, #34	; 0x22
    cf0c:	7043      	strb	r3, [r0, #1]
		pdu_tx = (void *)radio_pkt_scratch_get();
    cf0e:	4605      	mov	r5, r0
		lrpa = ull_filter_lll_lrpa_get(rl_idx);
    cf10:	4638      	mov	r0, r7
    cf12:	f017 f9bf 	bl	24294 <ull_filter_lll_lrpa_get>
		if (lll->rpa_gen && lrpa) {
    cf16:	7de3      	ldrb	r3, [r4, #23]
		lrpa = ull_filter_lll_lrpa_get(rl_idx);
    cf18:	4601      	mov	r1, r0
		if (lll->rpa_gen && lrpa) {
    cf1a:	4628      	mov	r0, r5
    cf1c:	f013 0f01 	tst.w	r3, #1
    cf20:	f810 3b02 	ldrb.w	r3, [r0], #2
    cf24:	d03e      	beq.n	cfa4 <isr_rx+0x35c>
    cf26:	b3e9      	cbz	r1, cfa4 <isr_rx+0x35c>
			pdu_tx->tx_addr = 1;
    cf28:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    cf2c:	702b      	strb	r3, [r5, #0]
			memcpy(&pdu_tx->connect_ind.init_addr[0], lrpa->val,
    cf2e:	2206      	movs	r2, #6
			memcpy(&pdu_tx->connect_ind.init_addr[0],
    cf30:	f01d fa8d 	bl	2a44e <memcpy>
		memcpy(&pdu_tx->connect_ind.adv_addr[0],
    cf34:	2206      	movs	r2, #6
    cf36:	f106 0122 	add.w	r1, r6, #34	; 0x22
    cf3a:	f105 0008 	add.w	r0, r5, #8
    cf3e:	f01d fa86 	bl	2a44e <memcpy>
		memcpy(&pdu_tx->connect_ind.access_addr[0],
    cf42:	2204      	movs	r2, #4
    cf44:	f108 0108 	add.w	r1, r8, #8
    cf48:	f105 000e 	add.w	r0, r5, #14
    cf4c:	f01d fa7f 	bl	2a44e <memcpy>
		memcpy(&pdu_tx->connect_ind.crc_init[0],
    cf50:	2203      	movs	r2, #3
    cf52:	f108 010c 	add.w	r1, r8, #12
    cf56:	f105 0012 	add.w	r0, r5, #18
    cf5a:	f01d fa78 	bl	2a44e <memcpy>
		pdu_tx->connect_ind.win_size = 1;
    cf5e:	2301      	movs	r3, #1
    cf60:	756b      	strb	r3, [r5, #21]
		conn_interval_us = (u32_t)lll_conn->interval * 1250U;
    cf62:	f8b8 b012 	ldrh.w	fp, [r8, #18]
		conn_offset_us = radio_tmr_end_get() + 502 + 1250;
    cf66:	f017 ff59 	bl	24e1c <radio_tmr_end_get>
		    lll->conn_win_offset_us == 0U) {
    cf6a:	f8d4 9010 	ldr.w	r9, [r4, #16]
		conn_offset_us = radio_tmr_end_get() + 502 + 1250;
    cf6e:	f500 60db 	add.w	r0, r0, #1752	; 0x6d8
		if (!IS_ENABLED(CONFIG_BT_CTLR_SCHED_ADVANCED) ||
    cf72:	f1b9 0f00 	cmp.w	r9, #0
    cf76:	d02f      	beq.n	cfd8 <isr_rx+0x390>
		conn_interval_us = (u32_t)lll_conn->interval * 1250U;
    cf78:	f240 43e2 	movw	r3, #1250	; 0x4e2
    cf7c:	fb03 f30b 	mul.w	r3, r3, fp
			while ((conn_space_us & ((u32_t)1 << 31)) ||
    cf80:	f1b9 0f00 	cmp.w	r9, #0
    cf84:	f2c0 80a9 	blt.w	d0da <isr_rx+0x492>
    cf88:	4548      	cmp	r0, r9
    cf8a:	f200 80a6 	bhi.w	d0da <isr_rx+0x492>
			pdu_tx->connect_ind.win_offset =
    cf8e:	f240 43e2 	movw	r3, #1250	; 0x4e2
				sys_cpu_to_le16((conn_space_us -
    cf92:	eba9 0000 	sub.w	r0, r9, r0
			pdu_tx->connect_ind.win_offset =
    cf96:	fbb0 f0f3 	udiv	r0, r0, r3
			pdu_tx->connect_ind.win_size++;
    cf9a:	7d6b      	ldrb	r3, [r5, #21]
			pdu_tx->connect_ind.win_offset =
    cf9c:	82e8      	strh	r0, [r5, #22]
			pdu_tx->connect_ind.win_size++;
    cf9e:	3301      	adds	r3, #1
    cfa0:	756b      	strb	r3, [r5, #21]
    cfa2:	e01e      	b.n	cfe2 <isr_rx+0x39a>
			pdu_tx->tx_addr = lll->init_addr_type;
    cfa4:	7da2      	ldrb	r2, [r4, #22]
    cfa6:	f3c2 1280 	ubfx	r2, r2, #6, #1
    cfaa:	f362 1386 	bfi	r3, r2, #6, #1
    cfae:	702b      	strb	r3, [r5, #0]
			memcpy(&pdu_tx->connect_ind.init_addr[0],
    cfb0:	2206      	movs	r2, #6
    cfb2:	f104 0119 	add.w	r1, r4, #25
    cfb6:	e7bb      	b.n	cf30 <isr_rx+0x2e8>
    cfb8:	3b9aca00 	.word	0x3b9aca00
    cfbc:	00000000 	.word	0x00000000
    cfc0:	00031bc6 	.word	0x00031bc6
    cfc4:	0002c0f7 	.word	0x0002c0f7
    cfc8:	0001ff41 	.word	0x0001ff41
    cfcc:	00031b62 	.word	0x00031b62
    cfd0:	1afd498d 	.word	0x1afd498d
    cfd4:	000200c9 	.word	0x000200c9
			pdu_tx->connect_ind.win_offset = sys_cpu_to_le16(0);
    cfd8:	f885 9016 	strb.w	r9, [r5, #22]
    cfdc:	f885 9017 	strb.w	r9, [r5, #23]
		conn_offset_us = radio_tmr_end_get() + 502 + 1250;
    cfe0:	4681      	mov	r9, r0
		pdu_tx->connect_ind.interval =
    cfe2:	f8b8 3012 	ldrh.w	r3, [r8, #18]
    cfe6:	832b      	strh	r3, [r5, #24]
		pdu_tx->connect_ind.latency =
    cfe8:	f8b8 3014 	ldrh.w	r3, [r8, #20]
    cfec:	836b      	strh	r3, [r5, #26]
		pdu_tx->connect_ind.timeout =
    cfee:	8aa3      	ldrh	r3, [r4, #20]
    cff0:	83ab      	strh	r3, [r5, #28]
		memcpy(&pdu_tx->connect_ind.chan_map[0],
    cff2:	f108 011c 	add.w	r1, r8, #28
    cff6:	2205      	movs	r2, #5
    cff8:	f105 001e 	add.w	r0, r5, #30
    cffc:	f01d fa27 	bl	2a44e <memcpy>
		pdu_tx->connect_ind.hop = lll_conn->data_chan_hop;
    d000:	f898 2022 	ldrb.w	r2, [r8, #34]	; 0x22
    d004:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
    d008:	f362 0304 	bfi	r3, r2, #0, #5
    d00c:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
		pdu_tx->connect_ind.sca = lll_conn_sca_local_get();
    d010:	f01f fb8b 	bl	2c72a <lll_conn_sca_local_get>
    d014:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
    d018:	f360 1347 	bfi	r3, r0, #5, #3
    d01c:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
		radio_pkt_tx_set(pdu_tx);
    d020:	4628      	mov	r0, r5
    d022:	f017 fd17 	bl	24a54 <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
    d026:	f017 fd45 	bl	24ab4 <radio_is_ready>
    d02a:	b140      	cbz	r0, d03e <isr_rx+0x3f6>
    d02c:	485b      	ldr	r0, [pc, #364]	; (d19c <isr_rx+0x554>)
    d02e:	f01b f889 	bl	28144 <printk>
    d032:	4040      	eors	r0, r0
    d034:	f380 8811 	msr	BASEPRI, r0
    d038:	f04f 0003 	mov.w	r0, #3
    d03c:	df02      	svc	2
}

static inline int lll_stop(void *lll)
{
	struct lll_hdr *hdr = lll;
	int ret = !!hdr->is_stop;
    d03e:	7923      	ldrb	r3, [r4, #4]

	hdr->is_stop = 1U;
    d040:	f043 0201 	orr.w	r2, r3, #1
    d044:	7122      	strb	r2, [r4, #4]
		LL_ASSERT(!ret);
    d046:	07da      	lsls	r2, r3, #31
    d048:	d508      	bpl.n	d05c <isr_rx+0x414>
    d04a:	4855      	ldr	r0, [pc, #340]	; (d1a0 <isr_rx+0x558>)
    d04c:	f01b f87a 	bl	28144 <printk>
    d050:	4040      	eors	r0, r0
    d052:	f380 8811 	msr	BASEPRI, r0
    d056:	f04f 0003 	mov.w	r0, #3
    d05a:	df02      	svc	2
		rx = ull_pdu_rx_alloc();
    d05c:	f011 fa86 	bl	1e56c <ull_pdu_rx_alloc>
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
    d060:	2308      	movs	r3, #8
		rx = ull_pdu_rx_alloc();
    d062:	4680      	mov	r8, r0
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
    d064:	7103      	strb	r3, [r0, #4]
		rx->hdr.handle = 0xffff;
    d066:	f64f 73ff 	movw	r3, #65535	; 0xffff
		memcpy(rx->pdu, pdu_tx, (offsetof(struct pdu_adv, connect_ind) +
    d06a:	2224      	movs	r2, #36	; 0x24
		rx->hdr.handle = 0xffff;
    d06c:	80c3      	strh	r3, [r0, #6]
		memcpy(rx->pdu, pdu_tx, (offsetof(struct pdu_adv, connect_ind) +
    d06e:	4629      	mov	r1, r5
		u8_t pdu_adv_rx_chan_sel = pdu_adv_rx->chan_sel;
    d070:	f896 6020 	ldrb.w	r6, [r6, #32]
		memcpy(rx->pdu, pdu_tx, (offsetof(struct pdu_adv, connect_ind) +
    d074:	3020      	adds	r0, #32
    d076:	f01d f9ea 	bl	2a44e <memcpy>
		pdu_adv_rx->chan_sel = pdu_adv_rx_chan_sel;
    d07a:	f898 3020 	ldrb.w	r3, [r8, #32]
		ftr->param = lll;
    d07e:	f8c8 4008 	str.w	r4, [r8, #8]
		u8_t pdu_adv_rx_chan_sel = pdu_adv_rx->chan_sel;
    d082:	f3c6 1640 	ubfx	r6, r6, #5, #1
		pdu_adv_rx->chan_sel = pdu_adv_rx_chan_sel;
    d086:	f366 1345 	bfi	r3, r6, #5, #1
    d08a:	f888 3020 	strb.w	r3, [r8, #32]
		ftr->ticks_anchor = radio_tmr_start_get();
    d08e:	f017 fe73 	bl	24d78 <radio_tmr_start_get>
				    radio_tx_chain_delay_get(0, 0);
    d092:	2100      	movs	r1, #0
		ftr->ticks_anchor = radio_tmr_start_get();
    d094:	f8c8 0010 	str.w	r0, [r8, #16]
				    radio_tx_chain_delay_get(0, 0);
    d098:	4608      	mov	r0, r1
    d09a:	f01f fd09 	bl	2cab0 <radio_tx_chain_delay_get>
		ftr->us_radio_rdy = radio_tx_ready_delay_get(0, 0);
    d09e:	2100      	movs	r1, #0
		ftr->us_radio_end = conn_space_us -
    d0a0:	eba9 0000 	sub.w	r0, r9, r0
    d0a4:	f8c8 0014 	str.w	r0, [r8, #20]
		ftr->us_radio_rdy = radio_tx_ready_delay_get(0, 0);
    d0a8:	4608      	mov	r0, r1
    d0aa:	f01f fcf8 	bl	2ca9e <radio_tx_ready_delay_get>
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
    d0ae:	f1ba 0f00 	cmp.w	sl, #0
    d0b2:	bf08      	it	eq
    d0b4:	27ff      	moveq	r7, #255	; 0xff
		ftr->us_radio_rdy = radio_tx_ready_delay_get(0, 0);
    d0b6:	f8c8 0018 	str.w	r0, [r8, #24]
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
    d0ba:	f888 701d 	strb.w	r7, [r8, #29]
			ftr->extra = ull_pdu_rx_alloc();
    d0be:	f011 fa55 	bl	1e56c <ull_pdu_rx_alloc>
		ull_rx_put(rx->hdr.link, rx);
    d0c2:	4641      	mov	r1, r8
			ftr->extra = ull_pdu_rx_alloc();
    d0c4:	f8c8 000c 	str.w	r0, [r8, #12]
		ull_rx_put(rx->hdr.link, rx);
    d0c8:	f8d8 0000 	ldr.w	r0, [r8]
    d0cc:	f011 fa64 	bl	1e598 <ull_rx_put>
		ull_rx_sched();
    d0d0:	f011 fa72 	bl	1e5b8 <ull_rx_sched>
}
    d0d4:	b005      	add	sp, #20
    d0d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				conn_space_us += conn_interval_us;
    d0da:	4499      	add	r9, r3
    d0dc:	e750      	b.n	cf80 <isr_rx+0x338>
			pdu_tx->tx_addr = lll->init_addr_type;
    d0de:	7da2      	ldrb	r2, [r4, #22]
    d0e0:	f3c2 1280 	ubfx	r2, r2, #6, #1
    d0e4:	f362 1386 	bfi	r3, r2, #6, #1
    d0e8:	702b      	strb	r3, [r5, #0]
			memcpy(&pdu_tx->scan_req.scan_addr[0],
    d0ea:	2206      	movs	r2, #6
    d0ec:	f104 0119 	add.w	r1, r4, #25
    d0f0:	e68b      	b.n	ce0a <isr_rx+0x1c2>
	else if (((((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
    d0f2:	f011 0f0d 	tst.w	r1, #13
    d0f6:	d001      	beq.n	d0fc <isr_rx+0x4b4>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_NONCONN_IND) ||
    d0f8:	2b06      	cmp	r3, #6
    d0fa:	d103      	bne.n	d104 <isr_rx+0x4bc>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
    d0fc:	f896 2021 	ldrb.w	r2, [r6, #33]	; 0x21
    d100:	2a25      	cmp	r2, #37	; 0x25
    d102:	d934      	bls.n	d16e <isr_rx+0x526>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind))) ||
    d104:	2b01      	cmp	r3, #1
    d106:	d022      	beq.n	d14e <isr_rx+0x506>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_RSP) &&
    d108:	f896 3020 	ldrb.w	r3, [r6, #32]
					&dir_report))) ||
    d10c:	f003 030f 	and.w	r3, r3, #15
    d110:	2b04      	cmp	r3, #4
    d112:	f47f ae26 	bne.w	cd62 <isr_rx+0x11a>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_RSP) &&
    d116:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
    d11a:	2b25      	cmp	r3, #37	; 0x25
    d11c:	f63f ae21 	bhi.w	cd62 <isr_rx+0x11a>
		   (lll->state != 0U) &&
    d120:	7da3      	ldrb	r3, [r4, #22]
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_scan_rsp)) &&
    d122:	07db      	lsls	r3, r3, #31
    d124:	f57f ae1d 	bpl.w	cd62 <isr_rx+0x11a>
	return false;
}

static inline bool isr_scan_rsp_adva_matches(struct pdu_adv *srsp)
{
	struct pdu_adv *sreq = (void *)radio_pkt_scratch_get();
    d128:	f017 fcf2 	bl	24b10 <radio_pkt_scratch_get>

	return ((sreq->rx_addr == srsp->tx_addr) &&
    d12c:	f896 3020 	ldrb.w	r3, [r6, #32]
    d130:	7802      	ldrb	r2, [r0, #0]
    d132:	f3c3 1380 	ubfx	r3, r3, #6, #1
    d136:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
    d13a:	f47f ae12 	bne.w	cd62 <isr_rx+0x11a>
		(memcmp(&sreq->scan_req.adv_addr[0],
    d13e:	2206      	movs	r2, #6
    d140:	f106 0122 	add.w	r1, r6, #34	; 0x22
    d144:	3008      	adds	r0, #8
    d146:	f01d f95b 	bl	2a400 <memcmp>
		   (lll->state != 0U) &&
    d14a:	b180      	cbz	r0, d16e <isr_rx+0x526>
    d14c:	e609      	b.n	cd62 <isr_rx+0x11a>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_DIRECT_IND) &&
    d14e:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
    d152:	2b0c      	cmp	r3, #12
    d154:	f47f ae05 	bne.w	cd62 <isr_rx+0x11a>
		    isr_scan_tgta_check(lll, false, pdu_adv_rx, rl_idx,
    d158:	f10d 030f 	add.w	r3, sp, #15
    d15c:	9300      	str	r3, [sp, #0]
    d15e:	4642      	mov	r2, r8
    d160:	463b      	mov	r3, r7
    d162:	2100      	movs	r1, #0
    d164:	4620      	mov	r0, r4
    d166:	f01e ffcf 	bl	2c108 <isr_scan_tgta_check>
		   (pdu_adv_rx->len == sizeof(struct pdu_adv_direct_ind)) &&
    d16a:	2800      	cmp	r0, #0
    d16c:	d0cc      	beq.n	d108 <isr_rx+0x4c0>
		   isr_scan_rsp_adva_matches(pdu_adv_rx))) &&
    d16e:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
    d172:	2b00      	cmp	r3, #0
    d174:	f43f adf5 	beq.w	cd62 <isr_rx+0x11a>
		 (pdu_adv_rx->len != 0) &&
    d178:	68a3      	ldr	r3, [r4, #8]
    d17a:	2b00      	cmp	r3, #0
    d17c:	f47f adf1 	bne.w	cd62 <isr_rx+0x11a>
		err = isr_rx_scan_report(lll, rssi_ready,
    d180:	f1ba 0f00 	cmp.w	sl, #0
    d184:	f89d 200f 	ldrb.w	r2, [sp, #15]
    d188:	bf14      	ite	ne
    d18a:	4639      	movne	r1, r7
    d18c:	21ff      	moveq	r1, #255	; 0xff
    d18e:	4628      	mov	r0, r5
    d190:	f01f f83d 	bl	2c20e <isr_rx_scan_report.isra.4>
		if (err) {
    d194:	e5e5      	b.n	cd62 <isr_rx+0x11a>
	else if (((((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
    d196:	2b02      	cmp	r3, #2
    d198:	e7af      	b.n	d0fa <isr_rx+0x4b2>
    d19a:	bf00      	nop
    d19c:	00031b62 	.word	0x00031b62
    d1a0:	0003166e 	.word	0x0003166e
    d1a4:	00000000 	.word	0x00000000

0000d1a8 <ull_conn_llcp>:

	return 0;
}

int ull_conn_llcp(struct ll_conn *conn, u32_t ticks_at_expire, u16_t lazy)
{
    d1a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d1ac:	4693      	mov	fp, r2
	LL_ASSERT(conn->lll.handle != 0xFFFF);
    d1ae:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
    d1b0:	f64f 73ff 	movw	r3, #65535	; 0xffff
    d1b4:	429a      	cmp	r2, r3
{
    d1b6:	b08d      	sub	sp, #52	; 0x34
    d1b8:	4604      	mov	r4, r0
    d1ba:	460f      	mov	r7, r1
	LL_ASSERT(conn->lll.handle != 0xFFFF);
    d1bc:	d108      	bne.n	d1d0 <ull_conn_llcp+0x28>
    d1be:	48c7      	ldr	r0, [pc, #796]	; (d4dc <ull_conn_llcp+0x334>)
    d1c0:	f01a ffc0 	bl	28144 <printk>
    d1c4:	4040      	eors	r0, r0
    d1c6:	f380 8811 	msr	BASEPRI, r0
    d1ca:	f04f 0003 	mov.w	r0, #3
    d1ce:	df02      	svc	2

	/* Check if no other procedure with instant is requested and not in
	 * Encryption setup.
	 */
	if ((conn->llcp_ack == conn->llcp_req) &&
    d1d0:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
    d1d4:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
    d1d8:	4293      	cmp	r3, r2
    d1da:	d110      	bne.n	d1fe <ull_conn_llcp+0x56>
#if defined(CONFIG_BT_CTLR_LE_ENC)
	    !conn->llcp_enc.pause_rx) {
    d1dc:	f894 1152 	ldrb.w	r1, [r4, #338]	; 0x152
	if ((conn->llcp_ack == conn->llcp_req) &&
    d1e0:	f011 0501 	ands.w	r5, r1, #1
    d1e4:	d10b      	bne.n	d1fe <ull_conn_llcp+0x56>
#endif /* !CONFIG_BT_CTLR_LE_ENC */

		/* TODO: Optimize the checks below, maybe have common flag */

		/* check if connection update procedure is requested */
		if (conn->llcp_cu.ack != conn->llcp_cu.req) {
    d1e6:	f894 0105 	ldrb.w	r0, [r4, #261]	; 0x105
    d1ea:	f894 6104 	ldrb.w	r6, [r4, #260]	; 0x104
    d1ee:	4286      	cmp	r6, r0
    d1f0:	d01d      	beq.n	d22e <ull_conn_llcp+0x86>
			/* switch to LLCP_CONN_UPD state machine */
			conn->llcp_type = LLCP_CONN_UPD;
    d1f2:	2201      	movs	r2, #1
			conn->llcp_ack -= 2U;
    d1f4:	3b02      	subs	r3, #2
			conn->llcp_type = LLCP_CONN_UPD;
    d1f6:	f884 20ea 	strb.w	r2, [r4, #234]	; 0xea
			conn->llcp_ack -= 2U;
    d1fa:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
#endif /* CONFIG_BT_CTLR_PHY */
		}
	}

	/* check if procedure is requested */
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
    d1fe:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
    d202:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
    d206:	1ad3      	subs	r3, r2, r3
    d208:	f003 0303 	and.w	r3, r3, #3
    d20c:	2b02      	cmp	r3, #2
    d20e:	f040 8424 	bne.w	da5a <ull_conn_llcp+0x8b2>
		switch (conn->llcp_type) {
    d212:	f894 30ea 	ldrb.w	r3, [r4, #234]	; 0xea
    d216:	3b01      	subs	r3, #1
    d218:	2b05      	cmp	r3, #5
    d21a:	f201 80de 	bhi.w	e3da <ull_conn_llcp+0x1232>
    d21e:	e8df f013 	tbh	[pc, r3, lsl #1]
    d222:	038f      	.short	0x038f
    d224:	064505f5 	.word	0x064505f5
    d228:	077c08dc 	.word	0x077c08dc
    d22c:	079b      	.short	0x079b
		} else if (conn->llcp_feature.ack != conn->llcp_feature.req) {
    d22e:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
    d232:	f894 6118 	ldrb.w	r6, [r4, #280]	; 0x118
    d236:	42b3      	cmp	r3, r6
    d238:	d065      	beq.n	d306 <ull_conn_llcp+0x15e>
static inline void event_fex_prep(struct ll_conn *conn)
{
	struct node_tx *tx;

	/* If waiting for response, do nothing */
	if (!((conn->llcp_feature.ack - conn->llcp_feature.req) & 0x01)) {
    d23a:	1b9b      	subs	r3, r3, r6
    d23c:	07d8      	lsls	r0, r3, #31
    d23e:	d5de      	bpl.n	d1fe <ull_conn_llcp+0x56>
		return;
	}

	if (conn->common.fex_valid) {
    d240:	f894 10dc 	ldrb.w	r1, [r4, #220]	; 0xdc
    d244:	f011 0601 	ands.w	r6, r1, #1
    d248:	d02d      	beq.n	d2a6 <ull_conn_llcp+0xfe>
		struct node_rx_pdu *rx;
		struct pdu_data *pdu;

		/* get a rx node for ULL->LL */
		rx = ll_pdu_rx_alloc();
    d24a:	f011 f8ab 	bl	1e3a4 <ll_pdu_rx_alloc>
		if (!rx) {
    d24e:	4606      	mov	r6, r0
    d250:	2800      	cmp	r0, #0
    d252:	d0d4      	beq.n	d1fe <ull_conn_llcp+0x56>
			return;
		}

		/* procedure request acked */
		conn->llcp_feature.ack = conn->llcp_feature.req;
    d254:	f894 3118 	ldrb.w	r3, [r4, #280]	; 0x118
    d258:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119

		/* prepare feature rsp structure */
		rx->hdr.handle = conn->lll.handle;
    d25c:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    d25e:	80c3      	strh	r3, [r0, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
    d260:	2302      	movs	r3, #2
    d262:	7103      	strb	r3, [r0, #4]
		pdu = (void *)rx->pdu;
		pdu->ll_id = PDU_DATA_LLID_CTRL;
    d264:	f890 3020 	ldrb.w	r3, [r0, #32]
    d268:	f043 0303 	orr.w	r3, r3, #3
    d26c:	f880 3020 	strb.w	r3, [r0, #32]
		pdu->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
    d270:	2309      	movs	r3, #9
    d272:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
			   sizeof(struct pdu_data_llctrl_feature_rsp);
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
    d276:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
		(void)memset(&pdu->llctrl.feature_rsp.features[0], 0x00,
    d27a:	2208      	movs	r2, #8
    d27c:	4629      	mov	r1, r5
    d27e:	3024      	adds	r0, #36	; 0x24
    d280:	f01d f90f 	bl	2a4a2 <memset>
			sizeof(pdu->llctrl.feature_rsp.features));
		pdu->llctrl.feature_req.features[0] =
			conn->llcp_feature.features & 0xFF;
    d284:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
		pdu->llctrl.feature_req.features[0] =
    d288:	f886 3024 	strb.w	r3, [r6, #36]	; 0x24
		pdu->llctrl.feature_req.features[1] =
			(conn->llcp_feature.features >> 8) & 0xFF;
    d28c:	0a1a      	lsrs	r2, r3, #8
		pdu->llctrl.feature_req.features[2] =
			(conn->llcp_feature.features >> 16) & 0xFF;
    d28e:	0c1b      	lsrs	r3, r3, #16
		pdu->llctrl.feature_req.features[1] =
    d290:	f886 2025 	strb.w	r2, [r6, #37]	; 0x25
		pdu->llctrl.feature_req.features[2] =
    d294:	f886 3026 	strb.w	r3, [r6, #38]	; 0x26

		/* enqueue feature rsp structure into rx queue */
		ll_rx_put(rx->hdr.link, rx);
    d298:	4631      	mov	r1, r6
			sys_cpu_to_le16(conn->llcp_version.company_id);
		pdu->llctrl.version_ind.sub_version_number =
			sys_cpu_to_le16(conn->llcp_version.sub_version_number);

		/* enqueue version ind structure into rx queue */
		ll_rx_put(rx->hdr.link, rx);
    d29a:	6808      	ldr	r0, [r1, #0]
    d29c:	f011 f85a 	bl	1e354 <ll_rx_put>
		ll_rx_sched();
    d2a0:	f011 f862 	bl	1e368 <ll_rx_sched>
    d2a4:	e7ab      	b.n	d1fe <ull_conn_llcp+0x56>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    d2a6:	488e      	ldr	r0, [pc, #568]	; (d4e0 <ull_conn_llcp+0x338>)
    d2a8:	f01e fb42 	bl	2b930 <mem_acquire>
	if (tx) {
    d2ac:	4605      	mov	r5, r0
    d2ae:	2800      	cmp	r0, #0
    d2b0:	d0a5      	beq.n	d1fe <ull_conn_llcp+0x56>
		conn->llcp_feature.ack--;
    d2b2:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
    d2b6:	3b01      	subs	r3, #1
    d2b8:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119
		conn->llcp_feature.features = LL_FEAT;
    d2bc:	4b89      	ldr	r3, [pc, #548]	; (d4e4 <ull_conn_llcp+0x33c>)
    d2be:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
		pdu->ll_id = PDU_DATA_LLID_CTRL;
    d2c2:	7903      	ldrb	r3, [r0, #4]
    d2c4:	f043 0303 	orr.w	r3, r3, #3
    d2c8:	7103      	strb	r3, [r0, #4]
		pdu->len = offsetof(struct pdu_data_llctrl, feature_req) +
    d2ca:	2309      	movs	r3, #9
    d2cc:	7143      	strb	r3, [r0, #5]
		pdu->llctrl.opcode = !conn->lll.role ?
    d2ce:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
    d2d2:	2b00      	cmp	r3, #0
    d2d4:	bfac      	ite	ge
    d2d6:	2308      	movge	r3, #8
    d2d8:	230e      	movlt	r3, #14
		(void)memset(&pdu->llctrl.feature_req.features[0],
    d2da:	2208      	movs	r2, #8
		pdu->llctrl.opcode = !conn->lll.role ?
    d2dc:	71c3      	strb	r3, [r0, #7]
		(void)memset(&pdu->llctrl.feature_req.features[0],
    d2de:	4631      	mov	r1, r6
    d2e0:	4410      	add	r0, r2
    d2e2:	f01d f8de 	bl	2a4a2 <memset>
			conn->llcp_feature.features & 0xFF;
    d2e6:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
		pdu->llctrl.feature_req.features[0] =
    d2ea:	722b      	strb	r3, [r5, #8]
			(conn->llcp_feature.features >> 8) & 0xFF;
    d2ec:	0a1a      	lsrs	r2, r3, #8
			(conn->llcp_feature.features >> 16) & 0xFF;
    d2ee:	0c1b      	lsrs	r3, r3, #16
		pdu->llctrl.feature_req.features[1] =
    d2f0:	726a      	strb	r2, [r5, #9]
		pdu->llctrl.feature_req.features[2] =
    d2f2:	72ab      	strb	r3, [r5, #10]
		ctrl_tx_enqueue(conn, tx);
    d2f4:	4629      	mov	r1, r5

		pr = &pdu_ctrl_tx->llctrl.phy_req;
		pr->tx_phys = conn->llcp_phy.tx;
		pr->rx_phys = conn->llcp_phy.rx;

		ctrl_tx_enqueue(conn, tx);
    d2f6:	4620      	mov	r0, r4
    d2f8:	f01f f834 	bl	2c364 <ctrl_tx_enqueue>

		/* Start Procedure Timeout (TODO: this shall not replace
		 * terminate procedure).
		 */
		conn->procedure_expire = conn->procedure_reload;
    d2fc:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
    d300:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	}
	break;
    d304:	e77b      	b.n	d1fe <ull_conn_llcp+0x56>
		} else if (conn->llcp_version.ack != conn->llcp_version.req) {
    d306:	f894 3121 	ldrb.w	r3, [r4, #289]	; 0x121
    d30a:	f894 5120 	ldrb.w	r5, [r4, #288]	; 0x120
    d30e:	42ab      	cmp	r3, r5
    d310:	d057      	beq.n	d3c2 <ull_conn_llcp+0x21a>
	if (!((conn->llcp_version.ack - conn->llcp_version.req) & 0x01)) {
    d312:	1b5b      	subs	r3, r3, r5
    d314:	07d9      	lsls	r1, r3, #31
    d316:	f57f af72 	bpl.w	d1fe <ull_conn_llcp+0x56>
	if (conn->llcp_version.tx == 0U) {
    d31a:	f894 3122 	ldrb.w	r3, [r4, #290]	; 0x122
    d31e:	07da      	lsls	r2, r3, #31
    d320:	d425      	bmi.n	d36e <ull_conn_llcp+0x1c6>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    d322:	486f      	ldr	r0, [pc, #444]	; (d4e0 <ull_conn_llcp+0x338>)
    d324:	f01e fb04 	bl	2b930 <mem_acquire>
		if (tx) {
    d328:	4601      	mov	r1, r0
    d32a:	2800      	cmp	r0, #0
    d32c:	f43f af67 	beq.w	d1fe <ull_conn_llcp+0x56>
			conn->llcp_version.ack--;
    d330:	f894 3121 	ldrb.w	r3, [r4, #289]	; 0x121
    d334:	3b01      	subs	r3, #1
    d336:	f884 3121 	strb.w	r3, [r4, #289]	; 0x121
			conn->llcp_version.tx = 1U;
    d33a:	f894 3122 	ldrb.w	r3, [r4, #290]	; 0x122
    d33e:	f043 0301 	orr.w	r3, r3, #1
    d342:	f884 3122 	strb.w	r3, [r4, #290]	; 0x122
			pdu->ll_id = PDU_DATA_LLID_CTRL;
    d346:	7903      	ldrb	r3, [r0, #4]
    d348:	f043 0303 	orr.w	r3, r3, #3
    d34c:	7103      	strb	r3, [r0, #4]
			pdu->len =
    d34e:	2306      	movs	r3, #6
    d350:	7143      	strb	r3, [r0, #5]
			pdu->llctrl.opcode =
    d352:	230c      	movs	r3, #12
    d354:	71c3      	strb	r3, [r0, #7]
			pdu->llctrl.version_ind.version_number =
    d356:	230a      	movs	r3, #10
    d358:	7203      	strb	r3, [r0, #8]
			pdu->llctrl.version_ind.company_id = cid;
    d35a:	f06f 030e 	mvn.w	r3, #14
    d35e:	7243      	strb	r3, [r0, #9]
    d360:	2305      	movs	r3, #5
    d362:	7283      	strb	r3, [r0, #10]
			pdu->llctrl.version_ind.sub_version_number = svn;
    d364:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    d368:	72c3      	strb	r3, [r0, #11]
    d36a:	7303      	strb	r3, [r0, #12]
			ctrl_tx_enqueue(conn, tx);
    d36c:	e7c3      	b.n	d2f6 <ull_conn_llcp+0x14e>
	} else if (conn->llcp_version.rx) {
    d36e:	079e      	lsls	r6, r3, #30
    d370:	f140 82e4 	bpl.w	d93c <ull_conn_llcp+0x794>
		rx = ll_pdu_rx_alloc();
    d374:	f011 f816 	bl	1e3a4 <ll_pdu_rx_alloc>
		if (!rx) {
    d378:	4601      	mov	r1, r0
    d37a:	2800      	cmp	r0, #0
    d37c:	f43f af3f 	beq.w	d1fe <ull_conn_llcp+0x56>
		conn->llcp_version.ack = conn->llcp_version.req;
    d380:	f894 3120 	ldrb.w	r3, [r4, #288]	; 0x120
    d384:	f884 3121 	strb.w	r3, [r4, #289]	; 0x121
		rx->hdr.handle = conn->lll.handle;
    d388:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    d38a:	80c3      	strh	r3, [r0, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
    d38c:	2302      	movs	r3, #2
    d38e:	7103      	strb	r3, [r0, #4]
		pdu->ll_id = PDU_DATA_LLID_CTRL;
    d390:	f890 3020 	ldrb.w	r3, [r0, #32]
    d394:	f043 0303 	orr.w	r3, r3, #3
    d398:	f880 3020 	strb.w	r3, [r0, #32]
		pdu->len = offsetof(struct pdu_data_llctrl, version_ind) +
    d39c:	2306      	movs	r3, #6
    d39e:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
    d3a2:	230c      	movs	r3, #12
    d3a4:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
		pdu->llctrl.version_ind.version_number =
    d3a8:	f894 3123 	ldrb.w	r3, [r4, #291]	; 0x123
    d3ac:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
		pdu->llctrl.version_ind.company_id =
    d3b0:	f8b4 3124 	ldrh.w	r3, [r4, #292]	; 0x124
    d3b4:	f8a0 3025 	strh.w	r3, [r0, #37]	; 0x25
		pdu->llctrl.version_ind.sub_version_number =
    d3b8:	f8b4 3126 	ldrh.w	r3, [r4, #294]	; 0x126
    d3bc:	f8a0 3027 	strh.w	r3, [r0, #39]	; 0x27
    d3c0:	e76b      	b.n	d29a <ull_conn_llcp+0xf2>
		} else if (conn->llcp_conn_param.ack !=
    d3c2:	f894 5171 	ldrb.w	r5, [r4, #369]	; 0x171
    d3c6:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
    d3ca:	429d      	cmp	r5, r3
    d3cc:	f000 815b 	beq.w	d686 <ull_conn_llcp+0x4de>
	conn_upd = conn_upd_curr;
    d3d0:	4e45      	ldr	r6, [pc, #276]	; (d4e8 <ull_conn_llcp+0x340>)
    d3d2:	6833      	ldr	r3, [r6, #0]
	if (conn_upd && (conn_upd != conn)) {
    d3d4:	b113      	cbz	r3, d3dc <ull_conn_llcp+0x234>
    d3d6:	429c      	cmp	r4, r3
    d3d8:	f47f af11 	bne.w	d1fe <ull_conn_llcp+0x56>
	switch (conn->llcp_conn_param.state) {
    d3dc:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
    d3e0:	f003 0307 	and.w	r3, r3, #7
    d3e4:	2b05      	cmp	r3, #5
    d3e6:	f200 82a9 	bhi.w	d93c <ull_conn_llcp+0x794>
    d3ea:	a201      	add	r2, pc, #4	; (adr r2, d3f0 <ull_conn_llcp+0x248>)
    d3ec:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    d3f0:	0000d409 	.word	0x0000d409
    d3f4:	0000d4f5 	.word	0x0000d4f5
    d3f8:	0000d62f 	.word	0x0000d62f
    d3fc:	0000d1ff 	.word	0x0000d1ff
    d400:	0000d1ff 	.word	0x0000d1ff
    d404:	0000d1ff 	.word	0x0000d1ff
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    d408:	4835      	ldr	r0, [pc, #212]	; (d4e0 <ull_conn_llcp+0x338>)
			event_counter = lll->event_counter +
    d40a:	f8b4 8036 	ldrh.w	r8, [r4, #54]	; 0x36
					lll->latency_prepare + lazy;
    d40e:	f8b4 9032 	ldrh.w	r9, [r4, #50]	; 0x32
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    d412:	f01e fa8d 	bl	2b930 <mem_acquire>
	if (!tx) {
    d416:	4605      	mov	r5, r0
    d418:	2800      	cmp	r0, #0
    d41a:	f43f aef0 	beq.w	d1fe <ull_conn_llcp+0x56>
	conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP_WAIT;
    d41e:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
    d422:	2204      	movs	r2, #4
    d424:	f362 0302 	bfi	r3, r2, #0, #3
    d428:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    d42c:	7903      	ldrb	r3, [r0, #4]
    d42e:	f043 0303 	orr.w	r3, r3, #3
    d432:	7103      	strb	r3, [r0, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
    d434:	2318      	movs	r3, #24
    d436:	7143      	strb	r3, [r0, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
    d438:	230f      	movs	r3, #15
    d43a:	71c3      	strb	r3, [r0, #7]
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
    d43c:	f8b4 3174 	ldrh.w	r3, [r4, #372]	; 0x174
    d440:	8103      	strh	r3, [r0, #8]
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
    d442:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
    d446:	8143      	strh	r3, [r0, #10]
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
    d448:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
    d44c:	8183      	strh	r3, [r0, #12]
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
    d44e:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
    d452:	81c3      	strh	r3, [r0, #14]
			event_counter = lll->event_counter +
    d454:	44c8      	add	r8, r9
	p->preferred_periodicity = 0U;
    d456:	2300      	movs	r3, #0
    d458:	7403      	strb	r3, [r0, #16]
	p->offset0 = sys_cpu_to_le16(0x0000);
    d45a:	74c3      	strb	r3, [r0, #19]
    d45c:	7503      	strb	r3, [r0, #20]
	p->reference_conn_event_count = sys_cpu_to_le16(event_counter);
    d45e:	44d8      	add	r8, fp
	p->offset1 = sys_cpu_to_le16(0xffff);
    d460:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    d464:	7543      	strb	r3, [r0, #21]
    d466:	7583      	strb	r3, [r0, #22]
	p->offset2 = sys_cpu_to_le16(0xffff);
    d468:	75c3      	strb	r3, [r0, #23]
    d46a:	7603      	strb	r3, [r0, #24]
	p->offset3 = sys_cpu_to_le16(0xffff);
    d46c:	7643      	strb	r3, [r0, #25]
    d46e:	7683      	strb	r3, [r0, #26]
	p->offset4 = sys_cpu_to_le16(0xffff);
    d470:	76c3      	strb	r3, [r0, #27]
    d472:	7703      	strb	r3, [r0, #28]
	p->offset5 = sys_cpu_to_le16(0xffff);
    d474:	7743      	strb	r3, [r0, #29]
    d476:	7783      	strb	r3, [r0, #30]
	p->reference_conn_event_count = sys_cpu_to_le16(event_counter);
    d478:	f8a0 8011 	strh.w	r8, [r0, #17]
	ctrl_tx_enqueue(conn, tx);
    d47c:	4601      	mov	r1, r0
    d47e:	4620      	mov	r0, r4
    d480:	f01e ff70 	bl	2c364 <ctrl_tx_enqueue>
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
    d484:	6822      	ldr	r2, [r4, #0]
	conn->procedure_expire = conn->procedure_reload;
    d486:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
	conn_upd_curr = conn;
    d48a:	6034      	str	r4, [r6, #0]
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
    d48c:	2a00      	cmp	r2, #0
	conn->procedure_expire = conn->procedure_reload;
    d48e:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
		conn->llcp_conn_param.ticks_ref = ticks_at_expire;
    d492:	f8c4 7190 	str.w	r7, [r4, #400]	; 0x190
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
    d496:	da0a      	bge.n	d4ae <ull_conn_llcp+0x306>
			u32_t ticks_prepare_to_start =
    d498:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
				(conn->evt.ticks_xtal_to_start &
    d49c:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
			conn->llcp_conn_param.ticks_ref -=
    d4a0:	428b      	cmp	r3, r1
    d4a2:	bf2c      	ite	cs
    d4a4:	18fb      	addcs	r3, r7, r3
    d4a6:	187b      	addcc	r3, r7, r1
    d4a8:	1a9b      	subs	r3, r3, r2
    d4aa:	f8c4 3190 	str.w	r3, [r4, #400]	; 0x190
		conn->llcp_conn_param.pdu_win_offset0 = (u16_t *)&p->offset0;
    d4ae:	3513      	adds	r5, #19
		s_mfy_sched_offset.param = (void *)conn;
    d4b0:	4b0e      	ldr	r3, [pc, #56]	; (d4ec <ull_conn_llcp+0x344>)
		conn->llcp_conn_param.pdu_win_offset0 = (u16_t *)&p->offset0;
    d4b2:	f8c4 518c 	str.w	r5, [r4, #396]	; 0x18c
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
    d4b6:	2201      	movs	r2, #1
    d4b8:	2102      	movs	r1, #2
    d4ba:	4610      	mov	r0, r2
		s_mfy_sched_offset.param = (void *)conn;
    d4bc:	609c      	str	r4, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
    d4be:	f00e f989 	bl	1b7d4 <mayfly_enqueue>
		LL_ASSERT(!retval);
    d4c2:	2800      	cmp	r0, #0
    d4c4:	f43f ae9b 	beq.w	d1fe <ull_conn_llcp+0x56>
    d4c8:	4809      	ldr	r0, [pc, #36]	; (d4f0 <ull_conn_llcp+0x348>)
	case LLCP_PHY_STATE_RSP_WAIT:
		/* no nothing */
		break;

	default:
		LL_ASSERT(0);
    d4ca:	f01a fe3b 	bl	28144 <printk>
    d4ce:	4040      	eors	r0, r0
    d4d0:	f380 8811 	msr	BASEPRI, r0
    d4d4:	f04f 0003 	mov.w	r0, #3
    d4d8:	df02      	svc	2
		break;
    d4da:	e690      	b.n	d1fe <ull_conn_llcp+0x56>
    d4dc:	00031dc0 	.word	0x00031dc0
    d4e0:	200034bc 	.word	0x200034bc
    d4e4:	000149ff 	.word	0x000149ff
    d4e8:	20003184 	.word	0x20003184
    d4ec:	2000fd60 	.word	0x2000fd60
    d4f0:	0003169c 	.word	0x0003169c
	if (conn->llcp_conn_param.status) {
    d4f4:	f894 5173 	ldrb.w	r5, [r4, #371]	; 0x173
    d4f8:	b1ed      	cbz	r5, d536 <ull_conn_llcp+0x38e>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    d4fa:	48cc      	ldr	r0, [pc, #816]	; (d82c <ull_conn_llcp+0x684>)
    d4fc:	f01e fa18 	bl	2b930 <mem_acquire>
		if (!tx) {
    d500:	4601      	mov	r1, r0
    d502:	2800      	cmp	r0, #0
    d504:	f43f ae7b 	beq.w	d1fe <ull_conn_llcp+0x56>
		pdu->ll_id = PDU_DATA_LLID_CTRL;
    d508:	7903      	ldrb	r3, [r0, #4]
    d50a:	f043 0303 	orr.w	r3, r3, #3
    d50e:	7103      	strb	r3, [r0, #4]
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
    d510:	2311      	movs	r3, #17
    d512:	71c3      	strb	r3, [r0, #7]
		pdu->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
    d514:	2303      	movs	r3, #3
    d516:	7143      	strb	r3, [r0, #5]
		rej->reject_opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
    d518:	230f      	movs	r3, #15
    d51a:	7203      	strb	r3, [r0, #8]
		rej->error_code = conn->llcp_conn_param.status;
    d51c:	f894 3173 	ldrb.w	r3, [r4, #371]	; 0x173
    d520:	7243      	strb	r3, [r0, #9]
		ctrl_tx_enqueue(conn, tx);
    d522:	4620      	mov	r0, r4
    d524:	f01e ff1e 	bl	2c364 <ctrl_tx_enqueue>
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
    d528:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
    d52c:	f884 3171 	strb.w	r3, [r4, #369]	; 0x171
		conn_upd_curr = NULL;
    d530:	2300      	movs	r3, #0
    d532:	6033      	str	r3, [r6, #0]
		return;
    d534:	e663      	b.n	d1fe <ull_conn_llcp+0x56>
	if (!conn->lll.role) {
    d536:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
    d53a:	2b00      	cmp	r3, #0
    d53c:	db34      	blt.n	d5a8 <ull_conn_llcp+0x400>
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
    d53e:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
		conn->llcp_cu.win_offset_us = 0U;
    d542:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
    d546:	2205      	movs	r2, #5
    d548:	f362 0302 	bfi	r3, r2, #0, #3
		if (conn->llcp_conn_param.preferred_periodicity) {
    d54c:	f894 217c 	ldrb.w	r2, [r4, #380]	; 0x17c
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
    d550:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
		conn->llcp_cu.win_size = 1U;
    d554:	2301      	movs	r3, #1
    d556:	f884 3114 	strb.w	r3, [r4, #276]	; 0x114
		if (conn->llcp_conn_param.preferred_periodicity) {
    d55a:	b312      	cbz	r2, d5a2 <ull_conn_llcp+0x3fa>
				((conn->llcp_conn_param.interval_min /
    d55c:	f8b4 3174 	ldrh.w	r3, [r4, #372]	; 0x174
    d560:	fbb3 f3f2 	udiv	r3, r3, r2
				  conn->llcp_conn_param.preferred_periodicity) +
    d564:	3301      	adds	r3, #1
			conn->llcp_cu.interval =
    d566:	fb13 f302 	smulbb	r3, r3, r2
    d56a:	b29b      	uxth	r3, r3
    d56c:	f8a4 3108 	strh.w	r3, [r4, #264]	; 0x108
		conn->llcp_cu.latency = conn->llcp_conn_param.latency;
    d570:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
    d574:	f8a4 310a 	strh.w	r3, [r4, #266]	; 0x10a
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
    d578:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
    d57c:	f8a4 310c 	strh.w	r3, [r4, #268]	; 0x10c
		conn->llcp_cu.state = LLCP_CUI_STATE_SELECT;
    d580:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
    d584:	2202      	movs	r2, #2
    d586:	f362 0301 	bfi	r3, r2, #0, #2
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
    d58a:	f894 2172 	ldrb.w	r2, [r4, #370]	; 0x172
    d58e:	f3c2 02c0 	ubfx	r2, r2, #3, #1
    d592:	f362 0382 	bfi	r3, r2, #2, #1
		conn->llcp_cu.ack--;
    d596:	3801      	subs	r0, #1
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
    d598:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
		conn->llcp_cu.ack--;
    d59c:	f884 0105 	strb.w	r0, [r4, #261]	; 0x105
		return;
    d5a0:	e62d      	b.n	d1fe <ull_conn_llcp+0x56>
				conn->llcp_conn_param.interval_max;
    d5a2:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
    d5a6:	e7e1      	b.n	d56c <ull_conn_llcp+0x3c4>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    d5a8:	48a0      	ldr	r0, [pc, #640]	; (d82c <ull_conn_llcp+0x684>)
    d5aa:	f01e f9c1 	bl	2b930 <mem_acquire>
	if (!tx) {
    d5ae:	4601      	mov	r1, r0
    d5b0:	2800      	cmp	r0, #0
    d5b2:	f43f ae24 	beq.w	d1fe <ull_conn_llcp+0x56>
	pdu->ll_id = PDU_DATA_LLID_CTRL;
    d5b6:	7903      	ldrb	r3, [r0, #4]
    d5b8:	f043 0303 	orr.w	r3, r3, #3
    d5bc:	7103      	strb	r3, [r0, #4]
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_rsp) +
    d5be:	2318      	movs	r3, #24
    d5c0:	7143      	strb	r3, [r0, #5]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_RSP;
    d5c2:	2310      	movs	r3, #16
    d5c4:	71c3      	strb	r3, [r0, #7]
	rsp->interval_min =
    d5c6:	f8b4 3174 	ldrh.w	r3, [r4, #372]	; 0x174
    d5ca:	8103      	strh	r3, [r0, #8]
	rsp->interval_max =
    d5cc:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
    d5d0:	8143      	strh	r3, [r0, #10]
	rsp->latency =
    d5d2:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
    d5d6:	8183      	strh	r3, [r0, #12]
	rsp->timeout =
    d5d8:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
    d5dc:	81c3      	strh	r3, [r0, #14]
	rsp->preferred_periodicity =
    d5de:	f894 317c 	ldrb.w	r3, [r4, #380]	; 0x17c
    d5e2:	7403      	strb	r3, [r0, #16]
	rsp->reference_conn_event_count =
    d5e4:	f8b4 317e 	ldrh.w	r3, [r4, #382]	; 0x17e
    d5e8:	f8a0 3011 	strh.w	r3, [r0, #17]
	rsp->offset0 = sys_cpu_to_le16(conn->llcp_conn_param.offset0);
    d5ec:	f8b4 3180 	ldrh.w	r3, [r4, #384]	; 0x180
    d5f0:	f8a0 3013 	strh.w	r3, [r0, #19]
	rsp->offset1 = sys_cpu_to_le16(conn->llcp_conn_param.offset1);
    d5f4:	f8b4 3182 	ldrh.w	r3, [r4, #386]	; 0x182
    d5f8:	f8a0 3015 	strh.w	r3, [r0, #21]
	rsp->offset2 = sys_cpu_to_le16(conn->llcp_conn_param.offset2);
    d5fc:	f8b4 3184 	ldrh.w	r3, [r4, #388]	; 0x184
    d600:	f8a0 3017 	strh.w	r3, [r0, #23]
	rsp->offset3 = sys_cpu_to_le16(conn->llcp_conn_param.offset3);
    d604:	f8b4 3186 	ldrh.w	r3, [r4, #390]	; 0x186
    d608:	f8a0 3019 	strh.w	r3, [r0, #25]
	rsp->offset4 = sys_cpu_to_le16(conn->llcp_conn_param.offset4);
    d60c:	f8b4 3188 	ldrh.w	r3, [r4, #392]	; 0x188
    d610:	f8a0 301b 	strh.w	r3, [r0, #27]
	rsp->offset5 = sys_cpu_to_le16(conn->llcp_conn_param.offset5);
    d614:	f8b4 318a 	ldrh.w	r3, [r4, #394]	; 0x18a
    d618:	f8a0 301d 	strh.w	r3, [r0, #29]
	ctrl_tx_enqueue(conn, tx);
    d61c:	4620      	mov	r0, r4
    d61e:	f01e fea1 	bl	2c364 <ctrl_tx_enqueue>
	conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
    d622:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
    d626:	f884 3171 	strb.w	r3, [r4, #369]	; 0x171
	conn_upd_curr = NULL;
    d62a:	6035      	str	r5, [r6, #0]
    d62c:	e5e7      	b.n	d1fe <ull_conn_llcp+0x56>
	if (conn->llcp_enc.pause_tx) {
    d62e:	078d      	lsls	r5, r1, #30
    d630:	f53f ade5 	bmi.w	d1fe <ull_conn_llcp+0x56>
	rx = ll_pdu_rx_alloc();
    d634:	f010 feb6 	bl	1e3a4 <ll_pdu_rx_alloc>
	if (!rx) {
    d638:	4601      	mov	r1, r0
    d63a:	2800      	cmp	r0, #0
    d63c:	f43f addf 	beq.w	d1fe <ull_conn_llcp+0x56>
	conn->llcp_conn_param.state = LLCP_CPR_STATE_APP_WAIT;
    d640:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
    d644:	2203      	movs	r2, #3
    d646:	f362 0302 	bfi	r3, r2, #0, #3
    d64a:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
	rx->hdr.handle = conn->lll.handle;
    d64e:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    d650:	80c3      	strh	r3, [r0, #6]
	rx->hdr.type = NODE_RX_TYPE_DC_PDU;
    d652:	2302      	movs	r3, #2
    d654:	7103      	strb	r3, [r0, #4]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
    d656:	f890 3020 	ldrb.w	r3, [r0, #32]
    d65a:	4313      	orrs	r3, r2
    d65c:	f880 3020 	strb.w	r3, [r0, #32]
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
    d660:	2318      	movs	r3, #24
    d662:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
    d666:	230f      	movs	r3, #15
    d668:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
    d66c:	f8b4 3174 	ldrh.w	r3, [r4, #372]	; 0x174
    d670:	8483      	strh	r3, [r0, #36]	; 0x24
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
    d672:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
    d676:	84c3      	strh	r3, [r0, #38]	; 0x26
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
    d678:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
    d67c:	8503      	strh	r3, [r0, #40]	; 0x28
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
    d67e:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
    d682:	8543      	strh	r3, [r0, #42]	; 0x2a
	ll_rx_put(rx->hdr.link, rx);
    d684:	e609      	b.n	d29a <ull_conn_llcp+0xf2>
		} else if (conn->llcp_length.ack != conn->llcp_length.req) {
    d686:	f894 0198 	ldrb.w	r0, [r4, #408]	; 0x198
    d68a:	f894 3199 	ldrb.w	r3, [r4, #409]	; 0x199
    d68e:	4283      	cmp	r3, r0
    d690:	f000 80b2 	beq.w	d7f8 <ull_conn_llcp+0x650>
	switch (conn->llcp_length.state) {
    d694:	f894 319a 	ldrb.w	r3, [r4, #410]	; 0x19a
    d698:	f3c3 0502 	ubfx	r5, r3, #0, #3
    d69c:	b2e9      	uxtb	r1, r5
    d69e:	2907      	cmp	r1, #7
    d6a0:	f000 814c 	beq.w	d93c <ull_conn_llcp+0x794>
    d6a4:	2201      	movs	r2, #1
    d6a6:	408a      	lsls	r2, r1
    d6a8:	f012 0f4e 	tst.w	r2, #78	; 0x4e
    d6ac:	f47f ada7 	bne.w	d1fe <ull_conn_llcp+0x56>
    d6b0:	f012 0f30 	tst.w	r2, #48	; 0x30
    d6b4:	d14c      	bne.n	d750 <ull_conn_llcp+0x5a8>
    d6b6:	2900      	cmp	r1, #0
    d6b8:	f040 8140 	bne.w	d93c <ull_conn_llcp+0x794>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    d6bc:	485b      	ldr	r0, [pc, #364]	; (d82c <ull_conn_llcp+0x684>)
    d6be:	f01e f937 	bl	2b930 <mem_acquire>
		if (!tx) {
    d6c2:	4601      	mov	r1, r0
    d6c4:	2800      	cmp	r0, #0
    d6c6:	f43f ad9a 	beq.w	d1fe <ull_conn_llcp+0x56>
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
    d6ca:	f894 319a 	ldrb.w	r3, [r4, #410]	; 0x19a
    d6ce:	2201      	movs	r2, #1
    d6d0:	f362 0302 	bfi	r3, r2, #0, #3
    d6d4:	f884 319a 	strb.w	r3, [r4, #410]	; 0x19a
		conn->default_tx_time = conn->llcp_length.tx_time;
    d6d8:	f8b4 21a2 	ldrh.w	r2, [r4, #418]	; 0x1a2
		conn->default_tx_octets = conn->llcp_length.tx_octets;
    d6dc:	f8b4 319e 	ldrh.w	r3, [r4, #414]	; 0x19e
    d6e0:	f8a4 30d6 	strh.w	r3, [r4, #214]	; 0xd6
		conn->default_tx_time = conn->llcp_length.tx_time;
    d6e4:	f8a4 20d8 	strh.w	r2, [r4, #216]	; 0xd8
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    d6e8:	7900      	ldrb	r0, [r0, #4]
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
    d6ea:	724d      	strb	r5, [r1, #9]
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    d6ec:	f040 0003 	orr.w	r0, r0, #3
    d6f0:	7108      	strb	r0, [r1, #4]
		pdu_ctrl_tx->len =
    d6f2:	2009      	movs	r0, #9
    d6f4:	7148      	strb	r0, [r1, #5]
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_REQ;
    d6f6:	2014      	movs	r0, #20
    d6f8:	71c8      	strb	r0, [r1, #7]
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
    d6fa:	f045 001b 	orr.w	r0, r5, #27
    d6fe:	7208      	strb	r0, [r1, #8]
		if (!conn->common.fex_valid ||
    d700:	f894 00dc 	ldrb.w	r0, [r4, #220]	; 0xdc
		lr->max_tx_octets = sys_cpu_to_le16(conn->default_tx_octets);
    d704:	818b      	strh	r3, [r1, #12]
		if (!conn->common.fex_valid ||
    d706:	07c0      	lsls	r0, r0, #31
    d708:	d504      	bpl.n	d714 <ull_conn_llcp+0x56c>
			BIT(BT_LE_FEAT_BIT_PHY_CODED)) &&
    d70a:	f8d4 011c 	ldr.w	r0, [r4, #284]	; 0x11c
		if (!conn->common.fex_valid ||
    d70e:	f410 6f10 	tst.w	r0, #2304	; 0x900
    d712:	d107      	bne.n	d724 <ull_conn_llcp+0x57c>
			lr->max_rx_time = sys_cpu_to_le16(rx_time);
    d714:	2248      	movs	r2, #72	; 0x48
			u16_t tx_time = PKT_US(conn->default_tx_octets, 0);
    d716:	330e      	adds	r3, #14
			lr->max_rx_time = sys_cpu_to_le16(rx_time);
    d718:	728a      	strb	r2, [r1, #10]
			lr->max_tx_time = sys_cpu_to_le16(tx_time);
    d71a:	00db      	lsls	r3, r3, #3
			lr->max_rx_time = sys_cpu_to_le16(rx_time);
    d71c:	2201      	movs	r2, #1
    d71e:	72ca      	strb	r2, [r1, #11]
			lr->max_tx_time = sys_cpu_to_le16(tx_time);
    d720:	81cb      	strh	r3, [r1, #14]
    d722:	e5e8      	b.n	d2f6 <ull_conn_llcp+0x14e>
		} else if (conn->llcp_feature.features &
    d724:	0503      	lsls	r3, r0, #20
    d726:	d507      	bpl.n	d738 <ull_conn_llcp+0x590>
			lr->max_rx_time = sys_cpu_to_le16(rx_time);
    d728:	f065 036f 	orn	r3, r5, #111	; 0x6f
    d72c:	f045 050a 	orr.w	r5, r5, #10
    d730:	728b      	strb	r3, [r1, #10]
    d732:	72cd      	strb	r5, [r1, #11]
			lr->max_tx_time = sys_cpu_to_le16(tx_time);
    d734:	81ca      	strh	r2, [r1, #14]
    d736:	e5de      	b.n	d2f6 <ull_conn_llcp+0x14e>
		} else if (conn->llcp_feature.features &
    d738:	05c6      	lsls	r6, r0, #23
    d73a:	f57f addc 	bpl.w	d2f6 <ull_conn_llcp+0x14e>
			lr->max_tx_time = sys_cpu_to_le16(tx_time);
    d73e:	2aa4      	cmp	r2, #164	; 0xa4
			lr->max_rx_time = sys_cpu_to_le16(rx_time);
    d740:	f065 035b 	orn	r3, r5, #91	; 0x5b
			lr->max_tx_time = sys_cpu_to_le16(tx_time);
    d744:	bf28      	it	cs
    d746:	22a4      	movcs	r2, #164	; 0xa4
			lr->max_rx_time = sys_cpu_to_le16(rx_time);
    d748:	728b      	strb	r3, [r1, #10]
    d74a:	72cd      	strb	r5, [r1, #11]
			lr->max_tx_time = sys_cpu_to_le16(tx_time);
    d74c:	81ca      	strh	r2, [r1, #14]
		ctrl_tx_enqueue(conn, tx);
    d74e:	e5d2      	b.n	d2f6 <ull_conn_llcp+0x14e>
		lll->max_rx_octets = conn->llcp_length.rx_octets;
    d750:	f8b4 219c 	ldrh.w	r2, [r4, #412]	; 0x19c
    d754:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
		lll->max_rx_time = conn->llcp_length.rx_time;
    d758:	f8b4 21a0 	ldrh.w	r2, [r4, #416]	; 0x1a0
    d75c:	f8a4 2062 	strh.w	r2, [r4, #98]	; 0x62
		if (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {
    d760:	f003 0207 	and.w	r2, r3, #7
    d764:	2a04      	cmp	r2, #4
		tx_octets = conn->llcp_length.tx_octets;
    d766:	f8b4 819e 	ldrh.w	r8, [r4, #414]	; 0x19e
		u16_t tx_time = conn->llcp_length.tx_time;
    d76a:	f8b4 61a2 	ldrh.w	r6, [r4, #418]	; 0x1a2
		if (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {
    d76e:	d141      	bne.n	d7f4 <ull_conn_llcp+0x64c>
			if (!conn->llcp_length.cache.tx_octets) {
    d770:	f8b4 21a4 	ldrh.w	r2, [r4, #420]	; 0x1a4
    d774:	bb82      	cbnz	r2, d7d8 <ull_conn_llcp+0x630>
				conn->llcp_length.ack = conn->llcp_length.req;
    d776:	f884 0199 	strb.w	r0, [r4, #409]	; 0x199
				conn->procedure_expire = 0U;
    d77a:	f8a4 20cc 	strh.w	r2, [r4, #204]	; 0xcc
		rx = conn->llcp_rx;
    d77e:	f8d4 5100 	ldr.w	r5, [r4, #256]	; 0x100
		LL_ASSERT(rx && rx->hdr.link);
    d782:	b10d      	cbz	r5, d788 <ull_conn_llcp+0x5e0>
    d784:	682b      	ldr	r3, [r5, #0]
    d786:	b943      	cbnz	r3, d79a <ull_conn_llcp+0x5f2>
    d788:	4829      	ldr	r0, [pc, #164]	; (d830 <ull_conn_llcp+0x688>)
    d78a:	f01a fcdb 	bl	28144 <printk>
    d78e:	4040      	eors	r0, r0
    d790:	f380 8811 	msr	BASEPRI, r0
    d794:	f04f 0003 	mov.w	r0, #3
    d798:	df02      	svc	2
		conn->llcp_rx = rx->hdr.link->mem;
    d79a:	6828      	ldr	r0, [r5, #0]
    d79c:	6843      	ldr	r3, [r0, #4]
    d79e:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
		rx->hdr.handle = conn->lll.handle;
    d7a2:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    d7a4:	80eb      	strh	r3, [r5, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
    d7a6:	2302      	movs	r3, #2
    d7a8:	712b      	strb	r3, [r5, #4]
		pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
    d7aa:	f895 3020 	ldrb.w	r3, [r5, #32]
    d7ae:	f043 0303 	orr.w	r3, r3, #3
    d7b2:	f885 3020 	strb.w	r3, [r5, #32]
		pdu_ctrl_rx->len =
    d7b6:	2309      	movs	r3, #9
    d7b8:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
		pdu_ctrl_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
    d7bc:	2315      	movs	r3, #21
    d7be:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
		lr->max_rx_octets = sys_cpu_to_le16(lll->max_rx_octets);
    d7c2:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
    d7c6:	84ab      	strh	r3, [r5, #36]	; 0x24
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
    d7c8:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
		lr->max_tx_octets = sys_cpu_to_le16(tx_octets);
    d7cc:	f8a5 8028 	strh.w	r8, [r5, #40]	; 0x28
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
    d7d0:	84eb      	strh	r3, [r5, #38]	; 0x26
		lr->max_tx_time = sys_cpu_to_le16(tx_time);
    d7d2:	856e      	strh	r6, [r5, #42]	; 0x2a
		ll_rx_put(rx->hdr.link, rx);
    d7d4:	4629      	mov	r1, r5
    d7d6:	e561      	b.n	d29c <ull_conn_llcp+0xf4>
				conn->llcp_length.tx_octets =
    d7d8:	f8a4 219e 	strh.w	r2, [r4, #414]	; 0x19e
				conn->llcp_length.tx_time =
    d7dc:	f8b4 11a6 	ldrh.w	r1, [r4, #422]	; 0x1a6
    d7e0:	f8a4 11a2 	strh.w	r1, [r4, #418]	; 0x1a2
				conn->llcp_length.cache.tx_octets = 0;
    d7e4:	2200      	movs	r2, #0
    d7e6:	f8a4 21a4 	strh.w	r2, [r4, #420]	; 0x1a4
			conn->llcp_length.state =
    d7ea:	f362 0302 	bfi	r3, r2, #0, #3
    d7ee:	f884 319a 	strb.w	r3, [r4, #410]	; 0x19a
    d7f2:	e7c4      	b.n	d77e <ull_conn_llcp+0x5d6>
    d7f4:	2206      	movs	r2, #6
    d7f6:	e7f8      	b.n	d7ea <ull_conn_llcp+0x642>
		} else if (conn->llcp_phy.ack != conn->llcp_phy.req) {
    d7f8:	f894 11a8 	ldrb.w	r1, [r4, #424]	; 0x1a8
    d7fc:	f894 31a9 	ldrb.w	r3, [r4, #425]	; 0x1a9
    d800:	428b      	cmp	r3, r1
    d802:	f43f acfc 	beq.w	d1fe <ull_conn_llcp+0x56>
	switch (conn->llcp_phy.state) {
    d806:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
    d80a:	f003 0003 	and.w	r0, r3, #3
    d80e:	2803      	cmp	r0, #3
    d810:	f200 8094 	bhi.w	d93c <ull_conn_llcp+0x794>
    d814:	a501      	add	r5, pc, #4	; (adr r5, d81c <ull_conn_llcp+0x674>)
    d816:	f855 f020 	ldr.w	pc, [r5, r0, lsl #2]
    d81a:	bf00      	nop
    d81c:	0000d835 	.word	0x0000d835
    d820:	0000d1ff 	.word	0x0000d1ff
    d824:	0000d1ff 	.word	0x0000d1ff
    d828:	0000d899 	.word	0x0000d899
    d82c:	200034bc 	.word	0x200034bc
    d830:	00031ded 	.word	0x00031ded
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    d834:	4890      	ldr	r0, [pc, #576]	; (da78 <ull_conn_llcp+0x8d0>)
    d836:	f01e f87b 	bl	2b930 <mem_acquire>
		if (!tx) {
    d83a:	4601      	mov	r1, r0
    d83c:	2800      	cmp	r0, #0
    d83e:	f43f acde 	beq.w	d1fe <ull_conn_llcp+0x56>
		conn->phy_pref_tx = conn->llcp_phy.tx;
    d842:	f894 21aa 	ldrb.w	r2, [r4, #426]	; 0x1aa
    d846:	f894 31ac 	ldrb.w	r3, [r4, #428]	; 0x1ac
		conn->phy_pref_flags = conn->llcp_phy.flags;
    d84a:	f894 51ab 	ldrb.w	r5, [r4, #427]	; 0x1ab
		conn->phy_pref_tx = conn->llcp_phy.tx;
    d84e:	f3c2 0082 	ubfx	r0, r2, #2, #3
    d852:	f360 0302 	bfi	r3, r0, #0, #3
		conn->phy_pref_rx = conn->llcp_phy.rx;
    d856:	f3c2 1242 	ubfx	r2, r2, #5, #3
    d85a:	f362 1306 	bfi	r3, r2, #4, #3
		conn->phy_pref_flags = conn->llcp_phy.flags;
    d85e:	f3c5 0540 	ubfx	r5, r5, #1, #1
    d862:	f365 03c3 	bfi	r3, r5, #3, #1
    d866:	f884 31ac 	strb.w	r3, [r4, #428]	; 0x1ac
		conn->llcp_phy.state = LLCP_PHY_STATE_ACK_WAIT;
    d86a:	f8b4 31aa 	ldrh.w	r3, [r4, #426]	; 0x1aa
    d86e:	f423 7381 	bic.w	r3, r3, #258	; 0x102
    d872:	f023 0301 	bic.w	r3, r3, #1
    d876:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    d87a:	f043 0301 	orr.w	r3, r3, #1
    d87e:	f8a4 31aa 	strh.w	r3, [r4, #426]	; 0x1aa
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    d882:	790b      	ldrb	r3, [r1, #4]
		pr->tx_phys = conn->llcp_phy.tx;
    d884:	7208      	strb	r0, [r1, #8]
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    d886:	f043 0303 	orr.w	r3, r3, #3
    d88a:	710b      	strb	r3, [r1, #4]
		pdu_ctrl_tx->len =
    d88c:	2303      	movs	r3, #3
    d88e:	714b      	strb	r3, [r1, #5]
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_REQ;
    d890:	2316      	movs	r3, #22
    d892:	71cb      	strb	r3, [r1, #7]
		pr->rx_phys = conn->llcp_phy.rx;
    d894:	724a      	strb	r2, [r1, #9]
    d896:	e52e      	b.n	d2f6 <ull_conn_llcp+0x14e>
		conn->llcp_phy.ack = conn->llcp_phy.req;
    d898:	f884 11a9 	strb.w	r1, [r4, #425]	; 0x1a9
		if (conn->llcp_phy.tx & BIT(1)) {
    d89c:	f3c3 0182 	ubfx	r1, r3, #2, #3
    d8a0:	078d      	lsls	r5, r1, #30
    d8a2:	d539      	bpl.n	d918 <ull_conn_llcp+0x770>
			conn->llcp_phy.tx = BIT(1);
    d8a4:	2102      	movs	r1, #2
			conn->llcp_phy.tx = 0U;
    d8a6:	f361 0384 	bfi	r3, r1, #2, #3
    d8aa:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
		if (conn->llcp_phy.rx & BIT(1)) {
    d8ae:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
    d8b2:	0959      	lsrs	r1, r3, #5
    d8b4:	078e      	lsls	r6, r1, #30
    d8b6:	d538      	bpl.n	d92a <ull_conn_llcp+0x782>
			conn->llcp_phy.rx = BIT(1);
    d8b8:	2102      	movs	r1, #2
			conn->llcp_phy.rx = 0U;
    d8ba:	f361 1347 	bfi	r3, r1, #5, #3
    d8be:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
		if (conn->llcp_phy.tx != conn->lll.phy_tx) {
    d8c2:	f894 11aa 	ldrb.w	r1, [r4, #426]	; 0x1aa
    d8c6:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
    d8ca:	f3c1 0082 	ubfx	r0, r1, #2, #3
    d8ce:	f003 0307 	and.w	r3, r3, #7
			conn->llcp.phy_upd_ind.tx = 0U;
    d8d2:	4283      	cmp	r3, r0
    d8d4:	bf08      	it	eq
    d8d6:	2000      	moveq	r0, #0
    d8d8:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    d8dc:	f360 0384 	bfi	r3, r0, #2, #3
		if (conn->llcp_phy.rx != conn->lll.phy_rx) {
    d8e0:	f894 0065 	ldrb.w	r0, [r4, #101]	; 0x65
    d8e4:	0949      	lsrs	r1, r1, #5
    d8e6:	f000 0007 	and.w	r0, r0, #7
			conn->llcp.phy_upd_ind.rx = 0U;
    d8ea:	4288      	cmp	r0, r1
    d8ec:	bf08      	it	eq
    d8ee:	2100      	moveq	r1, #0
    d8f0:	f361 1347 	bfi	r3, r1, #5, #3
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
    d8f4:	f894 11ab 	ldrb.w	r1, [r4, #427]	; 0x1ab
		conn->llcp.phy_upd_ind.initiate = 1U;
    d8f8:	b2db      	uxtb	r3, r3
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
    d8fa:	f3c1 0180 	ubfx	r1, r1, #2, #1
    d8fe:	f043 0301 	orr.w	r3, r3, #1
    d902:	f361 0341 	bfi	r3, r1, #1, #1
    d906:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
		conn->llcp_ack -= 2U;
    d90a:	3a02      	subs	r2, #2
		conn->llcp_type = LLCP_PHY_UPD;
    d90c:	2306      	movs	r3, #6
    d90e:	f884 30ea 	strb.w	r3, [r4, #234]	; 0xea
		conn->llcp_ack -= 2U;
    d912:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
	break;
    d916:	e472      	b.n	d1fe <ull_conn_llcp+0x56>
		} else if (conn->llcp_phy.tx & BIT(0)) {
    d918:	07c8      	lsls	r0, r1, #31
    d91a:	d501      	bpl.n	d920 <ull_conn_llcp+0x778>
			conn->llcp_phy.tx = BIT(0);
    d91c:	2101      	movs	r1, #1
    d91e:	e7c2      	b.n	d8a6 <ull_conn_llcp+0x6fe>
		} else if (conn->llcp_phy.tx & BIT(2)) {
    d920:	f011 0104 	ands.w	r1, r1, #4
			conn->llcp_phy.tx = BIT(2);
    d924:	bf18      	it	ne
    d926:	2104      	movne	r1, #4
    d928:	e7bd      	b.n	d8a6 <ull_conn_llcp+0x6fe>
		} else if (conn->llcp_phy.rx & BIT(0)) {
    d92a:	07cd      	lsls	r5, r1, #31
    d92c:	d501      	bpl.n	d932 <ull_conn_llcp+0x78a>
			conn->llcp_phy.rx = BIT(0);
    d92e:	2101      	movs	r1, #1
    d930:	e7c3      	b.n	d8ba <ull_conn_llcp+0x712>
		} else if (conn->llcp_phy.rx & BIT(2)) {
    d932:	f011 0104 	ands.w	r1, r1, #4
			conn->llcp_phy.rx = BIT(2);
    d936:	bf18      	it	ne
    d938:	2104      	movne	r1, #4
    d93a:	e7be      	b.n	d8ba <ull_conn_llcp+0x712>
		LL_ASSERT(0);
    d93c:	484f      	ldr	r0, [pc, #316]	; (da7c <ull_conn_llcp+0x8d4>)
    d93e:	e5c4      	b.n	d4ca <ull_conn_llcp+0x322>
	conn_upd = conn_upd_curr;
    d940:	494f      	ldr	r1, [pc, #316]	; (da80 <ull_conn_llcp+0x8d8>)
	if (!conn_upd) {
    d942:	680b      	ldr	r3, [r1, #0]
    d944:	b903      	cbnz	r3, d948 <ull_conn_llcp+0x7a0>
		conn_upd_curr = conn;
    d946:	600c      	str	r4, [r1, #0]
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
    d948:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    d94a:	8ee6      	ldrh	r6, [r4, #54]	; 0x36
    d94c:	441e      	add	r6, r3
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
    d94e:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
    d952:	445e      	add	r6, fp
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
    d954:	f013 0003 	ands.w	r0, r3, #3
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
    d958:	b2b6      	uxth	r6, r6
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
    d95a:	f000 809b 	beq.w	da94 <ull_conn_llcp+0x8ec>
		rx = ll_pdu_rx_alloc_peek(1);
    d95e:	2001      	movs	r0, #1
    d960:	f010 fd08 	bl	1e374 <ll_pdu_rx_alloc_peek>
		if (!rx) {
    d964:	4680      	mov	r8, r0
    d966:	2800      	cmp	r0, #0
    d968:	d077      	beq.n	da5a <ull_conn_llcp+0x8b2>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    d96a:	4843      	ldr	r0, [pc, #268]	; (da78 <ull_conn_llcp+0x8d0>)
    d96c:	f01d ffe0 	bl	2b930 <mem_acquire>
		if (!tx) {
    d970:	4605      	mov	r5, r0
    d972:	2800      	cmp	r0, #0
    d974:	d071      	beq.n	da5a <ull_conn_llcp+0x8b2>
		(void)ll_pdu_rx_alloc();
    d976:	f010 fd15 	bl	1e3a4 <ll_pdu_rx_alloc>
		rx->hdr.link->mem = conn->llcp_rx;
    d97a:	f8d8 3000 	ldr.w	r3, [r8]
    d97e:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
    d982:	605a      	str	r2, [r3, #4]
		switch (conn->llcp_cu.state) {
    d984:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
		conn->llcp_rx = rx;
    d988:	f8c4 8100 	str.w	r8, [r4, #256]	; 0x100
		switch (conn->llcp_cu.state) {
    d98c:	f003 0303 	and.w	r3, r3, #3
    d990:	2b01      	cmp	r3, #1
    d992:	d06d      	beq.n	da70 <ull_conn_llcp+0x8c8>
    d994:	2b02      	cmp	r3, #2
    d996:	d06d      	beq.n	da74 <ull_conn_llcp+0x8cc>
			LL_ASSERT(0);
    d998:	4838      	ldr	r0, [pc, #224]	; (da7c <ull_conn_llcp+0x8d4>)
    d99a:	f01a fbd3 	bl	28144 <printk>
    d99e:	4040      	eors	r0, r0
    d9a0:	f380 8811 	msr	BASEPRI, r0
    d9a4:	f04f 0003 	mov.w	r0, #3
    d9a8:	df02      	svc	2
		void (*fp_mfy_select_or_use)(void *) = NULL;
    d9aa:	2200      	movs	r2, #0
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
    d9ac:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
    d9b0:	f36f 0301 	bfc	r3, #0, #2
    d9b4:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
    d9b8:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    d9ba:	441e      	add	r6, r3
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    d9bc:	792b      	ldrb	r3, [r5, #4]
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
    d9be:	3606      	adds	r6, #6
    d9c0:	b2b6      	uxth	r6, r6
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    d9c2:	f043 0303 	orr.w	r3, r3, #3
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
    d9c6:	f8a4 60ec 	strh.w	r6, [r4, #236]	; 0xec
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    d9ca:	712b      	strb	r3, [r5, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_update_ind) +
    d9cc:	230c      	movs	r3, #12
    d9ce:	716b      	strb	r3, [r5, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND;
    d9d0:	2300      	movs	r3, #0
    d9d2:	71eb      	strb	r3, [r5, #7]
	pdu_ctrl_tx->llctrl.conn_update_ind.win_size = conn->llcp_cu.win_size;
    d9d4:	f894 3114 	ldrb.w	r3, [r4, #276]	; 0x114
    d9d8:	722b      	strb	r3, [r5, #8]
	pdu_ctrl_tx->llctrl.conn_update_ind.win_offset =
    d9da:	f240 41e2 	movw	r1, #1250	; 0x4e2
		sys_cpu_to_le16(conn->llcp_cu.win_offset_us / 1250U);
    d9de:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
	pdu_ctrl_tx->llctrl.conn_update_ind.win_offset =
    d9e2:	fbb3 f3f1 	udiv	r3, r3, r1
    d9e6:	f8a5 3009 	strh.w	r3, [r5, #9]
	pdu_ctrl_tx->llctrl.conn_update_ind.interval =
    d9ea:	f8b4 3108 	ldrh.w	r3, [r4, #264]	; 0x108
    d9ee:	f8a5 300b 	strh.w	r3, [r5, #11]
	pdu_ctrl_tx->llctrl.conn_update_ind.latency =
    d9f2:	f8b4 310a 	ldrh.w	r3, [r4, #266]	; 0x10a
    d9f6:	f8a5 300d 	strh.w	r3, [r5, #13]
	pdu_ctrl_tx->llctrl.conn_update_ind.timeout =
    d9fa:	f8b4 310c 	ldrh.w	r3, [r4, #268]	; 0x10c
    d9fe:	f8a5 300f 	strh.w	r3, [r5, #15]
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
    da02:	6823      	ldr	r3, [r4, #0]
	pdu_ctrl_tx->llctrl.conn_update_ind.instant =
    da04:	f8a5 6011 	strh.w	r6, [r5, #17]
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
    da08:	2b00      	cmp	r3, #0
		conn->llcp.conn_upd.ticks_anchor = ticks_at_expire;
    da0a:	f8c4 70f4 	str.w	r7, [r4, #244]	; 0xf4
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
    da0e:	da0a      	bge.n	da26 <ull_conn_llcp+0x87e>
			u32_t ticks_prepare_to_start =
    da10:	e9d4 1001 	ldrd	r1, r0, [r4, #4]
				(conn->evt.ticks_xtal_to_start &
    da14:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
			conn->llcp.conn_upd.ticks_anchor -=
    da18:	4288      	cmp	r0, r1
    da1a:	bf2c      	ite	cs
    da1c:	183f      	addcs	r7, r7, r0
    da1e:	187f      	addcc	r7, r7, r1
    da20:	1aff      	subs	r7, r7, r3
    da22:	f8c4 70f4 	str.w	r7, [r4, #244]	; 0xf4
		conn->llcp.conn_upd.pdu_win_offset = (u16_t *)
    da26:	f105 0309 	add.w	r3, r5, #9
    da2a:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
		mfy_sched_offset->fp = fp_mfy_select_or_use;
    da2e:	4b15      	ldr	r3, [pc, #84]	; (da84 <ull_conn_llcp+0x8dc>)
		mfy_sched_offset->param = (void *)conn;
    da30:	e9c3 4202 	strd	r4, r2, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
    da34:	2201      	movs	r2, #1
    da36:	2102      	movs	r1, #2
    da38:	4610      	mov	r0, r2
    da3a:	f00d fecb 	bl	1b7d4 <mayfly_enqueue>
		LL_ASSERT(!retval);
    da3e:	b140      	cbz	r0, da52 <ull_conn_llcp+0x8aa>
    da40:	4811      	ldr	r0, [pc, #68]	; (da88 <ull_conn_llcp+0x8e0>)
    da42:	f01a fb7f 	bl	28144 <printk>
    da46:	4040      	eors	r0, r0
    da48:	f380 8811 	msr	BASEPRI, r0
    da4c:	f04f 0003 	mov.w	r0, #3
    da50:	df02      	svc	2
			ctrl_tx_enqueue(conn, tx);
    da52:	4629      	mov	r1, r5
    da54:	4620      	mov	r0, r4
    da56:	f01e fc85 	bl	2c364 <ctrl_tx_enqueue>
	if (conn->llcp_terminate.ack != conn->llcp_terminate.req) {
    da5a:	f894 2129 	ldrb.w	r2, [r4, #297]	; 0x129
    da5e:	f894 3128 	ldrb.w	r3, [r4, #296]	; 0x128
    da62:	429a      	cmp	r2, r3
    da64:	f040 84c4 	bne.w	e3f0 <ull_conn_llcp+0x1248>
	return 0;
    da68:	2000      	movs	r0, #0
}
    da6a:	b00d      	add	sp, #52	; 0x34
    da6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			fp_mfy_select_or_use = ull_sched_mfy_win_offset_use;
    da70:	4a06      	ldr	r2, [pc, #24]	; (da8c <ull_conn_llcp+0x8e4>)
    da72:	e79b      	b.n	d9ac <ull_conn_llcp+0x804>
			fp_mfy_select_or_use = ull_sched_mfy_win_offset_select;
    da74:	4a06      	ldr	r2, [pc, #24]	; (da90 <ull_conn_llcp+0x8e8>)
    da76:	e799      	b.n	d9ac <ull_conn_llcp+0x804>
    da78:	200034bc 	.word	0x200034bc
    da7c:	000314f5 	.word	0x000314f5
    da80:	20003184 	.word	0x20003184
    da84:	2000fd50 	.word	0x2000fd50
    da88:	0003169c 	.word	0x0003169c
    da8c:	0002ca37 	.word	0x0002ca37
    da90:	0002ca39 	.word	0x0002ca39
	instant_latency = (event_counter - conn->llcp.conn_upd.instant) &
    da94:	f8b4 30ec 	ldrh.w	r3, [r4, #236]	; 0xec
    da98:	930a      	str	r3, [sp, #40]	; 0x28
    da9a:	eba6 0803 	sub.w	r8, r6, r3
    da9e:	fa1f f888 	uxth.w	r8, r8
	} else if (instant_latency <= 0x7FFF) {
    daa2:	f418 4f00 	tst.w	r8, #32768	; 0x8000
    daa6:	d1d8      	bne.n	da5a <ull_conn_llcp+0x8b2>
		conn->llcp_cu.ack = conn->llcp_cu.req;
    daa8:	f894 3104 	ldrb.w	r3, [r4, #260]	; 0x104
    daac:	f884 3105 	strb.w	r3, [r4, #261]	; 0x105
		conn->llcp_ack = conn->llcp_req;
    dab0:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
    dab4:	f894 3171 	ldrb.w	r3, [r4, #369]	; 0x171
    dab8:	f894 2170 	ldrb.w	r2, [r4, #368]	; 0x170
    dabc:	4293      	cmp	r3, r2
    dabe:	d009      	beq.n	dad4 <ull_conn_llcp+0x92c>
		    (conn->llcp_conn_param.state == LLCP_CPR_STATE_UPD)) {
    dac0:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
    dac4:	f003 0307 	and.w	r3, r3, #7
    dac8:	2b05      	cmp	r3, #5
			conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
    daca:	bf04      	itt	eq
    dacc:	f884 2171 	strbeq.w	r2, [r4, #369]	; 0x171
			conn->procedure_expire = 0U;
    dad0:	f8a4 00cc 	strheq.w	r0, [r4, #204]	; 0xcc
		if (conn_upd_curr == conn) {
    dad4:	680b      	ldr	r3, [r1, #0]
		rx = conn->llcp_rx;
    dad6:	f8d4 5100 	ldr.w	r5, [r4, #256]	; 0x100
		if (conn_upd_curr == conn) {
    dada:	429c      	cmp	r4, r3
			conn_upd_curr = NULL;
    dadc:	bf04      	itt	eq
    dade:	2300      	moveq	r3, #0
    dae0:	600b      	streq	r3, [r1, #0]
		LL_ASSERT(rx && rx->hdr.link);
    dae2:	b10d      	cbz	r5, dae8 <ull_conn_llcp+0x940>
    dae4:	682b      	ldr	r3, [r5, #0]
    dae6:	b943      	cbnz	r3, dafa <ull_conn_llcp+0x952>
    dae8:	48bd      	ldr	r0, [pc, #756]	; (dde0 <ull_conn_llcp+0xc38>)
    daea:	f01a fb2b 	bl	28144 <printk>
    daee:	4040      	eors	r0, r0
    daf0:	f380 8811 	msr	BASEPRI, r0
    daf4:	f04f 0003 	mov.w	r0, #3
    daf8:	df02      	svc	2
		conn->llcp_rx = rx->hdr.link->mem;
    dafa:	6828      	ldr	r0, [r5, #0]
		if ((conn->llcp_cu.interval != lll->interval) ||
    dafc:	f8b4 2108 	ldrh.w	r2, [r4, #264]	; 0x108
		conn->llcp_rx = rx->hdr.link->mem;
    db00:	6843      	ldr	r3, [r0, #4]
    db02:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
		if ((conn->llcp_cu.interval != lll->interval) ||
    db06:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
    db08:	f8b4 c10a 	ldrh.w	ip, [r4, #266]	; 0x10a
    db0c:	f8b4 110c 	ldrh.w	r1, [r4, #268]	; 0x10c
    db10:	429a      	cmp	r2, r3
    db12:	d113      	bne.n	db3c <ull_conn_llcp+0x994>
    db14:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    db16:	4563      	cmp	r3, ip
    db18:	d110      	bne.n	db3c <ull_conn_llcp+0x994>
		    (RADIO_CONN_EVENTS(conn->llcp_cu.timeout * 10000U,
    db1a:	f240 43e2 	movw	r3, #1250	; 0x4e2
    db1e:	fb03 fe02 	mul.w	lr, r3, r2
    db22:	f242 7310 	movw	r3, #10000	; 0x2710
    db26:	fb03 e301 	mla	r3, r3, r1, lr
    db2a:	3b01      	subs	r3, #1
    db2c:	fbb3 f3fe 	udiv	r3, r3, lr
		    (conn->llcp_cu.latency != lll->latency) ||
    db30:	f8b4 e0c6 	ldrh.w	lr, [r4, #198]	; 0xc6
    db34:	b29b      	uxth	r3, r3
    db36:	459e      	cmp	lr, r3
    db38:	f000 812e 	beq.w	dd98 <ull_conn_llcp+0xbf0>
			rx->hdr.handle = lll->handle;
    db3c:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    db3e:	80eb      	strh	r3, [r5, #6]
			rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
    db40:	230a      	movs	r3, #10
    db42:	712b      	strb	r3, [r5, #4]
			cu->status = 0x00;
    db44:	2300      	movs	r3, #0
    db46:	f885 3020 	strb.w	r3, [r5, #32]
			cu->interval = conn->llcp_cu.interval;
    db4a:	846a      	strh	r2, [r5, #34]	; 0x22
			cu->latency = conn->llcp_cu.latency;
    db4c:	f8a5 c024 	strh.w	ip, [r5, #36]	; 0x24
			cu->timeout = conn->llcp_cu.timeout;
    db50:	84e9      	strh	r1, [r5, #38]	; 0x26
		ll_rx_put(rx->hdr.link, rx);
    db52:	4629      	mov	r1, r5
    db54:	f010 fbfe 	bl	1e354 <ll_rx_put>
		ll_rx_sched();
    db58:	f010 fc06 	bl	1e368 <ll_rx_sched>
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
    db5c:	6823      	ldr	r3, [r4, #0]
    db5e:	2b00      	cmp	r3, #0
    db60:	da09      	bge.n	db76 <ull_conn_llcp+0x9ce>
			u32_t ticks_prepare_to_start =
    db62:	e9d4 2001 	ldrd	r2, r0, [r4, #4]
			conn->evt.ticks_xtal_to_start &= ~XON_BITMASK;
    db66:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
			ticks_at_expire -= (conn->evt.ticks_xtal_to_start -
    db6a:	4290      	cmp	r0, r2
    db6c:	bf2c      	ite	cs
    db6e:	183f      	addcs	r7, r7, r0
    db70:	18bf      	addcc	r7, r7, r2
			conn->evt.ticks_xtal_to_start &= ~XON_BITMASK;
    db72:	6023      	str	r3, [r4, #0]
			ticks_at_expire -= (conn->evt.ticks_xtal_to_start -
    db74:	1aff      	subs	r7, r7, r3
		conn_interval_old = instant_latency * lll->interval;
    db76:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
		latency = conn_interval_old / conn->llcp_cu.interval;
    db78:	f8b4 5108 	ldrh.w	r5, [r4, #264]	; 0x108
    db7c:	f8df 9288 	ldr.w	r9, [pc, #648]	; de08 <ull_conn_llcp+0xc60>
		conn_interval_old = instant_latency * lll->interval;
    db80:	fb13 f308 	smulbb	r3, r3, r8
    db84:	b29b      	uxth	r3, r3
		latency = conn_interval_old / conn->llcp_cu.interval;
    db86:	fbb3 f1f5 	udiv	r1, r3, r5
    db8a:	fa1f fa81 	uxth.w	sl, r1
		conn_interval_new = latency * conn->llcp_cu.interval;
    db8e:	fb15 f20a 	smulbb	r2, r5, sl
    db92:	b292      	uxth	r2, r2
		if (conn_interval_new > conn_interval_old) {
    db94:	4293      	cmp	r3, r2
    db96:	f240 40e2 	movw	r0, #1250	; 0x4e2
    db9a:	f080 8100 	bcs.w	dd9e <ull_conn_llcp+0xbf6>
			ticks_at_expire += HAL_TICKER_US_TO_TICKS(
    db9e:	1ad3      	subs	r3, r2, r3
    dba0:	4358      	muls	r0, r3
    dba2:	fba0 0109 	umull	r0, r1, r0, r9
    dba6:	a38c      	add	r3, pc, #560	; (adr r3, ddd8 <ull_conn_llcp+0xc30>)
    dba8:	e9d3 2300 	ldrd	r2, r3, [r3]
    dbac:	f7fe fba8 	bl	c300 <__aeabi_uldivmod>
    dbb0:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    dbb4:	4407      	add	r7, r0
		lll->latency_prepare += lazy;
    dbb6:	8e63      	ldrh	r3, [r4, #50]	; 0x32
    dbb8:	449b      	add	fp, r3
		lll->latency_prepare -= (instant_latency - latency);
    dbba:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    dbbc:	1b9e      	subs	r6, r3, r6
		} else if (lll->role) {
    dbbe:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
		lll->latency_prepare -= (instant_latency - latency);
    dbc2:	4456      	add	r6, sl
    dbc4:	445e      	add	r6, fp
		} else if (lll->role) {
    dbc6:	2b00      	cmp	r3, #0
		conn_interval_us = conn->llcp_cu.interval * 1250U;
    dbc8:	f240 4be2 	movw	fp, #1250	; 0x4e2
		lll->latency_prepare -= (instant_latency - latency);
    dbcc:	8666      	strh	r6, [r4, #50]	; 0x32
		conn_interval_us = conn->llcp_cu.interval * 1250U;
    dbce:	fb0b f505 	mul.w	r5, fp, r5
		} else if (lll->role) {
    dbd2:	f280 80f1 	bge.w	ddb8 <ull_conn_llcp+0xc10>
			lll->slave.window_widening_prepare_us -=
    dbd6:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
				lll->slave.window_widening_periodic_us *
    dbd8:	6c63      	ldr	r3, [r4, #68]	; 0x44
			lll->slave.window_widening_prepare_us -=
    dbda:	fb03 2318 	mls	r3, r3, r8, r2
    dbde:	64e3      	str	r3, [r4, #76]	; 0x4c
				(((lll_conn_ppm_local_get() +
    dbe0:	f01e fda5 	bl	2c72e <lll_conn_ppm_local_get>
    dbe4:	4606      	mov	r6, r0
				   lll_conn_ppm_get(conn->slave.sca)) *
    dbe6:	f894 00dc 	ldrb.w	r0, [r4, #220]	; 0xdc
    dbea:	f3c0 0082 	ubfx	r0, r0, #2, #3
    dbee:	f014 fd9f 	bl	22730 <lll_conn_ppm_get>
				conn->llcp_cu.win_size * 1250U;
    dbf2:	f894 2114 	ldrb.w	r2, [r4, #276]	; 0x114
				(((lll_conn_ppm_local_get() +
    dbf6:	4406      	add	r6, r0
				conn->llcp_cu.win_size * 1250U;
    dbf8:	fb0b f202 	mul.w	r2, fp, r2
			lll->slave.window_size_prepare_us =
    dbfc:	6562      	str	r2, [r4, #84]	; 0x54
				   lll_conn_ppm_get(conn->slave.sca)) *
    dbfe:	436e      	muls	r6, r5
			conn->slave.ticks_to_offset = 0U;
    dc00:	2200      	movs	r2, #0
    dc02:	f8c4 20e4 	str.w	r2, [r4, #228]	; 0xe4
				  conn_interval_us) + (1000000 - 1)) / 1000000U;
    dc06:	f506 2674 	add.w	r6, r6, #999424	; 0xf4000
			lll->slave.window_widening_prepare_us +=
    dc0a:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
				  conn_interval_us) + (1000000 - 1)) / 1000000U;
    dc0c:	4875      	ldr	r0, [pc, #468]	; (dde4 <ull_conn_llcp+0xc3c>)
    dc0e:	f206 263f 	addw	r6, r6, #575	; 0x23f
				(conn_interval_us >> 1) - EVENT_IFS_US;
    dc12:	086b      	lsrs	r3, r5, #1
				  conn_interval_us) + (1000000 - 1)) / 1000000U;
    dc14:	fbb6 f6f0 	udiv	r6, r6, r0
				lll->slave.window_widening_periodic_us *
    dc18:	fb06 f00a 	mul.w	r0, r6, sl
				(conn_interval_us >> 1) - EVENT_IFS_US;
    dc1c:	3b96      	subs	r3, #150	; 0x96
			lll->slave.window_widening_prepare_us +=
    dc1e:	4402      	add	r2, r0
			lll->slave.window_widening_max_us =
    dc20:	64a3      	str	r3, [r4, #72]	; 0x48
			lll->slave.window_widening_prepare_us +=
    dc22:	429a      	cmp	r2, r3
    dc24:	bf94      	ite	ls
    dc26:	64e2      	strls	r2, [r4, #76]	; 0x4c
    dc28:	64e3      	strhi	r3, [r4, #76]	; 0x4c
			lll->slave.window_widening_periodic_us =
    dc2a:	6466      	str	r6, [r4, #68]	; 0x44
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
    dc2c:	a36a      	add	r3, pc, #424	; (adr r3, ddd8 <ull_conn_llcp+0xc30>)
    dc2e:	e9d3 2300 	ldrd	r2, r3, [r3]
    dc32:	fba0 0109 	umull	r0, r1, r0, r9
    dc36:	f7fe fb63 	bl	c300 <__aeabi_uldivmod>
    dc3a:	1a3f      	subs	r7, r7, r0
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
    dc3c:	f8d4 0110 	ldr.w	r0, [r4, #272]	; 0x110
    dc40:	fbb0 f0fb 	udiv	r0, r0, fp
    dc44:	fb0b f000 	mul.w	r0, fp, r0
    dc48:	a363      	add	r3, pc, #396	; (adr r3, ddd8 <ull_conn_llcp+0xc30>)
    dc4a:	e9d3 2300 	ldrd	r2, r3, [r3]
    dc4e:	fba0 0109 	umull	r0, r1, r0, r9
    dc52:	f7fe fb55 	bl	c300 <__aeabi_uldivmod>
			periodic_us -= lll->slave.window_widening_periodic_us;
    dc56:	eba5 0806 	sub.w	r8, r5, r6
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
    dc5a:	f020 4a7f 	bic.w	sl, r0, #4278190080	; 0xff000000
		lll->interval = conn->llcp_cu.interval;
    dc5e:	f8b4 3108 	ldrh.w	r3, [r4, #264]	; 0x108
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
    dc62:	f8b4 210c 	ldrh.w	r2, [r4, #268]	; 0x10c
		lll->interval = conn->llcp_cu.interval;
    dc66:	85e3      	strh	r3, [r4, #46]	; 0x2e
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
    dc68:	f242 7310 	movw	r3, #10000	; 0x2710
    dc6c:	fb03 5202 	mla	r2, r3, r2, r5
		lll->latency = conn->llcp_cu.latency;
    dc70:	f8b4 110a 	ldrh.w	r1, [r4, #266]	; 0x10a
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    dc74:	4b5c      	ldr	r3, [pc, #368]	; (dde8 <ull_conn_llcp+0xc40>)
		lll->latency = conn->llcp_cu.latency;
    dc76:	8621      	strh	r1, [r4, #48]	; 0x30
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
    dc78:	3a01      	subs	r2, #1
    dc7a:	fbb2 f2f5 	udiv	r2, r2, r5
    dc7e:	f8a4 20c6 	strh.w	r2, [r4, #198]	; 0xc6
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    dc82:	4a5a      	ldr	r2, [pc, #360]	; (ddec <ull_conn_llcp+0xc44>)
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    dc84:	442b      	add	r3, r5
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    dc86:	442a      	add	r2, r5
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    dc88:	fbb3 f3f5 	udiv	r3, r3, r5
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    dc8c:	fbb2 f5f5 	udiv	r5, r2, r5
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    dc90:	f8a4 30ca 	strh.w	r3, [r4, #202]	; 0xca
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    dc94:	1d8a      	adds	r2, r1, #6
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    dc96:	b2ab      	uxth	r3, r5
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    dc98:	4293      	cmp	r3, r2
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    dc9a:	f8a4 30d2 	strh.w	r3, [r4, #210]	; 0xd2
				     (conn->apto_reload - (lll->latency + 6)) :
    dc9e:	bfc2      	ittt	gt
    dca0:	1a5b      	subgt	r3, r3, r1
    dca2:	3b06      	subgt	r3, #6
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    dca4:	b29b      	uxthgt	r3, r3
    dca6:	f8a4 30ce 	strh.w	r3, [r4, #206]	; 0xce
		if (conn->llcp_cu.cmd) {
    dcaa:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
    dcae:	0758      	lsls	r0, r3, #29
			conn->supervision_expire = 0U;
    dcb0:	bf44      	itt	mi
    dcb2:	2300      	movmi	r3, #0
    dcb4:	f8a4 30c8 	strhmi.w	r3, [r4, #200]	; 0xc8
			mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH,
    dcb8:	2102      	movs	r1, #2
    dcba:	2001      	movs	r0, #1
    dcbc:	f017 f9c2 	bl	25044 <mayfly_is_enabled>
		mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW,
    dcc0:	2200      	movs	r2, #0
    dcc2:	2102      	movs	r1, #2
			mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH,
    dcc4:	4606      	mov	r6, r0
		mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW,
    dcc6:	2001      	movs	r0, #1
    dcc8:	f00d fd5c 	bl	1b784 <mayfly_enable>
		ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    dccc:	4620      	mov	r0, r4
    dcce:	f012 fc57 	bl	20580 <ll_conn_handle_get>
    dcd2:	3005      	adds	r0, #5
    dcd4:	b2c5      	uxtb	r5, r0
		ticker_status =	ticker_stop(TICKER_INSTANCE_ID_CTLR,
    dcd6:	4b46      	ldr	r3, [pc, #280]	; (ddf0 <ull_conn_llcp+0xc48>)
    dcd8:	9400      	str	r4, [sp, #0]
    dcda:	462a      	mov	r2, r5
    dcdc:	2101      	movs	r1, #1
    dcde:	2000      	movs	r0, #0
    dce0:	f00e fa7c 	bl	1c1dc <ticker_stop>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
    dce4:	f030 0302 	bics.w	r3, r0, #2
    dce8:	d008      	beq.n	dcfc <ull_conn_llcp+0xb54>
    dcea:	4842      	ldr	r0, [pc, #264]	; (ddf4 <ull_conn_llcp+0xc4c>)
    dcec:	f01a fa2a 	bl	28144 <printk>
    dcf0:	4040      	eors	r0, r0
    dcf2:	f380 8811 	msr	BASEPRI, r0
    dcf6:	f04f 0003 	mov.w	r0, #3
    dcfa:	df02      	svc	2
				     HAL_TICKER_US_TO_TICKS(periodic_us),
    dcfc:	fba8 2309 	umull	r2, r3, r8, r9
    dd00:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    dd04:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    dd08:	a333      	add	r3, pc, #204	; (adr r3, ddd8 <ull_conn_llcp+0xc30>)
    dd0a:	e9d3 2300 	ldrd	r2, r3, [r3]
    dd0e:	f7fe faf7 	bl	c300 <__aeabi_uldivmod>
				     HAL_TICKER_REMAINDER(periodic_us),
    dd12:	4b39      	ldr	r3, [pc, #228]	; (ddf8 <ull_conn_llcp+0xc50>)
    dd14:	990a      	ldr	r1, [sp, #40]	; 0x28
			ticker_start(TICKER_INSTANCE_ID_CTLR,
    dd16:	f020 4b7f 	bic.w	fp, r0, #4278190080	; 0xff000000
				     HAL_TICKER_REMAINDER(periodic_us),
    dd1a:	fbab 8903 	umull	r8, r9, fp, r3
    dd1e:	ebb1 0008 	subs.w	r0, r1, r8
    dd22:	f04f 0307 	mov.w	r3, #7
    dd26:	990b      	ldr	r1, [sp, #44]	; 0x2c
    dd28:	fb03 990b 	mla	r9, r3, fp, r9
    dd2c:	eb61 0109 	sbc.w	r1, r1, r9
    dd30:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    dd34:	2300      	movs	r3, #0
    dd36:	f7fe fae3 	bl	c300 <__aeabi_uldivmod>
			ticker_start(TICKER_INSTANCE_ID_CTLR,
    dd3a:	f994 c03d 	ldrsb.w	ip, [r4, #61]	; 0x3d
    dd3e:	492f      	ldr	r1, [pc, #188]	; (ddfc <ull_conn_llcp+0xc54>)
    dd40:	4b2f      	ldr	r3, [pc, #188]	; (de00 <ull_conn_llcp+0xc58>)
				      conn->evt.ticks_slot),
    dd42:	68e2      	ldr	r2, [r4, #12]
			ticker_start(TICKER_INSTANCE_ID_CTLR,
    dd44:	9408      	str	r4, [sp, #32]
    dd46:	ea13 032c 	ands.w	r3, r3, ip, asr #32
    dd4a:	bf38      	it	cc
    dd4c:	460b      	movcc	r3, r1
    dd4e:	492d      	ldr	r1, [pc, #180]	; (de04 <ull_conn_llcp+0xc5c>)
    dd50:	e9cd 4106 	strd	r4, r1, [sp, #24]
    dd54:	2400      	movs	r4, #0
    dd56:	e9cd 2304 	strd	r2, r3, [sp, #16]
    dd5a:	e9cd 0402 	strd	r0, r4, [sp, #8]
    dd5e:	463b      	mov	r3, r7
    dd60:	e9cd ab00 	strd	sl, fp, [sp]
    dd64:	462a      	mov	r2, r5
    dd66:	2101      	movs	r1, #1
    dd68:	4620      	mov	r0, r4
    dd6a:	f00e f9a5 	bl	1c0b8 <ticker_start>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
    dd6e:	f030 0302 	bics.w	r3, r0, #2
    dd72:	d008      	beq.n	dd86 <ull_conn_llcp+0xbde>
    dd74:	481f      	ldr	r0, [pc, #124]	; (ddf4 <ull_conn_llcp+0xc4c>)
    dd76:	f01a f9e5 	bl	28144 <printk>
    dd7a:	4040      	eors	r0, r0
    dd7c:	f380 8811 	msr	BASEPRI, r0
    dd80:	f04f 0003 	mov.w	r0, #3
    dd84:	df02      	svc	2
		if (mayfly_was_enabled) {
    dd86:	b126      	cbz	r6, dd92 <ull_conn_llcp+0xbea>
			mayfly_enable(TICKER_USER_ID_ULL_HIGH,
    dd88:	2201      	movs	r2, #1
    dd8a:	2102      	movs	r1, #2
    dd8c:	4610      	mov	r0, r2
    dd8e:	f00d fcf9 	bl	1b784 <mayfly_enable>
				return -ECANCELED;
    dd92:	f06f 0047 	mvn.w	r0, #71	; 0x47
    dd96:	e668      	b.n	da6a <ull_conn_llcp+0x8c2>
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
    dd98:	2303      	movs	r3, #3
    dd9a:	712b      	strb	r3, [r5, #4]
    dd9c:	e6d9      	b.n	db52 <ull_conn_llcp+0x9aa>
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
    dd9e:	fb05 3111 	mls	r1, r5, r1, r3
    dda2:	b289      	uxth	r1, r1
    dda4:	4348      	muls	r0, r1
    dda6:	a30c      	add	r3, pc, #48	; (adr r3, ddd8 <ull_conn_llcp+0xc30>)
    dda8:	e9d3 2300 	ldrd	r2, r3, [r3]
    ddac:	fba0 0109 	umull	r0, r1, r0, r9
    ddb0:	f7fe faa6 	bl	c300 <__aeabi_uldivmod>
    ddb4:	1a3f      	subs	r7, r7, r0
    ddb6:	e6fe      	b.n	dbb6 <ull_conn_llcp+0xa0e>
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
    ddb8:	f8d4 0110 	ldr.w	r0, [r4, #272]	; 0x110
    ddbc:	a306      	add	r3, pc, #24	; (adr r3, ddd8 <ull_conn_llcp+0xc30>)
    ddbe:	e9d3 2300 	ldrd	r2, r3, [r3]
    ddc2:	fba0 0109 	umull	r0, r1, r0, r9
    ddc6:	f7fe fa9b 	bl	c300 <__aeabi_uldivmod>
    ddca:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			ticks_win_offset += 1U;
    ddce:	f100 0a01 	add.w	sl, r0, #1
		periodic_us = conn_interval_us;
    ddd2:	46a8      	mov	r8, r5
    ddd4:	e743      	b.n	dc5e <ull_conn_llcp+0xab6>
    ddd6:	bf00      	nop
    ddd8:	1afd498d 	.word	0x1afd498d
    dddc:	00000007 	.word	0x00000007
    dde0:	00031ded 	.word	0x00031ded
    dde4:	000f4240 	.word	0x000f4240
    dde8:	026259ff 	.word	0x026259ff
    ddec:	01c9c37f 	.word	0x01c9c37f
    ddf0:	00020301 	.word	0x00020301
    ddf4:	00031c28 	.word	0x00031c28
    ddf8:	1afd498d 	.word	0x1afd498d
    ddfc:	00022f41 	.word	0x00022f41
    de00:	00022c95 	.word	0x00022c95
    de04:	000202d1 	.word	0x000202d1
    de08:	3b9aca00 	.word	0x3b9aca00
			event_counter = lll->event_counter +
    de0c:	8e61      	ldrh	r1, [r4, #50]	; 0x32
    de0e:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    de10:	440b      	add	r3, r1
					lll->latency_prepare + lazy;
    de12:	449b      	add	fp, r3
	if (conn->llcp.chan_map.initiate) {
    de14:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    de18:	07d9      	lsls	r1, r3, #31
			event_counter = lll->event_counter +
    de1a:	fa1f fb8b 	uxth.w	fp, fp
	if (conn->llcp.chan_map.initiate) {
    de1e:	d525      	bpl.n	de6c <ull_conn_llcp+0xcc4>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    de20:	48cb      	ldr	r0, [pc, #812]	; (e150 <ull_conn_llcp+0xfa8>)
    de22:	f01d fd85 	bl	2b930 <mem_acquire>
		if (tx) {
    de26:	4605      	mov	r5, r0
    de28:	2800      	cmp	r0, #0
    de2a:	f43f ae16 	beq.w	da5a <ull_conn_llcp+0x8b2>
			conn->llcp.chan_map.initiate = 0U;
    de2e:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    de32:	f36f 0300 	bfc	r3, #0, #1
    de36:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
			conn->llcp.chan_map.instant = event_counter +
    de3a:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    de3c:	449b      	add	fp, r3
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    de3e:	7903      	ldrb	r3, [r0, #4]
						      conn->lll.latency + 6;
    de40:	f10b 0b06 	add.w	fp, fp, #6
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    de44:	f043 0303 	orr.w	r3, r3, #3
			conn->llcp.chan_map.instant = event_counter +
    de48:	f8a4 b0f2 	strh.w	fp, [r4, #242]	; 0xf2
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    de4c:	7103      	strb	r3, [r0, #4]
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
    de4e:	2308      	movs	r3, #8
    de50:	7143      	strb	r3, [r0, #5]
			pdu_ctrl_tx->llctrl.opcode =
    de52:	2301      	movs	r3, #1
    de54:	71c3      	strb	r3, [r0, #7]
			memcpy(&pdu_ctrl_tx->llctrl.chan_map_ind.chm[0],
    de56:	2205      	movs	r2, #5
    de58:	f104 01ed 	add.w	r1, r4, #237	; 0xed
    de5c:	3008      	adds	r0, #8
    de5e:	f01c faf6 	bl	2a44e <memcpy>
			pdu_ctrl_tx->llctrl.chan_map_ind.instant =
    de62:	f8b4 30f2 	ldrh.w	r3, [r4, #242]	; 0xf2
    de66:	f8a5 300d 	strh.w	r3, [r5, #13]
    de6a:	e5f2      	b.n	da52 <ull_conn_llcp+0x8aa>
	} else if (((event_counter - conn->llcp.chan_map.instant) & 0xFFFF)
    de6c:	f8b4 30f2 	ldrh.w	r3, [r4, #242]	; 0xf2
    de70:	ebab 0b03 	sub.w	fp, fp, r3
    de74:	f41b 4f00 	tst.w	fp, #32768	; 0x8000
    de78:	f47f adef 	bne.w	da5a <ull_conn_llcp+0x8b2>
		memcpy(&lll->data_chan_map[0],
    de7c:	f104 0538 	add.w	r5, r4, #56	; 0x38
		conn->llcp_ack = conn->llcp_req;
    de80:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
		memcpy(&lll->data_chan_map[0],
    de84:	f104 01ed 	add.w	r1, r4, #237	; 0xed
    de88:	2205      	movs	r2, #5
    de8a:	4628      	mov	r0, r5
    de8c:	f01c fadf 	bl	2a44e <memcpy>
			util_ones_count_get(&lll->data_chan_map[0],
    de90:	2105      	movs	r1, #5
    de92:	4628      	mov	r0, r5
    de94:	f01d fdc8 	bl	2ba28 <util_ones_count_get>
		lll->data_chan_count =
    de98:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
    de9c:	f360 0305 	bfi	r3, r0, #0, #6
    dea0:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
		conn->chm_updated = 1U;
    dea4:	2301      	movs	r3, #1
    dea6:	f884 31c4 	strb.w	r3, [r4, #452]	; 0x1c4
    deaa:	e5d6      	b.n	da5a <ull_conn_llcp+0x8b2>
	if (conn->llcp.encryption.state) {
    deac:	f894 60ec 	ldrb.w	r6, [r4, #236]	; 0xec
    deb0:	f016 0603 	ands.w	r6, r6, #3
    deb4:	d063      	beq.n	df7e <ull_conn_llcp+0xdd6>
		if (lll->role &&
    deb6:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
    deba:	2b00      	cmp	r3, #0
    debc:	f6bf adcd 	bge.w	da5a <ull_conn_llcp+0x8b2>
    dec0:	2e01      	cmp	r6, #1
    dec2:	f47f adca 	bne.w	da5a <ull_conn_llcp+0x8b2>
{
	struct pdu_data *pdu_ctrl_tx;
	struct node_tx *tx;

	/* acquire tx mem */
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    dec6:	48a2      	ldr	r0, [pc, #648]	; (e150 <ull_conn_llcp+0xfa8>)
    dec8:	f01d fd32 	bl	2b930 <mem_acquire>
	if (!tx) {
    decc:	4607      	mov	r7, r0
    dece:	2800      	cmp	r0, #0
    ded0:	f43f adc3 	beq.w	da5a <ull_conn_llcp+0x8b2>
		return -ENOBUFS;
	}

	pdu_ctrl_tx = (void *)tx->pdu;
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    ded4:	7903      	ldrb	r3, [r0, #4]
    ded6:	f043 0303 	orr.w	r3, r3, #3
    deda:	7103      	strb	r3, [r0, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp) +
    dedc:	230d      	movs	r3, #13
    dede:	7143      	strb	r3, [r0, #5]
			   sizeof(struct pdu_data_llctrl_enc_rsp);
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_RSP;
    dee0:	2304      	movs	r3, #4
    dee2:	71c3      	strb	r3, [r0, #7]
	BUILD_ASSERT(offsetof(__typeof(pdu_ctrl_tx->llctrl.enc_rsp), ivs) ==
		     (offsetof(__typeof(pdu_ctrl_tx->llctrl.enc_rsp), skds) +
		     sizeof(pdu_ctrl_tx->llctrl.enc_rsp.skds)));

	/* NOTE: if not sufficient random numbers, ignore waiting */
	entropy_get_entropy_isr(entropy, pdu_ctrl_tx->llctrl.enc_rsp.skds,
    dee4:	4b9b      	ldr	r3, [pc, #620]	; (e154 <ull_conn_llcp+0xfac>)
    dee6:	6818      	ldr	r0, [r3, #0]
					  u32_t flags)
{
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->driver_api;

	if (unlikely(!api->get_entropy_isr)) {
    dee8:	6843      	ldr	r3, [r0, #4]
    deea:	685e      	ldr	r6, [r3, #4]
    deec:	f107 0508 	add.w	r5, r7, #8
    def0:	b11e      	cbz	r6, defa <ull_conn_llcp+0xd52>
		return -ENOTSUP;
	}

	return api->get_entropy_isr(dev, buffer, length, flags);
    def2:	2300      	movs	r3, #0
    def4:	220c      	movs	r2, #12
    def6:	4629      	mov	r1, r5
    def8:	47b0      	blx	r6
				sizeof(pdu_ctrl_tx->llctrl.enc_rsp.skds) +
				sizeof(pdu_ctrl_tx->llctrl.enc_rsp.ivs), 0);

	/* things from slave stored for session key calculation */
	memcpy(&conn->llcp.encryption.skd[8],
    defa:	4629      	mov	r1, r5
    defc:	2208      	movs	r2, #8
    defe:	f104 00f6 	add.w	r0, r4, #246	; 0xf6
    df02:	f01c faa4 	bl	2a44e <memcpy>
	       &pdu_ctrl_tx->llctrl.enc_rsp.skds[0], 8);
	memcpy(&conn->lll.ccm_rx.iv[4],
    df06:	2204      	movs	r2, #4
    df08:	f107 0110 	add.w	r1, r7, #16
    df0c:	f104 009c 	add.w	r0, r4, #156	; 0x9c
    df10:	f01c fa9d 	bl	2a44e <memcpy>
	       &pdu_ctrl_tx->llctrl.enc_rsp.ivs[0], 4);

	ctrl_tx_enqueue(conn, tx);
    df14:	4639      	mov	r1, r7
    df16:	4620      	mov	r0, r4
    df18:	f01e fa24 	bl	2c364 <ctrl_tx_enqueue>
			rx = ll_pdu_rx_alloc();
    df1c:	f010 fa42 	bl	1e3a4 <ll_pdu_rx_alloc>
			if (!rx) {
    df20:	4605      	mov	r5, r0
    df22:	2800      	cmp	r0, #0
    df24:	f43f ad99 	beq.w	da5a <ull_conn_llcp+0x8b2>
			rx->hdr.handle = conn->lll.handle;
    df28:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    df2a:	80c3      	strh	r3, [r0, #6]
			pdu->ll_id = PDU_DATA_LLID_CTRL;
    df2c:	f890 3020 	ldrb.w	r3, [r0, #32]
    df30:	f043 0303 	orr.w	r3, r3, #3
    df34:	f880 3020 	strb.w	r3, [r0, #32]
			pdu->len = offsetof(struct pdu_data_llctrl, enc_req) +
    df38:	2317      	movs	r3, #23
    df3a:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
			rx->hdr.type = NODE_RX_TYPE_DC_PDU;
    df3e:	2602      	movs	r6, #2
			pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
    df40:	2303      	movs	r3, #3
    df42:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
			memcpy(&pdu->llctrl.enc_req.rand[0],
    df46:	2208      	movs	r2, #8
			rx->hdr.type = NODE_RX_TYPE_DC_PDU;
    df48:	7106      	strb	r6, [r0, #4]
			memcpy(&pdu->llctrl.enc_req.rand[0],
    df4a:	f204 1155 	addw	r1, r4, #341	; 0x155
    df4e:	3024      	adds	r0, #36	; 0x24
    df50:	f01c fa7d 	bl	2a44e <memcpy>
			pdu->llctrl.enc_req.ediv[0] = conn->llcp_enc.ediv[0];
    df54:	f894 3153 	ldrb.w	r3, [r4, #339]	; 0x153
    df58:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
			pdu->llctrl.enc_req.ediv[1] = conn->llcp_enc.ediv[1];
    df5c:	f894 3154 	ldrb.w	r3, [r4, #340]	; 0x154
    df60:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
			ll_rx_put(rx->hdr.link, rx);
    df64:	4629      	mov	r1, r5
    df66:	6828      	ldr	r0, [r5, #0]
    df68:	f010 f9f4 	bl	1e354 <ll_rx_put>
			ll_rx_sched();
    df6c:	f010 f9fc 	bl	1e368 <ll_rx_sched>
			conn->llcp.encryption.state = LLCP_ENC_STATE_LTK_WAIT;
    df70:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    df74:	f366 0301 	bfi	r3, r6, #0, #2
    df78:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
    df7c:	e56d      	b.n	da5a <ull_conn_llcp+0x8b2>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    df7e:	4874      	ldr	r0, [pc, #464]	; (e150 <ull_conn_llcp+0xfa8>)
    df80:	f01d fcd6 	bl	2b930 <mem_acquire>
	if (!tx) {
    df84:	4605      	mov	r5, r0
    df86:	2800      	cmp	r0, #0
    df88:	f43f ad67 	beq.w	da5a <ull_conn_llcp+0x8b2>
	if (!lll->role) {
    df8c:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
    df90:	2b00      	cmp	r3, #0
	pdu_ctrl_tx = (void *)tx->pdu;
    df92:	f100 0704 	add.w	r7, r0, #4
	if (!lll->role) {
    df96:	db47      	blt.n	e028 <ull_conn_llcp+0xe80>
		ecb_encrypt(&conn->llcp_enc.ltk[0],
    df98:	f104 087f 	add.w	r8, r4, #127	; 0x7f
    df9c:	4643      	mov	r3, r8
    df9e:	4632      	mov	r2, r6
    dfa0:	f104 01ee 	add.w	r1, r4, #238	; 0xee
    dfa4:	f204 105d 	addw	r0, r4, #349	; 0x15d
    dfa8:	f01e fd58 	bl	2ca5c <ecb_encrypt>
		memcpy(&lll->ccm_tx.key[0], &lll->ccm_rx.key[0],
    dfac:	2210      	movs	r2, #16
    dfae:	4641      	mov	r1, r8
    dfb0:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
    dfb4:	f01c fa4b 	bl	2a44e <memcpy>
		memcpy(&lll->ccm_tx.iv[0], &lll->ccm_rx.iv[0],
    dfb8:	f104 0198 	add.w	r1, r4, #152	; 0x98
    dfbc:	2208      	movs	r2, #8
    dfbe:	f104 00b9 	add.w	r0, r4, #185	; 0xb9
    dfc2:	f01c fa44 	bl	2a44e <memcpy>
		lll->ccm_rx.direction = 0;
    dfc6:	f894 3097 	ldrb.w	r3, [r4, #151]	; 0x97
		lll->ccm_rx.counter = 0;
    dfca:	f884 608f 	strb.w	r6, [r4, #143]	; 0x8f
		lll->ccm_rx.direction = 0;
    dfce:	f366 0300 	bfi	r3, r6, #0, #1
    dfd2:	f884 3097 	strb.w	r3, [r4, #151]	; 0x97
		lll->ccm_tx.direction = 1;
    dfd6:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
		lll->ccm_rx.counter = 0;
    dfda:	f884 6090 	strb.w	r6, [r4, #144]	; 0x90
		lll->ccm_tx.direction = 1;
    dfde:	f043 0301 	orr.w	r3, r3, #1
    dfe2:	f884 30b8 	strb.w	r3, [r4, #184]	; 0xb8
		lll->enc_rx = 1;
    dfe6:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
		lll->ccm_rx.counter = 0;
    dfea:	f884 6091 	strb.w	r6, [r4, #145]	; 0x91
		lll->enc_rx = 1;
    dfee:	f043 0308 	orr.w	r3, r3, #8
		lll->ccm_rx.counter = 0;
    dff2:	f884 6092 	strb.w	r6, [r4, #146]	; 0x92
    dff6:	f884 6093 	strb.w	r6, [r4, #147]	; 0x93
    dffa:	f884 6094 	strb.w	r6, [r4, #148]	; 0x94
    dffe:	f884 6095 	strb.w	r6, [r4, #149]	; 0x95
    e002:	f884 6096 	strb.w	r6, [r4, #150]	; 0x96
		lll->ccm_tx.counter = 0;
    e006:	e9c4 662c 	strd	r6, r6, [r4, #176]	; 0xb0
		lll->enc_rx = 1;
    e00a:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
		start_enc_rsp_send(conn, pdu_ctrl_tx);
    e00e:	4639      	mov	r1, r7
    e010:	4620      	mov	r0, r4
    e012:	f01e f9aa 	bl	2c36a <start_enc_rsp_send>
			ctrl_tx_enqueue(conn, tx);
    e016:	4629      	mov	r1, r5
    e018:	4620      	mov	r0, r4
    e01a:	f01e f9a3 	bl	2c364 <ctrl_tx_enqueue>
	conn->llcp_ack = conn->llcp_req;
    e01e:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
    e022:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
    e026:	e518      	b.n	da5a <ull_conn_llcp+0x8b2>
	else if (!lll->enc_rx) {
    e028:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
    e02c:	071b      	lsls	r3, r3, #28
    e02e:	d465      	bmi.n	e0fc <ull_conn_llcp+0xf54>
		if (conn->llcp.encryption.error_code) {
    e030:	f894 60ed 	ldrb.w	r6, [r4, #237]	; 0xed
    e034:	b1f6      	cbz	r6, e074 <ull_conn_llcp+0xecc>
	pdu->ll_id = PDU_DATA_LLID_CTRL;
    e036:	7903      	ldrb	r3, [r0, #4]
    e038:	f043 0303 	orr.w	r3, r3, #3
    e03c:	7103      	strb	r3, [r0, #4]
	if (conn->common.fex_valid &&
    e03e:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
    e042:	07df      	lsls	r7, r3, #31
    e044:	d511      	bpl.n	e06a <ull_conn_llcp+0xec2>
	    (conn->llcp_feature.features & BIT(BT_LE_FEAT_BIT_EXT_REJ_IND))) {
    e046:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
	if (conn->common.fex_valid &&
    e04a:	0758      	lsls	r0, r3, #29
    e04c:	d50d      	bpl.n	e06a <ull_conn_llcp+0xec2>
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
    e04e:	2311      	movs	r3, #17
    e050:	71eb      	strb	r3, [r5, #7]
		p->reject_opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
    e052:	2303      	movs	r3, #3
    e054:	722b      	strb	r3, [r5, #8]
		p->error_code = conn->llcp.encryption.error_code;
    e056:	726e      	strb	r6, [r5, #9]
		pdu->len = sizeof(struct pdu_data_llctrl_reject_ext_ind);
    e058:	2302      	movs	r3, #2
		pdu->len = sizeof(struct pdu_data_llctrl_reject_ind);
    e05a:	716b      	strb	r3, [r5, #5]
	pdu->len += offsetof(struct pdu_data_llctrl, reject_ind);
    e05c:	796b      	ldrb	r3, [r5, #5]
    e05e:	3301      	adds	r3, #1
    e060:	716b      	strb	r3, [r5, #5]
	conn->llcp.encryption.error_code = 0U;
    e062:	2300      	movs	r3, #0
    e064:	f884 30ed 	strb.w	r3, [r4, #237]	; 0xed
    e068:	e7d5      	b.n	e016 <ull_conn_llcp+0xe6e>
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
    e06a:	230d      	movs	r3, #13
    e06c:	71eb      	strb	r3, [r5, #7]
		p->error_code =	conn->llcp.encryption.error_code;
    e06e:	722e      	strb	r6, [r5, #8]
		pdu->len = sizeof(struct pdu_data_llctrl_reject_ind);
    e070:	2301      	movs	r3, #1
    e072:	e7f2      	b.n	e05a <ull_conn_llcp+0xeb2>
			ecb_encrypt(&conn->llcp_enc.ltk[0],
    e074:	f104 077f 	add.w	r7, r4, #127	; 0x7f
    e078:	463b      	mov	r3, r7
    e07a:	4632      	mov	r2, r6
    e07c:	f104 01ee 	add.w	r1, r4, #238	; 0xee
    e080:	f204 105d 	addw	r0, r4, #349	; 0x15d
    e084:	f01e fcea 	bl	2ca5c <ecb_encrypt>
			memcpy(&lll->ccm_tx.key[0],
    e088:	2210      	movs	r2, #16
    e08a:	4639      	mov	r1, r7
    e08c:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
    e090:	f01c f9dd 	bl	2a44e <memcpy>
			memcpy(&lll->ccm_tx.iv[0], &lll->ccm_rx.iv[0],
    e094:	2208      	movs	r2, #8
    e096:	f104 0198 	add.w	r1, r4, #152	; 0x98
    e09a:	f104 00b9 	add.w	r0, r4, #185	; 0xb9
    e09e:	f01c f9d6 	bl	2a44e <memcpy>
			lll->ccm_rx.direction = 1U;
    e0a2:	f894 3097 	ldrb.w	r3, [r4, #151]	; 0x97
			lll->ccm_rx.counter = 0U;
    e0a6:	f884 608f 	strb.w	r6, [r4, #143]	; 0x8f
			lll->ccm_rx.direction = 1U;
    e0aa:	f043 0301 	orr.w	r3, r3, #1
    e0ae:	f884 3097 	strb.w	r3, [r4, #151]	; 0x97
			lll->ccm_tx.direction = 0U;
    e0b2:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
			lll->ccm_rx.counter = 0U;
    e0b6:	f884 6090 	strb.w	r6, [r4, #144]	; 0x90
			lll->ccm_tx.direction = 0U;
    e0ba:	f366 0300 	bfi	r3, r6, #0, #1
    e0be:	f884 30b8 	strb.w	r3, [r4, #184]	; 0xb8
			lll->enc_rx = 1U;
    e0c2:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
			lll->ccm_rx.counter = 0U;
    e0c6:	f884 6091 	strb.w	r6, [r4, #145]	; 0x91
			lll->enc_rx = 1U;
    e0ca:	f043 0308 	orr.w	r3, r3, #8
    e0ce:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    e0d2:	792b      	ldrb	r3, [r5, #4]
			lll->ccm_rx.counter = 0U;
    e0d4:	f884 6092 	strb.w	r6, [r4, #146]	; 0x92
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    e0d8:	f043 0303 	orr.w	r3, r3, #3
			lll->ccm_rx.counter = 0U;
    e0dc:	f884 6093 	strb.w	r6, [r4, #147]	; 0x93
    e0e0:	f884 6094 	strb.w	r6, [r4, #148]	; 0x94
    e0e4:	f884 6095 	strb.w	r6, [r4, #149]	; 0x95
    e0e8:	f884 6096 	strb.w	r6, [r4, #150]	; 0x96
			lll->ccm_tx.counter = 0U;
    e0ec:	e9c4 662c 	strd	r6, r6, [r4, #176]	; 0xb0
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    e0f0:	712b      	strb	r3, [r5, #4]
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
    e0f2:	2301      	movs	r3, #1
    e0f4:	716b      	strb	r3, [r5, #5]
			pdu_ctrl_tx->llctrl.opcode =
    e0f6:	2305      	movs	r3, #5
    e0f8:	71eb      	strb	r3, [r5, #7]
			ctrl_tx_enqueue(conn, tx);
    e0fa:	e78c      	b.n	e016 <ull_conn_llcp+0xe6e>
		start_enc_rsp_send(conn, pdu_ctrl_tx);
    e0fc:	4639      	mov	r1, r7
    e0fe:	4620      	mov	r0, r4
    e100:	f01e f933 	bl	2c36a <start_enc_rsp_send>
		ctrl_tx_enqueue(conn, tx);
    e104:	4629      	mov	r1, r5
    e106:	4620      	mov	r0, r4
    e108:	f01e f92c 	bl	2c364 <ctrl_tx_enqueue>
		conn->llcp_enc.pause_rx = 0U;
    e10c:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
    e110:	f023 0303 	bic.w	r3, r3, #3
    e114:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
    e118:	e781      	b.n	e01e <ull_conn_llcp+0xe76>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
    e11a:	480d      	ldr	r0, [pc, #52]	; (e150 <ull_conn_llcp+0xfa8>)
    e11c:	f01d fc08 	bl	2b930 <mem_acquire>
	if (tx) {
    e120:	4601      	mov	r1, r0
    e122:	2800      	cmp	r0, #0
    e124:	f43f ac99 	beq.w	da5a <ull_conn_llcp+0x8b2>
		conn->llcp_ack = conn->llcp_req;
    e128:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
    e12c:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    e130:	7903      	ldrb	r3, [r0, #4]
    e132:	f043 0303 	orr.w	r3, r3, #3
    e136:	7103      	strb	r3, [r0, #4]
		pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, ping_req) +
    e138:	2301      	movs	r3, #1
    e13a:	7143      	strb	r3, [r0, #5]
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_REQ;
    e13c:	2312      	movs	r3, #18
    e13e:	71c3      	strb	r3, [r0, #7]
		ctrl_tx_enqueue(conn, tx);
    e140:	4620      	mov	r0, r4
    e142:	f01e f90f 	bl	2c364 <ctrl_tx_enqueue>
		conn->procedure_expire = conn->procedure_reload;
    e146:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
    e14a:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
    e14e:	e484      	b.n	da5a <ull_conn_llcp+0x8b2>
    e150:	200034bc 	.word	0x200034bc
    e154:	20003188 	.word	0x20003188
			event_counter = lll->event_counter +
    e158:	8e61      	ldrh	r1, [r4, #50]	; 0x32
    e15a:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
	if (conn->llcp.phy_upd_ind.initiate) {
    e15c:	f894 50ec 	ldrb.w	r5, [r4, #236]	; 0xec
			event_counter = lll->event_counter +
    e160:	440b      	add	r3, r1
					lll->latency_prepare + lazy;
    e162:	449b      	add	fp, r3
	if (conn->llcp.phy_upd_ind.initiate) {
    e164:	07e9      	lsls	r1, r5, #31
			event_counter = lll->event_counter +
    e166:	fa1f fb8b 	uxth.w	fp, fp
	if (conn->llcp.phy_upd_ind.initiate) {
    e16a:	d568      	bpl.n	e23e <ull_conn_llcp+0x1096>
		rx = ll_pdu_rx_alloc_peek(2);
    e16c:	2002      	movs	r0, #2
    e16e:	f010 f901 	bl	1e374 <ll_pdu_rx_alloc_peek>
		if (!rx) {
    e172:	4606      	mov	r6, r0
    e174:	2800      	cmp	r0, #0
    e176:	f43f ac70 	beq.w	da5a <ull_conn_llcp+0x8b2>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    e17a:	48b1      	ldr	r0, [pc, #708]	; (e440 <ull_conn_llcp+0x1298>)
    e17c:	f01d fbd8 	bl	2b930 <mem_acquire>
		if (!tx) {
    e180:	4605      	mov	r5, r0
    e182:	2800      	cmp	r0, #0
    e184:	f43f ac69 	beq.w	da5a <ull_conn_llcp+0x8b2>
		conn->llcp.phy_upd_ind.initiate = 0U;
    e188:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    e18c:	f36f 0300 	bfc	r3, #0, #1
    e190:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
		if (!((conn->llcp.phy_upd_ind.tx |
    e194:	b2db      	uxtb	r3, r3
    e196:	f3c3 0782 	ubfx	r7, r3, #2, #3
    e19a:	ea57 1753 	orrs.w	r7, r7, r3, lsr #5
    e19e:	d137      	bne.n	e210 <ull_conn_llcp+0x1068>
			conn->llcp_ack = conn->llcp_req;
    e1a0:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
    e1a4:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
			if (conn->llcp.phy_upd_ind.cmd) {
    e1a8:	079b      	lsls	r3, r3, #30
			conn->llcp.phy_upd_ind.instant = 0U;
    e1aa:	f8a4 70ee 	strh.w	r7, [r4, #238]	; 0xee
			if (conn->llcp.phy_upd_ind.cmd) {
    e1ae:	d519      	bpl.n	e1e4 <ull_conn_llcp+0x103c>
				(void)ll_pdu_rx_alloc();
    e1b0:	f010 f8f8 	bl	1e3a4 <ll_pdu_rx_alloc>
				rx->hdr.handle = lll->handle;
    e1b4:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    e1b6:	80f3      	strh	r3, [r6, #6]
				upd->status = 0U;
    e1b8:	f886 7020 	strb.w	r7, [r6, #32]
				rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
    e1bc:	230e      	movs	r3, #14
    e1be:	7133      	strb	r3, [r6, #4]
				upd->tx = lll->phy_tx;
    e1c0:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
				ll_rx_put(rx->hdr.link, rx);
    e1c4:	6830      	ldr	r0, [r6, #0]
				upd->tx = lll->phy_tx;
    e1c6:	f3c3 0302 	ubfx	r3, r3, #0, #3
    e1ca:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
				upd->rx = lll->phy_rx;
    e1ce:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
    e1d2:	f3c3 0302 	ubfx	r3, r3, #0, #3
    e1d6:	f886 3022 	strb.w	r3, [r6, #34]	; 0x22
				ll_rx_put(rx->hdr.link, rx);
    e1da:	4631      	mov	r1, r6
    e1dc:	f010 f8ba 	bl	1e354 <ll_rx_put>
				ll_rx_sched();
    e1e0:	f010 f8c2 	bl	1e368 <ll_rx_sched>
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
    e1e4:	792b      	ldrb	r3, [r5, #4]
    e1e6:	f043 0303 	orr.w	r3, r3, #3
    e1ea:	712b      	strb	r3, [r5, #4]
		pdu_ctrl_tx->len =
    e1ec:	2305      	movs	r3, #5
    e1ee:	716b      	strb	r3, [r5, #5]
		pdu_ctrl_tx->llctrl.opcode =
    e1f0:	2318      	movs	r3, #24
    e1f2:	71eb      	strb	r3, [r5, #7]
		ind->m_to_s_phy = conn->llcp.phy_upd_ind.tx;
    e1f4:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    e1f8:	f3c3 0382 	ubfx	r3, r3, #2, #3
    e1fc:	722b      	strb	r3, [r5, #8]
		ind->s_to_m_phy = conn->llcp.phy_upd_ind.rx;
    e1fe:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
    e202:	f3c3 1342 	ubfx	r3, r3, #5, #3
    e206:	726b      	strb	r3, [r5, #9]
		ind->instant = sys_cpu_to_le16(conn->llcp.phy_upd_ind.instant);
    e208:	f8b4 30ee 	ldrh.w	r3, [r4, #238]	; 0xee
    e20c:	816b      	strh	r3, [r5, #10]
		ctrl_tx_enqueue(conn, tx);
    e20e:	e420      	b.n	da52 <ull_conn_llcp+0x8aa>
			conn->llcp.phy_upd_ind.instant = event_counter +
    e210:	8e23      	ldrh	r3, [r4, #48]	; 0x30
    e212:	449b      	add	fp, r3
							 lll->latency +
    e214:	f10b 0b06 	add.w	fp, fp, #6
			conn->llcp.phy_upd_ind.instant = event_counter +
    e218:	f8a4 b0ee 	strh.w	fp, [r4, #238]	; 0xee
			(void)ll_pdu_rx_alloc();
    e21c:	f010 f8c2 	bl	1e3a4 <ll_pdu_rx_alloc>
			rx->hdr.link->mem = conn->llcp_rx;
    e220:	6833      	ldr	r3, [r6, #0]
    e222:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
    e226:	605a      	str	r2, [r3, #4]
			conn->llcp_rx = rx;
    e228:	f8c4 6100 	str.w	r6, [r4, #256]	; 0x100
			rx = ll_pdu_rx_alloc();
    e22c:	f010 f8ba 	bl	1e3a4 <ll_pdu_rx_alloc>
			rx->hdr.link->mem = conn->llcp_rx;
    e230:	6803      	ldr	r3, [r0, #0]
    e232:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
    e236:	605a      	str	r2, [r3, #4]
			conn->llcp_rx = rx;
    e238:	f8c4 0100 	str.w	r0, [r4, #256]	; 0x100
    e23c:	e7d2      	b.n	e1e4 <ull_conn_llcp+0x103c>
	} else if (((event_counter - conn->llcp.phy_upd_ind.instant) &
    e23e:	f8b4 30ee 	ldrh.w	r3, [r4, #238]	; 0xee
    e242:	ebab 0b03 	sub.w	fp, fp, r3
    e246:	f41b 4f00 	tst.w	fp, #32768	; 0x8000
    e24a:	f47f ac06 	bne.w	da5a <ull_conn_llcp+0x8b2>
		old_tx = lll->phy_tx;
    e24e:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
		old_rx = lll->phy_rx;
    e252:	f894 7065 	ldrb.w	r7, [r4, #101]	; 0x65
		conn->llcp_ack = conn->llcp_req;
    e256:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
		if (conn->llcp.phy_upd_ind.tx) {
    e25a:	f015 0f1c 	tst.w	r5, #28
		old_tx = lll->phy_tx;
    e25e:	f003 0807 	and.w	r8, r3, #7
		old_rx = lll->phy_rx;
    e262:	f007 0707 	and.w	r7, r7, #7
		u16_t eff_rx_time = lll->max_rx_time;
    e266:	f8b4 6062 	ldrh.w	r6, [r4, #98]	; 0x62
		if (conn->llcp.phy_upd_ind.tx) {
    e26a:	d162      	bne.n	e332 <ull_conn_llcp+0x118a>
		u16_t eff_tx_time = lll->max_tx_time;
    e26c:	f8b4 9060 	ldrh.w	r9, [r4, #96]	; 0x60
		if (conn->llcp.phy_upd_ind.rx) {
    e270:	f015 0fe0 	tst.w	r5, #224	; 0xe0
    e274:	d00d      	beq.n	e292 <ull_conn_llcp+0x10ea>
			lll->phy_rx = conn->llcp.phy_upd_ind.rx;
    e276:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
				calc_eff_time(lll->max_rx_octets, lll->phy_rx,
    e27a:	f894 005e 	ldrb.w	r0, [r4, #94]	; 0x5e
			lll->phy_rx = conn->llcp.phy_upd_ind.rx;
    e27e:	0969      	lsrs	r1, r5, #5
    e280:	f361 0302 	bfi	r3, r1, #0, #3
    e284:	f884 3065 	strb.w	r3, [r4, #101]	; 0x65
				calc_eff_time(lll->max_rx_octets, lll->phy_rx,
    e288:	f44f 6229 	mov.w	r2, #2704	; 0xa90
    e28c:	f01e f81a 	bl	2c2c4 <calc_eff_time>
    e290:	4606      	mov	r6, r0
		lll->phy_flags = conn->phy_pref_flags;
    e292:	f894 31ac 	ldrb.w	r3, [r4, #428]	; 0x1ac
    e296:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
		rx = conn->llcp_rx;
    e29a:	f8d4 5100 	ldr.w	r5, [r4, #256]	; 0x100
		lll->phy_flags = conn->phy_pref_flags;
    e29e:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    e2a2:	f363 02c3 	bfi	r2, r3, #3, #1
    e2a6:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
		LL_ASSERT(rx && rx->hdr.link);
    e2aa:	b10d      	cbz	r5, e2b0 <ull_conn_llcp+0x1108>
    e2ac:	682b      	ldr	r3, [r5, #0]
    e2ae:	b943      	cbnz	r3, e2c2 <ull_conn_llcp+0x111a>
    e2b0:	4864      	ldr	r0, [pc, #400]	; (e444 <ull_conn_llcp+0x129c>)
    e2b2:	f019 ff47 	bl	28144 <printk>
    e2b6:	4040      	eors	r0, r0
    e2b8:	f380 8811 	msr	BASEPRI, r0
    e2bc:	f04f 0003 	mov.w	r0, #3
    e2c0:	df02      	svc	2
		conn->llcp_rx = rx->hdr.link->mem;
    e2c2:	6828      	ldr	r0, [r5, #0]
    e2c4:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
    e2c8:	6843      	ldr	r3, [r0, #4]
    e2ca:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
		if (!conn->llcp.phy_upd_ind.cmd && (lll->phy_tx == old_tx) &&
    e2ce:	f894 e0ec 	ldrb.w	lr, [r4, #236]	; 0xec
    e2d2:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
    e2d6:	f3c2 0202 	ubfx	r2, r2, #0, #3
    e2da:	f3c3 0302 	ubfx	r3, r3, #0, #3
    e2de:	f01e 0f02 	tst.w	lr, #2
    e2e2:	fa5f fc82 	uxtb.w	ip, r2
    e2e6:	b2d9      	uxtb	r1, r3
    e2e8:	d131      	bne.n	e34e <ull_conn_llcp+0x11a6>
    e2ea:	45e0      	cmp	r8, ip
    e2ec:	d12f      	bne.n	e34e <ull_conn_llcp+0x11a6>
    e2ee:	428f      	cmp	r7, r1
    e2f0:	d12d      	bne.n	e34e <ull_conn_llcp+0x11a6>
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
    e2f2:	2303      	movs	r3, #3
    e2f4:	712b      	strb	r3, [r5, #4]
			ll_rx_put(rx->hdr.link, rx);
    e2f6:	4629      	mov	r1, r5
    e2f8:	f010 f82c 	bl	1e354 <ll_rx_put>
				rx = conn->llcp_rx;
    e2fc:	f8d4 5100 	ldr.w	r5, [r4, #256]	; 0x100
				LL_ASSERT(rx && rx->hdr.link);
    e300:	b10d      	cbz	r5, e306 <ull_conn_llcp+0x115e>
    e302:	682b      	ldr	r3, [r5, #0]
    e304:	b943      	cbnz	r3, e318 <ull_conn_llcp+0x1170>
    e306:	484f      	ldr	r0, [pc, #316]	; (e444 <ull_conn_llcp+0x129c>)
    e308:	f019 ff1c 	bl	28144 <printk>
    e30c:	4040      	eors	r0, r0
    e30e:	f380 8811 	msr	BASEPRI, r0
    e312:	f04f 0003 	mov.w	r0, #3
    e316:	df02      	svc	2
				conn->llcp_rx = rx->hdr.link->mem;
    e318:	6828      	ldr	r0, [r5, #0]
    e31a:	6843      	ldr	r3, [r0, #4]
    e31c:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
    e320:	2303      	movs	r3, #3
    e322:	712b      	strb	r3, [r5, #4]
		ll_rx_put(rx->hdr.link, rx);
    e324:	4629      	mov	r1, r5
    e326:	f010 f815 	bl	1e354 <ll_rx_put>
		ll_rx_sched();
    e32a:	f010 f81d 	bl	1e368 <ll_rx_sched>
    e32e:	f7ff bb94 	b.w	da5a <ull_conn_llcp+0x8b2>
			lll->phy_tx = conn->llcp.phy_upd_ind.tx;
    e332:	f3c5 0182 	ubfx	r1, r5, #2, #3
    e336:	f361 0302 	bfi	r3, r1, #0, #3
    e33a:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
			eff_tx_time = calc_eff_time(lll->max_tx_octets,
    e33e:	f8b4 20d8 	ldrh.w	r2, [r4, #216]	; 0xd8
    e342:	f894 005c 	ldrb.w	r0, [r4, #92]	; 0x5c
    e346:	f01d ffbd 	bl	2c2c4 <calc_eff_time>
    e34a:	4681      	mov	r9, r0
    e34c:	e790      	b.n	e270 <ull_conn_llcp+0x10c8>
		rx->hdr.handle = lll->handle;
    e34e:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
    e350:	80e9      	strh	r1, [r5, #6]
		rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
    e352:	210e      	movs	r1, #14
    e354:	7129      	strb	r1, [r5, #4]
		upd->status = 0U;
    e356:	2100      	movs	r1, #0
    e358:	f885 1020 	strb.w	r1, [r5, #32]
		upd->tx = lll->phy_tx;
    e35c:	f885 2021 	strb.w	r2, [r5, #33]	; 0x21
		upd->rx = lll->phy_rx;
    e360:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
		ll_rx_put(rx->hdr.link, rx);
    e364:	4629      	mov	r1, r5
    e366:	f00f fff5 	bl	1e354 <ll_rx_put>
		rx = conn->llcp_rx;
    e36a:	f8d4 5100 	ldr.w	r5, [r4, #256]	; 0x100
		LL_ASSERT(rx && rx->hdr.link);
    e36e:	b10d      	cbz	r5, e374 <ull_conn_llcp+0x11cc>
    e370:	682b      	ldr	r3, [r5, #0]
    e372:	b943      	cbnz	r3, e386 <ull_conn_llcp+0x11de>
    e374:	4833      	ldr	r0, [pc, #204]	; (e444 <ull_conn_llcp+0x129c>)
    e376:	f019 fee5 	bl	28144 <printk>
    e37a:	4040      	eors	r0, r0
    e37c:	f380 8811 	msr	BASEPRI, r0
    e380:	f04f 0003 	mov.w	r0, #3
    e384:	df02      	svc	2
		conn->llcp_rx = rx->hdr.link->mem;
    e386:	6828      	ldr	r0, [r5, #0]
    e388:	6843      	ldr	r3, [r0, #4]
    e38a:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
		if ((eff_tx_time <= lll->max_tx_time) &&
    e38e:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
    e392:	454b      	cmp	r3, r9
    e394:	d303      	bcc.n	e39e <ull_conn_llcp+0x11f6>
    e396:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
    e39a:	42b3      	cmp	r3, r6
    e39c:	d2c0      	bcs.n	e320 <ull_conn_llcp+0x1178>
		rx->hdr.handle = lll->handle;
    e39e:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
		lll->max_tx_time = eff_tx_time;
    e3a0:	f8a4 9060 	strh.w	r9, [r4, #96]	; 0x60
		lll->max_rx_time = eff_rx_time;
    e3a4:	f8a4 6062 	strh.w	r6, [r4, #98]	; 0x62
		rx->hdr.handle = lll->handle;
    e3a8:	80eb      	strh	r3, [r5, #6]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
    e3aa:	2302      	movs	r3, #2
    e3ac:	712b      	strb	r3, [r5, #4]
		pdu_rx->ll_id = PDU_DATA_LLID_CTRL;
    e3ae:	f895 3020 	ldrb.w	r3, [r5, #32]
    e3b2:	f043 0303 	orr.w	r3, r3, #3
    e3b6:	f885 3020 	strb.w	r3, [r5, #32]
		pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
    e3ba:	2309      	movs	r3, #9
    e3bc:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
		pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
    e3c0:	2315      	movs	r3, #21
    e3c2:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
		lr->max_rx_octets = sys_cpu_to_le16(lll->max_rx_octets);
    e3c6:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
    e3ca:	84ab      	strh	r3, [r5, #36]	; 0x24
		lr->max_tx_octets = sys_cpu_to_le16(lll->max_tx_octets);
    e3cc:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
    e3d0:	852b      	strh	r3, [r5, #40]	; 0x28
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
    e3d2:	84ee      	strh	r6, [r5, #38]	; 0x26
		lr->max_tx_time = sys_cpu_to_le16(lll->max_tx_time);
    e3d4:	f8a5 902a 	strh.w	r9, [r5, #42]	; 0x2a
    e3d8:	e7a4      	b.n	e324 <ull_conn_llcp+0x117c>
			LL_ASSERT(0);
    e3da:	481b      	ldr	r0, [pc, #108]	; (e448 <ull_conn_llcp+0x12a0>)
    e3dc:	f019 feb2 	bl	28144 <printk>
    e3e0:	4040      	eors	r0, r0
    e3e2:	f380 8811 	msr	BASEPRI, r0
    e3e6:	f04f 0003 	mov.w	r0, #3
    e3ea:	df02      	svc	2
			break;
    e3ec:	f7ff bb35 	b.w	da5a <ull_conn_llcp+0x8b2>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
    e3f0:	4813      	ldr	r0, [pc, #76]	; (e440 <ull_conn_llcp+0x1298>)
    e3f2:	f01d fa9d 	bl	2b930 <mem_acquire>
		if (tx) {
    e3f6:	4601      	mov	r1, r0
    e3f8:	b180      	cbz	r0, e41c <ull_conn_llcp+0x1274>
			conn->llcp_terminate.ack = conn->llcp_terminate.req;
    e3fa:	f894 3128 	ldrb.w	r3, [r4, #296]	; 0x128
    e3fe:	f884 3129 	strb.w	r3, [r4, #297]	; 0x129
			pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
    e402:	7903      	ldrb	r3, [r0, #4]
    e404:	f043 0303 	orr.w	r3, r3, #3
    e408:	7103      	strb	r3, [r0, #4]
			pdu_tx->len = offsetof(struct pdu_data_llctrl,
    e40a:	2302      	movs	r3, #2
    e40c:	7143      	strb	r3, [r0, #5]
			pdu_tx->llctrl.opcode =
    e40e:	71c3      	strb	r3, [r0, #7]
			pdu_tx->llctrl.terminate_ind.error_code =
    e410:	f894 312a 	ldrb.w	r3, [r4, #298]	; 0x12a
    e414:	7203      	strb	r3, [r0, #8]
			ctrl_tx_enqueue(conn, tx);
    e416:	4620      	mov	r0, r4
    e418:	f01d ffa4 	bl	2c364 <ctrl_tx_enqueue>
		if (!conn->procedure_expire) {
    e41c:	f8b4 00cc 	ldrh.w	r0, [r4, #204]	; 0xcc
    e420:	2800      	cmp	r0, #0
    e422:	f47f ab21 	bne.w	da68 <ull_conn_llcp+0x8c0>
			conn->procedure_expire = conn->supervision_reload;
    e426:	f8b4 30c6 	ldrh.w	r3, [r4, #198]	; 0xc6
			if (conn->procedure_expire <= 1U) {
    e42a:	2b01      	cmp	r3, #1
    e42c:	d903      	bls.n	e436 <ull_conn_llcp+0x128e>
			conn->procedure_expire = conn->supervision_reload;
    e42e:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
    e432:	f7ff bb19 	b.w	da68 <ull_conn_llcp+0x8c0>
				conn->procedure_expire++;
    e436:	3301      	adds	r3, #1
    e438:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
    e43c:	f7ff bb15 	b.w	da6a <ull_conn_llcp+0x8c2>
    e440:	200034bc 	.word	0x200034bc
    e444:	00031ded 	.word	0x00031ded
    e448:	000314f5 	.word	0x000314f5
    e44c:	00000000 	.word	0x00000000

0000e450 <ull_slave_setup>:
static void ticker_op_stop_adv_cb(u32_t status, void *param);
static void ticker_op_cb(u32_t status, void *param);

void ull_slave_setup(memq_link_t *link, struct node_rx_hdr *rx,
		     struct node_rx_ftr *ftr, struct lll_conn *lll)
{
    e450:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e454:	b097      	sub	sp, #92	; 0x5c
    e456:	461d      	mov	r5, r3
    e458:	900e      	str	r0, [sp, #56]	; 0x38
	u16_t win_offset;
	u16_t timeout;
	u16_t interval;
	u8_t chan_sel;

	((struct lll_adv *)ftr->param)->conn = NULL;
    e45a:	6813      	ldr	r3, [r2, #0]

	adv = ((struct lll_adv *)ftr->param)->hdr.parent;
	conn = lll->hdr.parent;
    e45c:	4628      	mov	r0, r5
{
    e45e:	4690      	mov	r8, r2
	((struct lll_adv *)ftr->param)->conn = NULL;
    e460:	2200      	movs	r2, #0
{
    e462:	460c      	mov	r4, r1
	conn = lll->hdr.parent;
    e464:	f850 6b0c 	ldr.w	r6, [r0], #12
	((struct lll_adv *)ftr->param)->conn = NULL;
    e468:	609a      	str	r2, [r3, #8]

	/* Populate the slave context */
	pdu_adv = (void *)((struct node_rx_pdu *)rx)->pdu;
	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
	memcpy(&lll->access_addr[0], &pdu_adv->connect_ind.access_addr[0], 4);
    e46a:	f105 0a08 	add.w	sl, r5, #8
	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
    e46e:	2203      	movs	r2, #3
    e470:	3132      	adds	r1, #50	; 0x32
	adv = ((struct lll_adv *)ftr->param)->hdr.parent;
    e472:	f8d3 9000 	ldr.w	r9, [r3]
	memcpy(&lll->data_chan_map[0], &pdu_adv->connect_ind.chan_map[0],
    e476:	f105 071c 	add.w	r7, r5, #28
	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
    e47a:	f01b ffe8 	bl	2a44e <memcpy>
	memcpy(&lll->access_addr[0], &pdu_adv->connect_ind.access_addr[0], 4);
    e47e:	2204      	movs	r2, #4
    e480:	f104 012e 	add.w	r1, r4, #46	; 0x2e
    e484:	4650      	mov	r0, sl
    e486:	f01b ffe2 	bl	2a44e <memcpy>
	memcpy(&lll->data_chan_map[0], &pdu_adv->connect_ind.chan_map[0],
    e48a:	2205      	movs	r2, #5
    e48c:	f104 013e 	add.w	r1, r4, #62	; 0x3e
    e490:	4638      	mov	r0, r7
    e492:	f01b ffdc 	bl	2a44e <memcpy>
	       sizeof(lll->data_chan_map));
	lll->data_chan_count = util_ones_count_get(&lll->data_chan_map[0],
    e496:	2105      	movs	r1, #5
    e498:	4638      	mov	r0, r7
    e49a:	f01d fac5 	bl	2ba28 <util_ones_count_get>
    e49e:	f895 3021 	ldrb.w	r3, [r5, #33]	; 0x21
    e4a2:	f360 0305 	bfi	r3, r0, #0, #6
    e4a6:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
			       sizeof(lll->data_chan_map));
	lll->data_chan_hop = pdu_adv->connect_ind.hop;
    e4aa:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    e4ae:	f3c3 0304 	ubfx	r3, r3, #0, #5
    e4b2:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
	interval = sys_le16_to_cpu(pdu_adv->connect_ind.interval);
    e4b6:	8f27      	ldrh	r7, [r4, #56]	; 0x38
	lll->interval = interval;
    e4b8:	826f      	strh	r7, [r5, #18]
	lll->latency = sys_le16_to_cpu(pdu_adv->connect_ind.latency);
    e4ba:	f894 203b 	ldrb.w	r2, [r4, #59]	; 0x3b
    e4be:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
    e4c2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    e4c6:	82ab      	strh	r3, [r5, #20]

	win_offset = sys_le16_to_cpu(pdu_adv->connect_ind.win_offset);
    e4c8:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
    e4ca:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
	conn_interval_us = interval * 1250U;

	/* calculate the window widening */
	conn->slave.sca = pdu_adv->connect_ind.sca;
    e4ce:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    e4d2:	f896 20dc 	ldrb.w	r2, [r6, #220]	; 0xdc
    e4d6:	095b      	lsrs	r3, r3, #5
    e4d8:	f363 0284 	bfi	r2, r3, #2, #3
    e4dc:	f886 20dc 	strb.w	r2, [r6, #220]	; 0xdc
	lll->slave.window_widening_periodic_us =
		(((lll_conn_ppm_local_get() +
    e4e0:	f01e f925 	bl	2c72e <lll_conn_ppm_local_get>
    e4e4:	900a      	str	r0, [sp, #40]	; 0x28
		   lll_conn_ppm_get(conn->slave.sca)) *
    e4e6:	f896 00dc 	ldrb.w	r0, [r6, #220]	; 0xdc
    e4ea:	f3c0 0082 	ubfx	r0, r0, #2, #3
    e4ee:	f014 f91f 	bl	22730 <lll_conn_ppm_get>
		(((lll_conn_ppm_local_get() +
    e4f2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
					      conn_interval_us);
	/* Dispatch LE Ping PDU 6 connection events (that peer would
	 * listen to) before 30s timeout
	 * TODO: "peer listens to" is greater than 30s due to latency
	 */
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    e4f4:	8aa9      	ldrh	r1, [r5, #20]
	conn_interval_us = interval * 1250U;
    e4f6:	f240 4be2 	movw	fp, #1250	; 0x4e2
    e4fa:	fb0b f707 	mul.w	r7, fp, r7
		(((lll_conn_ppm_local_get() +
    e4fe:	4418      	add	r0, r3
		   lll_conn_ppm_get(conn->slave.sca)) *
    e500:	4378      	muls	r0, r7
		  conn_interval_us) + (1000000 - 1)) / 1000000U;
    e502:	f500 2074 	add.w	r0, r0, #999424	; 0xf4000
    e506:	4bb6      	ldr	r3, [pc, #728]	; (e7e0 <ull_slave_setup+0x390>)
    e508:	f200 203f 	addw	r0, r0, #575	; 0x23f
    e50c:	fbb0 f0f3 	udiv	r0, r0, r3
	lll->slave.window_widening_max_us = (conn_interval_us >> 1) -
    e510:	087b      	lsrs	r3, r7, #1
    e512:	3b96      	subs	r3, #150	; 0x96
    e514:	62eb      	str	r3, [r5, #44]	; 0x2c
	lll->slave.window_size_event_us = pdu_adv->connect_ind.win_size * 1250U;
    e516:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
	lll->slave.window_widening_periodic_us =
    e51a:	62a8      	str	r0, [r5, #40]	; 0x28
	lll->slave.window_size_event_us = pdu_adv->connect_ind.win_size * 1250U;
    e51c:	fb0b f303 	mul.w	r3, fp, r3
    e520:	63eb      	str	r3, [r5, #60]	; 0x3c
	timeout = sys_le16_to_cpu(pdu_adv->connect_ind.timeout);
    e522:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
    e524:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
    e528:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
    e52c:	f242 7310 	movw	r3, #10000	; 0x2710
    e530:	fb03 7302 	mla	r3, r3, r2, r7
    e534:	3b01      	subs	r3, #1
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    e536:	4aab      	ldr	r2, [pc, #684]	; (e7e4 <ull_slave_setup+0x394>)
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
    e538:	fbb3 f3f7 	udiv	r3, r3, r7
    e53c:	f8a6 30c6 	strh.w	r3, [r6, #198]	; 0xc6
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    e540:	4ba9      	ldr	r3, [pc, #676]	; (e7e8 <ull_slave_setup+0x398>)
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    e542:	1d88      	adds	r0, r1, #6
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    e544:	443b      	add	r3, r7
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    e546:	443a      	add	r2, r7
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    e548:	fbb3 f3f7 	udiv	r3, r3, r7
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    e54c:	fbb2 f2f7 	udiv	r2, r2, r7
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
    e550:	f8a6 30ca 	strh.w	r3, [r6, #202]	; 0xca
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    e554:	b293      	uxth	r3, r2
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    e556:	4283      	cmp	r3, r0
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
    e558:	f8a6 30d2 	strh.w	r3, [r6, #210]	; 0xd2
			     (conn->apto_reload - (lll->latency + 6)) :
    e55c:	bfc2      	ittt	gt
    e55e:	1a5b      	subgt	r3, r3, r1
    e560:	3b06      	subgt	r3, #6
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    e562:	b29b      	uxthgt	r3, r3
			     conn->apto_reload;
#endif /* CONFIG_BT_CTLR_LE_PING */

	memcpy((void *)&conn->slave.force, &lll->access_addr[0],
    e564:	4651      	mov	r1, sl
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
    e566:	f8a6 30ce 	strh.w	r3, [r6, #206]	; 0xce
	memcpy((void *)&conn->slave.force, &lll->access_addr[0],
    e56a:	2204      	movs	r2, #4
    e56c:	f106 00e0 	add.w	r0, r6, #224	; 0xe0
    e570:	f01b ff6d 	bl	2a44e <memcpy>
	       sizeof(conn->slave.force));

#if defined(CONFIG_BT_CTLR_PRIVACY)
	u8_t own_addr_type = pdu_adv->rx_addr;
	u8_t own_addr[BDADDR_SIZE];
	u8_t rl_idx = ftr->rl_idx;
    e574:	f898 3015 	ldrb.w	r3, [r8, #21]
	u8_t own_addr_type = pdu_adv->rx_addr;
    e578:	f894 a020 	ldrb.w	sl, [r4, #32]
	u8_t rl_idx = ftr->rl_idx;
    e57c:	930a      	str	r3, [sp, #40]	; 0x28

	memcpy(own_addr, &pdu_adv->connect_ind.adv_addr[0], BDADDR_SIZE);
    e57e:	2206      	movs	r2, #6
    e580:	f104 0128 	add.w	r1, r4, #40	; 0x28
    e584:	a814      	add	r0, sp, #80	; 0x50
    e586:	f01b ff62 	bl	2a44e <memcpy>
#endif

	peer_addr_type = pdu_adv->tx_addr;
    e58a:	f894 3020 	ldrb.w	r3, [r4, #32]
    e58e:	f3c3 1380 	ubfx	r3, r3, #6, #1
    e592:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
    e596:	f104 0322 	add.w	r3, r4, #34	; 0x22
    e59a:	4619      	mov	r1, r3
    e59c:	2206      	movs	r2, #6
    e59e:	a812      	add	r0, sp, #72	; 0x48
    e5a0:	9311      	str	r3, [sp, #68]	; 0x44
    e5a2:	f01b ff54 	bl	2a44e <memcpy>

	chan_sel = pdu_adv->chan_sel;
    e5a6:	f894 2020 	ldrb.w	r2, [r4, #32]
	u8_t own_addr_type = pdu_adv->rx_addr;
    e5aa:	f3ca 1ac0 	ubfx	sl, sl, #7, #1
	chan_sel = pdu_adv->chan_sel;
    e5ae:	f3c2 1340 	ubfx	r3, r2, #5, #1

	cc = (void *)pdu_adv;
	cc->status = 0U;
    e5b2:	f44f 7280 	mov.w	r2, #256	; 0x100
	chan_sel = pdu_adv->chan_sel;
    e5b6:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	cc->status = 0U;
    e5ba:	8422      	strh	r2, [r4, #32]
	chan_sel = pdu_adv->chan_sel;
    e5bc:	b2db      	uxtb	r3, r3
	cc->role = 1U;

#if defined(CONFIG_BT_CTLR_PRIVACY)
	cc->own_addr_type = own_addr_type;
    e5be:	f884 a02f 	strb.w	sl, [r4, #47]	; 0x2f
	memcpy(&cc->own_addr[0], &own_addr[0], BDADDR_SIZE);
    e5c2:	2206      	movs	r2, #6
    e5c4:	a914      	add	r1, sp, #80	; 0x50
    e5c6:	f104 0030 	add.w	r0, r4, #48	; 0x30
	chan_sel = pdu_adv->chan_sel;
    e5ca:	930d      	str	r3, [sp, #52]	; 0x34
	memcpy(&cc->own_addr[0], &own_addr[0], BDADDR_SIZE);
    e5cc:	f01b ff3f 	bl	2a44e <memcpy>

	if (rl_idx != FILTER_IDX_NONE) {
    e5d0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    e5d2:	2bff      	cmp	r3, #255	; 0xff
    e5d4:	f104 0b29 	add.w	fp, r4, #41	; 0x29
    e5d8:	f104 0a23 	add.w	sl, r4, #35	; 0x23
    e5dc:	f000 80ea 	beq.w	e7b4 <ull_slave_setup+0x364>
		/* TODO: store rl_idx instead if safe */
		/* Store identity address */
		ll_rl_id_addr_get(rl_idx, &cc->peer_addr_type,
    e5e0:	9b11      	ldr	r3, [sp, #68]	; 0x44
    e5e2:	980a      	ldr	r0, [sp, #40]	; 0x28
    e5e4:	4619      	mov	r1, r3
    e5e6:	4652      	mov	r2, sl
    e5e8:	f015 f964 	bl	238b4 <ll_rl_id_addr_get>
				  &cc->peer_addr[0]);
		/* Mark it as identity address from RPA (0x02, 0x03) */
		cc->peer_addr_type += 2;
    e5ec:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
    e5f0:	3302      	adds	r3, #2
    e5f2:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22

		/* Store peer RPA */
		memcpy(&cc->peer_rpa[0], &peer_addr[0], BDADDR_SIZE);
    e5f6:	2206      	movs	r2, #6
    e5f8:	a912      	add	r1, sp, #72	; 0x48
    e5fa:	4658      	mov	r0, fp
		memset(&cc->peer_rpa[0], 0x0, BDADDR_SIZE);
#else
	if (1) {
#endif /* CONFIG_BT_CTLR_PRIVACY */
		cc->peer_addr_type = peer_addr_type;
		memcpy(cc->peer_addr, peer_addr, BDADDR_SIZE);
    e5fc:	f01b ff27 	bl	2a44e <memcpy>
	}

	cc->interval = lll->interval;
    e600:	8a6b      	ldrh	r3, [r5, #18]
    e602:	86e3      	strh	r3, [r4, #54]	; 0x36
	cc->latency = lll->latency;
    e604:	8aab      	ldrh	r3, [r5, #20]
    e606:	8723      	strh	r3, [r4, #56]	; 0x38
	cc->timeout = timeout;
    e608:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
    e60c:	8763      	strh	r3, [r4, #58]	; 0x3a
	cc->sca = conn->slave.sca;
    e60e:	f896 30dc 	ldrb.w	r3, [r6, #220]	; 0xdc
    e612:	f3c3 0382 	ubfx	r3, r3, #2, #3
    e616:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c

	lll->handle = ll_conn_handle_get(conn);
    e61a:	4630      	mov	r0, r6
    e61c:	f011 ffb0 	bl	20580 <ll_conn_handle_get>
		struct node_rx_cs *cs;

		/* pick the rx node instance stored within the connection
		 * rx node.
		 */
		rx_csa = (void *)ftr->extra;
    e620:	f8d8 a004 	ldr.w	sl, [r8, #4]
	lll->handle = ll_conn_handle_get(conn);
    e624:	8228      	strh	r0, [r5, #16]

		/* Enqueue the connection event */
		ll_rx_put(link, rx);
    e626:	4621      	mov	r1, r4
	rx->handle = lll->handle;
    e628:	80e0      	strh	r0, [r4, #6]
		ll_rx_put(link, rx);
    e62a:	980e      	ldr	r0, [sp, #56]	; 0x38
    e62c:	f00f fe92 	bl	1e354 <ll_rx_put>

		/* use the rx node for CSA event */
		rx = (void *)rx_csa;
		link = rx->link;

		rx->handle = lll->handle;
    e630:	8a2b      	ldrh	r3, [r5, #16]
    e632:	f8aa 3006 	strh.w	r3, [sl, #6]
		rx->type = NODE_RX_TYPE_CHAN_SEL_ALGO;
    e636:	230d      	movs	r3, #13
    e638:	f88a 3004 	strb.w	r3, [sl, #4]

		cs = (void *)rx_csa->pdu;

		if (chan_sel) {
    e63c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
		link = rx->link;
    e63e:	f8da 0000 	ldr.w	r0, [sl]
		if (chan_sel) {
    e642:	2b00      	cmp	r3, #0
    e644:	f000 80c3 	beq.w	e7ce <ull_slave_setup+0x37e>
			u16_t aa_ls = ((u16_t)lll->access_addr[1] << 8) |
    e648:	7a6a      	ldrb	r2, [r5, #9]
				      lll->access_addr[0];
    e64a:	7a2b      	ldrb	r3, [r5, #8]
			u16_t aa_ms = ((u16_t)lll->access_addr[3] << 8) |
    e64c:	7ae9      	ldrb	r1, [r5, #11]
			u16_t aa_ls = ((u16_t)lll->access_addr[1] << 8) |
    e64e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
				      lll->access_addr[2];
    e652:	7aaa      	ldrb	r2, [r5, #10]
			u16_t aa_ms = ((u16_t)lll->access_addr[3] << 8) |
    e654:	ea42 2201 	orr.w	r2, r2, r1, lsl #8

			lll->data_chan_sel = 1;
    e658:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
			lll->data_chan_id = aa_ms ^ aa_ls;
    e65c:	4053      	eors	r3, r2
			lll->data_chan_sel = 1;
    e65e:	f041 0140 	orr.w	r1, r1, #64	; 0x40
			lll->data_chan_id = aa_ms ^ aa_ls;
    e662:	846b      	strh	r3, [r5, #34]	; 0x22
			lll->data_chan_sel = 1;
    e664:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21

			cs->csa = 0x01;
    e668:	2301      	movs	r3, #1
		} else {
			cs->csa = 0x00;
    e66a:	f88a 3020 	strb.w	r3, [sl, #32]
		}
	}

	ll_rx_put(link, rx);
    e66e:	4651      	mov	r1, sl
    e670:	f00f fe70 	bl	1e354 <ll_rx_put>
	ll_rx_sched();
    e674:	f00f fe78 	bl	1e368 <ll_rx_sched>
	conn->evt.ticks_xtal_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US);
	conn->evt.ticks_preempt_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_PREEMPT_MIN_US);
	conn->evt.ticks_slot =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    e678:	f8d8 b010 	ldr.w	fp, [r8, #16]
    e67c:	f8df a180 	ldr.w	sl, [pc, #384]	; e800 <ull_slave_setup+0x3b0>
	conn->evt.ticks_xtal_to_start =
    e680:	2400      	movs	r4, #0
    e682:	2331      	movs	r3, #49	; 0x31
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    e684:	f20b 4052 	addw	r0, fp, #1106	; 0x452
	conn->evt.ticks_xtal_to_start =
    e688:	e9c6 3400 	strd	r3, r4, [r6]
	conn->evt.ticks_preempt_to_start =
    e68c:	60b4      	str	r4, [r6, #8]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    e68e:	a352      	add	r3, pc, #328	; (adr r3, e7d8 <ull_slave_setup+0x388>)
    e690:	e9d3 2300 	ldrd	r2, r3, [r3]
    e694:	fba0 010a 	umull	r0, r1, r0, sl
    e698:	f7fd fe32 	bl	c300 <__aeabi_uldivmod>
		ticks_slot_overhead = ticks_slot_offset;
	} else {
		ticks_slot_overhead = 0U;
	}

	conn_interval_us -= lll->slave.window_widening_periodic_us;
    e69c:	6aab      	ldr	r3, [r5, #40]	; 0x28

	conn_offset_us = ftr->us_radio_end;
	conn_offset_us += ((u64_t)win_offset + 1) * 1250U;
    e69e:	f8bd 203c 	ldrh.w	r2, [sp, #60]	; 0x3c
	conn_interval_us -= lll->slave.window_widening_periodic_us;
    e6a2:	1aff      	subs	r7, r7, r3
    e6a4:	f8d8 300c 	ldr.w	r3, [r8, #12]
    e6a8:	f5a3 73ae 	sub.w	r3, r3, #348	; 0x15c
    e6ac:	eba3 030b 	sub.w	r3, r3, fp
	conn_offset_us += ((u64_t)win_offset + 1) * 1250U;
    e6b0:	f240 4be2 	movw	fp, #1250	; 0x4e2
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    e6b4:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	conn_offset_us += ((u64_t)win_offset + 1) * 1250U;
    e6b8:	fb0b bb02 	mla	fp, fp, r2, fp
	conn_offset_us -= EVENT_OVERHEAD_START_US;
	conn_offset_us -= EVENT_TICKER_RES_MARGIN_US;
	conn_offset_us -= EVENT_JITTER_US;
	conn_offset_us -= ftr->us_radio_rdy;
    e6bc:	445b      	add	r3, fp

#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	/* disable ticker job, in order to chain stop and start to avoid RTC
	 * being stopped if no tickers active.
	 */
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
    e6be:	4622      	mov	r2, r4
    e6c0:	2102      	movs	r1, #2
	conn->evt.ticks_slot =
    e6c2:	60f0      	str	r0, [r6, #12]
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
    e6c4:	2001      	movs	r0, #1
	conn_offset_us -= ftr->us_radio_rdy;
    e6c6:	930a      	str	r3, [sp, #40]	; 0x28
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
    e6c8:	f00d f85c 	bl	1b784 <mayfly_enable>
#endif

	/* Stop Advertiser */
	ticker_id_adv = TICKER_ID_ADV_BASE + ull_adv_handle_get(adv);
    e6cc:	4648      	mov	r0, r9
    e6ce:	f010 fe59 	bl	1f384 <ull_adv_handle_get>
    e6d2:	1c82      	adds	r2, r0, #2
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
    e6d4:	4b45      	ldr	r3, [pc, #276]	; (e7ec <ull_slave_setup+0x39c>)
    e6d6:	f8cd 9000 	str.w	r9, [sp]
    e6da:	b2d2      	uxtb	r2, r2
    e6dc:	2101      	movs	r1, #1
    e6de:	4620      	mov	r0, r4
    e6e0:	f00d fd7c 	bl	1c1dc <ticker_stop>
				    TICKER_USER_ID_ULL_HIGH,
				    ticker_id_adv, ticker_op_stop_adv_cb, adv);
	ticker_op_stop_adv_cb(ticker_status, adv);
    e6e4:	4649      	mov	r1, r9
    e6e6:	f014 fac1 	bl	22c6c <ticker_op_stop_adv_cb>

	/* Stop Direct Adv Stop */
	if (adv->lll.is_hdcd) {
    e6ea:	f899 3028 	ldrb.w	r3, [r9, #40]	; 0x28
    e6ee:	07db      	lsls	r3, r3, #31
    e6f0:	d506      	bpl.n	e700 <ull_slave_setup+0x2b0>
		/* Advertiser stop can expire while here in this ISR.
		 * Deferred attempt to stop can fail as it would have
		 * expired, hence ignore failure.
		 */
		ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
    e6f2:	2201      	movs	r2, #1
    e6f4:	9400      	str	r4, [sp, #0]
    e6f6:	4623      	mov	r3, r4
    e6f8:	4611      	mov	r1, r2
    e6fa:	4620      	mov	r0, r4
    e6fc:	f00d fd6e 	bl	1c1dc <ticker_stop>
			    TICKER_ID_ADV_STOP, NULL, NULL);
	}

	/* Start Slave */
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    e700:	4630      	mov	r0, r6
    e702:	f011 ff3d 	bl	20580 <ll_conn_handle_get>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
				     TICKER_USER_ID_ULL_HIGH,
				     ticker_id_conn,
				     ftr->ticks_anchor - ticks_slot_offset,
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
    e706:	fba7 450a 	umull	r4, r5, r7, sl
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    e70a:	4681      	mov	r9, r0
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
    e70c:	a332      	add	r3, pc, #200	; (adr r3, e7d8 <ull_slave_setup+0x388>)
    e70e:	e9d3 2300 	ldrd	r2, r3, [r3]
    e712:	4620      	mov	r0, r4
    e714:	4629      	mov	r1, r5
    e716:	f7fd fdf3 	bl	c300 <__aeabi_uldivmod>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    e71a:	f8d8 3008 	ldr.w	r3, [r8, #8]
    e71e:	f1a3 0831 	sub.w	r8, r3, #49	; 0x31
    e722:	f44f 738c 	mov.w	r3, #280	; 0x118
    e726:	9308      	str	r3, [sp, #32]
    e728:	4b31      	ldr	r3, [pc, #196]	; (e7f0 <ull_slave_setup+0x3a0>)
    e72a:	e9cd 6306 	strd	r6, r3, [sp, #24]
    e72e:	4b31      	ldr	r3, [pc, #196]	; (e7f4 <ull_slave_setup+0x3a4>)
    e730:	9305      	str	r3, [sp, #20]
    e732:	68f3      	ldr	r3, [r6, #12]
    e734:	9304      	str	r3, [sp, #16]
				     HAL_TICKER_REMAINDER(conn_interval_us),
    e736:	4b30      	ldr	r3, [pc, #192]	; (e7f8 <ull_slave_setup+0x3a8>)
    e738:	f020 467f 	bic.w	r6, r0, #4278190080	; 0xff000000
    e73c:	fba6 bc03 	umull	fp, ip, r6, r3
    e740:	2307      	movs	r3, #7
    e742:	fb03 cc06 	mla	ip, r3, r6, ip
    e746:	ebb4 000b 	subs.w	r0, r4, fp
    e74a:	eb65 010c 	sbc.w	r1, r5, ip
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    e74e:	f109 0705 	add.w	r7, r9, #5
				     HAL_TICKER_REMAINDER(conn_interval_us),
    e752:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    e756:	f04f 0900 	mov.w	r9, #0
				     HAL_TICKER_REMAINDER(conn_interval_us),
    e75a:	2300      	movs	r3, #0
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    e75c:	f8cd 900c 	str.w	r9, [sp, #12]
				     HAL_TICKER_REMAINDER(conn_interval_us),
    e760:	f7fd fdce 	bl	c300 <__aeabi_uldivmod>
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
    e764:	990a      	ldr	r1, [sp, #40]	; 0x28
    e766:	a31c      	add	r3, pc, #112	; (adr r3, e7d8 <ull_slave_setup+0x388>)
    e768:	e9d3 2300 	ldrd	r2, r3, [r3]
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    e76c:	e9cd 6001 	strd	r6, r0, [sp, #4]
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
    e770:	fba1 010a 	umull	r0, r1, r1, sl
    e774:	f7fd fdc4 	bl	c300 <__aeabi_uldivmod>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    e778:	b2ff      	uxtb	r7, r7
    e77a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    e77e:	9000      	str	r0, [sp, #0]
    e780:	4643      	mov	r3, r8
    e782:	463a      	mov	r2, r7
    e784:	2101      	movs	r1, #1
    e786:	4648      	mov	r0, r9
    e788:	f00d fc96 	bl	1c0b8 <ticker_start>
#endif /* CONFIG_BT_CTLR_CONN_META */
				     (conn->evt.ticks_slot +
				      ticks_slot_overhead),
				     ull_slave_ticker_cb, conn, ticker_op_cb,
				     (void *)__LINE__);
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
    e78c:	f030 0302 	bics.w	r3, r0, #2
    e790:	d008      	beq.n	e7a4 <ull_slave_setup+0x354>
    e792:	481a      	ldr	r0, [pc, #104]	; (e7fc <ull_slave_setup+0x3ac>)
    e794:	f019 fcd6 	bl	28144 <printk>
    e798:	4040      	eors	r0, r0
    e79a:	f380 8811 	msr	BASEPRI, r0
    e79e:	f04f 0003 	mov.w	r0, #3
    e7a2:	df02      	svc	2

#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	/* enable ticker job, irrespective of disabled in this function so
	 * first connection event can be scheduled as soon as possible.
	 */
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1);
    e7a4:	2201      	movs	r2, #1
    e7a6:	2102      	movs	r1, #2
    e7a8:	4610      	mov	r0, r2
    e7aa:	f00c ffeb 	bl	1b784 <mayfly_enable>
#endif
}
    e7ae:	b017      	add	sp, #92	; 0x5c
    e7b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		memset(&cc->peer_rpa[0], 0x0, BDADDR_SIZE);
    e7b4:	2206      	movs	r2, #6
    e7b6:	2100      	movs	r1, #0
    e7b8:	4658      	mov	r0, fp
    e7ba:	f01b fe72 	bl	2a4a2 <memset>
		cc->peer_addr_type = peer_addr_type;
    e7be:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
    e7c2:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
		memcpy(cc->peer_addr, peer_addr, BDADDR_SIZE);
    e7c6:	2206      	movs	r2, #6
    e7c8:	a912      	add	r1, sp, #72	; 0x48
    e7ca:	4650      	mov	r0, sl
    e7cc:	e716      	b.n	e5fc <ull_slave_setup+0x1ac>
			cs->csa = 0x00;
    e7ce:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
    e7d2:	e74a      	b.n	e66a <ull_slave_setup+0x21a>
    e7d4:	f3af 8000 	nop.w
    e7d8:	1afd498d 	.word	0x1afd498d
    e7dc:	00000007 	.word	0x00000007
    e7e0:	000f4240 	.word	0x000f4240
    e7e4:	01c9c37f 	.word	0x01c9c37f
    e7e8:	026259ff 	.word	0x026259ff
    e7ec:	00022c6d 	.word	0x00022c6d
    e7f0:	00022c51 	.word	0x00022c51
    e7f4:	00022c95 	.word	0x00022c95
    e7f8:	1afd498d 	.word	0x1afd498d
    e7fc:	00031c28 	.word	0x00031c28
    e800:	3b9aca00 	.word	0x3b9aca00
    e804:	00000000 	.word	0x00000000

0000e808 <ull_slave_done>:
 * @param ticks_drift_plus[out]  Positive part of drift uncertainty window
 * @param ticks_drift_minus[out] Negative part of drift uncertainty window
 */
void ull_slave_done(struct node_rx_event_done *done, u32_t *ticks_drift_plus,
		    u32_t *ticks_drift_minus)
{
    e808:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    e80c:	4689      	mov	r9, r1
	u32_t window_widening_event_us;
	u32_t preamble_to_addr_us;

	start_to_address_actual_us =
		done->extra.slave.start_to_address_actual_us;
	window_widening_event_us =
    e80e:	e9d0 710b 	ldrd	r7, r1, [r0, #44]	; 0x2c
		done->extra.slave.window_widening_event_us;
	preamble_to_addr_us =
    e812:	6b46      	ldr	r6, [r0, #52]	; 0x34
		done->extra.slave.preamble_to_addr_us;

	start_to_address_expected_us = EVENT_JITTER_US +
    e814:	4d16      	ldr	r5, [pc, #88]	; (e870 <ull_slave_done+0x68>)
				       EVENT_TICKER_RES_MARGIN_US +
				       window_widening_event_us +
    e816:	198c      	adds	r4, r1, r6
	start_to_address_expected_us = EVENT_JITTER_US +
    e818:	3430      	adds	r4, #48	; 0x30
				       preamble_to_addr_us;

	if (start_to_address_actual_us <= start_to_address_expected_us) {
    e81a:	42a7      	cmp	r7, r4
{
    e81c:	4690      	mov	r8, r2
		*ticks_drift_plus =
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
    e81e:	a312      	add	r3, pc, #72	; (adr r3, e868 <ull_slave_done+0x60>)
    e820:	e9d3 2300 	ldrd	r2, r3, [r3]
	if (start_to_address_actual_us <= start_to_address_expected_us) {
    e824:	d815      	bhi.n	e852 <ull_slave_done+0x4a>
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
    e826:	fba1 0105 	umull	r0, r1, r1, r5
    e82a:	f7fd fd69 	bl	c300 <__aeabi_uldivmod>
    e82e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_plus =
    e832:	f8c9 0000 	str.w	r0, [r9]
		*ticks_drift_minus =
			HAL_TICKER_US_TO_TICKS((start_to_address_expected_us -
    e836:	1be0      	subs	r0, r4, r7
					       start_to_address_actual_us));
	} else {
		*ticks_drift_plus =
			HAL_TICKER_US_TO_TICKS(start_to_address_actual_us);
		*ticks_drift_minus =
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
    e838:	a30b      	add	r3, pc, #44	; (adr r3, e868 <ull_slave_done+0x60>)
    e83a:	e9d3 2300 	ldrd	r2, r3, [r3]
    e83e:	fba0 0105 	umull	r0, r1, r0, r5
    e842:	f7fd fd5d 	bl	c300 <__aeabi_uldivmod>
    e846:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_minus =
    e84a:	f8c8 0000 	str.w	r0, [r8]
					       EVENT_TICKER_RES_MARGIN_US +
					       preamble_to_addr_us);
	}
}
    e84e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			HAL_TICKER_US_TO_TICKS(start_to_address_actual_us);
    e852:	fba7 0105 	umull	r0, r1, r7, r5
    e856:	f7fd fd53 	bl	c300 <__aeabi_uldivmod>
    e85a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_plus =
    e85e:	f8c9 0000 	str.w	r0, [r9]
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
    e862:	f106 0030 	add.w	r0, r6, #48	; 0x30
    e866:	e7e7      	b.n	e838 <ull_slave_done+0x30>
    e868:	1afd498d 	.word	0x1afd498d
    e86c:	00000007 	.word	0x00000007
    e870:	3b9aca00 	.word	0x3b9aca00
    e874:	00000000 	.word	0x00000000

0000e878 <ull_master_setup>:
}
#endif /* CONFIG_BT_CTLR_LE_ENC */

void ull_master_setup(memq_link_t *link, struct node_rx_hdr *rx,
		      struct node_rx_ftr *ftr, struct lll_conn *lll)
{
    e878:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e87c:	461d      	mov	r5, r3
	struct ll_conn *conn;
	struct pdu_adv *pdu_tx;
	u32_t ticker_status;
	u8_t chan_sel;

	((struct lll_scan *)ftr->param)->conn = NULL;
    e87e:	6813      	ldr	r3, [r2, #0]
	conn = lll->hdr.parent;

	pdu_tx = (void *)((struct node_rx_pdu *)rx)->pdu;

#if defined(CONFIG_BT_CTLR_PRIVACY)
	u8_t own_addr_type = pdu_tx->tx_addr;
    e880:	f891 b020 	ldrb.w	fp, [r1, #32]
	scan = ((struct lll_scan *)ftr->param)->hdr.parent;
    e884:	f8d3 8000 	ldr.w	r8, [r3]
	conn = lll->hdr.parent;
    e888:	682e      	ldr	r6, [r5, #0]
	((struct lll_scan *)ftr->param)->conn = NULL;
    e88a:	f04f 0a00 	mov.w	sl, #0
{
    e88e:	b095      	sub	sp, #84	; 0x54
	((struct lll_scan *)ftr->param)->conn = NULL;
    e890:	f8c3 a008 	str.w	sl, [r3, #8]
	u8_t own_addr[BDADDR_SIZE];
	u8_t peer_addr[BDADDR_SIZE];
	u8_t rl_idx = ftr->rl_idx;
    e894:	7d53      	ldrb	r3, [r2, #21]
    e896:	930c      	str	r3, [sp, #48]	; 0x30

	memcpy(own_addr, &pdu_tx->connect_ind.init_addr[0], BDADDR_SIZE);
    e898:	f101 0322 	add.w	r3, r1, #34	; 0x22
{
    e89c:	460c      	mov	r4, r1
    e89e:	900e      	str	r0, [sp, #56]	; 0x38
	memcpy(own_addr, &pdu_tx->connect_ind.init_addr[0], BDADDR_SIZE);
    e8a0:	4619      	mov	r1, r3
{
    e8a2:	4617      	mov	r7, r2
	memcpy(own_addr, &pdu_tx->connect_ind.init_addr[0], BDADDR_SIZE);
    e8a4:	a810      	add	r0, sp, #64	; 0x40
    e8a6:	2206      	movs	r2, #6
    e8a8:	930b      	str	r3, [sp, #44]	; 0x2c
    e8aa:	f01b fdd0 	bl	2a44e <memcpy>
	memcpy(peer_addr, &pdu_tx->connect_ind.adv_addr[0], BDADDR_SIZE);
    e8ae:	2206      	movs	r2, #6
    e8b0:	f104 0128 	add.w	r1, r4, #40	; 0x28
    e8b4:	a812      	add	r0, sp, #72	; 0x48
    e8b6:	f01b fdca 	bl	2a44e <memcpy>
#endif

	/* This is the chan sel bit from the received adv pdu */
	chan_sel = pdu_tx->chan_sel;
    e8ba:	f894 9020 	ldrb.w	r9, [r4, #32]

	cc = (void *)pdu_tx;
	cc->status = 0U;
    e8be:	f8a4 a020 	strh.w	sl, [r4, #32]
	u8_t own_addr_type = pdu_tx->tx_addr;
    e8c2:	f3cb 1b80 	ubfx	fp, fp, #6, #1
	chan_sel = pdu_tx->chan_sel;
    e8c6:	f3c9 1940 	ubfx	r9, r9, #5, #1
    e8ca:	fa5f f389 	uxtb.w	r3, r9
	cc->role = 0U;

#if defined(CONFIG_BT_CTLR_PRIVACY)
	cc->own_addr_type = own_addr_type;
    e8ce:	f884 b02f 	strb.w	fp, [r4, #47]	; 0x2f
	memcpy(&cc->own_addr[0], &own_addr[0], BDADDR_SIZE);
    e8d2:	2206      	movs	r2, #6
    e8d4:	a910      	add	r1, sp, #64	; 0x40
    e8d6:	f104 0030 	add.w	r0, r4, #48	; 0x30
	chan_sel = pdu_tx->chan_sel;
    e8da:	930d      	str	r3, [sp, #52]	; 0x34
	memcpy(&cc->own_addr[0], &own_addr[0], BDADDR_SIZE);
    e8dc:	f01b fdb7 	bl	2a44e <memcpy>

	if (rl_idx != FILTER_IDX_NONE) {
    e8e0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    e8e2:	2aff      	cmp	r2, #255	; 0xff
    e8e4:	f104 0329 	add.w	r3, r4, #41	; 0x29
    e8e8:	f104 0b23 	add.w	fp, r4, #35	; 0x23
    e8ec:	f000 80d1 	beq.w	ea92 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x32>
		/* TODO: store rl_idx instead if safe */
		/* Store identity address */
		ll_rl_id_addr_get(rl_idx, &cc->peer_addr_type,
    e8f0:	e9dd 100b 	ldrd	r1, r0, [sp, #44]	; 0x2c
    e8f4:	465a      	mov	r2, fp
    e8f6:	930f      	str	r3, [sp, #60]	; 0x3c
    e8f8:	f014 ffdc 	bl	238b4 <ll_rl_id_addr_get>
				  &cc->peer_addr[0]);
		/* Mark it as identity address from RPA (0x02, 0x03) */
		cc->peer_addr_type += 2;
    e8fc:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22

		/* Store peer RPA */
		memcpy(&cc->peer_rpa[0], &peer_addr[0], BDADDR_SIZE);
    e900:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
		cc->peer_addr_type += 2;
    e902:	3202      	adds	r2, #2
    e904:	f884 2022 	strb.w	r2, [r4, #34]	; 0x22
		memcpy(&cc->peer_rpa[0], &peer_addr[0], BDADDR_SIZE);
    e908:	a912      	add	r1, sp, #72	; 0x48
    e90a:	2206      	movs	r2, #6
    e90c:	4618      	mov	r0, r3
		memset(&cc->peer_rpa[0], 0x0, BDADDR_SIZE);
#else
	if (1) {
#endif /* CONFIG_BT_CTLR_PRIVACY */
		cc->peer_addr_type = scan->lll.adv_addr_type;
		memcpy(cc->peer_addr, scan->lll.adv_addr, BDADDR_SIZE);
    e90e:	f01b fd9e 	bl	2a44e <memcpy>
	}

	cc->interval = lll->interval;
    e912:	8a6b      	ldrh	r3, [r5, #18]
    e914:	86e3      	strh	r3, [r4, #54]	; 0x36
	cc->latency = lll->latency;
    e916:	8aab      	ldrh	r3, [r5, #20]
    e918:	8723      	strh	r3, [r4, #56]	; 0x38
	cc->timeout = scan->lll.conn_timeout;
    e91a:	f8b8 3030 	ldrh.w	r3, [r8, #48]	; 0x30
    e91e:	8763      	strh	r3, [r4, #58]	; 0x3a
	cc->sca = lll_conn_sca_local_get();
    e920:	f01d ff03 	bl	2c72a <lll_conn_sca_local_get>
    e924:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c

	lll->handle = ll_conn_handle_get(conn);
    e928:	4630      	mov	r0, r6
    e92a:	f011 fe29 	bl	20580 <ll_conn_handle_get>
		struct node_rx_cs *cs;

		/* pick the rx node instance stored within the connection
		 * rx node.
		 */
		rx_csa = (void *)ftr->extra;
    e92e:	f8d7 a004 	ldr.w	sl, [r7, #4]
	lll->handle = ll_conn_handle_get(conn);
    e932:	8228      	strh	r0, [r5, #16]

		/* Enqueue the connection event */
		ll_rx_put(link, rx);
    e934:	4621      	mov	r1, r4
	rx->handle = lll->handle;
    e936:	80e0      	strh	r0, [r4, #6]
		ll_rx_put(link, rx);
    e938:	980e      	ldr	r0, [sp, #56]	; 0x38
    e93a:	f00f fd0b 	bl	1e354 <ll_rx_put>

		/* use the rx node for CSA event */
		rx = (void *)rx_csa;
		link = rx->link;

		rx->handle = lll->handle;
    e93e:	8a2b      	ldrh	r3, [r5, #16]
    e940:	f8aa 3006 	strh.w	r3, [sl, #6]
		rx->type = NODE_RX_TYPE_CHAN_SEL_ALGO;
    e944:	230d      	movs	r3, #13
    e946:	f88a 3004 	strb.w	r3, [sl, #4]

		cs = (void *)rx_csa->pdu;

		if (chan_sel) {
    e94a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
		link = rx->link;
    e94c:	f8da 0000 	ldr.w	r0, [sl]
		if (chan_sel) {
    e950:	2b00      	cmp	r3, #0
    e952:	f000 80ae 	beq.w	eab2 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x52>
			u16_t aa_ls = ((u16_t)lll->access_addr[1] << 8) |
    e956:	7a6a      	ldrb	r2, [r5, #9]
				      lll->access_addr[0];
    e958:	7a2b      	ldrb	r3, [r5, #8]
			u16_t aa_ms = ((u16_t)lll->access_addr[3] << 8) |
    e95a:	7ae9      	ldrb	r1, [r5, #11]
			u16_t aa_ls = ((u16_t)lll->access_addr[1] << 8) |
    e95c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
				      lll->access_addr[2];
    e960:	7aaa      	ldrb	r2, [r5, #10]
			u16_t aa_ms = ((u16_t)lll->access_addr[3] << 8) |
    e962:	ea42 2201 	orr.w	r2, r2, r1, lsl #8

			lll->data_chan_sel = 1;
    e966:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
			lll->data_chan_id = aa_ms ^ aa_ls;
    e96a:	4053      	eors	r3, r2
    e96c:	846b      	strh	r3, [r5, #34]	; 0x22
			lll->data_chan_sel = 1;
    e96e:	f041 0140 	orr.w	r1, r1, #64	; 0x40

			cs->csa = 0x01;
    e972:	2301      	movs	r3, #1
			lll->data_chan_sel = 1;
    e974:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21
			cs->csa = 0x01;
    e978:	f88a 3020 	strb.w	r3, [sl, #32]
		} else {
			cs->csa = 0x00;
		}
	}

	ll_rx_put(link, rx);
    e97c:	4651      	mov	r1, sl
    e97e:	f00f fce9 	bl	1e354 <ll_rx_put>
	ll_rx_sched();
    e982:	f00f fcf1 	bl	1e368 <ll_rx_sched>
	conn->evt.ticks_xtal_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US);
	conn->evt.ticks_preempt_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_PREEMPT_MIN_US);
	conn->evt.ticks_slot =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    e986:	f8d7 b010 	ldr.w	fp, [r7, #16]
    e98a:	f8df a144 	ldr.w	sl, [pc, #324]	; ead0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x70>
	conn->evt.ticks_xtal_to_start =
    e98e:	2400      	movs	r4, #0
    e990:	2331      	movs	r3, #49	; 0x31
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    e992:	f20b 4052 	addw	r0, fp, #1106	; 0x452
	conn->evt.ticks_xtal_to_start =
    e996:	e9c6 3400 	strd	r3, r4, [r6]
	conn->evt.ticks_preempt_to_start =
    e99a:	60b4      	str	r4, [r6, #8]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    e99c:	a346      	add	r3, pc, #280	; (adr r3, eab8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x58>)
    e99e:	e9d3 2300 	ldrd	r2, r3, [r3]
    e9a2:	fba0 010a 	umull	r0, r1, r0, sl
    e9a6:	f7fd fcab 	bl	c300 <__aeabi_uldivmod>
		ticks_slot_overhead = ticks_slot_offset;
	} else {
		ticks_slot_overhead = 0U;
	}

	conn_interval_us = lll->interval * 1250;
    e9aa:	8a6b      	ldrh	r3, [r5, #18]
	conn_offset_us = ftr->us_radio_end;
    e9ac:	68fd      	ldr	r5, [r7, #12]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
    e9ae:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	/* disable ticker job, in order to chain stop and start to avoid RTC
	 * being stopped if no tickers active.
	 */
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
    e9b2:	4622      	mov	r2, r4
    e9b4:	2102      	movs	r1, #2
	conn->evt.ticks_slot =
    e9b6:	60f0      	str	r0, [r6, #12]
	conn_interval_us = lll->interval * 1250;
    e9b8:	f240 49e2 	movw	r9, #1250	; 0x4e2
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
    e9bc:	2001      	movs	r0, #1
	conn_interval_us = lll->interval * 1250;
    e9be:	fb09 f903 	mul.w	r9, r9, r3
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
    e9c2:	f00c fedf 	bl	1b784 <mayfly_enable>
#endif

	/* Stop Scanner */
	ticker_id_scan = TICKER_ID_SCAN_BASE + ull_scan_handle_get(scan);
    e9c6:	4640      	mov	r0, r8
    e9c8:	f011 f95e 	bl	1fc88 <ull_scan_handle_get>
    e9cc:	1d02      	adds	r2, r0, #4
    e9ce:	b2d2      	uxtb	r2, r2
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
				    TICKER_USER_ID_ULL_HIGH,
				    ticker_id_scan, ticker_op_stop_scan_cb,
				    (void *)(u32_t)ticker_id_scan);
    e9d0:	9200      	str	r2, [sp, #0]
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
    e9d2:	4b3b      	ldr	r3, [pc, #236]	; (eac0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x60>)
    e9d4:	2101      	movs	r1, #1
    e9d6:	4620      	mov	r0, r4
    e9d8:	f00d fc00 	bl	1c1dc <ticker_stop>

	/* Scanner stop can expire while here in this ISR.
	 * Deferred attempt to stop can fail as it would have
	 * expired, hence ignore failure.
	 */
	ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
    e9dc:	4623      	mov	r3, r4
    e9de:	2203      	movs	r2, #3
    e9e0:	2101      	movs	r1, #1
    e9e2:	9400      	str	r4, [sp, #0]
    e9e4:	4620      	mov	r0, r4
    e9e6:	f00d fbf9 	bl	1c1dc <ticker_stop>
		    TICKER_ID_SCAN_STOP, NULL, NULL);

	/* Start master */
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    e9ea:	4630      	mov	r0, r6
    e9ec:	f011 fdc8 	bl	20580 <ll_conn_handle_get>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    e9f0:	68bb      	ldr	r3, [r7, #8]
	conn_offset_us -= EVENT_OVERHEAD_START_US;
    e9f2:	f5a5 7587 	sub.w	r5, r5, #270	; 0x10e
	conn_offset_us -= ftr->us_radio_rdy;
    e9f6:	eba5 050b 	sub.w	r5, r5, fp
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    e9fa:	f1a3 0b31 	sub.w	fp, r3, #49	; 0x31
    e9fe:	f240 2349 	movw	r3, #585	; 0x249
    ea02:	9308      	str	r3, [sp, #32]
    ea04:	4b2f      	ldr	r3, [pc, #188]	; (eac4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x64>)
    ea06:	e9cd 6306 	strd	r6, r3, [sp, #24]
    ea0a:	4b2f      	ldr	r3, [pc, #188]	; (eac8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x68>)
    ea0c:	9305      	str	r3, [sp, #20]
    ea0e:	68f3      	ldr	r3, [r6, #12]
				     TICKER_USER_ID_ULL_HIGH,
				     ticker_id_conn,
				     ftr->ticks_anchor - ticks_slot_offset,
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
    ea10:	fb89 890a 	smull	r8, r9, r9, sl
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
    ea14:	3005      	adds	r0, #5
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    ea16:	b2c7      	uxtb	r7, r0
    ea18:	e9cd 4303 	strd	r4, r3, [sp, #12]
				     HAL_TICKER_REMAINDER(conn_interval_us),
    ea1c:	4640      	mov	r0, r8
    ea1e:	a326      	add	r3, pc, #152	; (adr r3, eab8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x58>)
    ea20:	e9d3 2300 	ldrd	r2, r3, [r3]
    ea24:	4649      	mov	r1, r9
    ea26:	f7fd fc6b 	bl	c300 <__aeabi_uldivmod>
    ea2a:	4610      	mov	r0, r2
    ea2c:	4619      	mov	r1, r3
    ea2e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    ea32:	2300      	movs	r3, #0
    ea34:	f7fd fc64 	bl	c300 <__aeabi_uldivmod>
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
    ea38:	a31f      	add	r3, pc, #124	; (adr r3, eab8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x58>)
    ea3a:	e9d3 2300 	ldrd	r2, r3, [r3]
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    ea3e:	9002      	str	r0, [sp, #8]
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
    ea40:	4649      	mov	r1, r9
    ea42:	4640      	mov	r0, r8
    ea44:	f7fd fc5c 	bl	c300 <__aeabi_uldivmod>
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
    ea48:	a31b      	add	r3, pc, #108	; (adr r3, eab8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x58>)
    ea4a:	e9d3 2300 	ldrd	r2, r3, [r3]
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
    ea4e:	9001      	str	r0, [sp, #4]
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
    ea50:	fba5 010a 	umull	r0, r1, r5, sl
    ea54:	f7fd fc54 	bl	c300 <__aeabi_uldivmod>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
    ea58:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    ea5c:	9000      	str	r0, [sp, #0]
    ea5e:	465b      	mov	r3, fp
    ea60:	463a      	mov	r2, r7
    ea62:	2101      	movs	r1, #1
    ea64:	4620      	mov	r0, r4
    ea66:	f00d fb27 	bl	1c0b8 <ticker_start>
				     TICKER_NULL_LAZY,
				     (conn->evt.ticks_slot +
				      ticks_slot_overhead),
				     ull_master_ticker_cb, conn, ticker_op_cb,
				     (void *)__LINE__);
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
    ea6a:	f030 0302 	bics.w	r3, r0, #2
    ea6e:	d008      	beq.n	ea82 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x22>
    ea70:	4816      	ldr	r0, [pc, #88]	; (eacc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x6c>)
    ea72:	f019 fb67 	bl	28144 <printk>
    ea76:	4040      	eors	r0, r0
    ea78:	f380 8811 	msr	BASEPRI, r0
    ea7c:	f04f 0003 	mov.w	r0, #3
    ea80:	df02      	svc	2

#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	/* enable ticker job, irrespective of disabled in this function so
	 * first connection event can be scheduled as soon as possible.
	 */
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1);
    ea82:	2201      	movs	r2, #1
    ea84:	2102      	movs	r1, #2
    ea86:	4610      	mov	r0, r2
    ea88:	f00c fe7c 	bl	1b784 <mayfly_enable>
#endif
}
    ea8c:	b015      	add	sp, #84	; 0x54
    ea8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		memset(&cc->peer_rpa[0], 0x0, BDADDR_SIZE);
    ea92:	2206      	movs	r2, #6
    ea94:	4651      	mov	r1, sl
    ea96:	4618      	mov	r0, r3
    ea98:	f01b fd03 	bl	2a4a2 <memset>
		cc->peer_addr_type = scan->lll.adv_addr_type;
    ea9c:	f898 3032 	ldrb.w	r3, [r8, #50]	; 0x32
    eaa0:	f3c3 1340 	ubfx	r3, r3, #5, #1
    eaa4:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
		memcpy(cc->peer_addr, scan->lll.adv_addr, BDADDR_SIZE);
    eaa8:	2206      	movs	r2, #6
    eaaa:	f108 013b 	add.w	r1, r8, #59	; 0x3b
    eaae:	4658      	mov	r0, fp
    eab0:	e72d      	b.n	e90e <ull_master_setup+0x96>
			cs->csa = 0x00;
    eab2:	f88a 9020 	strb.w	r9, [sl, #32]
    eab6:	e761      	b.n	e97c <ull_master_setup+0x104>
    eab8:	1afd498d 	.word	0x1afd498d
    eabc:	00000007 	.word	0x00000007
    eac0:	0002c8e3 	.word	0x0002c8e3
    eac4:	00022f25 	.word	0x00022f25
    eac8:	00022f41 	.word	0x00022f41
    eacc:	00031c28 	.word	0x00031c28
    ead0:	3b9aca00 	.word	0x3b9aca00
    ead4:	00000000 	.word	0x00000000

0000ead8 <erase_op>:
}

#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */

static int erase_op(void *context)
{
    ead8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    eadc:	4604      	mov	r4, r0
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
    eade:	f01e fa4b 	bl	2cf78 <nrfx_nvmc_flash_page_size_get>
#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
	u32_t ticks_begin = 0U;
	u32_t ticks_diff;
	u32_t i = 0U;

	if (e_ctx->enable_time_limit) {
    eae2:	7b25      	ldrb	r5, [r4, #12]
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
    eae4:	4682      	mov	sl, r0
	if (e_ctx->enable_time_limit) {
    eae6:	b115      	cbz	r5, eaee <erase_op+0x16>
		ticks_begin = ticker_ticks_now_get();
    eae8:	f01d f8cb 	bl	2bc82 <ticker_ticks_now_get>
    eaec:	4605      	mov	r5, r0
		if (e_ctx->enable_time_limit) {
			ticks_diff =
				ticker_ticks_diff_get(ticker_ticks_now_get(),
						      ticks_begin);
			if (ticks_diff + ticks_diff/i >
			    HAL_TICKER_US_TO_TICKS(e_ctx->slot)) {
    eaee:	f20f 0968 	addw	r9, pc, #104	; 0x68
    eaf2:	e9d9 8900 	ldrd	r8, r9, [r9]
    eaf6:	f8df b068 	ldr.w	fp, [pc, #104]	; eb60 <erase_op+0x88>
	u32_t ticks_begin = 0U;
    eafa:	2700      	movs	r7, #0
		(void)nrfx_nvmc_page_erase(e_ctx->flash_addr);
    eafc:	6860      	ldr	r0, [r4, #4]
    eafe:	f017 fb7b 	bl	261f8 <nrfx_nvmc_page_erase>
		e_ctx->len -= pg_size;
    eb02:	68a3      	ldr	r3, [r4, #8]
    eb04:	eba3 030a 	sub.w	r3, r3, sl
    eb08:	60a3      	str	r3, [r4, #8]
		e_ctx->flash_addr += pg_size;
    eb0a:	6863      	ldr	r3, [r4, #4]
    eb0c:	4453      	add	r3, sl
    eb0e:	6063      	str	r3, [r4, #4]
		if (e_ctx->enable_time_limit) {
    eb10:	7b23      	ldrb	r3, [r4, #12]
		i++;
    eb12:	3701      	adds	r7, #1
		if (e_ctx->enable_time_limit) {
    eb14:	b94b      	cbnz	r3, eb2a <erase_op+0x52>
				break;
			}
		}
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */

	} while (e_ctx->len > 0);
    eb16:	68a3      	ldr	r3, [r4, #8]
    eb18:	2b00      	cmp	r3, #0
    eb1a:	d1ef      	bne.n	eafc <erase_op+0x24>

	return (e_ctx->len > 0) ? FLASH_OP_ONGOING : FLASH_OP_DONE;
    eb1c:	68a0      	ldr	r0, [r4, #8]
    eb1e:	3000      	adds	r0, #0
    eb20:	bf18      	it	ne
    eb22:	2001      	movne	r0, #1
}
    eb24:	4240      	negs	r0, r0
    eb26:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				ticker_ticks_diff_get(ticker_ticks_now_get(),
    eb2a:	f01d f8aa 	bl	2bc82 <ticker_ticks_now_get>
    eb2e:	4629      	mov	r1, r5
    eb30:	f01d f8a9 	bl	2bc86 <ticker_ticks_diff_get>
			if (ticks_diff + ticks_diff/i >
    eb34:	fbb0 f6f7 	udiv	r6, r0, r7
    eb38:	4406      	add	r6, r0
			    HAL_TICKER_US_TO_TICKS(e_ctx->slot)) {
    eb3a:	6960      	ldr	r0, [r4, #20]
    eb3c:	4642      	mov	r2, r8
    eb3e:	464b      	mov	r3, r9
    eb40:	fba0 010b 	umull	r0, r1, r0, fp
    eb44:	f7fd fbdc 	bl	c300 <__aeabi_uldivmod>
    eb48:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			if (ticks_diff + ticks_diff/i >
    eb4c:	4286      	cmp	r6, r0
    eb4e:	d9e2      	bls.n	eb16 <erase_op+0x3e>
    eb50:	e7e4      	b.n	eb1c <erase_op+0x44>
    eb52:	bf00      	nop
    eb54:	f3af 8000 	nop.w
    eb58:	1afd498d 	.word	0x1afd498d
    eb5c:	00000007 	.word	0x00000007
    eb60:	3b9aca00 	.word	0x3b9aca00
    eb64:	00000000 	.word	0x00000000

0000eb68 <work_in_time_slice>:
{
    eb68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    eb6c:	b08f      	sub	sp, #60	; 0x3c
	struct flash_context *context = p_flash_op_desc->context;
    eb6e:	f8d0 a004 	ldr.w	sl, [r0, #4]
			   HAL_TICKER_US_TO_TICKS(context->interval),
    eb72:	f8df 90d8 	ldr.w	r9, [pc, #216]	; ec4c <work_in_time_slice+0xe4>
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
    eb76:	f10d 0137 	add.w	r1, sp, #55	; 0x37
{
    eb7a:	4680      	mov	r8, r0
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
    eb7c:	f10d 0036 	add.w	r0, sp, #54	; 0x36
    eb80:	f01d f922 	bl	2bdc8 <ll_timeslice_ticker_id_get>
	err = ticker_start(instance_index,
    eb84:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
    eb88:	930a      	str	r3, [sp, #40]	; 0x28
    eb8a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
    eb8e:	930b      	str	r3, [sp, #44]	; 0x2c
    eb90:	f01d f877 	bl	2bc82 <ticker_ticks_now_get>
			   HAL_TICKER_US_TO_TICKS(context->interval),
    eb94:	f8da 4010 	ldr.w	r4, [sl, #16]
    eb98:	fba4 4509 	umull	r4, r5, r4, r9
    eb9c:	a326      	add	r3, pc, #152	; (adr r3, ec38 <work_in_time_slice+0xd0>)
    eb9e:	e9d3 2300 	ldrd	r2, r3, [r3]
	err = ticker_start(instance_index,
    eba2:	2700      	movs	r7, #0
    eba4:	4683      	mov	fp, r0
			   HAL_TICKER_US_TO_TICKS(context->interval),
    eba6:	4629      	mov	r1, r5
    eba8:	4620      	mov	r0, r4
    ebaa:	f7fd fba9 	bl	c300 <__aeabi_uldivmod>
	err = ticker_start(instance_index,
    ebae:	e9cd 7707 	strd	r7, r7, [sp, #28]
    ebb2:	4b23      	ldr	r3, [pc, #140]	; (ec40 <work_in_time_slice+0xd8>)
    ebb4:	9305      	str	r3, [sp, #20]
    ebb6:	f8cd 8018 	str.w	r8, [sp, #24]
			   HAL_TICKER_US_TO_TICKS(context->interval),
    ebba:	4606      	mov	r6, r0
			   HAL_TICKER_US_TO_TICKS(context->slot),
    ebbc:	f8da 0014 	ldr.w	r0, [sl, #20]
    ebc0:	a31d      	add	r3, pc, #116	; (adr r3, ec38 <work_in_time_slice+0xd0>)
    ebc2:	e9d3 2300 	ldrd	r2, r3, [r3]
    ebc6:	fba0 0109 	umull	r0, r1, r0, r9
    ebca:	f7fd fb99 	bl	c300 <__aeabi_uldivmod>
			   HAL_TICKER_REMAINDER(context->interval),
    ebce:	4b1d      	ldr	r3, [pc, #116]	; (ec44 <work_in_time_slice+0xdc>)
    ebd0:	f026 467f 	bic.w	r6, r6, #4278190080	; 0xff000000
    ebd4:	fba6 9a03 	umull	r9, sl, r6, r3
	err = ticker_start(instance_index,
    ebd8:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			   HAL_TICKER_REMAINDER(context->interval),
    ebdc:	2307      	movs	r3, #7
	err = ticker_start(instance_index,
    ebde:	e9cd 7003 	strd	r7, r0, [sp, #12]
			   HAL_TICKER_REMAINDER(context->interval),
    ebe2:	fb03 aa06 	mla	sl, r3, r6, sl
    ebe6:	ebb4 0009 	subs.w	r0, r4, r9
    ebea:	eb65 010a 	sbc.w	r1, r5, sl
    ebee:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    ebf2:	2300      	movs	r3, #0
    ebf4:	f7fd fb84 	bl	c300 <__aeabi_uldivmod>
	err = ticker_start(instance_index,
    ebf8:	465b      	mov	r3, fp
    ebfa:	e9cd 6001 	strd	r6, r0, [sp, #4]
    ebfe:	9700      	str	r7, [sp, #0]
    ec00:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    ec02:	980a      	ldr	r0, [sp, #40]	; 0x28
    ec04:	2103      	movs	r1, #3
    ec06:	f00d fa57 	bl	1c0b8 <ticker_start>
	if (err != TICKER_STATUS_SUCCESS && err != TICKER_STATUS_BUSY) {
    ec0a:	f030 0302 	bics.w	r3, r0, #2
    ec0e:	d10a      	bne.n	ec26 <work_in_time_slice+0xbe>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&sem, *(uintptr_t *)&timeout, K_SYSCALL_K_SEM_TAKE);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_take(sem, timeout);
    ec10:	f645 11b3 	movw	r1, #22963	; 0x59b3
    ec14:	480c      	ldr	r0, [pc, #48]	; (ec48 <work_in_time_slice+0xe0>)
    ec16:	f018 faa3 	bl	27160 <z_impl_k_sem_take>
	} else if (k_sem_take(&sem_sync, K_MSEC(FLASH_TIMEOUT_MS)) != 0) {
    ec1a:	b938      	cbnz	r0, ec2c <work_in_time_slice+0xc4>
		result = p_flash_op_desc->result;
    ec1c:	f8d8 0008 	ldr.w	r0, [r8, #8]
}
    ec20:	b00f      	add	sp, #60	; 0x3c
    ec22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		result = -ECANCELED;
    ec26:	f06f 0047 	mvn.w	r0, #71	; 0x47
    ec2a:	e7f9      	b.n	ec20 <work_in_time_slice+0xb8>
		result = -ETIMEDOUT;
    ec2c:	f06f 003b 	mvn.w	r0, #59	; 0x3b
	return result;
    ec30:	e7f6      	b.n	ec20 <work_in_time_slice+0xb8>
    ec32:	bf00      	nop
    ec34:	f3af 8000 	nop.w
    ec38:	1afd498d 	.word	0x1afd498d
    ec3c:	00000007 	.word	0x00000007
    ec40:	000256dd 	.word	0x000256dd
    ec44:	1afd498d 	.word	0x1afd498d
    ec48:	200039d4 	.word	0x200039d4
    ec4c:	3b9aca00 	.word	0x3b9aca00

0000ec50 <write_op>:
	w_ctx->data_addr += shift;
	w_ctx->len -= shift;
}

static int write_op(void *context)
{
    ec50:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
	u32_t ticks_begin = 0U;
	u32_t ticks_diff;
	u32_t i = 1U;

	if (w_ctx->enable_time_limit) {
    ec54:	7b06      	ldrb	r6, [r0, #12]
{
    ec56:	4604      	mov	r4, r0
	if (w_ctx->enable_time_limit) {
    ec58:	b116      	cbz	r6, ec60 <write_op+0x10>
		ticks_begin = ticker_ticks_now_get();
    ec5a:	f01d f812 	bl	2bc82 <ticker_ticks_now_get>
    ec5e:	4606      	mov	r6, r0
	}
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */

	/* If not aligned, write unaligned beginning */
	if (!is_aligned_32(w_ctx->flash_addr)) {
    ec60:	6860      	ldr	r0, [r4, #4]
    ec62:	f010 0503 	ands.w	r5, r0, #3
    ec66:	d067      	beq.n	ed38 <write_op+0xe8>
		count = sizeof(u32_t) - (w_ctx->flash_addr & 0x3);
    ec68:	68a3      	ldr	r3, [r4, #8]
		if (count > w_ctx->len) {
			count = w_ctx->len;
		}

		nrfx_nvmc_bytes_write(w_ctx->flash_addr,
    ec6a:	6821      	ldr	r1, [r4, #0]
		count = sizeof(u32_t) - (w_ctx->flash_addr & 0x3);
    ec6c:	f1c5 0504 	rsb	r5, r5, #4
		if (count > w_ctx->len) {
    ec70:	429d      	cmp	r5, r3
    ec72:	bf28      	it	cs
    ec74:	461d      	movcs	r5, r3
		nrfx_nvmc_bytes_write(w_ctx->flash_addr,
    ec76:	462a      	mov	r2, r5
    ec78:	f017 faec 	bl	26254 <nrfx_nvmc_bytes_write>
	w_ctx->flash_addr += shift;
    ec7c:	6863      	ldr	r3, [r4, #4]
    ec7e:	442b      	add	r3, r5
    ec80:	6063      	str	r3, [r4, #4]
	w_ctx->data_addr += shift;
    ec82:	6823      	ldr	r3, [r4, #0]
    ec84:	442b      	add	r3, r5
    ec86:	6023      	str	r3, [r4, #0]
	w_ctx->len -= shift;
    ec88:	68a3      	ldr	r3, [r4, #8]
    ec8a:	1b5d      	subs	r5, r3, r5
				      count);

		shift_write_context(count, w_ctx);

#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
		if (w_ctx->enable_time_limit) {
    ec8c:	7b23      	ldrb	r3, [r4, #12]
	w_ctx->len -= shift;
    ec8e:	60a5      	str	r5, [r4, #8]
		if (w_ctx->enable_time_limit) {
    ec90:	2b00      	cmp	r3, #0
    ec92:	d051      	beq.n	ed38 <write_op+0xe8>
			ticks_diff =
				ticker_ticks_diff_get(ticker_ticks_now_get(),
    ec94:	f01c fff5 	bl	2bc82 <ticker_ticks_now_get>
    ec98:	4631      	mov	r1, r6
    ec9a:	f01c fff4 	bl	2bc86 <ticker_ticks_diff_get>
						      ticks_begin);
			if (ticks_diff * 2U >
			    HAL_TICKER_US_TO_TICKS(w_ctx->slot)) {
    ec9e:	492c      	ldr	r1, [pc, #176]	; (ed50 <write_op+0x100>)
			if (ticks_diff * 2U >
    eca0:	0045      	lsls	r5, r0, #1
			    HAL_TICKER_US_TO_TICKS(w_ctx->slot)) {
    eca2:	6960      	ldr	r0, [r4, #20]
    eca4:	a328      	add	r3, pc, #160	; (adr r3, ed48 <write_op+0xf8>)
    eca6:	e9d3 2300 	ldrd	r2, r3, [r3]
    ecaa:	fba0 0101 	umull	r0, r1, r0, r1
    ecae:	f7fd fb27 	bl	c300 <__aeabi_uldivmod>
    ecb2:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			if (ticks_diff * 2U >
    ecb6:	4285      	cmp	r5, r0
    ecb8:	d93e      	bls.n	ed38 <write_op+0xe8>
				nvmc_wait_ready();
    ecba:	f016 fcf9 	bl	256b0 <nvmc_wait_ready>
				return FLASH_OP_ONGOING;
    ecbe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}

	nvmc_wait_ready();

	return FLASH_OP_DONE;
}
    ecc2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				     UNALIGNED_GET((u32_t *)w_ctx->data_addr));
    ecc6:	6823      	ldr	r3, [r4, #0]
		nrfx_nvmc_word_write(w_ctx->flash_addr,
    ecc8:	6860      	ldr	r0, [r4, #4]
    ecca:	6819      	ldr	r1, [r3, #0]
    eccc:	f017 fab4 	bl	26238 <nrfx_nvmc_word_write>
	w_ctx->flash_addr += shift;
    ecd0:	6863      	ldr	r3, [r4, #4]
    ecd2:	3304      	adds	r3, #4
    ecd4:	6063      	str	r3, [r4, #4]
	w_ctx->data_addr += shift;
    ecd6:	6823      	ldr	r3, [r4, #0]
    ecd8:	3304      	adds	r3, #4
    ecda:	6023      	str	r3, [r4, #0]
	w_ctx->len -= shift;
    ecdc:	68a3      	ldr	r3, [r4, #8]
    ecde:	3b04      	subs	r3, #4
    ece0:	60a3      	str	r3, [r4, #8]
		if (w_ctx->enable_time_limit) {
    ece2:	7b23      	ldrb	r3, [r4, #12]
		i++;
    ece4:	3501      	adds	r5, #1
		if (w_ctx->enable_time_limit) {
    ece6:	b193      	cbz	r3, ed0e <write_op+0xbe>
				ticker_ticks_diff_get(ticker_ticks_now_get(),
    ece8:	f01c ffcb 	bl	2bc82 <ticker_ticks_now_get>
    ecec:	4631      	mov	r1, r6
    ecee:	f01c ffca 	bl	2bc86 <ticker_ticks_diff_get>
			if (ticks_diff + ticks_diff/i >
    ecf2:	fbb0 f7f5 	udiv	r7, r0, r5
    ecf6:	4407      	add	r7, r0
			    HAL_TICKER_US_TO_TICKS(w_ctx->slot)) {
    ecf8:	6960      	ldr	r0, [r4, #20]
    ecfa:	4642      	mov	r2, r8
    ecfc:	464b      	mov	r3, r9
    ecfe:	fba0 010a 	umull	r0, r1, r0, sl
    ed02:	f7fd fafd 	bl	c300 <__aeabi_uldivmod>
    ed06:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			if (ticks_diff + ticks_diff/i >
    ed0a:	4287      	cmp	r7, r0
    ed0c:	d8d5      	bhi.n	ecba <write_op+0x6a>
	while (w_ctx->len >= sizeof(u32_t)) {
    ed0e:	68a2      	ldr	r2, [r4, #8]
    ed10:	2a03      	cmp	r2, #3
    ed12:	d8d8      	bhi.n	ecc6 <write_op+0x76>
	if (w_ctx->len) {
    ed14:	b162      	cbz	r2, ed30 <write_op+0xe0>
		nrfx_nvmc_bytes_write(w_ctx->flash_addr,
    ed16:	e9d4 1000 	ldrd	r1, r0, [r4]
    ed1a:	f017 fa9b 	bl	26254 <nrfx_nvmc_bytes_write>
	w_ctx->flash_addr += shift;
    ed1e:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
	w_ctx->data_addr += shift;
    ed22:	6823      	ldr	r3, [r4, #0]
    ed24:	440b      	add	r3, r1
	w_ctx->flash_addr += shift;
    ed26:	440a      	add	r2, r1
	w_ctx->data_addr += shift;
    ed28:	6023      	str	r3, [r4, #0]
	w_ctx->len -= shift;
    ed2a:	2300      	movs	r3, #0
	w_ctx->flash_addr += shift;
    ed2c:	6062      	str	r2, [r4, #4]
	w_ctx->len -= shift;
    ed2e:	60a3      	str	r3, [r4, #8]
	nvmc_wait_ready();
    ed30:	f016 fcbe 	bl	256b0 <nvmc_wait_ready>
	return FLASH_OP_DONE;
    ed34:	2000      	movs	r0, #0
    ed36:	e7c4      	b.n	ecc2 <write_op+0x72>
	u32_t ticks_begin = 0U;
    ed38:	2501      	movs	r5, #1
			    HAL_TICKER_US_TO_TICKS(w_ctx->slot)) {
    ed3a:	f8df a014 	ldr.w	sl, [pc, #20]	; ed50 <write_op+0x100>
    ed3e:	f20f 0908 	addw	r9, pc, #8
    ed42:	e9d9 8900 	ldrd	r8, r9, [r9]
    ed46:	e7e2      	b.n	ed0e <write_op+0xbe>
    ed48:	1afd498d 	.word	0x1afd498d
    ed4c:	00000007 	.word	0x00000007
    ed50:	3b9aca00 	.word	0x3b9aca00

0000ed54 <main>:
#include "dfu_ble.h"

LOG_MODULE_REGISTER(MAIN);

void main(void)
{
    ed54:	b508      	push	{r3, lr}
    int err;
    
    if( err = bt_init(), err ){
    ed56:	f000 facf 	bl	f2f8 <bt_init>
    ed5a:	4601      	mov	r1, r0
    ed5c:	b1b0      	cbz	r0, ed8c <main+0x38>
        LOG_ERR("Bluetooth init error (%d)", err);
    ed5e:	4b24      	ldr	r3, [pc, #144]	; (edf0 <main+0x9c>)
    ed60:	681b      	ldr	r3, [r3, #0]
    ed62:	0758      	lsls	r0, r3, #29
    ed64:	d00d      	beq.n	ed82 <main+0x2e>
    ed66:	2301      	movs	r3, #1
    ed68:	f04f 0200 	mov.w	r2, #0
    ed6c:	f363 0207 	bfi	r2, r3, #0, #8
 * @return Source ID.
 */
static inline u32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((u8_t *)data - (u8_t *)__log_const_start)/
    ed70:	4820      	ldr	r0, [pc, #128]	; (edf4 <main+0xa0>)
    ed72:	4b21      	ldr	r3, [pc, #132]	; (edf8 <main+0xa4>)
    ed74:	1a1b      	subs	r3, r3, r0
    ed76:	08db      	lsrs	r3, r3, #3
    ed78:	4820      	ldr	r0, [pc, #128]	; (edfc <main+0xa8>)
    ed7a:	f363 128f 	bfi	r2, r3, #6, #10
        LOG_ERR("Enable DFU error (%d)", err);
        goto run;
    }

    if( err = dfu_confirm_image(), err ){
        LOG_ERR("Confirm image error (%d)", err);
    ed7e:	f019 fde9 	bl	28954 <log_1>
	return z_impl_k_sleep(ms);
    ed82:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    ed86:	f018 f991 	bl	270ac <z_impl_k_sleep>
    ed8a:	e7fa      	b.n	ed82 <main+0x2e>
    if( err = dfu_init(1), err ){
    ed8c:	2001      	movs	r0, #1
    ed8e:	f000 fda3 	bl	f8d8 <dfu_init>
    ed92:	4601      	mov	r1, r0
    ed94:	b180      	cbz	r0, edb8 <main+0x64>
        LOG_ERR("Enable DFU error (%d)", err);
    ed96:	4b16      	ldr	r3, [pc, #88]	; (edf0 <main+0x9c>)
    ed98:	681b      	ldr	r3, [r3, #0]
    ed9a:	075a      	lsls	r2, r3, #29
    ed9c:	d0f1      	beq.n	ed82 <main+0x2e>
    ed9e:	2301      	movs	r3, #1
    eda0:	f04f 0200 	mov.w	r2, #0
    eda4:	f363 0207 	bfi	r2, r3, #0, #8
    eda8:	4812      	ldr	r0, [pc, #72]	; (edf4 <main+0xa0>)
    edaa:	4b13      	ldr	r3, [pc, #76]	; (edf8 <main+0xa4>)
    edac:	1a1b      	subs	r3, r3, r0
    edae:	08db      	lsrs	r3, r3, #3
    edb0:	f363 128f 	bfi	r2, r3, #6, #10
    edb4:	4812      	ldr	r0, [pc, #72]	; (ee00 <main+0xac>)
    edb6:	e7e2      	b.n	ed7e <main+0x2a>
    if( err = dfu_mode(1), err ){
    edb8:	2001      	movs	r0, #1
    edba:	f000 ff21 	bl	fc00 <dfu_mode>
    edbe:	4601      	mov	r1, r0
    edc0:	2800      	cmp	r0, #0
    edc2:	d1e8      	bne.n	ed96 <main+0x42>
    if( err = dfu_confirm_image(), err ){
    edc4:	f018 fde1 	bl	2798a <dfu_confirm_image>
    edc8:	4601      	mov	r1, r0
    edca:	2800      	cmp	r0, #0
    edcc:	d0d9      	beq.n	ed82 <main+0x2e>
        LOG_ERR("Confirm image error (%d)", err);
    edce:	4b08      	ldr	r3, [pc, #32]	; (edf0 <main+0x9c>)
    edd0:	681b      	ldr	r3, [r3, #0]
    edd2:	075b      	lsls	r3, r3, #29
    edd4:	d0d5      	beq.n	ed82 <main+0x2e>
    edd6:	2301      	movs	r3, #1
    edd8:	f04f 0200 	mov.w	r2, #0
    eddc:	f363 0207 	bfi	r2, r3, #0, #8
    ede0:	4804      	ldr	r0, [pc, #16]	; (edf4 <main+0xa0>)
    ede2:	4b05      	ldr	r3, [pc, #20]	; (edf8 <main+0xa4>)
    ede4:	1a1b      	subs	r3, r3, r0
    ede6:	08db      	lsrs	r3, r3, #3
    ede8:	f363 128f 	bfi	r2, r3, #6, #10
    edec:	4805      	ldr	r0, [pc, #20]	; (ee04 <main+0xb0>)
    edee:	e7c6      	b.n	ed7e <main+0x2a>
    edf0:	2000ff98 	.word	0x2000ff98
    edf4:	0002db28 	.word	0x0002db28
    edf8:	0002db28 	.word	0x0002db28
    edfc:	0002e858 	.word	0x0002e858
    ee00:	0002e872 	.word	0x0002e872
    ee04:	0002e888 	.word	0x0002e888

0000ee08 <bt_addr_le_to_str>:
 *
 *  @return Number of successfully formatted bytes from binary address.
 */
static inline int bt_addr_le_to_str(const bt_addr_le_t *addr, char *str,
				    size_t len)
{
    ee08:	b5f0      	push	{r4, r5, r6, r7, lr}
	char type[10];

	switch (addr->type) {
    ee0a:	7803      	ldrb	r3, [r0, #0]
{
    ee0c:	b08b      	sub	sp, #44	; 0x2c
    ee0e:	4604      	mov	r4, r0
    ee10:	460e      	mov	r6, r1
    ee12:	4617      	mov	r7, r2
    ee14:	ad07      	add	r5, sp, #28
	switch (addr->type) {
    ee16:	2b03      	cmp	r3, #3
    ee18:	d820      	bhi.n	ee5c <bt_addr_le_to_str+0x54>
    ee1a:	e8df f003 	tbb	[pc, r3]
    ee1e:	1902      	.short	0x1902
    ee20:	1d1b      	.short	0x1d1b
	case BT_ADDR_LE_PUBLIC:
		strcpy(type, "public");
    ee22:	4911      	ldr	r1, [pc, #68]	; (ee68 <bt_addr_le_to_str+0x60>)
		break;
	case BT_ADDR_LE_RANDOM:
		strcpy(type, "random");
    ee24:	4628      	mov	r0, r5
    ee26:	f01b fa9e 	bl	2a366 <strcpy>
	default:
		snprintk(type, sizeof(type), "0x%02x", addr->type);
		break;
	}

	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
    ee2a:	7863      	ldrb	r3, [r4, #1]
    ee2c:	9304      	str	r3, [sp, #16]
    ee2e:	78a3      	ldrb	r3, [r4, #2]
    ee30:	9303      	str	r3, [sp, #12]
    ee32:	78e3      	ldrb	r3, [r4, #3]
    ee34:	9302      	str	r3, [sp, #8]
    ee36:	7923      	ldrb	r3, [r4, #4]
    ee38:	9301      	str	r3, [sp, #4]
    ee3a:	7963      	ldrb	r3, [r4, #5]
    ee3c:	9300      	str	r3, [sp, #0]
    ee3e:	9505      	str	r5, [sp, #20]
    ee40:	79a3      	ldrb	r3, [r4, #6]
    ee42:	4a0a      	ldr	r2, [pc, #40]	; (ee6c <bt_addr_le_to_str+0x64>)
    ee44:	4639      	mov	r1, r7
    ee46:	4630      	mov	r0, r6
    ee48:	f019 f989 	bl	2815e <snprintk>
			addr->a.val[5], addr->a.val[4], addr->a.val[3],
			addr->a.val[2], addr->a.val[1], addr->a.val[0], type);
}
    ee4c:	b00b      	add	sp, #44	; 0x2c
    ee4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		strcpy(type, "random");
    ee50:	4907      	ldr	r1, [pc, #28]	; (ee70 <bt_addr_le_to_str+0x68>)
    ee52:	e7e7      	b.n	ee24 <bt_addr_le_to_str+0x1c>
		strcpy(type, "public-id");
    ee54:	4907      	ldr	r1, [pc, #28]	; (ee74 <bt_addr_le_to_str+0x6c>)
    ee56:	e7e5      	b.n	ee24 <bt_addr_le_to_str+0x1c>
		strcpy(type, "random-id");
    ee58:	4907      	ldr	r1, [pc, #28]	; (ee78 <bt_addr_le_to_str+0x70>)
    ee5a:	e7e3      	b.n	ee24 <bt_addr_le_to_str+0x1c>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
    ee5c:	4a07      	ldr	r2, [pc, #28]	; (ee7c <bt_addr_le_to_str+0x74>)
    ee5e:	210a      	movs	r1, #10
    ee60:	4628      	mov	r0, r5
    ee62:	f019 f97c 	bl	2815e <snprintk>
		break;
    ee66:	e7e0      	b.n	ee2a <bt_addr_le_to_str+0x22>
    ee68:	0002e8a6 	.word	0x0002e8a6
    ee6c:	0002e8c8 	.word	0x0002e8c8
    ee70:	0002e8ad 	.word	0x0002e8ad
    ee74:	0002e8b4 	.word	0x0002e8b4
    ee78:	0002e8be 	.word	0x0002e8be
    ee7c:	0003161a 	.word	0x0003161a

0000ee80 <le_param_updated>:
}

static void le_param_updated(struct bt_conn *conn, u16_t interval,
			     u16_t latency, u16_t timeout)
{
	printk("LE conn param updated: int 0x%04x lat %d "
    ee80:	4801      	ldr	r0, [pc, #4]	; (ee88 <le_param_updated+0x8>)
    ee82:	f019 b95f 	b.w	28144 <printk>
    ee86:	bf00      	nop
    ee88:	0002eba1 	.word	0x0002eba1

0000ee8c <le_param_req>:
{
    ee8c:	b507      	push	{r0, r1, r2, lr}
	printk("LE conn  param req: int (0x%04x, 0x%04x) lat %d"
    ee8e:	88cb      	ldrh	r3, [r1, #6]
    ee90:	9300      	str	r3, [sp, #0]
    ee92:	888b      	ldrh	r3, [r1, #4]
    ee94:	884a      	ldrh	r2, [r1, #2]
    ee96:	4804      	ldr	r0, [pc, #16]	; (eea8 <le_param_req+0x1c>)
    ee98:	8809      	ldrh	r1, [r1, #0]
    ee9a:	f019 f953 	bl	28144 <printk>
}
    ee9e:	2001      	movs	r0, #1
    eea0:	b003      	add	sp, #12
    eea2:	f85d fb04 	ldr.w	pc, [sp], #4
    eea6:	bf00      	nop
    eea8:	0002eb6a 	.word	0x0002eb6a

0000eeac <cmd_id_show>:

    return 0;
}

static int cmd_id_show(const struct shell *shell, size_t argc, char *argv[])
{
    eeac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    eeb0:	b08f      	sub	sp, #60	; 0x3c
    bt_addr_le_t addrs[CONFIG_BT_ID_MAX];
    size_t i, count = CONFIG_BT_ID_MAX;
    eeb2:	2301      	movs	r3, #1
{
    eeb4:	4606      	mov	r6, r0

    bt_id_get(addrs, &count);
    eeb6:	a903      	add	r1, sp, #12
    eeb8:	a804      	add	r0, sp, #16
    size_t i, count = CONFIG_BT_ID_MAX;
    eeba:	9303      	str	r3, [sp, #12]
    bt_id_get(addrs, &count);
    eebc:	f007 fe26 	bl	16b0c <bt_id_get>

    for (i = 0; i < count; i++) {
        char addr_str[BT_ADDR_LE_STR_LEN];

        bt_addr_le_to_str(&addrs[i], addr_str, sizeof(addr_str));
        shell_print(shell, "%s%zu: %s", i == selected_id ? "*" : " ", i, addr_str);
    eec0:	4f11      	ldr	r7, [pc, #68]	; (ef08 <cmd_id_show+0x5c>)
    eec2:	f8df 8048 	ldr.w	r8, [pc, #72]	; ef0c <cmd_id_show+0x60>
    eec6:	f8df 9048 	ldr.w	r9, [pc, #72]	; ef10 <cmd_id_show+0x64>
    for (i = 0; i < count; i++) {
    eeca:	2400      	movs	r4, #0
    eecc:	9b03      	ldr	r3, [sp, #12]
    eece:	42a3      	cmp	r3, r4
    eed0:	d803      	bhi.n	eeda <cmd_id_show+0x2e>
    }

    return 0;
}
    eed2:	2000      	movs	r0, #0
    eed4:	b00f      	add	sp, #60	; 0x3c
    eed6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        bt_addr_le_to_str(&addrs[i], addr_str, sizeof(addr_str));
    eeda:	ab04      	add	r3, sp, #16
    eedc:	ad06      	add	r5, sp, #24
    eede:	ebc4 00c4 	rsb	r0, r4, r4, lsl #3
    eee2:	221e      	movs	r2, #30
    eee4:	4629      	mov	r1, r5
    eee6:	4418      	add	r0, r3
    eee8:	f7ff ff8e 	bl	ee08 <bt_addr_le_to_str>
        shell_print(shell, "%s%zu: %s", i == selected_id ? "*" : " ", i, addr_str);
    eeec:	e9cd 4500 	strd	r4, r5, [sp]
    eef0:	2c00      	cmp	r4, #0
    eef2:	bf0c      	ite	eq
    eef4:	463b      	moveq	r3, r7
    eef6:	4643      	movne	r3, r8
    eef8:	464a      	mov	r2, r9
    eefa:	2100      	movs	r1, #0
    eefc:	4630      	mov	r0, r6
    eefe:	f01a f8e1 	bl	290c4 <shell_fprintf>
    for (i = 0; i < count; i++) {
    ef02:	3401      	adds	r4, #1
    ef04:	e7e2      	b.n	eecc <cmd_id_show+0x20>
    ef06:	bf00      	nop
    ef08:	000305d9 	.word	0x000305d9
    ef0c:	0002f4a5 	.word	0x0002f4a5
    ef10:	0002e9f7 	.word	0x0002e9f7

0000ef14 <device_found>:
{
    ef14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ef18:	b092      	sub	sp, #72	; 0x48
    (void) memset(name, 0, sizeof(name));
    ef1a:	ac0a      	add	r4, sp, #40	; 0x28
{
    ef1c:	4698      	mov	r8, r3
    ef1e:	4607      	mov	r7, r0
    ef20:	460e      	mov	r6, r1
    ef22:	4615      	mov	r5, r2
    (void) memset(name, 0, sizeof(name));
    ef24:	2100      	movs	r1, #0
    ef26:	221e      	movs	r2, #30
    ef28:	4620      	mov	r0, r4
    ef2a:	f01b faba 	bl	2a4a2 <memset>
    bt_data_parse(buf, data_cb, name);
    ef2e:	4622      	mov	r2, r4
    ef30:	4640      	mov	r0, r8
    ef32:	4909      	ldr	r1, [pc, #36]	; (ef58 <device_found+0x44>)
    ef34:	f006 fe00 	bl	15b38 <bt_data_parse>
    bt_addr_le_to_str(addr, le_addr, sizeof(le_addr));
    ef38:	a902      	add	r1, sp, #8
    ef3a:	221e      	movs	r2, #30
    ef3c:	4638      	mov	r0, r7
    ef3e:	f7ff ff63 	bl	ee08 <bt_addr_le_to_str>
    printk("[DEVICE]: %s, AD evt type %u, RSSI %i %s\n", le_addr, evtype, rssi, name);
    ef42:	9400      	str	r4, [sp, #0]
    ef44:	4633      	mov	r3, r6
    ef46:	462a      	mov	r2, r5
    ef48:	a902      	add	r1, sp, #8
    ef4a:	4804      	ldr	r0, [pc, #16]	; (ef5c <device_found+0x48>)
    ef4c:	f019 f8fa 	bl	28144 <printk>
}
    ef50:	b012      	add	sp, #72	; 0x48
    ef52:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ef56:	bf00      	nop
    ef58:	000278c1 	.word	0x000278c1
    ef5c:	0002eb22 	.word	0x0002eb22

0000ef60 <cmd_scan>:
{
    const char *action;
    int dups = -1;

    /* Parse duplicate filtering data */
    if (argc >= 3) {
    ef60:	2902      	cmp	r1, #2
{
    ef62:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    ef64:	4605      	mov	r5, r0
    ef66:	4616      	mov	r6, r2
    if (argc >= 3) {
    ef68:	d912      	bls.n	ef90 <cmd_scan+0x30>
        const char *dup_filter = argv[2];
    ef6a:	6897      	ldr	r7, [r2, #8]

        if (!strcmp(dup_filter, "dups")) {
    ef6c:	4930      	ldr	r1, [pc, #192]	; (f030 <cmd_scan+0xd0>)
    ef6e:	4638      	mov	r0, r7
    ef70:	f01b fa2b 	bl	2a3ca <strcmp>
    ef74:	4604      	mov	r4, r0
    ef76:	b168      	cbz	r0, ef94 <cmd_scan+0x34>
            dups = BT_HCI_LE_SCAN_FILTER_DUP_DISABLE;
        } else if (!strcmp(dup_filter, "nodups")) {
    ef78:	492e      	ldr	r1, [pc, #184]	; (f034 <cmd_scan+0xd4>)
    ef7a:	4638      	mov	r0, r7
    ef7c:	f01b fa25 	bl	2a3ca <strcmp>
    ef80:	b328      	cbz	r0, efce <cmd_scan+0x6e>
            dups = BT_HCI_LE_SCAN_FILTER_DUP_ENABLE;
        } else {
            shell_help(shell);
    ef82:	4628      	mov	r0, r5
    ef84:	f01a f8cb 	bl	2911e <shell_help>
            return SHELL_CMD_HELP_PRINTED;
    ef88:	2401      	movs	r4, #1
        shell_help(shell);
        return SHELL_CMD_HELP_PRINTED;
    }

    return 0;
}
    ef8a:	4620      	mov	r0, r4
    ef8c:	b003      	add	sp, #12
    ef8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    int dups = -1;
    ef90:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    action = argv[1];
    ef94:	6876      	ldr	r6, [r6, #4]
    if (!strcmp(action, "on")) {
    ef96:	4928      	ldr	r1, [pc, #160]	; (f038 <cmd_scan+0xd8>)
    ef98:	4630      	mov	r0, r6
    ef9a:	f01b fa16 	bl	2a3ca <strcmp>
    ef9e:	b9f0      	cbnz	r0, efde <cmd_scan+0x7e>
    struct bt_le_scan_param param = {.type       = BT_HCI_LE_SCAN_ACTIVE,
    efa0:	4b26      	ldr	r3, [pc, #152]	; (f03c <cmd_scan+0xdc>)
    err = bt_le_scan_start(&param, device_found);
    efa2:	4927      	ldr	r1, [pc, #156]	; (f040 <cmd_scan+0xe0>)
    struct bt_le_scan_param param = {.type       = BT_HCI_LE_SCAN_ACTIVE,
    efa4:	6818      	ldr	r0, [r3, #0]
    efa6:	9000      	str	r0, [sp, #0]
    if (dups >= 0) {
    efa8:	1c62      	adds	r2, r4, #1
    struct bt_le_scan_param param = {.type       = BT_HCI_LE_SCAN_ACTIVE,
    efaa:	889b      	ldrh	r3, [r3, #4]
        param.filter_dup = dups;
    efac:	bf18      	it	ne
    efae:	f88d 4001 	strbne.w	r4, [sp, #1]
    err = bt_le_scan_start(&param, device_found);
    efb2:	4668      	mov	r0, sp
    struct bt_le_scan_param param = {.type       = BT_HCI_LE_SCAN_ACTIVE,
    efb4:	f8ad 3004 	strh.w	r3, [sp, #4]
    err = bt_le_scan_start(&param, device_found);
    efb8:	f008 fb70 	bl	1769c <bt_le_scan_start>
    if (err) {
    efbc:	4604      	mov	r4, r0
    efbe:	b140      	cbz	r0, efd2 <cmd_scan+0x72>
        shell_error(shell,
    efc0:	4a20      	ldr	r2, [pc, #128]	; (f044 <cmd_scan+0xe4>)
    efc2:	4603      	mov	r3, r0
        shell_error(shell,
    efc4:	2102      	movs	r1, #2
    efc6:	4628      	mov	r0, r5
    efc8:	f01a f87c 	bl	290c4 <shell_fprintf>
        return err;
    efcc:	e7dd      	b.n	ef8a <cmd_scan+0x2a>
            dups = BT_HCI_LE_SCAN_FILTER_DUP_ENABLE;
    efce:	2401      	movs	r4, #1
    efd0:	e7e0      	b.n	ef94 <cmd_scan+0x34>
        shell_print(shell, "Bluetooth active scan enabled");
    efd2:	4a1d      	ldr	r2, [pc, #116]	; (f048 <cmd_scan+0xe8>)
        shell_print(shell, "Bluetooth passive scan enabled");
    efd4:	4621      	mov	r1, r4
    efd6:	4628      	mov	r0, r5
    efd8:	f01a f874 	bl	290c4 <shell_fprintf>
        return cmd_passive_scan_on(shell, dups);
    efdc:	e7d5      	b.n	ef8a <cmd_scan+0x2a>
    } else if (!strcmp(action, "off")) {
    efde:	491b      	ldr	r1, [pc, #108]	; (f04c <cmd_scan+0xec>)
    efe0:	4630      	mov	r0, r6
    efe2:	f01b f9f2 	bl	2a3ca <strcmp>
    efe6:	b940      	cbnz	r0, effa <cmd_scan+0x9a>
    err = bt_le_scan_stop();
    efe8:	f008 fbb0 	bl	1774c <bt_le_scan_stop>
    if (err) {
    efec:	4604      	mov	r4, r0
    efee:	b110      	cbz	r0, eff6 <cmd_scan+0x96>
        shell_error(shell, "Stopping scanning failed (err %d)", err);
    eff0:	4603      	mov	r3, r0
    eff2:	4a17      	ldr	r2, [pc, #92]	; (f050 <cmd_scan+0xf0>)
    eff4:	e7e6      	b.n	efc4 <cmd_scan+0x64>
        shell_print(shell, "Scan successfully stopped");
    eff6:	4a17      	ldr	r2, [pc, #92]	; (f054 <cmd_scan+0xf4>)
    eff8:	e7ec      	b.n	efd4 <cmd_scan+0x74>
    } else if (!strcmp(action, "passive")) {
    effa:	4917      	ldr	r1, [pc, #92]	; (f058 <cmd_scan+0xf8>)
    effc:	4630      	mov	r0, r6
    effe:	f01b f9e4 	bl	2a3ca <strcmp>
    f002:	2800      	cmp	r0, #0
    f004:	d1bd      	bne.n	ef82 <cmd_scan+0x22>
    struct bt_le_scan_param param = {.type       = BT_HCI_LE_SCAN_PASSIVE,
    f006:	4b15      	ldr	r3, [pc, #84]	; (f05c <cmd_scan+0xfc>)
    err = bt_le_scan_start(&param, device_found);
    f008:	490d      	ldr	r1, [pc, #52]	; (f040 <cmd_scan+0xe0>)
    struct bt_le_scan_param param = {.type       = BT_HCI_LE_SCAN_PASSIVE,
    f00a:	6818      	ldr	r0, [r3, #0]
    f00c:	889b      	ldrh	r3, [r3, #4]
    f00e:	9000      	str	r0, [sp, #0]
    f010:	f8ad 3004 	strh.w	r3, [sp, #4]
    err = bt_le_scan_start(&param, device_found);
    f014:	4668      	mov	r0, sp
    if (dups >= 0) {
    f016:	1c63      	adds	r3, r4, #1
        param.filter_dup = dups;
    f018:	bf18      	it	ne
    f01a:	f88d 4001 	strbne.w	r4, [sp, #1]
    err = bt_le_scan_start(&param, device_found);
    f01e:	f008 fb3d 	bl	1769c <bt_le_scan_start>
    if (err) {
    f022:	4604      	mov	r4, r0
    f024:	b110      	cbz	r0, f02c <cmd_scan+0xcc>
        shell_error(shell,
    f026:	4603      	mov	r3, r0
    f028:	4a0d      	ldr	r2, [pc, #52]	; (f060 <cmd_scan+0x100>)
    f02a:	e7cb      	b.n	efc4 <cmd_scan+0x64>
        shell_print(shell, "Bluetooth passive scan enabled");
    f02c:	4a0d      	ldr	r2, [pc, #52]	; (f064 <cmd_scan+0x104>)
    f02e:	e7d1      	b.n	efd4 <cmd_scan+0x74>
    f030:	0002ea04 	.word	0x0002ea04
    f034:	0002ea02 	.word	0x0002ea02
    f038:	0002f893 	.word	0x0002f893
    f03c:	0002dd38 	.word	0x0002dd38
    f040:	0000ef15 	.word	0x0000ef15
    f044:	0002ea09 	.word	0x0002ea09
    f048:	0002ea34 	.word	0x0002ea34
    f04c:	0002ea53 	.word	0x0002ea53
    f050:	0002ea57 	.word	0x0002ea57
    f054:	0002ea7a 	.word	0x0002ea7a
    f058:	0002ea95 	.word	0x0002ea95
    f05c:	0002dd3e 	.word	0x0002dd3e
    f060:	0002ea9d 	.word	0x0002ea9d
    f064:	0002eac9 	.word	0x0002eac9

0000f068 <bt_ready>:
{
    f068:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if (err) {
    f06a:	4604      	mov	r4, r0
    f06c:	b128      	cbz	r0, f07a <bt_ready+0x12>
        printk("Bluetooth init failed (err %d)\n", err);
    f06e:	4601      	mov	r1, r0
    f070:	4814      	ldr	r0, [pc, #80]	; (f0c4 <bt_ready+0x5c>)
        printk("Advertising failed to start (rc %d)\n", rc);
    f072:	f019 f867 	bl	28144 <printk>
}
    f076:	b004      	add	sp, #16
    f078:	bd10      	pop	{r4, pc}
    printk("Bluetooth initialized\n");
    f07a:	4813      	ldr	r0, [pc, #76]	; (f0c8 <bt_ready+0x60>)
    f07c:	f019 f862 	bl	28144 <printk>
    default_conn = NULL;
    f080:	4b12      	ldr	r3, [pc, #72]	; (f0cc <bt_ready+0x64>)
    bt_conn_cb_register(&conn_callbacks);
    f082:	4813      	ldr	r0, [pc, #76]	; (f0d0 <bt_ready+0x68>)
    default_conn = NULL;
    f084:	601c      	str	r4, [r3, #0]
    bt_conn_cb_register(&conn_callbacks);
    f086:	f008 fd0d 	bl	17aa4 <bt_conn_cb_register>
    bt_le_adv_stop();
    f08a:	f008 fae1 	bl	17650 <bt_le_adv_stop>
    rc = bt_le_adv_start(BT_LE_ADV_CONN_NAME, ad, ARRAY_SIZE(ad), NULL, 0);
    f08e:	2309      	movs	r3, #9
    f090:	f8ad 4008 	strh.w	r4, [sp, #8]
    f094:	f88d 3009 	strb.w	r3, [sp, #9]
    f098:	23a0      	movs	r3, #160	; 0xa0
    f09a:	f8ad 300a 	strh.w	r3, [sp, #10]
    f09e:	23f0      	movs	r3, #240	; 0xf0
    f0a0:	f8ad 300c 	strh.w	r3, [sp, #12]
    f0a4:	490b      	ldr	r1, [pc, #44]	; (f0d4 <bt_ready+0x6c>)
    f0a6:	9400      	str	r4, [sp, #0]
    f0a8:	4623      	mov	r3, r4
    f0aa:	2202      	movs	r2, #2
    f0ac:	a802      	add	r0, sp, #8
    f0ae:	f01b fc23 	bl	2a8f8 <bt_le_adv_start>
    if (rc) {
    f0b2:	4601      	mov	r1, r0
    f0b4:	b108      	cbz	r0, f0ba <bt_ready+0x52>
        printk("Advertising failed to start (rc %d)\n", rc);
    f0b6:	4808      	ldr	r0, [pc, #32]	; (f0d8 <bt_ready+0x70>)
    f0b8:	e7db      	b.n	f072 <bt_ready+0xa>
    printk("Advertising successfully started\n");
    f0ba:	4808      	ldr	r0, [pc, #32]	; (f0dc <bt_ready+0x74>)
    f0bc:	f019 f842 	bl	28144 <printk>
    f0c0:	e7d9      	b.n	f076 <bt_ready+0xe>
    f0c2:	bf00      	nop
    f0c4:	0002e8eb 	.word	0x0002e8eb
    f0c8:	0002e90b 	.word	0x0002e90b
    f0cc:	20000018 	.word	0x20000018
    f0d0:	2000f808 	.word	0x2000f808
    f0d4:	0002dd8c 	.word	0x0002dd8c
    f0d8:	0002e922 	.word	0x0002e922
    f0dc:	0002e947 	.word	0x0002e947

0000f0e0 <cmd_bt>:
                               SHELL_CMD_ARG(disconnect, NULL, HELP_NONE, cmd_disconnect, 1, 0),
                               SHELL_SUBCMD_SET_END);

static int cmd_bt(const struct shell *shell, size_t argc, char **argv)
{
    if (argc == 1) {
    f0e0:	2901      	cmp	r1, #1
{
    f0e2:	b513      	push	{r0, r1, r4, lr}
    f0e4:	460c      	mov	r4, r1
    if (argc == 1) {
    f0e6:	d104      	bne.n	f0f2 <cmd_bt+0x12>
        shell_help(shell);
    f0e8:	f01a f819 	bl	2911e <shell_help>
        return SHELL_CMD_HELP_PRINTED;
    f0ec:	4620      	mov	r0, r4
    }

    shell_error(shell, "%s unknown parameter: %s", argv[0], argv[1]);

    return -EINVAL;
}
    f0ee:	b002      	add	sp, #8
    f0f0:	bd10      	pop	{r4, pc}
    shell_error(shell, "%s unknown parameter: %s", argv[0], argv[1]);
    f0f2:	6853      	ldr	r3, [r2, #4]
    f0f4:	9300      	str	r3, [sp, #0]
    f0f6:	6813      	ldr	r3, [r2, #0]
    f0f8:	4a03      	ldr	r2, [pc, #12]	; (f108 <cmd_bt+0x28>)
    f0fa:	2102      	movs	r1, #2
    f0fc:	f019 ffe2 	bl	290c4 <shell_fprintf>
    f100:	f06f 0015 	mvn.w	r0, #21
    f104:	e7f3      	b.n	f0ee <cmd_bt+0xe>
    f106:	bf00      	nop
    f108:	0002e969 	.word	0x0002e969

0000f10c <str2bt_addr_le>:
{
    f10c:	b538      	push	{r3, r4, r5, lr}
    f10e:	460c      	mov	r4, r1
    err = str2bt_addr(str, &addr->a);
    f110:	1c51      	adds	r1, r2, #1
{
    f112:	4615      	mov	r5, r2
    err = str2bt_addr(str, &addr->a);
    f114:	f018 fbe6 	bl	278e4 <str2bt_addr>
    if (err < 0) {
    f118:	2800      	cmp	r0, #0
    f11a:	db06      	blt.n	f12a <str2bt_addr_le+0x1e>
    if (!strcmp(type, "public") || !strcmp(type, "(public)")) {
    f11c:	490f      	ldr	r1, [pc, #60]	; (f15c <str2bt_addr_le+0x50>)
    f11e:	4620      	mov	r0, r4
    f120:	f01b f953 	bl	2a3ca <strcmp>
    f124:	b910      	cbnz	r0, f12c <str2bt_addr_le+0x20>
        addr->type = BT_ADDR_LE_PUBLIC;
    f126:	2000      	movs	r0, #0
    f128:	7028      	strb	r0, [r5, #0]
}
    f12a:	bd38      	pop	{r3, r4, r5, pc}
    if (!strcmp(type, "public") || !strcmp(type, "(public)")) {
    f12c:	490c      	ldr	r1, [pc, #48]	; (f160 <str2bt_addr_le+0x54>)
    f12e:	4620      	mov	r0, r4
    f130:	f01b f94b 	bl	2a3ca <strcmp>
    f134:	2800      	cmp	r0, #0
    f136:	d0f6      	beq.n	f126 <str2bt_addr_le+0x1a>
    } else if (!strcmp(type, "random") || !strcmp(type, "(random)")) {
    f138:	490a      	ldr	r1, [pc, #40]	; (f164 <str2bt_addr_le+0x58>)
    f13a:	4620      	mov	r0, r4
    f13c:	f01b f945 	bl	2a3ca <strcmp>
    f140:	b918      	cbnz	r0, f14a <str2bt_addr_le+0x3e>
        addr->type = BT_ADDR_LE_RANDOM;
    f142:	2301      	movs	r3, #1
    f144:	702b      	strb	r3, [r5, #0]
    return 0;
    f146:	2000      	movs	r0, #0
    f148:	e7ef      	b.n	f12a <str2bt_addr_le+0x1e>
    } else if (!strcmp(type, "random") || !strcmp(type, "(random)")) {
    f14a:	4907      	ldr	r1, [pc, #28]	; (f168 <str2bt_addr_le+0x5c>)
    f14c:	4620      	mov	r0, r4
    f14e:	f01b f93c 	bl	2a3ca <strcmp>
    f152:	2800      	cmp	r0, #0
    f154:	d0f5      	beq.n	f142 <str2bt_addr_le+0x36>
        return -EINVAL;
    f156:	f06f 0015 	mvn.w	r0, #21
    f15a:	e7e6      	b.n	f12a <str2bt_addr_le+0x1e>
    f15c:	0002e8a6 	.word	0x0002e8a6
    f160:	0002ec7b 	.word	0x0002ec7b
    f164:	0002e8ad 	.word	0x0002e8ad
    f168:	0002ec84 	.word	0x0002ec84

0000f16c <cmd_disconnect>:
{
    f16c:	4613      	mov	r3, r2
    if (default_conn && argc < 3) {
    f16e:	4a1d      	ldr	r2, [pc, #116]	; (f1e4 <cmd_disconnect+0x78>)
    f170:	6812      	ldr	r2, [r2, #0]
{
    f172:	b573      	push	{r0, r1, r4, r5, r6, lr}
    f174:	4606      	mov	r6, r0
    if (default_conn && argc < 3) {
    f176:	b172      	cbz	r2, f196 <cmd_disconnect+0x2a>
    f178:	2902      	cmp	r1, #2
    f17a:	d814      	bhi.n	f1a6 <cmd_disconnect+0x3a>
        conn = bt_conn_ref(default_conn);
    f17c:	4610      	mov	r0, r2
    f17e:	f01b fc3c 	bl	2a9fa <bt_conn_ref>
        conn = bt_conn_lookup_addr_le(selected_id, &addr);
    f182:	4605      	mov	r5, r0
    if (!conn) {
    f184:	bb08      	cbnz	r0, f1ca <cmd_disconnect+0x5e>
        shell_error(shell, "Not connected");
    f186:	4a18      	ldr	r2, [pc, #96]	; (f1e8 <cmd_disconnect+0x7c>)
    f188:	2102      	movs	r1, #2
    f18a:	4630      	mov	r0, r6
    f18c:	f019 ff9a 	bl	290c4 <shell_fprintf>
        return -ENOEXEC;
    f190:	f06f 0407 	mvn.w	r4, #7
    f194:	e004      	b.n	f1a0 <cmd_disconnect+0x34>
        if (argc < 3) {
    f196:	2902      	cmp	r1, #2
    f198:	d805      	bhi.n	f1a6 <cmd_disconnect+0x3a>
            shell_help(shell);
    f19a:	f019 ffc0 	bl	2911e <shell_help>
            return SHELL_CMD_HELP_PRINTED;
    f19e:	2401      	movs	r4, #1
}
    f1a0:	4620      	mov	r0, r4
    f1a2:	b002      	add	sp, #8
    f1a4:	bd70      	pop	{r4, r5, r6, pc}
        err = str2bt_addr_le(argv[1], argv[2], &addr);
    f1a6:	466a      	mov	r2, sp
    f1a8:	e9d3 0101 	ldrd	r0, r1, [r3, #4]
    f1ac:	f7ff ffae 	bl	f10c <str2bt_addr_le>
        if (err) {
    f1b0:	4604      	mov	r4, r0
    f1b2:	b130      	cbz	r0, f1c2 <cmd_disconnect+0x56>
            shell_error(shell, "Invalid peer address (err %d)", err);
    f1b4:	4a0d      	ldr	r2, [pc, #52]	; (f1ec <cmd_disconnect+0x80>)
    f1b6:	4603      	mov	r3, r0
        shell_error(shell, "Disconnection failed (err %d)", err);
    f1b8:	2102      	movs	r1, #2
    f1ba:	4630      	mov	r0, r6
    f1bc:	f019 ff82 	bl	290c4 <shell_fprintf>
        return err;
    f1c0:	e7ee      	b.n	f1a0 <cmd_disconnect+0x34>
        conn = bt_conn_lookup_addr_le(selected_id, &addr);
    f1c2:	4669      	mov	r1, sp
    f1c4:	f008 ff6a 	bl	1809c <bt_conn_lookup_addr_le>
    f1c8:	e7db      	b.n	f182 <cmd_disconnect+0x16>
    err = bt_conn_disconnect(conn, BT_HCI_ERR_REMOTE_USER_TERM_CONN);
    f1ca:	2113      	movs	r1, #19
    f1cc:	f01b fc21 	bl	2aa12 <bt_conn_disconnect>
    if (err) {
    f1d0:	4604      	mov	r4, r0
    f1d2:	b110      	cbz	r0, f1da <cmd_disconnect+0x6e>
        shell_error(shell, "Disconnection failed (err %d)", err);
    f1d4:	4603      	mov	r3, r0
    f1d6:	4a06      	ldr	r2, [pc, #24]	; (f1f0 <cmd_disconnect+0x84>)
    f1d8:	e7ee      	b.n	f1b8 <cmd_disconnect+0x4c>
    bt_conn_unref(conn);
    f1da:	4628      	mov	r0, r5
    f1dc:	f01b fc14 	bl	2aa08 <bt_conn_unref>
    return 0;
    f1e0:	e7de      	b.n	f1a0 <cmd_disconnect+0x34>
    f1e2:	bf00      	nop
    f1e4:	20000018 	.word	0x20000018
    f1e8:	0002e9c9 	.word	0x0002e9c9
    f1ec:	0002e9aa 	.word	0x0002e9aa
    f1f0:	0002e9d8 	.word	0x0002e9d8

0000f1f4 <cmd_connect_le>:
{
    f1f4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    f1f6:	4613      	mov	r3, r2
    f1f8:	4605      	mov	r5, r0
    err = str2bt_addr_le(argv[1], argv[2], &addr);
    f1fa:	466a      	mov	r2, sp
    f1fc:	e9d3 0101 	ldrd	r0, r1, [r3, #4]
    f200:	f7ff ff84 	bl	f10c <str2bt_addr_le>
    if (err) {
    f204:	4604      	mov	r4, r0
    f206:	b140      	cbz	r0, f21a <cmd_connect_le+0x26>
        shell_error(shell, "Invalid peer address (err %d)", err);
    f208:	4603      	mov	r3, r0
    f20a:	4a12      	ldr	r2, [pc, #72]	; (f254 <cmd_connect_le+0x60>)
    f20c:	2102      	movs	r1, #2
    f20e:	4628      	mov	r0, r5
    f210:	f019 ff58 	bl	290c4 <shell_fprintf>
}
    f214:	4620      	mov	r0, r4
    f216:	b004      	add	sp, #16
    f218:	bd70      	pop	{r4, r5, r6, pc}
    conn = bt_conn_create_le(&addr, BT_LE_CONN_PARAM_DEFAULT);
    f21a:	4a0f      	ldr	r2, [pc, #60]	; (f258 <cmd_connect_le+0x64>)
    f21c:	6810      	ldr	r0, [r2, #0]
    f21e:	6851      	ldr	r1, [r2, #4]
    f220:	ab02      	add	r3, sp, #8
    f222:	c303      	stmia	r3!, {r0, r1}
    f224:	a902      	add	r1, sp, #8
    f226:	4668      	mov	r0, sp
    f228:	f008 ffb8 	bl	1819c <bt_conn_create_le>
    if (!conn) {
    f22c:	4606      	mov	r6, r0
    f22e:	b938      	cbnz	r0, f240 <cmd_connect_le+0x4c>
        shell_error(shell, "Connection failed");
    f230:	4a0a      	ldr	r2, [pc, #40]	; (f25c <cmd_connect_le+0x68>)
    f232:	2102      	movs	r1, #2
    f234:	4628      	mov	r0, r5
    f236:	f019 ff45 	bl	290c4 <shell_fprintf>
    f23a:	f06f 0407 	mvn.w	r4, #7
    f23e:	e7e9      	b.n	f214 <cmd_connect_le+0x20>
        shell_print(shell, "Connection pending");
    f240:	4628      	mov	r0, r5
    f242:	4a07      	ldr	r2, [pc, #28]	; (f260 <cmd_connect_le+0x6c>)
    f244:	4621      	mov	r1, r4
    f246:	f019 ff3d 	bl	290c4 <shell_fprintf>
        bt_conn_unref(conn);
    f24a:	4630      	mov	r0, r6
    f24c:	f01b fbdc 	bl	2aa08 <bt_conn_unref>
    return 0;
    f250:	e7e0      	b.n	f214 <cmd_connect_le+0x20>
    f252:	bf00      	nop
    f254:	0002e9aa 	.word	0x0002e9aa
    f258:	0002dd44 	.word	0x0002dd44
    f25c:	0002e983 	.word	0x0002e983
    f260:	0002e996 	.word	0x0002e996

0000f264 <disconnected>:
{
    f264:	b530      	push	{r4, r5, lr}
    f266:	b089      	sub	sp, #36	; 0x24
    f268:	460c      	mov	r4, r1
    conn_addr_str(conn, addr, sizeof(addr));
    f26a:	221e      	movs	r2, #30
    f26c:	4669      	mov	r1, sp
{
    f26e:	4605      	mov	r5, r0
    conn_addr_str(conn, addr, sizeof(addr));
    f270:	f018 fb6c 	bl	2794c <conn_addr_str>
    printk("Disconnected: %s (reason %u)\n", addr, reason);
    f274:	4622      	mov	r2, r4
    f276:	4669      	mov	r1, sp
    f278:	4807      	ldr	r0, [pc, #28]	; (f298 <disconnected+0x34>)
    if (default_conn == conn) {
    f27a:	4c08      	ldr	r4, [pc, #32]	; (f29c <disconnected+0x38>)
    printk("Disconnected: %s (reason %u)\n", addr, reason);
    f27c:	f018 ff62 	bl	28144 <printk>
    dfu_disconnect(conn);
    f280:	4628      	mov	r0, r5
    f282:	f000 fded 	bl	fe60 <dfu_disconnect>
    if (default_conn == conn) {
    f286:	6820      	ldr	r0, [r4, #0]
    f288:	42a8      	cmp	r0, r5
    f28a:	d103      	bne.n	f294 <disconnected+0x30>
        bt_conn_unref(default_conn);
    f28c:	f01b fbbc 	bl	2aa08 <bt_conn_unref>
        default_conn = NULL;
    f290:	2300      	movs	r3, #0
    f292:	6023      	str	r3, [r4, #0]
}
    f294:	b009      	add	sp, #36	; 0x24
    f296:	bd30      	pop	{r4, r5, pc}
    f298:	0002eb4c 	.word	0x0002eb4c
    f29c:	20000018 	.word	0x20000018

0000f2a0 <connected>:
{
    f2a0:	b530      	push	{r4, r5, lr}
    f2a2:	b089      	sub	sp, #36	; 0x24
    f2a4:	460d      	mov	r5, r1
    conn_addr_str(conn, addr, sizeof(addr));
    f2a6:	221e      	movs	r2, #30
    f2a8:	4669      	mov	r1, sp
{
    f2aa:	4604      	mov	r4, r0
    conn_addr_str(conn, addr, sizeof(addr));
    f2ac:	f018 fb4e 	bl	2794c <conn_addr_str>
    if (err) {
    f2b0:	b125      	cbz	r5, f2bc <connected+0x1c>
        printk("Failed to connect to %s (%u)\n", addr, err);
    f2b2:	462a      	mov	r2, r5
    f2b4:	4669      	mov	r1, sp
    f2b6:	480c      	ldr	r0, [pc, #48]	; (f2e8 <connected+0x48>)
    f2b8:	f018 ff44 	bl	28144 <printk>
    if (!default_conn) {
    f2bc:	4d0b      	ldr	r5, [pc, #44]	; (f2ec <connected+0x4c>)
    printk("Connected: %s\n", addr);
    f2be:	480c      	ldr	r0, [pc, #48]	; (f2f0 <connected+0x50>)
    f2c0:	4669      	mov	r1, sp
    f2c2:	f018 ff3f 	bl	28144 <printk>
    if (!default_conn) {
    f2c6:	682b      	ldr	r3, [r5, #0]
    f2c8:	b91b      	cbnz	r3, f2d2 <connected+0x32>
        default_conn = bt_conn_ref(conn);
    f2ca:	4620      	mov	r0, r4
    f2cc:	f01b fb95 	bl	2a9fa <bt_conn_ref>
    f2d0:	6028      	str	r0, [r5, #0]
    if( err = dfu_connect(conn), err ){
    f2d2:	4620      	mov	r0, r4
    f2d4:	f000 fce8 	bl	fca8 <dfu_connect>
    f2d8:	b2c1      	uxtb	r1, r0
    f2da:	b111      	cbz	r1, f2e2 <connected+0x42>
        printk("Error (%d)\n", err);
    f2dc:	4805      	ldr	r0, [pc, #20]	; (f2f4 <connected+0x54>)
    f2de:	f018 ff31 	bl	28144 <printk>
}
    f2e2:	b009      	add	sp, #36	; 0x24
    f2e4:	bd30      	pop	{r4, r5, pc}
    f2e6:	bf00      	nop
    f2e8:	0002eae9 	.word	0x0002eae9
    f2ec:	20000018 	.word	0x20000018
    f2f0:	0002eb07 	.word	0x0002eb07
    f2f4:	0002eb16 	.word	0x0002eb16

0000f2f8 <bt_init>:
{
    f2f8:	b510      	push	{r4, lr}
    int err = bt_enable(bt_ready);
    f2fa:	4805      	ldr	r0, [pc, #20]	; (f310 <bt_init+0x18>)
    f2fc:	f007 fff4 	bl	172e8 <bt_enable>
    if (err) {
    f300:	4604      	mov	r4, r0
    f302:	b118      	cbz	r0, f30c <bt_init+0x14>
        printk("Bluetooth init failed (err %d)\n", err);
    f304:	4601      	mov	r1, r0
    f306:	4803      	ldr	r0, [pc, #12]	; (f314 <bt_init+0x1c>)
    f308:	f018 ff1c 	bl	28144 <printk>
}
    f30c:	4620      	mov	r0, r4
    f30e:	bd10      	pop	{r4, pc}
    f310:	0000f069 	.word	0x0000f069
    f314:	0002e8eb 	.word	0x0002e8eb

0000f318 <find_connection>:
int receive_channel(struct device *dev);

K_THREAD_DEFINE(receive_channel_thread, MY_STACK_SIZE, receive_channel, NULL, NULL, NULL, MY_PRIORITY, 0, K_FOREVER);
K_THREAD_DEFINE(send_channel_thread, MY_STACK_SIZE, send_channel, NULL, NULL, NULL, MY_PRIORITY, 0, K_FOREVER);

static int find_connection(struct bt_conn *conn){
    f318:	b570      	push	{r4, r5, r6, lr}
    f31a:	4d09      	ldr	r5, [pc, #36]	; (f340 <find_connection+0x28>)
    f31c:	4606      	mov	r6, r0
    for (int i = 0; i < CONFIG_BT_MAX_CONN; i++) {
    f31e:	2400      	movs	r4, #0
        if( !memcmp(conn, dfu_data.connections[i].conn, sizeof conn) ) {
    f320:	2204      	movs	r2, #4
    f322:	f8d5 124c 	ldr.w	r1, [r5, #588]	; 0x24c
    f326:	4630      	mov	r0, r6
    f328:	f01b f86a 	bl	2a400 <memcmp>
    f32c:	b130      	cbz	r0, f33c <find_connection+0x24>
    for (int i = 0; i < CONFIG_BT_MAX_CONN; i++) {
    f32e:	3401      	adds	r4, #1
    f330:	2c05      	cmp	r4, #5
    f332:	f105 051c 	add.w	r5, r5, #28
    f336:	d1f3      	bne.n	f320 <find_connection+0x8>
            return i;
        }
    }
    return -ENXIO;
    f338:	f06f 0405 	mvn.w	r4, #5
}
    f33c:	4620      	mov	r0, r4
    f33e:	bd70      	pop	{r4, r5, r6, pc}
    f340:	200000f4 	.word	0x200000f4

0000f344 <read_efu_chr_vrs>:
 * Read handler for the OTA characteristic; processes an incoming OTA request.
 */
static ssize_t read_efu_chr_vrs(struct bt_conn *conn,
			       const struct bt_gatt_attr *attr, void *buf,
			       u16_t len, u16_t offset)
{
    f344:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f348:	b086      	sub	sp, #24
    struct image_version ver;
    memcpy(&ver, &dfu_data.slots[0].version, sizeof dfu_data.slots[0].version);
    f34a:	ac04      	add	r4, sp, #16
{
    f34c:	4605      	mov	r5, r0
    f34e:	460e      	mov	r6, r1
    f350:	4617      	mov	r7, r2
    memcpy(&ver, &dfu_data.slots[0].version, sizeof dfu_data.slots[0].version);
    f352:	490a      	ldr	r1, [pc, #40]	; (f37c <read_efu_chr_vrs+0x38>)
    f354:	2208      	movs	r2, #8
    f356:	4620      	mov	r0, r4
{
    f358:	4698      	mov	r8, r3
    memcpy(&ver, &dfu_data.slots[0].version, sizeof dfu_data.slots[0].version);
    f35a:	f01b f878 	bl	2a44e <memcpy>
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &ver, sizeof(ver));
    f35e:	2308      	movs	r3, #8
    f360:	e9cd 4301 	strd	r4, r3, [sp, #4]
    f364:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
    f368:	9300      	str	r3, [sp, #0]
    f36a:	463a      	mov	r2, r7
    f36c:	4643      	mov	r3, r8
    f36e:	4631      	mov	r1, r6
    f370:	4628      	mov	r0, r5
    f372:	f01c f984 	bl	2b67e <bt_gatt_attr_read>
}
    f376:	b006      	add	sp, #24
    f378:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f37c:	200000f8 	.word	0x200000f8

0000f380 <read_efu_chr_hw_tp>:

static ssize_t read_efu_chr_hw_tp(struct bt_conn *conn,
			       const struct bt_gatt_attr *attr, void *buf,
			       u16_t len, u16_t offset)
{
    f380:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f384:	b086      	sub	sp, #24
    u8_t hardware_type;
    memcpy(&hardware_type, &dfu_data.hardware_type, sizeof dfu_data.hardware_type);
    f386:	f10d 0417 	add.w	r4, sp, #23
{
    f38a:	4605      	mov	r5, r0
    f38c:	460e      	mov	r6, r1
    f38e:	4617      	mov	r7, r2
    memcpy(&hardware_type, &dfu_data.hardware_type, sizeof dfu_data.hardware_type);
    f390:	490a      	ldr	r1, [pc, #40]	; (f3bc <read_efu_chr_hw_tp+0x3c>)
    f392:	2201      	movs	r2, #1
    f394:	4620      	mov	r0, r4
{
    f396:	4698      	mov	r8, r3
    memcpy(&hardware_type, &dfu_data.hardware_type, sizeof dfu_data.hardware_type);
    f398:	f01b f859 	bl	2a44e <memcpy>
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &hardware_type, sizeof(hardware_type));
    f39c:	2301      	movs	r3, #1
    f39e:	e9cd 4301 	strd	r4, r3, [sp, #4]
    f3a2:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
    f3a6:	9300      	str	r3, [sp, #0]
    f3a8:	463a      	mov	r2, r7
    f3aa:	4643      	mov	r3, r8
    f3ac:	4631      	mov	r1, r6
    f3ae:	4628      	mov	r0, r5
    f3b0:	f01c f965 	bl	2b67e <bt_gatt_attr_read>
}
    f3b4:	b006      	add	sp, #24
    f3b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f3ba:	bf00      	nop
    f3bc:	200000f4 	.word	0x200000f4

0000f3c0 <write_func>:
    if( err ){
        LOG_DBG("Write complete: err %u", err);
    } else {
        LOG_DBG("Write complete");
    }
    (void) memset(&dfu_data.write_params, 0, sizeof(dfu_data.write_params));
    f3c0:	2224      	movs	r2, #36	; 0x24
    f3c2:	2100      	movs	r1, #0
    f3c4:	4801      	ldr	r0, [pc, #4]	; (f3cc <write_func+0xc>)
    f3c6:	f01b b86c 	b.w	2a4a2 <memset>
    f3ca:	bf00      	nop
    f3cc:	20000458 	.word	0x20000458

0000f3d0 <exchange_func>:
{
    f3d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    f3d2:	4607      	mov	r7, r0
    f3d4:	460e      	mov	r6, r1
    int id = find_connection(conn);
    f3d6:	f7ff ff9f 	bl	f318 <find_connection>
    if( id < 0 ){
    f3da:	4d27      	ldr	r5, [pc, #156]	; (f478 <exchange_func+0xa8>)
    f3dc:	1e04      	subs	r4, r0, #0
        LOG_ERR("Not found ID");
    f3de:	682b      	ldr	r3, [r5, #0]
    if( id < 0 ){
    f3e0:	da11      	bge.n	f406 <exchange_func+0x36>
        LOG_ERR("Not found ID");
    f3e2:	075b      	lsls	r3, r3, #29
    f3e4:	d047      	beq.n	f476 <exchange_func+0xa6>
    f3e6:	2301      	movs	r3, #1
    f3e8:	f04f 0100 	mov.w	r1, #0
    f3ec:	f363 0107 	bfi	r1, r3, #0, #8
    f3f0:	4a22      	ldr	r2, [pc, #136]	; (f47c <exchange_func+0xac>)
    f3f2:	4b23      	ldr	r3, [pc, #140]	; (f480 <exchange_func+0xb0>)
    f3f4:	4823      	ldr	r0, [pc, #140]	; (f484 <exchange_func+0xb4>)
    f3f6:	1a9b      	subs	r3, r3, r2
    f3f8:	08db      	lsrs	r3, r3, #3
    f3fa:	f363 118f 	bfi	r1, r3, #6, #10
}
    f3fe:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        LOG_ERR("Not found ID");
    f402:	f019 ba9a 	b.w	2893a <log_0>
    LOG_INF("Connection %d exchanges %s", id, err == 0U ? "successful" : "failed");
    f406:	f003 0307 	and.w	r3, r3, #7
    f40a:	2b02      	cmp	r3, #2
    f40c:	d913      	bls.n	f436 <exchange_func+0x66>
    f40e:	2203      	movs	r2, #3
    f410:	f04f 0300 	mov.w	r3, #0
    f414:	f362 0307 	bfi	r3, r2, #0, #8
    f418:	4918      	ldr	r1, [pc, #96]	; (f47c <exchange_func+0xac>)
    f41a:	4a19      	ldr	r2, [pc, #100]	; (f480 <exchange_func+0xb0>)
    f41c:	481a      	ldr	r0, [pc, #104]	; (f488 <exchange_func+0xb8>)
    f41e:	1a52      	subs	r2, r2, r1
    f420:	08d2      	lsrs	r2, r2, #3
    f422:	491a      	ldr	r1, [pc, #104]	; (f48c <exchange_func+0xbc>)
    f424:	f362 138f 	bfi	r3, r2, #6, #10
    f428:	4a19      	ldr	r2, [pc, #100]	; (f490 <exchange_func+0xc0>)
    f42a:	2e00      	cmp	r6, #0
    f42c:	bf18      	it	ne
    f42e:	460a      	movne	r2, r1
    f430:	4621      	mov	r1, r4
    f432:	f019 faa3 	bl	2897c <log_2>
    if (!err) {
    f436:	b9f6      	cbnz	r6, f476 <exchange_func+0xa6>
        u16_t mtu    = bt_gatt_get_mtu(conn);
    f438:	4638      	mov	r0, r7
    f43a:	f01c f975 	bl	2b728 <bt_gatt_get_mtu>
        dfu_data.connections[id].mtu = mtu - 3;
    f43e:	4b15      	ldr	r3, [pc, #84]	; (f494 <exchange_func+0xc4>)
    f440:	221c      	movs	r2, #28
    f442:	fb02 3404 	mla	r4, r2, r4, r3
    f446:	1ec3      	subs	r3, r0, #3
    f448:	f8a4 3258 	strh.w	r3, [r4, #600]	; 0x258
        LOG_WRN("New MTU is %d", mtu);
    f44c:	682b      	ldr	r3, [r5, #0]
    f44e:	f013 0f06 	tst.w	r3, #6
        u16_t mtu    = bt_gatt_get_mtu(conn);
    f452:	4601      	mov	r1, r0
        LOG_WRN("New MTU is %d", mtu);
    f454:	d00f      	beq.n	f476 <exchange_func+0xa6>
    f456:	2302      	movs	r3, #2
    f458:	f04f 0200 	mov.w	r2, #0
    f45c:	f363 0207 	bfi	r2, r3, #0, #8
    f460:	4806      	ldr	r0, [pc, #24]	; (f47c <exchange_func+0xac>)
    f462:	4b07      	ldr	r3, [pc, #28]	; (f480 <exchange_func+0xb0>)
    f464:	1a1b      	subs	r3, r3, r0
    f466:	08db      	lsrs	r3, r3, #3
    f468:	f363 128f 	bfi	r2, r3, #6, #10
    f46c:	480a      	ldr	r0, [pc, #40]	; (f498 <exchange_func+0xc8>)
}
    f46e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        LOG_WRN("New MTU is %d", mtu);
    f472:	f019 ba6f 	b.w	28954 <log_1>
}
    f476:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    f478:	20010018 	.word	0x20010018
    f47c:	0002db28 	.word	0x0002db28
    f480:	0002dc28 	.word	0x0002dc28
    f484:	0002efb1 	.word	0x0002efb1
    f488:	0002efc9 	.word	0x0002efc9
    f48c:	0003144d 	.word	0x0003144d
    f490:	0002efbe 	.word	0x0002efbe
    f494:	200000f4 	.word	0x200000f4
    f498:	0002efe4 	.word	0x0002efe4

0000f49c <cmd_show_connections>:

    return 0;
}

static int cmd_show_connections(const struct shell *shell, size_t argc, char *argv[])
{
    f49c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    shell_print(shell, "There are %d connections", dfu_data.number_of_connections);   
    f4a0:	4c1d      	ldr	r4, [pc, #116]	; (f518 <cmd_show_connections+0x7c>)
    f4a2:	4a1e      	ldr	r2, [pc, #120]	; (f51c <cmd_show_connections+0x80>)
    f4a4:	f894 3249 	ldrb.w	r3, [r4, #585]	; 0x249
            shell_print(shell, "Channel %d: doesn't have connection", i);   
        } else {
            if ( !dfu_data.connections[i].enable_dfu_read ){
                shell_print(shell, "Channel %d: connection doesn't have DFU read", i);
            } else {
                shell_print(shell, "Channel %d: hardware type is %d and version is %d.%d.%d+%d", i, dfu_data.connections[i].hardware_type, 
    f4a8:	4f1d      	ldr	r7, [pc, #116]	; (f520 <cmd_show_connections+0x84>)
                shell_print(shell, "Channel %d: connection doesn't have DFU read", i);
    f4aa:	f8df 8078 	ldr.w	r8, [pc, #120]	; f524 <cmd_show_connections+0x88>
            shell_print(shell, "Channel %d: doesn't have connection", i);   
    f4ae:	f8df 9078 	ldr.w	r9, [pc, #120]	; f528 <cmd_show_connections+0x8c>
{
    f4b2:	b087      	sub	sp, #28
    shell_print(shell, "There are %d connections", dfu_data.number_of_connections);   
    f4b4:	2100      	movs	r1, #0
{
    f4b6:	4606      	mov	r6, r0
    shell_print(shell, "There are %d connections", dfu_data.number_of_connections);   
    f4b8:	f019 fe04 	bl	290c4 <shell_fprintf>
    for (int i = 0 ; i < MAX_CONNECTION ; ++i ){
    f4bc:	2500      	movs	r5, #0
        if( !dfu_data.connections[i].conn ){
    f4be:	f8d4 124c 	ldr.w	r1, [r4, #588]	; 0x24c
    f4c2:	b969      	cbnz	r1, f4e0 <cmd_show_connections+0x44>
            shell_print(shell, "Channel %d: doesn't have connection", i);   
    f4c4:	462b      	mov	r3, r5
    f4c6:	464a      	mov	r2, r9
                shell_print(shell, "Channel %d: connection doesn't have DFU read", i);
    f4c8:	4630      	mov	r0, r6
    f4ca:	f019 fdfb 	bl	290c4 <shell_fprintf>
    for (int i = 0 ; i < MAX_CONNECTION ; ++i ){
    f4ce:	3501      	adds	r5, #1
    f4d0:	2d05      	cmp	r5, #5
    f4d2:	f104 041c 	add.w	r4, r4, #28
    f4d6:	d1f2      	bne.n	f4be <cmd_show_connections+0x22>
                dfu_data.connections[i].version.iv_revision, dfu_data.connections[i].version.iv_build_num);
            }
        }
    }
    return 0;
}
    f4d8:	2000      	movs	r0, #0
    f4da:	b007      	add	sp, #28
    f4dc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            if ( !dfu_data.connections[i].enable_dfu_read ){
    f4e0:	f894 1256 	ldrb.w	r1, [r4, #598]	; 0x256
    f4e4:	b911      	cbnz	r1, f4ec <cmd_show_connections+0x50>
                shell_print(shell, "Channel %d: connection doesn't have DFU read", i);
    f4e6:	462b      	mov	r3, r5
    f4e8:	4642      	mov	r2, r8
    f4ea:	e7ed      	b.n	f4c8 <cmd_show_connections+0x2c>
                shell_print(shell, "Channel %d: hardware type is %d and version is %d.%d.%d+%d", i, dfu_data.connections[i].hardware_type, 
    f4ec:	f8d4 3260 	ldr.w	r3, [r4, #608]	; 0x260
    f4f0:	9304      	str	r3, [sp, #16]
    f4f2:	f8b4 325e 	ldrh.w	r3, [r4, #606]	; 0x25e
    f4f6:	9303      	str	r3, [sp, #12]
    f4f8:	f894 325d 	ldrb.w	r3, [r4, #605]	; 0x25d
    f4fc:	9302      	str	r3, [sp, #8]
    f4fe:	f894 325c 	ldrb.w	r3, [r4, #604]	; 0x25c
    f502:	9301      	str	r3, [sp, #4]
    f504:	f894 3264 	ldrb.w	r3, [r4, #612]	; 0x264
    f508:	9300      	str	r3, [sp, #0]
    f50a:	463a      	mov	r2, r7
    f50c:	462b      	mov	r3, r5
    f50e:	2100      	movs	r1, #0
    f510:	4630      	mov	r0, r6
    f512:	f019 fdd7 	bl	290c4 <shell_fprintf>
    f516:	e7da      	b.n	f4ce <cmd_show_connections+0x32>
    f518:	200000f4 	.word	0x200000f4
    f51c:	0002ec94 	.word	0x0002ec94
    f520:	0002ed01 	.word	0x0002ed01
    f524:	0002ecd3 	.word	0x0002ecd3
    f528:	0002ecae 	.word	0x0002ecae

0000f52c <cmd_dfu>:
    SHELL_CMD_ARG(show_connections, NULL, "Show all connections", cmd_show_connections, 1, 0), SHELL_SUBCMD_SET_END);


static int cmd_dfu(const struct shell *shell, size_t argc, char **argv)
{
    if (argc == 1) {
    f52c:	2901      	cmp	r1, #1
{
    f52e:	b513      	push	{r0, r1, r4, lr}
    f530:	460c      	mov	r4, r1
    if (argc == 1) {
    f532:	d104      	bne.n	f53e <cmd_dfu+0x12>
        shell_help(shell);
    f534:	f019 fdf3 	bl	2911e <shell_help>
        /* shell returns 1 when help is printed */
        return 1;
    f538:	4620      	mov	r0, r4
    }

    shell_error(shell, "%s unknown parameter: %s", argv[0], argv[1]);

    return -EINVAL;
}
    f53a:	b002      	add	sp, #8
    f53c:	bd10      	pop	{r4, pc}
    shell_error(shell, "%s unknown parameter: %s", argv[0], argv[1]);
    f53e:	6853      	ldr	r3, [r2, #4]
    f540:	9300      	str	r3, [sp, #0]
    f542:	6813      	ldr	r3, [r2, #0]
    f544:	4a03      	ldr	r2, [pc, #12]	; (f554 <cmd_dfu+0x28>)
    f546:	2102      	movs	r1, #2
    f548:	f019 fdbc 	bl	290c4 <shell_fprintf>
    f54c:	f06f 0015 	mvn.w	r0, #21
    f550:	e7f3      	b.n	f53a <cmd_dfu+0xe>
    f552:	bf00      	nop
    f554:	0002e969 	.word	0x0002e969

0000f558 <read_func>:
{
    f558:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f55c:	4615      	mov	r5, r2
    f55e:	b09c      	sub	sp, #112	; 0x70
    f560:	461f      	mov	r7, r3
    if( err ){
    f562:	460c      	mov	r4, r1
    f564:	b1b9      	cbz	r1, f596 <read_func+0x3e>
        LOG_WRN("Read complete: err 0x%02x length %u", err, length);
    f566:	4b47      	ldr	r3, [pc, #284]	; (f684 <read_func+0x12c>)
    f568:	681b      	ldr	r3, [r3, #0]
    f56a:	f013 0f06 	tst.w	r3, #6
    f56e:	d101      	bne.n	f574 <read_func+0x1c>
    f570:	2401      	movs	r4, #1
    f572:	e015      	b.n	f5a0 <read_func+0x48>
    f574:	2202      	movs	r2, #2
    f576:	f04f 0300 	mov.w	r3, #0
    f57a:	f362 0307 	bfi	r3, r2, #0, #8
    f57e:	4842      	ldr	r0, [pc, #264]	; (f688 <read_func+0x130>)
    f580:	4a42      	ldr	r2, [pc, #264]	; (f68c <read_func+0x134>)
    f582:	1a12      	subs	r2, r2, r0
    f584:	08d2      	lsrs	r2, r2, #3
    f586:	f362 138f 	bfi	r3, r2, #6, #10
    f58a:	4841      	ldr	r0, [pc, #260]	; (f690 <read_func+0x138>)
    f58c:	f8bd 2088 	ldrh.w	r2, [sp, #136]	; 0x88
    f590:	f019 f9f4 	bl	2897c <log_2>
    f594:	e7ec      	b.n	f570 <read_func+0x18>
	if (!data) {
    f596:	b93b      	cbnz	r3, f5a8 <read_func+0x50>
		(void)memset(params, 0, sizeof(*params));
    f598:	2224      	movs	r2, #36	; 0x24
    f59a:	4628      	mov	r0, r5
    f59c:	f01a ff81 	bl	2a4a2 <memset>
}
    f5a0:	4620      	mov	r0, r4
    f5a2:	b01c      	add	sp, #112	; 0x70
    f5a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    int id = find_connection(conn);
    f5a8:	f7ff feb6 	bl	f318 <find_connection>
    if( id < 0 ){
    f5ac:	1e06      	subs	r6, r0, #0
    f5ae:	dbdf      	blt.n	f570 <read_func+0x18>
    if( params->single.handle == dfu_data.connections[id].hw_type_handle ){
    f5b0:	8bab      	ldrh	r3, [r5, #28]
    f5b2:	4d38      	ldr	r5, [pc, #224]	; (f694 <read_func+0x13c>)
    f5b4:	201c      	movs	r0, #28
    f5b6:	4370      	muls	r0, r6
    f5b8:	eb05 0800 	add.w	r8, r5, r0
    f5bc:	f8b8 2250 	ldrh.w	r2, [r8, #592]	; 0x250
    f5c0:	429a      	cmp	r2, r3
    f5c2:	d11b      	bne.n	f5fc <read_func+0xa4>
        memcpy(&dfu_data.connections[id].hardware_type, p_data, sizeof dfu_data.connections[id].hardware_type);
    f5c4:	f500 7019 	add.w	r0, r0, #612	; 0x264
    f5c8:	2201      	movs	r2, #1
    f5ca:	4639      	mov	r1, r7
    f5cc:	4428      	add	r0, r5
    f5ce:	f01a ff3e 	bl	2a44e <memcpy>
        if( dfu_data.connections[id].hardware_type == dfu_data.hardware_type ){
    f5d2:	f898 2264 	ldrb.w	r2, [r8, #612]	; 0x264
    f5d6:	782b      	ldrb	r3, [r5, #0]
    f5d8:	429a      	cmp	r2, r3
    f5da:	d1c9      	bne.n	f570 <read_func+0x18>
            msgq_dfu_event q_event = {
    f5dc:	4621      	mov	r1, r4
    f5de:	226c      	movs	r2, #108	; 0x6c
    f5e0:	a801      	add	r0, sp, #4
    f5e2:	f01a ff5e 	bl	2a4a2 <memset>
    f5e6:	f8b8 3252 	ldrh.w	r3, [r8, #594]	; 0x252
            k_msgq_put(&msgq_send, &q_event, K_NO_WAIT);
    f5ea:	482b      	ldr	r0, [pc, #172]	; (f698 <read_func+0x140>)
            msgq_dfu_event q_event = {
    f5ec:	f88d 6005 	strb.w	r6, [sp, #5]
            k_msgq_put(&msgq_send, &q_event, K_NO_WAIT);
    f5f0:	a901      	add	r1, sp, #4
            msgq_dfu_event q_event = {
    f5f2:	f8ad 3006 	strh.w	r3, [sp, #6]
            k_msgq_put(&msgq_send, &q_event, K_NO_WAIT);
    f5f6:	f018 f9c5 	bl	27984 <k_msgq_put.constprop.6>
    f5fa:	e7b9      	b.n	f570 <read_func+0x18>
    } else if( params->single.handle == dfu_data.connections[id].version_handle ) {
    f5fc:	f8b8 2252 	ldrh.w	r2, [r8, #594]	; 0x252
    f600:	429a      	cmp	r2, r3
    f602:	d12b      	bne.n	f65c <read_func+0x104>
        memcpy(&dfu_data.connections[id].version, p_data, sizeof dfu_data.connections[id].version);        
    f604:	f500 7017 	add.w	r0, r0, #604	; 0x25c
    f608:	182c      	adds	r4, r5, r0
    f60a:	2208      	movs	r2, #8
    f60c:	4639      	mov	r1, r7
    f60e:	4620      	mov	r0, r4
    f610:	f01a ff1d 	bl	2a44e <memcpy>
        if( cmp_version(&dfu_data.connections[id].version, &dfu_data.slots[0].version) > 0 && dfu_data.state == DFU_IDLE_STATE ){
    f614:	1d29      	adds	r1, r5, #4
    f616:	4620      	mov	r0, r4
    f618:	f018 f9b9 	bl	2798e <cmp_version>
    f61c:	2800      	cmp	r0, #0
    f61e:	dda7      	ble.n	f570 <read_func+0x18>
    f620:	f895 4244 	ldrb.w	r4, [r5, #580]	; 0x244
    f624:	2c01      	cmp	r4, #1
    f626:	d1a3      	bne.n	f570 <read_func+0x18>
            msgq_dfu_event q_event = {
    f628:	2266      	movs	r2, #102	; 0x66
    f62a:	2100      	movs	r1, #0
    f62c:	a802      	add	r0, sp, #8
    f62e:	f01a ff38 	bl	2a4a2 <memset>
    f632:	f8b8 3254 	ldrh.w	r3, [r8, #596]	; 0x254
    f636:	f8ad 3006 	strh.w	r3, [sp, #6]
            q_event.data[ q_event.data_size ] = DFU_UPDATING_STATE;            
    f63a:	2302      	movs	r3, #2
    f63c:	f88d 300c 	strb.w	r3, [sp, #12]
            k_msgq_put(&msgq_send, &q_event, K_NO_WAIT);
    f640:	a901      	add	r1, sp, #4
            q_event.data_size++;                        
    f642:	2303      	movs	r3, #3
            k_msgq_put(&msgq_send, &q_event, K_NO_WAIT);
    f644:	4814      	ldr	r0, [pc, #80]	; (f698 <read_func+0x140>)
            msgq_dfu_event q_event = {
    f646:	f88d 4004 	strb.w	r4, [sp, #4]
    f64a:	f88d 6005 	strb.w	r6, [sp, #5]
            q_event.data[ q_event.data_size ] = STATE_CMD;
    f64e:	f88d 400b 	strb.w	r4, [sp, #11]
            q_event.data_size++;                        
    f652:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
            k_msgq_put(&msgq_send, &q_event, K_NO_WAIT);
    f656:	f018 f995 	bl	27984 <k_msgq_put.constprop.6>
    f65a:	e7a1      	b.n	f5a0 <read_func+0x48>
        LOG_WRN("Handle unknown");        
    f65c:	4b09      	ldr	r3, [pc, #36]	; (f684 <read_func+0x12c>)
    f65e:	681b      	ldr	r3, [r3, #0]
    f660:	f013 0f06 	tst.w	r3, #6
    f664:	d084      	beq.n	f570 <read_func+0x18>
    f666:	2302      	movs	r3, #2
    f668:	f04f 0100 	mov.w	r1, #0
    f66c:	f363 0107 	bfi	r1, r3, #0, #8
    f670:	4a05      	ldr	r2, [pc, #20]	; (f688 <read_func+0x130>)
    f672:	4b06      	ldr	r3, [pc, #24]	; (f68c <read_func+0x134>)
    f674:	4809      	ldr	r0, [pc, #36]	; (f69c <read_func+0x144>)
    f676:	1a9b      	subs	r3, r3, r2
    f678:	08db      	lsrs	r3, r3, #3
    f67a:	f363 118f 	bfi	r1, r3, #6, #10
    f67e:	f019 f95c 	bl	2893a <log_0>
    f682:	e775      	b.n	f570 <read_func+0x18>
    f684:	20010018 	.word	0x20010018
    f688:	0002db28 	.word	0x0002db28
    f68c:	0002dc28 	.word	0x0002dc28
    f690:	0002f1a2 	.word	0x0002f1a2
    f694:	200000f4 	.word	0x200000f4
    f698:	20010130 	.word	0x20010130
    f69c:	0002f1c6 	.word	0x0002f1c6

0000f6a0 <discover_func>:
{
    f6a0:	b570      	push	{r4, r5, r6, lr}
    f6a2:	b09c      	sub	sp, #112	; 0x70
    f6a4:	460d      	mov	r5, r1
    f6a6:	4616      	mov	r6, r2
    int id = find_connection(conn);
    f6a8:	f7ff fe36 	bl	f318 <find_connection>
    if( id < 0 ){
    f6ac:	1e04      	subs	r4, r0, #0
    f6ae:	da15      	bge.n	f6dc <discover_func+0x3c>
        LOG_ERR("Not found ID");
    f6b0:	4b64      	ldr	r3, [pc, #400]	; (f844 <discover_func+0x1a4>)
    f6b2:	6818      	ldr	r0, [r3, #0]
    f6b4:	f010 0007 	ands.w	r0, r0, #7
    f6b8:	d00e      	beq.n	f6d8 <discover_func+0x38>
    f6ba:	2301      	movs	r3, #1
    f6bc:	f04f 0100 	mov.w	r1, #0
    f6c0:	f363 0107 	bfi	r1, r3, #0, #8
    f6c4:	4a60      	ldr	r2, [pc, #384]	; (f848 <discover_func+0x1a8>)
    f6c6:	4b61      	ldr	r3, [pc, #388]	; (f84c <discover_func+0x1ac>)
    f6c8:	4861      	ldr	r0, [pc, #388]	; (f850 <discover_func+0x1b0>)
    f6ca:	1a9b      	subs	r3, r3, r2
    f6cc:	08db      	lsrs	r3, r3, #3
    f6ce:	f363 118f 	bfi	r1, r3, #6, #10
    f6d2:	f019 f932 	bl	2893a <log_0>
        return BT_GATT_ITER_STOP;
    f6d6:	2000      	movs	r0, #0
}
    f6d8:	b01c      	add	sp, #112	; 0x70
    f6da:	bd70      	pop	{r4, r5, r6, pc}
    if (!attr) {
    f6dc:	2d00      	cmp	r5, #0
    f6de:	d17b      	bne.n	f7d8 <discover_func+0x138>
        dfu_data.connections[id].enable_dfu_read = dfu_data.connections[id].version_handle && dfu_data.connections[id].hw_type_handle;
    f6e0:	4d5c      	ldr	r5, [pc, #368]	; (f854 <discover_func+0x1b4>)
    f6e2:	221c      	movs	r2, #28
    f6e4:	fb02 5204 	mla	r2, r2, r4, r5
    f6e8:	f8b2 3252 	ldrh.w	r3, [r2, #594]	; 0x252
    f6ec:	b123      	cbz	r3, f6f8 <discover_func+0x58>
    f6ee:	f8b2 3250 	ldrh.w	r3, [r2, #592]	; 0x250
    f6f2:	3300      	adds	r3, #0
    f6f4:	bf18      	it	ne
    f6f6:	2301      	movne	r3, #1
    f6f8:	221c      	movs	r2, #28
    f6fa:	fb02 5204 	mla	r2, r2, r4, r5
        dfu_data.connections[id].enable_dfu_write = dfu_data.connections[id].exchange_handle ? 1 : 0;
    f6fe:	f8b2 1254 	ldrh.w	r1, [r2, #596]	; 0x254
        dfu_data.connections[id].enable_dfu_read = dfu_data.connections[id].version_handle && dfu_data.connections[id].hw_type_handle;
    f702:	f882 3256 	strb.w	r3, [r2, #598]	; 0x256
        dfu_data.connections[id].enable_dfu_write = dfu_data.connections[id].exchange_handle ? 1 : 0;
    f706:	1c08      	adds	r0, r1, #0
    f708:	bf18      	it	ne
    f70a:	2001      	movne	r0, #1
    f70c:	f882 0257 	strb.w	r0, [r2, #599]	; 0x257
        if( dfu_data.connections[id].enable_dfu_read && dfu_data.connections[id].enable_dfu_write ){
    f710:	4a4c      	ldr	r2, [pc, #304]	; (f844 <discover_func+0x1a4>)
    f712:	6812      	ldr	r2, [r2, #0]
    f714:	f002 0206 	and.w	r2, r2, #6
    f718:	2b00      	cmp	r3, #0
    f71a:	d03e      	beq.n	f79a <discover_func+0xfa>
    f71c:	b371      	cbz	r1, f77c <discover_func+0xdc>
            LOG_WRN("Discover complete and found OTA service!");
    f71e:	b9ba      	cbnz	r2, f750 <discover_func+0xb0>
            msgq_dfu_event q_event = {
    f720:	2100      	movs	r1, #0
    f722:	226c      	movs	r2, #108	; 0x6c
    f724:	a801      	add	r0, sp, #4
    f726:	f01a febc 	bl	2a4a2 <memset>
                .handle = dfu_data.connections[id].hw_type_handle,
    f72a:	231c      	movs	r3, #28
            msgq_dfu_event q_event = {
    f72c:	f88d 4005 	strb.w	r4, [sp, #5]
                .handle = dfu_data.connections[id].hw_type_handle,
    f730:	fb03 5404 	mla	r4, r3, r4, r5
            k_msgq_put(&msgq_send, &q_event, K_NO_WAIT);
    f734:	a901      	add	r1, sp, #4
            msgq_dfu_event q_event = {
    f736:	f8b4 3250 	ldrh.w	r3, [r4, #592]	; 0x250
            k_msgq_put(&msgq_send, &q_event, K_NO_WAIT);
    f73a:	4847      	ldr	r0, [pc, #284]	; (f858 <discover_func+0x1b8>)
            msgq_dfu_event q_event = {
    f73c:	f8ad 3006 	strh.w	r3, [sp, #6]
            k_msgq_put(&msgq_send, &q_event, K_NO_WAIT);
    f740:	f018 f920 	bl	27984 <k_msgq_put.constprop.6>
        (void) memset(params, 0, sizeof(*params));
    f744:	2228      	movs	r2, #40	; 0x28
    f746:	2100      	movs	r1, #0
    f748:	4630      	mov	r0, r6
    f74a:	f01a feaa 	bl	2a4a2 <memset>
    f74e:	e7c2      	b.n	f6d6 <discover_func+0x36>
            LOG_WRN("Discover complete and found OTA service!");
    f750:	2302      	movs	r3, #2
    f752:	f04f 0100 	mov.w	r1, #0
    f756:	f363 0107 	bfi	r1, r3, #0, #8
    f75a:	4a3b      	ldr	r2, [pc, #236]	; (f848 <discover_func+0x1a8>)
    f75c:	4b3b      	ldr	r3, [pc, #236]	; (f84c <discover_func+0x1ac>)
    f75e:	483f      	ldr	r0, [pc, #252]	; (f85c <discover_func+0x1bc>)
    f760:	1a9b      	subs	r3, r3, r2
    f762:	08db      	lsrs	r3, r3, #3
    f764:	f363 118f 	bfi	r1, r3, #6, #10
            LOG_WRN("Discover complete and not found OTA service!");
    f768:	f019 f8e7 	bl	2893a <log_0>
        if( dfu_data.connections[id].enable_dfu_read ){
    f76c:	231c      	movs	r3, #28
    f76e:	fb03 5304 	mla	r3, r3, r4, r5
    f772:	f893 3256 	ldrb.w	r3, [r3, #598]	; 0x256
    f776:	2b00      	cmp	r3, #0
    f778:	d0e4      	beq.n	f744 <discover_func+0xa4>
    f77a:	e7d1      	b.n	f720 <discover_func+0x80>
            LOG_WRN("Discover complete and found OTA service, but only DFU read!");
    f77c:	2a00      	cmp	r2, #0
    f77e:	d0cf      	beq.n	f720 <discover_func+0x80>
    f780:	2302      	movs	r3, #2
    f782:	f04f 0100 	mov.w	r1, #0
    f786:	f363 0107 	bfi	r1, r3, #0, #8
    f78a:	4a2f      	ldr	r2, [pc, #188]	; (f848 <discover_func+0x1a8>)
    f78c:	4b2f      	ldr	r3, [pc, #188]	; (f84c <discover_func+0x1ac>)
    f78e:	4834      	ldr	r0, [pc, #208]	; (f860 <discover_func+0x1c0>)
    f790:	1a9b      	subs	r3, r3, r2
    f792:	08db      	lsrs	r3, r3, #3
    f794:	f363 118f 	bfi	r1, r3, #6, #10
    f798:	e7e6      	b.n	f768 <discover_func+0xc8>
        } else if ( dfu_data.connections[id].enable_dfu_write ){
    f79a:	b171      	cbz	r1, f7ba <discover_func+0x11a>
            LOG_WRN("Discover complete and found OTA service, but only DFU write!");
    f79c:	2a00      	cmp	r2, #0
    f79e:	d0d1      	beq.n	f744 <discover_func+0xa4>
    f7a0:	2302      	movs	r3, #2
    f7a2:	f04f 0100 	mov.w	r1, #0
    f7a6:	f363 0107 	bfi	r1, r3, #0, #8
    f7aa:	4a27      	ldr	r2, [pc, #156]	; (f848 <discover_func+0x1a8>)
    f7ac:	4b27      	ldr	r3, [pc, #156]	; (f84c <discover_func+0x1ac>)
    f7ae:	482d      	ldr	r0, [pc, #180]	; (f864 <discover_func+0x1c4>)
    f7b0:	1a9b      	subs	r3, r3, r2
    f7b2:	08db      	lsrs	r3, r3, #3
    f7b4:	f363 118f 	bfi	r1, r3, #6, #10
    f7b8:	e7d6      	b.n	f768 <discover_func+0xc8>
            LOG_WRN("Discover complete and not found OTA service!");
    f7ba:	2a00      	cmp	r2, #0
    f7bc:	d0c2      	beq.n	f744 <discover_func+0xa4>
    f7be:	2302      	movs	r3, #2
    f7c0:	f04f 0100 	mov.w	r1, #0
    f7c4:	f363 0107 	bfi	r1, r3, #0, #8
    f7c8:	4a1f      	ldr	r2, [pc, #124]	; (f848 <discover_func+0x1a8>)
    f7ca:	4b20      	ldr	r3, [pc, #128]	; (f84c <discover_func+0x1ac>)
    f7cc:	4826      	ldr	r0, [pc, #152]	; (f868 <discover_func+0x1c8>)
    f7ce:	1a9b      	subs	r3, r3, r2
    f7d0:	08db      	lsrs	r3, r3, #3
    f7d2:	f363 118f 	bfi	r1, r3, #6, #10
    f7d6:	e7c7      	b.n	f768 <discover_func+0xc8>
    switch (params->type) {
    f7d8:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
    f7dc:	2b03      	cmp	r3, #3
    f7de:	d001      	beq.n	f7e4 <discover_func+0x144>
    return BT_GATT_ITER_CONTINUE;
    f7e0:	2001      	movs	r0, #1
    f7e2:	e779      	b.n	f6d8 <discover_func+0x38>
        gatt_chrc = attr->user_data;
    f7e4:	68eb      	ldr	r3, [r5, #12]
    f7e6:	4e21      	ldr	r6, [pc, #132]	; (f86c <discover_func+0x1cc>)
        if (!bt_uuid_cmp(gatt_chrc->uuid, &efu_bt_chr_vrs_uuid.uuid)) {
    f7e8:	4921      	ldr	r1, [pc, #132]	; (f870 <discover_func+0x1d0>)
    f7ea:	6818      	ldr	r0, [r3, #0]
        gatt_chrc = attr->user_data;
    f7ec:	6033      	str	r3, [r6, #0]
        if (!bt_uuid_cmp(gatt_chrc->uuid, &efu_bt_chr_vrs_uuid.uuid)) {
    f7ee:	f01a ff4a 	bl	2a686 <bt_uuid_cmp>
    f7f2:	b940      	cbnz	r0, f806 <discover_func+0x166>
            dfu_data.connections[id].version_handle = attr->handle + 1;
    f7f4:	4a17      	ldr	r2, [pc, #92]	; (f854 <discover_func+0x1b4>)
    f7f6:	231c      	movs	r3, #28
    f7f8:	fb03 2404 	mla	r4, r3, r4, r2
    f7fc:	8a2b      	ldrh	r3, [r5, #16]
    f7fe:	3301      	adds	r3, #1
    f800:	f8a4 3252 	strh.w	r3, [r4, #594]	; 0x252
    f804:	e7ec      	b.n	f7e0 <discover_func+0x140>
        } else if ( !bt_uuid_cmp(gatt_chrc->uuid, &efu_bt_chr_exg_uuid.uuid) ){
    f806:	6833      	ldr	r3, [r6, #0]
    f808:	491a      	ldr	r1, [pc, #104]	; (f874 <discover_func+0x1d4>)
    f80a:	6818      	ldr	r0, [r3, #0]
    f80c:	f01a ff3b 	bl	2a686 <bt_uuid_cmp>
    f810:	b940      	cbnz	r0, f824 <discover_func+0x184>
            dfu_data.connections[id].exchange_handle = attr->handle + 1;
    f812:	4a10      	ldr	r2, [pc, #64]	; (f854 <discover_func+0x1b4>)
    f814:	231c      	movs	r3, #28
    f816:	fb03 2404 	mla	r4, r3, r4, r2
    f81a:	8a2b      	ldrh	r3, [r5, #16]
    f81c:	3301      	adds	r3, #1
    f81e:	f8a4 3254 	strh.w	r3, [r4, #596]	; 0x254
    f822:	e7dd      	b.n	f7e0 <discover_func+0x140>
        } else if ( !bt_uuid_cmp(gatt_chrc->uuid, &efu_bt_chr_hw_tp_uuid.uuid) ){
    f824:	6833      	ldr	r3, [r6, #0]
    f826:	4914      	ldr	r1, [pc, #80]	; (f878 <discover_func+0x1d8>)
    f828:	6818      	ldr	r0, [r3, #0]
    f82a:	f01a ff2c 	bl	2a686 <bt_uuid_cmp>
    f82e:	2800      	cmp	r0, #0
    f830:	d1d6      	bne.n	f7e0 <discover_func+0x140>
            dfu_data.connections[id].hw_type_handle = attr->handle + 1;
    f832:	4b08      	ldr	r3, [pc, #32]	; (f854 <discover_func+0x1b4>)
    f834:	221c      	movs	r2, #28
    f836:	fb02 3404 	mla	r4, r2, r4, r3
    f83a:	8a2b      	ldrh	r3, [r5, #16]
    f83c:	3301      	adds	r3, #1
    f83e:	f8a4 3250 	strh.w	r3, [r4, #592]	; 0x250
    f842:	e7cd      	b.n	f7e0 <discover_func+0x140>
    f844:	20010018 	.word	0x20010018
    f848:	0002db28 	.word	0x0002db28
    f84c:	0002dc28 	.word	0x0002dc28
    f850:	0002efb1 	.word	0x0002efb1
    f854:	200000f4 	.word	0x200000f4
    f858:	20010130 	.word	0x20010130
    f85c:	0002eee2 	.word	0x0002eee2
    f860:	0002ef0b 	.word	0x0002ef0b
    f864:	0002ef47 	.word	0x0002ef47
    f868:	0002ef84 	.word	0x0002ef84
    f86c:	20000544 	.word	0x20000544
    f870:	2000fea3 	.word	0x2000fea3
    f874:	2000fe81 	.word	0x2000fe81
    f878:	2000fe92 	.word	0x2000fe92

0000f87c <dfu_bt_chr_write>:
{
    f87c:	b5f0      	push	{r4, r5, r6, r7, lr}
    f87e:	b09d      	sub	sp, #116	; 0x74
    f880:	4617      	mov	r7, r2
    f882:	461d      	mov	r5, r3
    int id = find_connection(conn);
    f884:	f7ff fd48 	bl	f318 <find_connection>
    if( id < 0 ){
    f888:	1e06      	subs	r6, r0, #0
    f88a:	db1e      	blt.n	f8ca <dfu_bt_chr_write+0x4e>
    if( !dfu_data.connections[id].enable_dfu_write ){
    f88c:	4b10      	ldr	r3, [pc, #64]	; (f8d0 <dfu_bt_chr_write+0x54>)
    f88e:	241c      	movs	r4, #28
    f890:	fb04 3406 	mla	r4, r4, r6, r3
    f894:	f894 3257 	ldrb.w	r3, [r4, #599]	; 0x257
    f898:	b1bb      	cbz	r3, f8ca <dfu_bt_chr_write+0x4e>
    msgq_dfu_event q_event = {
    f89a:	2268      	movs	r2, #104	; 0x68
    f89c:	2100      	movs	r1, #0
    f89e:	a802      	add	r0, sp, #8
    f8a0:	f01a fdff 	bl	2a4a2 <memset>
    f8a4:	2301      	movs	r3, #1
    f8a6:	f88d 3004 	strb.w	r3, [sp, #4]
    memcpy(q_event.data, p, len);
    f8aa:	4639      	mov	r1, r7
    msgq_dfu_event q_event = {
    f8ac:	f8b4 3254 	ldrh.w	r3, [r4, #596]	; 0x254
    f8b0:	f88d 6005 	strb.w	r6, [sp, #5]
    memcpy(q_event.data, p, len);
    f8b4:	462a      	mov	r2, r5
    f8b6:	f10d 000a 	add.w	r0, sp, #10
    msgq_dfu_event q_event = {
    f8ba:	f8ad 3006 	strh.w	r3, [sp, #6]
    memcpy(q_event.data, p, len);
    f8be:	f01a fdc6 	bl	2a44e <memcpy>
    k_msgq_put(&msgq_receive, &q_event, K_NO_WAIT);
    f8c2:	a901      	add	r1, sp, #4
    f8c4:	4803      	ldr	r0, [pc, #12]	; (f8d4 <dfu_bt_chr_write+0x58>)
    f8c6:	f018 f85d 	bl	27984 <k_msgq_put.constprop.6>
}
    f8ca:	4628      	mov	r0, r5
    f8cc:	b01d      	add	sp, #116	; 0x74
    f8ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f8d0:	200000f4 	.word	0x200000f4
    f8d4:	20010108 	.word	0x20010108

0000f8d8 <dfu_init>:
int dfu_init(u8_t hardware_type){
    f8d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    LOG_INF("DFU init:");
    f8dc:	4d5f      	ldr	r5, [pc, #380]	; (fa5c <dfu_init+0x184>)
    f8de:	682b      	ldr	r3, [r5, #0]
    f8e0:	f003 0307 	and.w	r3, r3, #7
    f8e4:	2b02      	cmp	r3, #2
int dfu_init(u8_t hardware_type){
    f8e6:	b087      	sub	sp, #28
    f8e8:	4604      	mov	r4, r0
    LOG_INF("DFU init:");
    f8ea:	d90d      	bls.n	f908 <dfu_init+0x30>
    f8ec:	2303      	movs	r3, #3
    f8ee:	f04f 0100 	mov.w	r1, #0
    f8f2:	f363 0107 	bfi	r1, r3, #0, #8
    f8f6:	4a5a      	ldr	r2, [pc, #360]	; (fa60 <dfu_init+0x188>)
    f8f8:	4b5a      	ldr	r3, [pc, #360]	; (fa64 <dfu_init+0x18c>)
    f8fa:	485b      	ldr	r0, [pc, #364]	; (fa68 <dfu_init+0x190>)
    f8fc:	1a9b      	subs	r3, r3, r2
    f8fe:	08db      	lsrs	r3, r3, #3
    f900:	f363 118f 	bfi	r1, r3, #6, #10
    f904:	f019 f819 	bl	2893a <log_0>
    if( dfu_data.slots[0].flash_area_id || dfu_data.slots[0].flash_area_id ){
    f908:	4b58      	ldr	r3, [pc, #352]	; (fa6c <dfu_init+0x194>)
    f90a:	7c1a      	ldrb	r2, [r3, #16]
    f90c:	2a00      	cmp	r2, #0
    f90e:	f040 80a2 	bne.w	fa56 <dfu_init+0x17e>
    dfu_data.slots[0].flash_area_id = DT_FLASH_AREA_IMAGE_0_ID;
    f912:	2201      	movs	r2, #1
    dfu_data.slots[1].flash_area_id = DT_FLASH_AREA_IMAGE_1_ID;
    f914:	2102      	movs	r1, #2
    dfu_data.hardware_type = hardware_type;
    f916:	701c      	strb	r4, [r3, #0]
    dfu_data.slots[0].flash_area_id = DT_FLASH_AREA_IMAGE_0_ID;
    f918:	741a      	strb	r2, [r3, #16]
    dfu_data.slots[1].flash_area_id = DT_FLASH_AREA_IMAGE_1_ID;
    f91a:	f883 1024 	strb.w	r1, [r3, #36]	; 0x24
    dfu_data.can_reboot = 1;
    f91e:	f883 2246 	strb.w	r2, [r3, #582]	; 0x246
    LOG_INF(" + Images:");
    f922:	4c50      	ldr	r4, [pc, #320]	; (fa64 <dfu_init+0x18c>)
    f924:	4b4e      	ldr	r3, [pc, #312]	; (fa60 <dfu_init+0x188>)
    f926:	1ae4      	subs	r4, r4, r3
    f928:	682b      	ldr	r3, [r5, #0]
    f92a:	f003 0307 	and.w	r3, r3, #7
    f92e:	428b      	cmp	r3, r1
    f930:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    f934:	d909      	bls.n	f94a <dfu_init+0x72>
    f936:	f04f 0100 	mov.w	r1, #0
    f93a:	2303      	movs	r3, #3
    f93c:	f363 0107 	bfi	r1, r3, #0, #8
    f940:	f364 118f 	bfi	r1, r4, #6, #10
    f944:	484a      	ldr	r0, [pc, #296]	; (fa70 <dfu_init+0x198>)
    f946:	f018 fff8 	bl	2893a <log_0>
    f94a:	4e48      	ldr	r6, [pc, #288]	; (fa6c <dfu_init+0x194>)
int dfu_init(u8_t hardware_type){
    f94c:	f04f 0800 	mov.w	r8, #0
        read_image_info(dfu_data.slots[slot].flash_area_id, &dfu_data.slots[slot].image_size,
    f950:	46b3      	mov	fp, r6
    f952:	1d32      	adds	r2, r6, #4
    f954:	f106 010c 	add.w	r1, r6, #12
    f958:	7c30      	ldrb	r0, [r6, #16]
    f95a:	3614      	adds	r6, #20
    f95c:	f018 f82a 	bl	279b4 <read_image_info>
        if (flash_area_open(dfu_data.slots[slot].flash_area_id, &dfu_data.slots[slot].fap)) {
    f960:	4631      	mov	r1, r6
    f962:	f89b 0010 	ldrb.w	r0, [fp, #16]
    f966:	f003 fecf 	bl	13708 <flash_area_open>
    f96a:	4607      	mov	r7, r0
    f96c:	b198      	cbz	r0, f996 <dfu_init+0xbe>
            LOG_ERR(" + + Error opening slot %d area", slot);
    f96e:	682b      	ldr	r3, [r5, #0]
    f970:	075b      	lsls	r3, r3, #29
    f972:	d00a      	beq.n	f98a <dfu_init+0xb2>
    f974:	f04f 0200 	mov.w	r2, #0
    f978:	2301      	movs	r3, #1
    f97a:	f363 0207 	bfi	r2, r3, #0, #8
    f97e:	f364 128f 	bfi	r2, r4, #6, #10
    f982:	4641      	mov	r1, r8
    f984:	483b      	ldr	r0, [pc, #236]	; (fa74 <dfu_init+0x19c>)
    f986:	f018 ffe5 	bl	28954 <log_1>
            return -ENOMEM;
    f98a:	f06f 070b 	mvn.w	r7, #11
    f98e:	e03d      	b.n	fa0c <dfu_init+0x134>
    f990:	f04f 0801 	mov.w	r8, #1
    f994:	e7dc      	b.n	f950 <dfu_init+0x78>
        if (dfu_data.slots[slot].version.iv_major == (u8_t)(-1)
    f996:	f89b 1004 	ldrb.w	r1, [fp, #4]
    f99a:	682a      	ldr	r2, [r5, #0]
    f99c:	29ff      	cmp	r1, #255	; 0xff
    f99e:	d139      	bne.n	fa14 <dfu_init+0x13c>
            && dfu_data.slots[slot].version.iv_minor == (u8_t)(-1)
    f9a0:	f89b 0005 	ldrb.w	r0, [fp, #5]
    f9a4:	28ff      	cmp	r0, #255	; 0xff
    f9a6:	d135      	bne.n	fa14 <dfu_init+0x13c>
            && dfu_data.slots[slot].version.iv_revision == (u16_t)(-1)
    f9a8:	f8bb c006 	ldrh.w	ip, [fp, #6]
    f9ac:	f64f 70ff 	movw	r0, #65535	; 0xffff
    f9b0:	4584      	cmp	ip, r0
    f9b2:	d12f      	bne.n	fa14 <dfu_init+0x13c>
            && dfu_data.slots[slot].version.iv_build_num == (u32_t)(-1)) {
    f9b4:	f8db 0008 	ldr.w	r0, [fp, #8]
    f9b8:	3001      	adds	r0, #1
    f9ba:	d12b      	bne.n	fa14 <dfu_init+0x13c>
            LOG_WRN(" + + Slot %d doesn't have image", slot);
    f9bc:	f012 0f06 	tst.w	r2, #6
    f9c0:	d00c      	beq.n	f9dc <dfu_init+0x104>
    f9c2:	f029 033f 	bic.w	r3, r9, #63	; 0x3f
    f9c6:	f043 0302 	orr.w	r3, r3, #2
    f9ca:	f363 0907 	bfi	r9, r3, #0, #8
    f9ce:	f364 198f 	bfi	r9, r4, #6, #10
    f9d2:	464a      	mov	r2, r9
    f9d4:	4641      	mov	r1, r8
    f9d6:	4828      	ldr	r0, [pc, #160]	; (fa78 <dfu_init+0x1a0>)
    f9d8:	f018 ffbc 	bl	28954 <log_1>
    for (size_t slot = 0; slot < NUM_OF_SLOTS; ++slot) {
    f9dc:	f1b8 0f00 	cmp.w	r8, #0
    f9e0:	d0d6      	beq.n	f990 <dfu_init+0xb8>
    LOG_INF(" + Start threads");
    f9e2:	682b      	ldr	r3, [r5, #0]
    f9e4:	f003 0307 	and.w	r3, r3, #7
    f9e8:	2b02      	cmp	r3, #2
    f9ea:	d909      	bls.n	fa00 <dfu_init+0x128>
    f9ec:	f04f 0100 	mov.w	r1, #0
    f9f0:	2303      	movs	r3, #3
    f9f2:	f363 0107 	bfi	r1, r3, #0, #8
    f9f6:	f364 118f 	bfi	r1, r4, #6, #10
    f9fa:	4820      	ldr	r0, [pc, #128]	; (fa7c <dfu_init+0x1a4>)
    f9fc:	f018 ff9d 	bl	2893a <log_0>
	z_impl_k_thread_start(thread);
    fa00:	481f      	ldr	r0, [pc, #124]	; (fa80 <dfu_init+0x1a8>)
    fa02:	f017 fbe9 	bl	271d8 <z_impl_k_thread_start>
    fa06:	481f      	ldr	r0, [pc, #124]	; (fa84 <dfu_init+0x1ac>)
    fa08:	f017 fbe6 	bl	271d8 <z_impl_k_thread_start>
}
    fa0c:	4638      	mov	r0, r7
    fa0e:	b007      	add	sp, #28
    fa10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            LOG_INF(" + + Slot %d is running version: %d.%d.%d+%d with %d bytes", slot,
    fa14:	f002 0207 	and.w	r2, r2, #7
    fa18:	2a02      	cmp	r2, #2
    fa1a:	d9df      	bls.n	f9dc <dfu_init+0x104>
    fa1c:	f02a 023f 	bic.w	r2, sl, #63	; 0x3f
    fa20:	f042 0203 	orr.w	r2, r2, #3
    fa24:	f362 0a07 	bfi	sl, r2, #0, #8
    fa28:	f89b 2005 	ldrb.w	r2, [fp, #5]
    fa2c:	9202      	str	r2, [sp, #8]
    fa2e:	f8bb 2006 	ldrh.w	r2, [fp, #6]
    fa32:	f8db 300c 	ldr.w	r3, [fp, #12]
    fa36:	9203      	str	r2, [sp, #12]
    fa38:	f364 1a8f 	bfi	sl, r4, #6, #10
    fa3c:	f8db 2008 	ldr.w	r2, [fp, #8]
    fa40:	9204      	str	r2, [sp, #16]
    fa42:	e9cd 8100 	strd	r8, r1, [sp]
    fa46:	9305      	str	r3, [sp, #20]
    fa48:	2206      	movs	r2, #6
    fa4a:	4653      	mov	r3, sl
    fa4c:	4669      	mov	r1, sp
    fa4e:	480e      	ldr	r0, [pc, #56]	; (fa88 <dfu_init+0x1b0>)
    fa50:	f018 ffc7 	bl	289e2 <log_n>
    fa54:	e7c2      	b.n	f9dc <dfu_init+0x104>
        return -EBUSY;
    fa56:	f06f 070f 	mvn.w	r7, #15
    fa5a:	e7d7      	b.n	fa0c <dfu_init+0x134>
    fa5c:	20010018 	.word	0x20010018
    fa60:	0002db28 	.word	0x0002db28
    fa64:	0002dc28 	.word	0x0002dc28
    fa68:	0002ee09 	.word	0x0002ee09
    fa6c:	200000f4 	.word	0x200000f4
    fa70:	0002ee13 	.word	0x0002ee13
    fa74:	0002ee1e 	.word	0x0002ee1e
    fa78:	0002ee3e 	.word	0x0002ee3e
    fa7c:	0002ee99 	.word	0x0002ee99
    fa80:	2000001c 	.word	0x2000001c
    fa84:	20000088 	.word	0x20000088
    fa88:	0002ee5e 	.word	0x0002ee5e

0000fa8c <init_write>:
{
    fa8c:	b538      	push	{r3, r4, r5, lr}
    if (dfu_data.state != DFU_IDLE_STATE) {
    fa8e:	4c31      	ldr	r4, [pc, #196]	; (fb54 <init_write+0xc8>)
    fa90:	f894 3244 	ldrb.w	r3, [r4, #580]	; 0x244
    fa94:	2b01      	cmp	r3, #1
    fa96:	d159      	bne.n	fb4c <init_write+0xc0>
    if (flash_img_init(&dfu_data.ctx)) {
    fa98:	f104 002c 	add.w	r0, r4, #44	; 0x2c
    fa9c:	f01a fa68 	bl	29f70 <flash_img_init>
    faa0:	4601      	mov	r1, r0
    faa2:	b1c8      	cbz	r0, fad8 <init_write+0x4c>
        LOG_ERR("Init flash image");
    faa4:	4b2c      	ldr	r3, [pc, #176]	; (fb58 <init_write+0xcc>)
    faa6:	681b      	ldr	r3, [r3, #0]
    faa8:	0759      	lsls	r1, r3, #29
    faaa:	d00d      	beq.n	fac8 <init_write+0x3c>
    faac:	2301      	movs	r3, #1
    faae:	f04f 0100 	mov.w	r1, #0
    fab2:	f363 0107 	bfi	r1, r3, #0, #8
    fab6:	4a29      	ldr	r2, [pc, #164]	; (fb5c <init_write+0xd0>)
    fab8:	4b29      	ldr	r3, [pc, #164]	; (fb60 <init_write+0xd4>)
    faba:	482a      	ldr	r0, [pc, #168]	; (fb64 <init_write+0xd8>)
    fabc:	1a9b      	subs	r3, r3, r2
    fabe:	08db      	lsrs	r3, r3, #3
    fac0:	f363 118f 	bfi	r1, r3, #6, #10
    fac4:	f018 ff39 	bl	2893a <log_0>
        dfu_data.state  = DFU_ERROR_STATE;
    fac8:	f240 3305 	movw	r3, #773	; 0x305
        dfu_data.state  = DFU_ERROR_STATE;
    facc:	f8a4 3244 	strh.w	r3, [r4, #580]	; 0x244
        return -EACCES;
    fad0:	f06f 050c 	mvn.w	r5, #12
};
    fad4:	4628      	mov	r0, r5
    fad6:	bd38      	pop	{r3, r4, r5, pc}
    if (flash_area_erase(dfu_data.ctx.flash_area, 0, dfu_data.ctx.flash_area->fa_size)) {
    fad8:	f8d4 022c 	ldr.w	r0, [r4, #556]	; 0x22c
    fadc:	6882      	ldr	r2, [r0, #8]
    fade:	f01a fa9f 	bl	2a020 <flash_area_erase>
    fae2:	4605      	mov	r5, r0
    fae4:	b1a0      	cbz	r0, fb10 <init_write+0x84>
        LOG_ERR("Erase flash");
    fae6:	4b1c      	ldr	r3, [pc, #112]	; (fb58 <init_write+0xcc>)
    fae8:	681b      	ldr	r3, [r3, #0]
    faea:	075a      	lsls	r2, r3, #29
    faec:	d00d      	beq.n	fb0a <init_write+0x7e>
    faee:	2301      	movs	r3, #1
    faf0:	f04f 0100 	mov.w	r1, #0
    faf4:	f363 0107 	bfi	r1, r3, #0, #8
    faf8:	4a18      	ldr	r2, [pc, #96]	; (fb5c <init_write+0xd0>)
    fafa:	4b19      	ldr	r3, [pc, #100]	; (fb60 <init_write+0xd4>)
    fafc:	481a      	ldr	r0, [pc, #104]	; (fb68 <init_write+0xdc>)
    fafe:	1a9b      	subs	r3, r3, r2
    fb00:	08db      	lsrs	r3, r3, #3
    fb02:	f363 118f 	bfi	r1, r3, #6, #10
    fb06:	f018 ff18 	bl	2893a <log_0>
        dfu_data.state  = DFU_ERROR_STATE;
    fb0a:	f240 4305 	movw	r3, #1029	; 0x405
    fb0e:	e7dd      	b.n	facc <init_write+0x40>
    if (flash_img_bytes_written(&dfu_data.ctx)) {
    fb10:	f104 002c 	add.w	r0, r4, #44	; 0x2c
    fb14:	f01a fa29 	bl	29f6a <flash_img_bytes_written>
    fb18:	2800      	cmp	r0, #0
    fb1a:	d0db      	beq.n	fad4 <init_write+0x48>
        LOG_ERR("Buff in memory");
    fb1c:	4b0e      	ldr	r3, [pc, #56]	; (fb58 <init_write+0xcc>)
    fb1e:	681b      	ldr	r3, [r3, #0]
    fb20:	075b      	lsls	r3, r3, #29
    fb22:	d00d      	beq.n	fb40 <init_write+0xb4>
    fb24:	2301      	movs	r3, #1
    fb26:	f04f 0100 	mov.w	r1, #0
    fb2a:	f363 0107 	bfi	r1, r3, #0, #8
    fb2e:	4a0b      	ldr	r2, [pc, #44]	; (fb5c <init_write+0xd0>)
    fb30:	4b0b      	ldr	r3, [pc, #44]	; (fb60 <init_write+0xd4>)
    fb32:	480e      	ldr	r0, [pc, #56]	; (fb6c <init_write+0xe0>)
    fb34:	1a9b      	subs	r3, r3, r2
    fb36:	08db      	lsrs	r3, r3, #3
    fb38:	f363 118f 	bfi	r1, r3, #6, #10
    fb3c:	f018 fefd 	bl	2893a <log_0>
        dfu_data.state = DFU_ERROR_STATE;
    fb40:	2305      	movs	r3, #5
    fb42:	f884 3244 	strb.w	r3, [r4, #580]	; 0x244
        return -EEXIST;
    fb46:	f06f 0510 	mvn.w	r5, #16
    fb4a:	e7c3      	b.n	fad4 <init_write+0x48>
        return -EINVAL;
    fb4c:	f06f 0515 	mvn.w	r5, #21
    fb50:	e7c0      	b.n	fad4 <init_write+0x48>
    fb52:	bf00      	nop
    fb54:	200000f4 	.word	0x200000f4
    fb58:	20010018 	.word	0x20010018
    fb5c:	0002db28 	.word	0x0002db28
    fb60:	0002dc28 	.word	0x0002dc28
    fb64:	0002eff2 	.word	0x0002eff2
    fb68:	0002f003 	.word	0x0002f003
    fb6c:	0002f00f 	.word	0x0002f00f

0000fb70 <dfu_bt_register>:
{
    fb70:	b508      	push	{r3, lr}
    LOG_INF("DFU Service register!");
    fb72:	4b0c      	ldr	r3, [pc, #48]	; (fba4 <dfu_bt_register+0x34>)
    fb74:	681b      	ldr	r3, [r3, #0]
    fb76:	f003 0307 	and.w	r3, r3, #7
    fb7a:	2b02      	cmp	r3, #2
    fb7c:	d90d      	bls.n	fb9a <dfu_bt_register+0x2a>
    fb7e:	2303      	movs	r3, #3
    fb80:	f04f 0100 	mov.w	r1, #0
    fb84:	f363 0107 	bfi	r1, r3, #0, #8
    fb88:	4a07      	ldr	r2, [pc, #28]	; (fba8 <dfu_bt_register+0x38>)
    fb8a:	4b08      	ldr	r3, [pc, #32]	; (fbac <dfu_bt_register+0x3c>)
    fb8c:	4808      	ldr	r0, [pc, #32]	; (fbb0 <dfu_bt_register+0x40>)
    fb8e:	1a9b      	subs	r3, r3, r2
    fb90:	08db      	lsrs	r3, r3, #3
    fb92:	f363 118f 	bfi	r1, r3, #6, #10
    fb96:	f018 fed0 	bl	2893a <log_0>
    return bt_gatt_service_register(&efu_bt_svc);
    fb9a:	4806      	ldr	r0, [pc, #24]	; (fbb4 <dfu_bt_register+0x44>)
}
    fb9c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return bt_gatt_service_register(&efu_bt_svc);
    fba0:	f00a bc6a 	b.w	1a478 <bt_gatt_service_register>
    fba4:	20010018 	.word	0x20010018
    fba8:	0002db28 	.word	0x0002db28
    fbac:	0002dc28 	.word	0x0002dc28
    fbb0:	0002ed3d 	.word	0x0002ed3d
    fbb4:	2000f8c0 	.word	0x2000f8c0

0000fbb8 <dfu_bt_unregister>:
{
    fbb8:	b508      	push	{r3, lr}
    LOG_INF("DFU Service unregister!");
    fbba:	4b0c      	ldr	r3, [pc, #48]	; (fbec <dfu_bt_unregister+0x34>)
    fbbc:	681b      	ldr	r3, [r3, #0]
    fbbe:	f003 0307 	and.w	r3, r3, #7
    fbc2:	2b02      	cmp	r3, #2
    fbc4:	d90d      	bls.n	fbe2 <dfu_bt_unregister+0x2a>
    fbc6:	2303      	movs	r3, #3
    fbc8:	f04f 0100 	mov.w	r1, #0
    fbcc:	f363 0107 	bfi	r1, r3, #0, #8
    fbd0:	4a07      	ldr	r2, [pc, #28]	; (fbf0 <dfu_bt_unregister+0x38>)
    fbd2:	4b08      	ldr	r3, [pc, #32]	; (fbf4 <dfu_bt_unregister+0x3c>)
    fbd4:	4808      	ldr	r0, [pc, #32]	; (fbf8 <dfu_bt_unregister+0x40>)
    fbd6:	1a9b      	subs	r3, r3, r2
    fbd8:	08db      	lsrs	r3, r3, #3
    fbda:	f363 118f 	bfi	r1, r3, #6, #10
    fbde:	f018 feac 	bl	2893a <log_0>
    return bt_gatt_service_unregister(&efu_bt_svc);
    fbe2:	4806      	ldr	r0, [pc, #24]	; (fbfc <dfu_bt_unregister+0x44>)
}
    fbe4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return bt_gatt_service_unregister(&efu_bt_svc);
    fbe8:	f00a bb0c 	b.w	1a204 <bt_gatt_service_unregister>
    fbec:	20010018 	.word	0x20010018
    fbf0:	0002db28 	.word	0x0002db28
    fbf4:	0002dc28 	.word	0x0002dc28
    fbf8:	0002ed53 	.word	0x0002ed53
    fbfc:	2000f8c0 	.word	0x2000f8c0

0000fc00 <dfu_mode>:
    if (enable != 0 && enable != 1 && enable != 2 ) {
    fc00:	2802      	cmp	r0, #2
{
    fc02:	b508      	push	{r3, lr}
    if (enable != 0 && enable != 1 && enable != 2 ) {
    fc04:	d914      	bls.n	fc30 <dfu_mode+0x30>
        LOG_ERR(" + Start threads");
    fc06:	4b18      	ldr	r3, [pc, #96]	; (fc68 <dfu_mode+0x68>)
    fc08:	681b      	ldr	r3, [r3, #0]
    fc0a:	075b      	lsls	r3, r3, #29
    fc0c:	d00d      	beq.n	fc2a <dfu_mode+0x2a>
    fc0e:	2301      	movs	r3, #1
    fc10:	f04f 0100 	mov.w	r1, #0
    fc14:	f363 0107 	bfi	r1, r3, #0, #8
    fc18:	4a14      	ldr	r2, [pc, #80]	; (fc6c <dfu_mode+0x6c>)
    fc1a:	4b15      	ldr	r3, [pc, #84]	; (fc70 <dfu_mode+0x70>)
    fc1c:	4815      	ldr	r0, [pc, #84]	; (fc74 <dfu_mode+0x74>)
    fc1e:	1a9b      	subs	r3, r3, r2
    fc20:	08db      	lsrs	r3, r3, #3
    fc22:	f363 118f 	bfi	r1, r3, #6, #10
    fc26:	f018 fe88 	bl	2893a <log_0>
    fc2a:	f06f 0022 	mvn.w	r0, #34	; 0x22
}
    fc2e:	bd08      	pop	{r3, pc}
    } else if (dfu_data.state == cast(enum dfu_state, enable)) {
    fc30:	4b11      	ldr	r3, [pc, #68]	; (fc78 <dfu_mode+0x78>)
    fc32:	f893 2244 	ldrb.w	r2, [r3, #580]	; 0x244
    fc36:	4282      	cmp	r2, r0
    fc38:	d012      	beq.n	fc60 <dfu_mode+0x60>
    dfu_data.state     = enable ? DFU_IDLE_STATE : APP_STATE;
    fc3a:	2800      	cmp	r0, #0
    fc3c:	bf14      	ite	ne
    fc3e:	2201      	movne	r2, #1
    fc40:	2200      	moveq	r2, #0
    dfu_data.immediate = enable & 1;
    fc42:	f000 0001 	and.w	r0, r0, #1
    dfu_data.state     = enable ? DFU_IDLE_STATE : APP_STATE;
    fc46:	f883 2244 	strb.w	r2, [r3, #580]	; 0x244
    dfu_data.immediate = enable & 1;
    fc4a:	f883 0247 	strb.w	r0, [r3, #583]	; 0x247
    if (dfu_data.state == DFU_IDLE_STATE) {
    fc4e:	d003      	beq.n	fc58 <dfu_mode+0x58>
}
    fc50:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        return dfu_bt_register();
    fc54:	f7ff bf8c 	b.w	fb70 <dfu_bt_register>
}
    fc58:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return dfu_bt_unregister();
    fc5c:	f7ff bfac 	b.w	fbb8 <dfu_bt_unregister>
        return -EINVAL;
    fc60:	f06f 0015 	mvn.w	r0, #21
    fc64:	e7e3      	b.n	fc2e <dfu_mode+0x2e>
    fc66:	bf00      	nop
    fc68:	20010018 	.word	0x20010018
    fc6c:	0002db28 	.word	0x0002db28
    fc70:	0002dc28 	.word	0x0002dc28
    fc74:	0002ee99 	.word	0x0002ee99
    fc78:	200000f4 	.word	0x200000f4

0000fc7c <cmd_mode>:
{
    fc7c:	4613      	mov	r3, r2
    fc7e:	b510      	push	{r4, lr}
    u8_t in = strtoul(argv[1], NULL, 10);
    fc80:	220a      	movs	r2, #10
{
    fc82:	4604      	mov	r4, r0
    u8_t in = strtoul(argv[1], NULL, 10);
    fc84:	2100      	movs	r1, #0
    fc86:	6858      	ldr	r0, [r3, #4]
    fc88:	f01a fad7 	bl	2a23a <strtoul>
    if (dfu_mode(in)) {
    fc8c:	b2c0      	uxtb	r0, r0
    fc8e:	f7ff ffb7 	bl	fc00 <dfu_mode>
    fc92:	b120      	cbz	r0, fc9e <cmd_mode+0x22>
        shell_error(shell, "Error");
    fc94:	4a03      	ldr	r2, [pc, #12]	; (fca4 <cmd_mode+0x28>)
    fc96:	2102      	movs	r1, #2
    fc98:	4620      	mov	r0, r4
    fc9a:	f019 fa13 	bl	290c4 <shell_fprintf>
}
    fc9e:	2000      	movs	r0, #0
    fca0:	bd10      	pop	{r4, pc}
    fca2:	bf00      	nop
    fca4:	0002ec8d 	.word	0x0002ec8d

0000fca8 <dfu_connect>:
{
    fca8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    LOG_INF("Connect DFU");
    fcaa:	4e5f      	ldr	r6, [pc, #380]	; (fe28 <dfu_connect+0x180>)
    fcac:	6833      	ldr	r3, [r6, #0]
    fcae:	f003 0307 	and.w	r3, r3, #7
    fcb2:	2b02      	cmp	r3, #2
{
    fcb4:	4607      	mov	r7, r0
    LOG_INF("Connect DFU");
    fcb6:	d90d      	bls.n	fcd4 <dfu_connect+0x2c>
    fcb8:	2303      	movs	r3, #3
    fcba:	f04f 0100 	mov.w	r1, #0
    fcbe:	f363 0107 	bfi	r1, r3, #0, #8
    fcc2:	4a5a      	ldr	r2, [pc, #360]	; (fe2c <dfu_connect+0x184>)
    fcc4:	4b5a      	ldr	r3, [pc, #360]	; (fe30 <dfu_connect+0x188>)
    fcc6:	485b      	ldr	r0, [pc, #364]	; (fe34 <dfu_connect+0x18c>)
    fcc8:	1a9b      	subs	r3, r3, r2
    fcca:	08db      	lsrs	r3, r3, #3
    fccc:	f363 118f 	bfi	r1, r3, #6, #10
    fcd0:	f018 fe33 	bl	2893a <log_0>
    if( !conn ){
    fcd4:	2f00      	cmp	r7, #0
    fcd6:	d047      	beq.n	fd68 <dfu_connect+0xc0>
    } else if( dfu_data.number_of_connections >= MAX_CONNECTION ){
    fcd8:	4d57      	ldr	r5, [pc, #348]	; (fe38 <dfu_connect+0x190>)
    fcda:	f895 3249 	ldrb.w	r3, [r5, #585]	; 0x249
    fcde:	2b04      	cmp	r3, #4
    fce0:	d857      	bhi.n	fd92 <dfu_connect+0xea>
    int id = find_connection(conn);
    fce2:	4638      	mov	r0, r7
    fce4:	f7ff fb18 	bl	f318 <find_connection>
    if( id == -ENXIO ){
    fce8:	3006      	adds	r0, #6
    fcea:	d125      	bne.n	fd38 <dfu_connect+0x90>
        id = find_connection(NULL);
    fcec:	2000      	movs	r0, #0
    fcee:	f7ff fb13 	bl	f318 <find_connection>
        LOG_WRN("New connection is with ID: %d", id);
    fcf2:	6833      	ldr	r3, [r6, #0]
    fcf4:	f013 0f06 	tst.w	r3, #6
        id = find_connection(NULL);
    fcf8:	4604      	mov	r4, r0
        LOG_WRN("New connection is with ID: %d", id);
    fcfa:	d00e      	beq.n	fd1a <dfu_connect+0x72>
    fcfc:	2302      	movs	r3, #2
    fcfe:	f04f 0200 	mov.w	r2, #0
    fd02:	f363 0207 	bfi	r2, r3, #0, #8
    fd06:	4949      	ldr	r1, [pc, #292]	; (fe2c <dfu_connect+0x184>)
    fd08:	4b49      	ldr	r3, [pc, #292]	; (fe30 <dfu_connect+0x188>)
    fd0a:	1a5b      	subs	r3, r3, r1
    fd0c:	08db      	lsrs	r3, r3, #3
    fd0e:	4601      	mov	r1, r0
    fd10:	f363 128f 	bfi	r2, r3, #6, #10
    fd14:	4849      	ldr	r0, [pc, #292]	; (fe3c <dfu_connect+0x194>)
    fd16:	f018 fe1d 	bl	28954 <log_1>
        if( id >= 0 ){
    fd1a:	2c00      	cmp	r4, #0
    fd1c:	db3c      	blt.n	fd98 <dfu_connect+0xf0>
            dfu_data.connections[id].conn = conn;
    fd1e:	231c      	movs	r3, #28
    fd20:	fb03 5404 	mla	r4, r3, r4, r5
            dfu_data.connections[id].mtu = 23;
    fd24:	2317      	movs	r3, #23
    fd26:	f8a4 3258 	strh.w	r3, [r4, #600]	; 0x258
            dfu_data.number_of_connections++;
    fd2a:	f895 3249 	ldrb.w	r3, [r5, #585]	; 0x249
            dfu_data.connections[id].conn = conn;
    fd2e:	f8c4 724c 	str.w	r7, [r4, #588]	; 0x24c
            dfu_data.number_of_connections++;
    fd32:	3301      	adds	r3, #1
    fd34:	f885 3249 	strb.w	r3, [r5, #585]	; 0x249
    id = find_connection(conn);
    fd38:	4638      	mov	r0, r7
    fd3a:	f7ff faed 	bl	f318 <find_connection>
    if( id < 0 ){
    fd3e:	1e04      	subs	r4, r0, #0
    fd40:	da2d      	bge.n	fd9e <dfu_connect+0xf6>
        LOG_ERR("Not found connection");
    fd42:	6833      	ldr	r3, [r6, #0]
    fd44:	0759      	lsls	r1, r3, #29
    fd46:	d00d      	beq.n	fd64 <dfu_connect+0xbc>
    fd48:	2301      	movs	r3, #1
    fd4a:	f04f 0100 	mov.w	r1, #0
    fd4e:	f363 0107 	bfi	r1, r3, #0, #8
    fd52:	4a36      	ldr	r2, [pc, #216]	; (fe2c <dfu_connect+0x184>)
    fd54:	4b36      	ldr	r3, [pc, #216]	; (fe30 <dfu_connect+0x188>)
    fd56:	483a      	ldr	r0, [pc, #232]	; (fe40 <dfu_connect+0x198>)
    fd58:	1a9b      	subs	r3, r3, r2
    fd5a:	08db      	lsrs	r3, r3, #3
    fd5c:	f363 118f 	bfi	r1, r3, #6, #10
    fd60:	f018 fdeb 	bl	2893a <log_0>
}
    fd64:	4620      	mov	r0, r4
    fd66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return -EFAULT;
    fd68:	f06f 040d 	mvn.w	r4, #13
        LOG_ERR("Aditional connection (err %d)", err);
    fd6c:	6833      	ldr	r3, [r6, #0]
    fd6e:	0758      	lsls	r0, r3, #29
    fd70:	d0f8      	beq.n	fd64 <dfu_connect+0xbc>
    fd72:	2301      	movs	r3, #1
    fd74:	f04f 0200 	mov.w	r2, #0
    fd78:	f363 0207 	bfi	r2, r3, #0, #8
    fd7c:	492b      	ldr	r1, [pc, #172]	; (fe2c <dfu_connect+0x184>)
    fd7e:	4b2c      	ldr	r3, [pc, #176]	; (fe30 <dfu_connect+0x188>)
    fd80:	4830      	ldr	r0, [pc, #192]	; (fe44 <dfu_connect+0x19c>)
    fd82:	1a5b      	subs	r3, r3, r1
    fd84:	08db      	lsrs	r3, r3, #3
    fd86:	f363 128f 	bfi	r2, r3, #6, #10
    fd8a:	4621      	mov	r1, r4
        LOG_ERR("Discover failed (err %d)", err);
    fd8c:	f018 fde2 	bl	28954 <log_1>
    return err;
    fd90:	e7e8      	b.n	fd64 <dfu_connect+0xbc>
        return -EBUSY;
    fd92:	f06f 040f 	mvn.w	r4, #15
    fd96:	e7e9      	b.n	fd6c <dfu_connect+0xc4>
            return -1;
    fd98:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    fd9c:	e7e6      	b.n	fd6c <dfu_connect+0xc4>
    struct bt_conn * conn_id = dfu_data.connections[id].conn;
    fd9e:	231c      	movs	r3, #28
    fda0:	fb03 5404 	mla	r4, r3, r4, r5
    if (err = bt_gatt_exchange_mtu(conn_id, &dfu_data.exchange_params), err) {
    fda4:	4928      	ldr	r1, [pc, #160]	; (fe48 <dfu_connect+0x1a0>)
    struct bt_conn * conn_id = dfu_data.connections[id].conn;
    fda6:	f8d4 724c 	ldr.w	r7, [r4, #588]	; 0x24c
    dfu_data.exchange_params.func = exchange_func;
    fdaa:	4b28      	ldr	r3, [pc, #160]	; (fe4c <dfu_connect+0x1a4>)
    fdac:	f8c5 33c4 	str.w	r3, [r5, #964]	; 0x3c4
    if (err = bt_gatt_exchange_mtu(conn_id, &dfu_data.exchange_params), err) {
    fdb0:	4638      	mov	r0, r7
    fdb2:	f00a fd5d 	bl	1a870 <bt_gatt_exchange_mtu>
    fdb6:	4604      	mov	r4, r0
    fdb8:	b180      	cbz	r0, fddc <dfu_connect+0x134>
        LOG_ERR("Exchange failed (err %d)", err);
    fdba:	6833      	ldr	r3, [r6, #0]
    fdbc:	075a      	lsls	r2, r3, #29
    fdbe:	d0d1      	beq.n	fd64 <dfu_connect+0xbc>
    fdc0:	2301      	movs	r3, #1
    fdc2:	f04f 0200 	mov.w	r2, #0
    fdc6:	f363 0207 	bfi	r2, r3, #0, #8
    fdca:	4918      	ldr	r1, [pc, #96]	; (fe2c <dfu_connect+0x184>)
    fdcc:	4b18      	ldr	r3, [pc, #96]	; (fe30 <dfu_connect+0x188>)
    fdce:	1a5b      	subs	r3, r3, r1
    fdd0:	08db      	lsrs	r3, r3, #3
    fdd2:	4601      	mov	r1, r0
    fdd4:	f363 128f 	bfi	r2, r3, #6, #10
    fdd8:	481d      	ldr	r0, [pc, #116]	; (fe50 <dfu_connect+0x1a8>)
    fdda:	e7d7      	b.n	fd8c <dfu_connect+0xe4>
    dfu_data.discover_params.func         = discover_func;
    fddc:	4b1d      	ldr	r3, [pc, #116]	; (fe54 <dfu_connect+0x1ac>)
    fdde:	f8c5 33a0 	str.w	r3, [r5, #928]	; 0x3a0
    dfu_data.discover_params.start_handle = 0x0001;
    fde2:	2301      	movs	r3, #1
    fde4:	f8a5 33a4 	strh.w	r3, [r5, #932]	; 0x3a4
    dfu_data.discover_params.end_handle   = 0xffff;
    fde8:	f64f 73ff 	movw	r3, #65535	; 0xffff
    fdec:	f8a5 33aa 	strh.w	r3, [r5, #938]	; 0x3aa
    if (err = bt_gatt_discover(conn_id, &dfu_data.discover_params), err) {
    fdf0:	4919      	ldr	r1, [pc, #100]	; (fe58 <dfu_connect+0x1b0>)
    dfu_data.discover_params.type         = BT_GATT_DISCOVER_CHARACTERISTIC;
    fdf2:	2303      	movs	r3, #3
    if (err = bt_gatt_discover(conn_id, &dfu_data.discover_params), err) {
    fdf4:	4638      	mov	r0, r7
    dfu_data.discover_params.type         = BT_GATT_DISCOVER_CHARACTERISTIC;
    fdf6:	f885 33ac 	strb.w	r3, [r5, #940]	; 0x3ac
    if (err = bt_gatt_discover(conn_id, &dfu_data.discover_params), err) {
    fdfa:	f00a fd5f 	bl	1a8bc <bt_gatt_discover>
    fdfe:	4604      	mov	r4, r0
    fe00:	2800      	cmp	r0, #0
    fe02:	d0af      	beq.n	fd64 <dfu_connect+0xbc>
        LOG_ERR("Discover failed (err %d)", err);
    fe04:	6833      	ldr	r3, [r6, #0]
    fe06:	075b      	lsls	r3, r3, #29
    fe08:	d0ac      	beq.n	fd64 <dfu_connect+0xbc>
    fe0a:	2301      	movs	r3, #1
    fe0c:	f04f 0200 	mov.w	r2, #0
    fe10:	f363 0207 	bfi	r2, r3, #0, #8
    fe14:	4905      	ldr	r1, [pc, #20]	; (fe2c <dfu_connect+0x184>)
    fe16:	4b06      	ldr	r3, [pc, #24]	; (fe30 <dfu_connect+0x188>)
    fe18:	1a5b      	subs	r3, r3, r1
    fe1a:	08db      	lsrs	r3, r3, #3
    fe1c:	4601      	mov	r1, r0
    fe1e:	f363 128f 	bfi	r2, r3, #6, #10
    fe22:	480e      	ldr	r0, [pc, #56]	; (fe5c <dfu_connect+0x1b4>)
    fe24:	e7b2      	b.n	fd8c <dfu_connect+0xe4>
    fe26:	bf00      	nop
    fe28:	20010018 	.word	0x20010018
    fe2c:	0002db28 	.word	0x0002db28
    fe30:	0002dc28 	.word	0x0002dc28
    fe34:	0002ed6b 	.word	0x0002ed6b
    fe38:	200000f4 	.word	0x200000f4
    fe3c:	0002ed77 	.word	0x0002ed77
    fe40:	0002edb3 	.word	0x0002edb3
    fe44:	0002ed95 	.word	0x0002ed95
    fe48:	200004a4 	.word	0x200004a4
    fe4c:	0000f3d1 	.word	0x0000f3d1
    fe50:	0002edc8 	.word	0x0002edc8
    fe54:	0000f6a1 	.word	0x0000f6a1
    fe58:	2000047c 	.word	0x2000047c
    fe5c:	0002ede1 	.word	0x0002ede1

0000fe60 <dfu_disconnect>:
    LOG_INF("Disconnect DFU");
    fe60:	4b1a      	ldr	r3, [pc, #104]	; (fecc <dfu_disconnect+0x6c>)
    fe62:	681b      	ldr	r3, [r3, #0]
    fe64:	f003 0307 	and.w	r3, r3, #7
    fe68:	2b02      	cmp	r3, #2
{
    fe6a:	b510      	push	{r4, lr}
    fe6c:	4604      	mov	r4, r0
    LOG_INF("Disconnect DFU");
    fe6e:	d90d      	bls.n	fe8c <dfu_disconnect+0x2c>
    fe70:	2303      	movs	r3, #3
    fe72:	f04f 0100 	mov.w	r1, #0
    fe76:	f363 0107 	bfi	r1, r3, #0, #8
    fe7a:	4a15      	ldr	r2, [pc, #84]	; (fed0 <dfu_disconnect+0x70>)
    fe7c:	4b15      	ldr	r3, [pc, #84]	; (fed4 <dfu_disconnect+0x74>)
    fe7e:	4816      	ldr	r0, [pc, #88]	; (fed8 <dfu_disconnect+0x78>)
    fe80:	1a9b      	subs	r3, r3, r2
    fe82:	08db      	lsrs	r3, r3, #3
    fe84:	f363 118f 	bfi	r1, r3, #6, #10
    fe88:	f018 fd57 	bl	2893a <log_0>
    if (conn == NULL) {
    fe8c:	b1c4      	cbz	r4, fec0 <dfu_disconnect+0x60>
    int id = find_connection(conn);
    fe8e:	4620      	mov	r0, r4
    fe90:	f7ff fa42 	bl	f318 <find_connection>
    if( id == -ENXIO ){
    fe94:	1d83      	adds	r3, r0, #6
    fe96:	d012      	beq.n	febe <dfu_disconnect+0x5e>
    memset( &dfu_data.connections[id], 0, sizeof dfu_data.connections[id] );
    fe98:	4c10      	ldr	r4, [pc, #64]	; (fedc <dfu_disconnect+0x7c>)
    fe9a:	221c      	movs	r2, #28
    fe9c:	fb02 4000 	mla	r0, r2, r0, r4
    fea0:	2100      	movs	r1, #0
    fea2:	f500 7013 	add.w	r0, r0, #588	; 0x24c
    fea6:	f01a fafc 	bl	2a4a2 <memset>
    dfu_data.number_of_connections--;
    feaa:	f894 0249 	ldrb.w	r0, [r4, #585]	; 0x249
    feae:	3801      	subs	r0, #1
    feb0:	b2c0      	uxtb	r0, r0
    feb2:	f884 0249 	strb.w	r0, [r4, #585]	; 0x249
    if( !dfu_data.number_of_connections ){
    feb6:	b930      	cbnz	r0, fec6 <dfu_disconnect+0x66>
        dfu_data.can_reboot = 1;
    feb8:	2301      	movs	r3, #1
    feba:	f884 3246 	strb.w	r3, [r4, #582]	; 0x246
}
    febe:	bd10      	pop	{r4, pc}
        return -EFAULT;
    fec0:	f06f 000d 	mvn.w	r0, #13
    fec4:	e7fb      	b.n	febe <dfu_disconnect+0x5e>
    return 0;
    fec6:	2000      	movs	r0, #0
    fec8:	e7f9      	b.n	febe <dfu_disconnect+0x5e>
    feca:	bf00      	nop
    fecc:	20010018 	.word	0x20010018
    fed0:	0002db28 	.word	0x0002db28
    fed4:	0002dc28 	.word	0x0002dc28
    fed8:	0002edfa 	.word	0x0002edfa
    fedc:	200000f4 	.word	0x200000f4

0000fee0 <send_request_write>:
{
    fee0:	b084      	sub	sp, #16
    fee2:	b538      	push	{r3, r4, r5, lr}
    fee4:	ac04      	add	r4, sp, #16
    fee6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    if (!dfu_data.connections[event.id_connection].conn) {
    feea:	4c55      	ldr	r4, [pc, #340]	; (10040 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x41>)
    feec:	f89d 3011 	ldrb.w	r3, [sp, #17]
    fef0:	221c      	movs	r2, #28
    fef2:	fb02 4303 	mla	r3, r2, r3, r4
    fef6:	f8d3 224c 	ldr.w	r2, [r3, #588]	; 0x24c
    fefa:	b9ca      	cbnz	r2, ff30 <send_request_write+0x50>
        LOG_ERR("Not connected");
    fefc:	4b51      	ldr	r3, [pc, #324]	; (10044 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x45>)
    fefe:	681b      	ldr	r3, [r3, #0]
    ff00:	075c      	lsls	r4, r3, #29
    ff02:	d106      	bne.n	ff12 <send_request_write+0x32>
        return -ENOEXEC;
    ff04:	f06f 0407 	mvn.w	r4, #7
}
    ff08:	4620      	mov	r0, r4
    ff0a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ff0e:	b004      	add	sp, #16
    ff10:	4770      	bx	lr
        LOG_ERR("Not connected");
    ff12:	2301      	movs	r3, #1
    ff14:	f04f 0100 	mov.w	r1, #0
    ff18:	f363 0107 	bfi	r1, r3, #0, #8
    ff1c:	4a4a      	ldr	r2, [pc, #296]	; (10048 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x49>)
    ff1e:	4b4b      	ldr	r3, [pc, #300]	; (1004c <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x4d>)
    ff20:	484b      	ldr	r0, [pc, #300]	; (10050 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x51>)
    ff22:	1a9b      	subs	r3, r3, r2
    ff24:	08db      	lsrs	r3, r3, #3
    ff26:	f363 118f 	bfi	r1, r3, #6, #10
    ff2a:	f018 fd06 	bl	2893a <log_0>
    ff2e:	e7e9      	b.n	ff04 <send_request_write+0x24>
    if(!event.handle){
    ff30:	f8bd 2012 	ldrh.w	r2, [sp, #18]
    ff34:	b982      	cbnz	r2, ff58 <send_request_write+0x78>
        LOG_ERR("Not get value handle");
    ff36:	4b43      	ldr	r3, [pc, #268]	; (10044 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x45>)
    ff38:	681b      	ldr	r3, [r3, #0]
    ff3a:	0758      	lsls	r0, r3, #29
    ff3c:	d0e2      	beq.n	ff04 <send_request_write+0x24>
    ff3e:	2301      	movs	r3, #1
    ff40:	f04f 0100 	mov.w	r1, #0
    ff44:	f363 0107 	bfi	r1, r3, #0, #8
    ff48:	4a3f      	ldr	r2, [pc, #252]	; (10048 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x49>)
    ff4a:	4b40      	ldr	r3, [pc, #256]	; (1004c <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x4d>)
    ff4c:	4841      	ldr	r0, [pc, #260]	; (10054 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x55>)
    ff4e:	1a9b      	subs	r3, r3, r2
    ff50:	08db      	lsrs	r3, r3, #3
    ff52:	f363 118f 	bfi	r1, r3, #6, #10
    ff56:	e7e8      	b.n	ff2a <send_request_write+0x4a>
    if( event.data_size > dfu_data.connections[event.id_connection].mtu || event.data_size > MAX_MSG_BT_SIZE ){
    ff58:	f8bd 207a 	ldrh.w	r2, [sp, #122]	; 0x7a
    ff5c:	f8b3 3258 	ldrh.w	r3, [r3, #600]	; 0x258
    ff60:	4293      	cmp	r3, r2
    ff62:	d301      	bcc.n	ff68 <send_request_write+0x88>
    ff64:	2a64      	cmp	r2, #100	; 0x64
    ff66:	d969      	bls.n	1003c <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x3d>
        LOG_ERR("Message is bigger than buffer size");
    ff68:	4b36      	ldr	r3, [pc, #216]	; (10044 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x45>)
    ff6a:	681b      	ldr	r3, [r3, #0]
    ff6c:	0759      	lsls	r1, r3, #29
    ff6e:	d0c9      	beq.n	ff04 <send_request_write+0x24>
    ff70:	2301      	movs	r3, #1
    ff72:	f04f 0100 	mov.w	r1, #0
    ff76:	f363 0107 	bfi	r1, r3, #0, #8
    ff7a:	4a33      	ldr	r2, [pc, #204]	; (10048 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x49>)
    ff7c:	4b33      	ldr	r3, [pc, #204]	; (1004c <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x4d>)
    ff7e:	4836      	ldr	r0, [pc, #216]	; (10058 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x59>)
    ff80:	1a9b      	subs	r3, r3, r2
    ff82:	08db      	lsrs	r3, r3, #3
    ff84:	f363 118f 	bfi	r1, r3, #6, #10
    ff88:	e7cf      	b.n	ff2a <send_request_write+0x4a>
        if (attempts >= 5) {
    ff8a:	3d01      	subs	r5, #1
    ff8c:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
    ff90:	d110      	bne.n	ffb4 <send_request_write+0xd4>
            LOG_ERR("Write going");
    ff92:	4b2c      	ldr	r3, [pc, #176]	; (10044 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x45>)
    ff94:	681b      	ldr	r3, [r3, #0]
    ff96:	075a      	lsls	r2, r3, #29
    ff98:	d0b4      	beq.n	ff04 <send_request_write+0x24>
    ff9a:	2301      	movs	r3, #1
    ff9c:	f04f 0100 	mov.w	r1, #0
    ffa0:	f363 0107 	bfi	r1, r3, #0, #8
    ffa4:	4a28      	ldr	r2, [pc, #160]	; (10048 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x49>)
    ffa6:	4b29      	ldr	r3, [pc, #164]	; (1004c <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x4d>)
    ffa8:	482c      	ldr	r0, [pc, #176]	; (1005c <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x5d>)
    ffaa:	1a9b      	subs	r3, r3, r2
    ffac:	08db      	lsrs	r3, r3, #3
    ffae:	f363 118f 	bfi	r1, r3, #6, #10
    ffb2:	e7ba      	b.n	ff2a <send_request_write+0x4a>
        k_sleep(K_MSEC(200));
    ffb4:	20c8      	movs	r0, #200	; 0xc8
    ffb6:	f017 fce3 	bl	27980 <k_sleep>
    while (dfu_data.write_params.func) {
    ffba:	f8d4 3378 	ldr.w	r3, [r4, #888]	; 0x378
    ffbe:	2b00      	cmp	r3, #0
    ffc0:	d1e3      	bne.n	ff8a <send_request_write+0xaa>
    memcpy(dfu_data.gatt_write_buf, event.data, event.data_size);
    ffc2:	4d27      	ldr	r5, [pc, #156]	; (10060 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x61>)
    ffc4:	f8bd 207a 	ldrh.w	r2, [sp, #122]	; 0x7a
    ffc8:	f10d 0116 	add.w	r1, sp, #22
    ffcc:	4628      	mov	r0, r5
    ffce:	f01a fa3e 	bl	2a44e <memcpy>
    dfu_data.write_params.length = event.data_size;
    ffd2:	f8bd 307a 	ldrh.w	r3, [sp, #122]	; 0x7a
    ffd6:	f8a4 3384 	strh.w	r3, [r4, #900]	; 0x384
    dfu_data.write_params.handle = event.handle;
    ffda:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    ffde:	f8a4 337c 	strh.w	r3, [r4, #892]	; 0x37c
    dfu_data.write_params.offset = event.offset;
    ffe2:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    ffe6:	f8a4 337e 	strh.w	r3, [r4, #894]	; 0x37e
    dfu_data.write_params.func   = write_func;
    ffea:	4b1e      	ldr	r3, [pc, #120]	; (10064 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x65>)
    ffec:	f8c4 3378 	str.w	r3, [r4, #888]	; 0x378
    err = bt_gatt_write(dfu_data.connections[event.id_connection].conn, &dfu_data.write_params);
    fff0:	f89d 3011 	ldrb.w	r3, [sp, #17]
    dfu_data.write_params.data   = dfu_data.gatt_write_buf;
    fff4:	f8c4 5380 	str.w	r5, [r4, #896]	; 0x380
    err = bt_gatt_write(dfu_data.connections[event.id_connection].conn, &dfu_data.write_params);
    fff8:	221c      	movs	r2, #28
    fffa:	fb02 4403 	mla	r4, r2, r3, r4
    fffe:	f1a5 0188 	sub.w	r1, r5, #136	; 0x88
   10002:	f8d4 024c 	ldr.w	r0, [r4, #588]	; 0x24c
   10006:	f00b f959 	bl	1b2bc <bt_gatt_write>
    if (err) {
   1000a:	4604      	mov	r4, r0
   1000c:	2800      	cmp	r0, #0
   1000e:	f43f af7b 	beq.w	ff08 <send_request_write+0x28>
        LOG_ERR("Write failed (err %d)", err);
   10012:	4b0c      	ldr	r3, [pc, #48]	; (10044 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x45>)
   10014:	681b      	ldr	r3, [r3, #0]
   10016:	075b      	lsls	r3, r3, #29
   10018:	f43f af76 	beq.w	ff08 <send_request_write+0x28>
   1001c:	2301      	movs	r3, #1
   1001e:	f04f 0200 	mov.w	r2, #0
   10022:	f363 0207 	bfi	r2, r3, #0, #8
   10026:	4908      	ldr	r1, [pc, #32]	; (10048 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x49>)
   10028:	4b08      	ldr	r3, [pc, #32]	; (1004c <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x4d>)
   1002a:	1a5b      	subs	r3, r3, r1
   1002c:	08db      	lsrs	r3, r3, #3
   1002e:	4601      	mov	r1, r0
   10030:	f363 128f 	bfi	r2, r3, #6, #10
   10034:	480c      	ldr	r0, [pc, #48]	; (10068 <CONFIG_BT_CTLR_SUBVERSION_NUMBER+0x69>)
   10036:	f018 fc8d 	bl	28954 <log_1>
   1003a:	e765      	b.n	ff08 <send_request_write+0x28>
   1003c:	2505      	movs	r5, #5
   1003e:	e7bc      	b.n	ffba <send_request_write+0xda>
   10040:	200000f4 	.word	0x200000f4
   10044:	20010018 	.word	0x20010018
   10048:	0002db28 	.word	0x0002db28
   1004c:	0002dc28 	.word	0x0002dc28
   10050:	0002f247 	.word	0x0002f247
   10054:	0002f255 	.word	0x0002f255
   10058:	0002f26a 	.word	0x0002f26a
   1005c:	0002f28d 	.word	0x0002f28d
   10060:	200004e0 	.word	0x200004e0
   10064:	0000f3c1 	.word	0x0000f3c1
   10068:	0002f299 	.word	0x0002f299

0001006c <send_request_read>:
int send_request_read(msgq_dfu_event event){
   1006c:	b084      	sub	sp, #16
   1006e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10070:	ac06      	add	r4, sp, #24
   10072:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    if (!dfu_data.connections[event.id_connection].conn) {
   10076:	4c41      	ldr	r4, [pc, #260]	; (1017c <send_request_read+0x110>)
   10078:	f89d 7019 	ldrb.w	r7, [sp, #25]
   1007c:	f8bd 601a 	ldrh.w	r6, [sp, #26]
   10080:	231c      	movs	r3, #28
   10082:	fb03 4307 	mla	r3, r3, r7, r4
   10086:	f8d3 324c 	ldr.w	r3, [r3, #588]	; 0x24c
   1008a:	b9cb      	cbnz	r3, 100c0 <send_request_read+0x54>
        LOG_ERR("Not connected");
   1008c:	4b3c      	ldr	r3, [pc, #240]	; (10180 <send_request_read+0x114>)
   1008e:	681b      	ldr	r3, [r3, #0]
   10090:	0758      	lsls	r0, r3, #29
   10092:	d106      	bne.n	100a2 <send_request_read+0x36>
        return -ENOEXEC;
   10094:	f06f 0407 	mvn.w	r4, #7
}
   10098:	4620      	mov	r0, r4
   1009a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   1009e:	b004      	add	sp, #16
   100a0:	4770      	bx	lr
        LOG_ERR("Not connected");
   100a2:	2301      	movs	r3, #1
   100a4:	f04f 0100 	mov.w	r1, #0
   100a8:	f363 0107 	bfi	r1, r3, #0, #8
   100ac:	4a35      	ldr	r2, [pc, #212]	; (10184 <send_request_read+0x118>)
   100ae:	4b36      	ldr	r3, [pc, #216]	; (10188 <send_request_read+0x11c>)
   100b0:	4836      	ldr	r0, [pc, #216]	; (1018c <send_request_read+0x120>)
   100b2:	1a9b      	subs	r3, r3, r2
   100b4:	08db      	lsrs	r3, r3, #3
   100b6:	f363 118f 	bfi	r1, r3, #6, #10
   100ba:	f018 fc3e 	bl	2893a <log_0>
   100be:	e7e9      	b.n	10094 <send_request_read+0x28>
    if(!event.handle){
   100c0:	2e00      	cmp	r6, #0
   100c2:	d158      	bne.n	10176 <send_request_read+0x10a>
        LOG_ERR("Not get value handle");
   100c4:	4b2e      	ldr	r3, [pc, #184]	; (10180 <send_request_read+0x114>)
   100c6:	681b      	ldr	r3, [r3, #0]
   100c8:	0759      	lsls	r1, r3, #29
   100ca:	d0e3      	beq.n	10094 <send_request_read+0x28>
   100cc:	2301      	movs	r3, #1
   100ce:	f04f 0100 	mov.w	r1, #0
   100d2:	f363 0107 	bfi	r1, r3, #0, #8
   100d6:	4a2b      	ldr	r2, [pc, #172]	; (10184 <send_request_read+0x118>)
   100d8:	4b2b      	ldr	r3, [pc, #172]	; (10188 <send_request_read+0x11c>)
   100da:	482d      	ldr	r0, [pc, #180]	; (10190 <send_request_read+0x124>)
   100dc:	1a9b      	subs	r3, r3, r2
   100de:	08db      	lsrs	r3, r3, #3
   100e0:	f363 118f 	bfi	r1, r3, #6, #10
   100e4:	e7e9      	b.n	100ba <send_request_read+0x4e>
        if (attempts >= 5) {
   100e6:	3d01      	subs	r5, #1
   100e8:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
   100ec:	d110      	bne.n	10110 <send_request_read+0xa4>
            LOG_ERR("Read going");
   100ee:	4b24      	ldr	r3, [pc, #144]	; (10180 <send_request_read+0x114>)
   100f0:	681b      	ldr	r3, [r3, #0]
   100f2:	075a      	lsls	r2, r3, #29
   100f4:	d0ce      	beq.n	10094 <send_request_read+0x28>
   100f6:	2301      	movs	r3, #1
   100f8:	f04f 0100 	mov.w	r1, #0
   100fc:	f363 0107 	bfi	r1, r3, #0, #8
   10100:	4a20      	ldr	r2, [pc, #128]	; (10184 <send_request_read+0x118>)
   10102:	4b21      	ldr	r3, [pc, #132]	; (10188 <send_request_read+0x11c>)
   10104:	4823      	ldr	r0, [pc, #140]	; (10194 <send_request_read+0x128>)
   10106:	1a9b      	subs	r3, r3, r2
   10108:	08db      	lsrs	r3, r3, #3
   1010a:	f363 118f 	bfi	r1, r3, #6, #10
   1010e:	e7d4      	b.n	100ba <send_request_read+0x4e>
        k_sleep(K_MSEC(200));
   10110:	20c8      	movs	r0, #200	; 0xc8
   10112:	f017 fc35 	bl	27980 <k_sleep>
    while (dfu_data.read_params.func) {
   10116:	f8d4 33dc 	ldr.w	r3, [r4, #988]	; 0x3dc
   1011a:	2b00      	cmp	r3, #0
   1011c:	d1e3      	bne.n	100e6 <send_request_read+0x7a>
    dfu_data.read_params.func = read_func;
   1011e:	4b1e      	ldr	r3, [pc, #120]	; (10198 <send_request_read+0x12c>)
   10120:	f8c4 33dc 	str.w	r3, [r4, #988]	; 0x3dc
    dfu_data.read_params.handle_count = 1;
   10124:	2301      	movs	r3, #1
   10126:	f8c4 33e0 	str.w	r3, [r4, #992]	; 0x3e0
    dfu_data.read_params.single.offset = event.offset;
   1012a:	f8bd 301c 	ldrh.w	r3, [sp, #28]
   1012e:	f8a4 33e6 	strh.w	r3, [r4, #998]	; 0x3e6
    if (err = bt_gatt_read(dfu_data.connections[event.id_connection].conn, &dfu_data.read_params), err) {
   10132:	231c      	movs	r3, #28
    dfu_data.read_params.single.handle = event.handle;
   10134:	f8a4 63e4 	strh.w	r6, [r4, #996]	; 0x3e4
    if (err = bt_gatt_read(dfu_data.connections[event.id_connection].conn, &dfu_data.read_params), err) {
   10138:	fb03 4407 	mla	r4, r3, r7, r4
   1013c:	4917      	ldr	r1, [pc, #92]	; (1019c <send_request_read+0x130>)
   1013e:	f8d4 024c 	ldr.w	r0, [r4, #588]	; 0x24c
   10142:	f00a ffaf 	bl	1b0a4 <bt_gatt_read>
   10146:	4604      	mov	r4, r0
   10148:	2800      	cmp	r0, #0
   1014a:	d0a5      	beq.n	10098 <send_request_read+0x2c>
        LOG_ERR("Handle 0x%x GATT read request failed (err %d)", event.handle, err);
   1014c:	4b0c      	ldr	r3, [pc, #48]	; (10180 <send_request_read+0x114>)
   1014e:	681b      	ldr	r3, [r3, #0]
   10150:	075b      	lsls	r3, r3, #29
   10152:	d0a1      	beq.n	10098 <send_request_read+0x2c>
   10154:	2201      	movs	r2, #1
   10156:	f04f 0300 	mov.w	r3, #0
   1015a:	f362 0307 	bfi	r3, r2, #0, #8
   1015e:	4909      	ldr	r1, [pc, #36]	; (10184 <send_request_read+0x118>)
   10160:	4a09      	ldr	r2, [pc, #36]	; (10188 <send_request_read+0x11c>)
   10162:	1a52      	subs	r2, r2, r1
   10164:	08d2      	lsrs	r2, r2, #3
   10166:	f362 138f 	bfi	r3, r2, #6, #10
   1016a:	4631      	mov	r1, r6
   1016c:	4602      	mov	r2, r0
   1016e:	480c      	ldr	r0, [pc, #48]	; (101a0 <send_request_read+0x134>)
   10170:	f018 fc04 	bl	2897c <log_2>
   10174:	e790      	b.n	10098 <send_request_read+0x2c>
   10176:	2505      	movs	r5, #5
   10178:	e7cd      	b.n	10116 <send_request_read+0xaa>
   1017a:	bf00      	nop
   1017c:	200000f4 	.word	0x200000f4
   10180:	20010018 	.word	0x20010018
   10184:	0002db28 	.word	0x0002db28
   10188:	0002dc28 	.word	0x0002dc28
   1018c:	0002f247 	.word	0x0002f247
   10190:	0002f255 	.word	0x0002f255
   10194:	0002f20e 	.word	0x0002f20e
   10198:	0000f559 	.word	0x0000f559
   1019c:	200004bc 	.word	0x200004bc
   101a0:	0002f219 	.word	0x0002f219

000101a4 <send_channel>:
    LOG_INF("Thread send channel");
   101a4:	4b27      	ldr	r3, [pc, #156]	; (10244 <send_channel+0xa0>)
int send_channel(struct device *dev){
   101a6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    LOG_INF("Thread send channel");
   101aa:	681b      	ldr	r3, [r3, #0]
   101ac:	f003 0307 	and.w	r3, r3, #7
   101b0:	2b02      	cmp	r3, #2
int send_channel(struct device *dev){
   101b2:	b098      	sub	sp, #96	; 0x60
    LOG_INF("Thread send channel");
   101b4:	d90d      	bls.n	101d2 <send_channel+0x2e>
   101b6:	2303      	movs	r3, #3
   101b8:	f04f 0100 	mov.w	r1, #0
   101bc:	f363 0107 	bfi	r1, r3, #0, #8
   101c0:	4a21      	ldr	r2, [pc, #132]	; (10248 <send_channel+0xa4>)
   101c2:	4b22      	ldr	r3, [pc, #136]	; (1024c <send_channel+0xa8>)
   101c4:	4822      	ldr	r0, [pc, #136]	; (10250 <send_channel+0xac>)
   101c6:	1a9b      	subs	r3, r3, r2
   101c8:	08db      	lsrs	r3, r3, #3
   101ca:	f363 118f 	bfi	r1, r3, #6, #10
   101ce:	f018 fbb4 	bl	2893a <log_0>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&q, *(uintptr_t *)&data, *(uintptr_t *)&timeout, K_SYSCALL_K_MSGQ_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_get(q, data, timeout);
   101d2:	4c20      	ldr	r4, [pc, #128]	; (10254 <send_channel+0xb0>)
   101d4:	4e20      	ldr	r6, [pc, #128]	; (10258 <send_channel+0xb4>)
            send_request_read(event);
   101d6:	f104 0510 	add.w	r5, r4, #16
   101da:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   101de:	491d      	ldr	r1, [pc, #116]	; (10254 <send_channel+0xb0>)
   101e0:	4630      	mov	r0, r6
   101e2:	f016 fb95 	bl	26910 <z_impl_k_msgq_get>
        switch (event.event)
   101e6:	7823      	ldrb	r3, [r4, #0]
   101e8:	b12b      	cbz	r3, 101f6 <send_channel+0x52>
   101ea:	2b01      	cmp	r3, #1
   101ec:	d016      	beq.n	1021c <send_channel+0x78>
        k_sleep(K_MSEC(10));
   101ee:	200a      	movs	r0, #10
   101f0:	f017 fbc6 	bl	27980 <k_sleep>
        k_msgq_get(&msgq_send, &event, K_FOREVER);
   101f4:	e7f1      	b.n	101da <send_channel+0x36>
            send_request_read(event);
   101f6:	f8d4 a000 	ldr.w	sl, [r4]
   101fa:	f8d4 9004 	ldr.w	r9, [r4, #4]
   101fe:	f8d4 8008 	ldr.w	r8, [r4, #8]
   10202:	68e7      	ldr	r7, [r4, #12]
   10204:	4629      	mov	r1, r5
   10206:	225c      	movs	r2, #92	; 0x5c
   10208:	4668      	mov	r0, sp
   1020a:	f01a f920 	bl	2a44e <memcpy>
   1020e:	4650      	mov	r0, sl
   10210:	4649      	mov	r1, r9
   10212:	4642      	mov	r2, r8
   10214:	463b      	mov	r3, r7
   10216:	f7ff ff29 	bl	1006c <send_request_read>
            break;
   1021a:	e7e8      	b.n	101ee <send_channel+0x4a>
            send_request_write(event);            
   1021c:	f8d4 a000 	ldr.w	sl, [r4]
   10220:	f8d4 9004 	ldr.w	r9, [r4, #4]
   10224:	f8d4 8008 	ldr.w	r8, [r4, #8]
   10228:	68e7      	ldr	r7, [r4, #12]
   1022a:	4629      	mov	r1, r5
   1022c:	225c      	movs	r2, #92	; 0x5c
   1022e:	4668      	mov	r0, sp
   10230:	f01a f90d 	bl	2a44e <memcpy>
   10234:	4650      	mov	r0, sl
   10236:	4649      	mov	r1, r9
   10238:	4642      	mov	r2, r8
   1023a:	463b      	mov	r3, r7
   1023c:	f7ff fe50 	bl	fee0 <send_request_write>
            break;
   10240:	e7d5      	b.n	101ee <send_channel+0x4a>
   10242:	bf00      	nop
   10244:	20010018 	.word	0x20010018
   10248:	0002db28 	.word	0x0002db28
   1024c:	0002dc28 	.word	0x0002dc28
   10250:	0002f1fa 	.word	0x0002f1fa
   10254:	20003bdc 	.word	0x20003bdc
   10258:	20010130 	.word	0x20010130

0001025c <process_get_requests>:
int process_get_requests(msgq_dfu_event event){
   1025c:	b084      	sub	sp, #16
   1025e:	b530      	push	{r4, r5, lr}
   10260:	b09f      	sub	sp, #124	; 0x7c
   10262:	ac22      	add	r4, sp, #136	; 0x88
   10264:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    msgq_dfu_event reply_event = {
   10268:	2268      	movs	r2, #104	; 0x68
   1026a:	2100      	movs	r1, #0
   1026c:	a804      	add	r0, sp, #16
    enum dfu_cmd command = cast(enum dfu_cmd, event.data[offset++]);
   1026e:	f89d 408f 	ldrb.w	r4, [sp, #143]	; 0x8f
    msgq_dfu_event reply_event = {
   10272:	f01a f916 	bl	2a4a2 <memset>
   10276:	2301      	movs	r3, #1
   10278:	f88d 300c 	strb.w	r3, [sp, #12]
   1027c:	f89d 3089 	ldrb.w	r3, [sp, #137]	; 0x89
   10280:	f88d 300d 	strb.w	r3, [sp, #13]
    if( command >= number_of_commands ){
   10284:	2c05      	cmp	r4, #5
    msgq_dfu_event reply_event = {
   10286:	f8bd 308a 	ldrh.w	r3, [sp, #138]	; 0x8a
   1028a:	f8ad 300e 	strh.w	r3, [sp, #14]
    if( command >= number_of_commands ){
   1028e:	d916      	bls.n	102be <process_get_requests+0x62>
        LOG_ERR("Commands with error (%d)", err);
   10290:	4b5a      	ldr	r3, [pc, #360]	; (103fc <process_get_requests+0x1a0>)
   10292:	681b      	ldr	r3, [r3, #0]
   10294:	075a      	lsls	r2, r3, #29
   10296:	d00f      	beq.n	102b8 <process_get_requests+0x5c>
   10298:	2301      	movs	r3, #1
   1029a:	f04f 0200 	mov.w	r2, #0
   1029e:	f363 0207 	bfi	r2, r3, #0, #8
   102a2:	4957      	ldr	r1, [pc, #348]	; (10400 <process_get_requests+0x1a4>)
   102a4:	4b57      	ldr	r3, [pc, #348]	; (10404 <process_get_requests+0x1a8>)
   102a6:	4858      	ldr	r0, [pc, #352]	; (10408 <process_get_requests+0x1ac>)
   102a8:	1a5b      	subs	r3, r3, r1
   102aa:	08db      	lsrs	r3, r3, #3
   102ac:	f363 128f 	bfi	r2, r3, #6, #10
   102b0:	f06f 0115 	mvn.w	r1, #21
   102b4:	f018 fb4e 	bl	28954 <log_1>
        err = -EINVAL;
   102b8:	f06f 0415 	mvn.w	r4, #21
   102bc:	e059      	b.n	10372 <process_get_requests+0x116>
    reply_event.data[reply_event.data_size++] = STS_MSG;
   102be:	2302      	movs	r3, #2
   102c0:	f88d 3012 	strb.w	r3, [sp, #18]
    reply_event.data[reply_event.data_size++] = command;
   102c4:	f8ad 3076 	strh.w	r3, [sp, #118]	; 0x76
   102c8:	f88d 4013 	strb.w	r4, [sp, #19]
    if( command == IMAGE_CHUNK_CMD && dfu_data.state == DFU_UPDATING_STATE ){
   102cc:	2c00      	cmp	r4, #0
   102ce:	d162      	bne.n	10396 <process_get_requests+0x13a>
   102d0:	4d4e      	ldr	r5, [pc, #312]	; (1040c <process_get_requests+0x1b0>)
   102d2:	f895 4244 	ldrb.w	r4, [r5, #580]	; 0x244
   102d6:	429c      	cmp	r4, r3
   102d8:	d17b      	bne.n	103d2 <process_get_requests+0x176>
        memcpy( &chunk_offset, event.data + offset, sizeof chunk_offset );
   102da:	2204      	movs	r2, #4
   102dc:	a924      	add	r1, sp, #144	; 0x90
   102de:	a802      	add	r0, sp, #8
   102e0:	f01a f8b5 	bl	2a44e <memcpy>
        chunk_size = MIN(dfu_data.slots[0].image_size - chunk_offset, MAX_CHUNK_SIZE_IMAGE);
   102e4:	9a02      	ldr	r2, [sp, #8]
   102e6:	68eb      	ldr	r3, [r5, #12]
        memcpy(reply_event.data + reply_event.data_size, &chunk_offset, sizeof chunk_offset);
   102e8:	f8bd 0076 	ldrh.w	r0, [sp, #118]	; 0x76
        chunk_size = MIN(dfu_data.slots[0].image_size - chunk_offset, MAX_CHUNK_SIZE_IMAGE);
   102ec:	1a9b      	subs	r3, r3, r2
   102ee:	2b5c      	cmp	r3, #92	; 0x5c
   102f0:	bf28      	it	cs
   102f2:	235c      	movcs	r3, #92	; 0x5c
   102f4:	f8ad 3006 	strh.w	r3, [sp, #6]
        memcpy(reply_event.data + reply_event.data_size, &chunk_offset, sizeof chunk_offset);
   102f8:	f10d 0312 	add.w	r3, sp, #18
   102fc:	2204      	movs	r2, #4
   102fe:	a902      	add	r1, sp, #8
   10300:	4418      	add	r0, r3
   10302:	f01a f8a4 	bl	2a44e <memcpy>
        reply_event.data_size += sizeof chunk_offset;
   10306:	f8bd 0076 	ldrh.w	r0, [sp, #118]	; 0x76
   1030a:	3004      	adds	r0, #4
        memcpy(reply_event.data + reply_event.data_size, &chunk_size, sizeof chunk_size);
   1030c:	f10d 0312 	add.w	r3, sp, #18
        reply_event.data_size += sizeof chunk_offset;
   10310:	b280      	uxth	r0, r0
        memcpy(reply_event.data + reply_event.data_size, &chunk_size, sizeof chunk_size);
   10312:	4622      	mov	r2, r4
        reply_event.data_size += sizeof chunk_offset;
   10314:	f8ad 0076 	strh.w	r0, [sp, #118]	; 0x76
        memcpy(reply_event.data + reply_event.data_size, &chunk_size, sizeof chunk_size);
   10318:	f10d 0106 	add.w	r1, sp, #6
   1031c:	4418      	add	r0, r3
   1031e:	f01a f896 	bl	2a44e <memcpy>
        reply_event.data_size += sizeof chunk_size;
   10322:	f8bd 2076 	ldrh.w	r2, [sp, #118]	; 0x76
        if (err = flash_area_read(dfu_data.slots[0].fap, chunk_offset, 
   10326:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   1032a:	6968      	ldr	r0, [r5, #20]
        reply_event.data_size += sizeof chunk_size;
   1032c:	3202      	adds	r2, #2
   1032e:	b292      	uxth	r2, r2
        if (err = flash_area_read(dfu_data.slots[0].fap, chunk_offset, 
   10330:	f10d 0112 	add.w	r1, sp, #18
        reply_event.data_size += sizeof chunk_size;
   10334:	f8ad 2076 	strh.w	r2, [sp, #118]	; 0x76
        if (err = flash_area_read(dfu_data.slots[0].fap, chunk_offset, 
   10338:	440a      	add	r2, r1
   1033a:	9902      	ldr	r1, [sp, #8]
   1033c:	f019 fe2a 	bl	29f94 <flash_area_read>
   10340:	4604      	mov	r4, r0
   10342:	b1e0      	cbz	r0, 1037e <process_get_requests+0x122>
            LOG_ERR("Error read (%d)", err);
   10344:	4b2d      	ldr	r3, [pc, #180]	; (103fc <process_get_requests+0x1a0>)
   10346:	681b      	ldr	r3, [r3, #0]
   10348:	075b      	lsls	r3, r3, #29
   1034a:	d00e      	beq.n	1036a <process_get_requests+0x10e>
   1034c:	2301      	movs	r3, #1
   1034e:	f04f 0200 	mov.w	r2, #0
   10352:	f363 0207 	bfi	r2, r3, #0, #8
   10356:	492a      	ldr	r1, [pc, #168]	; (10400 <process_get_requests+0x1a4>)
   10358:	4b2a      	ldr	r3, [pc, #168]	; (10404 <process_get_requests+0x1a8>)
   1035a:	1a5b      	subs	r3, r3, r1
   1035c:	08db      	lsrs	r3, r3, #3
   1035e:	4601      	mov	r1, r0
   10360:	f363 128f 	bfi	r2, r3, #6, #10
   10364:	482a      	ldr	r0, [pc, #168]	; (10410 <process_get_requests+0x1b4>)
   10366:	f018 faf5 	bl	28954 <log_1>
            dfu_data.state  = DFU_ERROR_STATE;
   1036a:	f240 1305 	movw	r3, #261	; 0x105
   1036e:	f8a5 3244 	strh.w	r3, [r5, #580]	; 0x244
}
   10372:	4620      	mov	r0, r4
   10374:	b01f      	add	sp, #124	; 0x7c
   10376:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   1037a:	b004      	add	sp, #16
   1037c:	4770      	bx	lr
        reply_event.data_size += chunk_size;
   1037e:	f8bd 3076 	ldrh.w	r3, [sp, #118]	; 0x76
   10382:	f8bd 2006 	ldrh.w	r2, [sp, #6]
        k_msgq_put(&msgq_send, &reply_event, K_NO_WAIT);
   10386:	4823      	ldr	r0, [pc, #140]	; (10414 <process_get_requests+0x1b8>)
        reply_event.data_size += chunk_size;
   10388:	4413      	add	r3, r2
        k_msgq_put(&msgq_send, &reply_event, K_NO_WAIT);
   1038a:	a903      	add	r1, sp, #12
        reply_event.data_size += chunk_size;
   1038c:	f8ad 3076 	strh.w	r3, [sp, #118]	; 0x76
        k_msgq_put(&msgq_send, &reply_event, K_NO_WAIT);
   10390:	f017 faf8 	bl	27984 <k_msgq_put.constprop.6>
    if( command == IMAGE_CHUNK_CMD && dfu_data.state == DFU_UPDATING_STATE ){
   10394:	e7ed      	b.n	10372 <process_get_requests+0x116>
    } else if( command == STATE_CMD ){
   10396:	2c01      	cmp	r4, #1
   10398:	d10d      	bne.n	103b6 <process_get_requests+0x15a>
        reply_event.data[reply_event.data_size++] = dfu_data.state;
   1039a:	2303      	movs	r3, #3
   1039c:	f8ad 3076 	strh.w	r3, [sp, #118]	; 0x76
   103a0:	4b1a      	ldr	r3, [pc, #104]	; (1040c <process_get_requests+0x1b0>)
   103a2:	f893 3244 	ldrb.w	r3, [r3, #580]	; 0x244
   103a6:	f88d 3014 	strb.w	r3, [sp, #20]
        k_msgq_put(&msgq_send, &reply_event, K_NO_WAIT);
   103aa:	a903      	add	r1, sp, #12
   103ac:	4819      	ldr	r0, [pc, #100]	; (10414 <process_get_requests+0x1b8>)
   103ae:	f017 fae9 	bl	27984 <k_msgq_put.constprop.6>
    int err = 0;
   103b2:	2400      	movs	r4, #0
   103b4:	e7dd      	b.n	10372 <process_get_requests+0x116>
    } else if( command == CONFIRM_IMAGE_CMD ){
   103b6:	2c05      	cmp	r4, #5
   103b8:	d10b      	bne.n	103d2 <process_get_requests+0x176>
        reply_event.data[reply_event.data_size++] = boot_is_img_confirmed();
   103ba:	f019 fd6c 	bl	29e96 <boot_is_img_confirmed>
   103be:	f8bd 3076 	ldrh.w	r3, [sp, #118]	; 0x76
   103c2:	1c5a      	adds	r2, r3, #1
   103c4:	f8ad 2076 	strh.w	r2, [sp, #118]	; 0x76
   103c8:	aa1e      	add	r2, sp, #120	; 0x78
   103ca:	4413      	add	r3, r2
   103cc:	f803 0c66 	strb.w	r0, [r3, #-102]
   103d0:	e7eb      	b.n	103aa <process_get_requests+0x14e>
        LOG_WRN("Request invalid!");
   103d2:	4b0a      	ldr	r3, [pc, #40]	; (103fc <process_get_requests+0x1a0>)
   103d4:	681c      	ldr	r4, [r3, #0]
   103d6:	f014 0406 	ands.w	r4, r4, #6
   103da:	d0ca      	beq.n	10372 <process_get_requests+0x116>
   103dc:	2302      	movs	r3, #2
   103de:	f04f 0100 	mov.w	r1, #0
   103e2:	f363 0107 	bfi	r1, r3, #0, #8
   103e6:	4a06      	ldr	r2, [pc, #24]	; (10400 <process_get_requests+0x1a4>)
   103e8:	4b06      	ldr	r3, [pc, #24]	; (10404 <process_get_requests+0x1a8>)
   103ea:	480b      	ldr	r0, [pc, #44]	; (10418 <process_get_requests+0x1bc>)
   103ec:	1a9b      	subs	r3, r3, r2
   103ee:	08db      	lsrs	r3, r3, #3
   103f0:	f363 118f 	bfi	r1, r3, #6, #10
   103f4:	f018 faa1 	bl	2893a <log_0>
   103f8:	e7db      	b.n	103b2 <process_get_requests+0x156>
   103fa:	bf00      	nop
   103fc:	20010018 	.word	0x20010018
   10400:	0002db28 	.word	0x0002db28
   10404:	0002dc28 	.word	0x0002dc28
   10408:	0002f01e 	.word	0x0002f01e
   1040c:	200000f4 	.word	0x200000f4
   10410:	0002f037 	.word	0x0002f037
   10414:	20010130 	.word	0x20010130
   10418:	0002f047 	.word	0x0002f047

0001041c <dfu_swap_slots>:
int dfu_swap_slots(int permanent){
   1041c:	b510      	push	{r4, lr}
    if (!dfu_data.can_reboot) {
   1041e:	4b1b      	ldr	r3, [pc, #108]	; (1048c <dfu_swap_slots+0x70>)
   10420:	f893 3246 	ldrb.w	r3, [r3, #582]	; 0x246
   10424:	b9a3      	cbnz	r3, 10450 <dfu_swap_slots+0x34>
        LOG_ERR("Cannot reboot");
   10426:	4b1a      	ldr	r3, [pc, #104]	; (10490 <dfu_swap_slots+0x74>)
   10428:	681b      	ldr	r3, [r3, #0]
   1042a:	075a      	lsls	r2, r3, #29
   1042c:	d00d      	beq.n	1044a <dfu_swap_slots+0x2e>
   1042e:	2301      	movs	r3, #1
   10430:	f04f 0100 	mov.w	r1, #0
   10434:	f363 0107 	bfi	r1, r3, #0, #8
   10438:	4a16      	ldr	r2, [pc, #88]	; (10494 <dfu_swap_slots+0x78>)
   1043a:	4b17      	ldr	r3, [pc, #92]	; (10498 <dfu_swap_slots+0x7c>)
   1043c:	4817      	ldr	r0, [pc, #92]	; (1049c <dfu_swap_slots+0x80>)
   1043e:	1a9b      	subs	r3, r3, r2
   10440:	08db      	lsrs	r3, r3, #3
   10442:	f363 118f 	bfi	r1, r3, #6, #10
   10446:	f018 fa78 	bl	2893a <log_0>
   1044a:	f06f 040c 	mvn.w	r4, #12
   1044e:	e016      	b.n	1047e <dfu_swap_slots+0x62>
    if (err = boot_request_upgrade(permanent), err) {
   10450:	f002 fff2 	bl	13438 <boot_request_upgrade>
   10454:	4604      	mov	r4, r0
   10456:	b1a0      	cbz	r0, 10482 <dfu_swap_slots+0x66>
        LOG_ERR("Boot request upgrade failed with err (%d)", err);
   10458:	4b0d      	ldr	r3, [pc, #52]	; (10490 <dfu_swap_slots+0x74>)
   1045a:	681b      	ldr	r3, [r3, #0]
   1045c:	075b      	lsls	r3, r3, #29
   1045e:	d00e      	beq.n	1047e <dfu_swap_slots+0x62>
   10460:	2301      	movs	r3, #1
   10462:	f04f 0200 	mov.w	r2, #0
   10466:	f363 0207 	bfi	r2, r3, #0, #8
   1046a:	490a      	ldr	r1, [pc, #40]	; (10494 <dfu_swap_slots+0x78>)
   1046c:	4b0a      	ldr	r3, [pc, #40]	; (10498 <dfu_swap_slots+0x7c>)
   1046e:	1a5b      	subs	r3, r3, r1
   10470:	08db      	lsrs	r3, r3, #3
   10472:	4601      	mov	r1, r0
   10474:	f363 128f 	bfi	r2, r3, #6, #10
   10478:	4809      	ldr	r0, [pc, #36]	; (104a0 <dfu_swap_slots+0x84>)
   1047a:	f018 fa6b 	bl	28954 <log_1>
}
   1047e:	4620      	mov	r0, r4
   10480:	bd10      	pop	{r4, pc}
    sys_reboot(SYS_REBOOT_COLD);
   10482:	2001      	movs	r0, #1
   10484:	f003 f954 	bl	13730 <sys_reboot>
    return err;
   10488:	e7f9      	b.n	1047e <dfu_swap_slots+0x62>
   1048a:	bf00      	nop
   1048c:	200000f4 	.word	0x200000f4
   10490:	20010018 	.word	0x20010018
   10494:	0002db28 	.word	0x0002db28
   10498:	0002dc28 	.word	0x0002dc28
   1049c:	0002eeaa 	.word	0x0002eeaa
   104a0:	0002eeb8 	.word	0x0002eeb8

000104a4 <process_set_requests>:
int process_set_requests(msgq_dfu_event event){
   104a4:	b084      	sub	sp, #16
   104a6:	b530      	push	{r4, r5, lr}
   104a8:	b09d      	sub	sp, #116	; 0x74
   104aa:	ac20      	add	r4, sp, #128	; 0x80
   104ac:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    msgq_dfu_event reply_event = {
   104b0:	2268      	movs	r2, #104	; 0x68
   104b2:	2100      	movs	r1, #0
   104b4:	a802      	add	r0, sp, #8
    enum dfu_cmd command = cast(enum dfu_cmd, event.data[offset++]);
   104b6:	f89d 5087 	ldrb.w	r5, [sp, #135]	; 0x87
   104ba:	f89d 4088 	ldrb.w	r4, [sp, #136]	; 0x88
    msgq_dfu_event reply_event = {
   104be:	f019 fff0 	bl	2a4a2 <memset>
   104c2:	2301      	movs	r3, #1
   104c4:	f88d 3004 	strb.w	r3, [sp, #4]
   104c8:	f89d 3081 	ldrb.w	r3, [sp, #129]	; 0x81
   104cc:	f88d 3005 	strb.w	r3, [sp, #5]
    if( command >= number_of_commands ){
   104d0:	2d05      	cmp	r5, #5
    msgq_dfu_event reply_event = {
   104d2:	f8bd 3082 	ldrh.w	r3, [sp, #130]	; 0x82
   104d6:	f8ad 3006 	strh.w	r3, [sp, #6]
    if( command >= number_of_commands ){
   104da:	d916      	bls.n	1050a <process_set_requests+0x66>
        LOG_ERR("Commands with error (%d)", err);
   104dc:	4b7a      	ldr	r3, [pc, #488]	; (106c8 <process_set_requests+0x224>)
   104de:	681b      	ldr	r3, [r3, #0]
   104e0:	0759      	lsls	r1, r3, #29
   104e2:	d00f      	beq.n	10504 <process_set_requests+0x60>
   104e4:	2301      	movs	r3, #1
   104e6:	f04f 0200 	mov.w	r2, #0
   104ea:	f363 0207 	bfi	r2, r3, #0, #8
   104ee:	4977      	ldr	r1, [pc, #476]	; (106cc <process_set_requests+0x228>)
   104f0:	4b77      	ldr	r3, [pc, #476]	; (106d0 <process_set_requests+0x22c>)
   104f2:	4878      	ldr	r0, [pc, #480]	; (106d4 <process_set_requests+0x230>)
   104f4:	1a5b      	subs	r3, r3, r1
   104f6:	08db      	lsrs	r3, r3, #3
   104f8:	f363 128f 	bfi	r2, r3, #6, #10
   104fc:	f06f 0115 	mvn.w	r1, #21
   10500:	f018 fa28 	bl	28954 <log_1>
        err = -EINVAL;
   10504:	f06f 0415 	mvn.w	r4, #21
    return err;
   10508:	e0a4      	b.n	10654 <process_set_requests+0x1b0>
    reply_event.data[reply_event.data_size++] = STS_MSG;
   1050a:	2302      	movs	r3, #2
    if( command == STATE_CMD ){
   1050c:	2d01      	cmp	r5, #1
    reply_event.data[reply_event.data_size++] = STS_MSG;
   1050e:	f88d 300a 	strb.w	r3, [sp, #10]
    reply_event.data[reply_event.data_size++] = command;
   10512:	f8ad 306e 	strh.w	r3, [sp, #110]	; 0x6e
   10516:	f88d 500b 	strb.w	r5, [sp, #11]
    if( command == STATE_CMD ){
   1051a:	d14b      	bne.n	105b4 <process_set_requests+0x110>
        if( (dfu_data.state == DFU_IDLE_STATE && 
   1051c:	4b6e      	ldr	r3, [pc, #440]	; (106d8 <process_set_requests+0x234>)
   1051e:	4a6a      	ldr	r2, [pc, #424]	; (106c8 <process_set_requests+0x224>)
   10520:	f893 1244 	ldrb.w	r1, [r3, #580]	; 0x244
   10524:	2901      	cmp	r1, #1
   10526:	d12e      	bne.n	10586 <process_set_requests+0xe2>
   10528:	1ea1      	subs	r1, r4, #2
   1052a:	2901      	cmp	r1, #1
   1052c:	d82f      	bhi.n	1058e <process_set_requests+0xea>
            dfu_data.can_reboot = 0;
   1052e:	2100      	movs	r1, #0
            dfu_data.state = new_state;
   10530:	f883 4244 	strb.w	r4, [r3, #580]	; 0x244
            dfu_data.can_reboot = 0;
   10534:	f883 1246 	strb.w	r1, [r3, #582]	; 0x246
            LOG_INF("[State machine] Changed to %s", new_state == DFU_DOWNLOADING_STATE
   10538:	6813      	ldr	r3, [r2, #0]
   1053a:	f003 0307 	and.w	r3, r3, #7
   1053e:	2b02      	cmp	r3, #2
   10540:	d912      	bls.n	10568 <process_set_requests+0xc4>
   10542:	2303      	movs	r3, #3
   10544:	f04f 0200 	mov.w	r2, #0
   10548:	f363 0207 	bfi	r2, r3, #0, #8
   1054c:	495f      	ldr	r1, [pc, #380]	; (106cc <process_set_requests+0x228>)
   1054e:	4b60      	ldr	r3, [pc, #384]	; (106d0 <process_set_requests+0x22c>)
   10550:	4862      	ldr	r0, [pc, #392]	; (106dc <process_set_requests+0x238>)
   10552:	1a5b      	subs	r3, r3, r1
   10554:	08db      	lsrs	r3, r3, #3
   10556:	f363 128f 	bfi	r2, r3, #6, #10
   1055a:	4961      	ldr	r1, [pc, #388]	; (106e0 <process_set_requests+0x23c>)
   1055c:	4b61      	ldr	r3, [pc, #388]	; (106e4 <process_set_requests+0x240>)
   1055e:	2c03      	cmp	r4, #3
   10560:	bf08      	it	eq
   10562:	4619      	moveq	r1, r3
   10564:	f018 f9f6 	bl	28954 <log_1>
            reply_event.data[reply_event.data_size++] = new_state;
   10568:	f8bd 306e 	ldrh.w	r3, [sp, #110]	; 0x6e
            k_msgq_put(&msgq_send, &reply_event, K_NO_WAIT);
   1056c:	485e      	ldr	r0, [pc, #376]	; (106e8 <process_set_requests+0x244>)
            reply_event.data[reply_event.data_size++] = new_state;
   1056e:	1c5a      	adds	r2, r3, #1
   10570:	f8ad 206e 	strh.w	r2, [sp, #110]	; 0x6e
   10574:	aa1c      	add	r2, sp, #112	; 0x70
   10576:	4413      	add	r3, r2
            k_msgq_put(&msgq_send, &reply_event, K_NO_WAIT);
   10578:	a901      	add	r1, sp, #4
            reply_event.data[reply_event.data_size++] = new_state;
   1057a:	f803 4c66 	strb.w	r4, [r3, #-102]
            k_msgq_put(&msgq_send, &reply_event, K_NO_WAIT);
   1057e:	f017 fa01 	bl	27984 <k_msgq_put.constprop.6>
    int err = 0;
   10582:	2400      	movs	r4, #0
   10584:	e066      	b.n	10654 <process_set_requests+0x1b0>
            (new_state == DFU_DOWNLOADING_STATE || new_state == DFU_UPDATING_STATE)) || (dfu_data.state == DFU_UPDATING_STATE && new_state == DFU_UPDATING_STATE ) ){
   10586:	2902      	cmp	r1, #2
   10588:	d101      	bne.n	1058e <process_set_requests+0xea>
   1058a:	2c02      	cmp	r4, #2
   1058c:	d0cf      	beq.n	1052e <process_set_requests+0x8a>
            LOG_WRN("Unknown command type");
   1058e:	6813      	ldr	r3, [r2, #0]
   10590:	f013 0f06 	tst.w	r3, #6
   10594:	d0f5      	beq.n	10582 <process_set_requests+0xde>
   10596:	2302      	movs	r3, #2
   10598:	f04f 0100 	mov.w	r1, #0
   1059c:	f363 0107 	bfi	r1, r3, #0, #8
   105a0:	4a4a      	ldr	r2, [pc, #296]	; (106cc <process_set_requests+0x228>)
   105a2:	4b4b      	ldr	r3, [pc, #300]	; (106d0 <process_set_requests+0x22c>)
   105a4:	4851      	ldr	r0, [pc, #324]	; (106ec <process_set_requests+0x248>)
   105a6:	1a9b      	subs	r3, r3, r2
   105a8:	08db      	lsrs	r3, r3, #3
   105aa:	f363 118f 	bfi	r1, r3, #6, #10
        LOG_WRN("Unknown command");
   105ae:	f018 f9c4 	bl	2893a <log_0>
   105b2:	e7e6      	b.n	10582 <process_set_requests+0xde>
    } else if( command == REBOOT_CMD && (dfu_data.state == DFU_DOWNLOADED_STATE || dfu_data.state == DFU_IDLE_STATE || dfu_data.state == DFU_ERROR_STATE) ){
   105b4:	2d02      	cmp	r5, #2
   105b6:	d11f      	bne.n	105f8 <process_set_requests+0x154>
   105b8:	4b47      	ldr	r3, [pc, #284]	; (106d8 <process_set_requests+0x234>)
   105ba:	f893 3244 	ldrb.w	r3, [r3, #580]	; 0x244
   105be:	1f1a      	subs	r2, r3, #4
   105c0:	2a01      	cmp	r2, #1
   105c2:	d901      	bls.n	105c8 <process_set_requests+0x124>
   105c4:	2b01      	cmp	r3, #1
   105c6:	d16b      	bne.n	106a0 <process_set_requests+0x1fc>
        if( reboot_type == SYS_REBOOT_COLD || reboot_type == SYS_REBOOT_WARM ){
   105c8:	2c01      	cmp	r4, #1
   105ca:	d803      	bhi.n	105d4 <process_set_requests+0x130>
            sys_reboot(reboot_type);
   105cc:	4620      	mov	r0, r4
   105ce:	f003 f8af 	bl	13730 <sys_reboot>
   105d2:	e7d6      	b.n	10582 <process_set_requests+0xde>
            LOG_WRN("Unknown reboot type");
   105d4:	4b3c      	ldr	r3, [pc, #240]	; (106c8 <process_set_requests+0x224>)
   105d6:	681b      	ldr	r3, [r3, #0]
   105d8:	f013 0f06 	tst.w	r3, #6
   105dc:	d0d1      	beq.n	10582 <process_set_requests+0xde>
   105de:	2302      	movs	r3, #2
   105e0:	f04f 0100 	mov.w	r1, #0
   105e4:	f363 0107 	bfi	r1, r3, #0, #8
   105e8:	4a38      	ldr	r2, [pc, #224]	; (106cc <process_set_requests+0x228>)
   105ea:	4b39      	ldr	r3, [pc, #228]	; (106d0 <process_set_requests+0x22c>)
   105ec:	4840      	ldr	r0, [pc, #256]	; (106f0 <process_set_requests+0x24c>)
   105ee:	1a9b      	subs	r3, r3, r2
   105f0:	08db      	lsrs	r3, r3, #3
   105f2:	f363 118f 	bfi	r1, r3, #6, #10
   105f6:	e7da      	b.n	105ae <process_set_requests+0x10a>
    } else if( command == TEST_IMAGE_CMD && (dfu_data.state == DFU_IDLE_STATE || dfu_data.state == DFU_DOWNLOADED_STATE) ) {
   105f8:	2d04      	cmp	r5, #4
   105fa:	d131      	bne.n	10660 <process_set_requests+0x1bc>
   105fc:	4d36      	ldr	r5, [pc, #216]	; (106d8 <process_set_requests+0x234>)
   105fe:	f895 3244 	ldrb.w	r3, [r5, #580]	; 0x244
   10602:	2b01      	cmp	r3, #1
   10604:	d001      	beq.n	1060a <process_set_requests+0x166>
   10606:	2b04      	cmp	r3, #4
   10608:	d14a      	bne.n	106a0 <process_set_requests+0x1fc>
        if (dfu_data.immediate) {
   1060a:	f895 3247 	ldrb.w	r3, [r5, #583]	; 0x247
   1060e:	2b00      	cmp	r3, #0
   10610:	d0b7      	beq.n	10582 <process_set_requests+0xde>
            k_sleep(K_SECONDS(5));
   10612:	f241 3088 	movw	r0, #5000	; 0x1388
   10616:	f017 f9b3 	bl	27980 <k_sleep>
            if( err = dfu_swap_slots(permanent), err){
   1061a:	4620      	mov	r0, r4
   1061c:	f7ff fefe 	bl	1041c <dfu_swap_slots>
   10620:	4604      	mov	r4, r0
   10622:	2800      	cmp	r0, #0
   10624:	d0ad      	beq.n	10582 <process_set_requests+0xde>
                LOG_ERR("Test image error (%d)", err);
   10626:	4b28      	ldr	r3, [pc, #160]	; (106c8 <process_set_requests+0x224>)
   10628:	681b      	ldr	r3, [r3, #0]
   1062a:	075a      	lsls	r2, r3, #29
   1062c:	d00e      	beq.n	1064c <process_set_requests+0x1a8>
   1062e:	2301      	movs	r3, #1
   10630:	f04f 0200 	mov.w	r2, #0
   10634:	f363 0207 	bfi	r2, r3, #0, #8
   10638:	4924      	ldr	r1, [pc, #144]	; (106cc <process_set_requests+0x228>)
   1063a:	4b25      	ldr	r3, [pc, #148]	; (106d0 <process_set_requests+0x22c>)
   1063c:	1a5b      	subs	r3, r3, r1
   1063e:	08db      	lsrs	r3, r3, #3
   10640:	4601      	mov	r1, r0
   10642:	f363 128f 	bfi	r2, r3, #6, #10
   10646:	482b      	ldr	r0, [pc, #172]	; (106f4 <process_set_requests+0x250>)
   10648:	f018 f984 	bl	28954 <log_1>
                dfu_data.state  = DFU_ERROR_STATE;
   1064c:	f240 6305 	movw	r3, #1541	; 0x605
   10650:	f8a5 3244 	strh.w	r3, [r5, #580]	; 0x244
}
   10654:	4620      	mov	r0, r4
   10656:	b01d      	add	sp, #116	; 0x74
   10658:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   1065c:	b004      	add	sp, #16
   1065e:	4770      	bx	lr
    } else if( command == CONFIRM_IMAGE_CMD && dfu_data.state == DFU_IDLE_STATE ) {
   10660:	2d05      	cmp	r5, #5
   10662:	d11d      	bne.n	106a0 <process_set_requests+0x1fc>
   10664:	4b1c      	ldr	r3, [pc, #112]	; (106d8 <process_set_requests+0x234>)
   10666:	f893 3244 	ldrb.w	r3, [r3, #580]	; 0x244
   1066a:	2b01      	cmp	r3, #1
   1066c:	d118      	bne.n	106a0 <process_set_requests+0x1fc>
    return boot_write_img_confirmed();
   1066e:	f019 fc19 	bl	29ea4 <boot_write_img_confirmed>
        if( err = dfu_confirm_image(), err ){
   10672:	4604      	mov	r4, r0
   10674:	2800      	cmp	r0, #0
   10676:	d084      	beq.n	10582 <process_set_requests+0xde>
            LOG_ERR("Confirm image error (%d)", err);
   10678:	4b13      	ldr	r3, [pc, #76]	; (106c8 <process_set_requests+0x224>)
   1067a:	681b      	ldr	r3, [r3, #0]
   1067c:	075b      	lsls	r3, r3, #29
   1067e:	d0e9      	beq.n	10654 <process_set_requests+0x1b0>
   10680:	2301      	movs	r3, #1
   10682:	f04f 0200 	mov.w	r2, #0
   10686:	f363 0207 	bfi	r2, r3, #0, #8
   1068a:	4910      	ldr	r1, [pc, #64]	; (106cc <process_set_requests+0x228>)
   1068c:	4b10      	ldr	r3, [pc, #64]	; (106d0 <process_set_requests+0x22c>)
   1068e:	1a5b      	subs	r3, r3, r1
   10690:	08db      	lsrs	r3, r3, #3
   10692:	4601      	mov	r1, r0
   10694:	f363 128f 	bfi	r2, r3, #6, #10
   10698:	4817      	ldr	r0, [pc, #92]	; (106f8 <process_set_requests+0x254>)
   1069a:	f018 f95b 	bl	28954 <log_1>
   1069e:	e7d9      	b.n	10654 <process_set_requests+0x1b0>
        LOG_WRN("Unknown command");
   106a0:	4b09      	ldr	r3, [pc, #36]	; (106c8 <process_set_requests+0x224>)
   106a2:	681b      	ldr	r3, [r3, #0]
   106a4:	f013 0f06 	tst.w	r3, #6
   106a8:	f43f af6b 	beq.w	10582 <process_set_requests+0xde>
   106ac:	2302      	movs	r3, #2
   106ae:	f04f 0100 	mov.w	r1, #0
   106b2:	f363 0107 	bfi	r1, r3, #0, #8
   106b6:	4a05      	ldr	r2, [pc, #20]	; (106cc <process_set_requests+0x228>)
   106b8:	4b05      	ldr	r3, [pc, #20]	; (106d0 <process_set_requests+0x22c>)
   106ba:	4810      	ldr	r0, [pc, #64]	; (106fc <process_set_requests+0x258>)
   106bc:	1a9b      	subs	r3, r3, r2
   106be:	08db      	lsrs	r3, r3, #3
   106c0:	f363 118f 	bfi	r1, r3, #6, #10
   106c4:	e773      	b.n	105ae <process_set_requests+0x10a>
   106c6:	bf00      	nop
   106c8:	20010018 	.word	0x20010018
   106cc:	0002db28 	.word	0x0002db28
   106d0:	0002dc28 	.word	0x0002dc28
   106d4:	0002f01e 	.word	0x0002f01e
   106d8:	200000f4 	.word	0x200000f4
   106dc:	0002f135 	.word	0x0002f135
   106e0:	0002f122 	.word	0x0002f122
   106e4:	0002f0dc 	.word	0x0002f0dc
   106e8:	20010130 	.word	0x20010130
   106ec:	0002f153 	.word	0x0002f153
   106f0:	0002f168 	.word	0x0002f168
   106f4:	0002f17c 	.word	0x0002f17c
   106f8:	0002e888 	.word	0x0002e888
   106fc:	0002f192 	.word	0x0002f192

00010700 <process_replies>:
int process_replies(msgq_dfu_event event){
   10700:	b084      	sub	sp, #16
   10702:	b5f0      	push	{r4, r5, r6, r7, lr}
   10704:	b09f      	sub	sp, #124	; 0x7c
   10706:	ac24      	add	r4, sp, #144	; 0x90
   10708:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    enum dfu_cmd command = cast(enum dfu_cmd, event.data[offset++]);
   1070c:	f89d 4097 	ldrb.w	r4, [sp, #151]	; 0x97
    msgq_dfu_event reply_event = {
   10710:	2268      	movs	r2, #104	; 0x68
   10712:	2100      	movs	r1, #0
   10714:	a804      	add	r0, sp, #16
   10716:	f019 fec4 	bl	2a4a2 <memset>
   1071a:	2701      	movs	r7, #1
        .id_connection = event.id_connection,
   1071c:	f89d 2091 	ldrb.w	r2, [sp, #145]	; 0x91
    msgq_dfu_event reply_event = {
   10720:	f8bd 3092 	ldrh.w	r3, [sp, #146]	; 0x92
   10724:	f88d 700c 	strb.w	r7, [sp, #12]
    if( command >= number_of_commands ){
   10728:	2c05      	cmp	r4, #5
    msgq_dfu_event reply_event = {
   1072a:	f88d 200d 	strb.w	r2, [sp, #13]
   1072e:	f8ad 300e 	strh.w	r3, [sp, #14]
    if( command >= number_of_commands ){
   10732:	d915      	bls.n	10760 <process_replies+0x60>
        LOG_ERR("Commands with error (%d)", err);
   10734:	4bb9      	ldr	r3, [pc, #740]	; (10a1c <process_replies+0x31c>)
   10736:	681b      	ldr	r3, [r3, #0]
   10738:	0758      	lsls	r0, r3, #29
   1073a:	d00e      	beq.n	1075a <process_replies+0x5a>
   1073c:	49b8      	ldr	r1, [pc, #736]	; (10a20 <process_replies+0x320>)
   1073e:	4bb9      	ldr	r3, [pc, #740]	; (10a24 <process_replies+0x324>)
   10740:	48b9      	ldr	r0, [pc, #740]	; (10a28 <process_replies+0x328>)
   10742:	1a5b      	subs	r3, r3, r1
   10744:	f04f 0200 	mov.w	r2, #0
   10748:	f367 0207 	bfi	r2, r7, #0, #8
   1074c:	08db      	lsrs	r3, r3, #3
   1074e:	f363 128f 	bfi	r2, r3, #6, #10
   10752:	f06f 0115 	mvn.w	r1, #21
   10756:	f018 f8fd 	bl	28954 <log_1>
        err = -EINVAL;
   1075a:	f06f 0415 	mvn.w	r4, #21
   1075e:	e041      	b.n	107e4 <process_replies+0xe4>
    if( command == IMAGE_CHUNK_CMD && dfu_data.state == DFU_DOWNLOADING_STATE ){
   10760:	2c00      	cmp	r4, #0
   10762:	f040 80bf 	bne.w	108e4 <process_replies+0x1e4>
   10766:	4db1      	ldr	r5, [pc, #708]	; (10a2c <process_replies+0x32c>)
   10768:	f895 3244 	ldrb.w	r3, [r5, #580]	; 0x244
   1076c:	2b03      	cmp	r3, #3
   1076e:	462e      	mov	r6, r5
   10770:	f040 8140 	bne.w	109f4 <process_replies+0x2f4>
        if( event.id_connection != dfu_data.id_connection_update ) {
   10774:	f8d5 323c 	ldr.w	r3, [r5, #572]	; 0x23c
   10778:	429a      	cmp	r2, r3
   1077a:	d16b      	bne.n	10854 <process_replies+0x154>
        memcpy( &chunk_offset, event.data + offset, sizeof chunk_offset );
   1077c:	2204      	movs	r2, #4
   1077e:	a926      	add	r1, sp, #152	; 0x98
   10780:	a802      	add	r0, sp, #8
   10782:	f019 fe64 	bl	2a44e <memcpy>
        memcpy( &chunk_size, event.data + offset, sizeof chunk_size );
   10786:	2202      	movs	r2, #2
   10788:	a927      	add	r1, sp, #156	; 0x9c
   1078a:	f10d 0006 	add.w	r0, sp, #6
   1078e:	f019 fe5e 	bl	2a44e <memcpy>
        if( chunk_offset != dfu_data.offset_update ){
   10792:	f8d5 2240 	ldr.w	r2, [r5, #576]	; 0x240
   10796:	9b02      	ldr	r3, [sp, #8]
   10798:	429a      	cmp	r2, r3
   1079a:	d15b      	bne.n	10854 <process_replies+0x154>
        if( !chunk_size ){
   1079c:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   107a0:	2a00      	cmp	r2, #0
   107a2:	d159      	bne.n	10858 <process_replies+0x158>
            if( err = flash_img_buffered_write(&dfu_data.ctx, event.data + offset, chunk_size, true), err){
   107a4:	463b      	mov	r3, r7
   107a6:	f10d 019e 	add.w	r1, sp, #158	; 0x9e
   107aa:	f105 002c 	add.w	r0, r5, #44	; 0x2c
   107ae:	f019 fb8f 	bl	29ed0 <flash_img_buffered_write>
   107b2:	4b9a      	ldr	r3, [pc, #616]	; (10a1c <process_replies+0x31c>)
   107b4:	4604      	mov	r4, r0
   107b6:	b1d8      	cbz	r0, 107f0 <process_replies+0xf0>
                LOG_ERR("Reboot error (%d)", err);
   107b8:	681b      	ldr	r3, [r3, #0]
                dfu_data.state = DFU_ERROR_STATE;
   107ba:	f240 2205 	movw	r2, #517	; 0x205
                LOG_ERR("Reboot error (%d)", err);
   107be:	0759      	lsls	r1, r3, #29
                dfu_data.state = DFU_ERROR_STATE;
   107c0:	f8a5 2244 	strh.w	r2, [r5, #580]	; 0x244
                LOG_ERR("Reboot error (%d)", err);
   107c4:	d00e      	beq.n	107e4 <process_replies+0xe4>
   107c6:	2301      	movs	r3, #1
   107c8:	f04f 0200 	mov.w	r2, #0
   107cc:	f363 0207 	bfi	r2, r3, #0, #8
   107d0:	4993      	ldr	r1, [pc, #588]	; (10a20 <process_replies+0x320>)
   107d2:	4b94      	ldr	r3, [pc, #592]	; (10a24 <process_replies+0x324>)
   107d4:	1a5b      	subs	r3, r3, r1
   107d6:	08db      	lsrs	r3, r3, #3
   107d8:	4601      	mov	r1, r0
   107da:	f363 128f 	bfi	r2, r3, #6, #10
   107de:	4894      	ldr	r0, [pc, #592]	; (10a30 <process_replies+0x330>)
   107e0:	f018 f8b8 	bl	28954 <log_1>
}
   107e4:	4620      	mov	r0, r4
   107e6:	b01f      	add	sp, #124	; 0x7c
   107e8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   107ec:	b004      	add	sp, #16
   107ee:	4770      	bx	lr
            LOG_INF("[State machine] Changed to DFU_DOWNLOADED_STATE");
   107f0:	681b      	ldr	r3, [r3, #0]
   107f2:	f003 0307 	and.w	r3, r3, #7
   107f6:	2b02      	cmp	r3, #2
   107f8:	d90d      	bls.n	10816 <process_replies+0x116>
   107fa:	2303      	movs	r3, #3
   107fc:	f04f 0100 	mov.w	r1, #0
   10800:	f363 0107 	bfi	r1, r3, #0, #8
   10804:	4a86      	ldr	r2, [pc, #536]	; (10a20 <process_replies+0x320>)
   10806:	4b87      	ldr	r3, [pc, #540]	; (10a24 <process_replies+0x324>)
   10808:	488a      	ldr	r0, [pc, #552]	; (10a34 <process_replies+0x334>)
   1080a:	1a9b      	subs	r3, r3, r2
   1080c:	08db      	lsrs	r3, r3, #3
   1080e:	f363 118f 	bfi	r1, r3, #6, #10
   10812:	f018 f892 	bl	2893a <log_0>
            reply_event.data[ reply_event.data_size++ ] = STS_MSG;
   10816:	f8bd 3076 	ldrh.w	r3, [sp, #118]	; 0x76
   1081a:	aa1e      	add	r2, sp, #120	; 0x78
   1081c:	441a      	add	r2, r3
            dfu_data.can_reboot = 1;
   1081e:	2001      	movs	r0, #1
            reply_event.data[ reply_event.data_size++ ] = STS_MSG;
   10820:	2402      	movs	r4, #2
   10822:	f802 4c66 	strb.w	r4, [r2, #-102]
   10826:	181a      	adds	r2, r3, r0
            reply_event.data[ reply_event.data_size++ ] = STATE_CMD;
   10828:	ac1e      	add	r4, sp, #120	; 0x78
   1082a:	fa14 f282 	uxtah	r2, r4, r2
            dfu_data.state = DFU_DOWNLOADED_STATE;
   1082e:	2104      	movs	r1, #4
            reply_event.data[ reply_event.data_size++ ] = STATE_CMD;
   10830:	f802 0c66 	strb.w	r0, [r2, #-102]
            reply_event.data[ reply_event.data_size++ ] = dfu_data.state;
   10834:	1cda      	adds	r2, r3, #3
            reply_event.data[ reply_event.data_size++ ] = STATE_CMD;
   10836:	3302      	adds	r3, #2
            reply_event.data[ reply_event.data_size++ ] = dfu_data.state;
   10838:	fa14 f383 	uxtah	r3, r4, r3
            dfu_data.can_reboot = 1;
   1083c:	f886 0246 	strb.w	r0, [r6, #582]	; 0x246
            dfu_data.state = DFU_DOWNLOADED_STATE;
   10840:	f886 1244 	strb.w	r1, [r6, #580]	; 0x244
            reply_event.data[ reply_event.data_size++ ] = dfu_data.state;
   10844:	f8ad 2076 	strh.w	r2, [sp, #118]	; 0x76
   10848:	f803 1c66 	strb.w	r1, [r3, #-102]
            k_msgq_put(&msgq_send, &reply_event, K_NO_WAIT);
   1084c:	a903      	add	r1, sp, #12
   1084e:	487a      	ldr	r0, [pc, #488]	; (10a38 <process_replies+0x338>)
   10850:	f017 f898 	bl	27984 <k_msgq_put.constprop.6>
    int err = 0;
   10854:	2400      	movs	r4, #0
   10856:	e7c5      	b.n	107e4 <process_replies+0xe4>
            if (err = flash_img_buffered_write(&dfu_data.ctx, event.data + offset, chunk_size, false), err) {
   10858:	4623      	mov	r3, r4
   1085a:	f10d 019e 	add.w	r1, sp, #158	; 0x9e
   1085e:	f105 002c 	add.w	r0, r5, #44	; 0x2c
   10862:	f019 fb35 	bl	29ed0 <flash_img_buffered_write>
   10866:	4604      	mov	r4, r0
   10868:	b1b8      	cbz	r0, 1089a <process_replies+0x19a>
                LOG_ERR("Write error (%d)", err);
   1086a:	4b6c      	ldr	r3, [pc, #432]	; (10a1c <process_replies+0x31c>)
   1086c:	681b      	ldr	r3, [r3, #0]
   1086e:	075a      	lsls	r2, r3, #29
   10870:	d00e      	beq.n	10890 <process_replies+0x190>
   10872:	2301      	movs	r3, #1
   10874:	f04f 0200 	mov.w	r2, #0
   10878:	f363 0207 	bfi	r2, r3, #0, #8
   1087c:	4968      	ldr	r1, [pc, #416]	; (10a20 <process_replies+0x320>)
   1087e:	4b69      	ldr	r3, [pc, #420]	; (10a24 <process_replies+0x324>)
   10880:	1a5b      	subs	r3, r3, r1
   10882:	08db      	lsrs	r3, r3, #3
   10884:	4601      	mov	r1, r0
   10886:	f363 128f 	bfi	r2, r3, #6, #10
   1088a:	486c      	ldr	r0, [pc, #432]	; (10a3c <process_replies+0x33c>)
   1088c:	f018 f862 	bl	28954 <log_1>
                dfu_data.state  = DFU_ERROR_STATE;
   10890:	f240 2305 	movw	r3, #517	; 0x205
   10894:	f8a6 3244 	strh.w	r3, [r6, #580]	; 0x244
                goto err_process_replies;
   10898:	e7a4      	b.n	107e4 <process_replies+0xe4>
            dfu_data.offset_update += chunk_size;
   1089a:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   1089e:	f8d5 3240 	ldr.w	r3, [r5, #576]	; 0x240
   108a2:	4413      	add	r3, r2
   108a4:	f8c5 3240 	str.w	r3, [r5, #576]	; 0x240
            reply_event.data[ reply_event.data_size++ ] = GET_MSG;
   108a8:	f8bd 3076 	ldrh.w	r3, [sp, #118]	; 0x76
   108ac:	aa1e      	add	r2, sp, #120	; 0x78
   108ae:	441a      	add	r2, r3
            reply_event.data[ reply_event.data_size++ ] = IMAGE_CHUNK_CMD;
   108b0:	1c98      	adds	r0, r3, #2
            reply_event.data[ reply_event.data_size++ ] = GET_MSG;
   108b2:	f802 7c66 	strb.w	r7, [r2, #-102]
   108b6:	3301      	adds	r3, #1
            reply_event.data[ reply_event.data_size++ ] = IMAGE_CHUNK_CMD;
   108b8:	aa1e      	add	r2, sp, #120	; 0x78
   108ba:	fa12 f383 	uxtah	r3, r2, r3
   108be:	b280      	uxth	r0, r0
   108c0:	f803 4c66 	strb.w	r4, [r3, #-102]
            memcpy( reply_event.data + reply_event.data_size, &dfu_data.offset_update, sizeof dfu_data.offset_update );
   108c4:	f10d 0312 	add.w	r3, sp, #18
            reply_event.data[ reply_event.data_size++ ] = IMAGE_CHUNK_CMD;
   108c8:	f8ad 0076 	strh.w	r0, [sp, #118]	; 0x76
            memcpy( reply_event.data + reply_event.data_size, &dfu_data.offset_update, sizeof dfu_data.offset_update );
   108cc:	2204      	movs	r2, #4
   108ce:	4418      	add	r0, r3
   108d0:	f505 7110 	add.w	r1, r5, #576	; 0x240
   108d4:	f019 fdbb 	bl	2a44e <memcpy>
            reply_event.data_size += sizeof dfu_data.offset_update;
   108d8:	f8bd 3076 	ldrh.w	r3, [sp, #118]	; 0x76
   108dc:	3304      	adds	r3, #4
   108de:	f8ad 3076 	strh.w	r3, [sp, #118]	; 0x76
   108e2:	e7b3      	b.n	1084c <process_replies+0x14c>
    } else if ( command == STATE_CMD ){
   108e4:	2c01      	cmp	r4, #1
   108e6:	f040 8085 	bne.w	109f4 <process_replies+0x2f4>
        if( dfu_data.state == DFU_IDLE_STATE && state == DFU_UPDATING_STATE ){
   108ea:	4d50      	ldr	r5, [pc, #320]	; (10a2c <process_replies+0x32c>)
        enum dfu_state state = cast(enum dfu_state, event.data[offset++]);
   108ec:	f89d 3098 	ldrb.w	r3, [sp, #152]	; 0x98
        if( dfu_data.state == DFU_IDLE_STATE && state == DFU_UPDATING_STATE ){
   108f0:	f895 1244 	ldrb.w	r1, [r5, #580]	; 0x244
   108f4:	2901      	cmp	r1, #1
   108f6:	d15c      	bne.n	109b2 <process_replies+0x2b2>
   108f8:	2b02      	cmp	r3, #2
   108fa:	d166      	bne.n	109ca <process_replies+0x2ca>
            dfu_data.can_reboot = 0;
   108fc:	2300      	movs	r3, #0
   108fe:	f885 3246 	strb.w	r3, [r5, #582]	; 0x246
            dfu_data.id_connection_update = event.id_connection;
   10902:	f8c5 223c 	str.w	r2, [r5, #572]	; 0x23c
            if( err = init_write(), err ){
   10906:	f7ff f8c1 	bl	fa8c <init_write>
   1090a:	4b44      	ldr	r3, [pc, #272]	; (10a1c <process_replies+0x31c>)
   1090c:	4604      	mov	r4, r0
                LOG_ERR("Init write error (%d)", err);
   1090e:	681b      	ldr	r3, [r3, #0]
            if( err = init_write(), err ){
   10910:	b1a8      	cbz	r0, 1093e <process_replies+0x23e>
                LOG_ERR("Init write error (%d)", err);
   10912:	075b      	lsls	r3, r3, #29
   10914:	d00e      	beq.n	10934 <process_replies+0x234>
   10916:	2301      	movs	r3, #1
   10918:	f04f 0200 	mov.w	r2, #0
   1091c:	f363 0207 	bfi	r2, r3, #0, #8
   10920:	493f      	ldr	r1, [pc, #252]	; (10a20 <process_replies+0x320>)
   10922:	4b40      	ldr	r3, [pc, #256]	; (10a24 <process_replies+0x324>)
   10924:	1a5b      	subs	r3, r3, r1
   10926:	08db      	lsrs	r3, r3, #3
   10928:	4601      	mov	r1, r0
   1092a:	f363 128f 	bfi	r2, r3, #6, #10
   1092e:	4844      	ldr	r0, [pc, #272]	; (10a40 <process_replies+0x340>)
   10930:	f018 f810 	bl	28954 <log_1>
                dfu_data.state  = DFU_ERROR_STATE;
   10934:	f240 3305 	movw	r3, #773	; 0x305
   10938:	f8a5 3244 	strh.w	r3, [r5, #580]	; 0x244
                goto err_process_replies;
   1093c:	e752      	b.n	107e4 <process_replies+0xe4>
            LOG_INF("[State machine] Changed to DFU_DOWNLOADING_STATE");
   1093e:	f003 0307 	and.w	r3, r3, #7
   10942:	2b02      	cmp	r3, #2
   10944:	d90d      	bls.n	10962 <process_replies+0x262>
   10946:	2303      	movs	r3, #3
   10948:	f04f 0100 	mov.w	r1, #0
   1094c:	f363 0107 	bfi	r1, r3, #0, #8
   10950:	4a33      	ldr	r2, [pc, #204]	; (10a20 <process_replies+0x320>)
   10952:	4b34      	ldr	r3, [pc, #208]	; (10a24 <process_replies+0x324>)
   10954:	483b      	ldr	r0, [pc, #236]	; (10a44 <process_replies+0x344>)
   10956:	1a9b      	subs	r3, r3, r2
   10958:	08db      	lsrs	r3, r3, #3
   1095a:	f363 118f 	bfi	r1, r3, #6, #10
   1095e:	f017 ffec 	bl	2893a <log_0>
            dfu_data.state = DFU_DOWNLOADING_STATE;
   10962:	2303      	movs	r3, #3
   10964:	f885 3244 	strb.w	r3, [r5, #580]	; 0x244
            reply_event.data[ reply_event.data_size++ ] = GET_MSG;
   10968:	f8bd 3076 	ldrh.w	r3, [sp, #118]	; 0x76
   1096c:	a91e      	add	r1, sp, #120	; 0x78
   1096e:	4419      	add	r1, r3
   10970:	2001      	movs	r0, #1
   10972:	f801 0c66 	strb.w	r0, [r1, #-102]
            reply_event.data[ reply_event.data_size++ ] = IMAGE_CHUNK_CMD;
   10976:	a91e      	add	r1, sp, #120	; 0x78
   10978:	1c98      	adds	r0, r3, #2
            reply_event.data[ reply_event.data_size++ ] = GET_MSG;
   1097a:	3301      	adds	r3, #1
            reply_event.data[ reply_event.data_size++ ] = IMAGE_CHUNK_CMD;
   1097c:	fa11 f383 	uxtah	r3, r1, r3
            dfu_data.offset_update = 0;
   10980:	2200      	movs	r2, #0
            reply_event.data[ reply_event.data_size++ ] = IMAGE_CHUNK_CMD;
   10982:	f803 2c66 	strb.w	r2, [r3, #-102]
   10986:	b280      	uxth	r0, r0
            memcpy( reply_event.data + reply_event.data_size, &dfu_data.offset_update, sizeof dfu_data.offset_update );
   10988:	f10d 0312 	add.w	r3, sp, #18
            dfu_data.offset_update = 0;
   1098c:	f8c5 2240 	str.w	r2, [r5, #576]	; 0x240
            reply_event.data[ reply_event.data_size++ ] = IMAGE_CHUNK_CMD;
   10990:	f8ad 0076 	strh.w	r0, [sp, #118]	; 0x76
            memcpy( reply_event.data + reply_event.data_size, &dfu_data.offset_update, sizeof dfu_data.offset_update );
   10994:	2204      	movs	r2, #4
   10996:	492c      	ldr	r1, [pc, #176]	; (10a48 <process_replies+0x348>)
   10998:	4418      	add	r0, r3
   1099a:	f019 fd58 	bl	2a44e <memcpy>
            reply_event.data_size += sizeof dfu_data.offset_update;
   1099e:	f8bd 3076 	ldrh.w	r3, [sp, #118]	; 0x76
            k_msgq_put(&msgq_send, &reply_event, K_NO_WAIT);
   109a2:	4825      	ldr	r0, [pc, #148]	; (10a38 <process_replies+0x338>)
            reply_event.data_size += sizeof dfu_data.offset_update;
   109a4:	3304      	adds	r3, #4
            k_msgq_put(&msgq_send, &reply_event, K_NO_WAIT);
   109a6:	a903      	add	r1, sp, #12
            reply_event.data_size += sizeof dfu_data.offset_update;
   109a8:	f8ad 3076 	strh.w	r3, [sp, #118]	; 0x76
            k_msgq_put(&msgq_send, &reply_event, K_NO_WAIT);
   109ac:	f016 ffea 	bl	27984 <k_msgq_put.constprop.6>
   109b0:	e718      	b.n	107e4 <process_replies+0xe4>
        } else if( dfu_data.state == DFU_UPDATING_STATE && state == DFU_DOWNLOADED_STATE ){
   109b2:	2902      	cmp	r1, #2
   109b4:	d109      	bne.n	109ca <process_replies+0x2ca>
   109b6:	2b04      	cmp	r3, #4
   109b8:	d107      	bne.n	109ca <process_replies+0x2ca>
            reply_event.data[ reply_event.data_size++ ] = TEST_IMAGE_CMD;
   109ba:	f88d 3013 	strb.w	r3, [sp, #19]
            reply_event.data[ reply_event.data_size++ ] = SYS_REBOOT_COLD;
   109be:	2303      	movs	r3, #3
   109c0:	f8ad 3076 	strh.w	r3, [sp, #118]	; 0x76
   109c4:	f88d 4014 	strb.w	r4, [sp, #20]
            k_msgq_put(&msgq_send, &reply_event, K_NO_WAIT);
   109c8:	e740      	b.n	1084c <process_replies+0x14c>
            LOG_WRN("Not is valid command");
   109ca:	4b14      	ldr	r3, [pc, #80]	; (10a1c <process_replies+0x31c>)
   109cc:	681c      	ldr	r4, [r3, #0]
   109ce:	f014 0406 	ands.w	r4, r4, #6
   109d2:	f43f af07 	beq.w	107e4 <process_replies+0xe4>
   109d6:	2302      	movs	r3, #2
   109d8:	f04f 0100 	mov.w	r1, #0
   109dc:	f363 0107 	bfi	r1, r3, #0, #8
   109e0:	4a0f      	ldr	r2, [pc, #60]	; (10a20 <process_replies+0x320>)
   109e2:	4b10      	ldr	r3, [pc, #64]	; (10a24 <process_replies+0x324>)
   109e4:	4819      	ldr	r0, [pc, #100]	; (10a4c <process_replies+0x34c>)
   109e6:	1a9b      	subs	r3, r3, r2
   109e8:	08db      	lsrs	r3, r3, #3
   109ea:	f363 118f 	bfi	r1, r3, #6, #10
        LOG_WRN("Not is valid command type!");
   109ee:	f017 ffa4 	bl	2893a <log_0>
   109f2:	e72f      	b.n	10854 <process_replies+0x154>
   109f4:	4b09      	ldr	r3, [pc, #36]	; (10a1c <process_replies+0x31c>)
   109f6:	681c      	ldr	r4, [r3, #0]
   109f8:	f014 0406 	ands.w	r4, r4, #6
   109fc:	f43f aef2 	beq.w	107e4 <process_replies+0xe4>
   10a00:	2302      	movs	r3, #2
   10a02:	f04f 0100 	mov.w	r1, #0
   10a06:	f363 0107 	bfi	r1, r3, #0, #8
   10a0a:	4a05      	ldr	r2, [pc, #20]	; (10a20 <process_replies+0x320>)
   10a0c:	4b05      	ldr	r3, [pc, #20]	; (10a24 <process_replies+0x324>)
   10a0e:	4810      	ldr	r0, [pc, #64]	; (10a50 <process_replies+0x350>)
   10a10:	1a9b      	subs	r3, r3, r2
   10a12:	08db      	lsrs	r3, r3, #3
   10a14:	f363 118f 	bfi	r1, r3, #6, #10
   10a18:	e7e9      	b.n	109ee <process_replies+0x2ee>
   10a1a:	bf00      	nop
   10a1c:	20010018 	.word	0x20010018
   10a20:	0002db28 	.word	0x0002db28
   10a24:	0002dc28 	.word	0x0002dc28
   10a28:	0002f01e 	.word	0x0002f01e
   10a2c:	200000f4 	.word	0x200000f4
   10a30:	0002f058 	.word	0x0002f058
   10a34:	0002f06a 	.word	0x0002f06a
   10a38:	20010130 	.word	0x20010130
   10a3c:	0002f09a 	.word	0x0002f09a
   10a40:	0002f0ab 	.word	0x0002f0ab
   10a44:	0002f0c1 	.word	0x0002f0c1
   10a48:	20000334 	.word	0x20000334
   10a4c:	0002f0f2 	.word	0x0002f0f2
   10a50:	0002f107 	.word	0x0002f107

00010a54 <receive_channel>:
int receive_channel(struct device *dev){
   10a54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10a58:	4b47      	ldr	r3, [pc, #284]	; (10b78 <receive_channel+0x124>)
   10a5a:	4a48      	ldr	r2, [pc, #288]	; (10b7c <receive_channel+0x128>)
    LOG_INF("Thread receive channel");
   10a5c:	4d48      	ldr	r5, [pc, #288]	; (10b80 <receive_channel+0x12c>)
int receive_channel(struct device *dev){
   10a5e:	b09b      	sub	sp, #108	; 0x6c
   10a60:	1a9b      	subs	r3, r3, r2
   10a62:	f3c3 03c9 	ubfx	r3, r3, #3, #10
   10a66:	9318      	str	r3, [sp, #96]	; 0x60
    LOG_INF("Thread receive channel");
   10a68:	682b      	ldr	r3, [r5, #0]
   10a6a:	f003 0307 	and.w	r3, r3, #7
   10a6e:	2b02      	cmp	r3, #2
   10a70:	d90a      	bls.n	10a88 <receive_channel+0x34>
   10a72:	2303      	movs	r3, #3
   10a74:	f04f 0100 	mov.w	r1, #0
   10a78:	f363 0107 	bfi	r1, r3, #0, #8
   10a7c:	9b18      	ldr	r3, [sp, #96]	; 0x60
   10a7e:	4841      	ldr	r0, [pc, #260]	; (10b84 <receive_channel+0x130>)
   10a80:	f363 118f 	bfi	r1, r3, #6, #10
   10a84:	f017 ff59 	bl	2893a <log_0>
   10a88:	4c3f      	ldr	r4, [pc, #252]	; (10b88 <receive_channel+0x134>)
                process_get_requests(event);
   10a8a:	f104 0810 	add.w	r8, r4, #16
   10a8e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   10a92:	493d      	ldr	r1, [pc, #244]	; (10b88 <receive_channel+0x134>)
   10a94:	483d      	ldr	r0, [pc, #244]	; (10b8c <receive_channel+0x138>)
   10a96:	f015 ff3b 	bl	26910 <z_impl_k_msgq_get>
        switch (event.event)
   10a9a:	7823      	ldrb	r3, [r4, #0]
   10a9c:	2b01      	cmp	r3, #1
   10a9e:	d010      	beq.n	10ac2 <receive_channel+0x6e>
   10aa0:	2b03      	cmp	r3, #3
   10aa2:	d03a      	beq.n	10b1a <receive_channel+0xc6>
            LOG_WRN("Unknown event");
   10aa4:	682b      	ldr	r3, [r5, #0]
   10aa6:	f013 0f06 	tst.w	r3, #6
   10aaa:	d036      	beq.n	10b1a <receive_channel+0xc6>
   10aac:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
   10ab0:	f043 0302 	orr.w	r3, r3, #2
   10ab4:	f363 0707 	bfi	r7, r3, #0, #8
   10ab8:	9b18      	ldr	r3, [sp, #96]	; 0x60
   10aba:	f363 178f 	bfi	r7, r3, #6, #10
   10abe:	4639      	mov	r1, r7
   10ac0:	e013      	b.n	10aea <receive_channel+0x96>
            msg_type = cast(enum dfu_msg_type, event.data[0]);
   10ac2:	79a3      	ldrb	r3, [r4, #6]
            switch (msg_type)
   10ac4:	2b01      	cmp	r3, #1
   10ac6:	d02c      	beq.n	10b22 <receive_channel+0xce>
   10ac8:	b19b      	cbz	r3, 10af2 <receive_channel+0x9e>
   10aca:	2b02      	cmp	r3, #2
   10acc:	d03e      	beq.n	10b4c <receive_channel+0xf8>
                LOG_WRN("Unknown event");
   10ace:	682b      	ldr	r3, [r5, #0]
   10ad0:	f013 0f06 	tst.w	r3, #6
   10ad4:	d021      	beq.n	10b1a <receive_channel+0xc6>
   10ad6:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
   10ada:	f043 0302 	orr.w	r3, r3, #2
   10ade:	f363 0607 	bfi	r6, r3, #0, #8
   10ae2:	9b18      	ldr	r3, [sp, #96]	; 0x60
   10ae4:	f363 168f 	bfi	r6, r3, #6, #10
   10ae8:	4631      	mov	r1, r6
            LOG_WRN("Unknown event");
   10aea:	4829      	ldr	r0, [pc, #164]	; (10b90 <receive_channel+0x13c>)
   10aec:	f017 ff25 	bl	2893a <log_0>
   10af0:	e013      	b.n	10b1a <receive_channel+0xc6>
                process_set_requests(event);
   10af2:	6823      	ldr	r3, [r4, #0]
   10af4:	9319      	str	r3, [sp, #100]	; 0x64
   10af6:	225c      	movs	r2, #92	; 0x5c
   10af8:	4641      	mov	r1, r8
   10afa:	4668      	mov	r0, sp
   10afc:	f8d4 b004 	ldr.w	fp, [r4, #4]
   10b00:	f8d4 a008 	ldr.w	sl, [r4, #8]
   10b04:	f8d4 900c 	ldr.w	r9, [r4, #12]
   10b08:	f019 fca1 	bl	2a44e <memcpy>
   10b0c:	9b19      	ldr	r3, [sp, #100]	; 0x64
   10b0e:	4659      	mov	r1, fp
   10b10:	4618      	mov	r0, r3
   10b12:	4652      	mov	r2, sl
   10b14:	464b      	mov	r3, r9
   10b16:	f7ff fcc5 	bl	104a4 <process_set_requests>
        k_sleep(K_MSEC(10));
   10b1a:	200a      	movs	r0, #10
   10b1c:	f016 ff30 	bl	27980 <k_sleep>
        k_msgq_get(&msgq_receive, &event, K_FOREVER);
   10b20:	e7b5      	b.n	10a8e <receive_channel+0x3a>
                process_get_requests(event);
   10b22:	6823      	ldr	r3, [r4, #0]
   10b24:	9319      	str	r3, [sp, #100]	; 0x64
   10b26:	4641      	mov	r1, r8
   10b28:	225c      	movs	r2, #92	; 0x5c
   10b2a:	4668      	mov	r0, sp
   10b2c:	f8d4 b004 	ldr.w	fp, [r4, #4]
   10b30:	f8d4 a008 	ldr.w	sl, [r4, #8]
   10b34:	f8d4 900c 	ldr.w	r9, [r4, #12]
   10b38:	f019 fc89 	bl	2a44e <memcpy>
   10b3c:	9b19      	ldr	r3, [sp, #100]	; 0x64
   10b3e:	4659      	mov	r1, fp
   10b40:	4618      	mov	r0, r3
   10b42:	4652      	mov	r2, sl
   10b44:	464b      	mov	r3, r9
   10b46:	f7ff fb89 	bl	1025c <process_get_requests>
                break;
   10b4a:	e7e6      	b.n	10b1a <receive_channel+0xc6>
                process_replies(event);
   10b4c:	6823      	ldr	r3, [r4, #0]
   10b4e:	9319      	str	r3, [sp, #100]	; 0x64
   10b50:	4641      	mov	r1, r8
   10b52:	225c      	movs	r2, #92	; 0x5c
   10b54:	4668      	mov	r0, sp
   10b56:	f8d4 b004 	ldr.w	fp, [r4, #4]
   10b5a:	f8d4 a008 	ldr.w	sl, [r4, #8]
   10b5e:	f8d4 900c 	ldr.w	r9, [r4, #12]
   10b62:	f019 fc74 	bl	2a44e <memcpy>
   10b66:	9b19      	ldr	r3, [sp, #100]	; 0x64
   10b68:	4659      	mov	r1, fp
   10b6a:	4618      	mov	r0, r3
   10b6c:	4652      	mov	r2, sl
   10b6e:	464b      	mov	r3, r9
   10b70:	f7ff fdc6 	bl	10700 <process_replies>
                break;
   10b74:	e7d1      	b.n	10b1a <receive_channel+0xc6>
   10b76:	bf00      	nop
   10b78:	0002dc28 	.word	0x0002dc28
   10b7c:	0002db28 	.word	0x0002db28
   10b80:	20010018 	.word	0x20010018
   10b84:	0002f1d5 	.word	0x0002f1d5
   10b88:	20003c48 	.word	0x20003c48
   10b8c:	20010108 	.word	0x20010108
   10b90:	0002f1ec 	.word	0x0002f1ec

00010b94 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
   10b94:	680b      	ldr	r3, [r1, #0]
   10b96:	3301      	adds	r3, #1
   10b98:	600b      	str	r3, [r1, #0]
	return _char_out(c);
   10b9a:	4b01      	ldr	r3, [pc, #4]	; (10ba0 <char_out+0xc>)
   10b9c:	681b      	ldr	r3, [r3, #0]
   10b9e:	4718      	bx	r3
   10ba0:	2000f8cc 	.word	0x2000f8cc

00010ba4 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
   10ba4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10ba8:	b085      	sub	sp, #20
   10baa:	469b      	mov	fp, r3
   10bac:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   10bae:	f8df 9088 	ldr.w	r9, [pc, #136]	; 10c38 <_printk_dec_ulong+0x94>
   10bb2:	2c01      	cmp	r4, #1
   10bb4:	bfb8      	it	lt
   10bb6:	2401      	movlt	r4, #1
   10bb8:	2b01      	cmp	r3, #1
   10bba:	bf0c      	ite	eq
   10bbc:	2330      	moveq	r3, #48	; 0x30
   10bbe:	2320      	movne	r3, #32
   10bc0:	4616      	mov	r6, r2
   10bc2:	4682      	mov	sl, r0
   10bc4:	4688      	mov	r8, r1
   10bc6:	9302      	str	r3, [sp, #8]
   10bc8:	2501      	movs	r5, #1
   10bca:	270a      	movs	r7, #10
   10bcc:	2200      	movs	r2, #0
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 10) {
		if (found_largest_digit != 0 || remainder >= pos) {
   10bce:	fbb6 f3f9 	udiv	r3, r6, r9
   10bd2:	9301      	str	r3, [sp, #4]
   10bd4:	b90a      	cbnz	r2, 10bda <_printk_dec_ulong+0x36>
   10bd6:	45b1      	cmp	r9, r6
   10bd8:	d81d      	bhi.n	10c16 <_printk_dec_ulong+0x72>
			found_largest_digit = 1;
			out((int)(remainder / pos + 48), ctx);
   10bda:	9b01      	ldr	r3, [sp, #4]
   10bdc:	4641      	mov	r1, r8
   10bde:	f103 0030 	add.w	r0, r3, #48	; 0x30
   10be2:	47d0      	blx	sl
			digits++;
   10be4:	3501      	adds	r5, #1
			found_largest_digit = 1;
   10be6:	2201      	movs	r2, #1
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
		remainder %= pos;
   10be8:	9b01      	ldr	r3, [sp, #4]
		remaining--;
   10bea:	3f01      	subs	r7, #1
	while (pos >= 10) {
   10bec:	2f01      	cmp	r7, #1
		remainder %= pos;
   10bee:	fb09 6613 	mls	r6, r9, r3, r6
		pos /= 10;
   10bf2:	f04f 030a 	mov.w	r3, #10
   10bf6:	fbb9 f9f3 	udiv	r9, r9, r3
	while (pos >= 10) {
   10bfa:	d1e8      	bne.n	10bce <_printk_dec_ulong+0x2a>
	}
	out((int)(remainder + 48), ctx);
   10bfc:	4641      	mov	r1, r8
   10bfe:	f106 0030 	add.w	r0, r6, #48	; 0x30
   10c02:	47d0      	blx	sl

	if (padding == PAD_SPACE_AFTER) {
   10c04:	f1bb 0f03 	cmp.w	fp, #3
   10c08:	d102      	bne.n	10c10 <_printk_dec_ulong+0x6c>
		remaining = min_width - digits;
   10c0a:	1b64      	subs	r4, r4, r5
		while (remaining-- > 0) {
   10c0c:	2c00      	cmp	r4, #0
   10c0e:	dc0e      	bgt.n	10c2e <_printk_dec_ulong+0x8a>
			out(' ', ctx);
		}
	}
}
   10c10:	b005      	add	sp, #20
   10c12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (remaining <= min_width
   10c16:	42bc      	cmp	r4, r7
   10c18:	dbe6      	blt.n	10be8 <_printk_dec_ulong+0x44>
				&& padding < PAD_SPACE_AFTER) {
   10c1a:	f1bb 0f02 	cmp.w	fp, #2
   10c1e:	d8e3      	bhi.n	10be8 <_printk_dec_ulong+0x44>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
   10c20:	4641      	mov	r1, r8
   10c22:	9802      	ldr	r0, [sp, #8]
   10c24:	9203      	str	r2, [sp, #12]
			digits++;
   10c26:	3501      	adds	r5, #1
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
   10c28:	47d0      	blx	sl
			digits++;
   10c2a:	9a03      	ldr	r2, [sp, #12]
   10c2c:	e7dc      	b.n	10be8 <_printk_dec_ulong+0x44>
			out(' ', ctx);
   10c2e:	4641      	mov	r1, r8
   10c30:	2020      	movs	r0, #32
   10c32:	47d0      	blx	sl
   10c34:	3c01      	subs	r4, #1
   10c36:	e7e9      	b.n	10c0c <_printk_dec_ulong+0x68>
   10c38:	3b9aca00 	.word	0x3b9aca00

00010c3c <__printk_hook_install>:
	_char_out = fn;
   10c3c:	4b01      	ldr	r3, [pc, #4]	; (10c44 <__printk_hook_install+0x8>)
   10c3e:	6018      	str	r0, [r3, #0]
}
   10c40:	4770      	bx	lr
   10c42:	bf00      	nop
   10c44:	2000f8cc 	.word	0x2000f8cc

00010c48 <vprintk>:
{
   10c48:	b507      	push	{r0, r1, r2, lr}
	struct out_context ctx = { 0 };
   10c4a:	2300      	movs	r3, #0
   10c4c:	9301      	str	r3, [sp, #4]
	z_vprintk(char_out, &ctx, fmt, ap);
   10c4e:	4602      	mov	r2, r0
   10c50:	460b      	mov	r3, r1
   10c52:	4803      	ldr	r0, [pc, #12]	; (10c60 <vprintk+0x18>)
   10c54:	a901      	add	r1, sp, #4
   10c56:	f017 f905 	bl	27e64 <z_vprintk>
}
   10c5a:	b003      	add	sp, #12
   10c5c:	f85d fb04 	ldr.w	pc, [sp], #4
   10c60:	00010b95 	.word	0x00010b95

00010c64 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
   10c64:	b530      	push	{r4, r5, lr}
   10c66:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
   10c68:	e9cd 0101 	strd	r0, r1, [sp, #4]
{
   10c6c:	4604      	mov	r4, r0
	struct str_context ctx = { str, size, 0 };
   10c6e:	2500      	movs	r5, #0

	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
   10c70:	a901      	add	r1, sp, #4
   10c72:	4805      	ldr	r0, [pc, #20]	; (10c88 <vsnprintk+0x24>)
	struct str_context ctx = { str, size, 0 };
   10c74:	9503      	str	r5, [sp, #12]
	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
   10c76:	f017 f8f5 	bl	27e64 <z_vprintk>

	if (ctx.count < ctx.max) {
   10c7a:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
   10c7e:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
   10c80:	bfb8      	it	lt
   10c82:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
   10c84:	b005      	add	sp, #20
   10c86:	bd30      	pop	{r4, r5, pc}
   10c88:	00027e3f 	.word	0x00027e3f

00010c8c <tc_aes128_set_encrypt_key>:

#define subbyte(a, o)(sbox[((a) >> (o))&0xff] << (o))
#define subword(a)(subbyte(a, 24)|subbyte(a, 16)|subbyte(a, 8)|subbyte(a, 0))

int tc_aes128_set_encrypt_key(TCAesKeySched_t s, const uint8_t *k)
{
   10c8c:	b5f0      	push	{r4, r5, r6, r7, lr}
	const unsigned int rconst[11] = {
   10c8e:	4e28      	ldr	r6, [pc, #160]	; (10d30 <tc_aes128_set_encrypt_key+0xa4>)
{
   10c90:	4607      	mov	r7, r0
   10c92:	460c      	mov	r4, r1
	const unsigned int rconst[11] = {
   10c94:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
{
   10c96:	b08d      	sub	sp, #52	; 0x34
	const unsigned int rconst[11] = {
   10c98:	ad01      	add	r5, sp, #4
   10c9a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   10c9c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   10c9e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   10ca0:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
   10ca4:	e885 0007 	stmia.w	r5, {r0, r1, r2}
		0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000
	};
	unsigned int i;
	unsigned int t;

	if (s == (TCAesKeySched_t) 0) {
   10ca8:	2f00      	cmp	r7, #0
   10caa:	d03c      	beq.n	10d26 <tc_aes128_set_encrypt_key+0x9a>
		return TC_CRYPTO_FAIL;
	} else if (k == (const uint8_t *) 0) {
   10cac:	2c00      	cmp	r4, #0
   10cae:	d03c      	beq.n	10d2a <tc_aes128_set_encrypt_key+0x9e>
   10cb0:	1f38      	subs	r0, r7, #4
   10cb2:	4621      	mov	r1, r4
   10cb4:	4602      	mov	r2, r0
   10cb6:	3410      	adds	r4, #16
		return TC_CRYPTO_FAIL;
	}

	for (i = 0; i < Nk; ++i) {
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
   10cb8:	784b      	ldrb	r3, [r1, #1]
   10cba:	780d      	ldrb	r5, [r1, #0]
   10cbc:	041b      	lsls	r3, r3, #16
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
   10cbe:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
   10cc2:	78cd      	ldrb	r5, [r1, #3]
   10cc4:	432b      	orrs	r3, r5
   10cc6:	788d      	ldrb	r5, [r1, #2]
   10cc8:	3104      	adds	r1, #4
   10cca:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
	for (i = 0; i < Nk; ++i) {
   10cce:	428c      	cmp	r4, r1
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
   10cd0:	f842 3f04 	str.w	r3, [r2, #4]!
	for (i = 0; i < Nk; ++i) {
   10cd4:	d1f0      	bne.n	10cb8 <tc_aes128_set_encrypt_key+0x2c>
	}

	for (; i < (Nb * (Nr + 1)); ++i) {
		t = s->words[i-1];
		if ((i % Nk) == 0) {
			t = subword(rotword(t)) ^ rconst[i/Nk];
   10cd6:	4c17      	ldr	r4, [pc, #92]	; (10d34 <tc_aes128_set_encrypt_key+0xa8>)
   10cd8:	2104      	movs	r1, #4
		if ((i % Nk) == 0) {
   10cda:	078a      	lsls	r2, r1, #30
		t = s->words[i-1];
   10cdc:	6903      	ldr	r3, [r0, #16]
		if ((i % Nk) == 0) {
   10cde:	d118      	bne.n	10d12 <tc_aes128_set_encrypt_key+0x86>
	return (((a) >> 24)|((a) << 8));
   10ce0:	ea4f 6333 	mov.w	r3, r3, ror #24
			t = subword(rotword(t)) ^ rconst[i/Nk];
   10ce4:	0e1a      	lsrs	r2, r3, #24
   10ce6:	5ca5      	ldrb	r5, [r4, r2]
   10ce8:	b2da      	uxtb	r2, r3
   10cea:	5ca2      	ldrb	r2, [r4, r2]
   10cec:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
   10cf0:	f3c3 4507 	ubfx	r5, r3, #16, #8
   10cf4:	f3c3 2307 	ubfx	r3, r3, #8, #8
   10cf8:	5d65      	ldrb	r5, [r4, r5]
   10cfa:	5ce3      	ldrb	r3, [r4, r3]
   10cfc:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
   10d00:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
   10d04:	ad0c      	add	r5, sp, #48	; 0x30
   10d06:	f021 0303 	bic.w	r3, r1, #3
   10d0a:	442b      	add	r3, r5
   10d0c:	f853 3c2c 	ldr.w	r3, [r3, #-44]
   10d10:	4053      	eors	r3, r2
		}
		s->words[i] = s->words[i-Nk] ^ t;
   10d12:	f850 2f04 	ldr.w	r2, [r0, #4]!
	for (; i < (Nb * (Nr + 1)); ++i) {
   10d16:	3101      	adds	r1, #1
		s->words[i] = s->words[i-Nk] ^ t;
   10d18:	4053      	eors	r3, r2
	for (; i < (Nb * (Nr + 1)); ++i) {
   10d1a:	292c      	cmp	r1, #44	; 0x2c
		s->words[i] = s->words[i-Nk] ^ t;
   10d1c:	6103      	str	r3, [r0, #16]
	for (; i < (Nb * (Nr + 1)); ++i) {
   10d1e:	d1dc      	bne.n	10cda <tc_aes128_set_encrypt_key+0x4e>
	}

	return TC_CRYPTO_SUCCESS;
   10d20:	2001      	movs	r0, #1
}
   10d22:	b00d      	add	sp, #52	; 0x34
   10d24:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return TC_CRYPTO_FAIL;
   10d26:	4638      	mov	r0, r7
   10d28:	e7fb      	b.n	10d22 <tc_aes128_set_encrypt_key+0x96>
   10d2a:	4620      	mov	r0, r4
   10d2c:	e7f9      	b.n	10d22 <tc_aes128_set_encrypt_key+0x96>
   10d2e:	bf00      	nop
   10d30:	0002dce0 	.word	0x0002dce0
   10d34:	0002f349 	.word	0x0002f349

00010d38 <tc_aes_encrypt>:
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
	(void) _copy(s, sizeof(t), t, sizeof(t));
}

int tc_aes_encrypt(uint8_t *out, const uint8_t *in, const TCAesKeySched_t s)
{
   10d38:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   10d3c:	4615      	mov	r5, r2
   10d3e:	b089      	sub	sp, #36	; 0x24
	uint8_t state[Nk*Nb];
	unsigned int i;

	if (out == (uint8_t *) 0) {
   10d40:	4607      	mov	r7, r0
   10d42:	2800      	cmp	r0, #0
   10d44:	d059      	beq.n	10dfa <tc_aes_encrypt+0xc2>
		return TC_CRYPTO_FAIL;
	} else if (in == (const uint8_t *) 0) {
   10d46:	2900      	cmp	r1, #0
   10d48:	d05a      	beq.n	10e00 <tc_aes_encrypt+0xc8>
		return TC_CRYPTO_FAIL;
	} else if (s == (TCAesKeySched_t) 0) {
   10d4a:	2a00      	cmp	r2, #0
   10d4c:	d05a      	beq.n	10e04 <tc_aes_encrypt+0xcc>
		return TC_CRYPTO_FAIL;
	}

	(void)_copy(state, sizeof(state), in, sizeof(state));
   10d4e:	2310      	movs	r3, #16
   10d50:	460a      	mov	r2, r1
   10d52:	4668      	mov	r0, sp
   10d54:	4619      	mov	r1, r3
   10d56:	f017 fabf 	bl	282d8 <_copy>
	add_round_key(state, s->words);
   10d5a:	4629      	mov	r1, r5
   10d5c:	4668      	mov	r0, sp
		s[i] = sbox[s[i]];
   10d5e:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 10e08 <tc_aes_encrypt+0xd0>
	add_round_key(state, s->words);
   10d62:	f017 fad1 	bl	28308 <add_round_key>

	for (i = 0; i < (Nr - 1); ++i) {
   10d66:	f105 0610 	add.w	r6, r5, #16
   10d6a:	46c8      	mov	r8, r9
   10d6c:	35a0      	adds	r5, #160	; 0xa0
   10d6e:	466c      	mov	r4, sp
{
   10d70:	466a      	mov	r2, sp
   10d72:	2310      	movs	r3, #16
		s[i] = sbox[s[i]];
   10d74:	7811      	ldrb	r1, [r2, #0]
	for (i = 0; i < (Nb * Nk); ++i) {
   10d76:	3b01      	subs	r3, #1
		s[i] = sbox[s[i]];
   10d78:	f819 1001 	ldrb.w	r1, [r9, r1]
   10d7c:	f802 1b01 	strb.w	r1, [r2], #1
	for (i = 0; i < (Nb * Nk); ++i) {
   10d80:	d1f8      	bne.n	10d74 <tc_aes_encrypt+0x3c>
		sub_bytes(state);
		shift_rows(state);
   10d82:	4668      	mov	r0, sp
   10d84:	f017 fb05 	bl	28392 <shift_rows>
	mult_row_column(t, s);
   10d88:	4669      	mov	r1, sp
   10d8a:	a804      	add	r0, sp, #16
   10d8c:	f017 fb3a 	bl	28404 <mult_row_column>
	mult_row_column(&t[Nb], s+Nb);
   10d90:	a901      	add	r1, sp, #4
   10d92:	a805      	add	r0, sp, #20
   10d94:	f017 fb36 	bl	28404 <mult_row_column>
	mult_row_column(&t[2 * Nb], s + (2 * Nb));
   10d98:	a902      	add	r1, sp, #8
   10d9a:	a806      	add	r0, sp, #24
   10d9c:	f017 fb32 	bl	28404 <mult_row_column>
	mult_row_column(&t[3 * Nb], s + (3 * Nb));
   10da0:	a903      	add	r1, sp, #12
   10da2:	a807      	add	r0, sp, #28
   10da4:	f017 fb2e 	bl	28404 <mult_row_column>
	(void) _copy(s, sizeof(t), t, sizeof(t));
   10da8:	2310      	movs	r3, #16
   10daa:	4619      	mov	r1, r3
   10dac:	eb0d 0203 	add.w	r2, sp, r3
   10db0:	4668      	mov	r0, sp
   10db2:	f017 fa91 	bl	282d8 <_copy>
		mix_columns(state);
		add_round_key(state, s->words + Nb*(i+1));
   10db6:	4631      	mov	r1, r6
   10db8:	4668      	mov	r0, sp
   10dba:	3610      	adds	r6, #16
   10dbc:	f017 faa4 	bl	28308 <add_round_key>
	for (i = 0; i < (Nr - 1); ++i) {
   10dc0:	42ae      	cmp	r6, r5
   10dc2:	d1d4      	bne.n	10d6e <tc_aes_encrypt+0x36>
   10dc4:	2610      	movs	r6, #16
		s[i] = sbox[s[i]];
   10dc6:	7823      	ldrb	r3, [r4, #0]
	for (i = 0; i < (Nb * Nk); ++i) {
   10dc8:	3e01      	subs	r6, #1
		s[i] = sbox[s[i]];
   10dca:	f818 3003 	ldrb.w	r3, [r8, r3]
   10dce:	f804 3b01 	strb.w	r3, [r4], #1
	for (i = 0; i < (Nb * Nk); ++i) {
   10dd2:	d1f8      	bne.n	10dc6 <tc_aes_encrypt+0x8e>
	}

	sub_bytes(state);
	shift_rows(state);
   10dd4:	4668      	mov	r0, sp
   10dd6:	f017 fadc 	bl	28392 <shift_rows>
	add_round_key(state, s->words + Nb*(i+1));
   10dda:	4629      	mov	r1, r5
   10ddc:	4668      	mov	r0, sp
   10dde:	f017 fa93 	bl	28308 <add_round_key>

	(void)_copy(out, sizeof(state), state, sizeof(state));
   10de2:	2310      	movs	r3, #16
   10de4:	4619      	mov	r1, r3
   10de6:	466a      	mov	r2, sp
   10de8:	4638      	mov	r0, r7
   10dea:	f017 fa75 	bl	282d8 <_copy>

	/* zeroing out the state buffer */
	_set(state, TC_ZERO_BYTE, sizeof(state));
   10dee:	4668      	mov	r0, sp
   10df0:	2210      	movs	r2, #16
   10df2:	4631      	mov	r1, r6
   10df4:	f017 fa7d 	bl	282f2 <_set>

	return TC_CRYPTO_SUCCESS;
   10df8:	2001      	movs	r0, #1
}
   10dfa:	b009      	add	sp, #36	; 0x24
   10dfc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return TC_CRYPTO_FAIL;
   10e00:	4608      	mov	r0, r1
   10e02:	e7fa      	b.n	10dfa <tc_aes_encrypt+0xc2>
   10e04:	4610      	mov	r0, r2
   10e06:	e7f8      	b.n	10dfa <tc_aes_encrypt+0xc2>
   10e08:	0002f349 	.word	0x0002f349

00010e0c <enable_logger>:

K_THREAD_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(struct device *arg)
{
   10e0c:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
   10e0e:	2200      	movs	r2, #0
{
   10e10:	b087      	sub	sp, #28
		k_timer_init(&log_process_thread_timer,
   10e12:	490d      	ldr	r1, [pc, #52]	; (10e48 <enable_logger+0x3c>)
   10e14:	480d      	ldr	r0, [pc, #52]	; (10e4c <enable_logger+0x40>)
   10e16:	f01c fc0b 	bl	2d630 <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   10e1a:	4d0d      	ldr	r5, [pc, #52]	; (10e50 <enable_logger+0x44>)
   10e1c:	490d      	ldr	r1, [pc, #52]	; (10e54 <enable_logger+0x48>)
   10e1e:	2400      	movs	r4, #0
   10e20:	230e      	movs	r3, #14
   10e22:	e9cd 4302 	strd	r4, r3, [sp, #8]
   10e26:	e9cd 4404 	strd	r4, r4, [sp, #16]
   10e2a:	e9cd 4400 	strd	r4, r4, [sp]
   10e2e:	4b0a      	ldr	r3, [pc, #40]	; (10e58 <enable_logger+0x4c>)
   10e30:	f44f 7240 	mov.w	r2, #768	; 0x300
   10e34:	4628      	mov	r0, r5
   10e36:	f016 fa0b 	bl	27250 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
   10e3a:	4908      	ldr	r1, [pc, #32]	; (10e5c <enable_logger+0x50>)
   10e3c:	4628      	mov	r0, r5
   10e3e:	f01c faf6 	bl	2d42e <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
   10e42:	4620      	mov	r0, r4
   10e44:	b007      	add	sp, #28
   10e46:	bd30      	pop	{r4, r5, pc}
   10e48:	00010e61 	.word	0x00010e61
   10e4c:	2000055c 	.word	0x2000055c
   10e50:	200005a4 	.word	0x200005a4
   10e54:	20006010 	.word	0x20006010
   10e58:	000113f5 	.word	0x000113f5
   10e5c:	0002f7b3 	.word	0x0002f7b3

00010e60 <log_process_thread_timer_expiry_fn>:
	z_impl_k_sem_give(sem);
   10e60:	4801      	ldr	r0, [pc, #4]	; (10e68 <log_process_thread_timer_expiry_fn+0x8>)
   10e62:	f016 b951 	b.w	27108 <z_impl_k_sem_give>
   10e66:	bf00      	nop
   10e68:	200100a4 	.word	0x200100a4

00010e6c <log_core_init>:
{
   10e6c:	b538      	push	{r3, r4, r5, lr}
		log_msg_pool_init();
   10e6e:	f000 fb21 	bl	114b4 <log_msg_pool_init>
		log_list_init(&list);
   10e72:	4813      	ldr	r0, [pc, #76]	; (10ec0 <log_core_init+0x54>)
   10e74:	4c13      	ldr	r4, [pc, #76]	; (10ec4 <log_core_init+0x58>)
   10e76:	f017 fd38 	bl	288ea <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
   10e7a:	4913      	ldr	r1, [pc, #76]	; (10ec8 <log_core_init+0x5c>)
   10e7c:	4813      	ldr	r0, [pc, #76]	; (10ecc <log_core_init+0x60>)
   10e7e:	2304      	movs	r3, #4
   10e80:	2228      	movs	r2, #40	; 0x28
   10e82:	f01c f88e 	bl	2cfa2 <k_mem_slab_init>
		timestamp_func = k_cycle_get_32_wrapper;
   10e86:	4b12      	ldr	r3, [pc, #72]	; (10ed0 <log_core_init+0x64>)
   10e88:	4a12      	ldr	r2, [pc, #72]	; (10ed4 <log_core_init+0x68>)
   10e8a:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
   10e8c:	f44f 4000 	mov.w	r0, #32768	; 0x8000
   10e90:	f000 fd40 	bl	11914 <log_output_timestamp_freq_set>
   10e94:	4810      	ldr	r0, [pc, #64]	; (10ed8 <log_core_init+0x6c>)
   10e96:	4b11      	ldr	r3, [pc, #68]	; (10edc <log_core_init+0x70>)
   10e98:	1a1b      	subs	r3, r3, r0
   10e9a:	08db      	lsrs	r3, r3, #3
		for (int i = 0; i < log_sources_count(); i++) {
   10e9c:	2100      	movs	r1, #0
	return __log_const_start[source_id].level;
   10e9e:	3004      	adds	r0, #4
   10ea0:	4299      	cmp	r1, r3
   10ea2:	d100      	bne.n	10ea6 <log_core_init+0x3a>
}
   10ea4:	bd38      	pop	{r3, r4, r5, pc}
			LOG_FILTER_SLOT_SET(filters,
   10ea6:	f810 2031 	ldrb.w	r2, [r0, r1, lsl #3]
   10eaa:	6825      	ldr	r5, [r4, #0]
   10eac:	f002 0207 	and.w	r2, r2, #7
   10eb0:	f025 0507 	bic.w	r5, r5, #7
   10eb4:	432a      	orrs	r2, r5
   10eb6:	f844 2b04 	str.w	r2, [r4], #4
		for (int i = 0; i < log_sources_count(); i++) {
   10eba:	3101      	adds	r1, #1
   10ebc:	e7f0      	b.n	10ea0 <log_core_init+0x34>
   10ebe:	bf00      	nop
   10ec0:	20000554 	.word	0x20000554
   10ec4:	2000ff98 	.word	0x2000ff98
   10ec8:	20008e80 	.word	0x20008e80
   10ecc:	20000588 	.word	0x20000588
   10ed0:	2000f8d0 	.word	0x2000f8d0
   10ed4:	00028929 	.word	0x00028929
   10ed8:	0002db28 	.word	0x0002db28
   10edc:	0002dc80 	.word	0x0002dc80

00010ee0 <dropped_notify>:
{
   10ee0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   10ee2:	4b0f      	ldr	r3, [pc, #60]	; (10f20 <dropped_notify+0x40>)
   10ee4:	f3bf 8f5b 	dmb	ish
   10ee8:	2500      	movs	r5, #0
   10eea:	e853 7f00 	ldrex	r7, [r3]
   10eee:	e843 5200 	strex	r2, r5, [r3]
   10ef2:	2a00      	cmp	r2, #0
   10ef4:	d1f9      	bne.n	10eea <dropped_notify+0xa>
   10ef6:	f3bf 8f5b 	dmb	ish
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
   10efa:	4c0a      	ldr	r4, [pc, #40]	; (10f24 <dropped_notify+0x44>)
   10efc:	4e0a      	ldr	r6, [pc, #40]	; (10f28 <dropped_notify+0x48>)
   10efe:	1b36      	subs	r6, r6, r4
   10f00:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
   10f02:	42b5      	cmp	r5, r6
   10f04:	db00      	blt.n	10f08 <dropped_notify+0x28>
}
   10f06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
   10f08:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
   10f0a:	795b      	ldrb	r3, [r3, #5]
   10f0c:	b12b      	cbz	r3, 10f1a <dropped_notify+0x3a>
	if (backend->api->dropped != NULL) {
   10f0e:	6823      	ldr	r3, [r4, #0]
   10f10:	68db      	ldr	r3, [r3, #12]
   10f12:	b113      	cbz	r3, 10f1a <dropped_notify+0x3a>
		backend->api->dropped(backend, cnt);
   10f14:	4639      	mov	r1, r7
   10f16:	4620      	mov	r0, r4
   10f18:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
   10f1a:	3501      	adds	r5, #1
   10f1c:	3410      	adds	r4, #16
   10f1e:	e7f0      	b.n	10f02 <dropped_notify+0x22>
   10f20:	2000054c 	.word	0x2000054c
   10f24:	0002dc80 	.word	0x0002dc80
   10f28:	0002dc90 	.word	0x0002dc90

00010f2c <log_dropped>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   10f2c:	4b06      	ldr	r3, [pc, #24]	; (10f48 <log_dropped+0x1c>)
   10f2e:	f3bf 8f5b 	dmb	ish
   10f32:	e853 2f00 	ldrex	r2, [r3]
   10f36:	3201      	adds	r2, #1
   10f38:	e843 2100 	strex	r1, r2, [r3]
   10f3c:	2900      	cmp	r1, #0
   10f3e:	d1f8      	bne.n	10f32 <log_dropped+0x6>
   10f40:	f3bf 8f5b 	dmb	ish
}
   10f44:	4770      	bx	lr
   10f46:	bf00      	nop
   10f48:	2000054c 	.word	0x2000054c

00010f4c <log_source_name_get>:
	return ((u8_t *)data - (u8_t *)__log_const_start)/
   10f4c:	4a04      	ldr	r2, [pc, #16]	; (10f60 <log_source_name_get+0x14>)
   10f4e:	4b05      	ldr	r3, [pc, #20]	; (10f64 <log_source_name_get+0x18>)
   10f50:	1a9b      	subs	r3, r3, r2
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
   10f52:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
   10f56:	bf34      	ite	cc
   10f58:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
   10f5c:	2000      	movcs	r0, #0
}
   10f5e:	4770      	bx	lr
   10f60:	0002db28 	.word	0x0002db28
   10f64:	0002dc80 	.word	0x0002dc80

00010f68 <z_impl_log_filter_set>:
{
   10f68:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   10f6c:	4689      	mov	r9, r1
   10f6e:	4616      	mov	r6, r2
   10f70:	4698      	mov	r8, r3
		if (backend == NULL) {
   10f72:	b9b8      	cbnz	r0, 10fa4 <z_impl_log_filter_set+0x3c>
	return __log_backends_end - __log_backends_start;
   10f74:	4b21      	ldr	r3, [pc, #132]	; (10ffc <z_impl_log_filter_set+0x94>)
   10f76:	4f22      	ldr	r7, [pc, #136]	; (11000 <z_impl_log_filter_set+0x98>)
   10f78:	1aff      	subs	r7, r7, r3
   10f7a:	113f      	asrs	r7, r7, #4
			for (int i = 0; i < log_backend_count_get(); i++) {
   10f7c:	4604      	mov	r4, r0
			u32_t max = 0U;
   10f7e:	4605      	mov	r5, r0
   10f80:	469a      	mov	sl, r3
			for (int i = 0; i < log_backend_count_get(); i++) {
   10f82:	42bc      	cmp	r4, r7
   10f84:	db02      	blt.n	10f8c <z_impl_log_filter_set+0x24>
}
   10f86:	4628      	mov	r0, r5
   10f88:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (z_syscall_trap()) {
		return (u32_t) arch_syscall_invoke4(*(uintptr_t *)&backend, *(uintptr_t *)&domain_id, *(uintptr_t *)&src_id, *(uintptr_t *)&level, K_SYSCALL_LOG_FILTER_SET);
	}
#endif
	compiler_barrier();
	return z_impl_log_filter_set(backend, domain_id, src_id, level);
   10f8c:	eb0a 1004 	add.w	r0, sl, r4, lsl #4
   10f90:	4643      	mov	r3, r8
   10f92:	4632      	mov	r2, r6
   10f94:	4649      	mov	r1, r9
   10f96:	f7ff ffe7 	bl	10f68 <z_impl_log_filter_set>
				max = MAX(current, max);
   10f9a:	4285      	cmp	r5, r0
   10f9c:	bf38      	it	cc
   10f9e:	4605      	movcc	r5, r0
			for (int i = 0; i < log_backend_count_get(); i++) {
   10fa0:	3401      	adds	r4, #1
   10fa2:	e7ee      	b.n	10f82 <z_impl_log_filter_set+0x1a>
	return __log_const_start[source_id].level;
   10fa4:	4b17      	ldr	r3, [pc, #92]	; (11004 <z_impl_log_filter_set+0x9c>)
			LOG_FILTER_SLOT_SET(filters,
   10fa6:	4918      	ldr	r1, [pc, #96]	; (11008 <z_impl_log_filter_set+0xa0>)
   10fa8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
		return log_compiled_level_get(src_id);
   10fac:	791d      	ldrb	r5, [r3, #4]
	return backend->cb->id;
   10fae:	6843      	ldr	r3, [r0, #4]
			LOG_FILTER_SLOT_SET(filters,
   10fb0:	791a      	ldrb	r2, [r3, #4]
   10fb2:	2307      	movs	r3, #7
   10fb4:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   10fb8:	fa03 f002 	lsl.w	r0, r3, r2
			level = MIN(level, max);
   10fbc:	4545      	cmp	r5, r8
			LOG_FILTER_SLOT_SET(filters,
   10fbe:	f851 3026 	ldr.w	r3, [r1, r6, lsl #2]
			level = MIN(level, max);
   10fc2:	bf28      	it	cs
   10fc4:	4645      	movcs	r5, r8
			LOG_FILTER_SLOT_SET(filters,
   10fc6:	ea23 0300 	bic.w	r3, r3, r0
   10fca:	f005 0007 	and.w	r0, r5, #7
   10fce:	fa00 f202 	lsl.w	r2, r0, r2
   10fd2:	4313      	orrs	r3, r2
	u32_t max_filter = LOG_LEVEL_NONE;
   10fd4:	2000      	movs	r0, #0
			LOG_FILTER_SLOT_SET(filters,
   10fd6:	2203      	movs	r2, #3
		u32_t tmp_filter = LOG_FILTER_SLOT_GET(&filters, i);
   10fd8:	fa23 f402 	lsr.w	r4, r3, r2
   10fdc:	f004 0407 	and.w	r4, r4, #7
   10fe0:	42a0      	cmp	r0, r4
   10fe2:	f102 0203 	add.w	r2, r2, #3
   10fe6:	bf38      	it	cc
   10fe8:	4620      	movcc	r0, r4
	for (i = first_slot; i < LOG_FILTERS_NUM_OF_SLOTS; i++) {
   10fea:	2a1e      	cmp	r2, #30
   10fec:	d1f4      	bne.n	10fd8 <z_impl_log_filter_set+0x70>
			LOG_FILTER_SLOT_SET(filters,
   10fee:	f023 0307 	bic.w	r3, r3, #7
   10ff2:	4303      	orrs	r3, r0
   10ff4:	f841 3026 	str.w	r3, [r1, r6, lsl #2]
	return level;
   10ff8:	e7c5      	b.n	10f86 <z_impl_log_filter_set+0x1e>
   10ffa:	bf00      	nop
   10ffc:	0002dc80 	.word	0x0002dc80
   11000:	0002dc90 	.word	0x0002dc90
   11004:	0002db28 	.word	0x0002db28
   11008:	2000ff98 	.word	0x2000ff98

0001100c <backend_filter_set>:
{
   1100c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return ((u8_t *)data - (u8_t *)__log_const_start)/
   1100e:	4c09      	ldr	r4, [pc, #36]	; (11034 <backend_filter_set+0x28>)
   11010:	4b09      	ldr	r3, [pc, #36]	; (11038 <backend_filter_set+0x2c>)
   11012:	1ae4      	subs	r4, r4, r3
   11014:	4606      	mov	r6, r0
   11016:	460f      	mov	r7, r1
   11018:	08e4      	lsrs	r4, r4, #3
		for (int i = 0; i < log_sources_count(); i++) {
   1101a:	2500      	movs	r5, #0
   1101c:	42a5      	cmp	r5, r4
   1101e:	d100      	bne.n	11022 <backend_filter_set+0x16>
}
   11020:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   11022:	2100      	movs	r1, #0
   11024:	462a      	mov	r2, r5
   11026:	463b      	mov	r3, r7
   11028:	4630      	mov	r0, r6
   1102a:	f7ff ff9d 	bl	10f68 <z_impl_log_filter_set>
		for (int i = 0; i < log_sources_count(); i++) {
   1102e:	3501      	adds	r5, #1
   11030:	e7f4      	b.n	1101c <backend_filter_set+0x10>
   11032:	bf00      	nop
   11034:	0002dc80 	.word	0x0002dc80
   11038:	0002db28 	.word	0x0002db28

0001103c <log_backend_enable>:
{
   1103c:	b538      	push	{r3, r4, r5, lr}
	id += backend - log_backend_get(0);
   1103e:	4b0c      	ldr	r3, [pc, #48]	; (11070 <log_backend_enable+0x34>)
   11040:	1ac3      	subs	r3, r0, r3
{
   11042:	460d      	mov	r5, r1
	id += backend - log_backend_get(0);
   11044:	111b      	asrs	r3, r3, #4
	log_backend_id_set(backend, id);
   11046:	6841      	ldr	r1, [r0, #4]
{
   11048:	4604      	mov	r4, r0
	id += backend - log_backend_get(0);
   1104a:	3301      	adds	r3, #1
	log_backend_id_set(backend, id);
   1104c:	710b      	strb	r3, [r1, #4]
	backend_filter_set(backend, level);
   1104e:	4611      	mov	r1, r2
   11050:	f7ff ffdc 	bl	1100c <backend_filter_set>
	log_backend_activate(backend, ctx);
   11054:	6863      	ldr	r3, [r4, #4]
	if (!backend_attached) {
   11056:	4c07      	ldr	r4, [pc, #28]	; (11074 <log_backend_enable+0x38>)
	backend->cb->ctx = ctx;
   11058:	601d      	str	r5, [r3, #0]
	backend->cb->active = true;
   1105a:	2201      	movs	r2, #1
   1105c:	715a      	strb	r2, [r3, #5]
   1105e:	7822      	ldrb	r2, [r4, #0]
   11060:	b912      	cbnz	r2, 11068 <log_backend_enable+0x2c>
   11062:	4805      	ldr	r0, [pc, #20]	; (11078 <log_backend_enable+0x3c>)
   11064:	f016 f850 	bl	27108 <z_impl_k_sem_give>
	backend_attached = true;
   11068:	2301      	movs	r3, #1
   1106a:	7023      	strb	r3, [r4, #0]
}
   1106c:	bd38      	pop	{r3, r4, r5, pc}
   1106e:	bf00      	nop
   11070:	0002dc80 	.word	0x0002dc80
   11074:	20003cfa 	.word	0x20003cfa
   11078:	200100a4 	.word	0x200100a4

0001107c <log_init>:
{
   1107c:	b570      	push	{r4, r5, r6, lr}
   1107e:	4b11      	ldr	r3, [pc, #68]	; (110c4 <log_init+0x48>)
   11080:	f3bf 8f5b 	dmb	ish
   11084:	e853 5f00 	ldrex	r5, [r3]
   11088:	1c6a      	adds	r2, r5, #1
   1108a:	e843 2100 	strex	r1, r2, [r3]
   1108e:	2900      	cmp	r1, #0
   11090:	d1f8      	bne.n	11084 <log_init+0x8>
   11092:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&initialized) != 0) {
   11096:	b92d      	cbnz	r5, 110a4 <log_init+0x28>
	return __log_backends_end - __log_backends_start;
   11098:	4c0b      	ldr	r4, [pc, #44]	; (110c8 <log_init+0x4c>)
   1109a:	4e0c      	ldr	r6, [pc, #48]	; (110cc <log_init+0x50>)
   1109c:	1b36      	subs	r6, r6, r4
   1109e:	1136      	asrs	r6, r6, #4
	for (i = 0; i < log_backend_count_get(); i++) {
   110a0:	42b5      	cmp	r5, r6
   110a2:	db00      	blt.n	110a6 <log_init+0x2a>
}
   110a4:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
   110a6:	7b23      	ldrb	r3, [r4, #12]
   110a8:	b143      	cbz	r3, 110bc <log_init+0x40>
			if (backend->api->init != NULL) {
   110aa:	6823      	ldr	r3, [r4, #0]
   110ac:	695b      	ldr	r3, [r3, #20]
   110ae:	b103      	cbz	r3, 110b2 <log_init+0x36>
				backend->api->init();
   110b0:	4798      	blx	r3
			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
   110b2:	2204      	movs	r2, #4
   110b4:	2100      	movs	r1, #0
   110b6:	4620      	mov	r0, r4
   110b8:	f7ff ffc0 	bl	1103c <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
   110bc:	3501      	adds	r5, #1
   110be:	3410      	adds	r4, #16
   110c0:	e7ee      	b.n	110a0 <log_init+0x24>
   110c2:	bf00      	nop
   110c4:	20000550 	.word	0x20000550
   110c8:	0002dc80 	.word	0x0002dc80
   110cc:	0002dc90 	.word	0x0002dc90

000110d0 <log_filter_get>:
	if (IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) && runtime) {
   110d0:	b153      	cbz	r3, 110e8 <log_filter_get+0x18>
	return backend->cb->id;
   110d2:	6843      	ldr	r3, [r0, #4]
		return LOG_FILTER_SLOT_GET(filters,
   110d4:	4907      	ldr	r1, [pc, #28]	; (110f4 <log_filter_get+0x24>)
   110d6:	7918      	ldrb	r0, [r3, #4]
   110d8:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   110dc:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
   110e0:	40d8      	lsrs	r0, r3
   110e2:	f000 0007 	and.w	r0, r0, #7
   110e6:	4770      	bx	lr
	return __log_const_start[source_id].level;
   110e8:	4b03      	ldr	r3, [pc, #12]	; (110f8 <log_filter_get+0x28>)
   110ea:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
		return log_compiled_level_get(src_id);
   110ee:	7918      	ldrb	r0, [r3, #4]
}
   110f0:	4770      	bx	lr
   110f2:	bf00      	nop
   110f4:	2000ff98 	.word	0x2000ff98
   110f8:	0002db28 	.word	0x0002db28

000110fc <log_strdup>:
	return (((const char *)addr >= (const char *)RO_START) &&
   110fc:	4b16      	ldr	r3, [pc, #88]	; (11158 <log_strdup+0x5c>)
   110fe:	4298      	cmp	r0, r3
{
   11100:	b537      	push	{r0, r1, r2, r4, r5, lr}
   11102:	4604      	mov	r4, r0
	return (((const char *)addr >= (const char *)RO_START) &&
   11104:	d302      	bcc.n	1110c <log_strdup+0x10>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
   11106:	4b15      	ldr	r3, [pc, #84]	; (1115c <log_strdup+0x60>)
   11108:	4298      	cmp	r0, r3
   1110a:	d31f      	bcc.n	1114c <log_strdup+0x50>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
   1110c:	2200      	movs	r2, #0
   1110e:	a901      	add	r1, sp, #4
   11110:	4813      	ldr	r0, [pc, #76]	; (11160 <log_strdup+0x64>)
   11112:	f015 fabb 	bl	2668c <k_mem_slab_alloc>
	if (err != 0) {
   11116:	4605      	mov	r5, r0
   11118:	b9d8      	cbnz	r0, 11152 <log_strdup+0x56>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   1111a:	2201      	movs	r2, #1
   1111c:	9b01      	ldr	r3, [sp, #4]
   1111e:	f3bf 8f5b 	dmb	ish
   11122:	e853 1f00 	ldrex	r1, [r3]
   11126:	e843 2000 	strex	r0, r2, [r3]
   1112a:	2800      	cmp	r0, #0
   1112c:	d1f9      	bne.n	11122 <log_strdup+0x26>
   1112e:	f3bf 8f5b 	dmb	ish
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
   11132:	9801      	ldr	r0, [sp, #4]
   11134:	4621      	mov	r1, r4
   11136:	221f      	movs	r2, #31
   11138:	3004      	adds	r0, #4
   1113a:	f019 f91e 	bl	2a37a <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
   1113e:	9c01      	ldr	r4, [sp, #4]
   11140:	237e      	movs	r3, #126	; 0x7e
   11142:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	dup->buf[sizeof(dup->buf) - 1] = '\0';
   11146:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
	return dup->buf;
   1114a:	3404      	adds	r4, #4
}
   1114c:	4620      	mov	r0, r4
   1114e:	b003      	add	sp, #12
   11150:	bd30      	pop	{r4, r5, pc}
		return (char *)log_strdup_fail_msg;
   11152:	4c04      	ldr	r4, [pc, #16]	; (11164 <log_strdup+0x68>)
   11154:	e7fa      	b.n	1114c <log_strdup+0x50>
   11156:	bf00      	nop
   11158:	0002d8b4 	.word	0x0002d8b4
   1115c:	00032508 	.word	0x00032508
   11160:	20000588 	.word	0x20000588
   11164:	0002f449 	.word	0x0002f449

00011168 <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (u8_t *)buf);
   11168:	b148      	cbz	r0, 1117e <log_is_strdup+0x16>
   1116a:	4b05      	ldr	r3, [pc, #20]	; (11180 <log_is_strdup+0x18>)
   1116c:	4298      	cmp	r0, r3
   1116e:	d305      	bcc.n	1117c <log_is_strdup+0x14>
   11170:	33a0      	adds	r3, #160	; 0xa0
   11172:	4298      	cmp	r0, r3
   11174:	bf2c      	ite	cs
   11176:	2000      	movcs	r0, #0
   11178:	2001      	movcc	r0, #1
   1117a:	4770      	bx	lr
   1117c:	2000      	movs	r0, #0
}
   1117e:	4770      	bx	lr
   11180:	20008e80 	.word	0x20008e80

00011184 <z_impl_log_process>:
{
   11184:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!backend_attached && !bypass) {
   11188:	4b5d      	ldr	r3, [pc, #372]	; (11300 <z_impl_log_process+0x17c>)
   1118a:	781b      	ldrb	r3, [r3, #0]
{
   1118c:	4604      	mov	r4, r0
	if (!backend_attached && !bypass) {
   1118e:	b903      	cbnz	r3, 11192 <z_impl_log_process+0xe>
   11190:	b360      	cbz	r0, 111ec <z_impl_log_process+0x68>
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
   11192:	f04f 0320 	mov.w	r3, #32
   11196:	f3ef 8611 	mrs	r6, BASEPRI
   1119a:	f383 8811 	msr	BASEPRI, r3
   1119e:	f3bf 8f6f 	isb	sy
	msg = log_list_head_get(&list);
   111a2:	4858      	ldr	r0, [pc, #352]	; (11304 <z_impl_log_process+0x180>)
   111a4:	f017 fbb1 	bl	2890a <log_list_head_get>
   111a8:	4605      	mov	r5, r0
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
   111aa:	f386 8811 	msr	BASEPRI, r6
   111ae:	f3bf 8f6f 	isb	sy
	if (msg != NULL) {
   111b2:	b178      	cbz	r0, 111d4 <z_impl_log_process+0x50>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   111b4:	f3bf 8f5b 	dmb	ish
   111b8:	4b53      	ldr	r3, [pc, #332]	; (11308 <z_impl_log_process+0x184>)
   111ba:	e853 2f00 	ldrex	r2, [r3]
   111be:	3a01      	subs	r2, #1
   111c0:	e843 2100 	strex	r1, r2, [r3]
   111c4:	2900      	cmp	r1, #0
   111c6:	d1f8      	bne.n	111ba <z_impl_log_process+0x36>
   111c8:	f3bf 8f5b 	dmb	ish
	if (!bypass) {
   111cc:	b18c      	cbz	r4, 111f2 <z_impl_log_process+0x6e>
	log_msg_put(msg);
   111ce:	4628      	mov	r0, r5
   111d0:	f017 fc91 	bl	28af6 <log_msg_put>
	if (!bypass && dropped_cnt) {
   111d4:	b924      	cbnz	r4, 111e0 <z_impl_log_process+0x5c>
   111d6:	4b4d      	ldr	r3, [pc, #308]	; (1130c <z_impl_log_process+0x188>)
   111d8:	681b      	ldr	r3, [r3, #0]
   111da:	b10b      	cbz	r3, 111e0 <z_impl_log_process+0x5c>
		dropped_notify();
   111dc:	f7ff fe80 	bl	10ee0 <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
   111e0:	4848      	ldr	r0, [pc, #288]	; (11304 <z_impl_log_process+0x180>)
   111e2:	f017 fb90 	bl	28906 <log_list_head_peek>
   111e6:	1c04      	adds	r4, r0, #0
   111e8:	bf18      	it	ne
   111ea:	2401      	movne	r4, #1
}
   111ec:	4620      	mov	r0, r4
   111ee:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    !panic_mode) {
   111f2:	4b47      	ldr	r3, [pc, #284]	; (11310 <z_impl_log_process+0x18c>)
   111f4:	781b      	ldrb	r3, [r3, #0]
		if (IS_ENABLED(CONFIG_LOG_DETECT_MISSED_STRDUP) &&
   111f6:	b9db      	cbnz	r3, 11230 <z_impl_log_process+0xac>
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   111f8:	7a2b      	ldrb	r3, [r5, #8]
	if (!log_msg_is_std(msg)) {
   111fa:	07da      	lsls	r2, r3, #31
   111fc:	d418      	bmi.n	11230 <z_impl_log_process+0xac>
	msg_str = log_msg_str_get(msg);
   111fe:	f017 fc8d 	bl	28b1c <log_msg_str_get>
   11202:	4681      	mov	r9, r0
	mask = count_s(msg_str, log_msg_nargs_get(msg));
   11204:	4628      	mov	r0, r5
   11206:	f017 fc56 	bl	28ab6 <log_msg_nargs_get>
	u32_t mask = 0;
   1120a:	4626      	mov	r6, r4
	bool arm = false;
   1120c:	4622      	mov	r2, r4
	mask = count_s(msg_str, log_msg_nargs_get(msg));
   1120e:	46cc      	mov	ip, r9
	u32_t arg = 0;
   11210:	4623      	mov	r3, r4
				mask |= BIT(arg);
   11212:	f04f 0e01 	mov.w	lr, #1
	while ((curr = *str++) && arg < nargs) {
   11216:	f81c 1b01 	ldrb.w	r1, [ip], #1
   1121a:	b109      	cbz	r1, 11220 <z_impl_log_process+0x9c>
   1121c:	4298      	cmp	r0, r3
   1121e:	d810      	bhi.n	11242 <z_impl_log_process+0xbe>
	return ((u8_t *)data - (u8_t *)__log_const_start)/
   11220:	4b3c      	ldr	r3, [pc, #240]	; (11314 <z_impl_log_process+0x190>)
				LOG_ERR(ERR_MSG, idx, msg_str);
   11222:	4a3d      	ldr	r2, [pc, #244]	; (11318 <z_impl_log_process+0x194>)
   11224:	f8df b10c 	ldr.w	fp, [pc, #268]	; 11334 <z_impl_log_process+0x1b0>
   11228:	1a9b      	subs	r3, r3, r2
   1122a:	f3c3 0ac9 	ubfx	sl, r3, #3, #10
	while (mask) {
   1122e:	b9e6      	cbnz	r6, 1126a <z_impl_log_process+0xe6>
	return __log_backends_end - __log_backends_start;
   11230:	4e3a      	ldr	r6, [pc, #232]	; (1131c <z_impl_log_process+0x198>)
   11232:	4f3b      	ldr	r7, [pc, #236]	; (11320 <z_impl_log_process+0x19c>)
		return LOG_FILTER_SLOT_GET(filters,
   11234:	f8df 9100 	ldr.w	r9, [pc, #256]	; 11338 <z_impl_log_process+0x1b4>
   11238:	1bbf      	subs	r7, r7, r6
   1123a:	113f      	asrs	r7, r7, #4
   1123c:	f04f 0800 	mov.w	r8, #0
   11240:	e05b      	b.n	112fa <z_impl_log_process+0x176>
		if (curr == '%') {
   11242:	2925      	cmp	r1, #37	; 0x25
   11244:	d102      	bne.n	1124c <z_impl_log_process+0xc8>
			arm = !arm;
   11246:	f082 0201 	eor.w	r2, r2, #1
   1124a:	e7e4      	b.n	11216 <z_impl_log_process+0x92>
		} else if (arm && isalpha(curr)) {
   1124c:	2a00      	cmp	r2, #0
   1124e:	d0e2      	beq.n	11216 <z_impl_log_process+0x92>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
}

static inline int isalpha(int c)
{
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
   11250:	f041 0720 	orr.w	r7, r1, #32
   11254:	3f61      	subs	r7, #97	; 0x61
   11256:	2f19      	cmp	r7, #25
   11258:	d8dd      	bhi.n	11216 <z_impl_log_process+0x92>
			if (curr == 's') {
   1125a:	2973      	cmp	r1, #115	; 0x73
				mask |= BIT(arg);
   1125c:	bf04      	itt	eq
   1125e:	fa0e f203 	lsleq.w	r2, lr, r3
   11262:	4316      	orreq	r6, r2
			arg++;
   11264:	3301      	adds	r3, #1
			arm = false;
   11266:	2200      	movs	r2, #0
   11268:	e7d5      	b.n	11216 <z_impl_log_process+0x92>
		idx = 31 - __builtin_clz(mask);
   1126a:	fab6 f786 	clz	r7, r6
   1126e:	f1c7 071f 	rsb	r7, r7, #31
		str = (const char *)log_msg_arg_get(msg, idx);
   11272:	4639      	mov	r1, r7
   11274:	4628      	mov	r0, r5
   11276:	f017 fc21 	bl	28abc <log_msg_arg_get>
	return (((const char *)addr >= (const char *)RO_START) &&
   1127a:	4b2a      	ldr	r3, [pc, #168]	; (11324 <z_impl_log_process+0x1a0>)
   1127c:	4298      	cmp	r0, r3
		str = (const char *)log_msg_arg_get(msg, idx);
   1127e:	4602      	mov	r2, r0
	return (((const char *)addr >= (const char *)RO_START) &&
   11280:	d302      	bcc.n	11288 <z_impl_log_process+0x104>
		if (!is_rodata(str) && !log_is_strdup(str) &&
   11282:	4b29      	ldr	r3, [pc, #164]	; (11328 <z_impl_log_process+0x1a4>)
   11284:	4298      	cmp	r0, r3
   11286:	d318      	bcc.n	112ba <z_impl_log_process+0x136>
   11288:	4610      	mov	r0, r2
   1128a:	f7ff ff6d 	bl	11168 <log_is_strdup>
   1128e:	b9a0      	cbnz	r0, 112ba <z_impl_log_process+0x136>
   11290:	4b26      	ldr	r3, [pc, #152]	; (1132c <z_impl_log_process+0x1a8>)
   11292:	429a      	cmp	r2, r3
   11294:	d011      	beq.n	112ba <z_impl_log_process+0x136>
				LOG_ERR(ERR_MSG, idx, msg_str);
   11296:	f8db 3000 	ldr.w	r3, [fp]
   1129a:	075b      	lsls	r3, r3, #29
   1129c:	d00d      	beq.n	112ba <z_impl_log_process+0x136>
   1129e:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   112a2:	f043 0301 	orr.w	r3, r3, #1
   112a6:	f363 0807 	bfi	r8, r3, #0, #8
   112aa:	f36a 188f 	bfi	r8, sl, #6, #10
   112ae:	4643      	mov	r3, r8
   112b0:	464a      	mov	r2, r9
   112b2:	4639      	mov	r1, r7
   112b4:	481e      	ldr	r0, [pc, #120]	; (11330 <z_impl_log_process+0x1ac>)
   112b6:	f017 fb61 	bl	2897c <log_2>
		mask &= ~BIT(idx);
   112ba:	2301      	movs	r3, #1
   112bc:	fa03 f707 	lsl.w	r7, r3, r7
   112c0:	ea26 0607 	bic.w	r6, r6, r7
   112c4:	e7b3      	b.n	1122e <z_impl_log_process+0xaa>
			if (log_backend_is_active(backend) &&
   112c6:	6873      	ldr	r3, [r6, #4]
   112c8:	795a      	ldrb	r2, [r3, #5]
   112ca:	b19a      	cbz	r2, 112f4 <z_impl_log_process+0x170>
	return msg->hdr.ids.source_id;
   112cc:	8968      	ldrh	r0, [r5, #10]
		return LOG_FILTER_SLOT_GET(filters,
   112ce:	791b      	ldrb	r3, [r3, #4]
	return msg->hdr.ids.level;
   112d0:	7aa9      	ldrb	r1, [r5, #10]
	return msg->hdr.ids.source_id;
   112d2:	0980      	lsrs	r0, r0, #6
   112d4:	eb03 0243 	add.w	r2, r3, r3, lsl #1
   112d8:	f859 3020 	ldr.w	r3, [r9, r0, lsl #2]
   112dc:	40d3      	lsrs	r3, r2
	return msg->hdr.ids.level;
   112de:	f001 0107 	and.w	r1, r1, #7
   112e2:	f003 0307 	and.w	r3, r3, #7
			if (log_backend_is_active(backend) &&
   112e6:	4299      	cmp	r1, r3
   112e8:	d804      	bhi.n	112f4 <z_impl_log_process+0x170>
	backend->api->put(backend, msg);
   112ea:	6833      	ldr	r3, [r6, #0]
   112ec:	4629      	mov	r1, r5
   112ee:	681b      	ldr	r3, [r3, #0]
   112f0:	4630      	mov	r0, r6
   112f2:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
   112f4:	f108 0801 	add.w	r8, r8, #1
   112f8:	3610      	adds	r6, #16
   112fa:	45b8      	cmp	r8, r7
   112fc:	dbe3      	blt.n	112c6 <z_impl_log_process+0x142>
   112fe:	e766      	b.n	111ce <z_impl_log_process+0x4a>
   11300:	20003cfa 	.word	0x20003cfa
   11304:	20000554 	.word	0x20000554
   11308:	20000548 	.word	0x20000548
   1130c:	2000054c 	.word	0x2000054c
   11310:	20003cfb 	.word	0x20003cfb
   11314:	0002dc40 	.word	0x0002dc40
   11318:	0002db28 	.word	0x0002db28
   1131c:	0002dc80 	.word	0x0002dc80
   11320:	0002dc90 	.word	0x0002dc90
   11324:	0002d8b4 	.word	0x0002d8b4
   11328:	00032508 	.word	0x00032508
   1132c:	0002f449 	.word	0x0002f449
   11330:	0002f467 	.word	0x0002f467
   11334:	20010024 	.word	0x20010024
   11338:	2000ff98 	.word	0x2000ff98

0001133c <msg_finalize>:
	msg->hdr.timestamp = timestamp_func();
   1133c:	4b26      	ldr	r3, [pc, #152]	; (113d8 <msg_finalize+0x9c>)
{
   1133e:	b570      	push	{r4, r5, r6, lr}
	msg->hdr.timestamp = timestamp_func();
   11340:	681b      	ldr	r3, [r3, #0]
	msg->hdr.ids = src_level;
   11342:	8141      	strh	r1, [r0, #10]
{
   11344:	4605      	mov	r5, r0
	msg->hdr.timestamp = timestamp_func();
   11346:	4798      	blx	r3
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   11348:	4c24      	ldr	r4, [pc, #144]	; (113dc <msg_finalize+0xa0>)
   1134a:	60e8      	str	r0, [r5, #12]
   1134c:	f3bf 8f5b 	dmb	ish
   11350:	e854 3f00 	ldrex	r3, [r4]
   11354:	3301      	adds	r3, #1
   11356:	e844 3200 	strex	r2, r3, [r4]
   1135a:	2a00      	cmp	r2, #0
   1135c:	d1f8      	bne.n	11350 <msg_finalize+0x14>
   1135e:	f3bf 8f5b 	dmb	ish
	__asm__ volatile(
   11362:	f04f 0320 	mov.w	r3, #32
   11366:	f3ef 8611 	mrs	r6, BASEPRI
   1136a:	f383 8811 	msr	BASEPRI, r3
   1136e:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
   11372:	481b      	ldr	r0, [pc, #108]	; (113e0 <msg_finalize+0xa4>)
   11374:	4629      	mov	r1, r5
   11376:	f017 fabc 	bl	288f2 <log_list_add_tail>
	__asm__ volatile(
   1137a:	f386 8811 	msr	BASEPRI, r6
   1137e:	f3bf 8f6f 	isb	sy
	if (panic_mode) {
   11382:	4b18      	ldr	r3, [pc, #96]	; (113e4 <msg_finalize+0xa8>)
   11384:	781a      	ldrb	r2, [r3, #0]
   11386:	b17a      	cbz	r2, 113a8 <msg_finalize+0x6c>
	__asm__ volatile(
   11388:	f04f 0320 	mov.w	r3, #32
   1138c:	f3ef 8411 	mrs	r4, BASEPRI
   11390:	f383 8811 	msr	BASEPRI, r3
   11394:	f3bf 8f6f 	isb	sy
	return z_impl_log_process(bypass);
   11398:	2000      	movs	r0, #0
   1139a:	f7ff fef3 	bl	11184 <z_impl_log_process>
	__asm__ volatile(
   1139e:	f384 8811 	msr	BASEPRI, r4
   113a2:	f3bf 8f6f 	isb	sy
}
   113a6:	bd70      	pop	{r4, r5, r6, pc}
	} else if (proc_tid != NULL && buffered_cnt == 1) {
   113a8:	490f      	ldr	r1, [pc, #60]	; (113e8 <msg_finalize+0xac>)
   113aa:	6823      	ldr	r3, [r4, #0]
   113ac:	6809      	ldr	r1, [r1, #0]
   113ae:	2900      	cmp	r1, #0
   113b0:	d0f9      	beq.n	113a6 <msg_finalize+0x6a>
   113b2:	2b01      	cmp	r3, #1
   113b4:	d106      	bne.n	113c4 <msg_finalize+0x88>
	z_impl_k_timer_start(timer, duration, period);
   113b6:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   113ba:	480c      	ldr	r0, [pc, #48]	; (113ec <msg_finalize+0xb0>)
}
   113bc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   113c0:	f016 b9be 	b.w	27740 <z_impl_k_timer_start>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
   113c4:	2b0a      	cmp	r3, #10
   113c6:	d1ee      	bne.n	113a6 <msg_finalize+0x6a>
	z_impl_k_timer_stop(timer);
   113c8:	4808      	ldr	r0, [pc, #32]	; (113ec <msg_finalize+0xb0>)
   113ca:	f01c f93d 	bl	2d648 <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
   113ce:	4808      	ldr	r0, [pc, #32]	; (113f0 <msg_finalize+0xb4>)
}
   113d0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   113d4:	f015 be98 	b.w	27108 <z_impl_k_sem_give>
   113d8:	2000f8d0 	.word	0x2000f8d0
   113dc:	20000548 	.word	0x20000548
   113e0:	20000554 	.word	0x20000554
   113e4:	20003cfb 	.word	0x20003cfb
   113e8:	20000610 	.word	0x20000610
   113ec:	2000055c 	.word	0x2000055c
   113f0:	200100a4 	.word	0x200100a4

000113f4 <log_process_thread_func>:
{
   113f4:	b508      	push	{r3, lr}
	log_init();
   113f6:	f7ff fe41 	bl	1107c <log_init>
	return z_impl_k_current_get();
   113fa:	f015 fe7f 	bl	270fc <z_impl_k_current_get>
	proc_tid = process_tid;
   113fe:	4b0b      	ldr	r3, [pc, #44]	; (1142c <log_process_thread_func+0x38>)
   11400:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
   11402:	b130      	cbz	r0, 11412 <log_process_thread_func+0x1e>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
   11404:	4b0a      	ldr	r3, [pc, #40]	; (11430 <log_process_thread_func+0x3c>)
	    process_tid &&
   11406:	681b      	ldr	r3, [r3, #0]
   11408:	2b09      	cmp	r3, #9
   1140a:	dd02      	ble.n	11412 <log_process_thread_func+0x1e>
	z_impl_k_sem_give(sem);
   1140c:	4809      	ldr	r0, [pc, #36]	; (11434 <log_process_thread_func+0x40>)
   1140e:	f015 fe7b 	bl	27108 <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
   11412:	4c08      	ldr	r4, [pc, #32]	; (11434 <log_process_thread_func+0x40>)
   11414:	2000      	movs	r0, #0
   11416:	f7ff feb5 	bl	11184 <z_impl_log_process>
		if (log_process(false) == false) {
   1141a:	2800      	cmp	r0, #0
   1141c:	d1fa      	bne.n	11414 <log_process_thread_func+0x20>
   1141e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   11422:	4620      	mov	r0, r4
   11424:	f015 fe9c 	bl	27160 <z_impl_k_sem_take>
   11428:	e7f4      	b.n	11414 <log_process_thread_func+0x20>
   1142a:	bf00      	nop
   1142c:	20000610 	.word	0x20000610
   11430:	20000548 	.word	0x20000548
   11434:	200100a4 	.word	0x200100a4

00011438 <z_impl_log_panic>:
{
   11438:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
   1143a:	4f0e      	ldr	r7, [pc, #56]	; (11474 <z_impl_log_panic+0x3c>)
   1143c:	783d      	ldrb	r5, [r7, #0]
   1143e:	b975      	cbnz	r5, 1145e <z_impl_log_panic+0x26>
	return __log_backends_end - __log_backends_start;
   11440:	4c0d      	ldr	r4, [pc, #52]	; (11478 <z_impl_log_panic+0x40>)
   11442:	4e0e      	ldr	r6, [pc, #56]	; (1147c <z_impl_log_panic+0x44>)
	log_init();
   11444:	f7ff fe1a 	bl	1107c <log_init>
   11448:	1b36      	subs	r6, r6, r4
   1144a:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
   1144c:	42b5      	cmp	r5, r6
   1144e:	db07      	blt.n	11460 <z_impl_log_panic+0x28>
   11450:	2000      	movs	r0, #0
   11452:	f7ff fe97 	bl	11184 <z_impl_log_process>
		while (log_process(false) == true) {
   11456:	2800      	cmp	r0, #0
   11458:	d1fa      	bne.n	11450 <z_impl_log_panic+0x18>
	panic_mode = true;
   1145a:	2301      	movs	r3, #1
   1145c:	703b      	strb	r3, [r7, #0]
}
   1145e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return backend->cb->active;
   11460:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
   11462:	795b      	ldrb	r3, [r3, #5]
   11464:	b11b      	cbz	r3, 1146e <z_impl_log_panic+0x36>
	backend->api->panic(backend);
   11466:	6823      	ldr	r3, [r4, #0]
   11468:	4620      	mov	r0, r4
   1146a:	691b      	ldr	r3, [r3, #16]
   1146c:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
   1146e:	3501      	adds	r5, #1
   11470:	3410      	adds	r4, #16
   11472:	e7eb      	b.n	1144c <z_impl_log_panic+0x14>
   11474:	20003cfb 	.word	0x20003cfb
   11478:	0002dc80 	.word	0x0002dc80
   1147c:	0002dc90 	.word	0x0002dc90

00011480 <log_free>:
{
   11480:	b507      	push	{r0, r1, r2, lr}
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
   11482:	3804      	subs	r0, #4
   11484:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   11486:	f3bf 8f5b 	dmb	ish
   1148a:	e850 3f00 	ldrex	r3, [r0]
   1148e:	1e5a      	subs	r2, r3, #1
   11490:	e840 2100 	strex	r1, r2, [r0]
   11494:	2900      	cmp	r1, #0
   11496:	d1f8      	bne.n	1148a <log_free+0xa>
   11498:	f3bf 8f5b 	dmb	ish
	if (atomic_dec(&dup->refcount) == 1) {
   1149c:	2b01      	cmp	r3, #1
   1149e:	d103      	bne.n	114a8 <log_free+0x28>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
   114a0:	a901      	add	r1, sp, #4
   114a2:	4803      	ldr	r0, [pc, #12]	; (114b0 <log_free+0x30>)
   114a4:	f015 f91e 	bl	266e4 <k_mem_slab_free>
}
   114a8:	b003      	add	sp, #12
   114aa:	f85d fb04 	ldr.w	pc, [sp], #4
   114ae:	bf00      	nop
   114b0:	20000588 	.word	0x20000588

000114b4 <log_msg_pool_init>:
static u8_t __noinit __aligned(sizeof(void *))
		log_msg_pool_buf[CONFIG_LOG_BUFFER_SIZE];

void log_msg_pool_init(void)
{
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
   114b4:	2320      	movs	r3, #32
   114b6:	461a      	mov	r2, r3
   114b8:	4901      	ldr	r1, [pc, #4]	; (114c0 <log_msg_pool_init+0xc>)
   114ba:	4802      	ldr	r0, [pc, #8]	; (114c4 <log_msg_pool_init+0x10>)
   114bc:	f01b bd71 	b.w	2cfa2 <k_mem_slab_init>
   114c0:	20008f20 	.word	0x20008f20
   114c4:	20000614 	.word	0x20000614

000114c8 <log_msg_no_space_handle>:

	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
   114c8:	b537      	push	{r0, r1, r2, r4, r5, lr}
	union log_msg_chunk *msg = NULL;
   114ca:	2300      	movs	r3, #0

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			log_dropped();
			err = k_mem_slab_alloc(&log_msg_pool,
   114cc:	4d09      	ldr	r5, [pc, #36]	; (114f4 <log_msg_no_space_handle+0x2c>)
	union log_msg_chunk *msg = NULL;
   114ce:	9301      	str	r3, [sp, #4]
   114d0:	2001      	movs	r0, #1
   114d2:	f7ff fe57 	bl	11184 <z_impl_log_process>
   114d6:	4604      	mov	r4, r0
			log_dropped();
   114d8:	f7ff fd28 	bl	10f2c <log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
   114dc:	2200      	movs	r2, #0
   114de:	a901      	add	r1, sp, #4
   114e0:	4628      	mov	r0, r5
   114e2:	f015 f8d3 	bl	2668c <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
   114e6:	b108      	cbz	r0, 114ec <log_msg_no_space_handle+0x24>
   114e8:	2c00      	cmp	r4, #0
   114ea:	d1f1      	bne.n	114d0 <log_msg_no_space_handle+0x8>
	} else {
		log_dropped();
	}
	return msg;

}
   114ec:	9801      	ldr	r0, [sp, #4]
   114ee:	b003      	add	sp, #12
   114f0:	bd30      	pop	{r4, r5, pc}
   114f2:	bf00      	nop
   114f4:	20000614 	.word	0x20000614

000114f8 <log_msg_chunk_alloc>:
{
   114f8:	b507      	push	{r0, r1, r2, lr}
	union log_msg_chunk *msg = NULL;
   114fa:	2200      	movs	r2, #0
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
   114fc:	a901      	add	r1, sp, #4
   114fe:	4806      	ldr	r0, [pc, #24]	; (11518 <log_msg_chunk_alloc+0x20>)
	union log_msg_chunk *msg = NULL;
   11500:	9201      	str	r2, [sp, #4]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
   11502:	f015 f8c3 	bl	2668c <k_mem_slab_alloc>
	if (err != 0) {
   11506:	b110      	cbz	r0, 1150e <log_msg_chunk_alloc+0x16>
		msg = log_msg_no_space_handle();
   11508:	f7ff ffde 	bl	114c8 <log_msg_no_space_handle>
   1150c:	9001      	str	r0, [sp, #4]
}
   1150e:	9801      	ldr	r0, [sp, #4]
   11510:	b003      	add	sp, #12
   11512:	f85d fb04 	ldr.w	pc, [sp], #4
   11516:	bf00      	nop
   11518:	20000614 	.word	0x20000614

0001151c <msg_free>:
{
   1151c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   1151e:	7a04      	ldrb	r4, [r0, #8]
	u32_t nargs = msg->hdr.params.std.nargs;
   11520:	7a45      	ldrb	r5, [r0, #9]
{
   11522:	9001      	str	r0, [sp, #4]
	if (log_msg_is_std(msg) && nargs) {
   11524:	f014 0401 	ands.w	r4, r4, #1
	u32_t nargs = msg->hdr.params.std.nargs;
   11528:	ea4f 1515 	mov.w	r5, r5, lsr #4
	if (log_msg_is_std(msg) && nargs) {
   1152c:	d00e      	beq.n	1154c <msg_free+0x30>
	if (msg->hdr.params.generic.ext == 1) {
   1152e:	9b01      	ldr	r3, [sp, #4]
   11530:	7a1a      	ldrb	r2, [r3, #8]
   11532:	0792      	lsls	r2, r2, #30
   11534:	d504      	bpl.n	11540 <msg_free+0x24>
		cont_free(msg->payload.ext.next);
   11536:	695b      	ldr	r3, [r3, #20]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
   11538:	4c10      	ldr	r4, [pc, #64]	; (1157c <msg_free+0x60>)
   1153a:	9303      	str	r3, [sp, #12]
	while (cont != NULL) {
   1153c:	9b03      	ldr	r3, [sp, #12]
   1153e:	b9b3      	cbnz	r3, 1156e <msg_free+0x52>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
   11540:	a901      	add	r1, sp, #4
   11542:	480e      	ldr	r0, [pc, #56]	; (1157c <msg_free+0x60>)
   11544:	f015 f8ce 	bl	266e4 <k_mem_slab_free>
}
   11548:	b004      	add	sp, #16
   1154a:	bd70      	pop	{r4, r5, r6, pc}
	if (log_msg_is_std(msg) && nargs) {
   1154c:	2d00      	cmp	r5, #0
   1154e:	d0ee      	beq.n	1152e <msg_free+0x12>
		for (i = 0; i < nargs; i++) {
   11550:	42a5      	cmp	r5, r4
   11552:	9801      	ldr	r0, [sp, #4]
   11554:	d9eb      	bls.n	1152e <msg_free+0x12>
			void *buf = (void *)log_msg_arg_get(msg, i);
   11556:	4621      	mov	r1, r4
   11558:	f017 fab0 	bl	28abc <log_msg_arg_get>
   1155c:	4606      	mov	r6, r0
			if (log_is_strdup(buf)) {
   1155e:	f7ff fe03 	bl	11168 <log_is_strdup>
   11562:	b110      	cbz	r0, 1156a <msg_free+0x4e>
				log_free(buf);
   11564:	4630      	mov	r0, r6
   11566:	f7ff ff8b 	bl	11480 <log_free>
		for (i = 0; i < nargs; i++) {
   1156a:	3401      	adds	r4, #1
   1156c:	e7f0      	b.n	11550 <msg_free+0x34>
		next = cont->next;
   1156e:	681d      	ldr	r5, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
   11570:	a903      	add	r1, sp, #12
   11572:	4620      	mov	r0, r4
   11574:	f015 f8b6 	bl	266e4 <k_mem_slab_free>
		cont = next;
   11578:	9503      	str	r5, [sp, #12]
   1157a:	e7df      	b.n	1153c <msg_free+0x20>
   1157c:	20000614 	.word	0x20000614

00011580 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *log_output,
			   const char *fmt, ...)
{
   11580:	b40e      	push	{r1, r2, r3}
   11582:	b503      	push	{r0, r1, lr}
   11584:	ab03      	add	r3, sp, #12
	va_start(args, fmt);
#if !defined(CONFIG_NEWLIB_LIBC) && !defined(CONFIG_ARCH_POSIX) && \
    defined(CONFIG_LOG_ENABLE_FANCY_OUTPUT_FORMATTING)
	length = z_prf(out_func, (void *)log_output, (char *)fmt, args);
#else
	z_vprintk(out_func, (void *)log_output, fmt, args);
   11586:	4601      	mov	r1, r0
{
   11588:	f853 2b04 	ldr.w	r2, [r3], #4
	z_vprintk(out_func, (void *)log_output, fmt, args);
   1158c:	4804      	ldr	r0, [pc, #16]	; (115a0 <print_formatted+0x20>)
	va_start(args, fmt);
   1158e:	9301      	str	r3, [sp, #4]
	z_vprintk(out_func, (void *)log_output, fmt, args);
   11590:	f016 fc68 	bl	27e64 <z_vprintk>
#endif
	va_end(args);

	return length;
}
   11594:	2000      	movs	r0, #0
   11596:	b002      	add	sp, #8
   11598:	f85d eb04 	ldr.w	lr, [sp], #4
   1159c:	b003      	add	sp, #12
   1159e:	4770      	bx	lr
   115a0:	00028ec5 	.word	0x00028ec5

000115a4 <prefix_print>:
}

static u32_t prefix_print(const struct log_output *log_output,
			 u32_t flags, bool func_on, u32_t timestamp, u8_t level,
			 u8_t domain_id, u16_t source_id)
{
   115a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   115a8:	b085      	sub	sp, #20
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (stamp) {
   115aa:	f011 0402 	ands.w	r4, r1, #2
{
   115ae:	4606      	mov	r6, r0
   115b0:	4690      	mov	r8, r2
   115b2:	f89d 7038 	ldrb.w	r7, [sp, #56]	; 0x38
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
   115b6:	f001 0901 	and.w	r9, r1, #1
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
   115ba:	f001 0508 	and.w	r5, r1, #8
	if (stamp) {
   115be:	d007      	beq.n	115d0 <prefix_print+0x2c>
	if (!format) {
   115c0:	f011 0f44 	tst.w	r1, #68	; 0x44
   115c4:	d137      	bne.n	11636 <prefix_print+0x92>
		length = print_formatted(log_output, "[%08lu] ", timestamp);
   115c6:	461a      	mov	r2, r3
   115c8:	4932      	ldr	r1, [pc, #200]	; (11694 <prefix_print+0xf0>)
   115ca:	f7ff ffd9 	bl	11580 <print_formatted>
		length += timestamp_print(log_output, flags, timestamp);
   115ce:	4604      	mov	r4, r0
	if (color) {
   115d0:	f1b9 0f00 	cmp.w	r9, #0
   115d4:	d00a      	beq.n	115ec <prefix_print+0x48>
		const char *color = start && (colors[level] != NULL) ?
   115d6:	4b30      	ldr	r3, [pc, #192]	; (11698 <prefix_print+0xf4>)
		print_formatted(log_output, "%s", color);
   115d8:	4930      	ldr	r1, [pc, #192]	; (1169c <prefix_print+0xf8>)
		const char *color = start && (colors[level] != NULL) ?
   115da:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
		print_formatted(log_output, "%s", color);
   115de:	4b30      	ldr	r3, [pc, #192]	; (116a0 <prefix_print+0xfc>)
   115e0:	4630      	mov	r0, r6
   115e2:	2a00      	cmp	r2, #0
   115e4:	bf08      	it	eq
   115e6:	461a      	moveq	r2, r3
   115e8:	f7ff ffca 	bl	11580 <print_formatted>
	if (level_on) {
   115ec:	b13d      	cbz	r5, 115fe <prefix_print+0x5a>
		total += print_formatted(log_output, "<%s> ", severity[level]);
   115ee:	4b2d      	ldr	r3, [pc, #180]	; (116a4 <prefix_print+0x100>)
   115f0:	492d      	ldr	r1, [pc, #180]	; (116a8 <prefix_print+0x104>)
   115f2:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
   115f6:	4630      	mov	r0, r6
   115f8:	f7ff ffc2 	bl	11580 <print_formatted>
   115fc:	4605      	mov	r5, r0
	total += print_formatted(log_output,
   115fe:	f1b8 0f00 	cmp.w	r8, #0
   11602:	d044      	beq.n	1168e <prefix_print+0xea>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
   11604:	2301      	movs	r3, #1
   11606:	fa03 f707 	lsl.w	r7, r3, r7
	total += print_formatted(log_output,
   1160a:	4b28      	ldr	r3, [pc, #160]	; (116ac <prefix_print+0x108>)
   1160c:	f017 0f10 	tst.w	r7, #16
   11610:	4f27      	ldr	r7, [pc, #156]	; (116b0 <prefix_print+0x10c>)
   11612:	bf18      	it	ne
   11614:	461f      	movne	r7, r3
   11616:	f8bd 1040 	ldrh.w	r1, [sp, #64]	; 0x40
   1161a:	f89d 003c 	ldrb.w	r0, [sp, #60]	; 0x3c
   1161e:	f7ff fc95 	bl	10f4c <log_source_name_get>
   11622:	4639      	mov	r1, r7
   11624:	4602      	mov	r2, r0
   11626:	4630      	mov	r0, r6
   11628:	f7ff ffaa 	bl	11580 <print_formatted>
   1162c:	4428      	add	r0, r5
		length += ids_print(log_output, level_on, func_on,
				    domain_id, source_id, level);
	}

	return length;
}
   1162e:	4420      	add	r0, r4
   11630:	b005      	add	sp, #20
   11632:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (freq != 0U) {
   11636:	4a1f      	ldr	r2, [pc, #124]	; (116b4 <prefix_print+0x110>)
   11638:	6811      	ldr	r1, [r2, #0]
   1163a:	b331      	cbz	r1, 1168a <prefix_print+0xe6>
		timestamp /= timestamp_div;
   1163c:	4a1e      	ldr	r2, [pc, #120]	; (116b8 <prefix_print+0x114>)
   1163e:	f44f 6e61 	mov.w	lr, #3600	; 0xe10
   11642:	6814      	ldr	r4, [r2, #0]
   11644:	fbb3 f3f4 	udiv	r3, r3, r4
		ms = (remainder * 1000U) / freq;
   11648:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
		seconds = timestamp / freq;
   1164c:	fbb3 f4f1 	udiv	r4, r3, r1
		seconds -= hours * 3600U;
   11650:	fbb4 f2fe 	udiv	r2, r4, lr
   11654:	fb0e 4e12 	mls	lr, lr, r2, r4
		remainder = timestamp % freq;
   11658:	fb01 3414 	mls	r4, r1, r4, r3
		ms = (remainder * 1000U) / freq;
   1165c:	fb0c f404 	mul.w	r4, ip, r4
		mins = seconds / 60U;
   11660:	f04f 0a3c 	mov.w	sl, #60	; 0x3c
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   11664:	fbb4 fbf1 	udiv	fp, r4, r1
   11668:	fb01 441b 	mls	r4, r1, fp, r4
		mins = seconds / 60U;
   1166c:	fbbe f3fa 	udiv	r3, lr, sl
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   11670:	fb0c f404 	mul.w	r4, ip, r4
   11674:	fbb4 f1f1 	udiv	r1, r4, r1
			length = print_formatted(log_output,
   11678:	e9cd b101 	strd	fp, r1, [sp, #4]
   1167c:	fb0a e113 	mls	r1, sl, r3, lr
   11680:	9100      	str	r1, [sp, #0]
   11682:	490e      	ldr	r1, [pc, #56]	; (116bc <prefix_print+0x118>)
   11684:	f7ff ff7c 	bl	11580 <print_formatted>
   11688:	e7a1      	b.n	115ce <prefix_print+0x2a>
		length = 0;
   1168a:	4608      	mov	r0, r1
   1168c:	e79f      	b.n	115ce <prefix_print+0x2a>
	total += print_formatted(log_output,
   1168e:	4f08      	ldr	r7, [pc, #32]	; (116b0 <prefix_print+0x10c>)
   11690:	e7c1      	b.n	11616 <prefix_print+0x72>
   11692:	bf00      	nop
   11694:	0002f4d6 	.word	0x0002f4d6
   11698:	0002de60 	.word	0x0002de60
   1169c:	000306d9 	.word	0x000306d9
   116a0:	0002f4c8 	.word	0x0002f4c8
   116a4:	0002de74 	.word	0x0002de74
   116a8:	0002f4fb 	.word	0x0002f4fb
   116ac:	0002f4d2 	.word	0x0002f4d2
   116b0:	0002f4cd 	.word	0x0002f4cd
   116b4:	20000630 	.word	0x20000630
   116b8:	20000634 	.word	0x20000634
   116bc:	0002f4df 	.word	0x0002f4df

000116c0 <postfix_print>:

static void postfix_print(const struct log_output *log_output,
			  u32_t flags, u8_t level)
{
   116c0:	b538      	push	{r3, r4, r5, lr}
   116c2:	460c      	mov	r4, r1
	if (color) {
   116c4:	07e1      	lsls	r1, r4, #31
{
   116c6:	4605      	mov	r5, r0
	if (color) {
   116c8:	d503      	bpl.n	116d2 <postfix_print+0x12>
		print_formatted(log_output, "%s", color);
   116ca:	4a08      	ldr	r2, [pc, #32]	; (116ec <postfix_print+0x2c>)
   116cc:	4908      	ldr	r1, [pc, #32]	; (116f0 <postfix_print+0x30>)
   116ce:	f7ff ff57 	bl	11580 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   116d2:	06e2      	lsls	r2, r4, #27
   116d4:	d408      	bmi.n	116e8 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   116d6:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
   116d8:	4628      	mov	r0, r5
		print_formatted(ctx, "\n");
   116da:	bf4c      	ite	mi
   116dc:	4905      	ldrmi	r1, [pc, #20]	; (116f4 <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
   116de:	4906      	ldrpl	r1, [pc, #24]	; (116f8 <postfix_print+0x38>)
	color_postfix(log_output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(log_output, flags);
}
   116e0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\r\n");
   116e4:	f7ff bf4c 	b.w	11580 <print_formatted>
}
   116e8:	bd38      	pop	{r3, r4, r5, pc}
   116ea:	bf00      	nop
   116ec:	0002f4c8 	.word	0x0002f4c8
   116f0:	000306d9 	.word	0x000306d9
   116f4:	0002f978 	.word	0x0002f978
   116f8:	0002f550 	.word	0x0002f550

000116fc <hexdump_line_print>:
{
   116fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   11700:	4698      	mov	r8, r3
   11702:	9b08      	ldr	r3, [sp, #32]
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   11704:	06dd      	lsls	r5, r3, #27
{
   11706:	4604      	mov	r4, r0
   11708:	460e      	mov	r6, r1
   1170a:	4617      	mov	r7, r2
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   1170c:	d405      	bmi.n	1171a <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   1170e:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
   11710:	bf4c      	ite	mi
   11712:	4929      	ldrmi	r1, [pc, #164]	; (117b8 <hexdump_line_print+0xbc>)
		print_formatted(ctx, "\r\n");
   11714:	4929      	ldrpl	r1, [pc, #164]	; (117bc <hexdump_line_print+0xc0>)
   11716:	f7ff ff33 	bl	11580 <print_formatted>
		print_formatted(log_output, " ");
   1171a:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 117c4 <hexdump_line_print+0xc8>
{
   1171e:	2500      	movs	r5, #0
	for (int i = 0; i < prefix_offset; i++) {
   11720:	4545      	cmp	r5, r8
   11722:	db2a      	blt.n	1177a <hexdump_line_print+0x7e>
			print_formatted(log_output, "   ");
   11724:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 117c8 <hexdump_line_print+0xcc>
			print_formatted(log_output, "%02x ", data[i]);
   11728:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 117cc <hexdump_line_print+0xd0>
			print_formatted(log_output, " ");
   1172c:	f8df a094 	ldr.w	sl, [pc, #148]	; 117c4 <hexdump_line_print+0xc8>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   11730:	2500      	movs	r5, #0
		if (i < length) {
   11732:	42af      	cmp	r7, r5
   11734:	d92e      	bls.n	11794 <hexdump_line_print+0x98>
			print_formatted(log_output, "%02x ", data[i]);
   11736:	5d72      	ldrb	r2, [r6, r5]
   11738:	4649      	mov	r1, r9
   1173a:	4620      	mov	r0, r4
   1173c:	f7ff ff20 	bl	11580 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   11740:	3501      	adds	r5, #1
   11742:	2d10      	cmp	r5, #16
   11744:	d11f      	bne.n	11786 <hexdump_line_print+0x8a>
	print_formatted(log_output, "|");
   11746:	491e      	ldr	r1, [pc, #120]	; (117c0 <hexdump_line_print+0xc4>)
			print_formatted(log_output, " ");
   11748:	f8df 8078 	ldr.w	r8, [pc, #120]	; 117c4 <hexdump_line_print+0xc8>
			print_formatted(log_output, "%c",
   1174c:	f8df 9080 	ldr.w	r9, [pc, #128]	; 117d0 <hexdump_line_print+0xd4>
	print_formatted(log_output, "|");
   11750:	4620      	mov	r0, r4
   11752:	f7ff ff15 	bl	11580 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   11756:	2500      	movs	r5, #0
		if (i < length) {
   11758:	42af      	cmp	r7, r5
   1175a:	d927      	bls.n	117ac <hexdump_line_print+0xb0>
			      isprint((int)c) ? c : '.');
   1175c:	5d72      	ldrb	r2, [r6, r5]
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isprint(int c)
{
	return (int)((((unsigned)c) >= ' ') &&
   1175e:	f1a2 0320 	sub.w	r3, r2, #32
			print_formatted(log_output, "%c",
   11762:	2b5f      	cmp	r3, #95	; 0x5f
   11764:	bf28      	it	cs
   11766:	222e      	movcs	r2, #46	; 0x2e
   11768:	4649      	mov	r1, r9
   1176a:	4620      	mov	r0, r4
   1176c:	f7ff ff08 	bl	11580 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   11770:	3501      	adds	r5, #1
   11772:	2d10      	cmp	r5, #16
   11774:	d113      	bne.n	1179e <hexdump_line_print+0xa2>
}
   11776:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(log_output, " ");
   1177a:	4649      	mov	r1, r9
   1177c:	4620      	mov	r0, r4
   1177e:	f7ff feff 	bl	11580 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
   11782:	3501      	adds	r5, #1
   11784:	e7cc      	b.n	11720 <hexdump_line_print+0x24>
		if (i > 0 && !(i % 8)) {
   11786:	076a      	lsls	r2, r5, #29
   11788:	d1d3      	bne.n	11732 <hexdump_line_print+0x36>
			print_formatted(log_output, " ");
   1178a:	4651      	mov	r1, sl
   1178c:	4620      	mov	r0, r4
   1178e:	f7ff fef7 	bl	11580 <print_formatted>
   11792:	e7ce      	b.n	11732 <hexdump_line_print+0x36>
			print_formatted(log_output, "   ");
   11794:	4641      	mov	r1, r8
   11796:	4620      	mov	r0, r4
   11798:	f7ff fef2 	bl	11580 <print_formatted>
   1179c:	e7d0      	b.n	11740 <hexdump_line_print+0x44>
		if (i > 0 && !(i % 8)) {
   1179e:	076b      	lsls	r3, r5, #29
   117a0:	d1da      	bne.n	11758 <hexdump_line_print+0x5c>
			print_formatted(log_output, " ");
   117a2:	4641      	mov	r1, r8
   117a4:	4620      	mov	r0, r4
   117a6:	f7ff feeb 	bl	11580 <print_formatted>
   117aa:	e7d5      	b.n	11758 <hexdump_line_print+0x5c>
			print_formatted(log_output, " ");
   117ac:	4641      	mov	r1, r8
   117ae:	4620      	mov	r0, r4
   117b0:	f7ff fee6 	bl	11580 <print_formatted>
   117b4:	e7dc      	b.n	11770 <hexdump_line_print+0x74>
   117b6:	bf00      	nop
   117b8:	0002f978 	.word	0x0002f978
   117bc:	0002f550 	.word	0x0002f550
   117c0:	0002f4a7 	.word	0x0002f4a7
   117c4:	0002f4a5 	.word	0x0002f4a5
   117c8:	0002f4a3 	.word	0x0002f4a3
   117cc:	0002f49d 	.word	0x0002f49d
   117d0:	0002f9a3 	.word	0x0002f9a3

000117d4 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *log_output,
			    struct log_msg *msg,
			    u32_t flags)
{
   117d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return msg->hdr.ids.level;
   117d8:	7a8b      	ldrb	r3, [r1, #10]
		log_output_msg_syst_process(log_output, msg, flags);
		return;
	}

	prefix_offset = raw_string ?
			0 : prefix_print(log_output, flags, std_msg, timestamp,
   117da:	f013 0407 	ands.w	r4, r3, #7
{
   117de:	4617      	mov	r7, r2
   117e0:	b08a      	sub	sp, #40	; 0x28
   117e2:	4605      	mov	r5, r0
   117e4:	460e      	mov	r6, r1
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   117e6:	7a0a      	ldrb	r2, [r1, #8]
			0 : prefix_print(log_output, flags, std_msg, timestamp,
   117e8:	d01c      	beq.n	11824 <log_output_msg_process+0x50>
	return msg->hdr.ids.source_id;
   117ea:	8949      	ldrh	r1, [r1, #10]
   117ec:	f3c3 03c2 	ubfx	r3, r3, #3, #3
   117f0:	0989      	lsrs	r1, r1, #6
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
   117f2:	43d2      	mvns	r2, r2
   117f4:	9102      	str	r1, [sp, #8]
   117f6:	e9cd 4300 	strd	r4, r3, [sp]
   117fa:	f002 0201 	and.w	r2, r2, #1
   117fe:	68f3      	ldr	r3, [r6, #12]
   11800:	4639      	mov	r1, r7
   11802:	f7ff fecf 	bl	115a4 <prefix_print>
   11806:	4681      	mov	r9, r0
   11808:	7a33      	ldrb	r3, [r6, #8]
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
   1180a:	07da      	lsls	r2, r3, #31
   1180c:	d40c      	bmi.n	11828 <log_output_msg_process+0x54>
		std_print(msg, log_output);
   1180e:	4629      	mov	r1, r5
   11810:	4630      	mov	r0, r6
   11812:	f017 f9ed 	bl	28bf0 <std_print>
		raw_string_print(msg, log_output);
	} else {
		hexdump_print(msg, log_output, prefix_offset, flags);
	}

	if (!raw_string) {
   11816:	b34c      	cbz	r4, 1186c <log_output_msg_process+0x98>
		postfix_print(log_output, flags, level);
   11818:	4622      	mov	r2, r4
   1181a:	4639      	mov	r1, r7
   1181c:	4628      	mov	r0, r5
   1181e:	f7ff ff4f 	bl	116c0 <postfix_print>
   11822:	e023      	b.n	1186c <log_output_msg_process+0x98>
			0 : prefix_print(log_output, flags, std_msg, timestamp,
   11824:	46a1      	mov	r9, r4
   11826:	e7ef      	b.n	11808 <log_output_msg_process+0x34>
	} else if (raw_string) {
   11828:	bb34      	cbnz	r4, 11878 <log_output_msg_process+0xa4>
	size_t offset = 0;
   1182a:	4627      	mov	r7, r4
		length = log_output->size;
   1182c:	68eb      	ldr	r3, [r5, #12]
   1182e:	9306      	str	r3, [sp, #24]
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
   11830:	aa06      	add	r2, sp, #24
   11832:	463b      	mov	r3, r7
   11834:	68a9      	ldr	r1, [r5, #8]
   11836:	4630      	mov	r0, r6
   11838:	f017 f9c6 	bl	28bc8 <log_msg_hexdump_data_get>
		log_output->control_block->offset = length;
   1183c:	9a06      	ldr	r2, [sp, #24]
   1183e:	686b      	ldr	r3, [r5, #4]
   11840:	601a      	str	r2, [r3, #0]
		if (length != 0) {
   11842:	b13a      	cbz	r2, 11854 <log_output_msg_process+0x80>
			eol = (log_output->buf[length - 1] == '\n');
   11844:	68ab      	ldr	r3, [r5, #8]
   11846:	4413      	add	r3, r2
   11848:	f813 4c01 	ldrb.w	r4, [r3, #-1]
   1184c:	f1a4 030a 	sub.w	r3, r4, #10
   11850:	425c      	negs	r4, r3
   11852:	415c      	adcs	r4, r3
		log_output_flush(log_output);
   11854:	4628      	mov	r0, r5
   11856:	f017 fb28 	bl	28eaa <log_output_flush>
		offset += length;
   1185a:	9b06      	ldr	r3, [sp, #24]
   1185c:	441f      	add	r7, r3
	} while (length > 0);
   1185e:	2b00      	cmp	r3, #0
   11860:	d1e4      	bne.n	1182c <log_output_msg_process+0x58>
	if (eol) {
   11862:	b11c      	cbz	r4, 1186c <log_output_msg_process+0x98>
		print_formatted(log_output, "\r");
   11864:	4914      	ldr	r1, [pc, #80]	; (118b8 <log_output_msg_process+0xe4>)
   11866:	4628      	mov	r0, r5
   11868:	f7ff fe8a 	bl	11580 <print_formatted>
	}

	log_output_flush(log_output);
   1186c:	4628      	mov	r0, r5
   1186e:	f017 fb1c 	bl	28eaa <log_output_flush>
}
   11872:	b00a      	add	sp, #40	; 0x28
   11874:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	print_formatted(log_output, "%s", log_msg_str_get(msg));
   11878:	4630      	mov	r0, r6
   1187a:	f017 f94f 	bl	28b1c <log_msg_str_get>
   1187e:	490f      	ldr	r1, [pc, #60]	; (118bc <log_output_msg_process+0xe8>)
   11880:	4602      	mov	r2, r0
   11882:	4628      	mov	r0, r5
   11884:	f7ff fe7c 	bl	11580 <print_formatted>
	u32_t offset = 0U;
   11888:	f04f 0800 	mov.w	r8, #0
		length = sizeof(buf);
   1188c:	f04f 0a10 	mov.w	sl, #16
		log_msg_hexdump_data_get(msg, buf, &length, offset);
   11890:	aa05      	add	r2, sp, #20
   11892:	4643      	mov	r3, r8
   11894:	a906      	add	r1, sp, #24
   11896:	4630      	mov	r0, r6
		length = sizeof(buf);
   11898:	f8cd a014 	str.w	sl, [sp, #20]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
   1189c:	f017 f994 	bl	28bc8 <log_msg_hexdump_data_get>
		if (length) {
   118a0:	9a05      	ldr	r2, [sp, #20]
   118a2:	2a00      	cmp	r2, #0
   118a4:	d0b8      	beq.n	11818 <log_output_msg_process+0x44>
			hexdump_line_print(log_output, buf, length,
   118a6:	464b      	mov	r3, r9
   118a8:	9700      	str	r7, [sp, #0]
   118aa:	a906      	add	r1, sp, #24
   118ac:	4628      	mov	r0, r5
   118ae:	f7ff ff25 	bl	116fc <hexdump_line_print>
			offset += length;
   118b2:	9b05      	ldr	r3, [sp, #20]
   118b4:	4498      	add	r8, r3
   118b6:	e7eb      	b.n	11890 <log_output_msg_process+0xbc>
   118b8:	0002f4a9 	.word	0x0002f4a9
   118bc:	000306d9 	.word	0x000306d9

000118c0 <log_output_dropped_process>:
	postfix_print(log_output, flags, level);
	log_output_flush(log_output);
}

void log_output_dropped_process(const struct log_output *log_output, u32_t cnt)
{
   118c0:	b573      	push	{r0, r1, r4, r5, r6, lr}
	int len;
	static const char prefix[] = DROPPED_COLOR_PREFIX "--- ";
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = log_output->func;
	struct device *dev = (struct device *)log_output->control_block->ctx;
   118c2:	e9d0 4300 	ldrd	r4, r3, [r0]
   118c6:	685d      	ldr	r5, [r3, #4]

	cnt = MIN(cnt, 9999);
	len = snprintf(buf, sizeof(buf), "%d", cnt);
   118c8:	4a0f      	ldr	r2, [pc, #60]	; (11908 <log_output_dropped_process+0x48>)
   118ca:	f242 730f 	movw	r3, #9999	; 0x270f
   118ce:	428b      	cmp	r3, r1
   118d0:	bf28      	it	cs
   118d2:	460b      	movcs	r3, r1
   118d4:	4668      	mov	r0, sp
   118d6:	2105      	movs	r1, #5
   118d8:	f003 fb82 	bl	14fe0 <snprintf>

	buffer_write(outf, (u8_t *)prefix, sizeof(prefix) - 1, dev);
   118dc:	462b      	mov	r3, r5
	len = snprintf(buf, sizeof(buf), "%d", cnt);
   118de:	4606      	mov	r6, r0
	buffer_write(outf, (u8_t *)prefix, sizeof(prefix) - 1, dev);
   118e0:	2204      	movs	r2, #4
   118e2:	4620      	mov	r0, r4
   118e4:	4909      	ldr	r1, [pc, #36]	; (1190c <log_output_dropped_process+0x4c>)
   118e6:	f017 f976 	bl	28bd6 <buffer_write>
	buffer_write(outf, buf, len, dev);
   118ea:	462b      	mov	r3, r5
   118ec:	4632      	mov	r2, r6
   118ee:	4669      	mov	r1, sp
   118f0:	4620      	mov	r0, r4
   118f2:	f017 f970 	bl	28bd6 <buffer_write>
	buffer_write(outf, (u8_t *)postfix, sizeof(postfix) - 1, dev);
   118f6:	462b      	mov	r3, r5
   118f8:	2217      	movs	r2, #23
   118fa:	4905      	ldr	r1, [pc, #20]	; (11910 <log_output_dropped_process+0x50>)
   118fc:	4620      	mov	r0, r4
   118fe:	f017 f96a 	bl	28bd6 <buffer_write>
}
   11902:	b002      	add	sp, #8
   11904:	bd70      	pop	{r4, r5, r6, pc}
   11906:	bf00      	nop
   11908:	0002ed92 	.word	0x0002ed92
   1190c:	0002f4c3 	.word	0x0002f4c3
   11910:	0002f4ab 	.word	0x0002f4ab

00011914 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(u32_t frequency)
{
	timestamp_div = 1U;
   11914:	4a08      	ldr	r2, [pc, #32]	; (11938 <log_output_timestamp_freq_set+0x24>)
{
   11916:	b510      	push	{r4, lr}
	timestamp_div = 1U;
   11918:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
   1191a:	4c08      	ldr	r4, [pc, #32]	; (1193c <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
   1191c:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
   1191e:	2100      	movs	r1, #0
   11920:	42a0      	cmp	r0, r4
   11922:	d804      	bhi.n	1192e <log_output_timestamp_freq_set+0x1a>
   11924:	b101      	cbz	r1, 11928 <log_output_timestamp_freq_set+0x14>
   11926:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
   11928:	4b05      	ldr	r3, [pc, #20]	; (11940 <log_output_timestamp_freq_set+0x2c>)
   1192a:	6018      	str	r0, [r3, #0]
}
   1192c:	bd10      	pop	{r4, pc}
		frequency /= 2U;
   1192e:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
   11930:	005b      	lsls	r3, r3, #1
   11932:	2101      	movs	r1, #1
   11934:	e7f4      	b.n	11920 <log_output_timestamp_freq_set+0xc>
   11936:	bf00      	nop
   11938:	20000634 	.word	0x20000634
   1193c:	000f4240 	.word	0x000f4240
   11940:	20000630 	.word	0x20000630

00011944 <severity_lvl_get>:
}


static void severity_lvl_get(size_t idx, struct shell_static_entry *entry)
{
	entry->handler = NULL;
   11944:	2300      	movs	r3, #0
	entry->help  = NULL;
	entry->subcmd = &dsub_module_name;
	entry->syntax = (idx < ARRAY_SIZE(severity_lvls_sorted)) ?
					severity_lvls_sorted[idx] : NULL;
   11946:	2804      	cmp	r0, #4
	entry->handler = NULL;
   11948:	60cb      	str	r3, [r1, #12]
	entry->help  = NULL;
   1194a:	604b      	str	r3, [r1, #4]
					severity_lvls_sorted[idx] : NULL;
   1194c:	bf98      	it	ls
   1194e:	4b04      	ldrls	r3, [pc, #16]	; (11960 <severity_lvl_get+0x1c>)
	entry->subcmd = &dsub_module_name;
   11950:	4a04      	ldr	r2, [pc, #16]	; (11964 <severity_lvl_get+0x20>)
					severity_lvls_sorted[idx] : NULL;
   11952:	bf98      	it	ls
   11954:	f853 3020 	ldrls.w	r3, [r3, r0, lsl #2]
	entry->subcmd = &dsub_module_name;
   11958:	608a      	str	r2, [r1, #8]
	entry->syntax = (idx < ARRAY_SIZE(severity_lvls_sorted)) ?
   1195a:	600b      	str	r3, [r1, #0]
}
   1195c:	4770      	bx	lr
   1195e:	bf00      	nop
   11960:	0002dec8 	.word	0x0002dec8
   11964:	0002dea4 	.word	0x0002dea4

00011968 <backend_name_get>:
	SHELL_SUBCMD_SET_END
);

static void backend_name_get(size_t idx, struct shell_static_entry *entry)
{
	entry->handler = NULL;
   11968:	2200      	movs	r2, #0
	entry->help  = NULL;
	entry->subcmd = &sub_log_backend;
   1196a:	4b08      	ldr	r3, [pc, #32]	; (1198c <backend_name_get+0x24>)
	entry->syntax  = NULL;
   1196c:	600a      	str	r2, [r1, #0]
	entry->handler = NULL;
   1196e:	60ca      	str	r2, [r1, #12]
	entry->help  = NULL;
   11970:	604a      	str	r2, [r1, #4]
	entry->subcmd = &sub_log_backend;
   11972:	608b      	str	r3, [r1, #8]
	return __log_backends_end - __log_backends_start;
   11974:	4a06      	ldr	r2, [pc, #24]	; (11990 <backend_name_get+0x28>)
   11976:	4b07      	ldr	r3, [pc, #28]	; (11994 <backend_name_get+0x2c>)
   11978:	1ad2      	subs	r2, r2, r3

	if (idx < log_backend_count_get()) {
   1197a:	ebb0 1f22 	cmp.w	r0, r2, asr #4
		const struct log_backend *backend = log_backend_get(idx);

		entry->syntax = backend->name;
   1197e:	bf3e      	ittt	cc
   11980:	eb03 1300 	addcc.w	r3, r3, r0, lsl #4
   11984:	689b      	ldrcc	r3, [r3, #8]
   11986:	600b      	strcc	r3, [r1, #0]
	}
}
   11988:	4770      	bx	lr
   1198a:	bf00      	nop
   1198c:	0002e008 	.word	0x0002e008
   11990:	0002dc90 	.word	0x0002dc90
   11994:	0002dc80 	.word	0x0002dc80

00011998 <cmd_log_backends_list>:
{
   11998:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   1199c:	4c11      	ldr	r4, [pc, #68]	; (119e4 <cmd_log_backends_list+0x4c>)
   1199e:	4d12      	ldr	r5, [pc, #72]	; (119e8 <cmd_log_backends_list+0x50>)
		shell_fprintf(shell, SHELL_NORMAL,
   119a0:	f8df 8048 	ldr.w	r8, [pc, #72]	; 119ec <cmd_log_backends_list+0x54>
   119a4:	f8df 9048 	ldr.w	r9, [pc, #72]	; 119f0 <cmd_log_backends_list+0x58>
   119a8:	f8df a048 	ldr.w	sl, [pc, #72]	; 119f4 <cmd_log_backends_list+0x5c>
   119ac:	1b2d      	subs	r5, r5, r4
{
   119ae:	4607      	mov	r7, r0
   119b0:	112d      	asrs	r5, r5, #4
	for (int i = 0; i < backend_count; i++) {
   119b2:	2600      	movs	r6, #0
   119b4:	42ae      	cmp	r6, r5
   119b6:	db03      	blt.n	119c0 <cmd_log_backends_list+0x28>
}
   119b8:	2000      	movs	r0, #0
   119ba:	b002      	add	sp, #8
   119bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			      backend->cb->active ? "enabled" : "disabled",
   119c0:	6862      	ldr	r2, [r4, #4]
		shell_fprintf(shell, SHELL_NORMAL,
   119c2:	7953      	ldrb	r3, [r2, #5]
   119c4:	7912      	ldrb	r2, [r2, #4]
   119c6:	2b00      	cmp	r3, #0
   119c8:	bf14      	ite	ne
   119ca:	4643      	movne	r3, r8
   119cc:	464b      	moveq	r3, r9
   119ce:	e9cd 3200 	strd	r3, r2, [sp]
   119d2:	2100      	movs	r1, #0
   119d4:	68a3      	ldr	r3, [r4, #8]
   119d6:	4652      	mov	r2, sl
   119d8:	4638      	mov	r0, r7
   119da:	f017 fb73 	bl	290c4 <shell_fprintf>
	for (int i = 0; i < backend_count; i++) {
   119de:	3601      	adds	r6, #1
   119e0:	3410      	adds	r4, #16
   119e2:	e7e7      	b.n	119b4 <cmd_log_backends_list+0x1c>
   119e4:	0002dc80 	.word	0x0002dc80
   119e8:	0002dc90 	.word	0x0002dc90
   119ec:	0002f521 	.word	0x0002f521
   119f0:	0002f529 	.word	0x0002f529
   119f4:	0002f532 	.word	0x0002f532

000119f8 <log_status>:
{
   119f8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   119fc:	4b21      	ldr	r3, [pc, #132]	; (11a84 <log_status+0x8c>)
   119fe:	4d22      	ldr	r5, [pc, #136]	; (11a88 <log_status+0x90>)
   11a00:	1aed      	subs	r5, r5, r3
	return backend->cb->active;
   11a02:	684b      	ldr	r3, [r1, #4]
	if (!log_backend_is_active(backend)) {
   11a04:	795b      	ldrb	r3, [r3, #5]
{
   11a06:	4606      	mov	r6, r0
   11a08:	460f      	mov	r7, r1
   11a0a:	08ed      	lsrs	r5, r5, #3
	if (!log_backend_is_active(backend)) {
   11a0c:	b91b      	cbnz	r3, 11a16 <log_status+0x1e>
		shell_warn(shell, "Logs are halted!");
   11a0e:	4a1f      	ldr	r2, [pc, #124]	; (11a8c <log_status+0x94>)
   11a10:	2104      	movs	r1, #4
   11a12:	f017 fb57 	bl	290c4 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL, "%-40s | current | built-in \r\n",
   11a16:	4b1e      	ldr	r3, [pc, #120]	; (11a90 <log_status+0x98>)
   11a18:	4a1e      	ldr	r2, [pc, #120]	; (11a94 <log_status+0x9c>)
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
   11a1a:	f8df 8080 	ldr.w	r8, [pc, #128]	; 11a9c <log_status+0xa4>
   11a1e:	f8df 9080 	ldr.w	r9, [pc, #128]	; 11aa0 <log_status+0xa8>
	shell_fprintf(shell, SHELL_NORMAL, "%-40s | current | built-in \r\n",
   11a22:	2100      	movs	r1, #0
   11a24:	4630      	mov	r0, r6
   11a26:	f017 fb4d 	bl	290c4 <shell_fprintf>
	shell_fprintf(shell, SHELL_NORMAL,
   11a2a:	4a1b      	ldr	r2, [pc, #108]	; (11a98 <log_status+0xa0>)
   11a2c:	2100      	movs	r1, #0
   11a2e:	4630      	mov	r0, r6
   11a30:	f017 fb48 	bl	290c4 <shell_fprintf>
	for (i = 0U; i < modules_cnt; i++) {
   11a34:	2400      	movs	r4, #0
   11a36:	42ac      	cmp	r4, r5
   11a38:	d103      	bne.n	11a42 <log_status+0x4a>
}
   11a3a:	2000      	movs	r0, #0
   11a3c:	b003      	add	sp, #12
   11a3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dynamic_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
   11a42:	4622      	mov	r2, r4
   11a44:	2301      	movs	r3, #1
   11a46:	2100      	movs	r1, #0
   11a48:	4638      	mov	r0, r7
   11a4a:	f7ff fb41 	bl	110d0 <log_filter_get>
		compiled_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
   11a4e:	2300      	movs	r3, #0
   11a50:	4622      	mov	r2, r4
   11a52:	4619      	mov	r1, r3
		dynamic_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
   11a54:	4682      	mov	sl, r0
		compiled_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
   11a56:	4638      	mov	r0, r7
   11a58:	f7ff fb3a 	bl	110d0 <log_filter_get>
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
   11a5c:	4621      	mov	r1, r4
		compiled_lvl = log_filter_get(backend, CONFIG_LOG_DOMAIN_ID,
   11a5e:	4683      	mov	fp, r0
		shell_fprintf(shell, SHELL_NORMAL, "%-40s | %-7s | %s\r\n",
   11a60:	2000      	movs	r0, #0
   11a62:	f7ff fa73 	bl	10f4c <log_source_name_get>
   11a66:	f858 302b 	ldr.w	r3, [r8, fp, lsl #2]
   11a6a:	9301      	str	r3, [sp, #4]
   11a6c:	f858 302a 	ldr.w	r3, [r8, sl, lsl #2]
   11a70:	9300      	str	r3, [sp, #0]
   11a72:	464a      	mov	r2, r9
   11a74:	4603      	mov	r3, r0
   11a76:	2100      	movs	r1, #0
   11a78:	4630      	mov	r0, r6
   11a7a:	f017 fb23 	bl	290c4 <shell_fprintf>
	for (i = 0U; i < modules_cnt; i++) {
   11a7e:	3401      	adds	r4, #1
   11a80:	e7d9      	b.n	11a36 <log_status+0x3e>
   11a82:	bf00      	nop
   11a84:	0002db28 	.word	0x0002db28
   11a88:	0002dc80 	.word	0x0002dc80
   11a8c:	0002f5ae 	.word	0x0002f5ae
   11a90:	0002f5c0 	.word	0x0002f5c0
   11a94:	0002f5cc 	.word	0x0002f5cc
   11a98:	0002f5ea 	.word	0x0002f5ea
   11a9c:	0002deb4 	.word	0x0002deb4
   11aa0:	0002f627 	.word	0x0002f627

00011aa4 <module_name_get>:
{
   11aa4:	b510      	push	{r4, lr}
	entry->handler = NULL;
   11aa6:	2300      	movs	r3, #0
	entry->subcmd = &dsub_module_name;
   11aa8:	4a05      	ldr	r2, [pc, #20]	; (11ac0 <module_name_get+0x1c>)
	entry->handler = NULL;
   11aaa:	60cb      	str	r3, [r1, #12]
{
   11aac:	460c      	mov	r4, r1
	entry->help  = NULL;
   11aae:	604b      	str	r3, [r1, #4]
	entry->subcmd = &dsub_module_name;
   11ab0:	608a      	str	r2, [r1, #8]
	entry->syntax = log_source_name_get(CONFIG_LOG_DOMAIN_ID, idx);
   11ab2:	4601      	mov	r1, r0
   11ab4:	4618      	mov	r0, r3
   11ab6:	f7ff fa49 	bl	10f4c <log_source_name_get>
   11aba:	6020      	str	r0, [r4, #0]
}
   11abc:	bd10      	pop	{r4, pc}
   11abe:	bf00      	nop
   11ac0:	0002dea4 	.word	0x0002dea4

00011ac4 <shell_backend_cmd_execute>:
{
   11ac4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char const *name = argv[-1];
   11ac8:	f852 7c04 	ldr.w	r7, [r2, #-4]
	return __log_backends_end - __log_backends_start;
   11acc:	4c19      	ldr	r4, [pc, #100]	; (11b34 <shell_backend_cmd_execute+0x70>)
{
   11ace:	b085      	sub	sp, #20
   11ad0:	4680      	mov	r8, r0
	size_t slen = strlen(name);
   11ad2:	4638      	mov	r0, r7
{
   11ad4:	4691      	mov	r9, r2
   11ad6:	9302      	str	r3, [sp, #8]
   11ad8:	468b      	mov	fp, r1
	size_t slen = strlen(name);
   11ada:	f018 fc6f 	bl	2a3bc <strlen>
   11ade:	4a16      	ldr	r2, [pc, #88]	; (11b38 <shell_backend_cmd_execute+0x74>)
   11ae0:	1b12      	subs	r2, r2, r4
   11ae2:	1112      	asrs	r2, r2, #4
   11ae4:	4603      	mov	r3, r0
   11ae6:	9201      	str	r2, [sp, #4]
	for (int i = 0; i < log_backend_count_get(); i++) {
   11ae8:	2500      	movs	r5, #0
   11aea:	46a2      	mov	sl, r4
   11aec:	9a01      	ldr	r2, [sp, #4]
   11aee:	4295      	cmp	r5, r2
   11af0:	db08      	blt.n	11b04 <shell_backend_cmd_execute+0x40>
		shell_error(shell, "Invalid backend: %s", name);
   11af2:	463b      	mov	r3, r7
   11af4:	4a11      	ldr	r2, [pc, #68]	; (11b3c <shell_backend_cmd_execute+0x78>)
   11af6:	2102      	movs	r1, #2
   11af8:	4640      	mov	r0, r8
   11afa:	f017 fae3 	bl	290c4 <shell_fprintf>
		return -ENOEXEC;
   11afe:	f06f 0607 	mvn.w	r6, #7
   11b02:	e012      	b.n	11b2a <shell_backend_cmd_execute+0x66>
		if (strncmp(name, backend->name, slen) == 0) {
   11b04:	68a1      	ldr	r1, [r4, #8]
   11b06:	9303      	str	r3, [sp, #12]
   11b08:	461a      	mov	r2, r3
   11b0a:	4638      	mov	r0, r7
   11b0c:	f018 fc69 	bl	2a3e2 <strncmp>
   11b10:	3410      	adds	r4, #16
   11b12:	4606      	mov	r6, r0
   11b14:	b110      	cbz	r0, 11b1c <shell_backend_cmd_execute+0x58>
	for (int i = 0; i < log_backend_count_get(); i++) {
   11b16:	3501      	adds	r5, #1
   11b18:	9b03      	ldr	r3, [sp, #12]
   11b1a:	e7e7      	b.n	11aec <shell_backend_cmd_execute+0x28>
		func(shell, backend, argc, argv);
   11b1c:	464b      	mov	r3, r9
   11b1e:	465a      	mov	r2, fp
   11b20:	eb0a 1105 	add.w	r1, sl, r5, lsl #4
   11b24:	4640      	mov	r0, r8
   11b26:	9c02      	ldr	r4, [sp, #8]
   11b28:	47a0      	blx	r4
}
   11b2a:	4630      	mov	r0, r6
   11b2c:	b005      	add	sp, #20
   11b2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11b32:	bf00      	nop
   11b34:	0002dc80 	.word	0x0002dc80
   11b38:	0002dc90 	.word	0x0002dc90
   11b3c:	0002f63b 	.word	0x0002f63b

00011b40 <cmd_log_backend_status>:
{
   11b40:	b508      	push	{r3, lr}
	shell_backend_cmd_execute(shell, argc, argv, log_status);
   11b42:	4b02      	ldr	r3, [pc, #8]	; (11b4c <cmd_log_backend_status+0xc>)
   11b44:	f7ff ffbe 	bl	11ac4 <shell_backend_cmd_execute>
}
   11b48:	2000      	movs	r0, #0
   11b4a:	bd08      	pop	{r3, pc}
   11b4c:	000119f9 	.word	0x000119f9

00011b50 <cmd_log_backend_halt>:
	return shell_backend_cmd_execute(shell, argc, argv, log_halt);
   11b50:	4b01      	ldr	r3, [pc, #4]	; (11b58 <cmd_log_backend_halt+0x8>)
   11b52:	f7ff bfb7 	b.w	11ac4 <shell_backend_cmd_execute>
   11b56:	bf00      	nop
   11b58:	00028ee7 	.word	0x00028ee7

00011b5c <cmd_log_backend_go>:
	return shell_backend_cmd_execute(shell, argc, argv, log_go);
   11b5c:	4b01      	ldr	r3, [pc, #4]	; (11b64 <cmd_log_backend_go+0x8>)
   11b5e:	f7ff bfb1 	b.w	11ac4 <shell_backend_cmd_execute>
   11b62:	bf00      	nop
   11b64:	00028eef 	.word	0x00028eef

00011b68 <cmd_log_backend_enable>:
	return shell_backend_cmd_execute(shell, argc, argv, log_enable);
   11b68:	4b01      	ldr	r3, [pc, #4]	; (11b70 <cmd_log_backend_enable+0x8>)
   11b6a:	f7ff bfab 	b.w	11ac4 <shell_backend_cmd_execute>
   11b6e:	bf00      	nop
   11b70:	00011c71 	.word	0x00011c71

00011b74 <cmd_log_backend_disable>:
	return shell_backend_cmd_execute(shell, argc, argv, log_disable);
   11b74:	4b01      	ldr	r3, [pc, #4]	; (11b7c <cmd_log_backend_disable+0x8>)
   11b76:	f7ff bfa5 	b.w	11ac4 <shell_backend_cmd_execute>
   11b7a:	bf00      	nop
   11b7c:	00028f6b 	.word	0x00028f6b

00011b80 <shell_state_precheck>:
	if (shell->log_backend->control_block->state
   11b80:	69c3      	ldr	r3, [r0, #28]
   11b82:	68db      	ldr	r3, [r3, #12]
{
   11b84:	b510      	push	{r4, lr}
	if (shell->log_backend->control_block->state
   11b86:	791c      	ldrb	r4, [r3, #4]
   11b88:	b92c      	cbnz	r4, 11b96 <shell_state_precheck+0x16>
		shell_error(shell, "Shell log backend not initialized.");
   11b8a:	4a04      	ldr	r2, [pc, #16]	; (11b9c <shell_state_precheck+0x1c>)
   11b8c:	2102      	movs	r1, #2
   11b8e:	f017 fa99 	bl	290c4 <shell_fprintf>
   11b92:	4620      	mov	r0, r4
}
   11b94:	bd10      	pop	{r4, pc}
	return true;
   11b96:	2001      	movs	r0, #1
   11b98:	e7fc      	b.n	11b94 <shell_state_precheck+0x14>
   11b9a:	bf00      	nop
   11b9c:	0002f650 	.word	0x0002f650

00011ba0 <filters_set>:
{
   11ba0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11ba4:	461f      	mov	r7, r3
   11ba6:	4d2c      	ldr	r5, [pc, #176]	; (11c58 <filters_set+0xb8>)
   11ba8:	4b2c      	ldr	r3, [pc, #176]	; (11c5c <filters_set+0xbc>)
   11baa:	1aed      	subs	r5, r5, r3
	int cnt = all ? log_sources_count() : argc;
   11bac:	1e16      	subs	r6, r2, #0
{
   11bae:	b085      	sub	sp, #20
   11bb0:	ea4f 05d5 	mov.w	r5, r5, lsr #3
	int cnt = all ? log_sources_count() : argc;
   11bb4:	bf14      	ite	ne
   11bb6:	4633      	movne	r3, r6
   11bb8:	462b      	moveq	r3, r5
   11bba:	9303      	str	r3, [sp, #12]
	if (!backend->cb->active) {
   11bbc:	684b      	ldr	r3, [r1, #4]
   11bbe:	795b      	ldrb	r3, [r3, #5]
{
   11bc0:	4680      	mov	r8, r0
   11bc2:	4689      	mov	r9, r1
	if (!backend->cb->active) {
   11bc4:	b91b      	cbnz	r3, 11bce <filters_set+0x2e>
		shell_warn(shell, "Backend not active.");
   11bc6:	4a26      	ldr	r2, [pc, #152]	; (11c60 <filters_set+0xc0>)
   11bc8:	2104      	movs	r1, #4
   11bca:	f017 fa7b 	bl	290c4 <shell_fprintf>
				shell_warn(shell, "%s: level set to %s.",
   11bce:	f8df a09c 	ldr.w	sl, [pc, #156]	; 11c6c <filters_set+0xcc>
	for (i = 0U; i < modules_cnt; i++) {
   11bd2:	2400      	movs	r4, #0
	for (i = 0; i < cnt; i++) {
   11bd4:	9b03      	ldr	r3, [sp, #12]
   11bd6:	429c      	cmp	r4, r3
   11bd8:	db02      	blt.n	11be0 <filters_set+0x40>
}
   11bda:	b005      	add	sp, #20
   11bdc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		id = all ? i : module_id_get(argv[i]);
   11be0:	b3be      	cbz	r6, 11c52 <filters_set+0xb2>
   11be2:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
   11be6:	9302      	str	r3, [sp, #8]
	for (i = 0U; i < modules_cnt; i++) {
   11be8:	f04f 0b00 	mov.w	fp, #0
   11bec:	455d      	cmp	r5, fp
   11bee:	d107      	bne.n	11c00 <filters_set+0x60>
			shell_error(shell, "%s: unknown source name.", argv[i]);
   11bf0:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
   11bf4:	4a1b      	ldr	r2, [pc, #108]	; (11c64 <filters_set+0xc4>)
   11bf6:	2102      	movs	r1, #2
   11bf8:	4640      	mov	r0, r8
   11bfa:	f017 fa63 	bl	290c4 <shell_fprintf>
   11bfe:	e020      	b.n	11c42 <filters_set+0xa2>
		tmp_name = log_source_name_get(CONFIG_LOG_DOMAIN_ID, i);
   11c00:	4659      	mov	r1, fp
   11c02:	2000      	movs	r0, #0
   11c04:	f7ff f9a2 	bl	10f4c <log_source_name_get>
		if (strncmp(tmp_name, name, 64) == 0) {
   11c08:	2240      	movs	r2, #64	; 0x40
   11c0a:	9902      	ldr	r1, [sp, #8]
   11c0c:	f018 fbe9 	bl	2a3e2 <strncmp>
   11c10:	b9c8      	cbnz	r0, 11c46 <filters_set+0xa6>
			return i;
   11c12:	465a      	mov	r2, fp
	return z_impl_log_filter_set(backend, domain_id, src_id, level);
   11c14:	2100      	movs	r1, #0
   11c16:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   11c18:	4648      	mov	r0, r9
   11c1a:	f7ff f9a5 	bl	10f68 <z_impl_log_filter_set>
			if (set_lvl != level) {
   11c1e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   11c20:	4283      	cmp	r3, r0
   11c22:	4683      	mov	fp, r0
   11c24:	d00d      	beq.n	11c42 <filters_set+0xa2>
						CONFIG_LOG_DOMAIN_ID, i) :
   11c26:	b98e      	cbnz	r6, 11c4c <filters_set+0xac>
					log_source_name_get(
   11c28:	4621      	mov	r1, r4
   11c2a:	4630      	mov	r0, r6
   11c2c:	f7ff f98e 	bl	10f4c <log_source_name_get>
   11c30:	4603      	mov	r3, r0
				shell_warn(shell, "%s: level set to %s.",
   11c32:	f85a 202b 	ldr.w	r2, [sl, fp, lsl #2]
   11c36:	9200      	str	r2, [sp, #0]
   11c38:	2104      	movs	r1, #4
   11c3a:	4a0b      	ldr	r2, [pc, #44]	; (11c68 <filters_set+0xc8>)
   11c3c:	4640      	mov	r0, r8
   11c3e:	f017 fa41 	bl	290c4 <shell_fprintf>
	for (i = 0; i < cnt; i++) {
   11c42:	3401      	adds	r4, #1
   11c44:	e7c6      	b.n	11bd4 <filters_set+0x34>
	for (i = 0U; i < modules_cnt; i++) {
   11c46:	f10b 0b01 	add.w	fp, fp, #1
   11c4a:	e7cf      	b.n	11bec <filters_set+0x4c>
						CONFIG_LOG_DOMAIN_ID, i) :
   11c4c:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
   11c50:	e7ef      	b.n	11c32 <filters_set+0x92>
   11c52:	4622      	mov	r2, r4
   11c54:	e7de      	b.n	11c14 <filters_set+0x74>
   11c56:	bf00      	nop
   11c58:	0002dc80 	.word	0x0002dc80
   11c5c:	0002db28 	.word	0x0002db28
   11c60:	0002f553 	.word	0x0002f553
   11c64:	0002f57e 	.word	0x0002f57e
   11c68:	0002f568 	.word	0x0002f568
   11c6c:	0002deb4 	.word	0x0002deb4

00011c70 <log_enable>:
{
   11c70:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	severity_level = severity_level_get(argv[1]);
   11c74:	f8d3 b004 	ldr.w	fp, [r3, #4]
   11c78:	f8df 8050 	ldr.w	r8, [pc, #80]	; 11ccc <log_enable+0x5c>
{
   11c7c:	4607      	mov	r7, r0
   11c7e:	4689      	mov	r9, r1
   11c80:	4692      	mov	sl, r2
   11c82:	461e      	mov	r6, r3
	for (i = 0; i < ARRAY_SIZE(severity_lvls); i++) {
   11c84:	2400      	movs	r4, #0
		if (strncmp(str, severity_lvls[i], 4) == 0) {
   11c86:	2204      	movs	r2, #4
   11c88:	f858 1b04 	ldr.w	r1, [r8], #4
   11c8c:	4658      	mov	r0, fp
   11c8e:	f018 fba8 	bl	2a3e2 <strncmp>
   11c92:	4605      	mov	r5, r0
   11c94:	b170      	cbz	r0, 11cb4 <log_enable+0x44>
	for (i = 0; i < ARRAY_SIZE(severity_lvls); i++) {
   11c96:	3401      	adds	r4, #1
   11c98:	2c05      	cmp	r4, #5
   11c9a:	d1f4      	bne.n	11c86 <log_enable+0x16>
		shell_error(shell, "Invalid severity: %s", argv[1]);
   11c9c:	6873      	ldr	r3, [r6, #4]
   11c9e:	4a0a      	ldr	r2, [pc, #40]	; (11cc8 <log_enable+0x58>)
   11ca0:	2102      	movs	r1, #2
   11ca2:	4638      	mov	r0, r7
   11ca4:	f017 fa0e 	bl	290c4 <shell_fprintf>
   11ca8:	f06f 0507 	mvn.w	r5, #7
}
   11cac:	4628      	mov	r0, r5
   11cae:	b003      	add	sp, #12
   11cb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	filters_set(shell, backend, argc - 2, &argv[2], severity_level);
   11cb4:	9400      	str	r4, [sp, #0]
   11cb6:	f106 0308 	add.w	r3, r6, #8
   11cba:	f1aa 0202 	sub.w	r2, sl, #2
   11cbe:	4649      	mov	r1, r9
   11cc0:	4638      	mov	r0, r7
   11cc2:	f7ff ff6d 	bl	11ba0 <filters_set>
	return 0;
   11cc6:	e7f1      	b.n	11cac <log_enable+0x3c>
   11cc8:	0002f598 	.word	0x0002f598
   11ccc:	0002deb4 	.word	0x0002deb4

00011cd0 <cmd_kernel_version>:
#include <device.h>
#include <drivers/timer/system_timer.h>

static int cmd_kernel_version(const struct shell *shell,
			      size_t argc, char **argv)
{
   11cd0:	b513      	push	{r0, r1, r4, lr}
   11cd2:	4604      	mov	r4, r0
	u32_t version = sys_kernel_version_get();
   11cd4:	f015 fb8a 	bl	273ec <sys_kernel_version_get>

	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Zephyr version %d.%d.%d",
   11cd8:	f3c0 2307 	ubfx	r3, r0, #8, #8
   11cdc:	9301      	str	r3, [sp, #4]
   11cde:	f3c0 4307 	ubfx	r3, r0, #16, #8
   11ce2:	9300      	str	r3, [sp, #0]
   11ce4:	4a04      	ldr	r2, [pc, #16]	; (11cf8 <cmd_kernel_version+0x28>)
   11ce6:	0e03      	lsrs	r3, r0, #24
   11ce8:	2100      	movs	r1, #0
   11cea:	4620      	mov	r0, r4
   11cec:	f017 f9ea 	bl	290c4 <shell_fprintf>
		      SYS_KERNEL_VER_MAJOR(version),
		      SYS_KERNEL_VER_MINOR(version),
		      SYS_KERNEL_VER_PATCHLEVEL(version));
	return 0;
}
   11cf0:	2000      	movs	r0, #0
   11cf2:	b002      	add	sp, #8
   11cf4:	bd10      	pop	{r4, pc}
   11cf6:	bf00      	nop
   11cf8:	0002f82a 	.word	0x0002f82a

00011cfc <cmd_kernel_uptime>:

static int cmd_kernel_uptime(const struct shell *shell,
			     size_t argc, char **argv)
{
   11cfc:	b510      	push	{r4, lr}
   11cfe:	4604      	mov	r4, r0
	return z_impl_k_uptime_get();
   11d00:	f01b fc88 	bl	2d614 <z_impl_k_uptime_get>
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "Uptime: %u ms", k_uptime_get_32());
   11d04:	4a03      	ldr	r2, [pc, #12]	; (11d14 <cmd_kernel_uptime+0x18>)
   11d06:	4603      	mov	r3, r0
   11d08:	2100      	movs	r1, #0
   11d0a:	4620      	mov	r0, r4
   11d0c:	f017 f9da 	bl	290c4 <shell_fprintf>
	return 0;
}
   11d10:	2000      	movs	r0, #0
   11d12:	bd10      	pop	{r4, pc}
   11d14:	0002f81b 	.word	0x0002f81b

00011d18 <cmd_kernel_cycles>:

static int cmd_kernel_cycles(const struct shell *shell,
			      size_t argc, char **argv)
{
   11d18:	b510      	push	{r4, lr}
   11d1a:	4604      	mov	r4, r0
#ifndef _ASMLANGUAGE
extern u32_t z_timer_cycle_get_32(void);

static inline u32_t arch_k_cycle_get_32(void)
{
	return z_timer_cycle_get_32();
   11d1c:	f001 fe54 	bl	139c8 <z_timer_cycle_get_32>
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	shell_print(shell, "cycles: %u hw cycles", k_cycle_get_32());
   11d20:	4a03      	ldr	r2, [pc, #12]	; (11d30 <cmd_kernel_cycles+0x18>)
   11d22:	4603      	mov	r3, r0
   11d24:	2100      	movs	r1, #0
   11d26:	4620      	mov	r0, r4
   11d28:	f017 f9cc 	bl	290c4 <shell_fprintf>
	return 0;
}
   11d2c:	2000      	movs	r0, #0
   11d2e:	bd10      	pop	{r4, pc}
   11d30:	0002f805 	.word	0x0002f805

00011d34 <history_handle>:

	shell_history_put(shell->history, line, length);
}

static void history_handle(const struct shell *shell, bool up)
{
   11d34:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (!IS_ENABLED(CONFIG_SHELL_HISTORY)) {
		return;
	}

	/* Checking if history process has been stopped */
	if (flag_history_exit_get(shell)) {
   11d36:	6883      	ldr	r3, [r0, #8]
	shell->ctx->internal.flags.mode_delete = val ? 1 : 0;
}

static inline bool flag_history_exit_get(const struct shell *shell)
{
	return shell->ctx->internal.flags.history_exit == 1 ? true : false;
   11d38:	f8d3 2258 	ldr.w	r2, [r3, #600]	; 0x258
   11d3c:	0652      	lsls	r2, r2, #25
{
   11d3e:	4604      	mov	r4, r0
   11d40:	460d      	mov	r5, r1
	if (flag_history_exit_get(shell)) {
   11d42:	d508      	bpl.n	11d56 <history_handle+0x22>
}

static inline void flag_history_exit_set(const struct shell *shell, bool val)
{
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
   11d44:	f8b3 2258 	ldrh.w	r2, [r3, #600]	; 0x258
   11d48:	68c0      	ldr	r0, [r0, #12]
   11d4a:	f36f 1286 	bfc	r2, #6, #1
   11d4e:	f8a3 2258 	strh.w	r2, [r3, #600]	; 0x258
		flag_history_exit_set(shell, false);
		shell_history_mode_exit(shell->history);
   11d52:	f017 fe55 	bl	29a00 <shell_history_mode_exit>
	}

	/* Backup command if history is entered */
	if (!shell_history_active(shell->history)) {
   11d56:	68e3      	ldr	r3, [r4, #12]
   11d58:	68db      	ldr	r3, [r3, #12]
   11d5a:	b963      	cbnz	r3, 11d76 <history_handle+0x42>
		if (up) {
   11d5c:	b39d      	cbz	r5, 11dc6 <history_handle+0x92>
			u16_t cmd_len = shell_strlen(shell->ctx->cmd_buff);
   11d5e:	68a0      	ldr	r0, [r4, #8]
   11d60:	3038      	adds	r0, #56	; 0x38
   11d62:	f017 f959 	bl	29018 <shell_strlen>

			if (cmd_len) {
   11d66:	68a3      	ldr	r3, [r4, #8]
   11d68:	b378      	cbz	r0, 11dca <history_handle+0x96>
				strcpy(shell->ctx->temp_buff,
   11d6a:	f103 0138 	add.w	r1, r3, #56	; 0x38
   11d6e:	f503 709c 	add.w	r0, r3, #312	; 0x138
   11d72:	f018 faf8 	bl	2a366 <strcpy>
		}
	}

	/* Start by checking if history is not empty. */
	history_mode = shell_history_get(shell->history, up,
					 shell->ctx->cmd_buff, &len);
   11d76:	68a2      	ldr	r2, [r4, #8]
	history_mode = shell_history_get(shell->history, up,
   11d78:	68e0      	ldr	r0, [r4, #12]
   11d7a:	f10d 0306 	add.w	r3, sp, #6
   11d7e:	3238      	adds	r2, #56	; 0x38
   11d80:	4629      	mov	r1, r5
   11d82:	f017 fe40 	bl	29a06 <shell_history_get>

	/* On exiting history mode print backed up command. */
	if (!history_mode) {
   11d86:	b958      	cbnz	r0, 11da0 <history_handle+0x6c>
		strcpy(shell->ctx->cmd_buff, shell->ctx->temp_buff);
   11d88:	68a0      	ldr	r0, [r4, #8]
   11d8a:	f500 719c 	add.w	r1, r0, #312	; 0x138
   11d8e:	3038      	adds	r0, #56	; 0x38
   11d90:	f018 fae9 	bl	2a366 <strcpy>
		len = shell_strlen(shell->ctx->cmd_buff);
   11d94:	68a0      	ldr	r0, [r4, #8]
   11d96:	3038      	adds	r0, #56	; 0x38
   11d98:	f017 f93e 	bl	29018 <shell_strlen>
   11d9c:	f8ad 0006 	strh.w	r0, [sp, #6]
	}

	shell_op_cursor_home_move(shell);
   11da0:	4620      	mov	r0, r4
   11da2:	f017 fc6b 	bl	2967c <shell_op_cursor_home_move>
	SHELL_VT100_CMD(shell, SHELL_VT100_CLEAREOS);
   11da6:	4a0a      	ldr	r2, [pc, #40]	; (11dd0 <history_handle+0x9c>)
   11da8:	490a      	ldr	r1, [pc, #40]	; (11dd4 <history_handle+0xa0>)
   11daa:	6960      	ldr	r0, [r4, #20]
   11dac:	f017 f93a 	bl	29024 <shell_raw_fprintf>
	clear_eos(shell);
	shell_print_cmd(shell);
   11db0:	4620      	mov	r0, r4
   11db2:	f000 fe85 	bl	12ac0 <shell_print_cmd>
	shell->ctx->cmd_buff_pos = len;
   11db6:	68a3      	ldr	r3, [r4, #8]
   11db8:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   11dbc:	869a      	strh	r2, [r3, #52]	; 0x34
	shell->ctx->cmd_buff_len = len;
   11dbe:	865a      	strh	r2, [r3, #50]	; 0x32
	shell_op_cond_next_line(shell);
   11dc0:	4620      	mov	r0, r4
   11dc2:	f000 fe3f 	bl	12a44 <shell_op_cond_next_line>
}
   11dc6:	b003      	add	sp, #12
   11dc8:	bd30      	pop	{r4, r5, pc}
				shell->ctx->temp_buff[0] = '\0';
   11dca:	f883 0138 	strb.w	r0, [r3, #312]	; 0x138
   11dce:	e7d2      	b.n	11d76 <history_handle+0x42>
   11dd0:	0002f8ca 	.word	0x0002f8ca
   11dd4:	000306d9 	.word	0x000306d9

00011dd8 <execute>:
/* Function is analyzing the command buffer to find matching commands. Next, it
 * invokes the  last recognized command which has a handler and passes the rest
 * of command buffer as arguments.
 */
static int execute(const struct shell *shell)
{
   11dd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11ddc:	b09d      	sub	sp, #116	; 0x74
   11dde:	4604      	mov	r4, r0
	struct shell_static_entry d_entry; /* Memory for dynamic commands. */
	char *argv[CONFIG_SHELL_ARGC_MAX + 1]; /* +1 reserved for NULL */
	const struct shell_static_entry *p_static_entry = NULL;
   11de0:	2300      	movs	r3, #0
   11de2:	9303      	str	r3, [sp, #12]
	bool wildcard_found = false;
	size_t cmd_idx = 0;
	size_t argc;
	char quote;

	shell_op_cursor_end_move(shell);
   11de4:	f017 fc50 	bl	29688 <shell_op_cursor_end_move>
	if (!shell_cursor_in_empty_line(shell)) {
   11de8:	4620      	mov	r0, r4
   11dea:	f017 fbd5 	bl	29598 <shell_cursor_in_empty_line>
   11dee:	b918      	cbnz	r0, 11df8 <execute+0x20>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
   11df0:	498c      	ldr	r1, [pc, #560]	; (12024 <execute+0x24c>)
   11df2:	6960      	ldr	r0, [r4, #20]
   11df4:	f017 f916 	bl	29024 <shell_raw_fprintf>
		cursor_next_line_move(shell);
	}

	memset(&shell->ctx->active_cmd, 0, sizeof(shell->ctx->active_cmd));
   11df8:	68a0      	ldr	r0, [r4, #8]
   11dfa:	2214      	movs	r2, #20
   11dfc:	2100      	movs	r1, #0
   11dfe:	3008      	adds	r0, #8
   11e00:	f018 fb4f 	bl	2a4a2 <memset>

	shell_cmd_trim(shell);
   11e04:	4620      	mov	r0, r4
   11e06:	f017 fb6e 	bl	294e6 <shell_cmd_trim>

	history_put(shell, shell->ctx->cmd_buff,
   11e0a:	68a1      	ldr	r1, [r4, #8]
	shell_history_put(shell->history, line, length);
   11e0c:	68e0      	ldr	r0, [r4, #12]
   11e0e:	8e4a      	ldrh	r2, [r1, #50]	; 0x32
   11e10:	3138      	adds	r1, #56	; 0x38
   11e12:	f017 fe2f 	bl	29a74 <shell_history_put>
		    shell->ctx->cmd_buff_len);

	if (IS_ENABLED(CONFIG_SHELL_WILDCARD)) {
		shell_wildcard_prepare(shell);
   11e16:	4620      	mov	r0, r4
   11e18:	f017 ffcd 	bl	29db6 <shell_wildcard_prepare>
	}

	/* create argument list */
	quote = shell_make_argv(&argc, &argv[0], shell->ctx->cmd_buff,
   11e1c:	68a2      	ldr	r2, [r4, #8]
   11e1e:	230c      	movs	r3, #12
   11e20:	3238      	adds	r2, #56	; 0x38
   11e22:	a90f      	add	r1, sp, #60	; 0x3c
   11e24:	a804      	add	r0, sp, #16
   11e26:	f017 f9f3 	bl	29210 <shell_make_argv>
				CONFIG_SHELL_ARGC_MAX);

	if (!argc) {
   11e2a:	9a04      	ldr	r2, [sp, #16]
	quote = shell_make_argv(&argc, &argv[0], shell->ctx->cmd_buff,
   11e2c:	4603      	mov	r3, r0
	if (!argc) {
   11e2e:	b92a      	cbnz	r2, 11e3c <execute+0x64>

	if (quote != 0) {
		shell_internal_fprintf(shell, SHELL_ERROR,
				       "not terminated: %c\n",
				       quote);
		return -ENOEXEC;
   11e30:	f06f 0507 	mvn.w	r5, #7
	}

	/* Executing the deepest found handler. */
	return exec_cmd(shell, argc - cmd_with_handler_lvl,
			&argv[cmd_with_handler_lvl], &help_entry);
}
   11e34:	4628      	mov	r0, r5
   11e36:	b01d      	add	sp, #116	; 0x74
   11e38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (quote != 0) {
   11e3c:	b128      	cbz	r0, 11e4a <execute+0x72>
		shell_internal_fprintf(shell, SHELL_ERROR,
   11e3e:	4a7a      	ldr	r2, [pc, #488]	; (12028 <execute+0x250>)
   11e40:	2102      	movs	r1, #2
   11e42:	4620      	mov	r0, r4
   11e44:	f017 fcb9 	bl	297ba <shell_internal_fprintf>
   11e48:	e7f2      	b.n	11e30 <execute+0x58>
	help_entry.help = NULL;
   11e4a:	4605      	mov	r5, r0
	size_t cmd_idx = 0;
   11e4c:	4607      	mov	r7, r0
	bool wildcard_found = false;
   11e4e:	4681      	mov	r9, r0
	size_t cmd_with_handler_lvl = 0;
   11e50:	4682      	mov	sl, r0
	size_t cmd_lvl = SHELL_CMD_ROOT_LVL;
   11e52:	4606      	mov	r6, r0
	const struct shell_cmd_entry *p_cmd = NULL;
   11e54:	4683      	mov	fp, r0
   11e56:	e03e      	b.n	11ed6 <execute+0xfe>
		     !strcmp(argv[cmd_lvl], "--help"))) {
   11e58:	4974      	ldr	r1, [pc, #464]	; (1202c <execute+0x254>)
   11e5a:	f858 0c34 	ldr.w	r0, [r8, #-52]
   11e5e:	f018 fab4 	bl	2a3ca <strcmp>
		    (!strcmp(argv[cmd_lvl], "-h") ||
   11e62:	2800      	cmp	r0, #0
   11e64:	d045      	beq.n	11ef2 <execute+0x11a>
			status = shell_wildcard_process(shell, p_cmd,
   11e66:	f858 2c34 	ldr.w	r2, [r8, #-52]
   11e6a:	4659      	mov	r1, fp
   11e6c:	4620      	mov	r0, r4
   11e6e:	f001 fa63 	bl	13338 <shell_wildcard_process>
			if (status == SHELL_WILDCARD_CMD_NO_MATCH_FOUND) {
   11e72:	2802      	cmp	r0, #2
   11e74:	d128      	bne.n	11ec8 <execute+0xf0>
	if (IS_ENABLED(CONFIG_SHELL_WILDCARD) && wildcard_found) {
   11e76:	f1b9 0f00 	cmp.w	r9, #0
   11e7a:	d009      	beq.n	11e90 <execute+0xb8>
		shell_wildcard_finalize(shell);
   11e7c:	4620      	mov	r0, r4
   11e7e:	f017 ffbc 	bl	29dfa <shell_wildcard_finalize>
				      shell->ctx->cmd_buff,
   11e82:	68a2      	ldr	r2, [r4, #8]
		(void)shell_make_argv(&argc, &argv[0],
   11e84:	230c      	movs	r3, #12
   11e86:	3238      	adds	r2, #56	; 0x38
   11e88:	a90f      	add	r1, sp, #60	; 0x3c
   11e8a:	a804      	add	r0, sp, #16
   11e8c:	f017 f9c0 	bl	29210 <shell_make_argv>
	if (shell->ctx->active_cmd.handler == NULL) {
   11e90:	68a0      	ldr	r0, [r4, #8]
   11e92:	6943      	ldr	r3, [r0, #20]
   11e94:	2b00      	cmp	r3, #0
   11e96:	f040 808f 	bne.w	11fb8 <execute+0x1e0>
			if (help_entry->help == NULL) {
   11e9a:	2d00      	cmp	r5, #0
   11e9c:	d0c8      	beq.n	11e30 <execute+0x58>
			if (help_entry->help != shell->ctx->active_cmd.help) {
   11e9e:	68c3      	ldr	r3, [r0, #12]
   11ea0:	429d      	cmp	r5, r3
   11ea2:	d00c      	beq.n	11ebe <execute+0xe6>
				shell->ctx->active_cmd = *help_entry;
   11ea4:	950b      	str	r5, [sp, #44]	; 0x2c
   11ea6:	f100 0508 	add.w	r5, r0, #8
   11eaa:	e003      	b.n	11eb4 <execute+0xdc>
				shell->ctx->active_cmd = help_entry;
   11eac:	68a3      	ldr	r3, [r4, #8]
   11eae:	950b      	str	r5, [sp, #44]	; 0x2c
   11eb0:	f103 0508 	add.w	r5, r3, #8
				shell->ctx->active_cmd = *help_entry;
   11eb4:	ae0a      	add	r6, sp, #40	; 0x28
   11eb6:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   11eb8:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   11eba:	6833      	ldr	r3, [r6, #0]
   11ebc:	602b      	str	r3, [r5, #0]
			shell_internal_help_print(shell);
   11ebe:	4620      	mov	r0, r4
   11ec0:	f017 f8bd 	bl	2903e <shell_internal_help_print>
			return SHELL_CMD_HELP_PRINTED;
   11ec4:	2501      	movs	r5, #1
   11ec6:	e7b5      	b.n	11e34 <execute+0x5c>
			if (status != SHELL_WILDCARD_NOT_FOUND) {
   11ec8:	2803      	cmp	r0, #3
   11eca:	d01a      	beq.n	11f02 <execute+0x12a>
				++cmd_lvl;
   11ecc:	3601      	adds	r6, #1
				continue;
   11ece:	46b8      	mov	r8, r7
				wildcard_found = true;
   11ed0:	f04f 0901 	mov.w	r9, #1
   11ed4:	4647      	mov	r7, r8
		if (cmd_lvl >= argc) {
   11ed6:	9b04      	ldr	r3, [sp, #16]
   11ed8:	42b3      	cmp	r3, r6
   11eda:	d9cc      	bls.n	11e76 <execute+0x9e>
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
   11edc:	b18e      	cbz	r6, 11f02 <execute+0x12a>
		    (!strcmp(argv[cmd_lvl], "-h") ||
   11ede:	ab1c      	add	r3, sp, #112	; 0x70
   11ee0:	eb03 0886 	add.w	r8, r3, r6, lsl #2
   11ee4:	4952      	ldr	r1, [pc, #328]	; (12030 <execute+0x258>)
   11ee6:	f858 0c34 	ldr.w	r0, [r8, #-52]
   11eea:	f018 fa6e 	bl	2a3ca <strcmp>
		if (IS_ENABLED(CONFIG_SHELL_HELP) && (cmd_lvl > 0) &&
   11eee:	2800      	cmp	r0, #0
   11ef0:	d1b2      	bne.n	11e58 <execute+0x80>
			if (help_entry.help) {
   11ef2:	2d00      	cmp	r5, #0
   11ef4:	d1da      	bne.n	11eac <execute+0xd4>
			shell_internal_fprintf(shell, SHELL_ERROR,
   11ef6:	4a4f      	ldr	r2, [pc, #316]	; (12034 <execute+0x25c>)
					shell_internal_fprintf(shell,
   11ef8:	2102      	movs	r1, #2
   11efa:	4620      	mov	r0, r4
   11efc:	f017 fc5d 	bl	297ba <shell_internal_fprintf>
					return -ENOEXEC;
   11f00:	e796      	b.n	11e30 <execute+0x58>
		shell_cmd_get(shell, p_cmd, cmd_lvl, cmd_idx++, &p_static_entry,
   11f02:	ab05      	add	r3, sp, #20
   11f04:	9301      	str	r3, [sp, #4]
   11f06:	ab03      	add	r3, sp, #12
   11f08:	f107 0801 	add.w	r8, r7, #1
   11f0c:	9300      	str	r3, [sp, #0]
   11f0e:	4632      	mov	r2, r6
   11f10:	463b      	mov	r3, r7
   11f12:	4659      	mov	r1, fp
   11f14:	4620      	mov	r0, r4
   11f16:	f000 fd43 	bl	129a0 <shell_cmd_get>
		if ((cmd_idx == 0) || (p_static_entry == NULL)) {
   11f1a:	f1b8 0f00 	cmp.w	r8, #0
   11f1e:	d001      	beq.n	11f24 <execute+0x14c>
   11f20:	9b03      	ldr	r3, [sp, #12]
   11f22:	b983      	cbnz	r3, 11f46 <execute+0x16e>
			if (cmd_lvl == 0 &&
   11f24:	2e00      	cmp	r6, #0
   11f26:	d1a6      	bne.n	11e76 <execute+0x9e>

void shell_cmd_trim(const struct shell *shell);

static inline bool shell_in_select_mode(const struct shell *shell)
{
	return shell->ctx->selected_cmd == NULL ? false : true;
   11f28:	68a3      	ldr	r3, [r4, #8]
   11f2a:	69db      	ldr	r3, [r3, #28]
   11f2c:	b113      	cbz	r3, 11f34 <execute+0x15c>
				(!shell_in_select_mode(shell) ||
   11f2e:	68db      	ldr	r3, [r3, #12]
   11f30:	2b00      	cmp	r3, #0
   11f32:	d1a0      	bne.n	11e76 <execute+0x9e>
				shell_internal_fprintf(shell, SHELL_ERROR,
   11f34:	4b40      	ldr	r3, [pc, #256]	; (12038 <execute+0x260>)
   11f36:	9300      	str	r3, [sp, #0]
   11f38:	4a40      	ldr	r2, [pc, #256]	; (1203c <execute+0x264>)
   11f3a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   11f3c:	2102      	movs	r1, #2
   11f3e:	4620      	mov	r0, r4
   11f40:	f017 fc3b 	bl	297ba <shell_internal_fprintf>
				return -ENOEXEC;
   11f44:	e774      	b.n	11e30 <execute+0x58>
		if (strcmp(argv[cmd_lvl], p_static_entry->syntax) == 0) {
   11f46:	6819      	ldr	r1, [r3, #0]
   11f48:	ab1c      	add	r3, sp, #112	; 0x70
   11f4a:	eb03 0386 	add.w	r3, r3, r6, lsl #2
   11f4e:	f853 0c34 	ldr.w	r0, [r3, #-52]
   11f52:	f018 fa3a 	bl	2a3ca <strcmp>
   11f56:	2800      	cmp	r0, #0
   11f58:	d1bc      	bne.n	11ed4 <execute+0xfc>
			if (p_static_entry->handler != NULL) {
   11f5a:	9f03      	ldr	r7, [sp, #12]
   11f5c:	68fb      	ldr	r3, [r7, #12]
   11f5e:	b1bb      	cbz	r3, 11f90 <execute+0x1b8>
				if (IS_ENABLED(CONFIG_SHELL_WILDCARD) &&
   11f60:	f1b9 0f00 	cmp.w	r9, #0
   11f64:	d007      	beq.n	11f76 <execute+0x19e>
					shell_op_cursor_end_move(shell);
   11f66:	4620      	mov	r0, r4
   11f68:	f017 fb8e 	bl	29688 <shell_op_cursor_end_move>
					shell_op_cond_next_line(shell);
   11f6c:	4620      	mov	r0, r4
   11f6e:	f000 fd69 	bl	12a44 <shell_op_cond_next_line>
					shell_internal_fprintf(shell,
   11f72:	4a33      	ldr	r2, [pc, #204]	; (12040 <execute+0x268>)
   11f74:	e7c0      	b.n	11ef8 <execute+0x120>
				shell->ctx->active_cmd = *p_static_entry;
   11f76:	68a3      	ldr	r3, [r4, #8]
   11f78:	46be      	mov	lr, r7
   11f7a:	f103 0c08 	add.w	ip, r3, #8
   11f7e:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   11f82:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   11f86:	f8de 3000 	ldr.w	r3, [lr]
   11f8a:	f8cc 3000 	str.w	r3, [ip]
   11f8e:	46b2      	mov	sl, r6
			if (p_static_entry->help != NULL) {
   11f90:	f8d7 c004 	ldr.w	ip, [r7, #4]
   11f94:	f1bc 0f00 	cmp.w	ip, #0
   11f98:	d008      	beq.n	11fac <execute+0x1d4>
				help_entry = *p_static_entry;
   11f9a:	46be      	mov	lr, r7
   11f9c:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   11fa0:	ad0a      	add	r5, sp, #40	; 0x28
   11fa2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   11fa4:	f8de 3000 	ldr.w	r3, [lr]
   11fa8:	602b      	str	r3, [r5, #0]
   11faa:	4665      	mov	r5, ip
			cmd_lvl++;
   11fac:	3601      	adds	r6, #1
			p_cmd = p_static_entry->subcmd;
   11fae:	f8d7 b008 	ldr.w	fp, [r7, #8]
			cmd_idx = 0;
   11fb2:	f04f 0800 	mov.w	r8, #0
   11fb6:	e78d      	b.n	11ed4 <execute+0xfc>
	return exec_cmd(shell, argc - cmd_with_handler_lvl,
   11fb8:	9d04      	ldr	r5, [sp, #16]
	if (shell->ctx->active_cmd.args.mandatory) {
   11fba:	7e03      	ldrb	r3, [r0, #24]
	return exec_cmd(shell, argc - cmd_with_handler_lvl,
   11fbc:	eba5 050a 	sub.w	r5, r5, sl
	if (shell->ctx->active_cmd.args.mandatory) {
   11fc0:	b18b      	cbz	r3, 11fe6 <execute+0x20e>
		bool in_range = (argc >= mand) && (argc <= (mand + opt));
   11fc2:	429d      	cmp	r5, r3
		u8_t opt = shell->ctx->active_cmd.args.optional;
   11fc4:	7e42      	ldrb	r2, [r0, #25]
		bool in_range = (argc >= mand) && (argc <= (mand + opt));
   11fc6:	d302      	bcc.n	11fce <execute+0x1f6>
   11fc8:	4413      	add	r3, r2
	if (!arg_cnt_ok) {
   11fca:	429d      	cmp	r5, r3
   11fcc:	d90b      	bls.n	11fe6 <execute+0x20e>
		shell_internal_fprintf(shell, SHELL_ERROR,
   11fce:	6883      	ldr	r3, [r0, #8]
   11fd0:	4a1c      	ldr	r2, [pc, #112]	; (12044 <execute+0x26c>)
   11fd2:	2102      	movs	r1, #2
   11fd4:	4620      	mov	r0, r4
   11fd6:	f017 fbf0 	bl	297ba <shell_internal_fprintf>
			shell_internal_help_print(shell);
   11fda:	4620      	mov	r0, r4
   11fdc:	f017 f82f 	bl	2903e <shell_internal_help_print>
		return -EINVAL;
   11fe0:	f06f 0515 	mvn.w	r5, #21
   11fe4:	e726      	b.n	11e34 <execute+0x5c>
	z_impl_k_mutex_unlock(mutex);
   11fe6:	f500 703b 	add.w	r0, r0, #748	; 0x2ec
   11fea:	f014 fd61 	bl	26ab0 <z_impl_k_mutex_unlock>
		flag_cmd_ctx_set(shell, 1);
   11fee:	68a3      	ldr	r3, [r4, #8]
	return shell->ctx->internal.flags.cmd_ctx == 1 ? true : false;
}

static inline void flag_cmd_ctx_set(const struct shell *shell, bool val)
{
	shell->ctx->internal.flags.cmd_ctx = val ? 1 : 0;
   11ff0:	f8b3 2258 	ldrh.w	r2, [r3, #600]	; 0x258
   11ff4:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   11ff8:	f8a3 2258 	strh.w	r2, [r3, #600]	; 0x258
		ret_val = shell->ctx->active_cmd.handler(shell, argc, argv);
   11ffc:	aa0f      	add	r2, sp, #60	; 0x3c
   11ffe:	4629      	mov	r1, r5
   12000:	695b      	ldr	r3, [r3, #20]
   12002:	eb02 028a 	add.w	r2, r2, sl, lsl #2
   12006:	4620      	mov	r0, r4
   12008:	4798      	blx	r3
   1200a:	4605      	mov	r5, r0
		flag_cmd_ctx_set(shell, 0);
   1200c:	68a0      	ldr	r0, [r4, #8]
   1200e:	f8b0 3258 	ldrh.w	r3, [r0, #600]	; 0x258
   12012:	f36f 13c7 	bfc	r3, #7, #1
   12016:	f8a0 3258 	strh.w	r3, [r0, #600]	; 0x258
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
   1201a:	f500 703b 	add.w	r0, r0, #748	; 0x2ec
   1201e:	f017 f82b 	bl	29078 <k_mutex_lock.constprop.35>
   12022:	e707      	b.n	11e34 <execute+0x5c>
   12024:	0002f978 	.word	0x0002f978
   12028:	0002f8d7 	.word	0x0002f8d7
   1202c:	0002f8ee 	.word	0x0002f8ee
   12030:	0002f8eb 	.word	0x0002f8eb
   12034:	0002f8f5 	.word	0x0002f8f5
   12038:	0002f913 	.word	0x0002f913
   1203c:	0002fa26 	.word	0x0002fa26
   12040:	0002f927 	.word	0x0002f927
   12044:	0002f956 	.word	0x0002f956

00012048 <shell_process>:

	return 0;
}

void shell_process(const struct shell *shell)
{
   12048:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1204c:	6883      	ldr	r3, [r0, #8]
   1204e:	f3bf 8f5b 	dmb	ish
   12052:	b0ad      	sub	sp, #180	; 0xb4
   12054:	4604      	mov	r4, r0
   12056:	f503 7316 	add.w	r3, r3, #600	; 0x258
   1205a:	e853 2f00 	ldrex	r2, [r3]
   1205e:	f042 0208 	orr.w	r2, r2, #8
   12062:	e843 2100 	strex	r1, r2, [r3]
   12066:	2900      	cmp	r1, #0
   12068:	d1f7      	bne.n	1205a <shell_process+0x12>
   1206a:	f3bf 8f5b 	dmb	ish
	internal.flags.processing = 1U;

	(void)atomic_or((atomic_t *)&shell->ctx->internal.value,
			internal.value);

	switch (shell->ctx->state) {
   1206e:	68a3      	ldr	r3, [r4, #8]
   12070:	791b      	ldrb	r3, [r3, #4]
   12072:	2b02      	cmp	r3, #2
   12074:	f040 8383 	bne.w	1277e <shell_process+0x736>
	size_t count = 0;
   12078:	2300      	movs	r3, #0
   1207a:	930b      	str	r3, [sp, #44]	; 0x2c
		(void)shell->iface->api->read(shell->iface, &data,
   1207c:	6860      	ldr	r0, [r4, #4]
   1207e:	6803      	ldr	r3, [r0, #0]
   12080:	2201      	movs	r2, #1
   12082:	691d      	ldr	r5, [r3, #16]
   12084:	f10d 012b 	add.w	r1, sp, #43	; 0x2b
   12088:	ab0b      	add	r3, sp, #44	; 0x2c
   1208a:	47a8      	blx	r5
		if (count == 0) {
   1208c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1208e:	2b00      	cmp	r3, #0
   12090:	f000 8375 	beq.w	1277e <shell_process+0x736>
		if (ascii_filter(data) != 0) {
   12094:	f89d 102b 	ldrb.w	r1, [sp, #43]	; 0x2b
	return (u8_t) data > SHELL_ASCII_MAX_CHAR ? -EINVAL : 0;
   12098:	0608      	lsls	r0, r1, #24
   1209a:	d4ef      	bmi.n	1207c <shell_process+0x34>
		switch (shell->ctx->receive_state) {
   1209c:	68a0      	ldr	r0, [r4, #8]
   1209e:	7943      	ldrb	r3, [r0, #5]
   120a0:	2b02      	cmp	r3, #2
   120a2:	f200 836a 	bhi.w	1277a <shell_process+0x732>
   120a6:	e8df f013 	tbh	[pc, r3, lsl #1]
   120aa:	0003      	.short	0x0003
   120ac:	02ff02da 	.word	0x02ff02da
	if ((data != '\r') && (data != '\n')) {
   120b0:	290d      	cmp	r1, #13
   120b2:	d01b      	beq.n	120ec <shell_process+0xa4>
   120b4:	290a      	cmp	r1, #10
   120b6:	d019      	beq.n	120ec <shell_process+0xa4>
	return shell->ctx->internal.flags.last_nl;
}

static inline void flag_last_nl_set(const struct shell *shell, u8_t val)
{
	shell->ctx->internal.flags.last_nl = val;
   120b8:	f8b0 3258 	ldrh.w	r3, [r0, #600]	; 0x258
   120bc:	f36f 230f 	bfc	r3, #8, #8
   120c0:	f8a0 3258 	strh.w	r3, [r0, #600]	; 0x258
			switch (data) {
   120c4:	2909      	cmp	r1, #9
   120c6:	d055      	beq.n	12174 <shell_process+0x12c>
   120c8:	d83a      	bhi.n	12140 <shell_process+0xf8>
   120ca:	2900      	cmp	r1, #0
   120cc:	d0d6      	beq.n	1207c <shell_process+0x34>
   120ce:	2908      	cmp	r1, #8
   120d0:	f000 8229 	beq.w	12526 <shell_process+0x4de>
   120d4:	f1a1 0320 	sub.w	r3, r1, #32
				if (isprint((int) data)) {
   120d8:	2b5e      	cmp	r3, #94	; 0x5e
   120da:	f200 8233 	bhi.w	12544 <shell_process+0x4fc>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
   120de:	f8b0 3258 	ldrh.w	r3, [r0, #600]	; 0x258
   120e2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   120e6:	f8a0 3258 	strh.w	r3, [r0, #600]	; 0x258
   120ea:	e11f      	b.n	1232c <shell_process+0x2e4>
	return shell->ctx->internal.flags.last_nl;
   120ec:	f8d0 3258 	ldr.w	r3, [r0, #600]	; 0x258
	if ((flag_last_nl_get(shell) == 0U) ||
   120f0:	f413 4f7f 	tst.w	r3, #65280	; 0xff00
   120f4:	d005      	beq.n	12102 <shell_process+0xba>
   120f6:	f8d0 3258 	ldr.w	r3, [r0, #600]	; 0x258
   120fa:	f3c3 2307 	ubfx	r3, r3, #8, #8
   120fe:	4299      	cmp	r1, r3
   12100:	d1e0      	bne.n	120c4 <shell_process+0x7c>
	shell->ctx->internal.flags.last_nl = val;
   12102:	f8b0 3258 	ldrh.w	r3, [r0, #600]	; 0x258
   12106:	f361 230f 	bfi	r3, r1, #8, #8
   1210a:	f8a0 3258 	strh.w	r3, [r0, #600]	; 0x258
				if (!shell->ctx->cmd_buff_len &&
   1210e:	8e43      	ldrh	r3, [r0, #50]	; 0x32
   12110:	b993      	cbnz	r3, 12138 <shell_process+0xf0>
   12112:	69c2      	ldr	r2, [r0, #28]
   12114:	b982      	cbnz	r2, 12138 <shell_process+0xf0>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
   12116:	f8b0 3258 	ldrh.w	r3, [r0, #600]	; 0x258
   1211a:	f362 1386 	bfi	r3, r2, #6, #1
   1211e:	f8a0 3258 	strh.w	r3, [r0, #600]	; 0x258
	shell_history_mode_exit(shell->history);
   12122:	68e0      	ldr	r0, [r4, #12]
   12124:	f017 fc6c 	bl	29a00 <shell_history_mode_exit>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
   12128:	4985      	ldr	r1, [pc, #532]	; (12340 <shell_process+0x2f8>)
   1212a:	6960      	ldr	r0, [r4, #20]
   1212c:	f016 ff7a 	bl	29024 <shell_raw_fprintf>
		state_set(shell, SHELL_STATE_ACTIVE);
   12130:	4620      	mov	r0, r4
   12132:	f016 ff8d 	bl	29050 <state_set.constprop.31>
		break;
   12136:	e7a1      	b.n	1207c <shell_process+0x34>
					(void)execute(shell);
   12138:	4620      	mov	r0, r4
   1213a:	f7ff fe4d 	bl	11dd8 <execute>
				state_set(shell, SHELL_STATE_ACTIVE);
   1213e:	e7f7      	b.n	12130 <shell_process+0xe8>
   12140:	291b      	cmp	r1, #27
   12142:	d014      	beq.n	1216e <shell_process+0x126>
   12144:	297f      	cmp	r1, #127	; 0x7f
   12146:	d1c5      	bne.n	120d4 <shell_process+0x8c>
	return shell->ctx->internal.flags.echo == 1 ? true : false;
   12148:	f8d0 3258 	ldr.w	r3, [r0, #600]	; 0x258
				if (flag_echo_get(shell)) {
   1214c:	075f      	lsls	r7, r3, #29
   1214e:	d595      	bpl.n	1207c <shell_process+0x34>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
   12150:	f8b0 3258 	ldrh.w	r3, [r0, #600]	; 0x258
   12154:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   12158:	f8a0 3258 	strh.w	r3, [r0, #600]	; 0x258
	return shell->ctx->internal.flags.mode_delete == 1 ? true : false;
   1215c:	f8d0 3258 	ldr.w	r3, [r0, #600]	; 0x258
					if (flag_mode_delete_get(shell)) {
   12160:	069e      	lsls	r6, r3, #26
   12162:	f100 81eb 	bmi.w	1253c <shell_process+0x4f4>
		shell_op_char_delete(shell);
   12166:	4620      	mov	r0, r4
   12168:	f017 fb68 	bl	2983c <shell_op_char_delete>
		break;
   1216c:	e786      	b.n	1207c <shell_process+0x34>
	shell->ctx->receive_state = state;
   1216e:	2301      	movs	r3, #1
   12170:	7143      	strb	r3, [r0, #5]
   12172:	e783      	b.n	1207c <shell_process+0x34>
	return shell->ctx->internal.flags.echo == 1 ? true : false;
   12174:	f8d0 3258 	ldr.w	r3, [r0, #600]	; 0x258
   12178:	f3c3 0980 	ubfx	r9, r3, #2, #1
				if (flag_echo_get(shell)) {
   1217c:	f1b9 0f00 	cmp.w	r9, #0
   12180:	f43f af7c 	beq.w	1207c <shell_process+0x34>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
   12184:	f8b0 3258 	ldrh.w	r3, [r0, #600]	; 0x258
   12188:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1218c:	f8a0 3258 	strh.w	r3, [r0, #600]	; 0x258
	if (compl_space == 0U) {
   12190:	8e43      	ldrh	r3, [r0, #50]	; 0x32
   12192:	2bff      	cmp	r3, #255	; 0xff
   12194:	f43f af72 	beq.w	1207c <shell_process+0x34>
	memcpy(shell->ctx->temp_buff, shell->ctx->cmd_buff,
   12198:	8e82      	ldrh	r2, [r0, #52]	; 0x34
   1219a:	f100 0138 	add.w	r1, r0, #56	; 0x38
   1219e:	f500 709c 	add.w	r0, r0, #312	; 0x138
   121a2:	f018 f954 	bl	2a44e <memcpy>
	shell->ctx->temp_buff[shell->ctx->cmd_buff_pos] = '\0';
   121a6:	68a2      	ldr	r2, [r4, #8]
   121a8:	8e93      	ldrh	r3, [r2, #52]	; 0x34
   121aa:	4413      	add	r3, r2
   121ac:	2100      	movs	r1, #0
   121ae:	f883 1138 	strb.w	r1, [r3, #312]	; 0x138
	(void)shell_make_argv(argc, *argv, shell->ctx->temp_buff,
   121b2:	f502 729c 	add.w	r2, r2, #312	; 0x138
   121b6:	230c      	movs	r3, #12
   121b8:	a91f      	add	r1, sp, #124	; 0x7c
   121ba:	a80d      	add	r0, sp, #52	; 0x34
   121bc:	f017 f828 	bl	29210 <shell_make_argv>
	int space = isspace((int)shell->ctx->cmd_buff[
   121c0:	68a3      	ldr	r3, [r4, #8]
						shell->ctx->cmd_buff_pos - 1]);
   121c2:	8e9a      	ldrh	r2, [r3, #52]	; 0x34
	int space = isspace((int)shell->ctx->cmd_buff[
   121c4:	4413      	add	r3, r2
   121c6:	f893 3037 	ldrb.w	r3, [r3, #55]	; 0x37
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
   121ca:	2b20      	cmp	r3, #32
   121cc:	d054      	beq.n	12278 <shell_process+0x230>
   121ce:	3b09      	subs	r3, #9
   121d0:	2b04      	cmp	r3, #4
   121d2:	bf8c      	ite	hi
   121d4:	2300      	movhi	r3, #0
   121d6:	2301      	movls	r3, #1
	if ((*argc == 0) || ((space == 0) && (*argc == 1))) {
   121d8:	990d      	ldr	r1, [sp, #52]	; 0x34
   121da:	b119      	cbz	r1, 121e4 <shell_process+0x19c>
   121dc:	2b00      	cmp	r3, #0
   121de:	d14e      	bne.n	1227e <shell_process+0x236>
   121e0:	2901      	cmp	r1, #1
   121e2:	d14b      	bne.n	1227c <shell_process+0x234>
		*complete_arg_idx = SHELL_CMD_ROOT_LVL;
   121e4:	2500      	movs	r5, #0
   121e6:	950c      	str	r5, [sp, #48]	; 0x30
	find_completion_candidates(shell, cmd, argv[arg_idx], &first, &cnt,
   121e8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   121ea:	aa2c      	add	r2, sp, #176	; 0xb0
   121ec:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	*cnt = 0;
   121f0:	2600      	movs	r6, #0
	find_completion_candidates(shell, cmd, argv[arg_idx], &first, &cnt,
   121f2:	f853 ac34 	ldr.w	sl, [r3, #-52]
	size_t incompl_cmd_len = shell_strlen(incompl_cmd);
   121f6:	4650      	mov	r0, sl
   121f8:	f016 ff0e 	bl	29018 <shell_strlen>
	size_t idx = 0;
   121fc:	46b0      	mov	r8, r6
	size_t incompl_cmd_len = shell_strlen(incompl_cmd);
   121fe:	9004      	str	r0, [sp, #16]
	*longest = 0U;
   12200:	9605      	str	r6, [sp, #20]
	size_t first = 0;
   12202:	9603      	str	r6, [sp, #12]
	bool found = false;
   12204:	46b3      	mov	fp, r6
		shell_cmd_get(shell, cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
   12206:	af1a      	add	r7, sp, #104	; 0x68
   12208:	2d00      	cmp	r5, #0
   1220a:	d045      	beq.n	12298 <shell_process+0x250>
   1220c:	68a9      	ldr	r1, [r5, #8]
   1220e:	1c2b      	adds	r3, r5, #0
   12210:	bf18      	it	ne
   12212:	2301      	movne	r3, #1
   12214:	e9cd 7301 	strd	r7, r3, [sp, #4]
   12218:	ab15      	add	r3, sp, #84	; 0x54
   1221a:	9300      	str	r3, [sp, #0]
   1221c:	9a02      	ldr	r2, [sp, #8]
   1221e:	4643      	mov	r3, r8
   12220:	4620      	mov	r0, r4
   12222:	f000 fbbd 	bl	129a0 <shell_cmd_get>
		if (!candidate) {
   12226:	9b15      	ldr	r3, [sp, #84]	; 0x54
   12228:	2b00      	cmp	r3, #0
   1222a:	d039      	beq.n	122a0 <shell_process+0x258>
	return entry->syntax &&
   1222c:	6818      	ldr	r0, [r3, #0]
		(entry->handler == NULL) && (entry->subcmd == NULL);
   1222e:	2800      	cmp	r0, #0
   12230:	d034      	beq.n	1229c <shell_process+0x254>
	return entry->syntax &&
   12232:	68da      	ldr	r2, [r3, #12]
   12234:	2a00      	cmp	r2, #0
   12236:	d131      	bne.n	1229c <shell_process+0x254>
		(entry->handler == NULL) && (entry->subcmd == NULL);
   12238:	689b      	ldr	r3, [r3, #8]
   1223a:	fab3 f383 	clz	r3, r3
   1223e:	095b      	lsrs	r3, r3, #5
	return (strncmp(candidate, str, len) == 0) ? true : false;
   12240:	9a04      	ldr	r2, [sp, #16]
   12242:	9302      	str	r3, [sp, #8]
   12244:	4651      	mov	r1, sl
   12246:	f018 f8cc 	bl	2a3e2 <strncmp>
		if (!is_empty && is_candidate) {
   1224a:	9b02      	ldr	r3, [sp, #8]
   1224c:	4303      	orrs	r3, r0
   1224e:	d110      	bne.n	12272 <shell_process+0x22a>
			size_t slen = strlen(candidate->syntax);
   12250:	9b15      	ldr	r3, [sp, #84]	; 0x54
   12252:	6818      	ldr	r0, [r3, #0]
   12254:	f018 f8b2 	bl	2a3bc <strlen>
			*longest = (slen > *longest) ? slen : *longest;
   12258:	9b05      	ldr	r3, [sp, #20]
   1225a:	4283      	cmp	r3, r0
   1225c:	bf38      	it	cc
   1225e:	4603      	movcc	r3, r0
   12260:	b29b      	uxth	r3, r3
   12262:	9305      	str	r3, [sp, #20]
			(*cnt)++;
   12264:	3601      	adds	r6, #1
			if (!found) {
   12266:	f1bb 0f00 	cmp.w	fp, #0
   1226a:	d102      	bne.n	12272 <shell_process+0x22a>
				*first_idx = idx;
   1226c:	f8cd 800c 	str.w	r8, [sp, #12]
			found = true;
   12270:	46cb      	mov	fp, r9
		idx++;
   12272:	f108 0801 	add.w	r8, r8, #1
   12276:	e7c7      	b.n	12208 <shell_process+0x1c0>
   12278:	2301      	movs	r3, #1
   1227a:	e7ad      	b.n	121d8 <shell_process+0x190>
	search_argc = space ? *argc : *argc - 1;
   1227c:	3901      	subs	r1, #1
	*cmd = shell_get_last_command(shell, search_argc, *argv,
   1227e:	2300      	movs	r3, #0
   12280:	9301      	str	r3, [sp, #4]
   12282:	ab10      	add	r3, sp, #64	; 0x40
   12284:	9300      	str	r3, [sp, #0]
   12286:	aa1f      	add	r2, sp, #124	; 0x7c
   12288:	ab0c      	add	r3, sp, #48	; 0x30
   1228a:	4620      	mov	r0, r4
   1228c:	f017 f8ac 	bl	293e8 <shell_get_last_command>
	if ((*cmd == NULL) && (search_argc != 0)) {
   12290:	4605      	mov	r5, r0
   12292:	2800      	cmp	r0, #0
   12294:	d1a8      	bne.n	121e8 <shell_process+0x1a0>
   12296:	e6f1      	b.n	1207c <shell_process+0x34>
		shell_cmd_get(shell, cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
   12298:	4629      	mov	r1, r5
   1229a:	e7b8      	b.n	1220e <shell_process+0x1c6>
		(entry->handler == NULL) && (entry->subcmd == NULL);
   1229c:	2300      	movs	r3, #0
   1229e:	e7cf      	b.n	12240 <shell_process+0x1f8>
	if (cnt == 1) {
   122a0:	2e01      	cmp	r6, #1
   122a2:	d14f      	bne.n	12344 <shell_process+0x2fc>
		autocomplete(shell, cmd, argv[arg_idx], first);
   122a4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   122a6:	aa2c      	add	r2, sp, #176	; 0xb0
   122a8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	u16_t arg_len = shell_strlen(arg);
   122ac:	f853 0c34 	ldr.w	r0, [r3, #-52]
   122b0:	f016 feb2 	bl	29018 <shell_strlen>
   122b4:	4606      	mov	r6, r0
	shell_cmd_get(shell, cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
   122b6:	b105      	cbz	r5, 122ba <shell_process+0x272>
   122b8:	68ad      	ldr	r5, [r5, #8]
   122ba:	68a3      	ldr	r3, [r4, #8]
   122bc:	3308      	adds	r3, #8
   122be:	e9cd 7300 	strd	r7, r3, [sp]
   122c2:	4629      	mov	r1, r5
   122c4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   122c8:	4620      	mov	r0, r4
   122ca:	f000 fb69 	bl	129a0 <shell_cmd_get>
	cmd_len = shell_strlen(match->syntax);
   122ce:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   122d0:	6818      	ldr	r0, [r3, #0]
   122d2:	f016 fea1 	bl	29018 <shell_strlen>
	if (cmd_len != arg_len) {
   122d6:	4286      	cmp	r6, r0
   122d8:	d007      	beq.n	122ea <shell_process+0x2a2>
					   match->syntax + arg_len,
   122da:	9b1a      	ldr	r3, [sp, #104]	; 0x68
		shell_op_completion_insert(shell,
   122dc:	6819      	ldr	r1, [r3, #0]
   122de:	1b82      	subs	r2, r0, r6
   122e0:	b292      	uxth	r2, r2
   122e2:	4431      	add	r1, r6
   122e4:	4620      	mov	r0, r4
   122e6:	f017 faa7 	bl	29838 <shell_op_completion_insert>
	if (!isspace((int) shell->ctx->cmd_buff[
   122ea:	68a3      	ldr	r3, [r4, #8]
					shell->ctx->cmd_buff_pos])) {
   122ec:	8e9a      	ldrh	r2, [r3, #52]	; 0x34
	if (!isspace((int) shell->ctx->cmd_buff[
   122ee:	441a      	add	r2, r3
   122f0:	f892 2038 	ldrb.w	r2, [r2, #56]	; 0x38
   122f4:	2a20      	cmp	r2, #32
   122f6:	d01d      	beq.n	12334 <shell_process+0x2ec>
   122f8:	3a09      	subs	r2, #9
   122fa:	2a04      	cmp	r2, #4
   122fc:	d91a      	bls.n	12334 <shell_process+0x2ec>
	return ((shell->ctx->internal.flags.insert_mode == 1) ? true : false);
   122fe:	f8d3 2258 	ldr.w	r2, [r3, #600]	; 0x258
		if (flag_insert_mode_get(shell)) {
   12302:	07d2      	lsls	r2, r2, #31
   12304:	d511      	bpl.n	1232a <shell_process+0x2e2>
	shell->ctx->internal.flags.insert_mode = val ? 1 : 0;
   12306:	f8b3 2258 	ldrh.w	r2, [r3, #600]	; 0x258
   1230a:	f36f 0200 	bfc	r2, #0, #1
   1230e:	f8a3 2258 	strh.w	r2, [r3, #600]	; 0x258
			shell_op_char_insert(shell, ' ');
   12312:	2120      	movs	r1, #32
   12314:	4620      	mov	r0, r4
   12316:	f000 fca3 	bl	12c60 <shell_op_char_insert>
			flag_insert_mode_set(shell, true);
   1231a:	68a2      	ldr	r2, [r4, #8]
   1231c:	f8b2 3258 	ldrh.w	r3, [r2, #600]	; 0x258
   12320:	f043 0301 	orr.w	r3, r3, #1
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
   12324:	f8a2 3258 	strh.w	r3, [r2, #600]	; 0x258
   12328:	e6a8      	b.n	1207c <shell_process+0x34>
			shell_op_char_insert(shell, ' ');
   1232a:	2120      	movs	r1, #32
					shell_op_char_insert(shell, data);
   1232c:	4620      	mov	r0, r4
   1232e:	f000 fc97 	bl	12c60 <shell_op_char_insert>
   12332:	e6a3      	b.n	1207c <shell_process+0x34>
		shell_op_cursor_move(shell, 1);
   12334:	2101      	movs	r1, #1
   12336:	4620      	mov	r0, r4
   12338:	f017 f942 	bl	295c0 <shell_op_cursor_move>
   1233c:	e69e      	b.n	1207c <shell_process+0x34>
   1233e:	bf00      	nop
   12340:	0002f978 	.word	0x0002f978
   12344:	9306      	str	r3, [sp, #24]
	} else if (cnt > 1) {
   12346:	f67f ae99 	bls.w	1207c <shell_process+0x34>
		tab_options_print(shell, cmd, argv[arg_idx], first, cnt,
   1234a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
	longest_option += shell_strlen(tab);
   1234c:	f8df 8354 	ldr.w	r8, [pc, #852]	; 126a4 <shell_process+0x65c>
		tab_options_print(shell, cmd, argv[arg_idx], first, cnt,
   12350:	ab2c      	add	r3, sp, #176	; 0xb0
   12352:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   12356:	f852 3c34 	ldr.w	r3, [r2, #-52]
   1235a:	9304      	str	r3, [sp, #16]
	size_t str_len = shell_strlen(str);
   1235c:	4618      	mov	r0, r3
   1235e:	f016 fe5b 	bl	29018 <shell_strlen>
		shell->ctx->vt100_ctx.printed_cmd = 0;
   12362:	68a2      	ldr	r2, [r4, #8]
   12364:	9b06      	ldr	r3, [sp, #24]
   12366:	f8dd 900c 	ldr.w	r9, [sp, #12]
	size_t str_len = shell_strlen(str);
   1236a:	9008      	str	r0, [sp, #32]
		shell->ctx->vt100_ctx.printed_cmd = 0;
   1236c:	8613      	strh	r3, [r2, #48]	; 0x30
   1236e:	9606      	str	r6, [sp, #24]
		shell_cmd_get(shell, cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
   12370:	2d00      	cmp	r5, #0
   12372:	f000 8086 	beq.w	12482 <shell_process+0x43a>
   12376:	68a9      	ldr	r1, [r5, #8]
   12378:	68a3      	ldr	r3, [r4, #8]
   1237a:	9a02      	ldr	r2, [sp, #8]
   1237c:	3308      	adds	r3, #8
   1237e:	9301      	str	r3, [sp, #4]
   12380:	ab1a      	add	r3, sp, #104	; 0x68
   12382:	9300      	str	r3, [sp, #0]
   12384:	4620      	mov	r0, r4
   12386:	464b      	mov	r3, r9
   12388:	f000 fb0a 	bl	129a0 <shell_cmd_get>
		is_empty = is_empty_cmd(match);
   1238c:	9b1a      	ldr	r3, [sp, #104]	; 0x68
	return entry->syntax &&
   1238e:	6818      	ldr	r0, [r3, #0]
		idx++;
   12390:	f109 0901 	add.w	r9, r9, #1
		(entry->handler == NULL) && (entry->subcmd == NULL);
   12394:	2800      	cmp	r0, #0
   12396:	d176      	bne.n	12486 <shell_process+0x43e>
		tab_item_print(shell, match->syntax, longest);
   12398:	9b1a      	ldr	r3, [sp, #104]	; 0x68
   1239a:	f8d3 a000 	ldr.w	sl, [r3]
	if (option == NULL) {
   1239e:	f1ba 0f00 	cmp.w	sl, #0
   123a2:	f040 8082 	bne.w	124aa <shell_process+0x462>
		shell->ctx->vt100_ctx.printed_cmd = 0;
   123a6:	68a3      	ldr	r3, [r4, #8]
   123a8:	f8a3 a030 	strh.w	sl, [r3, #48]	; 0x30
	while (cnt) {
   123ac:	9b06      	ldr	r3, [sp, #24]
   123ae:	3b01      	subs	r3, #1
   123b0:	9306      	str	r3, [sp, #24]
   123b2:	d1dd      	bne.n	12370 <shell_process+0x328>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
   123b4:	49b5      	ldr	r1, [pc, #724]	; (1268c <shell_process+0x644>)
   123b6:	6960      	ldr	r0, [r4, #20]
   123b8:	f016 fe34 	bl	29024 <shell_raw_fprintf>
	shell_print_prompt_and_cmd(shell);
   123bc:	4620      	mov	r0, r4
   123be:	f000 fc81 	bl	12cc4 <shell_print_prompt_and_cmd>
		partial_autocomplete(shell, cmd, argv[arg_idx], first, cnt);
   123c2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   123c4:	aa2c      	add	r2, sp, #176	; 0xb0
   123c6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
	u16_t arg_len = shell_strlen(arg);
   123ca:	f853 0c34 	ldr.w	r0, [r3, #-52]
   123ce:	f016 fe23 	bl	29018 <shell_strlen>
	size_t idx = first + 1;
   123d2:	9b03      	ldr	r3, [sp, #12]
	u16_t arg_len = shell_strlen(arg);
   123d4:	4680      	mov	r8, r0
	size_t idx = first + 1;
   123d6:	f103 0901 	add.w	r9, r3, #1
	shell_cmd_get(shell, cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
   123da:	2d00      	cmp	r5, #0
   123dc:	f000 809d 	beq.w	1251a <shell_process+0x4d2>
   123e0:	68a9      	ldr	r1, [r5, #8]
   123e2:	ab15      	add	r3, sp, #84	; 0x54
   123e4:	9301      	str	r3, [sp, #4]
   123e6:	ab0e      	add	r3, sp, #56	; 0x38
   123e8:	9300      	str	r3, [sp, #0]
   123ea:	4620      	mov	r0, r4
   123ec:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   123f0:	f000 fad6 	bl	129a0 <shell_cmd_get>
	strncpy(shell->ctx->temp_buff, match->syntax,
   123f4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   123f6:	68a0      	ldr	r0, [r4, #8]
   123f8:	6819      	ldr	r1, [r3, #0]
   123fa:	22ff      	movs	r2, #255	; 0xff
   123fc:	f500 709c 	add.w	r0, r0, #312	; 0x138
   12400:	f017 ffbb 	bl	2a37a <strncpy>
	*str = match->syntax;
   12404:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   12406:	f8d3 a000 	ldr.w	sl, [r3]
	u16_t common = UINT16_MAX;
   1240a:	f64f 77ff 	movw	r7, #65535	; 0xffff
		shell_cmd_get(shell, cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
   1240e:	2d00      	cmp	r5, #0
   12410:	f000 8087 	beq.w	12522 <shell_process+0x4da>
   12414:	68a9      	ldr	r1, [r5, #8]
   12416:	9a02      	ldr	r2, [sp, #8]
   12418:	ab1a      	add	r3, sp, #104	; 0x68
   1241a:	9301      	str	r3, [sp, #4]
   1241c:	ab0f      	add	r3, sp, #60	; 0x3c
   1241e:	9300      	str	r3, [sp, #0]
   12420:	4620      	mov	r0, r4
   12422:	464b      	mov	r3, r9
   12424:	f000 fabc 	bl	129a0 <shell_cmd_get>
		if (match2 == NULL) {
   12428:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
		shell_cmd_get(shell, cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
   1242a:	f109 0b01 	add.w	fp, r9, #1
		if (match2 == NULL) {
   1242e:	b1e3      	cbz	r3, 1246a <shell_process+0x422>
		curr_common = str_common(shell->ctx->temp_buff, match2->syntax,
   12430:	6818      	ldr	r0, [r3, #0]
static size_t str_common(const char *s1, const char *s2, size_t n)
   12432:	68a3      	ldr	r3, [r4, #8]
	size_t common = 0;
   12434:	2200      	movs	r2, #0
   12436:	f503 739c 	add.w	r3, r3, #312	; 0x138
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
   1243a:	f813 cb01 	ldrb.w	ip, [r3], #1
   1243e:	5c81      	ldrb	r1, [r0, r2]
   12440:	4561      	cmp	r1, ip
   12442:	d105      	bne.n	12450 <shell_process+0x408>
   12444:	b121      	cbz	r1, 12450 <shell_process+0x408>
		common++;
   12446:	3201      	adds	r2, #1
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
   12448:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1244c:	428a      	cmp	r2, r1
   1244e:	d1f4      	bne.n	1243a <shell_process+0x3f2>
		if ((arg_len == 0U) || (curr_common >= arg_len)) {
   12450:	f1b8 0f00 	cmp.w	r8, #0
   12454:	d001      	beq.n	1245a <shell_process+0x412>
   12456:	4542      	cmp	r2, r8
   12458:	db61      	blt.n	1251e <shell_process+0x4d6>
			common = (curr_common < common) ? curr_common : common;
   1245a:	4297      	cmp	r7, r2
			--cnt;
   1245c:	f106 36ff 	add.w	r6, r6, #4294967295	; 0xffffffff
			common = (curr_common < common) ? curr_common : common;
   12460:	bfa8      	it	ge
   12462:	4617      	movge	r7, r2
	while (cnt > 1) {
   12464:	2e01      	cmp	r6, #1
			common = (curr_common < common) ? curr_common : common;
   12466:	b2bf      	uxth	r7, r7
	while (cnt > 1) {
   12468:	d159      	bne.n	1251e <shell_process+0x4d6>
	if (common) {
   1246a:	2f00      	cmp	r7, #0
   1246c:	f43f ae06 	beq.w	1207c <shell_process+0x34>
		shell_op_completion_insert(shell, &completion[arg_len],
   12470:	eba7 0208 	sub.w	r2, r7, r8
   12474:	b292      	uxth	r2, r2
   12476:	eb0a 0108 	add.w	r1, sl, r8
   1247a:	4620      	mov	r0, r4
   1247c:	f017 f9dc 	bl	29838 <shell_op_completion_insert>
   12480:	e5fc      	b.n	1207c <shell_process+0x34>
		shell_cmd_get(shell, cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
   12482:	4629      	mov	r1, r5
   12484:	e778      	b.n	12378 <shell_process+0x330>
	return entry->syntax &&
   12486:	68da      	ldr	r2, [r3, #12]
   12488:	b91a      	cbnz	r2, 12492 <shell_process+0x44a>
		(entry->handler == NULL) && (entry->subcmd == NULL);
   1248a:	689b      	ldr	r3, [r3, #8]
   1248c:	2b00      	cmp	r3, #0
   1248e:	f43f af6f 	beq.w	12370 <shell_process+0x328>
		if (is_empty || (str && match->syntax &&
   12492:	9b04      	ldr	r3, [sp, #16]
   12494:	2b00      	cmp	r3, #0
   12496:	f43f af7f 	beq.w	12398 <shell_process+0x350>
	return (strncmp(candidate, str, len) == 0) ? true : false;
   1249a:	9a08      	ldr	r2, [sp, #32]
   1249c:	9904      	ldr	r1, [sp, #16]
   1249e:	f017 ffa0 	bl	2a3e2 <strncmp>
		if (is_empty || (str && match->syntax &&
   124a2:	2800      	cmp	r0, #0
   124a4:	f43f af78 	beq.w	12398 <shell_process+0x350>
   124a8:	e762      	b.n	12370 <shell_process+0x328>
	longest_option += shell_strlen(tab);
   124aa:	4640      	mov	r0, r8
   124ac:	f016 fdb4 	bl	29018 <shell_strlen>
   124b0:	9b05      	ldr	r3, [sp, #20]
   124b2:	4418      	add	r0, r3
	columns = (shell->ctx->vt100_ctx.cons.terminal_wid
   124b4:	68a3      	ldr	r3, [r4, #8]
	longest_option += shell_strlen(tab);
   124b6:	fa1f fb80 	uxth.w	fp, r0
			- shell_strlen(tab)) / longest_option;
   124ba:	4640      	mov	r0, r8
	columns = (shell->ctx->vt100_ctx.cons.terminal_wid
   124bc:	8d5f      	ldrh	r7, [r3, #42]	; 0x2a
			- shell_strlen(tab)) / longest_option;
   124be:	f016 fdab 	bl	29018 <shell_strlen>
   124c2:	9009      	str	r0, [sp, #36]	; 0x24
	diff = longest_option - shell_strlen(option);
   124c4:	4650      	mov	r0, sl
   124c6:	f016 fda7 	bl	29018 <shell_strlen>
   124ca:	ebab 0000 	sub.w	r0, fp, r0
   124ce:	b283      	uxth	r3, r0
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
   124d0:	68a1      	ldr	r1, [r4, #8]
	diff = longest_option - shell_strlen(option);
   124d2:	9307      	str	r3, [sp, #28]
			- shell_strlen(tab)) / longest_option;
   124d4:	9b09      	ldr	r3, [sp, #36]	; 0x24
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
   124d6:	8e0a      	ldrh	r2, [r1, #48]	; 0x30
			- shell_strlen(tab)) / longest_option;
   124d8:	1aff      	subs	r7, r7, r3
   124da:	fb97 fbfb 	sdiv	fp, r7, fp
	if (shell->ctx->vt100_ctx.printed_cmd++ % columns == 0U) {
   124de:	fa1f fb8b 	uxth.w	fp, fp
   124e2:	1c50      	adds	r0, r2, #1
   124e4:	fbb2 f3fb 	udiv	r3, r2, fp
   124e8:	fb0b 2213 	mls	r2, fp, r3, r2
   124ec:	b292      	uxth	r2, r2
   124ee:	8608      	strh	r0, [r1, #48]	; 0x30
   124f0:	b962      	cbnz	r2, 1250c <shell_process+0x4c4>
		shell_internal_fprintf(shell, SHELL_OPTION, "\n%s%s", tab,
   124f2:	f8cd a000 	str.w	sl, [sp]
   124f6:	4643      	mov	r3, r8
   124f8:	4a65      	ldr	r2, [pc, #404]	; (12690 <shell_process+0x648>)
   124fa:	2107      	movs	r1, #7
   124fc:	4620      	mov	r0, r4
   124fe:	f017 f95c 	bl	297ba <shell_internal_fprintf>
	shell_op_cursor_horiz_move(shell, diff);
   12502:	9907      	ldr	r1, [sp, #28]
   12504:	4620      	mov	r0, r4
   12506:	f000 fa8d 	bl	12a24 <shell_op_cursor_horiz_move>
   1250a:	e74f      	b.n	123ac <shell_process+0x364>
		shell_internal_fprintf(shell, SHELL_OPTION, "%s", option);
   1250c:	4653      	mov	r3, sl
   1250e:	4a61      	ldr	r2, [pc, #388]	; (12694 <shell_process+0x64c>)
   12510:	2107      	movs	r1, #7
   12512:	4620      	mov	r0, r4
   12514:	f017 f951 	bl	297ba <shell_internal_fprintf>
   12518:	e7f3      	b.n	12502 <shell_process+0x4ba>
	shell_cmd_get(shell, cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
   1251a:	4629      	mov	r1, r5
   1251c:	e761      	b.n	123e2 <shell_process+0x39a>
   1251e:	46d9      	mov	r9, fp
   12520:	e775      	b.n	1240e <shell_process+0x3c6>
		shell_cmd_get(shell, cmd ? cmd->subcmd : NULL, cmd ? 1 : 0,
   12522:	4629      	mov	r1, r5
   12524:	e777      	b.n	12416 <shell_process+0x3ce>
	return shell->ctx->internal.flags.echo == 1 ? true : false;
   12526:	f8d0 3258 	ldr.w	r3, [r0, #600]	; 0x258
				if (flag_echo_get(shell)) {
   1252a:	075b      	lsls	r3, r3, #29
   1252c:	f57f ada6 	bpl.w	1207c <shell_process+0x34>
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
   12530:	f8b0 3258 	ldrh.w	r3, [r0, #600]	; 0x258
   12534:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   12538:	f8a0 3258 	strh.w	r3, [r0, #600]	; 0x258
						shell_op_char_backspace(shell);
   1253c:	4620      	mov	r0, r4
   1253e:	f017 f998 	bl	29872 <shell_op_char_backspace>
   12542:	e59b      	b.n	1207c <shell_process+0x34>
	return shell->ctx->internal.flags.echo == 1 ? true : false;
   12544:	f8d0 3258 	ldr.w	r3, [r0, #600]	; 0x258
				} else if (flag_echo_get(shell)) {
   12548:	075d      	lsls	r5, r3, #29
   1254a:	f57f ad97 	bpl.w	1207c <shell_process+0x34>
	switch (data) {
   1254e:	3901      	subs	r1, #1
   12550:	2916      	cmp	r1, #22
   12552:	f63f ad93 	bhi.w	1207c <shell_process+0x34>
   12556:	a301      	add	r3, pc, #4	; (adr r3, 1255c <shell_process+0x514>)
   12558:	f853 f021 	ldr.w	pc, [r3, r1, lsl #2]
   1255c:	00012745 	.word	0x00012745
   12560:	000125b9 	.word	0x000125b9
   12564:	000125c1 	.word	0x000125c1
   12568:	00012167 	.word	0x00012167
   1256c:	00012739 	.word	0x00012739
   12570:	000125e7 	.word	0x000125e7
   12574:	0001207d 	.word	0x0001207d
   12578:	0001207d 	.word	0x0001207d
   1257c:	0001207d 	.word	0x0001207d
   12580:	0001207d 	.word	0x0001207d
   12584:	000125ef 	.word	0x000125ef
   12588:	000125f7 	.word	0x000125f7
   1258c:	0001207d 	.word	0x0001207d
   12590:	00012613 	.word	0x00012613
   12594:	0001207d 	.word	0x0001207d
   12598:	0001261d 	.word	0x0001261d
   1259c:	0001207d 	.word	0x0001207d
   125a0:	0001207d 	.word	0x0001207d
   125a4:	0001207d 	.word	0x0001207d
   125a8:	0001207d 	.word	0x0001207d
   125ac:	00012621 	.word	0x00012621
   125b0:	0001207d 	.word	0x0001207d
   125b4:	0001264d 	.word	0x0001264d
		shell_op_left_arrow(shell);
   125b8:	4620      	mov	r0, r4
   125ba:	f017 f86c 	bl	29696 <shell_op_left_arrow>
		break;
   125be:	e55d      	b.n	1207c <shell_process+0x34>
		shell_op_cursor_end_move(shell);
   125c0:	4620      	mov	r0, r4
   125c2:	f017 f861 	bl	29688 <shell_op_cursor_end_move>
		if (!shell_cursor_in_empty_line(shell)) {
   125c6:	4620      	mov	r0, r4
   125c8:	f016 ffe6 	bl	29598 <shell_cursor_in_empty_line>
   125cc:	b918      	cbnz	r0, 125d6 <shell_process+0x58e>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
   125ce:	492f      	ldr	r1, [pc, #188]	; (1268c <shell_process+0x644>)
   125d0:	6960      	ldr	r0, [r4, #20]
   125d2:	f016 fd27 	bl	29024 <shell_raw_fprintf>
		flag_history_exit_set(shell, true);
   125d6:	68a2      	ldr	r2, [r4, #8]
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
   125d8:	f8b2 3258 	ldrh.w	r3, [r2, #600]	; 0x258
   125dc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   125e0:	f8a2 3258 	strh.w	r3, [r2, #600]	; 0x258
   125e4:	e5a4      	b.n	12130 <shell_process+0xe8>
		shell_op_right_arrow(shell);
   125e6:	4620      	mov	r0, r4
   125e8:	f017 f85d 	bl	296a6 <shell_op_right_arrow>
		break;
   125ec:	e546      	b.n	1207c <shell_process+0x34>
		shell_op_delete_from_cursor(shell);
   125ee:	4620      	mov	r0, r4
   125f0:	f017 f862 	bl	296b8 <shell_op_delete_from_cursor>
		break;
   125f4:	e542      	b.n	1207c <shell_process+0x34>
		SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
   125f6:	6960      	ldr	r0, [r4, #20]
   125f8:	4a27      	ldr	r2, [pc, #156]	; (12698 <shell_process+0x650>)
   125fa:	4926      	ldr	r1, [pc, #152]	; (12694 <shell_process+0x64c>)
   125fc:	f016 fd12 	bl	29024 <shell_raw_fprintf>
		SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
   12600:	6960      	ldr	r0, [r4, #20]
   12602:	4a26      	ldr	r2, [pc, #152]	; (1269c <shell_process+0x654>)
   12604:	4923      	ldr	r1, [pc, #140]	; (12694 <shell_process+0x64c>)
   12606:	f016 fd0d 	bl	29024 <shell_raw_fprintf>
		shell_print_prompt_and_cmd(shell);
   1260a:	4620      	mov	r0, r4
   1260c:	f000 fb5a 	bl	12cc4 <shell_print_prompt_and_cmd>
		break;
   12610:	e534      	b.n	1207c <shell_process+0x34>
		history_handle(shell, false);
   12612:	2100      	movs	r1, #0
		history_handle(shell, true);
   12614:	4620      	mov	r0, r4
   12616:	f7ff fb8d 	bl	11d34 <history_handle>
		break;
   1261a:	e52f      	b.n	1207c <shell_process+0x34>
		history_handle(shell, true);
   1261c:	2101      	movs	r1, #1
   1261e:	e7f9      	b.n	12614 <shell_process+0x5cc>
		shell_op_cursor_home_move(shell);
   12620:	4620      	mov	r0, r4
   12622:	f017 f82b 	bl	2967c <shell_op_cursor_home_move>
		cmd_buffer_clear(shell);
   12626:	68a3      	ldr	r3, [r4, #8]
	SHELL_VT100_CMD(shell, SHELL_VT100_CLEAREOS);
   12628:	491a      	ldr	r1, [pc, #104]	; (12694 <shell_process+0x64c>)
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
   1262a:	2200      	movs	r2, #0
   1262c:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
	shell->ctx->cmd_buff_pos = 0;
   12630:	869a      	strh	r2, [r3, #52]	; 0x34
	shell->ctx->cmd_buff_len = 0;
   12632:	865a      	strh	r2, [r3, #50]	; 0x32
		flag_history_exit_set(shell, true);
   12634:	68a2      	ldr	r2, [r4, #8]
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
   12636:	f8b2 3258 	ldrh.w	r3, [r2, #600]	; 0x258
   1263a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1263e:	f8a2 3258 	strh.w	r3, [r2, #600]	; 0x258
	SHELL_VT100_CMD(shell, SHELL_VT100_CLEAREOS);
   12642:	6960      	ldr	r0, [r4, #20]
   12644:	4a16      	ldr	r2, [pc, #88]	; (126a0 <shell_process+0x658>)
   12646:	f016 fced 	bl	29024 <shell_raw_fprintf>
   1264a:	e517      	b.n	1207c <shell_process+0x34>
		shell_op_word_remove(shell);
   1264c:	4620      	mov	r0, r4
   1264e:	f000 fa89 	bl	12b64 <shell_op_word_remove>
		flag_history_exit_set(shell, true);
   12652:	68a2      	ldr	r2, [r4, #8]
	shell->ctx->internal.flags.history_exit = val ? 1 : 0;
   12654:	f8b2 3258 	ldrh.w	r3, [r2, #600]	; 0x258
   12658:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1265c:	e662      	b.n	12324 <shell_process+0x2dc>
			if (data == '[') {
   1265e:	295b      	cmp	r1, #91	; 0x5b
   12660:	d101      	bne.n	12666 <shell_process+0x61e>
	shell->ctx->receive_state = state;
   12662:	2302      	movs	r3, #2
   12664:	e584      	b.n	12170 <shell_process+0x128>
	return shell->ctx->internal.flags.echo == 1 ? true : false;
   12666:	f8d0 3258 	ldr.w	r3, [r0, #600]	; 0x258
			} else if (flag_echo_get(shell)) {
   1266a:	0758      	lsls	r0, r3, #29
   1266c:	d506      	bpl.n	1267c <shell_process+0x634>
	if (data == SHELL_VT100_ASCII_ALT_B) {
   1266e:	2962      	cmp	r1, #98	; 0x62
   12670:	d108      	bne.n	12684 <shell_process+0x63c>
		shell_op_cursor_word_move(shell, -1);
   12672:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
		shell_op_cursor_word_move(shell, 1);
   12676:	4620      	mov	r0, r4
   12678:	f016 ffc6 	bl	29608 <shell_op_cursor_word_move>
	shell->ctx->receive_state = state;
   1267c:	68a3      	ldr	r3, [r4, #8]
   1267e:	2200      	movs	r2, #0
   12680:	715a      	strb	r2, [r3, #5]
   12682:	e4fb      	b.n	1207c <shell_process+0x34>
	} else if (data == SHELL_VT100_ASCII_ALT_F) {
   12684:	2966      	cmp	r1, #102	; 0x66
   12686:	d1f9      	bne.n	1267c <shell_process+0x634>
		shell_op_cursor_word_move(shell, 1);
   12688:	2101      	movs	r1, #1
   1268a:	e7f4      	b.n	12676 <shell_process+0x62e>
   1268c:	0002f978 	.word	0x0002f978
   12690:	0002f971 	.word	0x0002f971
   12694:	000306d9 	.word	0x000306d9
   12698:	0002f8ce 	.word	0x0002f8ce
   1269c:	0002f8d2 	.word	0x0002f8d2
   126a0:	0002f8ca 	.word	0x0002f8ca
   126a4:	0002f4a4 	.word	0x0002f4a4
	shell->ctx->receive_state = state;
   126a8:	2300      	movs	r3, #0
   126aa:	7143      	strb	r3, [r0, #5]
   126ac:	f8d0 3258 	ldr.w	r3, [r0, #600]	; 0x258
			if (!flag_echo_get(shell)) {
   126b0:	075a      	lsls	r2, r3, #29
   126b2:	f57f ace3 	bpl.w	1207c <shell_process+0x34>
			switch (data) {
   126b6:	3931      	subs	r1, #49	; 0x31
   126b8:	291b      	cmp	r1, #27
   126ba:	f63f acdf 	bhi.w	1207c <shell_process+0x34>
   126be:	a301      	add	r3, pc, #4	; (adr r3, 126c4 <shell_process+0x67c>)
   126c0:	f853 f021 	ldr.w	pc, [r3, r1, lsl #2]
   126c4:	00012741 	.word	0x00012741
   126c8:	0001274d 	.word	0x0001274d
   126cc:	0001276b 	.word	0x0001276b
   126d0:	00012735 	.word	0x00012735
   126d4:	0001207d 	.word	0x0001207d
   126d8:	0001207d 	.word	0x0001207d
   126dc:	0001207d 	.word	0x0001207d
   126e0:	0001207d 	.word	0x0001207d
   126e4:	0001207d 	.word	0x0001207d
   126e8:	0001207d 	.word	0x0001207d
   126ec:	0001207d 	.word	0x0001207d
   126f0:	0001207d 	.word	0x0001207d
   126f4:	0001207d 	.word	0x0001207d
   126f8:	0001207d 	.word	0x0001207d
   126fc:	0001207d 	.word	0x0001207d
   12700:	0001207d 	.word	0x0001207d
   12704:	0001261d 	.word	0x0001261d
   12708:	00012613 	.word	0x00012613
   1270c:	000125e7 	.word	0x000125e7
   12710:	000125b9 	.word	0x000125b9
   12714:	0001207d 	.word	0x0001207d
   12718:	00012739 	.word	0x00012739
   1271c:	0001207d 	.word	0x0001207d
   12720:	00012745 	.word	0x00012745
   12724:	0001207d 	.word	0x0001207d
   12728:	0001207d 	.word	0x0001207d
   1272c:	0001207d 	.word	0x0001207d
   12730:	00012751 	.word	0x00012751
	shell->ctx->receive_state = state;
   12734:	2303      	movs	r3, #3
   12736:	7143      	strb	r3, [r0, #5]
		shell_op_cursor_end_move(shell);
   12738:	4620      	mov	r0, r4
   1273a:	f016 ffa5 	bl	29688 <shell_op_cursor_end_move>
		break;
   1273e:	e49d      	b.n	1207c <shell_process+0x34>
	shell->ctx->receive_state = state;
   12740:	2303      	movs	r3, #3
   12742:	7143      	strb	r3, [r0, #5]
		shell_op_cursor_home_move(shell);
   12744:	4620      	mov	r0, r4
   12746:	f016 ff99 	bl	2967c <shell_op_cursor_home_move>
		break;
   1274a:	e497      	b.n	1207c <shell_process+0x34>
	shell->ctx->receive_state = state;
   1274c:	2303      	movs	r3, #3
   1274e:	7143      	strb	r3, [r0, #5]
	return ((shell->ctx->internal.flags.insert_mode == 1) ? true : false);
   12750:	f8d0 3258 	ldr.w	r3, [r0, #600]	; 0x258
	shell->ctx->internal.flags.insert_mode = val ? 1 : 0;
   12754:	f8b0 2258 	ldrh.w	r2, [r0, #600]	; 0x258
	return ((shell->ctx->internal.flags.insert_mode == 1) ? true : false);
   12758:	f003 0301 	and.w	r3, r3, #1
				flag_insert_mode_set(shell, !status);
   1275c:	f083 0301 	eor.w	r3, r3, #1
	shell->ctx->internal.flags.insert_mode = val ? 1 : 0;
   12760:	f363 0200 	bfi	r2, r3, #0, #1
   12764:	f8a0 2258 	strh.w	r2, [r0, #600]	; 0x258
   12768:	e488      	b.n	1207c <shell_process+0x34>
	shell->ctx->receive_state = state;
   1276a:	2303      	movs	r3, #3
   1276c:	7143      	strb	r3, [r0, #5]
	return shell->ctx->internal.flags.echo == 1 ? true : false;
   1276e:	f8d0 3258 	ldr.w	r3, [r0, #600]	; 0x258
				if (flag_echo_get(shell)) {
   12772:	075b      	lsls	r3, r3, #29
   12774:	f57f ac82 	bpl.w	1207c <shell_process+0x34>
   12778:	e4f5      	b.n	12166 <shell_process+0x11e>
	shell->ctx->receive_state = state;
   1277a:	2300      	movs	r3, #0
   1277c:	e4f8      	b.n	12170 <shell_process+0x128>
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1277e:	68a3      	ldr	r3, [r4, #8]
   12780:	f3bf 8f5b 	dmb	ish
   12784:	f503 7316 	add.w	r3, r3, #600	; 0x258
   12788:	e853 2f00 	ldrex	r2, [r3]
   1278c:	f022 0208 	bic.w	r2, r2, #8
   12790:	e843 2100 	strex	r1, r2, [r3]
   12794:	2900      	cmp	r1, #0
   12796:	d1f7      	bne.n	12788 <shell_process+0x740>
   12798:	f3bf 8f5b 	dmb	ish

	internal.value = 0xFFFFFFFF;
	internal.flags.processing = 0U;
	(void)atomic_and((atomic_t *)&shell->ctx->internal.value,
			 internal.value);
}
   1279c:	b02d      	add	sp, #180	; 0xb4
   1279e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   127a2:	bf00      	nop

000127a4 <shell_init>:
{
   127a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   127a8:	4604      	mov	r4, r0
	int err = shell->iface->api->init(shell->iface, p_config,
   127aa:	6840      	ldr	r0, [r0, #4]
   127ac:	4a37      	ldr	r2, [pc, #220]	; (1288c <shell_init+0xe8>)
{
   127ae:	461f      	mov	r7, r3
	int err = shell->iface->api->init(shell->iface, p_config,
   127b0:	6803      	ldr	r3, [r0, #0]
{
   127b2:	b086      	sub	sp, #24
	int err = shell->iface->api->init(shell->iface, p_config,
   127b4:	681d      	ldr	r5, [r3, #0]
   127b6:	4623      	mov	r3, r4
   127b8:	47a8      	blx	r5
	if (err != 0) {
   127ba:	4606      	mov	r6, r0
   127bc:	2800      	cmp	r0, #0
   127be:	d161      	bne.n	12884 <shell_init+0xe0>
	memset(shell->ctx, 0, sizeof(*shell->ctx));
   127c0:	4601      	mov	r1, r0
   127c2:	f44f 7241 	mov.w	r2, #772	; 0x304
   127c6:	68a0      	ldr	r0, [r4, #8]
   127c8:	f017 fe6b 	bl	2a4a2 <memset>
	shell->ctx->prompt = shell->default_prompt;
   127cc:	68a3      	ldr	r3, [r4, #8]
   127ce:	6822      	ldr	r2, [r4, #0]
	shell_history_init(shell->history);
   127d0:	68e0      	ldr	r0, [r4, #12]
	shell->ctx->prompt = shell->default_prompt;
   127d2:	601a      	str	r2, [r3, #0]
	shell_history_init(shell->history);
   127d4:	f017 f9b9 	bl	29b4a <shell_history_init>
	k_mutex_init(&shell->ctx->wr_mtx);
   127d8:	68a0      	ldr	r0, [r4, #8]
   127da:	f500 703b 	add.w	r0, r0, #748	; 0x2ec
	z_impl_k_mutex_init(mutex);
   127de:	f01a fc25 	bl	2d02c <z_impl_k_mutex_init>
   127e2:	f44f 7827 	mov.w	r8, #668	; 0x29c
   127e6:	f44f 7517 	mov.w	r5, #604	; 0x25c
		k_poll_signal_init(&shell->ctx->signals[i]);
   127ea:	68a0      	ldr	r0, [r4, #8]
   127ec:	4428      	add	r0, r5
		arch_syscall_invoke1(*(uintptr_t *)&signal, K_SYSCALL_K_POLL_SIGNAL_INIT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_poll_signal_init(signal);
   127ee:	f01b f852 	bl	2d896 <z_impl_k_poll_signal_init>
		k_poll_event_init(&shell->ctx->events[i],
   127f2:	68a0      	ldr	r0, [r4, #8]
   127f4:	2200      	movs	r2, #0
   127f6:	1943      	adds	r3, r0, r5
   127f8:	2101      	movs	r1, #1
   127fa:	4440      	add	r0, r8
   127fc:	3510      	adds	r5, #16
   127fe:	f014 ffcd 	bl	2779c <k_poll_event_init>
	for (int i = 0; i < SHELL_SIGNALS; i++) {
   12802:	f5b5 7f27 	cmp.w	r5, #668	; 0x29c
   12806:	f108 0814 	add.w	r8, r8, #20
   1280a:	d1ee      	bne.n	127ea <shell_init+0x46>
		shell->stats->log_lost_cnt = 0;
   1280c:	69a3      	ldr	r3, [r4, #24]
   1280e:	2500      	movs	r5, #0
   12810:	601d      	str	r5, [r3, #0]
	flag_tx_rdy_set(shell, true);
   12812:	68a3      	ldr	r3, [r4, #8]
	shell->ctx->internal.flags.tx_rdy = val ? 1 : 0;
   12814:	f8b3 2258 	ldrh.w	r2, [r3, #600]	; 0x258
	shell->ctx->vt100_ctx.cons.name_len = shell_strlen(shell->ctx->prompt);
   12818:	6818      	ldr	r0, [r3, #0]
   1281a:	f042 0210 	orr.w	r2, r2, #16
   1281e:	f8a3 2258 	strh.w	r2, [r3, #600]	; 0x258
	shell->ctx->internal.flags.echo = val ? 1 : 0;
   12822:	f8b3 2258 	ldrh.w	r2, [r3, #600]	; 0x258
   12826:	f042 0204 	orr.w	r2, r2, #4
   1282a:	f8a3 2258 	strh.w	r2, [r3, #600]	; 0x258
	shell->ctx->internal.flags.mode_delete = val ? 1 : 0;
   1282e:	f8b3 2258 	ldrh.w	r2, [r3, #600]	; 0x258
   12832:	f042 0220 	orr.w	r2, r2, #32
   12836:	f8a3 2258 	strh.w	r2, [r3, #600]	; 0x258
	shell->ctx->state = SHELL_STATE_INITIALIZED;
   1283a:	2201      	movs	r2, #1
   1283c:	711a      	strb	r2, [r3, #4]
	shell->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
   1283e:	4a14      	ldr	r2, [pc, #80]	; (12890 <shell_init+0xec>)
   12840:	629a      	str	r2, [r3, #40]	; 0x28
	shell->ctx->vt100_ctx.cons.name_len = shell_strlen(shell->ctx->prompt);
   12842:	f016 fbe9 	bl	29018 <shell_strlen>
   12846:	68a3      	ldr	r3, [r4, #8]
   12848:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
	flag_use_colors_set(shell, IS_ENABLED(CONFIG_SHELL_VT100_COLORS));
   1284c:	68a2      	ldr	r2, [r4, #8]
	shell->ctx->internal.flags.use_colors = val ? 1 : 0;
   1284e:	f8b2 3258 	ldrh.w	r3, [r2, #600]	; 0x258
   12852:	f043 0302 	orr.w	r3, r3, #2
   12856:	f8a2 3258 	strh.w	r3, [r2, #600]	; 0x258
	k_tid_t tid = k_thread_create(shell->thread,
   1285a:	e9d4 010a 	ldrd	r0, r1, [r4, #40]	; 0x28
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   1285e:	230e      	movs	r3, #14
   12860:	9303      	str	r3, [sp, #12]
   12862:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   12864:	9400      	str	r4, [sp, #0]
   12866:	e9cd 7301 	strd	r7, r3, [sp, #4]
   1286a:	e9cd 5504 	strd	r5, r5, [sp, #16]
   1286e:	4b09      	ldr	r3, [pc, #36]	; (12894 <shell_init+0xf0>)
   12870:	f44f 6200 	mov.w	r2, #2048	; 0x800
   12874:	f014 fcec 	bl	27250 <z_impl_k_thread_create>
	shell->ctx->tid = tid;
   12878:	68a3      	ldr	r3, [r4, #8]
	k_thread_name_set(tid, shell->thread_name);
   1287a:	6a61      	ldr	r1, [r4, #36]	; 0x24
	shell->ctx->tid = tid;
   1287c:	f8c3 0300 	str.w	r0, [r3, #768]	; 0x300
	return z_impl_k_thread_name_set(thread_id, value);
   12880:	f01a fdd5 	bl	2d42e <z_impl_k_thread_name_set>
}
   12884:	4630      	mov	r0, r6
   12886:	b006      	add	sp, #24
   12888:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1288c:	00029065 	.word	0x00029065
   12890:	00500018 	.word	0x00500018
   12894:	000128c9 	.word	0x000128c9

00012898 <shell_start>:
	if (shell->ctx->state != SHELL_STATE_INITIALIZED) {
   12898:	6883      	ldr	r3, [r0, #8]
   1289a:	791b      	ldrb	r3, [r3, #4]
   1289c:	2b01      	cmp	r3, #1
{
   1289e:	b510      	push	{r4, lr}
   128a0:	4604      	mov	r4, r0
	if (shell->ctx->state != SHELL_STATE_INITIALIZED) {
   128a2:	d10b      	bne.n	128bc <shell_start+0x24>
		shell_vt100_color_set(shell, SHELL_NORMAL);
   128a4:	2100      	movs	r1, #0
   128a6:	f000 f913 	bl	12ad0 <shell_vt100_color_set>
	shell_raw_fprintf(shell->fprintf_ctx, "\n\n");
   128aa:	4906      	ldr	r1, [pc, #24]	; (128c4 <shell_start+0x2c>)
   128ac:	6960      	ldr	r0, [r4, #20]
   128ae:	f016 fbb9 	bl	29024 <shell_raw_fprintf>
	state_set(shell, SHELL_STATE_ACTIVE);
   128b2:	4620      	mov	r0, r4
   128b4:	f016 fbcc 	bl	29050 <state_set.constprop.31>
	return 0;
   128b8:	2000      	movs	r0, #0
}
   128ba:	bd10      	pop	{r4, pc}
		return -ENOTSUP;
   128bc:	f06f 0022 	mvn.w	r0, #34	; 0x22
   128c0:	e7fb      	b.n	128ba <shell_start+0x22>
   128c2:	bf00      	nop
   128c4:	0002f977 	.word	0x0002f977

000128c8 <shell_thread>:
{
   128c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   128cc:	4604      	mov	r4, r0
	err = shell->iface->api->enable(shell->iface, false);
   128ce:	6840      	ldr	r0, [r0, #4]
   128d0:	6803      	ldr	r3, [r0, #0]
{
   128d2:	460e      	mov	r6, r1
	err = shell->iface->api->enable(shell->iface, false);
   128d4:	689b      	ldr	r3, [r3, #8]
   128d6:	2100      	movs	r1, #0
{
   128d8:	4615      	mov	r5, r2
	err = shell->iface->api->enable(shell->iface, false);
   128da:	4798      	blx	r3
	if (err != 0) {
   128dc:	2800      	cmp	r0, #0
   128de:	d140      	bne.n	12962 <shell_thread+0x9a>
	if (log_backend && IS_ENABLED(CONFIG_SHELL_LOG_BACKEND)) {
   128e0:	b126      	cbz	r6, 128ec <shell_thread+0x24>
		shell_log_backend_enable(shell->log_backend, (void *)shell,
   128e2:	462a      	mov	r2, r5
   128e4:	4621      	mov	r1, r4
   128e6:	69e0      	ldr	r0, [r4, #28]
   128e8:	f017 f9bb 	bl	29c62 <shell_log_backend_enable>
	err = shell_start(shell);
   128ec:	4620      	mov	r0, r4
   128ee:	f7ff ffd3 	bl	12898 <shell_start>
	if (err != 0) {
   128f2:	2800      	cmp	r0, #0
   128f4:	d135      	bne.n	12962 <shell_thread+0x9a>
		shell_signal_handle(shell, SHELL_SIGNAL_KILL, kill_handler);
   128f6:	4f1c      	ldr	r7, [pc, #112]	; (12968 <shell_thread+0xa0>)
		shell_signal_handle(shell, SHELL_SIGNAL_RXRDY, shell_process);
   128f8:	4e1c      	ldr	r6, [pc, #112]	; (1296c <shell_thread+0xa4>)
			shell_signal_handle(shell, SHELL_SIGNAL_LOG_MSG,
   128fa:	4d1d      	ldr	r5, [pc, #116]	; (12970 <shell_thread+0xa8>)
		err = k_poll(shell->ctx->events, SHELL_SIGNAL_TXDONE,
   128fc:	68a0      	ldr	r0, [r4, #8]
   128fe:	f500 7027 	add.w	r0, r0, #668	; 0x29c
	return z_impl_k_poll(events, num_events, timeout);
   12902:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   12906:	2103      	movs	r1, #3
   12908:	f014 ff5c 	bl	277c4 <z_impl_k_poll>
   1290c:	4680      	mov	r8, r0
		k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
   1290e:	68a0      	ldr	r0, [r4, #8]
   12910:	f500 703b 	add.w	r0, r0, #748	; 0x2ec
   12914:	f016 fbb0 	bl	29078 <k_mutex_lock.constprop.35>
		if (err != 0) {
   12918:	f1b8 0f00 	cmp.w	r8, #0
   1291c:	d007      	beq.n	1292e <shell_thread+0x66>
			shell_internal_fprintf(shell, SHELL_ERROR,
   1291e:	4643      	mov	r3, r8
   12920:	4620      	mov	r0, r4
   12922:	4a14      	ldr	r2, [pc, #80]	; (12974 <shell_thread+0xac>)
   12924:	2102      	movs	r1, #2
}
   12926:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			shell_internal_fprintf(shell, SHELL_ERROR,
   1292a:	f016 bf46 	b.w	297ba <shell_internal_fprintf>
		if (shell->iface->api->update) {
   1292e:	6860      	ldr	r0, [r4, #4]
   12930:	6803      	ldr	r3, [r0, #0]
   12932:	695b      	ldr	r3, [r3, #20]
   12934:	b103      	cbz	r3, 12938 <shell_thread+0x70>
			shell->iface->api->update(shell->iface);
   12936:	4798      	blx	r3
		shell_signal_handle(shell, SHELL_SIGNAL_KILL, kill_handler);
   12938:	463a      	mov	r2, r7
   1293a:	4620      	mov	r0, r4
   1293c:	2102      	movs	r1, #2
   1293e:	f016 fb3b 	bl	28fb8 <shell_signal_handle>
		shell_signal_handle(shell, SHELL_SIGNAL_RXRDY, shell_process);
   12942:	4632      	mov	r2, r6
   12944:	4620      	mov	r0, r4
   12946:	2100      	movs	r1, #0
   12948:	f016 fb36 	bl	28fb8 <shell_signal_handle>
			shell_signal_handle(shell, SHELL_SIGNAL_LOG_MSG,
   1294c:	4620      	mov	r0, r4
   1294e:	462a      	mov	r2, r5
   12950:	2101      	movs	r1, #1
   12952:	f016 fb31 	bl	28fb8 <shell_signal_handle>
		k_mutex_unlock(&shell->ctx->wr_mtx);
   12956:	68a0      	ldr	r0, [r4, #8]
   12958:	f500 703b 	add.w	r0, r0, #748	; 0x2ec
	z_impl_k_mutex_unlock(mutex);
   1295c:	f014 f8a8 	bl	26ab0 <z_impl_k_mutex_unlock>
   12960:	e7cc      	b.n	128fc <shell_thread+0x34>
}
   12962:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12966:	bf00      	nop
   12968:	00028fe3 	.word	0x00028fe3
   1296c:	00012049 	.word	0x00012049
   12970:	00029081 	.word	0x00029081
   12974:	0002f97a 	.word	0x0002f97a

00012978 <shell_fprintf_fmt>:
	return 0;
}

void shell_fprintf_fmt(const struct shell_fprintf *sh_fprintf,
		       const char *fmt, va_list args)
{
   12978:	b510      	push	{r4, lr}
   1297a:	4604      	mov	r4, r0
#if !defined(CONFIG_NEWLIB_LIBC) && !defined(CONFIG_ARCH_POSIX)
	(void)z_prf(out_func, (void *)sh_fprintf, (char *)fmt, args);
   1297c:	4613      	mov	r3, r2
   1297e:	460a      	mov	r2, r1
   12980:	4601      	mov	r1, r0
   12982:	4806      	ldr	r0, [pc, #24]	; (1299c <shell_fprintf_fmt+0x24>)
   12984:	f001 fe6e 	bl	14664 <z_prf>
#else
	z_vprintk(out_func, (void *)sh_fprintf, fmt, args);
#endif

	if (sh_fprintf->ctrl_blk->autoflush) {
   12988:	6923      	ldr	r3, [r4, #16]
   1298a:	791b      	ldrb	r3, [r3, #4]
   1298c:	b123      	cbz	r3, 12998 <shell_fprintf_fmt+0x20>
		shell_fprintf_buffer_flush(sh_fprintf);
   1298e:	4620      	mov	r0, r4
	}
}
   12990:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		shell_fprintf_buffer_flush(sh_fprintf);
   12994:	f016 bbd4 	b.w	29140 <shell_fprintf_buffer_flush>
}
   12998:	bd10      	pop	{r4, pc}
   1299a:	bf00      	nop
   1299c:	00029159 	.word	0x00029159

000129a0 <shell_cmd_get>:

void shell_cmd_get(const struct shell *shell,
		   const struct shell_cmd_entry *command, size_t lvl,
		   size_t idx, const struct shell_static_entry **entry,
		   struct shell_static_entry *d_entry)
{
   129a0:	b570      	push	{r4, r5, r6, lr}
   129a2:	e9dd 4604 	ldrd	r4, r6, [sp, #16]
	__ASSERT_NO_MSG(entry != NULL);
	__ASSERT_NO_MSG(d_entry != NULL);

	*entry = NULL;
   129a6:	2000      	movs	r0, #0
   129a8:	6020      	str	r0, [r4, #0]

	if (lvl == SHELL_CMD_ROOT_LVL) {
   129aa:	b952      	cbnz	r2, 129c2 <shell_cmd_get+0x22>
	return ((u8_t *)__shell_root_cmds_end -
   129ac:	480f      	ldr	r0, [pc, #60]	; (129ec <shell_cmd_get+0x4c>)
   129ae:	4a10      	ldr	r2, [pc, #64]	; (129f0 <shell_cmd_get+0x50>)
   129b0:	1a12      	subs	r2, r2, r0
			const struct shell_static_entry *ptr =
						       shell->ctx->selected_cmd;
			if (ptr->subcmd->u.entry[idx].syntax != NULL) {
				*entry = &ptr->subcmd->u.entry[idx];
			}
		} else if (idx < shell_root_cmd_count()) {
   129b2:	ebb3 0fd2 	cmp.w	r3, r2, lsr #3
   129b6:	d203      	bcs.n	129c0 <shell_cmd_get+0x20>
			const struct shell_cmd_entry *cmd;

			cmd = shell_root_cmd_get(idx);
			*entry = cmd->u.entry;
   129b8:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
   129bc:	685b      	ldr	r3, [r3, #4]
   129be:	6023      	str	r3, [r4, #0]
	} else {
		if (command->u.entry[idx].syntax != NULL) {
			*entry = &command->u.entry[idx];
		}
	}
}
   129c0:	bd70      	pop	{r4, r5, r6, pc}
	if (command == NULL) {
   129c2:	2900      	cmp	r1, #0
   129c4:	d0fc      	beq.n	129c0 <shell_cmd_get+0x20>
	if (command->is_dynamic) {
   129c6:	780a      	ldrb	r2, [r1, #0]
   129c8:	684d      	ldr	r5, [r1, #4]
   129ca:	b13a      	cbz	r2, 129dc <shell_cmd_get+0x3c>
		command->u.dynamic_get(idx, d_entry);
   129cc:	4618      	mov	r0, r3
   129ce:	4631      	mov	r1, r6
   129d0:	47a8      	blx	r5
		if (d_entry->syntax != NULL) {
   129d2:	6833      	ldr	r3, [r6, #0]
   129d4:	2b00      	cmp	r3, #0
   129d6:	d0f3      	beq.n	129c0 <shell_cmd_get+0x20>
			*entry = d_entry;
   129d8:	6026      	str	r6, [r4, #0]
   129da:	e7f1      	b.n	129c0 <shell_cmd_get+0x20>
		if (command->u.entry[idx].syntax != NULL) {
   129dc:	2214      	movs	r2, #20
   129de:	4353      	muls	r3, r2
   129e0:	18ea      	adds	r2, r5, r3
   129e2:	58eb      	ldr	r3, [r5, r3]
   129e4:	2b00      	cmp	r3, #0
   129e6:	d0eb      	beq.n	129c0 <shell_cmd_get+0x20>
			*entry = &command->u.entry[idx];
   129e8:	6022      	str	r2, [r4, #0]
   129ea:	e7e9      	b.n	129c0 <shell_cmd_get+0x20>
   129ec:	0002dc90 	.word	0x0002dc90
   129f0:	0002dcd8 	.word	0x0002dcd8

000129f4 <clear_eos.isra.6>:
	SHELL_VT100_CMD(shell, SHELL_VT100_CLEAREOS);
   129f4:	4a01      	ldr	r2, [pc, #4]	; (129fc <clear_eos.isra.6+0x8>)
   129f6:	4902      	ldr	r1, [pc, #8]	; (12a00 <clear_eos.isra.6+0xc>)
   129f8:	f016 bdad 	b.w	29556 <shell_raw_fprintf>
   129fc:	0002f991 	.word	0x0002f991
   12a00:	000306d9 	.word	0x000306d9

00012a04 <shell_op_cursor_vert_move>:
#include <ctype.h>
#include "shell_ops.h"

void shell_op_cursor_vert_move(const struct shell *shell, s32_t delta)
{
	if (delta != 0) {
   12a04:	b159      	cbz	r1, 12a1e <shell_op_cursor_vert_move+0x1a>
		shell_raw_fprintf(shell->fprintf_ctx, "\033[%d%c",
   12a06:	2900      	cmp	r1, #0
   12a08:	ea81 72e1 	eor.w	r2, r1, r1, asr #31
   12a0c:	eba2 72e1 	sub.w	r2, r2, r1, asr #31
   12a10:	bfcc      	ite	gt
   12a12:	2341      	movgt	r3, #65	; 0x41
   12a14:	2342      	movle	r3, #66	; 0x42
   12a16:	4902      	ldr	r1, [pc, #8]	; (12a20 <shell_op_cursor_vert_move+0x1c>)
   12a18:	6940      	ldr	r0, [r0, #20]
   12a1a:	f016 bd9c 	b.w	29556 <shell_raw_fprintf>
				  delta > 0 ? delta : -delta,
				  delta > 0 ? 'A' : 'B');
	}
}
   12a1e:	4770      	bx	lr
   12a20:	0002f99f 	.word	0x0002f99f

00012a24 <shell_op_cursor_horiz_move>:

void shell_op_cursor_horiz_move(const struct shell *shell, s32_t delta)
{
	if (delta != 0) {
   12a24:	b159      	cbz	r1, 12a3e <shell_op_cursor_horiz_move+0x1a>
		shell_raw_fprintf(shell->fprintf_ctx, "\033[%d%c",
   12a26:	2900      	cmp	r1, #0
   12a28:	ea81 72e1 	eor.w	r2, r1, r1, asr #31
   12a2c:	eba2 72e1 	sub.w	r2, r2, r1, asr #31
   12a30:	bfcc      	ite	gt
   12a32:	2343      	movgt	r3, #67	; 0x43
   12a34:	2344      	movle	r3, #68	; 0x44
   12a36:	4902      	ldr	r1, [pc, #8]	; (12a40 <shell_op_cursor_horiz_move+0x1c>)
   12a38:	6940      	ldr	r0, [r0, #20]
   12a3a:	f016 bd8c 	b.w	29556 <shell_raw_fprintf>
				  delta > 0 ? delta : -delta,
				  delta > 0 ? 'C' : 'D');
	}
}
   12a3e:	4770      	bx	lr
   12a40:	0002f99f 	.word	0x0002f99f

00012a44 <shell_op_cond_next_line>:
	return ((shell->ctx->cmd_buff_pos + shell_strlen(shell->ctx->prompt))
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
}

void shell_op_cond_next_line(const struct shell *shell)
{
   12a44:	b510      	push	{r4, lr}
   12a46:	4604      	mov	r4, r0
	if (shell_cursor_in_empty_line(shell) || full_line_cmd(shell)) {
   12a48:	f016 fda6 	bl	29598 <shell_cursor_in_empty_line>
   12a4c:	b128      	cbz	r0, 12a5a <shell_op_cond_next_line+0x16>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
   12a4e:	6960      	ldr	r0, [r4, #20]
   12a50:	4905      	ldr	r1, [pc, #20]	; (12a68 <shell_op_cond_next_line+0x24>)
		cursor_next_line_move(shell);
	}
}
   12a52:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   12a56:	f016 bd7e 	b.w	29556 <shell_raw_fprintf>
	if (shell_cursor_in_empty_line(shell) || full_line_cmd(shell)) {
   12a5a:	f104 0008 	add.w	r0, r4, #8
   12a5e:	f016 fd87 	bl	29570 <full_line_cmd.isra.8>
   12a62:	2800      	cmp	r0, #0
   12a64:	d1f3      	bne.n	12a4e <shell_op_cond_next_line+0xa>
}
   12a66:	bd10      	pop	{r4, pc}
   12a68:	0002f978 	.word	0x0002f978

00012a6c <shell_op_cursor_position_synchronize>:

void shell_op_cursor_position_synchronize(const struct shell *shell)
{
   12a6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
   12a70:	4606      	mov	r6, r0
{
   12a72:	4605      	mov	r5, r0
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
   12a74:	f856 4f08 	ldr.w	r4, [r6, #8]!
	bool last_line;

	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
   12a78:	f104 0020 	add.w	r0, r4, #32
   12a7c:	8e62      	ldrh	r2, [r4, #50]	; 0x32
   12a7e:	8ea1      	ldrh	r1, [r4, #52]	; 0x34
   12a80:	f016 fbb0 	bl	291e4 <shell_multiline_data_calc>
	last_line = (cons->cur_y == cons->cur_y_end);

	/* In case cursor reaches the bottom line of a terminal, it will
	 * be moved to the next line.
	 */
	if (full_line_cmd(shell)) {
   12a84:	4630      	mov	r0, r6
	last_line = (cons->cur_y == cons->cur_y_end);
   12a86:	f8b4 8024 	ldrh.w	r8, [r4, #36]	; 0x24
   12a8a:	8ce7      	ldrh	r7, [r4, #38]	; 0x26
	if (full_line_cmd(shell)) {
   12a8c:	f016 fd70 	bl	29570 <full_line_cmd.isra.8>
   12a90:	b118      	cbz	r0, 12a9a <shell_op_cursor_position_synchronize+0x2e>
   12a92:	490a      	ldr	r1, [pc, #40]	; (12abc <shell_op_cursor_position_synchronize+0x50>)
   12a94:	6968      	ldr	r0, [r5, #20]
   12a96:	f016 fd5e 	bl	29556 <shell_raw_fprintf>
		cursor_next_line_move(shell);
	}

	if (last_line) {
   12a9a:	45b8      	cmp	r8, r7
   12a9c:	d107      	bne.n	12aae <shell_op_cursor_position_synchronize+0x42>
		shell_op_cursor_horiz_move(shell, cons->cur_x -
							       cons->cur_x_end);
	} else {
		shell_op_cursor_vert_move(shell, cons->cur_y_end - cons->cur_y);
		shell_op_cursor_horiz_move(shell, cons->cur_x -
   12a9e:	8c21      	ldrh	r1, [r4, #32]
							       cons->cur_x_end);
   12aa0:	8c63      	ldrh	r3, [r4, #34]	; 0x22
		shell_op_cursor_horiz_move(shell, cons->cur_x -
   12aa2:	4628      	mov	r0, r5
   12aa4:	1ac9      	subs	r1, r1, r3
	}
}
   12aa6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		shell_op_cursor_horiz_move(shell, cons->cur_x -
   12aaa:	f7ff bfbb 	b.w	12a24 <shell_op_cursor_horiz_move>
		shell_op_cursor_vert_move(shell, cons->cur_y_end - cons->cur_y);
   12aae:	8ce1      	ldrh	r1, [r4, #38]	; 0x26
   12ab0:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
   12ab2:	4628      	mov	r0, r5
   12ab4:	1ac9      	subs	r1, r1, r3
   12ab6:	f7ff ffa5 	bl	12a04 <shell_op_cursor_vert_move>
   12aba:	e7f0      	b.n	12a9e <shell_op_cursor_position_synchronize+0x32>
   12abc:	0002f978 	.word	0x0002f978

00012ac0 <shell_print_cmd>:
	shell_internal_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
}

void shell_print_cmd(const struct shell *shell)
{
	shell_raw_fprintf(shell->fprintf_ctx, "%s", shell->ctx->cmd_buff);
   12ac0:	6882      	ldr	r2, [r0, #8]
   12ac2:	4902      	ldr	r1, [pc, #8]	; (12acc <shell_print_cmd+0xc>)
   12ac4:	6940      	ldr	r0, [r0, #20]
   12ac6:	3238      	adds	r2, #56	; 0x38
   12ac8:	f016 bd45 	b.w	29556 <shell_raw_fprintf>
   12acc:	000306d9 	.word	0x000306d9

00012ad0 <shell_vt100_color_set>:

void shell_vt100_color_set(const struct shell *shell,
			   enum shell_vt100_color color)
{

	if (shell->ctx->vt100_ctx.col.col == color) {
   12ad0:	6883      	ldr	r3, [r0, #8]
{
   12ad2:	b507      	push	{r0, r1, r2, lr}
	if (shell->ctx->vt100_ctx.col.col == color) {
   12ad4:	f893 202e 	ldrb.w	r2, [r3, #46]	; 0x2e
   12ad8:	428a      	cmp	r2, r1
   12ada:	d012      	beq.n	12b02 <shell_vt100_color_set+0x32>
		return;
	}

	shell->ctx->vt100_ctx.col.col = color;
   12adc:	f883 102e 	strb.w	r1, [r3, #46]	; 0x2e

	if (color != SHELL_NORMAL) {
   12ae0:	6940      	ldr	r0, [r0, #20]
   12ae2:	b189      	cbz	r1, 12b08 <shell_vt100_color_set+0x38>

		u8_t cmd[] = SHELL_VT100_COLOR(color - 1);
   12ae4:	4b09      	ldr	r3, [pc, #36]	; (12b0c <shell_vt100_color_set+0x3c>)
   12ae6:	9300      	str	r3, [sp, #0]
   12ae8:	2333      	movs	r3, #51	; 0x33
   12aea:	f88d 3004 	strb.w	r3, [sp, #4]
   12aee:	312f      	adds	r1, #47	; 0x2f
   12af0:	236d      	movs	r3, #109	; 0x6d
   12af2:	f88d 1005 	strb.w	r1, [sp, #5]
   12af6:	f8ad 3006 	strh.w	r3, [sp, #6]

		shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
   12afa:	466a      	mov	r2, sp
	} else {
		static const u8_t cmd[] = SHELL_VT100_MODESOFF;

		shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
   12afc:	4904      	ldr	r1, [pc, #16]	; (12b10 <shell_vt100_color_set+0x40>)
   12afe:	f016 fd2a 	bl	29556 <shell_raw_fprintf>
	}
}
   12b02:	b003      	add	sp, #12
   12b04:	f85d fb04 	ldr.w	pc, [sp], #4
		shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
   12b08:	4a02      	ldr	r2, [pc, #8]	; (12b14 <shell_vt100_color_set+0x44>)
   12b0a:	e7f7      	b.n	12afc <shell_vt100_color_set+0x2c>
   12b0c:	3b315b1b 	.word	0x3b315b1b
   12b10:	000306d9 	.word	0x000306d9
   12b14:	0002f99b 	.word	0x0002f99b

00012b18 <shell_vt100_colors_restore>:

void shell_vt100_colors_restore(const struct shell *shell,
				       const struct shell_vt100_colors *color)
{
   12b18:	b537      	push	{r0, r1, r2, r4, r5, lr}
   12b1a:	460d      	mov	r5, r1
	shell_vt100_color_set(shell, color->col);
   12b1c:	7809      	ldrb	r1, [r1, #0]
{
   12b1e:	4604      	mov	r4, r0
	shell_vt100_color_set(shell, color->col);
   12b20:	f7ff ffd6 	bl	12ad0 <shell_vt100_color_set>
	vt100_bgcolor_set(shell, color->bgcol);
   12b24:	786b      	ldrb	r3, [r5, #1]
	if ((bgcolor == SHELL_NORMAL) ||
   12b26:	b1cb      	cbz	r3, 12b5c <shell_vt100_colors_restore+0x44>
	    (shell->ctx->vt100_ctx.col.bgcol == bgcolor)) {
   12b28:	68a2      	ldr	r2, [r4, #8]
	if ((bgcolor == SHELL_NORMAL) ||
   12b2a:	f892 102f 	ldrb.w	r1, [r2, #47]	; 0x2f
   12b2e:	4299      	cmp	r1, r3
   12b30:	d014      	beq.n	12b5c <shell_vt100_colors_restore+0x44>
	u8_t cmd[] = SHELL_VT100_BGCOLOR(bgcolor - 1);
   12b32:	f645 311b 	movw	r1, #23323	; 0x5b1b
   12b36:	f8ad 1000 	strh.w	r1, [sp]
   12b3a:	2134      	movs	r1, #52	; 0x34
   12b3c:	f88d 1002 	strb.w	r1, [sp, #2]
   12b40:	f103 012f 	add.w	r1, r3, #47	; 0x2f
   12b44:	f88d 1003 	strb.w	r1, [sp, #3]
   12b48:	216d      	movs	r1, #109	; 0x6d
   12b4a:	f8ad 1004 	strh.w	r1, [sp, #4]
	shell->ctx->vt100_ctx.col.bgcol = bgcolor;
   12b4e:	f882 302f 	strb.w	r3, [r2, #47]	; 0x2f
	shell_raw_fprintf(shell->fprintf_ctx, "%s", cmd);
   12b52:	4903      	ldr	r1, [pc, #12]	; (12b60 <shell_vt100_colors_restore+0x48>)
   12b54:	6960      	ldr	r0, [r4, #20]
   12b56:	466a      	mov	r2, sp
   12b58:	f016 fcfd 	bl	29556 <shell_raw_fprintf>
}
   12b5c:	b003      	add	sp, #12
   12b5e:	bd30      	pop	{r4, r5, pc}
   12b60:	000306d9 	.word	0x000306d9

00012b64 <shell_op_word_remove>:
{
   12b64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
   12b66:	6883      	ldr	r3, [r0, #8]
	if ((shell->ctx->cmd_buff_len == 0) ||
   12b68:	8e5a      	ldrh	r2, [r3, #50]	; 0x32
{
   12b6a:	4605      	mov	r5, r0
	if ((shell->ctx->cmd_buff_len == 0) ||
   12b6c:	2a00      	cmp	r2, #0
   12b6e:	d046      	beq.n	12bfe <shell_op_word_remove+0x9a>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
   12b70:	8e98      	ldrh	r0, [r3, #52]	; 0x34
	if ((shell->ctx->cmd_buff_len == 0) ||
   12b72:	2800      	cmp	r0, #0
   12b74:	d043      	beq.n	12bfe <shell_op_word_remove+0x9a>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos - 1];
   12b76:	3037      	adds	r0, #55	; 0x37
   12b78:	4418      	add	r0, r3
	char *str_start = &shell->ctx->cmd_buff[0];
   12b7a:	f103 0638 	add.w	r6, r3, #56	; 0x38
   12b7e:	4603      	mov	r3, r0
   12b80:	1ac4      	subs	r4, r0, r3
	while ((str >= str_start) && (*str == ' ')) {
   12b82:	42b3      	cmp	r3, r6
   12b84:	b2a4      	uxth	r4, r4
   12b86:	4619      	mov	r1, r3
   12b88:	d30d      	bcc.n	12ba6 <shell_op_word_remove+0x42>
   12b8a:	f811 7901 	ldrb.w	r7, [r1], #-1
   12b8e:	2f20      	cmp	r7, #32
   12b90:	d033      	beq.n	12bfa <shell_op_word_remove+0x96>
   12b92:	4619      	mov	r1, r3
   12b94:	3b01      	subs	r3, #1
	while ((str >= str_start) && (*str != ' ')) {
   12b96:	7808      	ldrb	r0, [r1, #0]
   12b98:	2820      	cmp	r0, #32
   12b9a:	d004      	beq.n	12ba6 <shell_op_word_remove+0x42>
		++chars_to_delete;
   12b9c:	3401      	adds	r4, #1
	while ((str >= str_start) && (*str != ' ')) {
   12b9e:	429e      	cmp	r6, r3
		++chars_to_delete;
   12ba0:	b2a4      	uxth	r4, r4
		--str;
   12ba2:	4619      	mov	r1, r3
	while ((str >= str_start) && (*str != ' ')) {
   12ba4:	d9f5      	bls.n	12b92 <shell_op_word_remove+0x2e>
	memmove(str + 1, str + 1 + chars_to_delete,
   12ba6:	1c63      	adds	r3, r4, #1
   12ba8:	1c4e      	adds	r6, r1, #1
   12baa:	1b12      	subs	r2, r2, r4
   12bac:	4419      	add	r1, r3
   12bae:	4630      	mov	r0, r6
   12bb0:	f017 fc36 	bl	2a420 <memmove>
	shell->ctx->cmd_buff_len -= chars_to_delete;
   12bb4:	68a9      	ldr	r1, [r5, #8]
   12bb6:	8e4a      	ldrh	r2, [r1, #50]	; 0x32
   12bb8:	1b12      	subs	r2, r2, r4
   12bba:	b292      	uxth	r2, r2
   12bbc:	864a      	strh	r2, [r1, #50]	; 0x32
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
   12bbe:	440a      	add	r2, r1
   12bc0:	2700      	movs	r7, #0
	shell_op_cursor_move(shell, -chars_to_delete);
   12bc2:	4261      	negs	r1, r4
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
   12bc4:	f882 7038 	strb.w	r7, [r2, #56]	; 0x38
	shell_op_cursor_move(shell, -chars_to_delete);
   12bc8:	4628      	mov	r0, r5
   12bca:	b209      	sxth	r1, r1
   12bcc:	f016 fcf8 	bl	295c0 <shell_op_cursor_move>
	SHELL_VT100_CMD(shell, SHELL_VT100_SAVECURSOR);
   12bd0:	6968      	ldr	r0, [r5, #20]
   12bd2:	4a0b      	ldr	r2, [pc, #44]	; (12c00 <shell_op_word_remove+0x9c>)
   12bd4:	490b      	ldr	r1, [pc, #44]	; (12c04 <shell_op_word_remove+0xa0>)
   12bd6:	f016 fcbe 	bl	29556 <shell_raw_fprintf>
	shell_internal_fprintf(shell, SHELL_NORMAL, "%s", str + 1);
   12bda:	4639      	mov	r1, r7
   12bdc:	4633      	mov	r3, r6
   12bde:	4a09      	ldr	r2, [pc, #36]	; (12c04 <shell_op_word_remove+0xa0>)
   12be0:	4628      	mov	r0, r5
   12be2:	f016 fdea 	bl	297ba <shell_internal_fprintf>
	clear_eos(shell);
   12be6:	6968      	ldr	r0, [r5, #20]
   12be8:	f7ff ff04 	bl	129f4 <clear_eos.isra.6>
	SHELL_VT100_CMD(shell, SHELL_VT100_RESTORECURSOR);
   12bec:	6968      	ldr	r0, [r5, #20]
   12bee:	4a06      	ldr	r2, [pc, #24]	; (12c08 <shell_op_word_remove+0xa4>)
   12bf0:	4904      	ldr	r1, [pc, #16]	; (12c04 <shell_op_word_remove+0xa0>)
}
   12bf2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   12bf6:	f016 bcae 	b.w	29556 <shell_raw_fprintf>
   12bfa:	460b      	mov	r3, r1
   12bfc:	e7c0      	b.n	12b80 <shell_op_word_remove+0x1c>
   12bfe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   12c00:	0002f995 	.word	0x0002f995
   12c04:	000306d9 	.word	0x000306d9
   12c08:	0002f998 	.word	0x0002f998

00012c0c <reprint_from_cursor>:
{
   12c0c:	b570      	push	{r4, r5, r6, lr}
   12c0e:	4604      	mov	r4, r0
   12c10:	460d      	mov	r5, r1
	if (data_removed) {
   12c12:	4616      	mov	r6, r2
   12c14:	b112      	cbz	r2, 12c1c <reprint_from_cursor+0x10>
		clear_eos(shell);
   12c16:	6940      	ldr	r0, [r0, #20]
   12c18:	f7ff feec 	bl	129f4 <clear_eos.isra.6>
		      &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos]);
   12c1c:	68a2      	ldr	r2, [r4, #8]
	shell_internal_fprintf(shell, SHELL_NORMAL, "%s",
   12c1e:	8e93      	ldrh	r3, [r2, #52]	; 0x34
   12c20:	3338      	adds	r3, #56	; 0x38
   12c22:	4413      	add	r3, r2
   12c24:	4620      	mov	r0, r4
   12c26:	4a0c      	ldr	r2, [pc, #48]	; (12c58 <reprint_from_cursor+0x4c>)
   12c28:	2100      	movs	r1, #0
   12c2a:	f016 fdc6 	bl	297ba <shell_internal_fprintf>
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
   12c2e:	4620      	mov	r0, r4
   12c30:	f850 3f08 	ldr.w	r3, [r0, #8]!
   12c34:	8e5a      	ldrh	r2, [r3, #50]	; 0x32
   12c36:	869a      	strh	r2, [r3, #52]	; 0x34
	if (full_line_cmd(shell)) {
   12c38:	f016 fc9a 	bl	29570 <full_line_cmd.isra.8>
   12c3c:	b128      	cbz	r0, 12c4a <reprint_from_cursor+0x3e>
		if (((data_removed) && (diff > 0)) || (!data_removed)) {
   12c3e:	b106      	cbz	r6, 12c42 <reprint_from_cursor+0x36>
   12c40:	b11d      	cbz	r5, 12c4a <reprint_from_cursor+0x3e>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
   12c42:	4906      	ldr	r1, [pc, #24]	; (12c5c <reprint_from_cursor+0x50>)
   12c44:	6960      	ldr	r0, [r4, #20]
   12c46:	f016 fc86 	bl	29556 <shell_raw_fprintf>
	shell_op_cursor_move(shell, -diff);
   12c4a:	4269      	negs	r1, r5
   12c4c:	4620      	mov	r0, r4
   12c4e:	b209      	sxth	r1, r1
}
   12c50:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	shell_op_cursor_move(shell, -diff);
   12c54:	f016 bcb4 	b.w	295c0 <shell_op_cursor_move>
   12c58:	000306d9 	.word	0x000306d9
   12c5c:	0002f978 	.word	0x0002f978

00012c60 <shell_op_char_insert>:
{
   12c60:	b513      	push	{r0, r1, r4, lr}
	if (shell->ctx->internal.flags.insert_mode &&
   12c62:	6883      	ldr	r3, [r0, #8]
{
   12c64:	f88d 1007 	strb.w	r1, [sp, #7]
	if (shell->ctx->internal.flags.insert_mode &&
   12c68:	f8d3 2258 	ldr.w	r2, [r3, #600]	; 0x258
   12c6c:	07d2      	lsls	r2, r2, #31
{
   12c6e:	4604      	mov	r4, r0
	if (shell->ctx->internal.flags.insert_mode &&
   12c70:	d51d      	bpl.n	12cae <shell_op_char_insert+0x4e>
		(shell->ctx->cmd_buff_len != shell->ctx->cmd_buff_pos)) {
   12c72:	8e99      	ldrh	r1, [r3, #52]	; 0x34
	if (shell->ctx->internal.flags.insert_mode &&
   12c74:	8e5a      	ldrh	r2, [r3, #50]	; 0x32
   12c76:	428a      	cmp	r2, r1
   12c78:	d019      	beq.n	12cae <shell_op_char_insert+0x4e>
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos++] = data;
   12c7a:	1c48      	adds	r0, r1, #1
   12c7c:	8698      	strh	r0, [r3, #52]	; 0x34
   12c7e:	440b      	add	r3, r1
		char_replace(shell, data);
   12c80:	f89d 2007 	ldrb.w	r2, [sp, #7]
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos++] = data;
   12c84:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
	if (!flag_echo_get(shell)) {
   12c88:	68a3      	ldr	r3, [r4, #8]
	return shell->ctx->internal.flags.echo == 1 ? true : false;
   12c8a:	f8d3 3258 	ldr.w	r3, [r3, #600]	; 0x258
   12c8e:	075b      	lsls	r3, r3, #29
   12c90:	d50b      	bpl.n	12caa <shell_op_char_insert+0x4a>
	shell_raw_fprintf(shell->fprintf_ctx, "%c", data);
   12c92:	6960      	ldr	r0, [r4, #20]
   12c94:	4909      	ldr	r1, [pc, #36]	; (12cbc <shell_op_char_insert+0x5c>)
   12c96:	f016 fc5e 	bl	29556 <shell_raw_fprintf>
	if (shell_cursor_in_empty_line(shell)) {
   12c9a:	4620      	mov	r0, r4
   12c9c:	f016 fc7c 	bl	29598 <shell_cursor_in_empty_line>
   12ca0:	b118      	cbz	r0, 12caa <shell_op_char_insert+0x4a>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
   12ca2:	4907      	ldr	r1, [pc, #28]	; (12cc0 <shell_op_char_insert+0x60>)
   12ca4:	6960      	ldr	r0, [r4, #20]
   12ca6:	f016 fc56 	bl	29556 <shell_raw_fprintf>
}
   12caa:	b002      	add	sp, #8
   12cac:	bd10      	pop	{r4, pc}
		data_insert(shell, &data, 1);
   12cae:	2201      	movs	r2, #1
   12cb0:	f10d 0107 	add.w	r1, sp, #7
   12cb4:	4620      	mov	r0, r4
   12cb6:	f016 fd8d 	bl	297d4 <data_insert>
}
   12cba:	e7f6      	b.n	12caa <shell_op_char_insert+0x4a>
   12cbc:	0002f9a3 	.word	0x0002f9a3
   12cc0:	0002f978 	.word	0x0002f978

00012cc4 <shell_print_prompt_and_cmd>:
	shell_internal_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
   12cc4:	6883      	ldr	r3, [r0, #8]
   12cc6:	4a0a      	ldr	r2, [pc, #40]	; (12cf0 <shell_print_prompt_and_cmd+0x2c>)
   12cc8:	681b      	ldr	r3, [r3, #0]
{
   12cca:	b510      	push	{r4, lr}
   12ccc:	4604      	mov	r4, r0
	shell_internal_fprintf(shell, SHELL_INFO, "%s", shell->ctx->prompt);
   12cce:	2103      	movs	r1, #3
   12cd0:	f016 fd73 	bl	297ba <shell_internal_fprintf>
	if (flag_echo_get(shell)) {
   12cd4:	68a3      	ldr	r3, [r4, #8]
	return shell->ctx->internal.flags.echo == 1 ? true : false;
   12cd6:	f8d3 3258 	ldr.w	r3, [r3, #600]	; 0x258
   12cda:	075b      	lsls	r3, r3, #29
   12cdc:	d507      	bpl.n	12cee <shell_print_prompt_and_cmd+0x2a>
		shell_print_cmd(shell);
   12cde:	4620      	mov	r0, r4
   12ce0:	f7ff feee 	bl	12ac0 <shell_print_cmd>
		shell_op_cursor_position_synchronize(shell);
   12ce4:	4620      	mov	r0, r4
}
   12ce6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		shell_op_cursor_position_synchronize(shell);
   12cea:	f7ff bebf 	b.w	12a6c <shell_op_cursor_position_synchronize>
}
   12cee:	bd10      	pop	{r4, pc}
   12cf0:	000306d9 	.word	0x000306d9

00012cf4 <init>:
static int init(const struct shell_transport *transport,
		const void *config,
		shell_transport_handler_t evt_handler,
		void *context)
{
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
   12cf4:	6840      	ldr	r0, [r0, #4]
{
   12cf6:	b510      	push	{r4, lr}
   12cf8:	460c      	mov	r4, r1

	sh_uart->ctrl_blk->dev = (struct device *)config;
   12cfa:	6801      	ldr	r1, [r0, #0]
	sh_uart->ctrl_blk->handler = evt_handler;
	sh_uart->ctrl_blk->context = context;
   12cfc:	608b      	str	r3, [r1, #8]
static inline void uart_irq_callback_user_data_set(
					struct device *dev,
					uart_irq_callback_user_data_t cb,
					void *user_data)
{
	const struct uart_driver_api *api =
   12cfe:	6863      	ldr	r3, [r4, #4]
	sh_uart->ctrl_blk->handler = evt_handler;
   12d00:	e9c1 4200 	strd	r4, r2, [r1]
		(const struct uart_driver_api *)dev->driver_api;

	if ((api != NULL) && (api->irq_callback_set != NULL)) {
   12d04:	b12b      	cbz	r3, 12d12 <init+0x1e>
   12d06:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   12d08:	b11b      	cbz	r3, 12d12 <init+0x1e>
		api->irq_callback_set(dev, cb, user_data);
   12d0a:	4602      	mov	r2, r0
   12d0c:	4904      	ldr	r1, [pc, #16]	; (12d20 <init+0x2c>)
   12d0e:	4620      	mov	r0, r4
   12d10:	4798      	blx	r3
	if (api->irq_rx_enable) {
   12d12:	6863      	ldr	r3, [r4, #4]
   12d14:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   12d16:	b10b      	cbz	r3, 12d1c <init+0x28>
		api->irq_rx_enable(dev);
   12d18:	4620      	mov	r0, r4
   12d1a:	4798      	blx	r3
		k_timer_user_data_set(sh_uart->timer, (void *)sh_uart);
		k_timer_start(sh_uart->timer, RX_POLL_PERIOD, RX_POLL_PERIOD);
	}

	return 0;
}
   12d1c:	2000      	movs	r0, #0
   12d1e:	bd10      	pop	{r4, pc}
   12d20:	00012d4d 	.word	0x00012d4d

00012d24 <enable_shell_uart>:
	.update = update,
#endif /* CONFIG_MCUMGR_SMP_SHELL */
};

static int enable_shell_uart(struct device *arg)
{
   12d24:	b507      	push	{r0, r1, r2, lr}
	if (z_syscall_trap()) {
		return (struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
   12d26:	4807      	ldr	r0, [pc, #28]	; (12d44 <enable_shell_uart+0x20>)
   12d28:	f013 faec 	bl	26304 <z_impl_device_get_binding>
	bool log_backend = CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL > 0;
	u32_t level =
		(CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL > LOG_LEVEL_DBG) ?
		CONFIG_LOG_MAX_LEVEL : CONFIG_SHELL_BACKEND_SERIAL_LOG_LEVEL;

	shell_init(&shell_uart, dev, true, log_backend, level);
   12d2c:	2304      	movs	r3, #4
   12d2e:	9300      	str	r3, [sp, #0]
   12d30:	2301      	movs	r3, #1
   12d32:	4601      	mov	r1, r0
   12d34:	461a      	mov	r2, r3
   12d36:	4804      	ldr	r0, [pc, #16]	; (12d48 <enable_shell_uart+0x24>)
   12d38:	f7ff fd34 	bl	127a4 <shell_init>

	return 0;
}
   12d3c:	2000      	movs	r0, #0
   12d3e:	b003      	add	sp, #12
   12d40:	f85d fb04 	ldr.w	pc, [sp], #4
   12d44:	0002f9a6 	.word	0x0002f9a6
   12d48:	0002e0ec 	.word	0x0002e0ec

00012d4c <uart_callback>:
{
   12d4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct device *dev = sh_uart->ctrl_blk->dev;
   12d50:	6803      	ldr	r3, [r0, #0]
{
   12d52:	b085      	sub	sp, #20
   12d54:	4604      	mov	r4, r0
	struct device *dev = sh_uart->ctrl_blk->dev;
   12d56:	681d      	ldr	r5, [r3, #0]
	if (api->irq_update) {
   12d58:	686b      	ldr	r3, [r5, #4]
   12d5a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   12d5c:	b10b      	cbz	r3, 12d62 <uart_callback+0x16>
		return api->irq_update(dev);
   12d5e:	4628      	mov	r0, r5
   12d60:	4798      	blx	r3
	if (api->irq_rx_ready) {
   12d62:	686b      	ldr	r3, [r5, #4]
   12d64:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   12d66:	2b00      	cmp	r3, #0
   12d68:	d030      	beq.n	12dcc <uart_callback+0x80>
		return api->irq_rx_ready(dev);
   12d6a:	4628      	mov	r0, r5
   12d6c:	4798      	blx	r3
	if (uart_irq_rx_ready(dev)) {
   12d6e:	2800      	cmp	r0, #0
   12d70:	d02c      	beq.n	12dcc <uart_callback+0x80>
   12d72:	4e3c      	ldr	r6, [pc, #240]	; (12e64 <uart_callback+0x118>)
			LOG_WRN("RX ring buffer full.");
   12d74:	4b3c      	ldr	r3, [pc, #240]	; (12e68 <uart_callback+0x11c>)
   12d76:	f8df a0f4 	ldr.w	sl, [pc, #244]	; 12e6c <uart_callback+0x120>
   12d7a:	f8df b0f4 	ldr.w	fp, [pc, #244]	; 12e70 <uart_callback+0x124>
   12d7e:	1af6      	subs	r6, r6, r3
   12d80:	f3c6 06c9 	ubfx	r6, r6, #3, #10
	bool new_data = false;
   12d84:	2700      	movs	r7, #0
		len = ring_buf_put_claim(sh_uart->rx_ringbuf, &data,
   12d86:	68e0      	ldr	r0, [r4, #12]
   12d88:	a903      	add	r1, sp, #12
   12d8a:	6902      	ldr	r2, [r0, #16]
   12d8c:	f015 fa00 	bl	28190 <ring_buf_put_claim>
		if (len > 0) {
   12d90:	4680      	mov	r8, r0
   12d92:	2800      	cmp	r0, #0
   12d94:	d03f      	beq.n	12e16 <uart_callback+0xca>
			rd_len = uart_fifo_read(sh_uart->ctrl_blk->dev,
   12d96:	6823      	ldr	r3, [r4, #0]
   12d98:	6818      	ldr	r0, [r3, #0]
	if (api->fifo_read) {
   12d9a:	6843      	ldr	r3, [r0, #4]
   12d9c:	699b      	ldr	r3, [r3, #24]
   12d9e:	2b00      	cmp	r3, #0
   12da0:	d037      	beq.n	12e12 <uart_callback+0xc6>
		return api->fifo_read(dev, rx_data, size);
   12da2:	4642      	mov	r2, r8
   12da4:	9903      	ldr	r1, [sp, #12]
   12da6:	4798      	blx	r3
				new_data = true;
   12da8:	1e03      	subs	r3, r0, #0
			int err = ring_buf_put_finish(sh_uart->rx_ringbuf,
   12daa:	4619      	mov	r1, r3
   12dac:	68e0      	ldr	r0, [r4, #12]
   12dae:	9301      	str	r3, [sp, #4]
				new_data = true;
   12db0:	bf18      	it	ne
   12db2:	2701      	movne	r7, #1
			int err = ring_buf_put_finish(sh_uart->rx_ringbuf,
   12db4:	f015 fa08 	bl	281c8 <ring_buf_put_finish>
			__ASSERT_NO_MSG(err == 0);
   12db8:	9b01      	ldr	r3, [sp, #4]
	} while (rd_len && (rd_len == len));
   12dba:	b10b      	cbz	r3, 12dc0 <uart_callback+0x74>
   12dbc:	4598      	cmp	r8, r3
   12dbe:	d0e2      	beq.n	12d86 <uart_callback+0x3a>
	if (new_data) {
   12dc0:	b127      	cbz	r7, 12dcc <uart_callback+0x80>
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_RX_RDY,
   12dc2:	6823      	ldr	r3, [r4, #0]
   12dc4:	2000      	movs	r0, #0
   12dc6:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
   12dca:	4790      	blx	r2
	if (api->irq_tx_ready) {
   12dcc:	686b      	ldr	r3, [r5, #4]
   12dce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   12dd0:	b1e3      	cbz	r3, 12e0c <uart_callback+0xc0>
		return api->irq_tx_ready(dev);
   12dd2:	4628      	mov	r0, r5
   12dd4:	4798      	blx	r3
	if (uart_irq_tx_ready(dev)) {
   12dd6:	b1c8      	cbz	r0, 12e0c <uart_callback+0xc0>
	len = ring_buf_get_claim(sh_uart->tx_ringbuf, (u8_t **)&data,
   12dd8:	68a0      	ldr	r0, [r4, #8]
	struct device *dev = sh_uart->ctrl_blk->dev;
   12dda:	6823      	ldr	r3, [r4, #0]
	len = ring_buf_get_claim(sh_uart->tx_ringbuf, (u8_t **)&data,
   12ddc:	6902      	ldr	r2, [r0, #16]
	struct device *dev = sh_uart->ctrl_blk->dev;
   12dde:	681e      	ldr	r6, [r3, #0]
	len = ring_buf_get_claim(sh_uart->tx_ringbuf, (u8_t **)&data,
   12de0:	a903      	add	r1, sp, #12
   12de2:	f015 fa23 	bl	2822c <ring_buf_get_claim>
	if (len) {
   12de6:	4605      	mov	r5, r0
   12de8:	2800      	cmp	r0, #0
   12dea:	d034      	beq.n	12e56 <uart_callback+0x10a>
	if (api->fifo_fill) {
   12dec:	6873      	ldr	r3, [r6, #4]
   12dee:	695b      	ldr	r3, [r3, #20]
   12df0:	b37b      	cbz	r3, 12e52 <uart_callback+0x106>
		return api->fifo_fill(dev, tx_data, size);
   12df2:	4602      	mov	r2, r0
   12df4:	9903      	ldr	r1, [sp, #12]
   12df6:	4630      	mov	r0, r6
   12df8:	4798      	blx	r3
   12dfa:	4601      	mov	r1, r0
		err = ring_buf_get_finish(sh_uart->tx_ringbuf, len);
   12dfc:	68a0      	ldr	r0, [r4, #8]
   12dfe:	f015 fa36 	bl	2826e <ring_buf_get_finish>
	sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
   12e02:	6823      	ldr	r3, [r4, #0]
   12e04:	2001      	movs	r0, #1
   12e06:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
   12e0a:	4790      	blx	r2
}
   12e0c:	b005      	add	sp, #20
   12e0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return 0;
   12e12:	4618      	mov	r0, r3
   12e14:	e7c8      	b.n	12da8 <uart_callback+0x5c>
			LOG_WRN("RX ring buffer full.");
   12e16:	f8da 3000 	ldr.w	r3, [sl]
   12e1a:	f013 0f06 	tst.w	r3, #6
   12e1e:	d00b      	beq.n	12e38 <uart_callback+0xec>
   12e20:	f029 033f 	bic.w	r3, r9, #63	; 0x3f
   12e24:	f043 0302 	orr.w	r3, r3, #2
   12e28:	f363 0907 	bfi	r9, r3, #0, #8
   12e2c:	f366 198f 	bfi	r9, r6, #6, #10
   12e30:	4649      	mov	r1, r9
   12e32:	4658      	mov	r0, fp
   12e34:	f015 fd81 	bl	2893a <log_0>
			rd_len = uart_fifo_read(sh_uart->ctrl_blk->dev,
   12e38:	6823      	ldr	r3, [r4, #0]
   12e3a:	6818      	ldr	r0, [r3, #0]
	if (api->fifo_read) {
   12e3c:	6843      	ldr	r3, [r0, #4]
   12e3e:	699b      	ldr	r3, [r3, #24]
   12e40:	b12b      	cbz	r3, 12e4e <uart_callback+0x102>
		return api->fifo_read(dev, rx_data, size);
   12e42:	2201      	movs	r2, #1
   12e44:	f10d 010b 	add.w	r1, sp, #11
   12e48:	4798      	blx	r3
   12e4a:	4603      	mov	r3, r0
   12e4c:	e7b5      	b.n	12dba <uart_callback+0x6e>
	return 0;
   12e4e:	4618      	mov	r0, r3
   12e50:	e7fb      	b.n	12e4a <uart_callback+0xfe>
	return 0;
   12e52:	4619      	mov	r1, r3
   12e54:	e7d2      	b.n	12dfc <uart_callback+0xb0>
		arch_syscall_invoke1(*(uintptr_t *)&dev, K_SYSCALL_UART_IRQ_TX_DISABLE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_irq_tx_disable(dev);
   12e56:	4630      	mov	r0, r6
   12e58:	f016 fd1c 	bl	29894 <z_impl_uart_irq_tx_disable>
		sh_uart->ctrl_blk->tx_busy = 0;
   12e5c:	6823      	ldr	r3, [r4, #0]
   12e5e:	60dd      	str	r5, [r3, #12]
   12e60:	e7cf      	b.n	12e02 <uart_callback+0xb6>
   12e62:	bf00      	nop
   12e64:	0002dc70 	.word	0x0002dc70
   12e68:	0002db28 	.word	0x0002db28
   12e6c:	2001003c 	.word	0x2001003c
   12e70:	0002f9da 	.word	0x0002f9da

00012e74 <formatted_text_print.constprop.2>:
 *   shell		Pointer to shell instance.
 *   p_str		Pointer to string to be printed.
 *   terminal_offset	Requested left margin.
 *   offset_first_line	Add margin to the first printed line.
 */
static void formatted_text_print(const struct shell *shell, const char *str,
   12e74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12e78:	4605      	mov	r5, r0
   12e7a:	4690      	mov	r8, r2
				 size_t terminal_offset, bool offset_first_line)
{
	size_t offset = 0;
	size_t length;

	if (str == NULL) {
   12e7c:	460f      	mov	r7, r1
   12e7e:	2900      	cmp	r1, #0
   12e80:	d06e      	beq.n	12f60 <formatted_text_print.constprop.2+0xec>
   12e82:	2400      	movs	r4, #0
		shell_op_cursor_horiz_move(shell, terminal_offset);
	}


	/* Skipping whitespace. */
	while (isspace((int) *(str + offset))) {
   12e84:	5d3b      	ldrb	r3, [r7, r4]
   12e86:	2b20      	cmp	r3, #32
   12e88:	d025      	beq.n	12ed6 <formatted_text_print.constprop.2+0x62>
   12e8a:	3b09      	subs	r3, #9
   12e8c:	2b04      	cmp	r3, #4
   12e8e:	d922      	bls.n	12ed6 <formatted_text_print.constprop.2+0x62>
	shell_raw_fprintf(shell->fprintf_ctx, "\n");
   12e90:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 12f64 <formatted_text_print.constprop.2+0xf0>
	return str == NULL ? 0U : (u16_t)strlen(str);
   12e94:	4638      	mov	r0, r7
   12e96:	f017 fa91 	bl	2a3bc <strlen>
		size_t idx = 0;

		length = shell_strlen(str) - offset;

		if (length <=
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
   12e9a:	68ab      	ldr	r3, [r5, #8]
   12e9c:	8d59      	ldrh	r1, [r3, #42]	; 0x2a
		length = shell_strlen(str) - offset;
   12e9e:	b280      	uxth	r0, r0
   12ea0:	1b00      	subs	r0, r0, r4
		    shell->ctx->vt100_ctx.cons.terminal_wid - terminal_offset) {
   12ea2:	eba1 0308 	sub.w	r3, r1, r8
		if (length <=
   12ea6:	4298      	cmp	r0, r3
   12ea8:	eb07 0a04 	add.w	sl, r7, r4
   12eac:	d915      	bls.n	12eda <formatted_text_print.constprop.2+0x66>
   12eae:	4650      	mov	r0, sl
		size_t idx = 0;
   12eb0:	2600      	movs	r6, #0
		length = shell->ctx->vt100_ctx.cons.terminal_wid
				- terminal_offset;

		while (true) {
			/* Determining line break. */
			if (isspace((int) (*(str + offset + idx)))) {
   12eb2:	f810 2b01 	ldrb.w	r2, [r0], #1
   12eb6:	2a20      	cmp	r2, #32
   12eb8:	d006      	beq.n	12ec8 <formatted_text_print.constprop.2+0x54>
   12eba:	f1a2 0c09 	sub.w	ip, r2, #9
   12ebe:	f1bc 0f04 	cmp.w	ip, #4
   12ec2:	d802      	bhi.n	12eca <formatted_text_print.constprop.2+0x56>
				length = idx;
				if (*(str + offset + idx) == '\n') {
   12ec4:	2a0a      	cmp	r2, #10
   12ec6:	d031      	beq.n	12f2c <formatted_text_print.constprop.2+0xb8>
   12ec8:	4633      	mov	r3, r6
					break;
				}
			}

			if ((idx + terminal_offset) >=
   12eca:	eb08 0206 	add.w	r2, r8, r6
   12ece:	4291      	cmp	r1, r2
   12ed0:	d92b      	bls.n	12f2a <formatted_text_print.constprop.2+0xb6>
			    shell->ctx->vt100_ctx.cons.terminal_wid) {
				/* End of line reached. */
				break;
			}

			++idx;
   12ed2:	3601      	adds	r6, #1
   12ed4:	e7ed      	b.n	12eb2 <formatted_text_print.constprop.2+0x3e>
		++offset;
   12ed6:	3401      	adds	r4, #1
   12ed8:	e7d4      	b.n	12e84 <formatted_text_print.constprop.2+0x10>
   12eda:	4653      	mov	r3, sl
			for (idx = 0; idx < length; idx++) {
   12edc:	2600      	movs	r6, #0
   12ede:	42b0      	cmp	r0, r6
   12ee0:	d017      	beq.n	12f12 <formatted_text_print.constprop.2+0x9e>
				if (*(str + offset + idx) == '\n') {
   12ee2:	f813 2b01 	ldrb.w	r2, [r3], #1
   12ee6:	2a0a      	cmp	r2, #10
   12ee8:	eb04 0906 	add.w	r9, r4, r6
   12eec:	d11b      	bne.n	12f26 <formatted_text_print.constprop.2+0xb2>
	shell_fprintf_buffer_flush(shell->fprintf_ctx);
   12eee:	6968      	ldr	r0, [r5, #20]
   12ef0:	f016 f926 	bl	29140 <shell_fprintf_buffer_flush>
					shell_write(shell, str + offset, idx);
   12ef4:	4632      	mov	r2, r6
   12ef6:	4651      	mov	r1, sl
   12ef8:	4628      	mov	r0, r5
   12efa:	f016 fc01 	bl	29700 <shell_write>
   12efe:	4919      	ldr	r1, [pc, #100]	; (12f64 <formatted_text_print.constprop.2+0xf0>)
   12f00:	6968      	ldr	r0, [r5, #20]
   12f02:	f016 fd17 	bl	29934 <shell_raw_fprintf>
					shell_op_cursor_horiz_move(shell,
   12f06:	4641      	mov	r1, r8
   12f08:	4628      	mov	r0, r5
					offset += idx + 1;
   12f0a:	f109 0401 	add.w	r4, r9, #1
					shell_op_cursor_horiz_move(shell,
   12f0e:	f7ff fd89 	bl	12a24 <shell_op_cursor_horiz_move>
			shell_raw_fprintf(shell->fprintf_ctx, str + offset);
   12f12:	1939      	adds	r1, r7, r4
   12f14:	6968      	ldr	r0, [r5, #20]
   12f16:	f016 fd0d 	bl	29934 <shell_raw_fprintf>
   12f1a:	6968      	ldr	r0, [r5, #20]
   12f1c:	4911      	ldr	r1, [pc, #68]	; (12f64 <formatted_text_print.constprop.2+0xf0>)
		cursor_next_line_move(shell);
		shell_op_cursor_horiz_move(shell, terminal_offset);

	}
	cursor_next_line_move(shell);
}
   12f1e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12f22:	f016 bd07 	b.w	29934 <shell_raw_fprintf>
			for (idx = 0; idx < length; idx++) {
   12f26:	3601      	adds	r6, #1
   12f28:	e7d9      	b.n	12ede <formatted_text_print.constprop.2+0x6a>
			if ((idx + terminal_offset) >=
   12f2a:	461e      	mov	r6, r3
   12f2c:	6968      	ldr	r0, [r5, #20]
   12f2e:	f016 f907 	bl	29140 <shell_fprintf_buffer_flush>
		shell_write(shell, str + offset, length);
   12f32:	4632      	mov	r2, r6
   12f34:	4651      	mov	r1, sl
   12f36:	4628      	mov	r0, r5
   12f38:	f016 fbe2 	bl	29700 <shell_write>
		offset += length;
   12f3c:	4434      	add	r4, r6
		while (isspace((int) (*(str + offset)))) {
   12f3e:	5d3b      	ldrb	r3, [r7, r4]
   12f40:	2b20      	cmp	r3, #32
   12f42:	d00b      	beq.n	12f5c <formatted_text_print.constprop.2+0xe8>
   12f44:	3b09      	subs	r3, #9
   12f46:	2b04      	cmp	r3, #4
   12f48:	d908      	bls.n	12f5c <formatted_text_print.constprop.2+0xe8>
   12f4a:	4649      	mov	r1, r9
   12f4c:	6968      	ldr	r0, [r5, #20]
   12f4e:	f016 fcf1 	bl	29934 <shell_raw_fprintf>
		shell_op_cursor_horiz_move(shell, terminal_offset);
   12f52:	4641      	mov	r1, r8
   12f54:	4628      	mov	r0, r5
   12f56:	f7ff fd65 	bl	12a24 <shell_op_cursor_horiz_move>
   12f5a:	e79b      	b.n	12e94 <formatted_text_print.constprop.2+0x20>
			++offset;
   12f5c:	3401      	adds	r4, #1
   12f5e:	e7ee      	b.n	12f3e <formatted_text_print.constprop.2+0xca>
}
   12f60:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   12f64:	0002f978 	.word	0x0002f978

00012f68 <shell_help_subcmd_print>:

/* Function is printing command help, its subcommands name and subcommands
 * help string.
 */
void shell_help_subcmd_print(const struct shell *shell)
{
   12f68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct shell_static_entry static_entry;
	u16_t longest_syntax = 0U;
	size_t cmd_idx = 0;

	/* Checking if there are any subcommands available. */
	if (!shell->ctx->active_cmd.subcmd) {
   12f6c:	6882      	ldr	r2, [r0, #8]
{
   12f6e:	b08d      	sub	sp, #52	; 0x34
	if (!shell->ctx->active_cmd.subcmd) {
   12f70:	6912      	ldr	r2, [r2, #16]
	const struct shell_static_entry *entry = NULL;
   12f72:	2300      	movs	r3, #0
{
   12f74:	4604      	mov	r4, r0
	const struct shell_static_entry *entry = NULL;
   12f76:	9306      	str	r3, [sp, #24]
	if (!shell->ctx->active_cmd.subcmd) {
   12f78:	2a00      	cmp	r2, #0
   12f7a:	d051      	beq.n	13020 <shell_help_subcmd_print+0xb8>
	size_t cmd_idx = 0;
   12f7c:	4698      	mov	r8, r3
	u16_t longest_syntax = 0U;
   12f7e:	461d      	mov	r5, r3
		return;
	}

	/* Searching for the longest subcommand to print. */
	do {
		shell_cmd_get(shell, shell->ctx->active_cmd.subcmd,
   12f80:	ae07      	add	r6, sp, #28
   12f82:	af06      	add	r7, sp, #24
   12f84:	e9cd 7600 	strd	r7, r6, [sp]
   12f88:	68a1      	ldr	r1, [r4, #8]
   12f8a:	4643      	mov	r3, r8
   12f8c:	2201      	movs	r2, #1
   12f8e:	6909      	ldr	r1, [r1, #16]
   12f90:	4620      	mov	r0, r4
   12f92:	f7ff fd05 	bl	129a0 <shell_cmd_get>
			      !SHELL_CMD_ROOT_LVL,
			      cmd_idx++, &entry, &static_entry);

		if (!entry) {
   12f96:	9b06      	ldr	r3, [sp, #24]
		shell_cmd_get(shell, shell->ctx->active_cmd.subcmd,
   12f98:	f108 0901 	add.w	r9, r8, #1
		if (!entry) {
   12f9c:	2b00      	cmp	r3, #0
   12f9e:	d03c      	beq.n	1301a <shell_help_subcmd_print+0xb2>
			break;
		}

		u16_t len = shell_strlen(entry->syntax);
   12fa0:	6818      	ldr	r0, [r3, #0]
	return str == NULL ? 0U : (u16_t)strlen(str);
   12fa2:	b110      	cbz	r0, 12faa <shell_help_subcmd_print+0x42>
   12fa4:	f017 fa0a 	bl	2a3bc <strlen>
   12fa8:	b280      	uxth	r0, r0

		longest_syntax = longest_syntax > len ? longest_syntax : len;
   12faa:	4285      	cmp	r5, r0
   12fac:	bf38      	it	cc
   12fae:	4605      	movcc	r5, r0
	} while (cmd_idx != 0); /* too many commands */
   12fb0:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
   12fb4:	d12f      	bne.n	13016 <shell_help_subcmd_print+0xae>

	if (cmd_idx == 1) {
		return;
	}

	shell_internal_fprintf(shell, SHELL_NORMAL, "Subcommands:\n");
   12fb6:	4a20      	ldr	r2, [pc, #128]	; (13038 <shell_help_subcmd_print+0xd0>)
	const u16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
   12fb8:	f8df 9080 	ldr.w	r9, [pc, #128]	; 1303c <shell_help_subcmd_print+0xd4>
	shell_internal_fprintf(shell, SHELL_NORMAL, "Subcommands:\n");
   12fbc:	2100      	movs	r1, #0
   12fbe:	4620      	mov	r0, r4
   12fc0:	f016 fbfb 	bl	297ba <shell_internal_fprintf>

	/* Printing subcommands and help string (if exists). */
	cmd_idx = 0;
   12fc4:	2300      	movs	r3, #0

	while (true) {
		shell_cmd_get(shell, shell->ctx->active_cmd.subcmd,
   12fc6:	e9cd 7600 	strd	r7, r6, [sp]
   12fca:	68a1      	ldr	r1, [r4, #8]
   12fcc:	2201      	movs	r2, #1
   12fce:	6909      	ldr	r1, [r1, #16]
   12fd0:	4620      	mov	r0, r4
   12fd2:	f103 0b01 	add.w	fp, r3, #1
   12fd6:	f7ff fce3 	bl	129a0 <shell_cmd_get>
			      !SHELL_CMD_ROOT_LVL,
			      cmd_idx++, &entry, &static_entry);

		if (entry == NULL) {
   12fda:	9b06      	ldr	r3, [sp, #24]
   12fdc:	b303      	cbz	r3, 13020 <shell_help_subcmd_print+0xb8>
			break;
		}

		help_item_print(shell, entry->syntax, longest_syntax,
   12fde:	681a      	ldr	r2, [r3, #0]
	const u16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
   12fe0:	4816      	ldr	r0, [pc, #88]	; (1303c <shell_help_subcmd_print+0xd4>)
		help_item_print(shell, entry->syntax, longest_syntax,
   12fe2:	9205      	str	r2, [sp, #20]
   12fe4:	f8d3 8004 	ldr.w	r8, [r3, #4]
	const u16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
   12fe8:	f017 f9e8 	bl	2a3bc <strlen>
	if (item_name == NULL) {
   12fec:	9a05      	ldr	r2, [sp, #20]
	const u16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
   12fee:	4682      	mov	sl, r0
	if (item_name == NULL) {
   12ff0:	b17a      	cbz	r2, 13012 <shell_help_subcmd_print+0xaa>
		shell_internal_fprintf(shell, SHELL_NORMAL, "%s%-*s%s:",
   12ff2:	e9cd 2901 	strd	r2, r9, [sp, #4]
   12ff6:	9500      	str	r5, [sp, #0]
   12ff8:	464b      	mov	r3, r9
   12ffa:	4a11      	ldr	r2, [pc, #68]	; (13040 <shell_help_subcmd_print+0xd8>)
   12ffc:	2100      	movs	r1, #0
   12ffe:	4620      	mov	r0, r4
   13000:	f016 fbdb 	bl	297ba <shell_internal_fprintf>
	if (item_help == NULL) {
   13004:	f1b8 0f00 	cmp.w	r8, #0
   13008:	d10d      	bne.n	13026 <shell_help_subcmd_print+0xbe>
   1300a:	490e      	ldr	r1, [pc, #56]	; (13044 <shell_help_subcmd_print+0xdc>)
   1300c:	6960      	ldr	r0, [r4, #20]
   1300e:	f016 fc91 	bl	29934 <shell_raw_fprintf>
   13012:	465b      	mov	r3, fp
   13014:	e7d7      	b.n	12fc6 <shell_help_subcmd_print+0x5e>
		shell_cmd_get(shell, shell->ctx->active_cmd.subcmd,
   13016:	46c8      	mov	r8, r9
   13018:	e7b4      	b.n	12f84 <shell_help_subcmd_print+0x1c>
	if (cmd_idx == 1) {
   1301a:	f1b9 0f01 	cmp.w	r9, #1
   1301e:	d1ca      	bne.n	12fb6 <shell_help_subcmd_print+0x4e>
				entry->help);
	}
}
   13020:	b00d      	add	sp, #52	; 0x34
   13022:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	const u16_t offset = 2 * strlen(tabulator) + item_name_width + 1;
   13026:	1c6a      	adds	r2, r5, #1
   13028:	eb02 024a 	add.w	r2, r2, sl, lsl #1
	formatted_text_print(shell, item_help, offset, false);
   1302c:	b292      	uxth	r2, r2
   1302e:	4641      	mov	r1, r8
   13030:	4620      	mov	r0, r4
   13032:	f7ff ff1f 	bl	12e74 <formatted_text_print.constprop.2>
   13036:	e7ec      	b.n	13012 <shell_help_subcmd_print+0xaa>
   13038:	0002f9f3 	.word	0x0002f9f3
   1303c:	0002fa0b 	.word	0x0002fa0b
   13040:	0002fa01 	.word	0x0002fa01
   13044:	0002f978 	.word	0x0002f978

00013048 <shell_help_cmd_print>:

void shell_help_cmd_print(const struct shell *shell)
{
	static const char cmd_sep[] = " - ";	/* commands separator */

	u16_t field_width = shell_strlen(shell->ctx->active_cmd.syntax) +
   13048:	6883      	ldr	r3, [r0, #8]
{
   1304a:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1304c:	4605      	mov	r5, r0
	u16_t field_width = shell_strlen(shell->ctx->active_cmd.syntax) +
   1304e:	6898      	ldr	r0, [r3, #8]
   13050:	b1c8      	cbz	r0, 13086 <shell_help_cmd_print+0x3e>
   13052:	f017 f9b3 	bl	2a3bc <strlen>
   13056:	b284      	uxth	r4, r0
   13058:	4e0c      	ldr	r6, [pc, #48]	; (1308c <shell_help_cmd_print+0x44>)
   1305a:	4630      	mov	r0, r6
   1305c:	f017 f9ae 	bl	2a3bc <strlen>
							  shell_strlen(cmd_sep);

	shell_internal_fprintf(shell, SHELL_NORMAL, "%s%s",
   13060:	68ab      	ldr	r3, [r5, #8]
   13062:	9600      	str	r6, [sp, #0]
	u16_t field_width = shell_strlen(shell->ctx->active_cmd.syntax) +
   13064:	4404      	add	r4, r0
	shell_internal_fprintf(shell, SHELL_NORMAL, "%s%s",
   13066:	689b      	ldr	r3, [r3, #8]
   13068:	4a09      	ldr	r2, [pc, #36]	; (13090 <shell_help_cmd_print+0x48>)
   1306a:	4628      	mov	r0, r5
   1306c:	2100      	movs	r1, #0
   1306e:	f016 fba4 	bl	297ba <shell_internal_fprintf>
			       shell->ctx->active_cmd.syntax, cmd_sep);

	formatted_text_print(shell, shell->ctx->active_cmd.help,
   13072:	68ab      	ldr	r3, [r5, #8]
	u16_t field_width = shell_strlen(shell->ctx->active_cmd.syntax) +
   13074:	b2a4      	uxth	r4, r4
	formatted_text_print(shell, shell->ctx->active_cmd.help,
   13076:	68d9      	ldr	r1, [r3, #12]
   13078:	4622      	mov	r2, r4
   1307a:	4628      	mov	r0, r5
			     field_width, false);
}
   1307c:	b002      	add	sp, #8
   1307e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	formatted_text_print(shell, shell->ctx->active_cmd.help,
   13082:	f7ff bef7 	b.w	12e74 <formatted_text_print.constprop.2>
   13086:	4604      	mov	r4, r0
   13088:	e7e6      	b.n	13058 <shell_help_cmd_print+0x10>
   1308a:	bf00      	nop
   1308c:	0002f9ef 	.word	0x0002f9ef
   13090:	0002f972 	.word	0x0002f972

00013094 <cmd_clear>:
	cursor_restore(shell);
	return ret_val;
}

static int cmd_clear(const struct shell *shell, size_t argc, char **argv)
{
   13094:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(argv);

	SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
   13096:	4d07      	ldr	r5, [pc, #28]	; (130b4 <cmd_clear+0x20>)
   13098:	4a07      	ldr	r2, [pc, #28]	; (130b8 <cmd_clear+0x24>)
{
   1309a:	4604      	mov	r4, r0
	SHELL_VT100_CMD(shell, SHELL_VT100_CURSORHOME);
   1309c:	4629      	mov	r1, r5
   1309e:	6940      	ldr	r0, [r0, #20]
   130a0:	f016 fc8f 	bl	299c2 <shell_raw_fprintf>
	SHELL_VT100_CMD(shell, SHELL_VT100_CLEARSCREEN);
   130a4:	6960      	ldr	r0, [r4, #20]
   130a6:	4a05      	ldr	r2, [pc, #20]	; (130bc <cmd_clear+0x28>)
   130a8:	4629      	mov	r1, r5
   130aa:	f016 fc8a 	bl	299c2 <shell_raw_fprintf>

	return 0;
}
   130ae:	2000      	movs	r0, #0
   130b0:	bd38      	pop	{r3, r4, r5, pc}
   130b2:	bf00      	nop
   130b4:	000306d9 	.word	0x000306d9
   130b8:	0002fa14 	.word	0x0002fa14
   130bc:	0002fa18 	.word	0x0002fa18

000130c0 <cmd_resize_default>:
	return 0;
}

static int cmd_resize_default(const struct shell *shell,
			      size_t argc, char **argv)
{
   130c0:	b510      	push	{r4, lr}
   130c2:	4604      	mov	r4, r0
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);

	SHELL_VT100_CMD(shell, SHELL_VT100_SETCOL_80);
   130c4:	4a04      	ldr	r2, [pc, #16]	; (130d8 <cmd_resize_default+0x18>)
   130c6:	4905      	ldr	r1, [pc, #20]	; (130dc <cmd_resize_default+0x1c>)
   130c8:	6940      	ldr	r0, [r0, #20]
   130ca:	f016 fc7a 	bl	299c2 <shell_raw_fprintf>
	shell->ctx->vt100_ctx.cons.terminal_wid =  SHELL_DEFAULT_TERMINAL_WIDTH;
	shell->ctx->vt100_ctx.cons.terminal_hei = SHELL_DEFAULT_TERMINAL_HEIGHT;
   130ce:	68a3      	ldr	r3, [r4, #8]
   130d0:	4a03      	ldr	r2, [pc, #12]	; (130e0 <cmd_resize_default+0x20>)
   130d2:	629a      	str	r2, [r3, #40]	; 0x28

	return 0;
}
   130d4:	2000      	movs	r0, #0
   130d6:	bd10      	pop	{r4, pc}
   130d8:	0002fa1d 	.word	0x0002fa1d
   130dc:	000306d9 	.word	0x000306d9
   130e0:	00500018 	.word	0x00500018

000130e4 <cmd_shell_stats_show>:
{
   130e4:	b508      	push	{r3, lr}
	shell_print(shell, "Lost logs: %u", shell->stats->log_lost_cnt);
   130e6:	6983      	ldr	r3, [r0, #24]
   130e8:	4a03      	ldr	r2, [pc, #12]	; (130f8 <cmd_shell_stats_show+0x14>)
   130ea:	681b      	ldr	r3, [r3, #0]
   130ec:	2100      	movs	r1, #0
   130ee:	f015 ffe9 	bl	290c4 <shell_fprintf>
}
   130f2:	2000      	movs	r0, #0
   130f4:	bd08      	pop	{r3, pc}
   130f6:	bf00      	nop
   130f8:	0002fc52 	.word	0x0002fc52

000130fc <cmd_help>:
{
   130fc:	b510      	push	{r4, lr}
	shell_print(shell,
   130fe:	4a06      	ldr	r2, [pc, #24]	; (13118 <cmd_help+0x1c>)
{
   13100:	4604      	mov	r4, r0
	shell_print(shell,
   13102:	2100      	movs	r1, #0
   13104:	f015 ffde 	bl	290c4 <shell_fprintf>
	shell_print(shell,
   13108:	4620      	mov	r0, r4
   1310a:	4a04      	ldr	r2, [pc, #16]	; (1311c <cmd_help+0x20>)
   1310c:	2100      	movs	r1, #0
   1310e:	f015 ffd9 	bl	290c4 <shell_fprintf>
}
   13112:	2000      	movs	r0, #0
   13114:	bd10      	pop	{r4, pc}
   13116:	bf00      	nop
   13118:	0002fa57 	.word	0x0002fa57
   1311c:	0002fb46 	.word	0x0002fb46

00013120 <cmd_history>:
{
   13120:	b5f0      	push	{r4, r5, r6, r7, lr}
			shell_print(shell, "[%3d] %s",
   13122:	4f10      	ldr	r7, [pc, #64]	; (13164 <cmd_history+0x44>)
{
   13124:	b085      	sub	sp, #20
   13126:	4604      	mov	r4, r0
	size_t i = 0;
   13128:	2500      	movs	r5, #0
				  shell->ctx->temp_buff, &len);
   1312a:	68a2      	ldr	r2, [r4, #8]
		shell_history_get(shell->history, true,
   1312c:	68e0      	ldr	r0, [r4, #12]
   1312e:	f10d 030e 	add.w	r3, sp, #14
   13132:	f502 729c 	add.w	r2, r2, #312	; 0x138
   13136:	2101      	movs	r1, #1
   13138:	f016 fc65 	bl	29a06 <shell_history_get>
		if (len) {
   1313c:	f8bd 000e 	ldrh.w	r0, [sp, #14]
   13140:	68a3      	ldr	r3, [r4, #8]
   13142:	b158      	cbz	r0, 1315c <cmd_history+0x3c>
			shell_print(shell, "[%3d] %s",
   13144:	f503 739c 	add.w	r3, r3, #312	; 0x138
   13148:	9300      	str	r3, [sp, #0]
   1314a:	1c6e      	adds	r6, r5, #1
   1314c:	462b      	mov	r3, r5
   1314e:	463a      	mov	r2, r7
   13150:	2100      	movs	r1, #0
   13152:	4620      	mov	r0, r4
   13154:	f015 ffb6 	bl	290c4 <shell_fprintf>
   13158:	4635      	mov	r5, r6
		shell_history_get(shell->history, true,
   1315a:	e7e6      	b.n	1312a <cmd_history+0xa>
	shell->ctx->temp_buff[0] = '\0';
   1315c:	f883 0138 	strb.w	r0, [r3, #312]	; 0x138
}
   13160:	b005      	add	sp, #20
   13162:	bdf0      	pop	{r4, r5, r6, r7, pc}
   13164:	0002fc0e 	.word	0x0002fc0e

00013168 <cmd_echo>:
	if (argc == 2) {
   13168:	2902      	cmp	r1, #2
{
   1316a:	b507      	push	{r0, r1, r2, lr}
	if (argc == 2) {
   1316c:	d10c      	bne.n	13188 <cmd_echo+0x20>
		shell_error(shell, "%s:%s%s", argv[0],
   1316e:	6853      	ldr	r3, [r2, #4]
   13170:	9301      	str	r3, [sp, #4]
   13172:	4b0d      	ldr	r3, [pc, #52]	; (131a8 <cmd_echo+0x40>)
   13174:	9300      	str	r3, [sp, #0]
   13176:	6813      	ldr	r3, [r2, #0]
   13178:	4a0c      	ldr	r2, [pc, #48]	; (131ac <cmd_echo+0x44>)
   1317a:	f015 ffa3 	bl	290c4 <shell_fprintf>
   1317e:	f06f 0015 	mvn.w	r0, #21
}
   13182:	b003      	add	sp, #12
   13184:	f85d fb04 	ldr.w	pc, [sp], #4
	shell_print(shell, "Echo status: %s",
   13188:	6883      	ldr	r3, [r0, #8]
   1318a:	4a09      	ldr	r2, [pc, #36]	; (131b0 <cmd_echo+0x48>)
	return shell->ctx->internal.flags.echo == 1 ? true : false;
   1318c:	f8d3 3258 	ldr.w	r3, [r3, #600]	; 0x258
   13190:	f013 0f04 	tst.w	r3, #4
   13194:	f04f 0100 	mov.w	r1, #0
   13198:	4b06      	ldr	r3, [pc, #24]	; (131b4 <cmd_echo+0x4c>)
   1319a:	bf18      	it	ne
   1319c:	4613      	movne	r3, r2
   1319e:	4a06      	ldr	r2, [pc, #24]	; (131b8 <cmd_echo+0x50>)
   131a0:	f015 ff90 	bl	290c4 <shell_fprintf>
	return 0;
   131a4:	2000      	movs	r0, #0
   131a6:	e7ec      	b.n	13182 <cmd_echo+0x1a>
   131a8:	0002fa2c 	.word	0x0002fa2c
   131ac:	0002fa23 	.word	0x0002fa23
   131b0:	0002f893 	.word	0x0002f893
   131b4:	0002ea53 	.word	0x0002ea53
   131b8:	0002fa41 	.word	0x0002fa41

000131bc <cmd_resize>:

static int cmd_resize(const struct shell *shell, size_t argc, char **argv)
{
   131bc:	b5f0      	push	{r4, r5, r6, r7, lr}
	int err;

	if (argc != 1) {
   131be:	2901      	cmp	r1, #1
{
   131c0:	b085      	sub	sp, #20
   131c2:	4605      	mov	r5, r0
	if (argc != 1) {
   131c4:	d00d      	beq.n	131e2 <cmd_resize+0x26>
		shell_error(shell, "%s:%s%s", argv[0],
   131c6:	6853      	ldr	r3, [r2, #4]
   131c8:	9301      	str	r3, [sp, #4]
   131ca:	4b53      	ldr	r3, [pc, #332]	; (13318 <cmd_resize+0x15c>)
   131cc:	9300      	str	r3, [sp, #0]
   131ce:	6813      	ldr	r3, [r2, #0]
   131d0:	4a52      	ldr	r2, [pc, #328]	; (1331c <cmd_resize+0x160>)
   131d2:	2102      	movs	r1, #2
   131d4:	f015 ff76 	bl	290c4 <shell_fprintf>
			    SHELL_MSG_UNKNOWN_PARAMETER, argv[1]);
		return -EINVAL;
   131d8:	f06f 0415 	mvn.w	r4, #21
			   " screen size");
		return -ENOEXEC;
	}

	return 0;
}
   131dc:	4620      	mov	r0, r4
   131de:	b005      	add	sp, #20
   131e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	SHELL_VT100_CMD(shell, SHELL_VT100_SAVECURSOR);
   131e2:	4a4f      	ldr	r2, [pc, #316]	; (13320 <cmd_resize+0x164>)
   131e4:	494f      	ldr	r1, [pc, #316]	; (13324 <cmd_resize+0x168>)
   131e6:	6940      	ldr	r0, [r0, #20]
   131e8:	f016 fbeb 	bl	299c2 <shell_raw_fprintf>
	shell_op_cursor_vert_move(shell, -SHELL_MAX_TERMINAL_SIZE);
   131ec:	f06f 01f9 	mvn.w	r1, #249	; 0xf9
   131f0:	4628      	mov	r0, r5
   131f2:	f7ff fc07 	bl	12a04 <shell_op_cursor_vert_move>
	shell_op_cursor_horiz_move(shell, SHELL_MAX_TERMINAL_SIZE);
   131f6:	21fa      	movs	r1, #250	; 0xfa
   131f8:	4628      	mov	r0, r5
   131fa:	f7ff fc13 	bl	12a24 <shell_op_cursor_horiz_move>
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
   131fe:	68a8      	ldr	r0, [r5, #8]
	char c = 0;
   13200:	2400      	movs	r4, #0
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
   13202:	f44f 7280 	mov.w	r2, #256	; 0x100
   13206:	4621      	mov	r1, r4
   13208:	f500 709c 	add.w	r0, r0, #312	; 0x138
	char c = 0;
   1320c:	f88d 400b 	strb.w	r4, [sp, #11]
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
   13210:	f017 f947 	bl	2a4a2 <memset>
	shell_raw_fprintf(shell->fprintf_ctx, cmd_get_terminal_size);
   13214:	4944      	ldr	r1, [pc, #272]	; (13328 <cmd_resize+0x16c>)
   13216:	6968      	ldr	r0, [r5, #20]
   13218:	f016 fbd3 	bl	299c2 <shell_raw_fprintf>
	shell_fprintf_buffer_flush(shell->fprintf_ctx);
   1321c:	6968      	ldr	r0, [r5, #20]
   1321e:	f015 ff8f 	bl	29140 <shell_fprintf_buffer_flush>
   13222:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
			(void)shell->iface->api->read(shell->iface, &c,
   13226:	6868      	ldr	r0, [r5, #4]
   13228:	6803      	ldr	r3, [r0, #0]
   1322a:	2201      	movs	r2, #1
   1322c:	691f      	ldr	r7, [r3, #16]
   1322e:	f10d 010b 	add.w	r1, sp, #11
   13232:	ab03      	add	r3, sp, #12
   13234:	47b8      	blx	r7
			if (cnt == 0) {
   13236:	9b03      	ldr	r3, [sp, #12]
   13238:	b953      	cbnz	r3, 13250 <cmd_resize+0x94>
	z_impl_k_busy_wait(usec_to_wait);
   1323a:	3e01      	subs	r6, #1
   1323c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   13240:	b2b6      	uxth	r6, r6
   13242:	f01a f8f2 	bl	2d42a <z_impl_k_busy_wait>
	for (u16_t i = 0; i < 1000; i++) {
   13246:	2e00      	cmp	r6, #0
   13248:	d1ed      	bne.n	13226 <cmd_resize+0x6a>
		ret_val = -ENOTSUP;
   1324a:	f06f 0422 	mvn.w	r4, #34	; 0x22
   1324e:	e031      	b.n	132b4 <cmd_resize+0xf8>
			if ((c != SHELL_VT100_ASCII_ESC) &&
   13250:	f89d 300b 	ldrb.w	r3, [sp, #11]
   13254:	68aa      	ldr	r2, [r5, #8]
   13256:	2b1b      	cmp	r3, #27
   13258:	d053      	beq.n	13302 <cmd_resize+0x146>
   1325a:	f892 1138 	ldrb.w	r1, [r2, #312]	; 0x138
   1325e:	291b      	cmp	r1, #27
   13260:	d1e1      	bne.n	13226 <cmd_resize+0x6a>
			if (c == 'R') { /* End of response from the terminal. */
   13262:	2b52      	cmp	r3, #82	; 0x52
   13264:	d14d      	bne.n	13302 <cmd_resize+0x146>
				shell->ctx->temp_buff[buff_idx] = '\0';
   13266:	4414      	add	r4, r2
   13268:	2300      	movs	r3, #0
   1326a:	f884 3138 	strb.w	r3, [r4, #312]	; 0x138
				if (shell->ctx->temp_buff[1] != '[') {
   1326e:	f892 1139 	ldrb.w	r1, [r2, #313]	; 0x139
   13272:	295b      	cmp	r1, #91	; 0x5b
   13274:	d14d      	bne.n	13312 <cmd_resize+0x156>
   13276:	f502 709d 	add.w	r0, r2, #314	; 0x13a
	*y = 0U;
   1327a:	461f      	mov	r7, r3
				buff_idx = 2U;
   1327c:	2602      	movs	r6, #2
				while (shell->ctx->temp_buff[buff_idx] != ';') {
   1327e:	f810 1b01 	ldrb.w	r1, [r0], #1
   13282:	3601      	adds	r6, #1
   13284:	293b      	cmp	r1, #59	; 0x3b
   13286:	b2b6      	uxth	r6, r6
   13288:	d126      	bne.n	132d8 <cmd_resize+0x11c>
				if (++buff_idx >= CONFIG_SHELL_CMD_BUFF_SIZE) {
   1328a:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
   1328e:	d0dc      	beq.n	1324a <cmd_resize+0x8e>
   13290:	f506 709c 	add.w	r0, r6, #312	; 0x138
   13294:	4410      	add	r0, r2
	*x = 0U;
   13296:	2300      	movs	r3, #0
				while (shell->ctx->temp_buff[buff_idx]
   13298:	f810 4b01 	ldrb.w	r4, [r0], #1
   1329c:	bb34      	cbnz	r4, 132ec <cmd_resize+0x130>
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
   1329e:	2bfa      	cmp	r3, #250	; 0xfa
   132a0:	bf28      	it	cs
   132a2:	23fa      	movcs	r3, #250	; 0xfa
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
   132a4:	2ffa      	cmp	r7, #250	; 0xfa
		shell->ctx->vt100_ctx.cons.terminal_wid = x;
   132a6:	8553      	strh	r3, [r2, #42]	; 0x2a
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
   132a8:	463b      	mov	r3, r7
   132aa:	bf28      	it	cs
   132ac:	23fa      	movcs	r3, #250	; 0xfa
				shell->ctx->temp_buff[0] = 0;
   132ae:	f882 4138 	strb.w	r4, [r2, #312]	; 0x138
		shell->ctx->vt100_ctx.cons.terminal_hei = y;
   132b2:	8513      	strh	r3, [r2, #40]	; 0x28
	SHELL_VT100_CMD(shell, SHELL_VT100_RESTORECURSOR);
   132b4:	4a1d      	ldr	r2, [pc, #116]	; (1332c <cmd_resize+0x170>)
   132b6:	491b      	ldr	r1, [pc, #108]	; (13324 <cmd_resize+0x168>)
   132b8:	6968      	ldr	r0, [r5, #20]
   132ba:	f016 fb82 	bl	299c2 <shell_raw_fprintf>
	if (err != 0) {
   132be:	2c00      	cmp	r4, #0
   132c0:	d08c      	beq.n	131dc <cmd_resize+0x20>
		shell->ctx->vt100_ctx.cons.terminal_hei =
   132c2:	68ab      	ldr	r3, [r5, #8]
   132c4:	4a1a      	ldr	r2, [pc, #104]	; (13330 <cmd_resize+0x174>)
   132c6:	629a      	str	r2, [r3, #40]	; 0x28
		shell_warn(shell, "No response from the terminal, assumed 80x24"
   132c8:	2104      	movs	r1, #4
   132ca:	4a1a      	ldr	r2, [pc, #104]	; (13334 <cmd_resize+0x178>)
   132cc:	4628      	mov	r0, r5
   132ce:	f015 fef9 	bl	290c4 <shell_fprintf>
   132d2:	f06f 0407 	mvn.w	r4, #7
   132d6:	e781      	b.n	131dc <cmd_resize+0x20>
					*y = *y * 10U +
   132d8:	eb07 0387 	add.w	r3, r7, r7, lsl #2
   132dc:	eb01 0343 	add.w	r3, r1, r3, lsl #1
   132e0:	3b30      	subs	r3, #48	; 0x30
					if (buff_idx >=
   132e2:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
					*y = *y * 10U +
   132e6:	b29f      	uxth	r7, r3
					if (buff_idx >=
   132e8:	d1c9      	bne.n	1327e <cmd_resize+0xc2>
   132ea:	e7ae      	b.n	1324a <cmd_resize+0x8e>
					*x = *x * 10U +
   132ec:	eb03 0383 	add.w	r3, r3, r3, lsl #2
					(shell->ctx->temp_buff[buff_idx++] -
   132f0:	3601      	adds	r6, #1
					*x = *x * 10U +
   132f2:	eb04 0443 	add.w	r4, r4, r3, lsl #1
					(shell->ctx->temp_buff[buff_idx++] -
   132f6:	b2b6      	uxth	r6, r6
					*x = *x * 10U +
   132f8:	3c30      	subs	r4, #48	; 0x30
					if (buff_idx >=
   132fa:	2eff      	cmp	r6, #255	; 0xff
					*x = *x * 10U +
   132fc:	b2a3      	uxth	r3, r4
					if (buff_idx >=
   132fe:	d9cb      	bls.n	13298 <cmd_resize+0xdc>
   13300:	e7a3      	b.n	1324a <cmd_resize+0x8e>
			shell->ctx->temp_buff[buff_idx] = c;
   13302:	1911      	adds	r1, r2, r4
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
   13304:	3401      	adds	r4, #1
   13306:	b2a4      	uxth	r4, r4
   13308:	2c09      	cmp	r4, #9
			shell->ctx->temp_buff[buff_idx] = c;
   1330a:	f881 3138 	strb.w	r3, [r1, #312]	; 0x138
			if (++buff_idx > SHELL_CURSOR_POSITION_BUFFER - 1) {
   1330e:	d98a      	bls.n	13226 <cmd_resize+0x6a>
				shell->ctx->temp_buff[0] = 0;
   13310:	2300      	movs	r3, #0
   13312:	f882 3138 	strb.w	r3, [r2, #312]	; 0x138
				return -ENOMEM;
   13316:	e798      	b.n	1324a <cmd_resize+0x8e>
   13318:	0002fa2c 	.word	0x0002fa2c
   1331c:	0002fa23 	.word	0x0002fa23
   13320:	0002fa0e 	.word	0x0002fa0e
   13324:	000306d9 	.word	0x000306d9
   13328:	0002fa52 	.word	0x0002fa52
   1332c:	0002fa11 	.word	0x0002fa11
   13330:	00500018 	.word	0x00500018
   13334:	0002fc18 	.word	0x0002fc18

00013338 <shell_wildcard_process>:


enum shell_wildcard_status shell_wildcard_process(const struct shell *shell,
					      const struct shell_cmd_entry *cmd,
					      const char *pattern)
{
   13338:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1333c:	4682      	mov	sl, r0
   1333e:	b089      	sub	sp, #36	; 0x24
   13340:	4616      	mov	r6, r2
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_NOT_FOUND;

	if (cmd == NULL) {
   13342:	468b      	mov	fp, r1
   13344:	b921      	cbnz	r1, 13350 <shell_wildcard_process+0x18>
		return ret_val;
   13346:	2403      	movs	r4, #3
	 * and it will try to add matching commands.
	 */
	ret_val = commands_expand(shell, cmd, pattern);

	return ret_val;
}
   13348:	4620      	mov	r0, r4
   1334a:	b009      	add	sp, #36	; 0x24
   1334c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!shell_wildcard_character_exist(pattern)) {
   13350:	4610      	mov	r0, r2
   13352:	f016 fd1c 	bl	29d8e <shell_wildcard_character_exist>
   13356:	2800      	cmp	r0, #0
   13358:	d0f5      	beq.n	13346 <shell_wildcard_process+0xe>
   1335a:	2500      	movs	r5, #0
	size_t cnt = 0;
   1335c:	9501      	str	r5, [sp, #4]
	enum shell_wildcard_status ret_val = SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
   1335e:	2402      	movs	r4, #2
	if (cmd->is_dynamic) {
   13360:	f89b 2000 	ldrb.w	r2, [fp]
   13364:	f8db 3004 	ldr.w	r3, [fp, #4]
   13368:	4268      	negs	r0, r5
   1336a:	b18a      	cbz	r2, 13390 <shell_wildcard_process+0x58>
		cmd->u.dynamic_get(idx, d_entry);
   1336c:	a903      	add	r1, sp, #12
   1336e:	4798      	blx	r3
		*entry = (d_entry->syntax != NULL) ? d_entry : NULL;
   13370:	9b03      	ldr	r3, [sp, #12]
   13372:	2b00      	cmp	r3, #0
   13374:	d15b      	bne.n	1342e <shell_wildcard_process+0xf6>
	if (cnt > 0) {
   13376:	9b01      	ldr	r3, [sp, #4]
   13378:	2b00      	cmp	r3, #0
   1337a:	d0e5      	beq.n	13348 <shell_wildcard_process+0x10>
		shell_pattern_remove(shell->ctx->temp_buff,
   1337c:	f8da 0008 	ldr.w	r0, [sl, #8]
   13380:	4632      	mov	r2, r6
   13382:	f100 0136 	add.w	r1, r0, #54	; 0x36
   13386:	f500 709c 	add.w	r0, r0, #312	; 0x138
   1338a:	f016 f806 	bl	2939a <shell_pattern_remove>
	return ret_val;
   1338e:	e7db      	b.n	13348 <shell_wildcard_process+0x10>
		*entry = (cmd->u.entry[idx].syntax != NULL) ?
   13390:	f06f 0213 	mvn.w	r2, #19
   13394:	436a      	muls	r2, r5
   13396:	eb03 0802 	add.w	r8, r3, r2
				&cmd->u.entry[idx] : NULL;
   1339a:	589b      	ldr	r3, [r3, r2]
   1339c:	2b00      	cmp	r3, #0
   1339e:	d0ea      	beq.n	13376 <shell_wildcard_process+0x3e>
		if (fnmatch(pattern, p_static_entry->syntax, 0) == 0) {
   133a0:	2200      	movs	r2, #0
   133a2:	f8d8 1000 	ldr.w	r1, [r8]
   133a6:	4630      	mov	r0, r6
   133a8:	f015 fa9c 	bl	288e4 <fnmatch>
   133ac:	bb80      	cbnz	r0, 13410 <shell_wildcard_process+0xd8>
			ret_val = command_add(shell->ctx->temp_buff,
   133ae:	f8d8 9000 	ldr.w	r9, [r8]
   133b2:	f8da 7008 	ldr.w	r7, [sl, #8]
	return str == NULL ? 0U : (u16_t)strlen(str);
   133b6:	f1b9 0f00 	cmp.w	r9, #0
   133ba:	d02c      	beq.n	13416 <shell_wildcard_process+0xde>
   133bc:	4648      	mov	r0, r9
   133be:	f016 fffd 	bl	2a3bc <strlen>
   133c2:	b284      	uxth	r4, r0
	if ((*buff_len + cmd_len + 1) > CONFIG_SHELL_CMD_BUFF_SIZE) {
   133c4:	8efb      	ldrh	r3, [r7, #54]	; 0x36
   133c6:	3301      	adds	r3, #1
   133c8:	4423      	add	r3, r4
   133ca:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   133ce:	dc24      	bgt.n	1341a <shell_wildcard_process+0xe2>
	completion_addr = strstr(buff, pattern);
   133d0:	4631      	mov	r1, r6
   133d2:	f507 709c 	add.w	r0, r7, #312	; 0x138
   133d6:	f016 ffa9 	bl	2a32c <strstr>
	if (!completion_addr) {
   133da:	4680      	mov	r8, r0
   133dc:	b328      	cbz	r0, 1342a <shell_wildcard_process+0xf2>
   133de:	f016 ffed 	bl	2a3bc <strlen>
	memmove(completion_addr + cmd_len + 1, completion_addr, shift + 1);
   133e2:	b282      	uxth	r2, r0
   133e4:	1c60      	adds	r0, r4, #1
   133e6:	3201      	adds	r2, #1
   133e8:	4641      	mov	r1, r8
   133ea:	4440      	add	r0, r8
   133ec:	f017 f818 	bl	2a420 <memmove>
	memcpy(completion_addr, cmd, cmd_len);
   133f0:	4622      	mov	r2, r4
   133f2:	4649      	mov	r1, r9
   133f4:	4640      	mov	r0, r8
   133f6:	f017 f82a 	bl	2a44e <memcpy>
	completion_addr[cmd_len] = ' ';
   133fa:	2320      	movs	r3, #32
   133fc:	f808 3004 	strb.w	r3, [r8, r4]
	*buff_len += cmd_len + 1; /* + 1 for space */
   13400:	8efb      	ldrh	r3, [r7, #54]	; 0x36
   13402:	441c      	add	r4, r3
			cnt++;
   13404:	9b01      	ldr	r3, [sp, #4]
	*buff_len += cmd_len + 1; /* + 1 for space */
   13406:	3401      	adds	r4, #1
			cnt++;
   13408:	3301      	adds	r3, #1
	*buff_len += cmd_len + 1; /* + 1 for space */
   1340a:	86fc      	strh	r4, [r7, #54]	; 0x36
			cnt++;
   1340c:	9301      	str	r3, [sp, #4]
			ret_val = command_add(shell->ctx->temp_buff,
   1340e:	2400      	movs	r4, #0
	} while (cmd_idx);
   13410:	3d01      	subs	r5, #1
   13412:	d1a5      	bne.n	13360 <shell_wildcard_process+0x28>
   13414:	e7af      	b.n	13376 <shell_wildcard_process+0x3e>
   13416:	464c      	mov	r4, r9
   13418:	e7d4      	b.n	133c4 <shell_wildcard_process+0x8c>
				shell_internal_fprintf(shell,
   1341a:	4633      	mov	r3, r6
   1341c:	4a05      	ldr	r2, [pc, #20]	; (13434 <shell_wildcard_process+0xfc>)
   1341e:	2104      	movs	r1, #4
   13420:	4650      	mov	r0, sl
   13422:	f016 f9ca 	bl	297ba <shell_internal_fprintf>
			ret_val = command_add(shell->ctx->temp_buff,
   13426:	2401      	movs	r4, #1
   13428:	e7a5      	b.n	13376 <shell_wildcard_process+0x3e>
		return SHELL_WILDCARD_CMD_NO_MATCH_FOUND;
   1342a:	2402      	movs	r4, #2
   1342c:	e7a3      	b.n	13376 <shell_wildcard_process+0x3e>
		*entry = (d_entry->syntax != NULL) ? d_entry : NULL;
   1342e:	f10d 080c 	add.w	r8, sp, #12
   13432:	e7b5      	b.n	133a0 <shell_wildcard_process+0x68>
   13434:	00030030 	.word	0x00030030

00013438 <boot_request_upgrade>:

	return BOOT_SWAP_TYPE_NONE;
}

int boot_request_upgrade(int permanent)
{
   13438:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1343a:	4605      	mov	r5, r0
	rc = flash_area_open(bank_id, &fa);
   1343c:	a901      	add	r1, sp, #4
   1343e:	2002      	movs	r0, #2
   13440:	f000 f962 	bl	13708 <flash_area_open>
	if (rc) {
   13444:	4604      	mov	r4, r0
   13446:	bb10      	cbnz	r0, 1348e <boot_request_upgrade+0x56>
	offs = MAGIC_OFFS(fa);
   13448:	9801      	ldr	r0, [sp, #4]
	rc = flash_area_write(fa, offs, boot_img_magic, BOOT_MAGIC_SZ);
   1344a:	4a13      	ldr	r2, [pc, #76]	; (13498 <boot_request_upgrade+0x60>)
	offs = MAGIC_OFFS(fa);
   1344c:	6881      	ldr	r1, [r0, #8]
	rc = flash_area_write(fa, offs, boot_img_magic, BOOT_MAGIC_SZ);
   1344e:	2310      	movs	r3, #16
   13450:	3910      	subs	r1, #16
   13452:	f016 fdbc 	bl	29fce <flash_area_write>
   13456:	4604      	mov	r4, r0
	flash_area_close(fa);
   13458:	9801      	ldr	r0, [sp, #4]
   1345a:	f016 fd9a 	bl	29f92 <flash_area_close>
	u8_t swap_type;
#endif
	int rc;

	rc = boot_magic_write(FLASH_AREA_IMAGE_SECONDARY);
	if (rc) {
   1345e:	b9b4      	cbnz	r4, 1348e <boot_request_upgrade+0x56>
		goto op_end;
	}

	if (permanent) {
   13460:	b1c5      	cbz	r5, 13494 <boot_request_upgrade+0x5c>
	return boot_flag_write(BOOT_FLAG_IMAGE_OK, bank_id);
   13462:	2002      	movs	r0, #2
   13464:	f016 fd04 	bl	29e70 <boot_flag_write.constprop.6>
		rc = boot_image_ok_write(FLASH_AREA_IMAGE_SECONDARY);

#ifdef CONFIG_MCUBOOT_TRAILER_SWAP_TYPE
		if (rc) {
   13468:	4604      	mov	r4, r0
   1346a:	b980      	cbnz	r0, 1348e <boot_request_upgrade+0x56>
			goto op_end;
		}

		swap_type = BOOT_SWAP_TYPE_PERM;
   1346c:	2503      	movs	r5, #3
	rc = flash_area_open(bank_id, &fa);
   1346e:	a901      	add	r1, sp, #4
   13470:	2002      	movs	r0, #2
   13472:	f000 f949 	bl	13708 <flash_area_open>
	if (rc) {
   13476:	4604      	mov	r4, r0
   13478:	b948      	cbnz	r0, 1348e <boot_request_upgrade+0x56>
	offs = SWAP_TYPE_OFFS(fa);
   1347a:	9801      	ldr	r0, [sp, #4]
   1347c:	6881      	ldr	r1, [r0, #8]
	rc = boot_write_trailer_byte(fa, offs, swap_type);
   1347e:	462a      	mov	r2, r5
   13480:	3928      	subs	r1, #40	; 0x28
   13482:	f016 fcc7 	bl	29e14 <boot_write_trailer_byte>
   13486:	4604      	mov	r4, r0
	flash_area_close(fa);
   13488:	9801      	ldr	r0, [sp, #4]
   1348a:	f016 fd82 	bl	29f92 <flash_area_close>
#else
	}
#endif
op_end:
	return rc;
}
   1348e:	4620      	mov	r0, r4
   13490:	b003      	add	sp, #12
   13492:	bd30      	pop	{r4, r5, pc}
		swap_type = BOOT_SWAP_TYPE_TEST;
   13494:	2502      	movs	r5, #2
   13496:	e7ea      	b.n	1346e <boot_request_upgrade+0x36>
   13498:	0002e394 	.word	0x0002e394

0001349c <flash_progressive_erase>:
 * @param[in] off offset from the beginning of the image flash area beginning
 *
 * @return  0 on success, negative errno code on fail.
 */
static int flash_progressive_erase(struct flash_img_context *ctx, off_t off)
{
   1349c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1349e:	4606      	mov	r6, r0
   134a0:	b085      	sub	sp, #20
	flash_dev = flash_area_get_device(fap);
   134a2:	f8d0 0200 	ldr.w	r0, [r0, #512]	; 0x200
{
   134a6:	460c      	mov	r4, r1
	flash_dev = flash_area_get_device(fap);
   134a8:	f016 fde7 	bl	2a07a <flash_area_get_device>
	if (flash_dev) {
   134ac:	b9a0      	cbnz	r0, 134d8 <flash_progressive_erase+0x3c>
	int rc = -ENODEV;
   134ae:	f06f 0412 	mvn.w	r4, #18
	struct flash_sector sector;
	int rc;

	rc = flash_sector_from_off(ctx->flash_area, off, &sector);
	if (rc) {
		LOG_ERR("Unable to determine flash sector size");
   134b2:	4b2b      	ldr	r3, [pc, #172]	; (13560 <flash_progressive_erase+0xc4>)
   134b4:	681b      	ldr	r3, [r3, #0]
   134b6:	075a      	lsls	r2, r3, #29
   134b8:	d01a      	beq.n	134f0 <flash_progressive_erase+0x54>
   134ba:	2301      	movs	r3, #1
   134bc:	f04f 0100 	mov.w	r1, #0
   134c0:	f363 0107 	bfi	r1, r3, #0, #8
   134c4:	4a27      	ldr	r2, [pc, #156]	; (13564 <flash_progressive_erase+0xc8>)
   134c6:	4b28      	ldr	r3, [pc, #160]	; (13568 <flash_progressive_erase+0xcc>)
   134c8:	4828      	ldr	r0, [pc, #160]	; (1356c <flash_progressive_erase+0xd0>)
   134ca:	1a9b      	subs	r3, r3, r2
   134cc:	08db      	lsrs	r3, r3, #3
   134ce:	f363 118f 	bfi	r1, r3, #6, #10
   134d2:	f015 fa32 	bl	2893a <log_0>
   134d6:	e00b      	b.n	134f0 <flash_progressive_erase+0x54>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&dev, *(uintptr_t *)&offset, *(uintptr_t *)&info, K_SYSCALL_FLASH_GET_PAGE_INFO_BY_OFFS);
	}
#endif
	compiler_barrier();
	return z_impl_flash_get_page_info_by_offs(dev, offset, info);
   134d8:	aa01      	add	r2, sp, #4
   134da:	4621      	mov	r1, r4
   134dc:	f019 fd21 	bl	2cf22 <z_impl_flash_get_page_info_by_offs>
		if (rc == 0) {
   134e0:	b948      	cbnz	r0, 134f6 <flash_progressive_erase+0x5a>
			sector->fs_size = page.size;
   134e2:	e9dd 4701 	ldrd	r4, r7, [sp, #4]
	} else {
		if (ctx->off_last != sector.fs_off) {
   134e6:	f8d6 320c 	ldr.w	r3, [r6, #524]	; 0x20c
   134ea:	42a3      	cmp	r3, r4
   134ec:	d105      	bne.n	134fa <flash_progressive_erase+0x5e>
	rc = flash_sector_from_off(ctx->flash_area, off, &sector);
   134ee:	2400      	movs	r4, #0
			}
		}
	}

	return rc;
}
   134f0:	4620      	mov	r0, r4
   134f2:	b005      	add	sp, #20
   134f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (rc) {
   134f6:	4604      	mov	r4, r0
   134f8:	e7db      	b.n	134b2 <flash_progressive_erase+0x16>
			LOG_INF("Erasing sector at offset 0x%08lx",
   134fa:	4d19      	ldr	r5, [pc, #100]	; (13560 <flash_progressive_erase+0xc4>)
			ctx->off_last = sector.fs_off;
   134fc:	f8c6 420c 	str.w	r4, [r6, #524]	; 0x20c
			LOG_INF("Erasing sector at offset 0x%08lx",
   13500:	682b      	ldr	r3, [r5, #0]
   13502:	f003 0307 	and.w	r3, r3, #7
   13506:	2b02      	cmp	r3, #2
   13508:	d90e      	bls.n	13528 <flash_progressive_erase+0x8c>
   1350a:	2303      	movs	r3, #3
   1350c:	f04f 0200 	mov.w	r2, #0
   13510:	f363 0207 	bfi	r2, r3, #0, #8
   13514:	4913      	ldr	r1, [pc, #76]	; (13564 <flash_progressive_erase+0xc8>)
   13516:	4b14      	ldr	r3, [pc, #80]	; (13568 <flash_progressive_erase+0xcc>)
   13518:	4815      	ldr	r0, [pc, #84]	; (13570 <flash_progressive_erase+0xd4>)
   1351a:	1a5b      	subs	r3, r3, r1
   1351c:	08db      	lsrs	r3, r3, #3
   1351e:	f363 128f 	bfi	r2, r3, #6, #10
   13522:	4621      	mov	r1, r4
   13524:	f015 fa16 	bl	28954 <log_1>
			rc = flash_area_erase(ctx->flash_area, sector.fs_off,
   13528:	4621      	mov	r1, r4
   1352a:	463a      	mov	r2, r7
   1352c:	f8d6 0200 	ldr.w	r0, [r6, #512]	; 0x200
   13530:	f016 fd76 	bl	2a020 <flash_area_erase>
			if (rc) {
   13534:	4604      	mov	r4, r0
   13536:	2800      	cmp	r0, #0
   13538:	d0d9      	beq.n	134ee <flash_progressive_erase+0x52>
				LOG_ERR("Error %d while erasing sector", rc);
   1353a:	682b      	ldr	r3, [r5, #0]
   1353c:	075b      	lsls	r3, r3, #29
   1353e:	d0d7      	beq.n	134f0 <flash_progressive_erase+0x54>
   13540:	2301      	movs	r3, #1
   13542:	f04f 0200 	mov.w	r2, #0
   13546:	f363 0207 	bfi	r2, r3, #0, #8
   1354a:	4906      	ldr	r1, [pc, #24]	; (13564 <flash_progressive_erase+0xc8>)
   1354c:	4b06      	ldr	r3, [pc, #24]	; (13568 <flash_progressive_erase+0xcc>)
   1354e:	1a5b      	subs	r3, r3, r1
   13550:	08db      	lsrs	r3, r3, #3
   13552:	4601      	mov	r1, r0
   13554:	f363 128f 	bfi	r2, r3, #6, #10
   13558:	4806      	ldr	r0, [pc, #24]	; (13574 <flash_progressive_erase+0xd8>)
   1355a:	f015 f9fb 	bl	28954 <log_1>
	return rc;
   1355e:	e7c7      	b.n	134f0 <flash_progressive_erase+0x54>
   13560:	2001001c 	.word	0x2001001c
   13564:	0002db28 	.word	0x0002db28
   13568:	0002dc30 	.word	0x0002dc30
   1356c:	00030082 	.word	0x00030082
   13570:	000300a8 	.word	0x000300a8
   13574:	000300c9 	.word	0x000300c9

00013578 <flash_sync>:

#endif /* CONFIG_IMG_ERASE_PROGRESSIVELY */

static int flash_sync(struct flash_img_context *ctx)
{
   13578:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   1357c:	4604      	mov	r4, r0
	int rc = 0;

	if (ctx->buf_bytes < CONFIG_IMG_BLOCK_BUF_SIZE) {
   1357e:	f8b0 0208 	ldrh.w	r0, [r0, #520]	; 0x208
   13582:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
   13586:	d205      	bcs.n	13594 <flash_sync+0x1c>
		(void)memset(ctx->buf + ctx->buf_bytes, 0xFF,
   13588:	f5c0 7200 	rsb	r2, r0, #512	; 0x200
   1358c:	21ff      	movs	r1, #255	; 0xff
   1358e:	4420      	add	r0, r4
   13590:	f016 ff87 	bl	2a4a2 <memset>
			     CONFIG_IMG_BLOCK_BUF_SIZE - ctx->buf_bytes);
	}

#ifdef CONFIG_IMG_ERASE_PROGRESSIVELY
	rc = flash_progressive_erase(ctx, ctx->bytes_written +
   13594:	f8d4 1204 	ldr.w	r1, [r4, #516]	; 0x204
   13598:	4620      	mov	r0, r4
   1359a:	f501 7100 	add.w	r1, r1, #512	; 0x200
   1359e:	f7ff ff7d 	bl	1349c <flash_progressive_erase>
				     CONFIG_IMG_BLOCK_BUF_SIZE);
	if (rc) {
   135a2:	4605      	mov	r5, r0
   135a4:	b1c0      	cbz	r0, 135d8 <flash_sync+0x60>
		LOG_ERR("flash_progressive_erase error %d offset=0x%08zx", rc,
   135a6:	4b46      	ldr	r3, [pc, #280]	; (136c0 <flash_sync+0x148>)
   135a8:	681b      	ldr	r3, [r3, #0]
   135aa:	0758      	lsls	r0, r3, #29
   135ac:	d010      	beq.n	135d0 <flash_sync+0x58>
   135ae:	2201      	movs	r2, #1
   135b0:	f04f 0300 	mov.w	r3, #0
   135b4:	f362 0307 	bfi	r3, r2, #0, #8
   135b8:	4942      	ldr	r1, [pc, #264]	; (136c4 <flash_sync+0x14c>)
   135ba:	4a43      	ldr	r2, [pc, #268]	; (136c8 <flash_sync+0x150>)
   135bc:	4843      	ldr	r0, [pc, #268]	; (136cc <flash_sync+0x154>)
   135be:	1a52      	subs	r2, r2, r1
   135c0:	08d2      	lsrs	r2, r2, #3
   135c2:	f362 138f 	bfi	r3, r2, #6, #10
   135c6:	f8d4 2204 	ldr.w	r2, [r4, #516]	; 0x204
   135ca:	4629      	mov	r1, r5
#endif

	rc = flash_area_write(ctx->flash_area, ctx->bytes_written, ctx->buf,
			      CONFIG_IMG_BLOCK_BUF_SIZE);
	if (rc) {
		LOG_ERR("flash_write error %d offset=0x%08zx", rc,
   135cc:	f015 f9d6 	bl	2897c <log_2>

	ctx->bytes_written += ctx->buf_bytes;
	ctx->buf_bytes = 0U;

	return rc;
}
   135d0:	4628      	mov	r0, r5
   135d2:	b004      	add	sp, #16
   135d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	rc = flash_area_write(ctx->flash_area, ctx->bytes_written, ctx->buf,
   135d8:	f44f 7300 	mov.w	r3, #512	; 0x200
   135dc:	4622      	mov	r2, r4
   135de:	e9d4 0180 	ldrd	r0, r1, [r4, #512]	; 0x200
   135e2:	f016 fcf4 	bl	29fce <flash_area_write>
   135e6:	46a1      	mov	r9, r4
	if (rc) {
   135e8:	4605      	mov	r5, r0
   135ea:	b198      	cbz	r0, 13614 <flash_sync+0x9c>
		LOG_ERR("flash_write error %d offset=0x%08zx", rc,
   135ec:	4b34      	ldr	r3, [pc, #208]	; (136c0 <flash_sync+0x148>)
   135ee:	681b      	ldr	r3, [r3, #0]
   135f0:	0759      	lsls	r1, r3, #29
   135f2:	d0ed      	beq.n	135d0 <flash_sync+0x58>
   135f4:	2201      	movs	r2, #1
   135f6:	f04f 0300 	mov.w	r3, #0
   135fa:	f362 0307 	bfi	r3, r2, #0, #8
   135fe:	4931      	ldr	r1, [pc, #196]	; (136c4 <flash_sync+0x14c>)
   13600:	4a31      	ldr	r2, [pc, #196]	; (136c8 <flash_sync+0x150>)
   13602:	1a52      	subs	r2, r2, r1
   13604:	08d2      	lsrs	r2, r2, #3
   13606:	f362 138f 	bfi	r3, r2, #6, #10
   1360a:	4601      	mov	r1, r0
   1360c:	f8d4 2204 	ldr.w	r2, [r4, #516]	; 0x204
   13610:	482f      	ldr	r0, [pc, #188]	; (136d0 <flash_sync+0x158>)
   13612:	e7db      	b.n	135cc <flash_sync+0x54>
	if (!flash_verify(ctx->flash_area, ctx->bytes_written, ctx->buf,
   13614:	e9d4 a880 	ldrd	sl, r8, [r4, #512]	; 0x200
   13618:	f44f 7700 	mov.w	r7, #512	; 0x200
		size = (len >= sizeof(temp)) ? sizeof(temp) : len;
   1361c:	2f04      	cmp	r7, #4
   1361e:	463e      	mov	r6, r7
   13620:	bf28      	it	cs
   13622:	2604      	movcs	r6, #4
		rc = flash_area_read(fa, offset, &temp, size);
   13624:	4641      	mov	r1, r8
   13626:	4633      	mov	r3, r6
   13628:	aa03      	add	r2, sp, #12
   1362a:	4650      	mov	r0, sl
   1362c:	f016 fcb2 	bl	29f94 <flash_area_read>
		if (rc) {
   13630:	4601      	mov	r1, r0
   13632:	b1b0      	cbz	r0, 13662 <flash_sync+0xea>
			LOG_ERR("flash_read error %d offset=0x%08lx",
   13634:	4b22      	ldr	r3, [pc, #136]	; (136c0 <flash_sync+0x148>)
   13636:	681b      	ldr	r3, [r3, #0]
   13638:	075a      	lsls	r2, r3, #29
   1363a:	d00e      	beq.n	1365a <flash_sync+0xe2>
   1363c:	2201      	movs	r2, #1
   1363e:	f04f 0300 	mov.w	r3, #0
   13642:	f362 0307 	bfi	r3, r2, #0, #8
   13646:	481f      	ldr	r0, [pc, #124]	; (136c4 <flash_sync+0x14c>)
   13648:	4a1f      	ldr	r2, [pc, #124]	; (136c8 <flash_sync+0x150>)
   1364a:	1a12      	subs	r2, r2, r0
   1364c:	08d2      	lsrs	r2, r2, #3
   1364e:	f362 138f 	bfi	r3, r2, #6, #10
   13652:	4820      	ldr	r0, [pc, #128]	; (136d4 <flash_sync+0x15c>)
   13654:	4642      	mov	r2, r8
   13656:	f015 f991 	bl	2897c <log_2>
	if (!flash_verify(ctx->flash_area, ctx->bytes_written, ctx->buf,
   1365a:	b32f      	cbz	r7, 136a8 <flash_sync+0x130>
		return -EIO;
   1365c:	f06f 0504 	mvn.w	r5, #4
   13660:	e7b6      	b.n	135d0 <flash_sync+0x58>
		if (memcmp(data, &temp, size)) {
   13662:	4632      	mov	r2, r6
   13664:	a903      	add	r1, sp, #12
   13666:	4648      	mov	r0, r9
   13668:	f016 feca 	bl	2a400 <memcmp>
   1366c:	b1c0      	cbz	r0, 136a0 <flash_sync+0x128>
			LOG_ERR("offset=0x%08lx VERIFY FAIL. "
   1366e:	4b14      	ldr	r3, [pc, #80]	; (136c0 <flash_sync+0x148>)
   13670:	681b      	ldr	r3, [r3, #0]
   13672:	075b      	lsls	r3, r3, #29
   13674:	d0f1      	beq.n	1365a <flash_sync+0xe2>
   13676:	2301      	movs	r3, #1
   13678:	f04f 0200 	mov.w	r2, #0
   1367c:	f363 0207 	bfi	r2, r3, #0, #8
   13680:	4910      	ldr	r1, [pc, #64]	; (136c4 <flash_sync+0x14c>)
   13682:	4b11      	ldr	r3, [pc, #68]	; (136c8 <flash_sync+0x150>)
   13684:	4814      	ldr	r0, [pc, #80]	; (136d8 <flash_sync+0x160>)
   13686:	1a5b      	subs	r3, r3, r1
   13688:	08db      	lsrs	r3, r3, #3
   1368a:	f363 128f 	bfi	r2, r3, #6, #10
   1368e:	f8ad 2000 	strh.w	r2, [sp]
   13692:	f899 3000 	ldrb.w	r3, [r9]
   13696:	9a03      	ldr	r2, [sp, #12]
   13698:	4641      	mov	r1, r8
   1369a:	f015 f987 	bl	289ac <log_3>
   1369e:	e7dc      	b.n	1365a <flash_sync+0xe2>
	while (len) {
   136a0:	1bbf      	subs	r7, r7, r6
		offset += size;
   136a2:	44b0      	add	r8, r6
		data += size;
   136a4:	44b1      	add	r9, r6
	while (len) {
   136a6:	d1b9      	bne.n	1361c <flash_sync+0xa4>
	ctx->bytes_written += ctx->buf_bytes;
   136a8:	f8b4 2208 	ldrh.w	r2, [r4, #520]	; 0x208
   136ac:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
   136b0:	4413      	add	r3, r2
   136b2:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
	ctx->buf_bytes = 0U;
   136b6:	2300      	movs	r3, #0
   136b8:	f8a4 3208 	strh.w	r3, [r4, #520]	; 0x208
	return rc;
   136bc:	e788      	b.n	135d0 <flash_sync+0x58>
   136be:	bf00      	nop
   136c0:	2001001c 	.word	0x2001001c
   136c4:	0002db28 	.word	0x0002db28
   136c8:	0002dc30 	.word	0x0002dc30
   136cc:	000300e7 	.word	0x000300e7
   136d0:	00030117 	.word	0x00030117
   136d4:	0003013b 	.word	0x0003013b
   136d8:	0003015e 	.word	0x0003015e

000136dc <get_flash_area_from_id>:
extern const struct flash_area *flash_map;
extern const int flash_map_entries;

static struct flash_area const *get_flash_area_from_id(int idx)
{
	for (int i = 0; i < flash_map_entries; i++) {
   136dc:	4b08      	ldr	r3, [pc, #32]	; (13700 <get_flash_area_from_id+0x24>)
{
   136de:	b530      	push	{r4, r5, lr}
	for (int i = 0; i < flash_map_entries; i++) {
   136e0:	681d      	ldr	r5, [r3, #0]
		if (flash_map[i].fa_id == idx) {
   136e2:	4b08      	ldr	r3, [pc, #32]	; (13704 <get_flash_area_from_id+0x28>)
   136e4:	6819      	ldr	r1, [r3, #0]
	for (int i = 0; i < flash_map_entries; i++) {
   136e6:	2300      	movs	r3, #0
   136e8:	429d      	cmp	r5, r3
   136ea:	dc02      	bgt.n	136f2 <get_flash_area_from_id+0x16>
			return &flash_map[i];
		}
	}

	return NULL;
   136ec:	2200      	movs	r2, #0
}
   136ee:	4610      	mov	r0, r2
   136f0:	bd30      	pop	{r4, r5, pc}
		if (flash_map[i].fa_id == idx) {
   136f2:	011c      	lsls	r4, r3, #4
   136f4:	190a      	adds	r2, r1, r4
   136f6:	5d0c      	ldrb	r4, [r1, r4]
   136f8:	4284      	cmp	r4, r0
   136fa:	d0f8      	beq.n	136ee <get_flash_area_from_id+0x12>
	for (int i = 0; i < flash_map_entries; i++) {
   136fc:	3301      	adds	r3, #1
   136fe:	e7f3      	b.n	136e8 <get_flash_area_from_id+0xc>
   13700:	0002e3f4 	.word	0x0002e3f4
   13704:	2000f948 	.word	0x2000f948

00013708 <flash_area_open>:

int flash_area_open(u8_t id, const struct flash_area **fap)
{
	const struct flash_area *area;

	if (flash_map == NULL) {
   13708:	4b08      	ldr	r3, [pc, #32]	; (1372c <flash_area_open+0x24>)
   1370a:	681b      	ldr	r3, [r3, #0]
{
   1370c:	b510      	push	{r4, lr}
   1370e:	460c      	mov	r4, r1
	if (flash_map == NULL) {
   13710:	b12b      	cbz	r3, 1371e <flash_area_open+0x16>
		return -EACCES;
	}

	area = get_flash_area_from_id(id);
   13712:	f7ff ffe3 	bl	136dc <get_flash_area_from_id>
	if (area == NULL) {
   13716:	b128      	cbz	r0, 13724 <flash_area_open+0x1c>
		return -ENOENT;
	}

	*fap = area;
   13718:	6020      	str	r0, [r4, #0]
	return 0;
   1371a:	2000      	movs	r0, #0
}
   1371c:	bd10      	pop	{r4, pc}
		return -EACCES;
   1371e:	f06f 000c 	mvn.w	r0, #12
   13722:	e7fb      	b.n	1371c <flash_area_open+0x14>
		return -ENOENT;
   13724:	f06f 0001 	mvn.w	r0, #1
   13728:	e7f8      	b.n	1371c <flash_area_open+0x14>
   1372a:	bf00      	nop
   1372c:	2000f948 	.word	0x2000f948

00013730 <sys_reboot>:

extern void sys_arch_reboot(int type);
extern void sys_clock_disable(void);

void sys_reboot(int type)
{
   13730:	b508      	push	{r3, lr}
   13732:	4604      	mov	r4, r0
	__asm__ volatile(
   13734:	f04f 0220 	mov.w	r2, #32
   13738:	f3ef 8311 	mrs	r3, BASEPRI
   1373c:	f382 8811 	msr	BASEPRI, r2
   13740:	f3bf 8f6f 	isb	sy
	(void)irq_lock();
#ifdef CONFIG_SYS_CLOCK_EXISTS
	sys_clock_disable();
   13744:	f016 fd63 	bl	2a20e <sys_clock_disable>
#endif

	sys_arch_reboot(type);
   13748:	4620      	mov	r0, r4
   1374a:	f001 fc79 	bl	15040 <sys_arch_reboot>

	/* should never get here */
	printk("Failed to reboot: spinning endlessly...\n");
   1374e:	4803      	ldr	r0, [pc, #12]	; (1375c <sys_reboot+0x2c>)
   13750:	f014 fcf8 	bl	28144 <printk>
 * @return N/A
 * @req K-CPU-IDLE-001
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
   13754:	f000 fa52 	bl	13bfc <arch_cpu_idle>
   13758:	e7fc      	b.n	13754 <sys_reboot+0x24>
   1375a:	bf00      	nop
   1375c:	000301c5 	.word	0x000301c5

00013760 <console_out>:
		return c;
	}

#endif  /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
   13760:	280a      	cmp	r0, #10
{
   13762:	b538      	push	{r3, r4, r5, lr}
   13764:	4604      	mov	r4, r0
   13766:	4d07      	ldr	r5, [pc, #28]	; (13784 <console_out+0x24>)
	if ('\n' == c) {
   13768:	d104      	bne.n	13774 <console_out+0x14>
   1376a:	6828      	ldr	r0, [r5, #0]
	api->poll_out(dev, out_char);
   1376c:	6843      	ldr	r3, [r0, #4]
   1376e:	210d      	movs	r1, #13
   13770:	685b      	ldr	r3, [r3, #4]
   13772:	4798      	blx	r3
		uart_poll_out(uart_console_dev, '\r');
	}
	uart_poll_out(uart_console_dev, c);
   13774:	6828      	ldr	r0, [r5, #0]
   13776:	6843      	ldr	r3, [r0, #4]
   13778:	b2e1      	uxtb	r1, r4
   1377a:	685b      	ldr	r3, [r3, #4]
   1377c:	4798      	blx	r3

	return c;
}
   1377e:	4620      	mov	r0, r4
   13780:	bd38      	pop	{r3, r4, r5, pc}
   13782:	bf00      	nop
   13784:	200009dc 	.word	0x200009dc

00013788 <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
   13788:	b510      	push	{r4, lr}
	__stdout_hook_install(console_out);
   1378a:	4c04      	ldr	r4, [pc, #16]	; (1379c <uart_console_hook_install+0x14>)
   1378c:	4620      	mov	r0, r4
   1378e:	f001 fc21 	bl	14fd4 <__stdout_hook_install>
	__printk_hook_install(console_out);
   13792:	4620      	mov	r0, r4
}
   13794:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__printk_hook_install(console_out);
   13798:	f7fd ba50 	b.w	10c3c <__printk_hook_install>
   1379c:	00013761 	.word	0x00013761

000137a0 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
   137a0:	b508      	push	{r3, lr}
   137a2:	4804      	ldr	r0, [pc, #16]	; (137b4 <uart_console_init+0x14>)
   137a4:	f012 fdae 	bl	26304 <z_impl_device_get_binding>

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
   137a8:	4b03      	ldr	r3, [pc, #12]	; (137b8 <uart_console_init+0x18>)
   137aa:	6018      	str	r0, [r3, #0]
		}
	}
	k_busy_wait(1000000);
#endif

	uart_console_hook_install();
   137ac:	f7ff ffec 	bl	13788 <uart_console_hook_install>

	return 0;
}
   137b0:	2000      	movs	r0, #0
   137b2:	bd08      	pop	{r3, pc}
   137b4:	0002f9a6 	.word	0x0002f9a6
   137b8:	200009dc 	.word	0x200009dc

000137bc <nrf_power_clock_isr>:
#endif
}

NRF_STATIC_INLINE bool nrf_clock_event_check(NRF_CLOCK_Type const * p_reg, nrf_clock_event_t event)
{
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   137bc:	4b15      	ldr	r3, [pc, #84]	; (13814 <nrf_power_clock_isr+0x58>)
	}
#endif
}

void nrf_power_clock_isr(void *arg)
{
   137be:	b507      	push	{r0, r1, r2, lr}
   137c0:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
   137c2:	b182      	cbz	r2, 137e6 <nrf_power_clock_isr+0x2a>
    return p_reg->INTENSET & mask;
   137c4:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   137c8:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
   137cc:	07d1      	lsls	r1, r2, #31
   137ce:	d50a      	bpl.n	137e6 <nrf_power_clock_isr+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   137d0:	2200      	movs	r2, #0
   137d2:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   137d4:	681b      	ldr	r3, [r3, #0]
	ARG_UNUSED(arg);

	if (clock_event_check_and_clean(NRF_CLOCK_EVENT_HFCLKSTARTED,
					NRF_CLOCK_INT_HF_STARTED_MASK)) {
		struct device *hfclk_dev = DEVICE_GET(clock_nrf5_m16src);
		struct nrf_clock_control *data = hfclk_dev->driver_data;
   137d6:	4810      	ldr	r0, [pc, #64]	; (13818 <nrf_power_clock_isr+0x5c>)
   137d8:	9300      	str	r3, [sp, #0]
    (void)dummy;
   137da:	9b00      	ldr	r3, [sp, #0]

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (!data->started) {
   137dc:	6883      	ldr	r3, [r0, #8]
   137de:	7a5b      	ldrb	r3, [r3, #9]
   137e0:	b90b      	cbnz	r3, 137e6 <nrf_power_clock_isr+0x2a>
			clkstarted_handle(hfclk_dev);
   137e2:	f016 fcf5 	bl	2a1d0 <clkstarted_handle>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   137e6:	4b0d      	ldr	r3, [pc, #52]	; (1381c <nrf_power_clock_isr+0x60>)
   137e8:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
   137ea:	b182      	cbz	r2, 1380e <nrf_power_clock_isr+0x52>
    return p_reg->INTENSET & mask;
   137ec:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
   137f0:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
   137f4:	0792      	lsls	r2, r2, #30
   137f6:	d50a      	bpl.n	1380e <nrf_power_clock_isr+0x52>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   137f8:	2200      	movs	r2, #0
   137fa:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   137fc:	681b      	ldr	r3, [r3, #0]
   137fe:	9301      	str	r3, [sp, #4]
    (void)dummy;
   13800:	9b01      	ldr	r3, [sp, #4]

		if (IS_ENABLED(
			CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
			z_nrf_clock_calibration_lfclk_started(lfclk_dev);
		}
		clkstarted_handle(lfclk_dev);
   13802:	4807      	ldr	r0, [pc, #28]	; (13820 <nrf_power_clock_isr+0x64>)
	usb_power_isr();

	if (IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
		z_nrf_clock_calibration_isr();
	}
}
   13804:	b003      	add	sp, #12
   13806:	f85d eb04 	ldr.w	lr, [sp], #4
		clkstarted_handle(lfclk_dev);
   1380a:	f016 bce1 	b.w	2a1d0 <clkstarted_handle>
}
   1380e:	b003      	add	sp, #12
   13810:	f85d fb04 	ldr.w	pc, [sp], #4
   13814:	40000100 	.word	0x40000100
   13818:	2000fefc 	.word	0x2000fefc
   1381c:	40000104 	.word	0x40000104
   13820:	2000ff08 	.word	0x2000ff08

00013824 <rtc1_nrf_isr>:
 * symbol.
 */
void rtc1_nrf_isr(void *arg)
{
	ARG_UNUSED(arg);
	RTC->EVENTS_COMPARE[0] = 0;
   13824:	4b0d      	ldr	r3, [pc, #52]	; (1385c <rtc1_nrf_isr+0x38>)
   13826:	2200      	movs	r2, #0
   13828:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
   1382c:	f04f 0220 	mov.w	r2, #32
   13830:	f3ef 8111 	mrs	r1, BASEPRI
   13834:	f382 8811 	msr	BASEPRI, r2
   13838:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t t = counter();
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
   1383c:	4a08      	ldr	r2, [pc, #32]	; (13860 <rtc1_nrf_isr+0x3c>)
#endif
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
   1383e:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
   13842:	6813      	ldr	r3, [r2, #0]
	return (a - b) & COUNTER_MAX;
   13844:	1ac0      	subs	r0, r0, r3
   13846:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
   1384a:	4403      	add	r3, r0
   1384c:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
   1384e:	f381 8811 	msr	BASEPRI, r1
   13852:	f3bf 8f6f 	isb	sy
		}
		set_comparator(next);
	}

	k_spin_unlock(&lock, key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
   13856:	f013 bedb 	b.w	27610 <z_clock_announce>
   1385a:	bf00      	nop
   1385c:	40011000 	.word	0x40011000
   13860:	200009f8 	.word	0x200009f8

00013864 <z_clock_driver_init>:
}

int z_clock_driver_init(struct device *device)
{
   13864:	b573      	push	{r0, r1, r4, r5, r6, lr}
   13866:	481c      	ldr	r0, [pc, #112]	; (138d8 <z_clock_driver_init+0x74>)
   13868:	f012 fd4c 	bl	26304 <z_impl_device_get_binding>
	struct device *clock;

	ARG_UNUSED(device);

	clock = device_get_binding(DT_INST_0_NORDIC_NRF_CLOCK_LABEL "_32K");
	if (!clock) {
   1386c:	b380      	cbz	r0, 138d0 <z_clock_driver_init+0x6c>
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
   1386e:	6843      	ldr	r3, [r0, #4]
}

NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
   13870:	4d1a      	ldr	r5, [pc, #104]	; (138dc <z_clock_driver_init+0x78>)
   13872:	681b      	ldr	r3, [r3, #0]
   13874:	2100      	movs	r1, #0
   13876:	4798      	blx	r3
    p_reg->CC[ch] = cc_val;
   13878:	2601      	movs	r6, #1
    p_reg->PRESCALER = val;
   1387a:	2400      	movs	r4, #0
    p_reg->INTENSET = mask;
   1387c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->PRESCALER = val;
   13880:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    p_reg->CC[ch] = cc_val;
   13884:	f8c5 6540 	str.w	r6, [r5, #1344]	; 0x540
    p_reg->INTENSET = mask;
   13888:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   1388c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   13890:	f503 538a 	add.w	r3, r3, #4416	; 0x1140
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   13894:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   13898:	601c      	str	r4, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   1389a:	681b      	ldr	r3, [r3, #0]
   1389c:	9301      	str	r3, [sp, #4]
    (void)dummy;
   1389e:	9b01      	ldr	r3, [sp, #4]
   138a0:	4b0f      	ldr	r3, [pc, #60]	; (138e0 <z_clock_driver_init+0x7c>)

	/* Clear the event flag and possible pending interrupt */
	nrf_rtc_event_clear(RTC, NRF_RTC_EVENT_COMPARE_0);
	NVIC_ClearPendingIRQ(RTC1_IRQn);

	IRQ_CONNECT(RTC1_IRQn, 1, rtc1_nrf_isr, 0, 0);
   138a2:	4631      	mov	r1, r6
   138a4:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
   138a8:	2011      	movs	r0, #17
   138aa:	4622      	mov	r2, r4
   138ac:	f000 f93a 	bl	13b24 <z_arm_irq_priority_set>
	irq_enable(RTC1_IRQn);
   138b0:	2011      	movs	r0, #17
   138b2:	f000 f905 	bl	13ac0 <arch_irq_enable>
    return (uint32_t)p_reg + task;
}

NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   138b6:	4b0b      	ldr	r3, [pc, #44]	; (138e4 <z_clock_driver_init+0x80>)
   138b8:	601e      	str	r6, [r3, #0]
   138ba:	602e      	str	r6, [r5, #0]
     return p_reg->COUNTER;
   138bc:	f8d5 3504 	ldr.w	r3, [r5, #1284]	; 0x504

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	if (!IS_ENABLED(TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
   138c0:	4433      	add	r3, r6
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
   138c2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
   138c6:	f8c5 3540 	str.w	r3, [r5, #1344]	; 0x540
	}

	return 0;
   138ca:	4620      	mov	r0, r4
}
   138cc:	b002      	add	sp, #8
   138ce:	bd70      	pop	{r4, r5, r6, pc}
		return -1;
   138d0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   138d4:	e7fa      	b.n	138cc <z_clock_driver_init+0x68>
   138d6:	bf00      	nop
   138d8:	000301ee 	.word	0x000301ee
   138dc:	40011000 	.word	0x40011000
   138e0:	e000e100 	.word	0xe000e100
   138e4:	40011008 	.word	0x40011008

000138e8 <z_clock_set_timeout>:

void z_clock_set_timeout(s32_t ticks, bool idle)
{
   138e8:	b5f0      	push	{r4, r5, r6, r7, lr}
	ARG_UNUSED(idle);

#ifdef CONFIG_TICKLESS_KERNEL
	ticks = (ticks == K_FOREVER) ? MAX_TICKS : ticks;
   138ea:	4e25      	ldr	r6, [pc, #148]	; (13980 <z_clock_set_timeout+0x98>)
   138ec:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
   138f0:	bf08      	it	eq
   138f2:	4630      	moveq	r0, r6
	__asm__ volatile(
   138f4:	f04f 0320 	mov.w	r3, #32
   138f8:	f3ef 8511 	mrs	r5, BASEPRI
   138fc:	f383 8811 	msr	BASEPRI, r3
   13900:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
   13904:	491f      	ldr	r1, [pc, #124]	; (13984 <z_clock_set_timeout+0x9c>)
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t cyc, dt, t = counter();
	u32_t unannounced = counter_sub(t, last_count);
   13906:	4b20      	ldr	r3, [pc, #128]	; (13988 <z_clock_set_timeout+0xa0>)
   13908:	f8d1 4504 	ldr.w	r4, [r1, #1284]	; 0x504
   1390c:	681b      	ldr	r3, [r3, #0]
	return (a - b) & COUNTER_MAX;
   1390e:	1ae2      	subs	r2, r4, r3
   13910:	f022 477f 	bic.w	r7, r2, #4278190080	; 0xff000000
	/* If we haven't announced for more than half the 24-bit wrap
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
   13914:	0212      	lsls	r2, r2, #8
   13916:	d419      	bmi.n	1394c <z_clock_set_timeout+0x64>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
   13918:	1e42      	subs	r2, r0, #1
   1391a:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
   1391e:	42b2      	cmp	r2, r6
   13920:	bfa8      	it	ge
   13922:	4632      	movge	r2, r6
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
   13924:	1c78      	adds	r0, r7, #1
   13926:	4410      	add	r0, r2
	 */
	if (cyc > MAX_CYCLES) {
		cyc = MAX_CYCLES;
	}

	cyc += last_count;
   13928:	42b0      	cmp	r0, r6
   1392a:	bf94      	ite	ls
   1392c:	1818      	addls	r0, r3, r0
   1392e:	1998      	addhi	r0, r3, r6
	return (a - b) & COUNTER_MAX;
   13930:	1b04      	subs	r4, r0, r4
   13932:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
   13936:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
	 * least on nRF52.  Some experimentation on nrf52840 shows
	 * that you need to be early by about 400 processor cycles
	 * (about 1/5th of a RTC cycle) in order to reliably get the
	 * interrupt.  The docs say two cycles, they mean two cycles.
	 */
	if (counter_sub(cyc, t) > 2) {
   1393a:	2c02      	cmp	r4, #2
    p_reg->CC[ch] = cc_val;
   1393c:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
   13940:	d906      	bls.n	13950 <z_clock_set_timeout+0x68>
	__asm__ volatile(
   13942:	f385 8811 	msr	BASEPRI, r5
   13946:	f3bf 8f6f 	isb	sy
	}
#endif

	k_spin_unlock(&lock, key);
#endif /* CONFIG_TICKLESS_KERNEL */
}
   1394a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		ticks = 0;
   1394c:	2200      	movs	r2, #0
   1394e:	e7e9      	b.n	13924 <z_clock_set_timeout+0x3c>
     return p_reg->COUNTER;
   13950:	f8d1 3504 	ldr.w	r3, [r1, #1284]	; 0x504
		if (dt == 0 || dt > 0x7fffff) {
   13954:	4a0d      	ldr	r2, [pc, #52]	; (1398c <z_clock_set_timeout+0xa4>)
	return (a - b) & COUNTER_MAX;
   13956:	1ac3      	subs	r3, r0, r3
   13958:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
		if (dt == 0 || dt > 0x7fffff) {
   1395c:	1e5c      	subs	r4, r3, #1
   1395e:	4294      	cmp	r4, r2
   13960:	d905      	bls.n	1396e <z_clock_set_timeout+0x86>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   13962:	4b0b      	ldr	r3, [pc, #44]	; (13990 <z_clock_set_timeout+0xa8>)
   13964:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   13968:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   1396c:	e7e9      	b.n	13942 <z_clock_set_timeout+0x5a>
		} else if (dt == 1) {
   1396e:	2b01      	cmp	r3, #1
			set_comparator(cyc + 2);
   13970:	bf02      	ittt	eq
   13972:	3002      	addeq	r0, #2
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
   13974:	f020 407f 	biceq.w	r0, r0, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
   13978:	f8c1 0540 	streq.w	r0, [r1, #1344]	; 0x540
   1397c:	e7e1      	b.n	13942 <z_clock_set_timeout+0x5a>
   1397e:	bf00      	nop
   13980:	00fffffe 	.word	0x00fffffe
   13984:	40011000 	.word	0x40011000
   13988:	200009f8 	.word	0x200009f8
   1398c:	007ffffe 	.word	0x007ffffe
   13990:	e000e100 	.word	0xe000e100

00013994 <z_clock_elapsed>:
	__asm__ volatile(
   13994:	f04f 0220 	mov.w	r2, #32
   13998:	f3ef 8311 	mrs	r3, BASEPRI
   1399c:	f382 8811 	msr	BASEPRI, r2
   139a0:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
   139a4:	4a06      	ldr	r2, [pc, #24]	; (139c0 <z_clock_elapsed+0x2c>)
   139a6:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
   139aa:	4a06      	ldr	r2, [pc, #24]	; (139c4 <z_clock_elapsed+0x30>)
	return (a - b) & COUNTER_MAX;
   139ac:	6812      	ldr	r2, [r2, #0]
   139ae:	1a80      	subs	r0, r0, r2
   139b0:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	__asm__ volatile(
   139b4:	f383 8811 	msr	BASEPRI, r3
   139b8:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
   139bc:	4770      	bx	lr
   139be:	bf00      	nop
   139c0:	40011000 	.word	0x40011000
   139c4:	200009f8 	.word	0x200009f8

000139c8 <z_timer_cycle_get_32>:
	__asm__ volatile(
   139c8:	f04f 0320 	mov.w	r3, #32
   139cc:	f3ef 8211 	mrs	r2, BASEPRI
   139d0:	f383 8811 	msr	BASEPRI, r3
   139d4:	f3bf 8f6f 	isb	sy

u32_t z_timer_cycle_get_32(void)
{
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) + last_count;
   139d8:	4906      	ldr	r1, [pc, #24]	; (139f4 <z_timer_cycle_get_32+0x2c>)
   139da:	4b07      	ldr	r3, [pc, #28]	; (139f8 <z_timer_cycle_get_32+0x30>)
   139dc:	6808      	ldr	r0, [r1, #0]
   139de:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	__asm__ volatile(
   139e2:	f382 8811 	msr	BASEPRI, r2
   139e6:	f3bf 8f6f 	isb	sy
	return (a - b) & COUNTER_MAX;
   139ea:	1a1b      	subs	r3, r3, r0
   139ec:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000

	k_spin_unlock(&lock, key);
	return ret;
}
   139f0:	4418      	add	r0, r3
   139f2:	4770      	bx	lr
   139f4:	200009f8 	.word	0x200009f8
   139f8:	40011000 	.word	0x40011000

000139fc <z_arm_exc_exit>:
    /* r0 contains the caller mode */
    push {r0, lr}
#endif

#ifdef CONFIG_PREEMPT_ENABLED
    ldr r0, =_kernel
   139fc:	4804      	ldr	r0, [pc, #16]	; (13a10 <_EXIT_EXC+0x2>)

    ldr r1, [r0, #_kernel_offset_to_current]
   139fe:	6881      	ldr	r1, [r0, #8]

    ldr r0, [r0, #_kernel_offset_to_ready_q_cache]
   13a00:	6a40      	ldr	r0, [r0, #36]	; 0x24
    cmp r0, r1
   13a02:	4288      	cmp	r0, r1
    beq _EXIT_EXC
   13a04:	d003      	beq.n	13a0e <_EXIT_EXC>

#if defined(CONFIG_CPU_CORTEX_M)
    /* context switch required, pend the PendSV exception */
    ldr r1, =_SCS_ICSR
   13a06:	4903      	ldr	r1, [pc, #12]	; (13a14 <_EXIT_EXC+0x6>)
    ldr r2, =_SCS_ICSR_PENDSV
   13a08:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    str r2, [r1]
   13a0c:	600a      	str	r2, [r1, #0]

00013a0e <_EXIT_EXC>:
    bl z_check_stack_sentinel
#endif /* CONFIG_CPU_CORTEX_M */
#endif /* CONFIG_STACK_SENTINEL */

#if defined(CONFIG_CPU_CORTEX_M)
    bx lr
   13a0e:	4770      	bx	lr
    ldr r0, =_kernel
   13a10:	20003b20 	.word	0x20003b20
    ldr r1, =_SCS_ICSR
   13a14:	e000ed04 	.word	0xe000ed04

00013a18 <arch_swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
   13a18:	4a09      	ldr	r2, [pc, #36]	; (13a40 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
   13a1a:	490a      	ldr	r1, [pc, #40]	; (13a44 <arch_swap+0x2c>)
	_current->arch.basepri = key;
   13a1c:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
   13a1e:	6809      	ldr	r1, [r1, #0]
   13a20:	6699      	str	r1, [r3, #104]	; 0x68

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   13a22:	4909      	ldr	r1, [pc, #36]	; (13a48 <arch_swap+0x30>)
	_current->arch.basepri = key;
   13a24:	6658      	str	r0, [r3, #100]	; 0x64
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   13a26:	684b      	ldr	r3, [r1, #4]
   13a28:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   13a2c:	604b      	str	r3, [r1, #4]
   13a2e:	2300      	movs	r3, #0
   13a30:	f383 8811 	msr	BASEPRI, r3
   13a34:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
   13a38:	6893      	ldr	r3, [r2, #8]
}
   13a3a:	6e98      	ldr	r0, [r3, #104]	; 0x68
   13a3c:	4770      	bx	lr
   13a3e:	bf00      	nop
   13a40:	20003b20 	.word	0x20003b20
   13a44:	0002e830 	.word	0x0002e830
   13a48:	e000ed00 	.word	0xe000ed00

00013a4c <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
   13a4c:	4912      	ldr	r1, [pc, #72]	; (13a98 <z_arm_pendsv+0x4c>)
    ldr r2, [r1, #_kernel_offset_to_current]
   13a4e:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
   13a50:	f04f 0028 	mov.w	r0, #40	; 0x28
    add r0, r2
   13a54:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
   13a56:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
   13a5a:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   13a5e:	2020      	movs	r0, #32
    msr BASEPRI, r0
   13a60:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
   13a64:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
   13a68:	4f0c      	ldr	r7, [pc, #48]	; (13a9c <z_arm_pendsv+0x50>)
    ldr v3, =_SCS_ICSR_UNPENDSV
   13a6a:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
   13a6e:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
   13a70:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
   13a72:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
   13a74:	6e50      	ldr	r0, [r2, #100]	; 0x64
    movs r3, #0
   13a76:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
   13a78:	6653      	str	r3, [r2, #100]	; 0x64
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
   13a7a:	f380 8811 	msr	BASEPRI, r0
    isb
#endif

#if defined (CONFIG_ARM_MPU)
    /* Re-program dynamic memory map */
    push {r2,lr}
   13a7e:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
   13a80:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
   13a82:	f016 fbd2 	bl	2a22a <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
   13a86:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
   13a8a:	f102 0028 	add.w	r0, r2, #40	; 0x28
    ldmia r0, {v1-v8, ip}
   13a8e:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
    mov r0, #0
    msr PSPLIM, r0
#endif /* CONFIG_BUILTIN_STACK_GUARD */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
   13a92:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
   13a96:	4770      	bx	lr
    ldr r1, =_kernel
   13a98:	20003b20 	.word	0x20003b20
    ldr v4, =_SCS_ICSR
   13a9c:	e000ed04 	.word	0xe000ed04

00013aa0 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
   13aa0:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
   13aa4:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
   13aa6:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
   13aaa:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
   13aae:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
   13ab0:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
   13ab4:	2902      	cmp	r1, #2
    beq _oops
   13ab6:	d0ff      	beq.n	13ab8 <_oops>

00013ab8 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
   13ab8:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
   13aba:	f016 fbab 	bl	2a214 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
   13abe:	bd01      	pop	{r0, pc}

00013ac0 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
   13ac0:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
   13ac2:	2b00      	cmp	r3, #0
   13ac4:	db08      	blt.n	13ad8 <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   13ac6:	2201      	movs	r2, #1
   13ac8:	f000 001f 	and.w	r0, r0, #31
   13acc:	fa02 f000 	lsl.w	r0, r2, r0
   13ad0:	095b      	lsrs	r3, r3, #5
   13ad2:	4a02      	ldr	r2, [pc, #8]	; (13adc <arch_irq_enable+0x1c>)
   13ad4:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   13ad8:	4770      	bx	lr
   13ada:	bf00      	nop
   13adc:	e000e100 	.word	0xe000e100

00013ae0 <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
   13ae0:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
   13ae2:	2b00      	cmp	r3, #0
   13ae4:	db0d      	blt.n	13b02 <arch_irq_disable+0x22>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   13ae6:	2201      	movs	r2, #1
   13ae8:	095b      	lsrs	r3, r3, #5
   13aea:	f000 001f 	and.w	r0, r0, #31
   13aee:	fa02 f000 	lsl.w	r0, r2, r0
   13af2:	3320      	adds	r3, #32
   13af4:	4a03      	ldr	r2, [pc, #12]	; (13b04 <arch_irq_disable+0x24>)
   13af6:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   13afa:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   13afe:	f3bf 8f6f 	isb	sy
}
   13b02:	4770      	bx	lr
   13b04:	e000e100 	.word	0xe000e100

00013b08 <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
   13b08:	0942      	lsrs	r2, r0, #5
   13b0a:	4b05      	ldr	r3, [pc, #20]	; (13b20 <arch_irq_is_enabled+0x18>)
   13b0c:	f000 001f 	and.w	r0, r0, #31
   13b10:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
   13b14:	2301      	movs	r3, #1
   13b16:	fa03 f000 	lsl.w	r0, r3, r0
}
   13b1a:	4010      	ands	r0, r2
   13b1c:	4770      	bx	lr
   13b1e:	bf00      	nop
   13b20:	e000e100 	.word	0xe000e100

00013b24 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(DT_NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(DT_NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
   13b24:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
   13b26:	2b00      	cmp	r3, #0
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   13b28:	bfa8      	it	ge
   13b2a:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
	prio += _IRQ_PRIO_OFFSET;
   13b2e:	f101 0101 	add.w	r1, r1, #1
   13b32:	ea4f 1141 	mov.w	r1, r1, lsl #5
   13b36:	bfae      	itee	ge
   13b38:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   13b3c:	f000 000f 	andlt.w	r0, r0, #15
   13b40:	4b03      	ldrlt	r3, [pc, #12]	; (13b50 <z_arm_irq_priority_set+0x2c>)
   13b42:	b2c9      	uxtb	r1, r1
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   13b44:	bfac      	ite	ge
   13b46:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   13b4a:	5419      	strblt	r1, [r3, r0]
}
   13b4c:	4770      	bx	lr
   13b4e:	bf00      	nop
   13b50:	e000ed14 	.word	0xe000ed14

00013b54 <_arch_isr_direct_pm>:
	z_arm_reserved();
}

#ifdef CONFIG_SYS_POWER_MANAGEMENT
void _arch_isr_direct_pm(void)
{
   13b54:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
   13b56:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
   13b58:	4b04      	ldr	r3, [pc, #16]	; (13b6c <_arch_isr_direct_pm+0x18>)
   13b5a:	6a18      	ldr	r0, [r3, #32]
   13b5c:	b118      	cbz	r0, 13b66 <_arch_isr_direct_pm+0x12>
		s32_t idle_val = _kernel.idle;

		_kernel.idle = 0;
   13b5e:	2200      	movs	r2, #0
   13b60:	621a      	str	r2, [r3, #32]
		z_sys_power_save_idle_exit(idle_val);
   13b62:	f019 fa1c 	bl	2cf9e <z_sys_power_save_idle_exit>

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
   13b66:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
   13b68:	bd08      	pop	{r3, pc}
   13b6a:	bf00      	nop
   13b6c:	20003b20 	.word	0x20003b20

00013b70 <arch_new_thread>:
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     size_t stackSize, k_thread_entry_t pEntry,
		     void *parameter1, void *parameter2, void *parameter3,
		     int priority, unsigned int options)
{
   13b70:	b573      	push	{r0, r1, r4, r5, r6, lr}
   13b72:	461e      	mov	r6, r3
#endif
	stackEnd = pStackMem + stackSize;

	struct __esf *pInitCtx;

	z_new_thread_init(thread, pStackMem, stackSize, priority,
   13b74:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   13b76:	9300      	str	r3, [sp, #0]
	stackEnd = pStackMem + stackSize;
   13b78:	188c      	adds	r4, r1, r2
	z_new_thread_init(thread, pStackMem, stackSize, priority,
   13b7a:	9b09      	ldr	r3, [sp, #36]	; 0x24
{
   13b7c:	4605      	mov	r5, r0
	z_new_thread_init(thread, pStackMem, stackSize, priority,
   13b7e:	f019 fc5b 	bl	2d438 <z_new_thread_init>
	 *
	 * The initial carved stack frame only needs to contain the basic
	 * stack frame (state context), because no FP operations have been
	 * performed yet for this thread.
	 */
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
   13b82:	f1a4 0320 	sub.w	r3, r4, #32
	pInitCtx->basic.pc = (u32_t)z_thread_entry;
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	pInitCtx->basic.pc &= 0xfffffffe;
   13b86:	4a0a      	ldr	r2, [pc, #40]	; (13bb0 <arch_new_thread+0x40>)
	pInitCtx = (struct __esf *)(STACK_ROUND_DOWN(stackEnd -
   13b88:	f023 0307 	bic.w	r3, r3, #7
	pInitCtx->basic.pc &= 0xfffffffe;
   13b8c:	f022 0201 	bic.w	r2, r2, #1
   13b90:	619a      	str	r2, [r3, #24]
#endif

	pInitCtx->basic.a1 = (u32_t)pEntry;
	pInitCtx->basic.a2 = (u32_t)parameter1;
   13b92:	9a06      	ldr	r2, [sp, #24]
   13b94:	605a      	str	r2, [r3, #4]
	pInitCtx->basic.a3 = (u32_t)parameter2;
   13b96:	9a07      	ldr	r2, [sp, #28]
   13b98:	609a      	str	r2, [r3, #8]
	pInitCtx->basic.a4 = (u32_t)parameter3;
   13b9a:	9a08      	ldr	r2, [sp, #32]
   13b9c:	60da      	str	r2, [r3, #12]
	pInitCtx->basic.xpsr =
   13b9e:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
	pInitCtx->basic.a1 = (u32_t)pEntry;
   13ba2:	601e      	str	r6, [r3, #0]
	pInitCtx->basic.xpsr =
   13ba4:	61da      	str	r2, [r3, #28]
		0x01000000UL; /* clear all, thumb bit is 1, even if RO */

	thread->callee_saved.psp = (u32_t)pInitCtx;
   13ba6:	64ab      	str	r3, [r5, #72]	; 0x48
#if defined(CONFIG_CPU_CORTEX_R)
	pInitCtx->basic.lr = (u32_t)pInitCtx->basic.pc;
	thread->callee_saved.spsr = A_BIT | T_BIT | MODE_SYS;
	thread->callee_saved.lr = (u32_t)pInitCtx->basic.pc;
#endif
	thread->arch.basepri = 0;
   13ba8:	2300      	movs	r3, #0
   13baa:	666b      	str	r3, [r5, #100]	; 0x64

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
   13bac:	b002      	add	sp, #8
   13bae:	bd70      	pop	{r4, r5, r6, pc}
   13bb0:	00027dcd 	.word	0x00027dcd

00013bb4 <arch_switch_to_main_thread>:

void arch_switch_to_main_thread(struct k_thread *main_thread,
				k_thread_stack_t *main_stack,
				size_t main_stack_size,
				k_thread_entry_t _main)
{
   13bb4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   13bb6:	4605      	mov	r5, r0
   13bb8:	460c      	mov	r4, r1
   13bba:	4617      	mov	r7, r2
   13bbc:	461e      	mov	r6, r3
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
   13bbe:	f000 fc61 	bl	14484 <z_arm_configure_static_mpu_regions>
	start_of_main_stack =
		Z_THREAD_STACK_BUFFER(main_stack) + main_stack_size;

	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);

	_current = main_thread;
   13bc2:	4b0a      	ldr	r3, [pc, #40]	; (13bec <arch_switch_to_main_thread+0x38>)
	start_of_main_stack =
   13bc4:	443c      	add	r4, r7
#ifdef CONFIG_ARM_MPU
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
   13bc6:	4628      	mov	r0, r5
	_current = main_thread;
   13bc8:	609d      	str	r5, [r3, #8]
	start_of_main_stack = (char *)STACK_ROUND_DOWN(start_of_main_stack);
   13bca:	f024 0407 	bic.w	r4, r4, #7
	z_arm_configure_dynamic_mpu_regions(main_thread);
   13bce:	f016 fb2c 	bl	2a22a <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
   13bd2:	4630      	mov	r0, r6
   13bd4:	f384 8809 	msr	PSP, r4
   13bd8:	2100      	movs	r1, #0
   13bda:	b663      	cpsie	if
   13bdc:	f381 8811 	msr	BASEPRI, r1
   13be0:	f3bf 8f6f 	isb	sy
   13be4:	2200      	movs	r2, #0
   13be6:	2300      	movs	r3, #0
   13be8:	f014 f8f0 	bl	27dcc <z_thread_entry>
	:
	: "r" (_main), "r" (start_of_main_stack)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
   13bec:	20003b20 	.word	0x20003b20

00013bf0 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr r1, =_SCB_SCR
   13bf0:	4901      	ldr	r1, [pc, #4]	; (13bf8 <z_arm_cpu_idle_init+0x8>)
	movs.n r2, #_SCR_INIT_BITS
   13bf2:	2210      	movs	r2, #16
	str r2, [r1]
   13bf4:	600a      	str	r2, [r1, #0]
#endif
	bx lr
   13bf6:	4770      	bx	lr
	ldr r1, =_SCB_SCR
   13bf8:	e000ed10 	.word	0xe000ed10

00013bfc <arch_cpu_idle>:
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	cpsie i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* clear BASEPRI so wfi is awakened by incoming interrupts */
	eors.n r0, r0
   13bfc:	4040      	eors	r0, r0
	msr BASEPRI, r0
   13bfe:	f380 8811 	msr	BASEPRI, r0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	wfi
   13c02:	bf30      	wfi

	bx lr
   13c04:	4770      	bx	lr
   13c06:	bf00      	nop

00013c08 <z_arm_bus_fault>:
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_reserved)

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) || \
	defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	mrs r0, MSP
   13c08:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
   13c0c:	f3ef 8109 	mrs	r1, PSP
	mov r2, lr /* EXC_RETURN */
   13c10:	4672      	mov	r2, lr

	push {r0, lr}
   13c12:	b501      	push	{r0, lr}
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE || CONFIG_ARMv7_M_ARMV8_M_MAINLINE */

	bl z_arm_fault
   13c14:	f000 faec 	bl	141f0 <z_arm_fault>

#if defined(CONFIG_CPU_CORTEX_M)
	pop {r0, pc}
   13c18:	bd01      	pop	{r0, pc}
   13c1a:	bf00      	nop

00013c1c <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   13c1c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   13c1e:	4606      	mov	r6, r0

	if (esf != NULL) {
   13c20:	460c      	mov	r4, r1
   13c22:	2900      	cmp	r1, #0
   13c24:	d045      	beq.n	13cb2 <z_arm_fatal_error+0x96>
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
   13c26:	4f26      	ldr	r7, [pc, #152]	; (13cc0 <z_arm_fatal_error+0xa4>)
   13c28:	683b      	ldr	r3, [r7, #0]
   13c2a:	0758      	lsls	r0, r3, #29
   13c2c:	d041      	beq.n	13cb2 <z_arm_fatal_error+0x96>
   13c2e:	2201      	movs	r2, #1
   13c30:	f04f 0300 	mov.w	r3, #0
   13c34:	f362 0307 	bfi	r3, r2, #0, #8
   13c38:	4d22      	ldr	r5, [pc, #136]	; (13cc4 <z_arm_fatal_error+0xa8>)
   13c3a:	4a23      	ldr	r2, [pc, #140]	; (13cc8 <z_arm_fatal_error+0xac>)
   13c3c:	4823      	ldr	r0, [pc, #140]	; (13ccc <z_arm_fatal_error+0xb0>)
   13c3e:	1aad      	subs	r5, r5, r2
   13c40:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   13c44:	f365 138f 	bfi	r3, r5, #6, #10
   13c48:	f8ad 3000 	strh.w	r3, [sp]
   13c4c:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
   13c50:	6809      	ldr	r1, [r1, #0]
   13c52:	f014 feab 	bl	289ac <log_3>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
   13c56:	683b      	ldr	r3, [r7, #0]
   13c58:	0759      	lsls	r1, r3, #29
   13c5a:	d02a      	beq.n	13cb2 <z_arm_fatal_error+0x96>
   13c5c:	2201      	movs	r2, #1
   13c5e:	f04f 0300 	mov.w	r3, #0
   13c62:	f362 0307 	bfi	r3, r2, #0, #8
   13c66:	f365 138f 	bfi	r3, r5, #6, #10
   13c6a:	f8ad 3000 	strh.w	r3, [sp]
   13c6e:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
   13c72:	68e1      	ldr	r1, [r4, #12]
   13c74:	4816      	ldr	r0, [pc, #88]	; (13cd0 <z_arm_fatal_error+0xb4>)
   13c76:	f014 fe99 	bl	289ac <log_3>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
   13c7a:	683b      	ldr	r3, [r7, #0]
   13c7c:	075a      	lsls	r2, r3, #29
   13c7e:	d018      	beq.n	13cb2 <z_arm_fatal_error+0x96>
   13c80:	2301      	movs	r3, #1
   13c82:	f04f 0200 	mov.w	r2, #0
   13c86:	f363 0207 	bfi	r2, r3, #0, #8
   13c8a:	f365 128f 	bfi	r2, r5, #6, #10
   13c8e:	69e1      	ldr	r1, [r4, #28]
   13c90:	4810      	ldr	r0, [pc, #64]	; (13cd4 <z_arm_fatal_error+0xb8>)
   13c92:	f014 fe5f 	bl	28954 <log_1>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
   13c96:	683b      	ldr	r3, [r7, #0]
   13c98:	075b      	lsls	r3, r3, #29
   13c9a:	d00a      	beq.n	13cb2 <z_arm_fatal_error+0x96>
   13c9c:	f04f 0200 	mov.w	r2, #0
   13ca0:	2301      	movs	r3, #1
   13ca2:	f363 0207 	bfi	r2, r3, #0, #8
   13ca6:	f365 128f 	bfi	r2, r5, #6, #10
   13caa:	69a1      	ldr	r1, [r4, #24]
   13cac:	480a      	ldr	r0, [pc, #40]	; (13cd8 <z_arm_fatal_error+0xbc>)
   13cae:	f014 fe51 	bl	28954 <log_1>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
   13cb2:	4621      	mov	r1, r4
   13cb4:	4630      	mov	r0, r6
}
   13cb6:	b003      	add	sp, #12
   13cb8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	z_fatal_error(reason, esf);
   13cbc:	f012 bb70 	b.w	263a0 <z_fatal_error>
   13cc0:	20010030 	.word	0x20010030
   13cc4:	0002dc58 	.word	0x0002dc58
   13cc8:	0002db28 	.word	0x0002db28
   13ccc:	0003021a 	.word	0x0003021a
   13cd0:	00030249 	.word	0x00030249
   13cd4:	00030278 	.word	0x00030278
   13cd8:	00030287 	.word	0x00030287

00013cdc <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
   13cdc:	bf30      	wfi
    b z_SysNmiOnReset
   13cde:	f7ff bffd 	b.w	13cdc <z_SysNmiOnReset>
   13ce2:	bf00      	nop

00013ce4 <z_arm_prep_c>:
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
   13ce4:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   13ce6:	4b08      	ldr	r3, [pc, #32]	; (13d08 <z_arm_prep_c+0x24>)
   13ce8:	4a08      	ldr	r2, [pc, #32]	; (13d0c <z_arm_prep_c+0x28>)
   13cea:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
   13cee:	6093      	str	r3, [r2, #8]
  __ASM volatile ("dsb 0xF":::"memory");
   13cf0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   13cf4:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
	enable_floating_point();
	z_bss_zero();
   13cf8:	f012 fbe2 	bl	264c0 <z_bss_zero>
	z_data_copy();
   13cfc:	f012 fbea 	bl	264d4 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_int_lib_init();
   13d00:	f000 fb8e 	bl	14420 <z_arm_int_lib_init>
	z_cstart();
   13d04:	f012 fc1e 	bl	26544 <z_cstart>
   13d08:	0000c200 	.word	0x0000c200
   13d0c:	e000ed00 	.word	0xe000ed00

00013d10 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
   13d10:	b501      	push	{r0, lr}
	 * device for the next timer deadline is not interrupted.  For
	 * non-tickless idle, this ensures that the clearing of the kernel idle
	 * state is not interrupted.  In each case, z_sys_power_save_idle_exit
	 * is called with interrupts disabled.
	 */
	cpsid i  /* PRIMASK = 1 */
   13d12:	b672      	cpsid	i

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
   13d14:	4a0b      	ldr	r2, [pc, #44]	; (13d44 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
   13d16:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
   13d18:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
   13d1a:	bf1e      	ittt	ne
	movne	r1, #0
   13d1c:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
   13d1e:	6211      	strne	r1, [r2, #32]
		blne	z_sys_power_save_idle_exit
   13d20:	f019 f93d 	blne	2cf9e <z_sys_power_save_idle_exit>
_idle_state_cleared:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
   13d24:	b662      	cpsie	i
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
   13d26:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
   13d2a:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
   13d2e:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 */
	mov r0, #0
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldr r1, =_sw_isr_table
   13d32:	4905      	ldr	r1, [pc, #20]	; (13d48 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
   13d34:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
   13d36:	c909      	ldmia	r1!, {r0, r3}
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	ldm sp!,{r0-r3} /* Restore r0 to r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
   13d38:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
   13d3a:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
   13d3e:	4903      	ldr	r1, [pc, #12]	; (13d4c <_isr_wrapper+0x3c>)
	bx r1
   13d40:	4708      	bx	r1
   13d42:	0000      	.short	0x0000
	ldr r2, =_kernel
   13d44:	20003b20 	.word	0x20003b20
	ldr r1, =_sw_isr_table
   13d48:	0002d8b4 	.word	0x0002d8b4
	ldr r1, =z_arm_int_exit
   13d4c:	000139fd 	.word	0x000139fd

00013d50 <__start>:
 * search for a __start symbol instead, so create that alias here.
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
   13d50:	f016 fc50 	bl	2a5f4 <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   13d54:	2020      	movs	r0, #32
    msr BASEPRI, r0
   13d56:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to _interrupt_stack during initialization.
     */
    ldr r0, =_interrupt_stack
   13d5a:	4808      	ldr	r0, [pc, #32]	; (13d7c <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
   13d5c:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
   13d60:	1840      	adds	r0, r0, r1
    msr PSP, r0
   13d62:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
   13d66:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
   13d6a:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
   13d6c:	4308      	orrs	r0, r1
    msr CONTROL, r0
   13d6e:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
   13d72:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
   13d76:	f7ff ffb5 	bl	13ce4 <z_arm_prep_c>
   13d7a:	0000      	.short	0x0000
    ldr r0, =_interrupt_stack
   13d7c:	20007a10 	.word	0x20007a10

00013d80 <usage_fault.isra.2>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t usage_fault(const z_arch_esf_t *esf)
   13d80:	b510      	push	{r4, lr}
{
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");
   13d82:	4c4c      	ldr	r4, [pc, #304]	; (13eb4 <usage_fault.isra.2+0x134>)
   13d84:	6823      	ldr	r3, [r4, #0]
   13d86:	075b      	lsls	r3, r3, #29
   13d88:	d00d      	beq.n	13da6 <usage_fault.isra.2+0x26>
   13d8a:	2301      	movs	r3, #1
   13d8c:	f04f 0100 	mov.w	r1, #0
   13d90:	f363 0107 	bfi	r1, r3, #0, #8
   13d94:	4a48      	ldr	r2, [pc, #288]	; (13eb8 <usage_fault.isra.2+0x138>)
   13d96:	4b49      	ldr	r3, [pc, #292]	; (13ebc <usage_fault.isra.2+0x13c>)
   13d98:	4849      	ldr	r0, [pc, #292]	; (13ec0 <usage_fault.isra.2+0x140>)
   13d9a:	1a9b      	subs	r3, r3, r2
   13d9c:	08db      	lsrs	r3, r3, #3
   13d9e:	f363 118f 	bfi	r1, r3, #6, #10
   13da2:	f014 fdca 	bl	2893a <log_0>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   13da6:	4b47      	ldr	r3, [pc, #284]	; (13ec4 <usage_fault.isra.2+0x144>)
   13da8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   13daa:	0198      	lsls	r0, r3, #6
   13dac:	d510      	bpl.n	13dd0 <usage_fault.isra.2+0x50>
		PR_FAULT_INFO("  Division by zero");
   13dae:	6823      	ldr	r3, [r4, #0]
   13db0:	0759      	lsls	r1, r3, #29
   13db2:	d00d      	beq.n	13dd0 <usage_fault.isra.2+0x50>
   13db4:	2301      	movs	r3, #1
   13db6:	f04f 0100 	mov.w	r1, #0
   13dba:	f363 0107 	bfi	r1, r3, #0, #8
   13dbe:	4a3e      	ldr	r2, [pc, #248]	; (13eb8 <usage_fault.isra.2+0x138>)
   13dc0:	4b3e      	ldr	r3, [pc, #248]	; (13ebc <usage_fault.isra.2+0x13c>)
   13dc2:	4841      	ldr	r0, [pc, #260]	; (13ec8 <usage_fault.isra.2+0x148>)
   13dc4:	1a9b      	subs	r3, r3, r2
   13dc6:	08db      	lsrs	r3, r3, #3
   13dc8:	f363 118f 	bfi	r1, r3, #6, #10
   13dcc:	f014 fdb5 	bl	2893a <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
   13dd0:	4b3c      	ldr	r3, [pc, #240]	; (13ec4 <usage_fault.isra.2+0x144>)
   13dd2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   13dd4:	01da      	lsls	r2, r3, #7
   13dd6:	d510      	bpl.n	13dfa <usage_fault.isra.2+0x7a>
		PR_FAULT_INFO("  Unaligned memory access");
   13dd8:	6823      	ldr	r3, [r4, #0]
   13dda:	075b      	lsls	r3, r3, #29
   13ddc:	d00d      	beq.n	13dfa <usage_fault.isra.2+0x7a>
   13dde:	2301      	movs	r3, #1
   13de0:	f04f 0100 	mov.w	r1, #0
   13de4:	f363 0107 	bfi	r1, r3, #0, #8
   13de8:	4a33      	ldr	r2, [pc, #204]	; (13eb8 <usage_fault.isra.2+0x138>)
   13dea:	4b34      	ldr	r3, [pc, #208]	; (13ebc <usage_fault.isra.2+0x13c>)
   13dec:	4837      	ldr	r0, [pc, #220]	; (13ecc <usage_fault.isra.2+0x14c>)
   13dee:	1a9b      	subs	r3, r3, r2
   13df0:	08db      	lsrs	r3, r3, #3
   13df2:	f363 118f 	bfi	r1, r3, #6, #10
   13df6:	f014 fda0 	bl	2893a <log_0>
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
   13dfa:	4b32      	ldr	r3, [pc, #200]	; (13ec4 <usage_fault.isra.2+0x144>)
   13dfc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   13dfe:	0318      	lsls	r0, r3, #12
   13e00:	d510      	bpl.n	13e24 <usage_fault.isra.2+0xa4>
		PR_FAULT_INFO("  No coprocessor instructions");
   13e02:	6823      	ldr	r3, [r4, #0]
   13e04:	0759      	lsls	r1, r3, #29
   13e06:	d00d      	beq.n	13e24 <usage_fault.isra.2+0xa4>
   13e08:	2301      	movs	r3, #1
   13e0a:	f04f 0100 	mov.w	r1, #0
   13e0e:	f363 0107 	bfi	r1, r3, #0, #8
   13e12:	4a29      	ldr	r2, [pc, #164]	; (13eb8 <usage_fault.isra.2+0x138>)
   13e14:	4b29      	ldr	r3, [pc, #164]	; (13ebc <usage_fault.isra.2+0x13c>)
   13e16:	482e      	ldr	r0, [pc, #184]	; (13ed0 <usage_fault.isra.2+0x150>)
   13e18:	1a9b      	subs	r3, r3, r2
   13e1a:	08db      	lsrs	r3, r3, #3
   13e1c:	f363 118f 	bfi	r1, r3, #6, #10
   13e20:	f014 fd8b 	bl	2893a <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
   13e24:	4b27      	ldr	r3, [pc, #156]	; (13ec4 <usage_fault.isra.2+0x144>)
   13e26:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   13e28:	035a      	lsls	r2, r3, #13
   13e2a:	d510      	bpl.n	13e4e <usage_fault.isra.2+0xce>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
   13e2c:	6823      	ldr	r3, [r4, #0]
   13e2e:	075b      	lsls	r3, r3, #29
   13e30:	d00d      	beq.n	13e4e <usage_fault.isra.2+0xce>
   13e32:	2301      	movs	r3, #1
   13e34:	f04f 0100 	mov.w	r1, #0
   13e38:	f363 0107 	bfi	r1, r3, #0, #8
   13e3c:	4a1e      	ldr	r2, [pc, #120]	; (13eb8 <usage_fault.isra.2+0x138>)
   13e3e:	4b1f      	ldr	r3, [pc, #124]	; (13ebc <usage_fault.isra.2+0x13c>)
   13e40:	4824      	ldr	r0, [pc, #144]	; (13ed4 <usage_fault.isra.2+0x154>)
   13e42:	1a9b      	subs	r3, r3, r2
   13e44:	08db      	lsrs	r3, r3, #3
   13e46:	f363 118f 	bfi	r1, r3, #6, #10
   13e4a:	f014 fd76 	bl	2893a <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
   13e4e:	4b1d      	ldr	r3, [pc, #116]	; (13ec4 <usage_fault.isra.2+0x144>)
   13e50:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   13e52:	0398      	lsls	r0, r3, #14
   13e54:	d510      	bpl.n	13e78 <usage_fault.isra.2+0xf8>
		PR_FAULT_INFO("  Illegal use of the EPSR");
   13e56:	6823      	ldr	r3, [r4, #0]
   13e58:	0759      	lsls	r1, r3, #29
   13e5a:	d00d      	beq.n	13e78 <usage_fault.isra.2+0xf8>
   13e5c:	2301      	movs	r3, #1
   13e5e:	f04f 0100 	mov.w	r1, #0
   13e62:	f363 0107 	bfi	r1, r3, #0, #8
   13e66:	4a14      	ldr	r2, [pc, #80]	; (13eb8 <usage_fault.isra.2+0x138>)
   13e68:	4b14      	ldr	r3, [pc, #80]	; (13ebc <usage_fault.isra.2+0x13c>)
   13e6a:	481b      	ldr	r0, [pc, #108]	; (13ed8 <usage_fault.isra.2+0x158>)
   13e6c:	1a9b      	subs	r3, r3, r2
   13e6e:	08db      	lsrs	r3, r3, #3
   13e70:	f363 118f 	bfi	r1, r3, #6, #10
   13e74:	f014 fd61 	bl	2893a <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
   13e78:	4b12      	ldr	r3, [pc, #72]	; (13ec4 <usage_fault.isra.2+0x144>)
   13e7a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   13e7c:	03da      	lsls	r2, r3, #15
   13e7e:	d510      	bpl.n	13ea2 <usage_fault.isra.2+0x122>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
   13e80:	6823      	ldr	r3, [r4, #0]
   13e82:	075b      	lsls	r3, r3, #29
   13e84:	d00d      	beq.n	13ea2 <usage_fault.isra.2+0x122>
   13e86:	2301      	movs	r3, #1
   13e88:	f04f 0100 	mov.w	r1, #0
   13e8c:	f363 0107 	bfi	r1, r3, #0, #8
   13e90:	4a09      	ldr	r2, [pc, #36]	; (13eb8 <usage_fault.isra.2+0x138>)
   13e92:	4b0a      	ldr	r3, [pc, #40]	; (13ebc <usage_fault.isra.2+0x13c>)
   13e94:	4811      	ldr	r0, [pc, #68]	; (13edc <usage_fault.isra.2+0x15c>)
   13e96:	1a9b      	subs	r3, r3, r2
   13e98:	08db      	lsrs	r3, r3, #3
   13e9a:	f363 118f 	bfi	r1, r3, #6, #10
   13e9e:	f014 fd4c 	bl	2893a <log_0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   13ea2:	4a08      	ldr	r2, [pc, #32]	; (13ec4 <usage_fault.isra.2+0x144>)
   13ea4:	6a93      	ldr	r3, [r2, #40]	; 0x28
   13ea6:	ea6f 4303 	mvn.w	r3, r3, lsl #16
   13eaa:	ea6f 4313 	mvn.w	r3, r3, lsr #16
   13eae:	6293      	str	r3, [r2, #40]	; 0x28

	return reason;
}
   13eb0:	2000      	movs	r0, #0
   13eb2:	bd10      	pop	{r4, pc}
   13eb4:	20010030 	.word	0x20010030
   13eb8:	0002db28 	.word	0x0002db28
   13ebc:	0002dc58 	.word	0x0002dc58
   13ec0:	00030415 	.word	0x00030415
   13ec4:	e000ed00 	.word	0xe000ed00
   13ec8:	0003042d 	.word	0x0003042d
   13ecc:	00030440 	.word	0x00030440
   13ed0:	0003045a 	.word	0x0003045a
   13ed4:	00030478 	.word	0x00030478
   13ed8:	0003049d 	.word	0x0003049d
   13edc:	000304b7 	.word	0x000304b7

00013ee0 <mem_manage_fault.isra.4>:
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   13ee0:	b570      	push	{r4, r5, r6, lr}
	PR_FAULT_INFO("***** MPU FAULT *****");
   13ee2:	4c51      	ldr	r4, [pc, #324]	; (14028 <mem_manage_fault.isra.4+0x148>)
   13ee4:	6823      	ldr	r3, [r4, #0]
   13ee6:	075b      	lsls	r3, r3, #29
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   13ee8:	4606      	mov	r6, r0
   13eea:	460d      	mov	r5, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
   13eec:	d00d      	beq.n	13f0a <mem_manage_fault.isra.4+0x2a>
   13eee:	2301      	movs	r3, #1
   13ef0:	f04f 0100 	mov.w	r1, #0
   13ef4:	f363 0107 	bfi	r1, r3, #0, #8
   13ef8:	4a4c      	ldr	r2, [pc, #304]	; (1402c <mem_manage_fault.isra.4+0x14c>)
   13efa:	4b4d      	ldr	r3, [pc, #308]	; (14030 <mem_manage_fault.isra.4+0x150>)
   13efc:	484d      	ldr	r0, [pc, #308]	; (14034 <mem_manage_fault.isra.4+0x154>)
   13efe:	1a9b      	subs	r3, r3, r2
   13f00:	08db      	lsrs	r3, r3, #3
   13f02:	f363 118f 	bfi	r1, r3, #6, #10
   13f06:	f014 fd18 	bl	2893a <log_0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   13f0a:	4b4b      	ldr	r3, [pc, #300]	; (14038 <mem_manage_fault.isra.4+0x158>)
   13f0c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   13f0e:	06d8      	lsls	r0, r3, #27
   13f10:	d510      	bpl.n	13f34 <mem_manage_fault.isra.4+0x54>
		PR_FAULT_INFO("  Stacking error (context area might be"
   13f12:	6823      	ldr	r3, [r4, #0]
   13f14:	0759      	lsls	r1, r3, #29
   13f16:	d00d      	beq.n	13f34 <mem_manage_fault.isra.4+0x54>
   13f18:	2301      	movs	r3, #1
   13f1a:	f04f 0100 	mov.w	r1, #0
   13f1e:	f363 0107 	bfi	r1, r3, #0, #8
   13f22:	4a42      	ldr	r2, [pc, #264]	; (1402c <mem_manage_fault.isra.4+0x14c>)
   13f24:	4b42      	ldr	r3, [pc, #264]	; (14030 <mem_manage_fault.isra.4+0x150>)
   13f26:	4845      	ldr	r0, [pc, #276]	; (1403c <mem_manage_fault.isra.4+0x15c>)
   13f28:	1a9b      	subs	r3, r3, r2
   13f2a:	08db      	lsrs	r3, r3, #3
   13f2c:	f363 118f 	bfi	r1, r3, #6, #10
   13f30:	f014 fd03 	bl	2893a <log_0>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
   13f34:	4b40      	ldr	r3, [pc, #256]	; (14038 <mem_manage_fault.isra.4+0x158>)
   13f36:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   13f38:	071a      	lsls	r2, r3, #28
   13f3a:	d510      	bpl.n	13f5e <mem_manage_fault.isra.4+0x7e>
		PR_FAULT_INFO("  Unstacking error");
   13f3c:	6823      	ldr	r3, [r4, #0]
   13f3e:	075b      	lsls	r3, r3, #29
   13f40:	d00d      	beq.n	13f5e <mem_manage_fault.isra.4+0x7e>
   13f42:	2301      	movs	r3, #1
   13f44:	f04f 0100 	mov.w	r1, #0
   13f48:	f363 0107 	bfi	r1, r3, #0, #8
   13f4c:	4a37      	ldr	r2, [pc, #220]	; (1402c <mem_manage_fault.isra.4+0x14c>)
   13f4e:	4b38      	ldr	r3, [pc, #224]	; (14030 <mem_manage_fault.isra.4+0x150>)
   13f50:	483b      	ldr	r0, [pc, #236]	; (14040 <mem_manage_fault.isra.4+0x160>)
   13f52:	1a9b      	subs	r3, r3, r2
   13f54:	08db      	lsrs	r3, r3, #3
   13f56:	f363 118f 	bfi	r1, r3, #6, #10
   13f5a:	f014 fcee 	bl	2893a <log_0>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
   13f5e:	4b36      	ldr	r3, [pc, #216]	; (14038 <mem_manage_fault.isra.4+0x158>)
   13f60:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   13f62:	0798      	lsls	r0, r3, #30
   13f64:	d52c      	bpl.n	13fc0 <mem_manage_fault.isra.4+0xe0>
		PR_FAULT_INFO("  Data Access Violation");
   13f66:	6823      	ldr	r3, [r4, #0]
   13f68:	0759      	lsls	r1, r3, #29
   13f6a:	d00d      	beq.n	13f88 <mem_manage_fault.isra.4+0xa8>
   13f6c:	2301      	movs	r3, #1
   13f6e:	f04f 0100 	mov.w	r1, #0
   13f72:	f363 0107 	bfi	r1, r3, #0, #8
   13f76:	4a2d      	ldr	r2, [pc, #180]	; (1402c <mem_manage_fault.isra.4+0x14c>)
   13f78:	4b2d      	ldr	r3, [pc, #180]	; (14030 <mem_manage_fault.isra.4+0x150>)
   13f7a:	4832      	ldr	r0, [pc, #200]	; (14044 <mem_manage_fault.isra.4+0x164>)
   13f7c:	1a9b      	subs	r3, r3, r2
   13f7e:	08db      	lsrs	r3, r3, #3
   13f80:	f363 118f 	bfi	r1, r3, #6, #10
   13f84:	f014 fcd9 	bl	2893a <log_0>
		mmfar = SCB->MMFAR;
   13f88:	4b2b      	ldr	r3, [pc, #172]	; (14038 <mem_manage_fault.isra.4+0x158>)
   13f8a:	6b59      	ldr	r1, [r3, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
   13f8c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   13f8e:	061a      	lsls	r2, r3, #24
   13f90:	d516      	bpl.n	13fc0 <mem_manage_fault.isra.4+0xe0>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
   13f92:	6823      	ldr	r3, [r4, #0]
   13f94:	075b      	lsls	r3, r3, #29
   13f96:	d00d      	beq.n	13fb4 <mem_manage_fault.isra.4+0xd4>
   13f98:	2301      	movs	r3, #1
   13f9a:	f04f 0200 	mov.w	r2, #0
   13f9e:	f363 0207 	bfi	r2, r3, #0, #8
   13fa2:	4822      	ldr	r0, [pc, #136]	; (1402c <mem_manage_fault.isra.4+0x14c>)
   13fa4:	4b22      	ldr	r3, [pc, #136]	; (14030 <mem_manage_fault.isra.4+0x150>)
   13fa6:	1a1b      	subs	r3, r3, r0
   13fa8:	08db      	lsrs	r3, r3, #3
   13faa:	f363 128f 	bfi	r2, r3, #6, #10
   13fae:	4826      	ldr	r0, [pc, #152]	; (14048 <mem_manage_fault.isra.4+0x168>)
   13fb0:	f014 fcd0 	bl	28954 <log_1>
			if (from_hard_fault) {
   13fb4:	b126      	cbz	r6, 13fc0 <mem_manage_fault.isra.4+0xe0>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
   13fb6:	4a20      	ldr	r2, [pc, #128]	; (14038 <mem_manage_fault.isra.4+0x158>)
   13fb8:	6a93      	ldr	r3, [r2, #40]	; 0x28
   13fba:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   13fbe:	6293      	str	r3, [r2, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
   13fc0:	4b1d      	ldr	r3, [pc, #116]	; (14038 <mem_manage_fault.isra.4+0x158>)
   13fc2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   13fc4:	07d8      	lsls	r0, r3, #31
   13fc6:	d510      	bpl.n	13fea <mem_manage_fault.isra.4+0x10a>
		PR_FAULT_INFO("  Instruction Access Violation");
   13fc8:	6823      	ldr	r3, [r4, #0]
   13fca:	0759      	lsls	r1, r3, #29
   13fcc:	d00d      	beq.n	13fea <mem_manage_fault.isra.4+0x10a>
   13fce:	2301      	movs	r3, #1
   13fd0:	f04f 0100 	mov.w	r1, #0
   13fd4:	f363 0107 	bfi	r1, r3, #0, #8
   13fd8:	4a14      	ldr	r2, [pc, #80]	; (1402c <mem_manage_fault.isra.4+0x14c>)
   13fda:	4b15      	ldr	r3, [pc, #84]	; (14030 <mem_manage_fault.isra.4+0x150>)
   13fdc:	481b      	ldr	r0, [pc, #108]	; (1404c <mem_manage_fault.isra.4+0x16c>)
   13fde:	1a9b      	subs	r3, r3, r2
   13fe0:	08db      	lsrs	r3, r3, #3
   13fe2:	f363 118f 	bfi	r1, r3, #6, #10
   13fe6:	f014 fca8 	bl	2893a <log_0>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   13fea:	4b13      	ldr	r3, [pc, #76]	; (14038 <mem_manage_fault.isra.4+0x158>)
   13fec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   13fee:	069a      	lsls	r2, r3, #26
   13ff0:	d510      	bpl.n	14014 <mem_manage_fault.isra.4+0x134>
		PR_FAULT_INFO(
   13ff2:	6823      	ldr	r3, [r4, #0]
   13ff4:	075b      	lsls	r3, r3, #29
   13ff6:	d00d      	beq.n	14014 <mem_manage_fault.isra.4+0x134>
   13ff8:	2301      	movs	r3, #1
   13ffa:	f04f 0100 	mov.w	r1, #0
   13ffe:	f363 0107 	bfi	r1, r3, #0, #8
   14002:	4a0a      	ldr	r2, [pc, #40]	; (1402c <mem_manage_fault.isra.4+0x14c>)
   14004:	4b0a      	ldr	r3, [pc, #40]	; (14030 <mem_manage_fault.isra.4+0x150>)
   14006:	4812      	ldr	r0, [pc, #72]	; (14050 <mem_manage_fault.isra.4+0x170>)
   14008:	1a9b      	subs	r3, r3, r2
   1400a:	08db      	lsrs	r3, r3, #3
   1400c:	f363 118f 	bfi	r1, r3, #6, #10
   14010:	f014 fc93 	bl	2893a <log_0>
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
   14014:	4b08      	ldr	r3, [pc, #32]	; (14038 <mem_manage_fault.isra.4+0x158>)
   14016:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
   14018:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
   1401a:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
   1401c:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
   14020:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
   14022:	7028      	strb	r0, [r5, #0]
}
   14024:	bd70      	pop	{r4, r5, r6, pc}
   14026:	bf00      	nop
   14028:	20010030 	.word	0x20010030
   1402c:	0002db28 	.word	0x0002db28
   14030:	0002dc58 	.word	0x0002dc58
   14034:	0003033d 	.word	0x0003033d
   14038:	e000ed00 	.word	0xe000ed00
   1403c:	00030353 	.word	0x00030353
   14040:	00030386 	.word	0x00030386
   14044:	00030399 	.word	0x00030399
   14048:	000303b1 	.word	0x000303b1
   1404c:	000303c7 	.word	0x000303c7
   14050:	000303e6 	.word	0x000303e6

00014054 <bus_fault.isra.5>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   14054:	b570      	push	{r4, r5, r6, lr}
	PR_FAULT_INFO("***** BUS FAULT *****");
   14056:	4c5a      	ldr	r4, [pc, #360]	; (141c0 <bus_fault.isra.5+0x16c>)
   14058:	6823      	ldr	r3, [r4, #0]
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   1405a:	460d      	mov	r5, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
   1405c:	0759      	lsls	r1, r3, #29
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   1405e:	4606      	mov	r6, r0
	PR_FAULT_INFO("***** BUS FAULT *****");
   14060:	d00d      	beq.n	1407e <bus_fault.isra.5+0x2a>
   14062:	2301      	movs	r3, #1
   14064:	f04f 0100 	mov.w	r1, #0
   14068:	f363 0107 	bfi	r1, r3, #0, #8
   1406c:	4a55      	ldr	r2, [pc, #340]	; (141c4 <bus_fault.isra.5+0x170>)
   1406e:	4b56      	ldr	r3, [pc, #344]	; (141c8 <bus_fault.isra.5+0x174>)
   14070:	4856      	ldr	r0, [pc, #344]	; (141cc <bus_fault.isra.5+0x178>)
   14072:	1a9b      	subs	r3, r3, r2
   14074:	08db      	lsrs	r3, r3, #3
   14076:	f363 118f 	bfi	r1, r3, #6, #10
   1407a:	f014 fc5e 	bl	2893a <log_0>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   1407e:	4b54      	ldr	r3, [pc, #336]	; (141d0 <bus_fault.isra.5+0x17c>)
   14080:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   14082:	04da      	lsls	r2, r3, #19
   14084:	d510      	bpl.n	140a8 <bus_fault.isra.5+0x54>
		PR_FAULT_INFO("  Stacking error");
   14086:	6823      	ldr	r3, [r4, #0]
   14088:	075b      	lsls	r3, r3, #29
   1408a:	d00d      	beq.n	140a8 <bus_fault.isra.5+0x54>
   1408c:	2301      	movs	r3, #1
   1408e:	f04f 0100 	mov.w	r1, #0
   14092:	f363 0107 	bfi	r1, r3, #0, #8
   14096:	4a4b      	ldr	r2, [pc, #300]	; (141c4 <bus_fault.isra.5+0x170>)
   14098:	4b4b      	ldr	r3, [pc, #300]	; (141c8 <bus_fault.isra.5+0x174>)
   1409a:	484e      	ldr	r0, [pc, #312]	; (141d4 <bus_fault.isra.5+0x180>)
   1409c:	1a9b      	subs	r3, r3, r2
   1409e:	08db      	lsrs	r3, r3, #3
   140a0:	f363 118f 	bfi	r1, r3, #6, #10
   140a4:	f014 fc49 	bl	2893a <log_0>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
   140a8:	4b49      	ldr	r3, [pc, #292]	; (141d0 <bus_fault.isra.5+0x17c>)
   140aa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   140ac:	0518      	lsls	r0, r3, #20
   140ae:	d510      	bpl.n	140d2 <bus_fault.isra.5+0x7e>
		PR_FAULT_INFO("  Unstacking error");
   140b0:	6823      	ldr	r3, [r4, #0]
   140b2:	0759      	lsls	r1, r3, #29
   140b4:	d00d      	beq.n	140d2 <bus_fault.isra.5+0x7e>
   140b6:	2301      	movs	r3, #1
   140b8:	f04f 0100 	mov.w	r1, #0
   140bc:	f363 0107 	bfi	r1, r3, #0, #8
   140c0:	4a40      	ldr	r2, [pc, #256]	; (141c4 <bus_fault.isra.5+0x170>)
   140c2:	4b41      	ldr	r3, [pc, #260]	; (141c8 <bus_fault.isra.5+0x174>)
   140c4:	4844      	ldr	r0, [pc, #272]	; (141d8 <bus_fault.isra.5+0x184>)
   140c6:	1a9b      	subs	r3, r3, r2
   140c8:	08db      	lsrs	r3, r3, #3
   140ca:	f363 118f 	bfi	r1, r3, #6, #10
   140ce:	f014 fc34 	bl	2893a <log_0>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   140d2:	4b3f      	ldr	r3, [pc, #252]	; (141d0 <bus_fault.isra.5+0x17c>)
   140d4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   140d6:	059a      	lsls	r2, r3, #22
   140d8:	d52c      	bpl.n	14134 <bus_fault.isra.5+0xe0>
		PR_FAULT_INFO("  Precise data bus error");
   140da:	6823      	ldr	r3, [r4, #0]
   140dc:	075b      	lsls	r3, r3, #29
   140de:	d00d      	beq.n	140fc <bus_fault.isra.5+0xa8>
   140e0:	2301      	movs	r3, #1
   140e2:	f04f 0100 	mov.w	r1, #0
   140e6:	f363 0107 	bfi	r1, r3, #0, #8
   140ea:	4a36      	ldr	r2, [pc, #216]	; (141c4 <bus_fault.isra.5+0x170>)
   140ec:	4b36      	ldr	r3, [pc, #216]	; (141c8 <bus_fault.isra.5+0x174>)
   140ee:	483b      	ldr	r0, [pc, #236]	; (141dc <bus_fault.isra.5+0x188>)
   140f0:	1a9b      	subs	r3, r3, r2
   140f2:	08db      	lsrs	r3, r3, #3
   140f4:	f363 118f 	bfi	r1, r3, #6, #10
   140f8:	f014 fc1f 	bl	2893a <log_0>
		STORE_xFAR(bfar, SCB->BFAR);
   140fc:	4b34      	ldr	r3, [pc, #208]	; (141d0 <bus_fault.isra.5+0x17c>)
   140fe:	6b99      	ldr	r1, [r3, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
   14100:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   14102:	0418      	lsls	r0, r3, #16
   14104:	d516      	bpl.n	14134 <bus_fault.isra.5+0xe0>
			PR_EXC("  BFAR Address: 0x%x", bfar);
   14106:	6823      	ldr	r3, [r4, #0]
   14108:	075a      	lsls	r2, r3, #29
   1410a:	d00d      	beq.n	14128 <bus_fault.isra.5+0xd4>
   1410c:	2301      	movs	r3, #1
   1410e:	f04f 0200 	mov.w	r2, #0
   14112:	f363 0207 	bfi	r2, r3, #0, #8
   14116:	482b      	ldr	r0, [pc, #172]	; (141c4 <bus_fault.isra.5+0x170>)
   14118:	4b2b      	ldr	r3, [pc, #172]	; (141c8 <bus_fault.isra.5+0x174>)
   1411a:	1a1b      	subs	r3, r3, r0
   1411c:	08db      	lsrs	r3, r3, #3
   1411e:	f363 128f 	bfi	r2, r3, #6, #10
   14122:	482f      	ldr	r0, [pc, #188]	; (141e0 <bus_fault.isra.5+0x18c>)
   14124:	f014 fc16 	bl	28954 <log_1>
			if (from_hard_fault) {
   14128:	b126      	cbz	r6, 14134 <bus_fault.isra.5+0xe0>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
   1412a:	4a29      	ldr	r2, [pc, #164]	; (141d0 <bus_fault.isra.5+0x17c>)
   1412c:	6a93      	ldr	r3, [r2, #40]	; 0x28
   1412e:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
   14132:	6293      	str	r3, [r2, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
   14134:	4b26      	ldr	r3, [pc, #152]	; (141d0 <bus_fault.isra.5+0x17c>)
   14136:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   14138:	055b      	lsls	r3, r3, #21
   1413a:	d510      	bpl.n	1415e <bus_fault.isra.5+0x10a>
		PR_FAULT_INFO("  Imprecise data bus error");
   1413c:	6823      	ldr	r3, [r4, #0]
   1413e:	075e      	lsls	r6, r3, #29
   14140:	d00d      	beq.n	1415e <bus_fault.isra.5+0x10a>
   14142:	2301      	movs	r3, #1
   14144:	f04f 0100 	mov.w	r1, #0
   14148:	f363 0107 	bfi	r1, r3, #0, #8
   1414c:	4a1d      	ldr	r2, [pc, #116]	; (141c4 <bus_fault.isra.5+0x170>)
   1414e:	4b1e      	ldr	r3, [pc, #120]	; (141c8 <bus_fault.isra.5+0x174>)
   14150:	4824      	ldr	r0, [pc, #144]	; (141e4 <bus_fault.isra.5+0x190>)
   14152:	1a9b      	subs	r3, r3, r2
   14154:	08db      	lsrs	r3, r3, #3
   14156:	f363 118f 	bfi	r1, r3, #6, #10
   1415a:	f014 fbee 	bl	2893a <log_0>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
   1415e:	4b1c      	ldr	r3, [pc, #112]	; (141d0 <bus_fault.isra.5+0x17c>)
   14160:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   14162:	05d0      	lsls	r0, r2, #23
   14164:	d518      	bpl.n	14198 <bus_fault.isra.5+0x144>
		PR_FAULT_INFO("  Instruction bus error");
   14166:	6823      	ldr	r3, [r4, #0]
   14168:	0759      	lsls	r1, r3, #29
   1416a:	d00d      	beq.n	14188 <bus_fault.isra.5+0x134>
   1416c:	2301      	movs	r3, #1
   1416e:	f04f 0100 	mov.w	r1, #0
   14172:	f363 0107 	bfi	r1, r3, #0, #8
   14176:	4a13      	ldr	r2, [pc, #76]	; (141c4 <bus_fault.isra.5+0x170>)
   14178:	4b13      	ldr	r3, [pc, #76]	; (141c8 <bus_fault.isra.5+0x174>)
   1417a:	481b      	ldr	r0, [pc, #108]	; (141e8 <bus_fault.isra.5+0x194>)
   1417c:	1a9b      	subs	r3, r3, r2
   1417e:	08db      	lsrs	r3, r3, #3
   14180:	f363 118f 	bfi	r1, r3, #6, #10
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   14184:	f014 fbd9 	bl	2893a <log_0>
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
   14188:	4a11      	ldr	r2, [pc, #68]	; (141d0 <bus_fault.isra.5+0x17c>)
   1418a:	6a93      	ldr	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
   1418c:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
   1418e:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
   14192:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
   14194:	7028      	strb	r0, [r5, #0]
}
   14196:	bd70      	pop	{r4, r5, r6, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
   14198:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1419a:	049a      	lsls	r2, r3, #18
   1419c:	d5f4      	bpl.n	14188 <bus_fault.isra.5+0x134>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   1419e:	6823      	ldr	r3, [r4, #0]
   141a0:	075b      	lsls	r3, r3, #29
   141a2:	d0f1      	beq.n	14188 <bus_fault.isra.5+0x134>
   141a4:	2301      	movs	r3, #1
   141a6:	f04f 0100 	mov.w	r1, #0
   141aa:	f363 0107 	bfi	r1, r3, #0, #8
   141ae:	4a05      	ldr	r2, [pc, #20]	; (141c4 <bus_fault.isra.5+0x170>)
   141b0:	4b05      	ldr	r3, [pc, #20]	; (141c8 <bus_fault.isra.5+0x174>)
   141b2:	480e      	ldr	r0, [pc, #56]	; (141ec <bus_fault.isra.5+0x198>)
   141b4:	1a9b      	subs	r3, r3, r2
   141b6:	08db      	lsrs	r3, r3, #3
   141b8:	f363 118f 	bfi	r1, r3, #6, #10
   141bc:	e7e2      	b.n	14184 <bus_fault.isra.5+0x130>
   141be:	bf00      	nop
   141c0:	20010030 	.word	0x20010030
   141c4:	0002db28 	.word	0x0002db28
   141c8:	0002dc58 	.word	0x0002dc58
   141cc:	000302b5 	.word	0x000302b5
   141d0:	e000ed00 	.word	0xe000ed00
   141d4:	000302cb 	.word	0x000302cb
   141d8:	00030386 	.word	0x00030386
   141dc:	000302dc 	.word	0x000302dc
   141e0:	000302f5 	.word	0x000302f5
   141e4:	0003030a 	.word	0x0003030a
   141e8:	00030325 	.word	0x00030325
   141ec:	000303e6 	.word	0x000303e6

000141f0 <z_arm_fault>:
 * @param psp PSP value immediately after the exception occurred
 * @param exc_return EXC_RETURN value present in LR after exception entry.
 *
 */
void z_arm_fault(u32_t msp, u32_t psp, u32_t exc_return)
{
   141f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   141f4:	4b77      	ldr	r3, [pc, #476]	; (143d4 <z_arm_fault+0x1e4>)
   141f6:	685f      	ldr	r7, [r3, #4]
{
   141f8:	b08a      	sub	sp, #40	; 0x28
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   141fa:	f3c7 0408 	ubfx	r4, r7, #0, #9
   141fe:	f04f 0800 	mov.w	r8, #0
   14202:	f388 8811 	msr	BASEPRI, r8
   14206:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
   1420a:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
   1420e:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
   14212:	d116      	bne.n	14242 <z_arm_fault+0x52>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
   14214:	f002 030c 	and.w	r3, r2, #12
   14218:	2b08      	cmp	r3, #8
   1421a:	d114      	bne.n	14246 <z_arm_fault+0x56>
		PR_EXC("SPSEL in thread mode does not indicate PSP");
   1421c:	4b6e      	ldr	r3, [pc, #440]	; (143d8 <z_arm_fault+0x1e8>)
   1421e:	681d      	ldr	r5, [r3, #0]
   14220:	f015 0507 	ands.w	r5, r5, #7
   14224:	d023      	beq.n	1426e <z_arm_fault+0x7e>
   14226:	2301      	movs	r3, #1
   14228:	f04f 0100 	mov.w	r1, #0
   1422c:	f363 0107 	bfi	r1, r3, #0, #8
   14230:	4a6a      	ldr	r2, [pc, #424]	; (143dc <z_arm_fault+0x1ec>)
   14232:	4b6b      	ldr	r3, [pc, #428]	; (143e0 <z_arm_fault+0x1f0>)
   14234:	486b      	ldr	r0, [pc, #428]	; (143e4 <z_arm_fault+0x1f4>)
   14236:	1a9b      	subs	r3, r3, r2
   14238:	08db      	lsrs	r3, r3, #3
   1423a:	f363 118f 	bfi	r1, r3, #6, #10
   1423e:	f014 fb7c 	bl	2893a <log_0>
		return NULL;
   14242:	4646      	mov	r6, r8
   14244:	e005      	b.n	14252 <z_arm_fault+0x62>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
   14246:	0715      	lsls	r5, r2, #28
			ptr_esf =  (z_arch_esf_t *)psp;
   14248:	bf4e      	itee	mi
   1424a:	460e      	movmi	r6, r1
			ptr_esf = (z_arch_esf_t *)msp;
   1424c:	4606      	movpl	r6, r0
			*nested_exc = true;
   1424e:	f04f 0801 	movpl.w	r8, #1
	*recoverable = false;
   14252:	2300      	movs	r3, #0
   14254:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
   14258:	1ee3      	subs	r3, r4, #3
   1425a:	2b09      	cmp	r3, #9
   1425c:	f200 809a 	bhi.w	14394 <z_arm_fault+0x1a4>
   14260:	e8df f003 	tbb	[pc, r3]
   14264:	79817d07 	.word	0x79817d07
   14268:	98989898 	.word	0x98989898
   1426c:	8598      	.short	0x8598
	*nested_exc = false;
   1426e:	46a8      	mov	r8, r5
   14270:	e7e7      	b.n	14242 <z_arm_fault+0x52>
	PR_FAULT_INFO("***** HARD FAULT *****");
   14272:	4f59      	ldr	r7, [pc, #356]	; (143d8 <z_arm_fault+0x1e8>)
   14274:	683b      	ldr	r3, [r7, #0]
   14276:	0759      	lsls	r1, r3, #29
   14278:	d00d      	beq.n	14296 <z_arm_fault+0xa6>
   1427a:	2301      	movs	r3, #1
   1427c:	f04f 0100 	mov.w	r1, #0
   14280:	f363 0107 	bfi	r1, r3, #0, #8
   14284:	4a55      	ldr	r2, [pc, #340]	; (143dc <z_arm_fault+0x1ec>)
   14286:	4b56      	ldr	r3, [pc, #344]	; (143e0 <z_arm_fault+0x1f0>)
   14288:	4857      	ldr	r0, [pc, #348]	; (143e8 <z_arm_fault+0x1f8>)
   1428a:	1a9b      	subs	r3, r3, r2
   1428c:	08db      	lsrs	r3, r3, #3
   1428e:	f363 118f 	bfi	r1, r3, #6, #10
   14292:	f014 fb52 	bl	2893a <log_0>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   14296:	4b4f      	ldr	r3, [pc, #316]	; (143d4 <z_arm_fault+0x1e4>)
   14298:	6ada      	ldr	r2, [r3, #44]	; 0x2c
	*recoverable = false;
   1429a:	2400      	movs	r4, #0
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   1429c:	0792      	lsls	r2, r2, #30
	*recoverable = false;
   1429e:	f88d 4007 	strb.w	r4, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   142a2:	d52d      	bpl.n	14300 <z_arm_fault+0x110>
		PR_EXC("  Bus fault on vector table read");
   142a4:	683b      	ldr	r3, [r7, #0]
   142a6:	075d      	lsls	r5, r3, #29
   142a8:	d101      	bne.n	142ae <z_arm_fault+0xbe>
	u32_t reason = K_ERR_CPU_EXCEPTION;
   142aa:	2400      	movs	r4, #0
   142ac:	e00d      	b.n	142ca <z_arm_fault+0xda>
		PR_EXC("  Bus fault on vector table read");
   142ae:	2301      	movs	r3, #1
   142b0:	f04f 0100 	mov.w	r1, #0
   142b4:	f363 0107 	bfi	r1, r3, #0, #8
   142b8:	4a48      	ldr	r2, [pc, #288]	; (143dc <z_arm_fault+0x1ec>)
   142ba:	4b49      	ldr	r3, [pc, #292]	; (143e0 <z_arm_fault+0x1f0>)
   142bc:	484b      	ldr	r0, [pc, #300]	; (143ec <z_arm_fault+0x1fc>)
   142be:	1a9b      	subs	r3, r3, r2
   142c0:	08db      	lsrs	r3, r3, #3
   142c2:	f363 118f 	bfi	r1, r3, #6, #10
   142c6:	f014 fb38 	bl	2893a <log_0>
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
		"ESF could not be retrieved successfully. Shall never occur.");

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
   142ca:	f89d 3007 	ldrb.w	r3, [sp, #7]
   142ce:	b9a3      	cbnz	r3, 142fa <z_arm_fault+0x10a>
		return;
	}

	/* Copy ESF */
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
   142d0:	2220      	movs	r2, #32
   142d2:	4631      	mov	r1, r6
   142d4:	a802      	add	r0, sp, #8
   142d6:	f016 f8ba 	bl	2a44e <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
   142da:	9b09      	ldr	r3, [sp, #36]	; 0x24
   142dc:	f1b8 0f00 	cmp.w	r8, #0
   142e0:	d073      	beq.n	143ca <z_arm_fault+0x1da>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
   142e2:	f3c3 0208 	ubfx	r2, r3, #0, #9
   142e6:	b922      	cbnz	r2, 142f2 <z_arm_fault+0x102>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
   142e8:	ea6f 2353 	mvn.w	r3, r3, lsr #9
   142ec:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   142f0:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
   142f2:	a902      	add	r1, sp, #8
   142f4:	4620      	mov	r0, r4
   142f6:	f7ff fc91 	bl	13c1c <z_arm_fatal_error>
}
   142fa:	b00a      	add	sp, #40	; 0x28
   142fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
   14300:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   14302:	0058      	lsls	r0, r3, #1
   14304:	d5d1      	bpl.n	142aa <z_arm_fault+0xba>
		PR_EXC("  Fault escalation (see below)");
   14306:	683b      	ldr	r3, [r7, #0]
   14308:	0759      	lsls	r1, r3, #29
   1430a:	d00d      	beq.n	14328 <z_arm_fault+0x138>
   1430c:	2301      	movs	r3, #1
   1430e:	f04f 0100 	mov.w	r1, #0
   14312:	f363 0107 	bfi	r1, r3, #0, #8
   14316:	4a31      	ldr	r2, [pc, #196]	; (143dc <z_arm_fault+0x1ec>)
   14318:	4b31      	ldr	r3, [pc, #196]	; (143e0 <z_arm_fault+0x1f0>)
   1431a:	4835      	ldr	r0, [pc, #212]	; (143f0 <z_arm_fault+0x200>)
   1431c:	1a9b      	subs	r3, r3, r2
   1431e:	08db      	lsrs	r3, r3, #3
   14320:	f363 118f 	bfi	r1, r3, #6, #10
   14324:	f014 fb09 	bl	2893a <log_0>
		if (SCB_MMFSR != 0) {
   14328:	4b32      	ldr	r3, [pc, #200]	; (143f4 <z_arm_fault+0x204>)
   1432a:	781b      	ldrb	r3, [r3, #0]
   1432c:	b12b      	cbz	r3, 1433a <z_arm_fault+0x14a>
			reason = mem_manage_fault(esf, 1, recoverable);
   1432e:	f10d 0107 	add.w	r1, sp, #7
   14332:	2001      	movs	r0, #1
		reason = mem_manage_fault(esf, 0, recoverable);
   14334:	f7ff fdd4 	bl	13ee0 <mem_manage_fault.isra.4>
   14338:	e00f      	b.n	1435a <z_arm_fault+0x16a>
		} else if (SCB_BFSR != 0) {
   1433a:	4b2f      	ldr	r3, [pc, #188]	; (143f8 <z_arm_fault+0x208>)
   1433c:	781b      	ldrb	r3, [r3, #0]
   1433e:	b12b      	cbz	r3, 1434c <z_arm_fault+0x15c>
			reason = bus_fault(esf, 1, recoverable);
   14340:	f10d 0107 	add.w	r1, sp, #7
   14344:	2001      	movs	r0, #1
		reason = bus_fault(esf, 0, recoverable);
   14346:	f7ff fe85 	bl	14054 <bus_fault.isra.5>
   1434a:	e006      	b.n	1435a <z_arm_fault+0x16a>
		} else if (SCB_UFSR != 0) {
   1434c:	4b2b      	ldr	r3, [pc, #172]	; (143fc <z_arm_fault+0x20c>)
   1434e:	881b      	ldrh	r3, [r3, #0]
   14350:	b29b      	uxth	r3, r3
   14352:	2b00      	cmp	r3, #0
   14354:	d0a9      	beq.n	142aa <z_arm_fault+0xba>
			reason = usage_fault(esf);
   14356:	f7ff fd13 	bl	13d80 <usage_fault.isra.2>
   1435a:	4604      	mov	r4, r0
   1435c:	e7b5      	b.n	142ca <z_arm_fault+0xda>
		reason = mem_manage_fault(esf, 0, recoverable);
   1435e:	f10d 0107 	add.w	r1, sp, #7
   14362:	2000      	movs	r0, #0
   14364:	e7e6      	b.n	14334 <z_arm_fault+0x144>
		reason = bus_fault(esf, 0, recoverable);
   14366:	f10d 0107 	add.w	r1, sp, #7
   1436a:	2000      	movs	r0, #0
   1436c:	e7eb      	b.n	14346 <z_arm_fault+0x156>
	PR_FAULT_INFO(
   1436e:	4b1a      	ldr	r3, [pc, #104]	; (143d8 <z_arm_fault+0x1e8>)
   14370:	681b      	ldr	r3, [r3, #0]
   14372:	075a      	lsls	r2, r3, #29
   14374:	d099      	beq.n	142aa <z_arm_fault+0xba>
   14376:	2301      	movs	r3, #1
   14378:	f04f 0100 	mov.w	r1, #0
   1437c:	f363 0107 	bfi	r1, r3, #0, #8
   14380:	4a16      	ldr	r2, [pc, #88]	; (143dc <z_arm_fault+0x1ec>)
   14382:	4b17      	ldr	r3, [pc, #92]	; (143e0 <z_arm_fault+0x1f0>)
   14384:	481e      	ldr	r0, [pc, #120]	; (14400 <z_arm_fault+0x210>)
   14386:	1a9b      	subs	r3, r3, r2
   14388:	08db      	lsrs	r3, r3, #3
   1438a:	f363 118f 	bfi	r1, r3, #6, #10
   1438e:	f014 fad4 	bl	2893a <log_0>
   14392:	e78a      	b.n	142aa <z_arm_fault+0xba>
	PR_FAULT_INFO("***** %s %d) *****",
   14394:	4b10      	ldr	r3, [pc, #64]	; (143d8 <z_arm_fault+0x1e8>)
   14396:	681b      	ldr	r3, [r3, #0]
   14398:	075b      	lsls	r3, r3, #29
   1439a:	d086      	beq.n	142aa <z_arm_fault+0xba>
   1439c:	2201      	movs	r2, #1
   1439e:	f04f 0300 	mov.w	r3, #0
   143a2:	f362 0307 	bfi	r3, r2, #0, #8
   143a6:	490e      	ldr	r1, [pc, #56]	; (143e0 <z_arm_fault+0x1f0>)
   143a8:	4a0c      	ldr	r2, [pc, #48]	; (143dc <z_arm_fault+0x1ec>)
   143aa:	4816      	ldr	r0, [pc, #88]	; (14404 <z_arm_fault+0x214>)
   143ac:	1a89      	subs	r1, r1, r2
   143ae:	08c9      	lsrs	r1, r1, #3
   143b0:	f417 7ff8 	tst.w	r7, #496	; 0x1f0
   143b4:	f361 138f 	bfi	r3, r1, #6, #10
   143b8:	f1a4 0210 	sub.w	r2, r4, #16
   143bc:	4912      	ldr	r1, [pc, #72]	; (14408 <z_arm_fault+0x218>)
   143be:	bf18      	it	ne
   143c0:	4601      	movne	r1, r0
   143c2:	4812      	ldr	r0, [pc, #72]	; (1440c <z_arm_fault+0x21c>)
   143c4:	f014 fada 	bl	2897c <log_2>
   143c8:	e76f      	b.n	142aa <z_arm_fault+0xba>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   143ca:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
   143ce:	f023 0301 	bic.w	r3, r3, #1
   143d2:	e78d      	b.n	142f0 <z_arm_fault+0x100>
   143d4:	e000ed00 	.word	0xe000ed00
   143d8:	20010030 	.word	0x20010030
   143dc:	0002db28 	.word	0x0002db28
   143e0:	0002dc58 	.word	0x0002dc58
   143e4:	000304e2 	.word	0x000304e2
   143e8:	0003050d 	.word	0x0003050d
   143ec:	00030524 	.word	0x00030524
   143f0:	00030545 	.word	0x00030545
   143f4:	e000ed28 	.word	0xe000ed28
   143f8:	e000ed29 	.word	0xe000ed29
   143fc:	e000ed2a 	.word	0xe000ed2a
   14400:	00030564 	.word	0x00030564
   14404:	000305af 	.word	0x000305af
   14408:	0003059a 	.word	0x0003059a
   1440c:	000305c8 	.word	0x000305c8

00014410 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
   14410:	4a02      	ldr	r2, [pc, #8]	; (1441c <z_arm_fault_init+0xc>)
   14412:	6953      	ldr	r3, [r2, #20]
   14414:	f043 0310 	orr.w	r3, r3, #16
   14418:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
   1441a:	4770      	bx	lr
   1441c:	e000ed00 	.word	0xe000ed00

00014420 <z_arm_int_lib_init>:
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   14420:	4804      	ldr	r0, [pc, #16]	; (14434 <z_arm_int_lib_init+0x14>)
 * @return N/A
 */

void z_arm_int_lib_init(void)
{
	int irq = 0;
   14422:	2300      	movs	r3, #0
   14424:	2120      	movs	r1, #32
   14426:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
   14428:	3301      	adds	r3, #1
   1442a:	2b30      	cmp	r3, #48	; 0x30
   1442c:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
   14430:	d1f9      	bne.n	14426 <z_arm_int_lib_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
   14432:	4770      	bx	lr
   14434:	e000e100 	.word	0xe000e100

00014438 <z_impl_k_thread_abort>:
#include <sys/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
   14438:	b538      	push	{r3, r4, r5, lr}
   1443a:	4605      	mov	r5, r0
	__asm__ volatile(
   1443c:	f04f 0320 	mov.w	r3, #32
   14440:	f3ef 8411 	mrs	r4, BASEPRI
   14444:	f383 8811 	msr	BASEPRI, r3
   14448:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
		 "essential thread aborted");

	z_thread_single_abort(thread);
   1444c:	f019 f803 	bl	2d456 <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
   14450:	4b0a      	ldr	r3, [pc, #40]	; (1447c <z_impl_k_thread_abort+0x44>)
   14452:	689b      	ldr	r3, [r3, #8]
   14454:	42ab      	cmp	r3, r5
   14456:	d10b      	bne.n	14470 <z_impl_k_thread_abort+0x38>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
   14458:	4b09      	ldr	r3, [pc, #36]	; (14480 <z_impl_k_thread_abort+0x48>)
   1445a:	685a      	ldr	r2, [r3, #4]
   1445c:	f3c2 0208 	ubfx	r2, r2, #0, #9
   14460:	b912      	cbnz	r2, 14468 <z_impl_k_thread_abort+0x30>
	z_check_stack_sentinel();

#ifndef CONFIG_ARM
	sys_trace_thread_switched_out();
#endif
	ret = arch_swap(key);
   14462:	4620      	mov	r0, r4
   14464:	f7ff fad8 	bl	13a18 <arch_swap>
			(void)z_swap_irqlock(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   14468:	685a      	ldr	r2, [r3, #4]
   1446a:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   1446e:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
   14470:	4620      	mov	r0, r4
}
   14472:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_irqlock(key);
   14476:	f018 bf18 	b.w	2d2aa <z_reschedule_irqlock>
   1447a:	bf00      	nop
   1447c:	20003b20 	.word	0x20003b20
   14480:	e000ed00 	.word	0xe000ed00

00014484 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
   14484:	b51f      	push	{r0, r1, r2, r3, r4, lr}
		.size = (u32_t)&_nocache_ram_size,
		.attr = K_MEM_PARTITION_P_RW_U_NA_NOCACHE,
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
   14486:	4b08      	ldr	r3, [pc, #32]	; (144a8 <z_arm_configure_static_mpu_regions+0x24>)
   14488:	9301      	str	r3, [sp, #4]
   1448a:	4b08      	ldr	r3, [pc, #32]	; (144ac <z_arm_configure_static_mpu_regions+0x28>)
   1448c:	9302      	str	r3, [sp, #8]
   1448e:	4b08      	ldr	r3, [pc, #32]	; (144b0 <z_arm_configure_static_mpu_regions+0x2c>)
   14490:	9303      	str	r3, [sp, #12]

	/* Define a constant array of k_mem_partition objects
	 * to hold the configuration of the respective static
	 * MPU regions.
	 */
	const struct k_mem_partition *static_regions[] = {
   14492:	ab01      	add	r3, sp, #4
   14494:	9300      	str	r3, [sp, #0]
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   14496:	4a07      	ldr	r2, [pc, #28]	; (144b4 <z_arm_configure_static_mpu_regions+0x30>)
   14498:	4b07      	ldr	r3, [pc, #28]	; (144b8 <z_arm_configure_static_mpu_regions+0x34>)
   1449a:	2101      	movs	r1, #1
   1449c:	4668      	mov	r0, sp
   1449e:	f000 f8c1 	bl	14624 <arm_core_mpu_configure_static_mpu_regions>
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
   144a2:	b005      	add	sp, #20
   144a4:	f85d fb04 	ldr.w	pc, [sp], #4
   144a8:	20000000 	.word	0x20000000
   144ac:	00000000 	.word	0x00000000
   144b0:	060b0000 	.word	0x060b0000
   144b4:	20000000 	.word	0x20000000
   144b8:	20040000 	.word	0x20040000

000144bc <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct k_mem_partition
	*regions[], u8_t regions_num, u8_t start_reg_index,
	bool do_sanity_check)
{
   144bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 */
static void region_init(const u32_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Select the region you want to access */
	MPU->RNR = index;
   144be:	4f33      	ldr	r7, [pc, #204]	; (1458c <mpu_configure_regions+0xd0>)
   144c0:	460e      	mov	r6, r1
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
   144c2:	2100      	movs	r1, #0
   144c4:	42b1      	cmp	r1, r6
   144c6:	da11      	bge.n	144ec <mpu_configure_regions+0x30>
		if (regions[i]->size == 0U) {
   144c8:	f850 c021 	ldr.w	ip, [r0, r1, lsl #2]
   144cc:	f8dc 4004 	ldr.w	r4, [ip, #4]
   144d0:	2c00      	cmp	r4, #0
   144d2:	d058      	beq.n	14586 <mpu_configure_regions+0xca>
			continue;
		}
		/* Non-empty region. */

		if (do_sanity_check &&
   144d4:	b19b      	cbz	r3, 144fe <mpu_configure_regions+0x42>
	 * and greater or equal to the minimum
	 * MPU region size. Start address of the
	 * partition must align with size.
	 */
	int partition_is_valid =
		((part->size & (part->size - 1)) == 0U)
   144d6:	f104 3eff 	add.w	lr, r4, #4294967295	; 0xffffffff
		&&
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
		&&
   144da:	ea14 0f0e 	tst.w	r4, lr
   144de:	d007      	beq.n	144f0 <mpu_configure_regions+0x34>
				(!mpu_partition_is_valid(regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
   144e0:	4b2b      	ldr	r3, [pc, #172]	; (14590 <mpu_configure_regions+0xd4>)
   144e2:	681b      	ldr	r3, [r3, #0]
   144e4:	075a      	lsls	r2, r3, #29
   144e6:	d130      	bne.n	1454a <mpu_configure_regions+0x8e>
			return -EINVAL;
		}

		reg_index = mpu_configure_region(reg_index, regions[i]);
   144e8:	f06f 0215 	mvn.w	r2, #21
		/* Increment number of programmed MPU indices. */
		reg_index++;
	}

	return reg_index;
}
   144ec:	4610      	mov	r0, r2
   144ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		&&
   144f0:	2c1f      	cmp	r4, #31
   144f2:	d9f5      	bls.n	144e0 <mpu_configure_regions+0x24>
		((part->start & (part->size - 1)) == 0U);
   144f4:	f8dc 5000 	ldr.w	r5, [ip]
		&&
   144f8:	ea1e 0f05 	tst.w	lr, r5
   144fc:	d1f0      	bne.n	144e0 <mpu_configure_regions+0x24>
 * to that power-of-two value.
 */
static inline u32_t size_to_mpu_rasr_size(u32_t size)
{
	/* The minimal supported region size is 32 bytes */
	if (size <= 32U) {
   144fe:	2c20      	cmp	r4, #32
		reg_index = mpu_configure_region(reg_index, regions[i]);
   14500:	b2d5      	uxtb	r5, r2
	region_conf.base = new_region->start;
   14502:	f8dc 2000 	ldr.w	r2, [ip]
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
   14506:	f8dc c008 	ldr.w	ip, [ip, #8]
   1450a:	d92d      	bls.n	14568 <mpu_configure_regions+0xac>
	/*
	 * A size value greater than 2^31 could not be handled by
	 * round_up_to_next_power_of_two() properly. We handle
	 * it separately here.
	 */
	if (size > (1UL << 31)) {
   1450c:	f1b4 4f00 	cmp.w	r4, #2147483648	; 0x80000000
   14510:	d82c      	bhi.n	1456c <mpu_configure_regions+0xb0>
		return REGION_4G;
	}

	return ((32 - __builtin_clz(size - 1) - 2 + 1) << MPU_RASR_SIZE_Pos) &
   14512:	3c01      	subs	r4, #1
   14514:	fab4 f484 	clz	r4, r4
   14518:	f1c4 041f 	rsb	r4, r4, #31
   1451c:	0064      	lsls	r4, r4, #1
	if (index > (get_num_regions() - 1)) {
   1451e:	2d07      	cmp	r5, #7
	/* in ARMv7-M MPU the base address is not required
	 * to determine region attributes
	 */
	(void) base;

	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
   14520:	ea4c 0404 	orr.w	r4, ip, r4
   14524:	d924      	bls.n	14570 <mpu_configure_regions+0xb4>
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
   14526:	4b1a      	ldr	r3, [pc, #104]	; (14590 <mpu_configure_regions+0xd4>)
   14528:	681b      	ldr	r3, [r3, #0]
   1452a:	075b      	lsls	r3, r3, #29
   1452c:	d0dc      	beq.n	144e8 <mpu_configure_regions+0x2c>
   1452e:	2301      	movs	r3, #1
   14530:	f04f 0200 	mov.w	r2, #0
   14534:	f363 0207 	bfi	r2, r3, #0, #8
   14538:	4916      	ldr	r1, [pc, #88]	; (14594 <mpu_configure_regions+0xd8>)
   1453a:	4b17      	ldr	r3, [pc, #92]	; (14598 <mpu_configure_regions+0xdc>)
   1453c:	4817      	ldr	r0, [pc, #92]	; (1459c <mpu_configure_regions+0xe0>)
   1453e:	1a5b      	subs	r3, r3, r1
   14540:	08db      	lsrs	r3, r3, #3
   14542:	f363 128f 	bfi	r2, r3, #6, #10
   14546:	4629      	mov	r1, r5
   14548:	e00b      	b.n	14562 <mpu_configure_regions+0xa6>
			LOG_ERR("Partition %u: sanity check failed.", i);
   1454a:	2301      	movs	r3, #1
   1454c:	f04f 0200 	mov.w	r2, #0
   14550:	f363 0207 	bfi	r2, r3, #0, #8
   14554:	480f      	ldr	r0, [pc, #60]	; (14594 <mpu_configure_regions+0xd8>)
   14556:	4b10      	ldr	r3, [pc, #64]	; (14598 <mpu_configure_regions+0xdc>)
   14558:	1a1b      	subs	r3, r3, r0
   1455a:	08db      	lsrs	r3, r3, #3
   1455c:	4810      	ldr	r0, [pc, #64]	; (145a0 <mpu_configure_regions+0xe4>)
   1455e:	f363 128f 	bfi	r2, r3, #6, #10
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
   14562:	f014 f9f7 	bl	28954 <log_1>
   14566:	e7bf      	b.n	144e8 <mpu_configure_regions+0x2c>
		return REGION_32B;
   14568:	2408      	movs	r4, #8
   1456a:	e7d8      	b.n	1451e <mpu_configure_regions+0x62>
		return REGION_4G;
   1456c:	243e      	movs	r4, #62	; 0x3e
   1456e:	e7d6      	b.n	1451e <mpu_configure_regions+0x62>
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
   14570:	f022 021f 	bic.w	r2, r2, #31
				| MPU_RBAR_VALID_Msk | index;
   14574:	432a      	orrs	r2, r5
   14576:	f042 0210 	orr.w	r2, r2, #16
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
   1457a:	f044 0401 	orr.w	r4, r4, #1
	MPU->RNR = index;
   1457e:	60bd      	str	r5, [r7, #8]
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
   14580:	60fa      	str	r2, [r7, #12]
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
   14582:	613c      	str	r4, [r7, #16]
		reg_index++;
   14584:	1c6a      	adds	r2, r5, #1
	for (i = 0; i < regions_num; i++) {
   14586:	3101      	adds	r1, #1
   14588:	e79c      	b.n	144c4 <mpu_configure_regions+0x8>
   1458a:	bf00      	nop
   1458c:	e000ed90 	.word	0xe000ed90
   14590:	20010028 	.word	0x20010028
   14594:	0002db28 	.word	0x0002db28
   14598:	0002dc48 	.word	0x0002dc48
   1459c:	00030602 	.word	0x00030602
   145a0:	000305df 	.word	0x000305df

000145a4 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
   145a4:	4b03      	ldr	r3, [pc, #12]	; (145b4 <arm_core_mpu_enable+0x10>)
   145a6:	2205      	movs	r2, #5
   145a8:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
   145aa:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   145ae:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
   145b2:	4770      	bx	lr
   145b4:	e000ed90 	.word	0xe000ed90

000145b8 <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
   145b8:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
   145bc:	4b01      	ldr	r3, [pc, #4]	; (145c4 <arm_core_mpu_disable+0xc>)
   145be:	2200      	movs	r2, #0
   145c0:	605a      	str	r2, [r3, #4]
}
   145c2:	4770      	bx	lr
   145c4:	e000ed90 	.word	0xe000ed90

000145c8 <arm_mpu_init>:
 */
static int arm_mpu_init(struct device *arg)
{
	u32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
   145c8:	4913      	ldr	r1, [pc, #76]	; (14618 <arm_mpu_init+0x50>)
   145ca:	6808      	ldr	r0, [r1, #0]
   145cc:	2808      	cmp	r0, #8
{
   145ce:	b510      	push	{r4, lr}
	if (mpu_config.num_regions > get_num_regions()) {
   145d0:	d81e      	bhi.n	14610 <arm_mpu_init+0x48>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
   145d2:	f7ff fff1 	bl	145b8 <arm_core_mpu_disable>
	MPU->RNR = index;
   145d6:	4c11      	ldr	r4, [pc, #68]	; (1461c <arm_mpu_init+0x54>)
   145d8:	6849      	ldr	r1, [r1, #4]

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   145da:	2200      	movs	r2, #0
   145dc:	4290      	cmp	r0, r2
   145de:	f101 010c 	add.w	r1, r1, #12
   145e2:	d105      	bne.n	145f0 <arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
   145e4:	4b0e      	ldr	r3, [pc, #56]	; (14620 <arm_mpu_init+0x58>)
   145e6:	7018      	strb	r0, [r3, #0]


	arm_core_mpu_enable();
   145e8:	f7ff ffdc 	bl	145a4 <arm_core_mpu_enable>
	__ASSERT(
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		DT_NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
   145ec:	2000      	movs	r0, #0
}
   145ee:	bd10      	pop	{r4, pc}
   145f0:	60a2      	str	r2, [r4, #8]
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
   145f2:	f851 3c0c 	ldr.w	r3, [r1, #-12]
   145f6:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
   145fa:	4313      	orrs	r3, r2
   145fc:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
   14600:	60e3      	str	r3, [r4, #12]
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
   14602:	f851 3c04 	ldr.w	r3, [r1, #-4]
   14606:	f043 0301 	orr.w	r3, r3, #1
   1460a:	6123      	str	r3, [r4, #16]
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   1460c:	3201      	adds	r2, #1
   1460e:	e7e5      	b.n	145dc <arm_mpu_init+0x14>
		return -1;
   14610:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14614:	e7eb      	b.n	145ee <arm_mpu_init+0x26>
   14616:	bf00      	nop
   14618:	0002e424 	.word	0x0002e424
   1461c:	e000ed90 	.word	0xe000ed90
   14620:	20003d62 	.word	0x20003d62

00014624 <arm_core_mpu_configure_static_mpu_regions>:
{
   14624:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const u8_t regions_num,
	const u32_t background_area_base,
	const u32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
   14626:	4c03      	ldr	r4, [pc, #12]	; (14634 <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
   14628:	2301      	movs	r3, #1
   1462a:	7822      	ldrb	r2, [r4, #0]
   1462c:	f7ff ff46 	bl	144bc <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
   14630:	7020      	strb	r0, [r4, #0]
}
   14632:	bd10      	pop	{r4, pc}
   14634:	20003d62 	.word	0x20003d62

00014638 <arm_core_mpu_configure_dynamic_mpu_regions>:
{
   14638:	b508      	push	{r3, lr}

	/* In ARMv7-M architecture the dynamic regions are
	 * programmed on top of existing SRAM region configuration.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
   1463a:	4a08      	ldr	r2, [pc, #32]	; (1465c <arm_core_mpu_configure_dynamic_mpu_regions+0x24>)
   1463c:	2300      	movs	r3, #0
   1463e:	7812      	ldrb	r2, [r2, #0]
   14640:	f7ff ff3c 	bl	144bc <mpu_configure_regions>
		regions_num, mpu_reg_index, false);

	if (mpu_reg_index != -EINVAL) {
   14644:	f110 0f16 	cmn.w	r0, #22
   14648:	d003      	beq.n	14652 <arm_core_mpu_configure_dynamic_mpu_regions+0x1a>
/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
   1464a:	4b05      	ldr	r3, [pc, #20]	; (14660 <arm_core_mpu_configure_dynamic_mpu_regions+0x28>)
  MPU->RASR = 0U;
   1464c:	2200      	movs	r2, #0

		/* Disable the non-programmed MPU regions. */
		for (int i = mpu_reg_index; i < get_num_regions(); i++) {
   1464e:	2807      	cmp	r0, #7
   14650:	dd00      	ble.n	14654 <arm_core_mpu_configure_dynamic_mpu_regions+0x1c>
}
   14652:	bd08      	pop	{r3, pc}
  MPU->RNR = rnr;
   14654:	6098      	str	r0, [r3, #8]
  MPU->RASR = 0U;
   14656:	611a      	str	r2, [r3, #16]
   14658:	3001      	adds	r0, #1
   1465a:	e7f8      	b.n	1464e <arm_core_mpu_configure_dynamic_mpu_regions+0x16>
   1465c:	20003d62 	.word	0x20003d62
   14660:	e000ed90 	.word	0xe000ed90

00014664 <z_prf>:
	*sptr = p;
	return i;
}

int z_prf(int (*func)(), void *dest, const char *format, va_list vargs)
{
   14664:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14668:	b09f      	sub	sp, #124	; 0x7c
   1466a:	461e      	mov	r6, r3
	struct zero_padding zero;
	VALTYPE val;

#define PUTC(c)	do { if ((*func)(c, dest) == EOF) return EOF; } while (false)

	count = 0;
   1466c:	2300      	movs	r3, #0
{
   1466e:	9001      	str	r0, [sp, #4]
   14670:	9104      	str	r1, [sp, #16]
	count = 0;
   14672:	9300      	str	r3, [sp, #0]

	while ((c = *format++)) {
   14674:	4613      	mov	r3, r2
   14676:	f813 0b01 	ldrb.w	r0, [r3], #1
   1467a:	9305      	str	r3, [sp, #20]
   1467c:	b158      	cbz	r0, 14696 <z_prf+0x32>
		if (c != '%') {
   1467e:	2825      	cmp	r0, #37	; 0x25
   14680:	f000 8085 	beq.w	1478e <z_prf+0x12a>
			PUTC(c);
   14684:	9904      	ldr	r1, [sp, #16]
   14686:	9b01      	ldr	r3, [sp, #4]
   14688:	4798      	blx	r3
   1468a:	3001      	adds	r0, #1
   1468c:	f040 840d 	bne.w	14eaa <z_prf+0x846>
   14690:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   14694:	9300      	str	r3, [sp, #0]
		}
	}
	return count;

#undef PUTC
}
   14696:	9800      	ldr	r0, [sp, #0]
   14698:	b01f      	add	sp, #124	; 0x7c
   1469a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				switch (c) {
   1469e:	2c23      	cmp	r4, #35	; 0x23
   146a0:	d06c      	beq.n	1477c <z_prf+0x118>
   146a2:	d861      	bhi.n	14768 <z_prf+0x104>
   146a4:	2c00      	cmp	r4, #0
   146a6:	d0f6      	beq.n	14696 <z_prf+0x32>
					fspace = true;
   146a8:	2c20      	cmp	r4, #32
   146aa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   146ac:	bf08      	it	eq
   146ae:	2301      	moveq	r3, #1
   146b0:	930a      	str	r3, [sp, #40]	; 0x28
					fminus = true;
   146b2:	f8cd 8014 	str.w	r8, [sp, #20]
			while (strchr("-+ #0", (c = *format++)) != NULL) {
   146b6:	f8dd 8014 	ldr.w	r8, [sp, #20]
   146ba:	48b9      	ldr	r0, [pc, #740]	; (149a0 <z_prf+0x33c>)
   146bc:	f818 4b01 	ldrb.w	r4, [r8], #1
   146c0:	4621      	mov	r1, r4
   146c2:	f015 fe6d 	bl	2a3a0 <strchr>
   146c6:	2800      	cmp	r0, #0
   146c8:	d1e9      	bne.n	1469e <z_prf+0x3a>
			if (c == '*') {
   146ca:	2c2a      	cmp	r4, #42	; 0x2a
   146cc:	d166      	bne.n	1479c <z_prf+0x138>
				width = va_arg(vargs, int);
   146ce:	f856 3b04 	ldr.w	r3, [r6], #4
   146d2:	9307      	str	r3, [sp, #28]
				if (width < 0) {
   146d4:	2b00      	cmp	r3, #0
					width = -width;
   146d6:	bfbf      	itttt	lt
   146d8:	425b      	neglt	r3, r3
   146da:	9307      	strlt	r3, [sp, #28]
					fminus = true;
   146dc:	2301      	movlt	r3, #1
   146de:	930b      	strlt	r3, [sp, #44]	; 0x2c
				c = *format++;
   146e0:	9b05      	ldr	r3, [sp, #20]
   146e2:	f898 4000 	ldrb.w	r4, [r8]
   146e6:	f103 0802 	add.w	r8, r3, #2
			if (c == '.') {
   146ea:	2c2e      	cmp	r4, #46	; 0x2e
   146ec:	d17c      	bne.n	147e8 <z_prf+0x184>
				if (c == '*') {
   146ee:	f898 3000 	ldrb.w	r3, [r8]
   146f2:	2b2a      	cmp	r3, #42	; 0x2a
   146f4:	d175      	bne.n	147e2 <z_prf+0x17e>
					precision = va_arg(vargs, int);
   146f6:	f856 5b04 	ldr.w	r5, [r6], #4
				c = *format++;
   146fa:	f108 0801 	add.w	r8, r8, #1
				c = *format++;
   146fe:	f818 4b01 	ldrb.w	r4, [r8], #1
			if (strchr("hlz", c) != NULL) {
   14702:	48a8      	ldr	r0, [pc, #672]	; (149a4 <z_prf+0x340>)
   14704:	4621      	mov	r1, r4
   14706:	4627      	mov	r7, r4
   14708:	f015 fe4a 	bl	2a3a0 <strchr>
   1470c:	2800      	cmp	r0, #0
   1470e:	d06e      	beq.n	147ee <z_prf+0x18a>
				c = *format++;
   14710:	4643      	mov	r3, r8
				} else if (i == 'h' && c == 'h') {
   14712:	2f68      	cmp	r7, #104	; 0x68
				c = *format++;
   14714:	f813 4b01 	ldrb.w	r4, [r3], #1
   14718:	9305      	str	r3, [sp, #20]
				} else if (i == 'h' && c == 'h') {
   1471a:	d107      	bne.n	1472c <z_prf+0xc8>
   1471c:	2c68      	cmp	r4, #104	; 0x68
   1471e:	d105      	bne.n	1472c <z_prf+0xc8>
					c = *format++;
   14720:	f108 0302 	add.w	r3, r8, #2
   14724:	f898 4001 	ldrb.w	r4, [r8, #1]
   14728:	9305      	str	r3, [sp, #20]
					i = 'H';
   1472a:	2748      	movs	r7, #72	; 0x48
			switch (c) {
   1472c:	2c67      	cmp	r4, #103	; 0x67
   1472e:	d87c      	bhi.n	1482a <z_prf+0x1c6>
   14730:	2c65      	cmp	r4, #101	; 0x65
   14732:	f080 8139 	bcs.w	149a8 <z_prf+0x344>
   14736:	2c47      	cmp	r4, #71	; 0x47
   14738:	d85d      	bhi.n	147f6 <z_prf+0x192>
   1473a:	2c45      	cmp	r4, #69	; 0x45
   1473c:	f080 8134 	bcs.w	149a8 <z_prf+0x344>
   14740:	2c00      	cmp	r4, #0
   14742:	d0a8      	beq.n	14696 <z_prf+0x32>
   14744:	2c25      	cmp	r4, #37	; 0x25
   14746:	f000 83ac 	beq.w	14ea2 <z_prf+0x83e>
				PUTC('%');
   1474a:	9904      	ldr	r1, [sp, #16]
   1474c:	9b01      	ldr	r3, [sp, #4]
   1474e:	2025      	movs	r0, #37	; 0x25
   14750:	4798      	blx	r3
   14752:	3001      	adds	r0, #1
   14754:	d09c      	beq.n	14690 <z_prf+0x2c>
				PUTC(c);
   14756:	9904      	ldr	r1, [sp, #16]
   14758:	9b01      	ldr	r3, [sp, #4]
   1475a:	4620      	mov	r0, r4
   1475c:	4798      	blx	r3
   1475e:	3001      	adds	r0, #1
   14760:	d096      	beq.n	14690 <z_prf+0x2c>
				count += 2;
   14762:	9b00      	ldr	r3, [sp, #0]
   14764:	3302      	adds	r3, #2
   14766:	e3a2      	b.n	14eae <z_prf+0x84a>
				switch (c) {
   14768:	2c2d      	cmp	r4, #45	; 0x2d
   1476a:	d00a      	beq.n	14782 <z_prf+0x11e>
   1476c:	2c30      	cmp	r4, #48	; 0x30
   1476e:	d00b      	beq.n	14788 <z_prf+0x124>
					fplus = true;
   14770:	2c2b      	cmp	r4, #43	; 0x2b
   14772:	9b09      	ldr	r3, [sp, #36]	; 0x24
   14774:	bf08      	it	eq
   14776:	2301      	moveq	r3, #1
   14778:	9309      	str	r3, [sp, #36]	; 0x24
   1477a:	e79a      	b.n	146b2 <z_prf+0x4e>
					falt = true;
   1477c:	2301      	movs	r3, #1
   1477e:	9306      	str	r3, [sp, #24]
   14780:	e797      	b.n	146b2 <z_prf+0x4e>
					fminus = true;
   14782:	2301      	movs	r3, #1
   14784:	930b      	str	r3, [sp, #44]	; 0x2c
   14786:	e794      	b.n	146b2 <z_prf+0x4e>
					fzero = true;
   14788:	2301      	movs	r3, #1
   1478a:	9308      	str	r3, [sp, #32]
   1478c:	e791      	b.n	146b2 <z_prf+0x4e>
			fminus = fplus = fspace = falt = fzero = false;
   1478e:	2300      	movs	r3, #0
   14790:	9308      	str	r3, [sp, #32]
   14792:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
   14796:	930b      	str	r3, [sp, #44]	; 0x2c
   14798:	9306      	str	r3, [sp, #24]
   1479a:	e78c      	b.n	146b6 <z_prf+0x52>
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   1479c:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
			} else if (!isdigit(c)) {
   147a0:	2b09      	cmp	r3, #9
				width = 0;
   147a2:	9007      	str	r0, [sp, #28]
			} else if (!isdigit(c)) {
   147a4:	d8a1      	bhi.n	146ea <z_prf+0x86>
		i = 10 * i + *p++ - '0';
   147a6:	220a      	movs	r2, #10
	while (isdigit(*p)) {
   147a8:	f8dd 8014 	ldr.w	r8, [sp, #20]
   147ac:	f818 4b01 	ldrb.w	r4, [r8], #1
   147b0:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
   147b4:	2b09      	cmp	r3, #9
   147b6:	d898      	bhi.n	146ea <z_prf+0x86>
		i = 10 * i + *p++ - '0';
   147b8:	9b07      	ldr	r3, [sp, #28]
   147ba:	f8cd 8014 	str.w	r8, [sp, #20]
   147be:	fb02 4403 	mla	r4, r2, r3, r4
   147c2:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
   147c6:	9307      	str	r3, [sp, #28]
   147c8:	e7ee      	b.n	147a8 <z_prf+0x144>
   147ca:	fb01 3505 	mla	r5, r1, r5, r3
   147ce:	3d30      	subs	r5, #48	; 0x30
   147d0:	4690      	mov	r8, r2
	while (isdigit(*p)) {
   147d2:	4642      	mov	r2, r8
   147d4:	f812 3b01 	ldrb.w	r3, [r2], #1
   147d8:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
   147dc:	2809      	cmp	r0, #9
   147de:	d9f4      	bls.n	147ca <z_prf+0x166>
   147e0:	e78d      	b.n	146fe <z_prf+0x9a>
	int i = 0;
   147e2:	2500      	movs	r5, #0
		i = 10 * i + *p++ - '0';
   147e4:	210a      	movs	r1, #10
   147e6:	e7f4      	b.n	147d2 <z_prf+0x16e>
			precision = -1;
   147e8:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   147ec:	e789      	b.n	14702 <z_prf+0x9e>
   147ee:	f8cd 8014 	str.w	r8, [sp, #20]
			i = 0;
   147f2:	4607      	mov	r7, r0
   147f4:	e79a      	b.n	1472c <z_prf+0xc8>
			switch (c) {
   147f6:	2c63      	cmp	r4, #99	; 0x63
   147f8:	d05a      	beq.n	148b0 <z_prf+0x24c>
   147fa:	d820      	bhi.n	1483e <z_prf+0x1da>
   147fc:	2c58      	cmp	r4, #88	; 0x58
   147fe:	d1a4      	bne.n	1474a <z_prf+0xe6>
				if (c == 'o') {
   14800:	2c6f      	cmp	r4, #111	; 0x6f
   14802:	f106 0904 	add.w	r9, r6, #4
   14806:	6831      	ldr	r1, [r6, #0]
   14808:	f040 831c 	bne.w	14e44 <z_prf+0x7e0>
	if (alt_form) {
   1480c:	9b06      	ldr	r3, [sp, #24]
   1480e:	2b00      	cmp	r3, #0
   14810:	f000 830a 	beq.w	14e28 <z_prf+0x7c4>
		*buf++ = '0';
   14814:	2330      	movs	r3, #48	; 0x30
   14816:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
		if (!value) {
   1481a:	2900      	cmp	r1, #0
   1481c:	f040 830f 	bne.w	14e3e <z_prf+0x7da>
			*buf++ = 0;
   14820:	f88d 105d 	strb.w	r1, [sp, #93]	; 0x5d
			prefix = 0;
   14824:	4688      	mov	r8, r1
			return 1;
   14826:	2601      	movs	r6, #1
   14828:	e026      	b.n	14878 <z_prf+0x214>
			switch (c) {
   1482a:	2c70      	cmp	r4, #112	; 0x70
   1482c:	f000 82e7 	beq.w	14dfe <z_prf+0x79a>
   14830:	d828      	bhi.n	14884 <z_prf+0x220>
   14832:	2c6e      	cmp	r4, #110	; 0x6e
   14834:	f000 82d0 	beq.w	14dd8 <z_prf+0x774>
   14838:	d8e2      	bhi.n	14800 <z_prf+0x19c>
   1483a:	2c69      	cmp	r4, #105	; 0x69
   1483c:	d185      	bne.n	1474a <z_prf+0xe6>
				switch (i) {
   1483e:	6834      	ldr	r4, [r6, #0]
	if (value < 0) {
   14840:	2c00      	cmp	r4, #0
   14842:	f106 0904 	add.w	r9, r6, #4
   14846:	f280 809c 	bge.w	14982 <z_prf+0x31e>
		*buf++ = '-';
   1484a:	232d      	movs	r3, #45	; 0x2d
   1484c:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
		value = -value;
   14850:	4261      	negs	r1, r4
		*buf++ = ' ';
   14852:	f10d 065d 	add.w	r6, sp, #93	; 0x5d
	return _to_x(buf, value, 10);
   14856:	4630      	mov	r0, r6
   14858:	220a      	movs	r2, #10
   1485a:	f015 fe44 	bl	2a4e6 <_to_x>
				if (fplus || fspace || val < 0) {
   1485e:	9b09      	ldr	r3, [sp, #36]	; 0x24
	return (buf + _to_udec(buf, value)) - start;
   14860:	4406      	add	r6, r0
   14862:	a817      	add	r0, sp, #92	; 0x5c
   14864:	1a36      	subs	r6, r6, r0
				if (fplus || fspace || val < 0) {
   14866:	2b00      	cmp	r3, #0
   14868:	f040 8324 	bne.w	14eb4 <z_prf+0x850>
   1486c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1486e:	2b00      	cmp	r3, #0
   14870:	f040 8320 	bne.w	14eb4 <z_prf+0x850>
   14874:	ea4f 78d4 	mov.w	r8, r4, lsr #31
			if (precision >= 0) {
   14878:	2d00      	cmp	r5, #0
   1487a:	da22      	bge.n	148c2 <z_prf+0x25e>
			zero.predot = zero.postdot = zero.trail = 0;
   1487c:	2500      	movs	r5, #0
   1487e:	462f      	mov	r7, r5
   14880:	46aa      	mov	sl, r5
   14882:	e0e5      	b.n	14a50 <z_prf+0x3ec>
			switch (c) {
   14884:	2c75      	cmp	r4, #117	; 0x75
   14886:	d0bb      	beq.n	14800 <z_prf+0x19c>
   14888:	2c78      	cmp	r4, #120	; 0x78
   1488a:	d0b9      	beq.n	14800 <z_prf+0x19c>
   1488c:	2c73      	cmp	r4, #115	; 0x73
   1488e:	f47f af5c 	bne.w	1474a <z_prf+0xe6>
				cptr = va_arg(vargs, char *);
   14892:	46b1      	mov	r9, r6
					precision = INT_MAX;
   14894:	2d00      	cmp	r5, #0
				cptr = va_arg(vargs, char *);
   14896:	f859 3b04 	ldr.w	r3, [r9], #4
					precision = INT_MAX;
   1489a:	bfb8      	it	lt
   1489c:	f06f 4500 	mvnlt.w	r5, #2147483648	; 0x80000000
				for (clen = 0; clen < precision; clen++) {
   148a0:	2600      	movs	r6, #0
   148a2:	42b5      	cmp	r5, r6
   148a4:	f040 82bb 	bne.w	14e1e <z_prf+0x7ba>
   148a8:	462e      	mov	r6, r5
   148aa:	2500      	movs	r5, #0
   148ac:	46a8      	mov	r8, r5
   148ae:	e009      	b.n	148c4 <z_prf+0x260>
				buf[0] = va_arg(vargs, int);
   148b0:	46b1      	mov	r9, r6
				break;
   148b2:	f04f 0800 	mov.w	r8, #0
				buf[0] = va_arg(vargs, int);
   148b6:	f859 3b04 	ldr.w	r3, [r9], #4
   148ba:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
				clen = 1;
   148be:	2601      	movs	r6, #1
				break;
   148c0:	4645      	mov	r5, r8
   148c2:	ab17      	add	r3, sp, #92	; 0x5c
				zero_head = precision - clen + prefix;
   148c4:	eb05 0208 	add.w	r2, r5, r8
			zero.predot = zero.postdot = zero.trail = 0;
   148c8:	2500      	movs	r5, #0
				zero_head = precision - clen + prefix;
   148ca:	1b92      	subs	r2, r2, r6
			zero.predot = zero.postdot = zero.trail = 0;
   148cc:	462f      	mov	r7, r5
   148ce:	46aa      	mov	sl, r5
			if (zero_head < 0) {
   148d0:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
			width -= clen + zero_head;
   148d4:	1991      	adds	r1, r2, r6
   148d6:	9106      	str	r1, [sp, #24]
   148d8:	9907      	ldr	r1, [sp, #28]
   148da:	1990      	adds	r0, r2, r6
   148dc:	1a0c      	subs	r4, r1, r0
			if (!fminus && width > 0) {
   148de:	990b      	ldr	r1, [sp, #44]	; 0x2c
   148e0:	b911      	cbnz	r1, 148e8 <z_prf+0x284>
   148e2:	2c00      	cmp	r4, #0
   148e4:	f300 8304 	bgt.w	14ef0 <z_prf+0x88c>
			while (prefix-- > 0) {
   148e8:	eb03 0b08 	add.w	fp, r3, r8
   148ec:	455b      	cmp	r3, fp
   148ee:	f040 8301 	bne.w	14ef4 <z_prf+0x890>
			while (zero_head-- > 0) {
   148f2:	f112 32ff 	adds.w	r2, r2, #4294967295	; 0xffffffff
   148f6:	f080 830d 	bcs.w	14f14 <z_prf+0x8b0>
			clen -= prefix;
   148fa:	eba6 0608 	sub.w	r6, r6, r8
			if (zero.predot) {
   148fe:	f1ba 0f00 	cmp.w	sl, #0
   14902:	d011      	beq.n	14928 <z_prf+0x2c4>
				c = *cptr;
   14904:	f89b 0000 	ldrb.w	r0, [fp]
				while (isdigit(c)) {
   14908:	eb0b 0806 	add.w	r8, fp, r6
   1490c:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
   14910:	2b09      	cmp	r3, #9
   14912:	eba8 060b 	sub.w	r6, r8, fp
   14916:	f240 8308 	bls.w	14f2a <z_prf+0x8c6>
   1491a:	46d0      	mov	r8, sl
				while (zero.predot-- > 0) {
   1491c:	f118 38ff 	adds.w	r8, r8, #4294967295	; 0xffffffff
   14920:	f080 830c 	bcs.w	14f3c <z_prf+0x8d8>
				clen -= zero.predot;
   14924:	eba6 060a 	sub.w	r6, r6, sl
			if (zero.postdot) {
   14928:	b1af      	cbz	r7, 14956 <z_prf+0x2f2>
   1492a:	eb0b 0806 	add.w	r8, fp, r6
					c = *cptr++;
   1492e:	f81b ab01 	ldrb.w	sl, [fp], #1
					PUTC(c);
   14932:	9904      	ldr	r1, [sp, #16]
   14934:	9b01      	ldr	r3, [sp, #4]
   14936:	4650      	mov	r0, sl
   14938:	4798      	blx	r3
   1493a:	3001      	adds	r0, #1
   1493c:	f43f aea8 	beq.w	14690 <z_prf+0x2c>
				} while (c != '.');
   14940:	f1ba 0f2e 	cmp.w	sl, #46	; 0x2e
   14944:	eba8 060b 	sub.w	r6, r8, fp
   14948:	d1f1      	bne.n	1492e <z_prf+0x2ca>
				while (zero.postdot-- > 0) {
   1494a:	46b8      	mov	r8, r7
   1494c:	f1b8 0f00 	cmp.w	r8, #0
   14950:	f300 82fd 	bgt.w	14f4e <z_prf+0x8ea>
				clen -= zero.postdot;
   14954:	1bf6      	subs	r6, r6, r7
			if (zero.trail) {
   14956:	b195      	cbz	r5, 1497e <z_prf+0x31a>
				c = *cptr;
   14958:	f89b 0000 	ldrb.w	r0, [fp]
				while (isdigit(c) || c == '.') {
   1495c:	eb0b 0806 	add.w	r8, fp, r6
   14960:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
   14964:	2b09      	cmp	r3, #9
   14966:	eba8 060b 	sub.w	r6, r8, fp
   1496a:	f240 82fb 	bls.w	14f64 <z_prf+0x900>
   1496e:	282e      	cmp	r0, #46	; 0x2e
   14970:	f000 82f8 	beq.w	14f64 <z_prf+0x900>
				while (zero.trail-- > 0) {
   14974:	462f      	mov	r7, r5
   14976:	2f00      	cmp	r7, #0
   14978:	f300 82fd 	bgt.w	14f76 <z_prf+0x912>
				clen -= zero.trail;
   1497c:	1b76      	subs	r6, r6, r5
   1497e:	445e      	add	r6, fp
   14980:	e30c      	b.n	14f9c <z_prf+0x938>
	} else if (fplus) {
   14982:	9b09      	ldr	r3, [sp, #36]	; 0x24
   14984:	b123      	cbz	r3, 14990 <z_prf+0x32c>
		*buf++ = '+';
   14986:	232b      	movs	r3, #43	; 0x2b
		*buf++ = ' ';
   14988:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
   1498c:	4621      	mov	r1, r4
   1498e:	e760      	b.n	14852 <z_prf+0x1ee>
	} else if (fspace) {
   14990:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   14992:	b10b      	cbz	r3, 14998 <z_prf+0x334>
		*buf++ = ' ';
   14994:	2320      	movs	r3, #32
   14996:	e7f7      	b.n	14988 <z_prf+0x324>
	} else if (fspace) {
   14998:	4621      	mov	r1, r4
   1499a:	ae17      	add	r6, sp, #92	; 0x5c
   1499c:	e75b      	b.n	14856 <z_prf+0x1f2>
   1499e:	bf00      	nop
   149a0:	00030628 	.word	0x00030628
   149a4:	0003062e 	.word	0x0003062e
				u.d = va_arg(vargs, double);
   149a8:	f106 0907 	add.w	r9, r6, #7
   149ac:	f029 0907 	bic.w	r9, r9, #7
   149b0:	e8f9 2302 	ldrd	r2, r3, [r9], #8
	fract = (double_temp << 11) & ~HIGHBIT64;
   149b4:	02d8      	lsls	r0, r3, #11
   149b6:	ea40 5052 	orr.w	r0, r0, r2, lsr #21
   149ba:	02d6      	lsls	r6, r2, #11
   149bc:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
   149c0:	9602      	str	r6, [sp, #8]
   149c2:	9003      	str	r0, [sp, #12]
   149c4:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
	if (sign) {
   149c8:	2a00      	cmp	r2, #0
	exp = double_temp >> 52 & 0x7ff;
   149ca:	f3c3 510a 	ubfx	r1, r3, #20, #11
	if (sign) {
   149ce:	f173 0300 	sbcs.w	r3, r3, #0
	fract = (double_temp << 11) & ~HIGHBIT64;
   149d2:	e9cd 6712 	strd	r6, r7, [sp, #72]	; 0x48
	if (sign) {
   149d6:	da43      	bge.n	14a60 <z_prf+0x3fc>
		*buf++ = '-';
   149d8:	232d      	movs	r3, #45	; 0x2d
		*buf++ = ' ';
   149da:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
   149de:	f10d 075d 	add.w	r7, sp, #93	; 0x5d
	if (exp == 0x7ff) {
   149e2:	f240 73ff 	movw	r3, #2047	; 0x7ff
   149e6:	4299      	cmp	r1, r3
   149e8:	d155      	bne.n	14a96 <z_prf+0x432>
		if (!fract) {
   149ea:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   149ee:	4313      	orrs	r3, r2
   149f0:	f1a4 0441 	sub.w	r4, r4, #65	; 0x41
   149f4:	f107 0b03 	add.w	fp, r7, #3
   149f8:	d142      	bne.n	14a80 <z_prf+0x41c>
			if (isupper(c)) {
   149fa:	2c19      	cmp	r4, #25
   149fc:	d83a      	bhi.n	14a74 <z_prf+0x410>
				*buf++ = 'I';
   149fe:	2349      	movs	r3, #73	; 0x49
   14a00:	703b      	strb	r3, [r7, #0]
				*buf++ = 'N';
   14a02:	234e      	movs	r3, #78	; 0x4e
   14a04:	707b      	strb	r3, [r7, #1]
				*buf++ = 'F';
   14a06:	2346      	movs	r3, #70	; 0x46
		*buf = 0;
   14a08:	2500      	movs	r5, #0
		return buf - start;
   14a0a:	ae17      	add	r6, sp, #92	; 0x5c
				*buf++ = 'n';
   14a0c:	70bb      	strb	r3, [r7, #2]
		*buf = 0;
   14a0e:	70fd      	strb	r5, [r7, #3]
		return buf - start;
   14a10:	ebab 0b06 	sub.w	fp, fp, r6
			zero.predot = zero.postdot = zero.trail = 0;
   14a14:	462f      	mov	r7, r5
   14a16:	46aa      	mov	sl, r5
				if (fplus || fspace || (buf[0] == '-')) {
   14a18:	9b09      	ldr	r3, [sp, #36]	; 0x24
   14a1a:	2b00      	cmp	r3, #0
   14a1c:	f040 81d9 	bne.w	14dd2 <z_prf+0x76e>
   14a20:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   14a22:	2b00      	cmp	r3, #0
   14a24:	f040 81d5 	bne.w	14dd2 <z_prf+0x76e>
   14a28:	f89d 805c 	ldrb.w	r8, [sp, #92]	; 0x5c
   14a2c:	f1a8 032d 	sub.w	r3, r8, #45	; 0x2d
   14a30:	f1d3 0800 	rsbs	r8, r3, #0
   14a34:	eb48 0803 	adc.w	r8, r8, r3
				if (!isdigit(buf[prefix])) {
   14a38:	ab1e      	add	r3, sp, #120	; 0x78
   14a3a:	4443      	add	r3, r8
				clen += zero.predot + zero.postdot + zero.trail;
   14a3c:	44bb      	add	fp, r7
   14a3e:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
   14a42:	3b30      	subs	r3, #48	; 0x30
   14a44:	eb0b 060a 	add.w	r6, fp, sl
				if (!isdigit(buf[prefix])) {
   14a48:	2b09      	cmp	r3, #9
				clen += zero.predot + zero.postdot + zero.trail;
   14a4a:	442e      	add	r6, r5
				if (!isdigit(buf[prefix])) {
   14a4c:	f200 8237 	bhi.w	14ebe <z_prf+0x85a>
			} else if (fzero) {
   14a50:	9b08      	ldr	r3, [sp, #32]
   14a52:	2b00      	cmp	r3, #0
   14a54:	f000 8236 	beq.w	14ec4 <z_prf+0x860>
   14a58:	9b07      	ldr	r3, [sp, #28]
   14a5a:	1b9a      	subs	r2, r3, r6
   14a5c:	ab17      	add	r3, sp, #92	; 0x5c
   14a5e:	e737      	b.n	148d0 <z_prf+0x26c>
	} else if (fplus) {
   14a60:	9b09      	ldr	r3, [sp, #36]	; 0x24
   14a62:	b10b      	cbz	r3, 14a68 <z_prf+0x404>
		*buf++ = '+';
   14a64:	232b      	movs	r3, #43	; 0x2b
   14a66:	e7b8      	b.n	149da <z_prf+0x376>
	} else if (fspace) {
   14a68:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   14a6a:	b10b      	cbz	r3, 14a70 <z_prf+0x40c>
		*buf++ = ' ';
   14a6c:	2320      	movs	r3, #32
   14a6e:	e7b4      	b.n	149da <z_prf+0x376>
	} else if (fspace) {
   14a70:	af17      	add	r7, sp, #92	; 0x5c
   14a72:	e7b6      	b.n	149e2 <z_prf+0x37e>
				*buf++ = 'i';
   14a74:	2369      	movs	r3, #105	; 0x69
   14a76:	703b      	strb	r3, [r7, #0]
				*buf++ = 'n';
   14a78:	236e      	movs	r3, #110	; 0x6e
   14a7a:	707b      	strb	r3, [r7, #1]
				*buf++ = 'f';
   14a7c:	2366      	movs	r3, #102	; 0x66
   14a7e:	e7c3      	b.n	14a08 <z_prf+0x3a4>
			if (isupper(c)) {
   14a80:	2c19      	cmp	r4, #25
				*buf++ = 'N';
   14a82:	bf99      	ittee	ls
   14a84:	234e      	movls	r3, #78	; 0x4e
				*buf++ = 'A';
   14a86:	2241      	movls	r2, #65	; 0x41
				*buf++ = 'n';
   14a88:	236e      	movhi	r3, #110	; 0x6e
				*buf++ = 'a';
   14a8a:	2261      	movhi	r2, #97	; 0x61
				*buf++ = 'N';
   14a8c:	bf94      	ite	ls
   14a8e:	703b      	strbls	r3, [r7, #0]
				*buf++ = 'n';
   14a90:	703b      	strbhi	r3, [r7, #0]
				*buf++ = 'a';
   14a92:	707a      	strb	r2, [r7, #1]
   14a94:	e7b8      	b.n	14a08 <z_prf+0x3a4>
	if ((exp | fract) != 0) {
   14a96:	9b02      	ldr	r3, [sp, #8]
   14a98:	9803      	ldr	r0, [sp, #12]
   14a9a:	430b      	orrs	r3, r1
   14a9c:	930c      	str	r3, [sp, #48]	; 0x30
   14a9e:	17cb      	asrs	r3, r1, #31
   14aa0:	4303      	orrs	r3, r0
   14aa2:	930d      	str	r3, [sp, #52]	; 0x34
   14aa4:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
		c = 'f';
   14aa8:	2c46      	cmp	r4, #70	; 0x46
   14aaa:	bf08      	it	eq
   14aac:	2466      	moveq	r4, #102	; 0x66
	if ((exp | fract) != 0) {
   14aae:	4313      	orrs	r3, r2
   14ab0:	f000 80ff 	beq.w	14cb2 <z_prf+0x64e>
		if (exp == 0) {
   14ab4:	2900      	cmp	r1, #0
   14ab6:	f000 809f 	beq.w	14bf8 <z_prf+0x594>
		fract |= HIGHBIT64;
   14aba:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   14abc:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
		exp -= (1023 - 1);	/* +1 since .1 vs 1. */
   14ac0:	f2a1 38fe 	subw	r8, r1, #1022	; 0x3fe
		fract |= HIGHBIT64;
   14ac4:	9313      	str	r3, [sp, #76]	; 0x4c
   14ac6:	2600      	movs	r6, #0
	while (exp <= -3) {
   14ac8:	f118 0f02 	cmn.w	r8, #2
   14acc:	f2c0 80a8 	blt.w	14c20 <z_prf+0x5bc>
		while ((fract >> 32) <= (MAXFP1 / 2)) {
   14ad0:	f06f 4a00 	mvn.w	sl, #2147483648	; 0x80000000
   14ad4:	f04f 0b00 	mov.w	fp, #0
	while (exp > 0) {
   14ad8:	f1b8 0f00 	cmp.w	r8, #0
   14adc:	f300 80cc 	bgt.w	14c78 <z_prf+0x614>
		_rlrshift(&fract);
   14ae0:	a812      	add	r0, sp, #72	; 0x48
		exp++;
   14ae2:	f108 0801 	add.w	r8, r8, #1
		_rlrshift(&fract);
   14ae6:	f015 fd20 	bl	2a52a <_rlrshift>
	while (exp < (0 + 4)) {
   14aea:	f1b8 0f04 	cmp.w	r8, #4
   14aee:	d1f7      	bne.n	14ae0 <z_prf+0x47c>
		precision = 6;		/* Default precision if none given */
   14af0:	2d00      	cmp	r5, #0
	if ((c == 'g') || (c == 'G')) {
   14af2:	f004 03df 	and.w	r3, r4, #223	; 0xdf
		precision = 6;		/* Default precision if none given */
   14af6:	bfb8      	it	lt
   14af8:	2506      	movlt	r5, #6
	if ((c == 'g') || (c == 'G')) {
   14afa:	2b47      	cmp	r3, #71	; 0x47
   14afc:	f040 80e1 	bne.w	14cc2 <z_prf+0x65e>
		if (decexp < (-4 + 1) || decexp > precision) {
   14b00:	1cf2      	adds	r2, r6, #3
   14b02:	db02      	blt.n	14b0a <z_prf+0x4a6>
   14b04:	42ae      	cmp	r6, r5
   14b06:	f340 80d7 	ble.w	14cb8 <z_prf+0x654>
			c += 'e' - 'g';
   14b0a:	3c02      	subs	r4, #2
   14b0c:	b2e4      	uxtb	r4, r4
			if (precision > 0) {
   14b0e:	2d00      	cmp	r5, #0
   14b10:	f000 80dd 	beq.w	14cce <z_prf+0x66a>
		if (!falt && (precision > 0)) {
   14b14:	9b06      	ldr	r3, [sp, #24]
				precision--;
   14b16:	3d01      	subs	r5, #1
		if (!falt && (precision > 0)) {
   14b18:	2b00      	cmp	r3, #0
   14b1a:	f040 80d8 	bne.w	14cce <z_prf+0x66a>
   14b1e:	2d00      	cmp	r5, #0
   14b20:	bfd4      	ite	le
   14b22:	f04f 0800 	movle.w	r8, #0
   14b26:	f04f 0801 	movgt.w	r8, #1
	if (c == 'f') {
   14b2a:	2c66      	cmp	r4, #102	; 0x66
   14b2c:	f040 80d1 	bne.w	14cd2 <z_prf+0x66e>
		if (exp < 0) {
   14b30:	eb16 0a05 	adds.w	sl, r6, r5
   14b34:	f140 80d5 	bpl.w	14ce2 <z_prf+0x67e>
	digit_count = 16;
   14b38:	2310      	movs	r3, #16
   14b3a:	9311      	str	r3, [sp, #68]	; 0x44
   14b3c:	2466      	movs	r4, #102	; 0x66
			exp = 0;
   14b3e:	f04f 0a00 	mov.w	sl, #0
	ltemp = 0x0800000000000000;
   14b42:	2200      	movs	r2, #0
   14b44:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
   14b48:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
	while (exp--) {
   14b4c:	f11a 3aff 	adds.w	sl, sl, #4294967295	; 0xffffffff
   14b50:	f080 80c9 	bcs.w	14ce6 <z_prf+0x682>
	fract += ltemp;
   14b54:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14b56:	9a14      	ldr	r2, [sp, #80]	; 0x50
   14b58:	9915      	ldr	r1, [sp, #84]	; 0x54
   14b5a:	189b      	adds	r3, r3, r2
   14b5c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   14b5e:	eb41 0202 	adc.w	r2, r1, r2
   14b62:	e9cd 3212 	strd	r3, r2, [sp, #72]	; 0x48
	if ((fract >> 32) & 0xF0000000) {
   14b66:	f002 4370 	and.w	r3, r2, #4026531840	; 0xf0000000
   14b6a:	930e      	str	r3, [sp, #56]	; 0x38
   14b6c:	2300      	movs	r3, #0
   14b6e:	930f      	str	r3, [sp, #60]	; 0x3c
   14b70:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
   14b74:	4313      	orrs	r3, r2
   14b76:	d006      	beq.n	14b86 <z_prf+0x522>
		_ldiv5(&fract);
   14b78:	a812      	add	r0, sp, #72	; 0x48
   14b7a:	f015 fce8 	bl	2a54e <_ldiv5>
		_rlrshift(&fract);
   14b7e:	a812      	add	r0, sp, #72	; 0x48
   14b80:	f015 fcd3 	bl	2a52a <_rlrshift>
		decexp++;
   14b84:	3601      	adds	r6, #1
	if (c == 'f') {
   14b86:	2c66      	cmp	r4, #102	; 0x66
   14b88:	f040 80c7 	bne.w	14d1a <z_prf+0x6b6>
		if (decexp > 0) {
   14b8c:	2e00      	cmp	r6, #0
   14b8e:	f340 80b1 	ble.w	14cf4 <z_prf+0x690>
			while (decexp > 0 && digit_count > 0) {
   14b92:	9b11      	ldr	r3, [sp, #68]	; 0x44
   14b94:	2b00      	cmp	r3, #0
   14b96:	dd07      	ble.n	14ba8 <z_prf+0x544>
				*buf++ = _get_digit(&fract, &digit_count);
   14b98:	a911      	add	r1, sp, #68	; 0x44
   14b9a:	a812      	add	r0, sp, #72	; 0x48
   14b9c:	f015 fd03 	bl	2a5a6 <_get_digit>
			while (decexp > 0 && digit_count > 0) {
   14ba0:	3e01      	subs	r6, #1
				*buf++ = _get_digit(&fract, &digit_count);
   14ba2:	f807 0b01 	strb.w	r0, [r7], #1
			while (decexp > 0 && digit_count > 0) {
   14ba6:	d1f4      	bne.n	14b92 <z_prf+0x52e>
			zp->predot = decexp;
   14ba8:	46b2      	mov	sl, r6
   14baa:	46bb      	mov	fp, r7
			decexp = 0;
   14bac:	2600      	movs	r6, #0
		if (falt || (precision > 0)) {
   14bae:	9b06      	ldr	r3, [sp, #24]
   14bb0:	b913      	cbnz	r3, 14bb8 <z_prf+0x554>
   14bb2:	2d00      	cmp	r5, #0
   14bb4:	f340 80af 	ble.w	14d16 <z_prf+0x6b2>
			*buf++ = '.';
   14bb8:	232e      	movs	r3, #46	; 0x2e
   14bba:	f80b 3b01 	strb.w	r3, [fp], #1
		if (decexp < 0 && precision > 0) {
   14bbe:	2e00      	cmp	r6, #0
   14bc0:	f000 80a7 	beq.w	14d12 <z_prf+0x6ae>
   14bc4:	2d00      	cmp	r5, #0
   14bc6:	f340 80a6 	ble.w	14d16 <z_prf+0x6b2>
			zp->postdot = -decexp;
   14bca:	4277      	negs	r7, r6
   14bcc:	42af      	cmp	r7, r5
   14bce:	bfa8      	it	ge
   14bd0:	462f      	movge	r7, r5
			precision -= zp->postdot;
   14bd2:	1bed      	subs	r5, r5, r7
		while (precision > 0 && digit_count > 0) {
   14bd4:	2d00      	cmp	r5, #0
   14bd6:	dd03      	ble.n	14be0 <z_prf+0x57c>
   14bd8:	9b11      	ldr	r3, [sp, #68]	; 0x44
   14bda:	2b00      	cmp	r3, #0
   14bdc:	f300 8091 	bgt.w	14d02 <z_prf+0x69e>
	if (prune_zero) {
   14be0:	f1b8 0f00 	cmp.w	r8, #0
   14be4:	f040 80af 	bne.w	14d46 <z_prf+0x6e2>
	*buf = 0;
   14be8:	2300      	movs	r3, #0
	return buf - start;
   14bea:	ae17      	add	r6, sp, #92	; 0x5c
	*buf = 0;
   14bec:	f88b 3000 	strb.w	r3, [fp]
	return buf - start;
   14bf0:	ebab 0b06 	sub.w	fp, fp, r6
   14bf4:	e710      	b.n	14a18 <z_prf+0x3b4>
				exp--;
   14bf6:	3901      	subs	r1, #1
			while (((fract <<= 1) & HIGHBIT64) == 0) {
   14bf8:	9b02      	ldr	r3, [sp, #8]
   14bfa:	18db      	adds	r3, r3, r3
   14bfc:	9302      	str	r3, [sp, #8]
   14bfe:	9b03      	ldr	r3, [sp, #12]
   14c00:	415b      	adcs	r3, r3
   14c02:	9303      	str	r3, [sp, #12]
   14c04:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   14c08:	2a00      	cmp	r2, #0
   14c0a:	f173 0300 	sbcs.w	r3, r3, #0
   14c0e:	daf2      	bge.n	14bf6 <z_prf+0x592>
   14c10:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   14c14:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
   14c18:	e74f      	b.n	14aba <z_prf+0x456>
			_rlrshift(&fract);
   14c1a:	a812      	add	r0, sp, #72	; 0x48
   14c1c:	f015 fc85 	bl	2a52a <_rlrshift>
		while ((fract >> 32) >= (MAXFP1 / 5)) {
   14c20:	e9dd 2c12 	ldrd	r2, ip, [sp, #72]	; 0x48
   14c24:	f04f 0b00 	mov.w	fp, #0
   14c28:	48b9      	ldr	r0, [pc, #740]	; (14f10 <z_prf+0x8ac>)
   14c2a:	2100      	movs	r1, #0
   14c2c:	4559      	cmp	r1, fp
   14c2e:	bf08      	it	eq
   14c30:	4560      	cmpeq	r0, ip
   14c32:	f108 0801 	add.w	r8, r8, #1
   14c36:	d3f0      	bcc.n	14c1a <z_prf+0x5b6>
		fract *= 5U;
   14c38:	2005      	movs	r0, #5
   14c3a:	fba2 2300 	umull	r2, r3, r2, r0
   14c3e:	fb00 330c 	mla	r3, r0, ip, r3
   14c42:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
		decexp--;
   14c46:	46dc      	mov	ip, fp
   14c48:	3e01      	subs	r6, #1
		while ((fract >> 32) <= (MAXFP1 / 2)) {
   14c4a:	f06f 4a00 	mvn.w	sl, #2147483648	; 0x80000000
   14c4e:	f04f 0b00 	mov.w	fp, #0
   14c52:	2100      	movs	r1, #0
   14c54:	458b      	cmp	fp, r1
   14c56:	bf08      	it	eq
   14c58:	459a      	cmpeq	sl, r3
   14c5a:	d206      	bcs.n	14c6a <z_prf+0x606>
   14c5c:	f1bc 0f00 	cmp.w	ip, #0
   14c60:	f43f af32 	beq.w	14ac8 <z_prf+0x464>
   14c64:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
   14c68:	e72e      	b.n	14ac8 <z_prf+0x464>
			fract <<= 1;
   14c6a:	1892      	adds	r2, r2, r2
   14c6c:	415b      	adcs	r3, r3
			exp--;
   14c6e:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
   14c72:	f04f 0c01 	mov.w	ip, #1
   14c76:	e7ec      	b.n	14c52 <z_prf+0x5ee>
		_ldiv5(&fract);
   14c78:	a812      	add	r0, sp, #72	; 0x48
   14c7a:	f015 fc68 	bl	2a54e <_ldiv5>
		exp--;
   14c7e:	e9dd 1012 	ldrd	r1, r0, [sp, #72]	; 0x48
   14c82:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
		decexp++;
   14c86:	3601      	adds	r6, #1
   14c88:	f04f 0c00 	mov.w	ip, #0
		while ((fract >> 32) <= (MAXFP1 / 2)) {
   14c8c:	2300      	movs	r3, #0
   14c8e:	459b      	cmp	fp, r3
   14c90:	bf08      	it	eq
   14c92:	4582      	cmpeq	sl, r0
   14c94:	d206      	bcs.n	14ca4 <z_prf+0x640>
   14c96:	f1bc 0f00 	cmp.w	ip, #0
   14c9a:	f43f af1d 	beq.w	14ad8 <z_prf+0x474>
   14c9e:	e9cd 1012 	strd	r1, r0, [sp, #72]	; 0x48
   14ca2:	e719      	b.n	14ad8 <z_prf+0x474>
			fract <<= 1;
   14ca4:	1849      	adds	r1, r1, r1
   14ca6:	4140      	adcs	r0, r0
			exp--;
   14ca8:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
   14cac:	f04f 0c01 	mov.w	ip, #1
   14cb0:	e7ec      	b.n	14c8c <z_prf+0x628>
	if ((exp | fract) != 0) {
   14cb2:	2600      	movs	r6, #0
   14cb4:	46b0      	mov	r8, r6
   14cb6:	e713      	b.n	14ae0 <z_prf+0x47c>
		if (!falt && (precision > 0)) {
   14cb8:	9b06      	ldr	r3, [sp, #24]
			precision -= decexp;
   14cba:	1bad      	subs	r5, r5, r6
		if (!falt && (precision > 0)) {
   14cbc:	b923      	cbnz	r3, 14cc8 <z_prf+0x664>
			c = 'f';
   14cbe:	2466      	movs	r4, #102	; 0x66
   14cc0:	e72d      	b.n	14b1e <z_prf+0x4ba>
	prune_zero = false;		/* Assume trailing 0's allowed     */
   14cc2:	f04f 0800 	mov.w	r8, #0
   14cc6:	e730      	b.n	14b2a <z_prf+0x4c6>
   14cc8:	f04f 0800 	mov.w	r8, #0
   14ccc:	e730      	b.n	14b30 <z_prf+0x4cc>
   14cce:	f04f 0800 	mov.w	r8, #0
		exp = precision + 1;
   14cd2:	f105 0a01 	add.w	sl, r5, #1
	digit_count = 16;
   14cd6:	2310      	movs	r3, #16
   14cd8:	459a      	cmp	sl, r3
   14cda:	9311      	str	r3, [sp, #68]	; 0x44
	if (exp > 16) {
   14cdc:	bfa8      	it	ge
   14cde:	469a      	movge	sl, r3
   14ce0:	e72f      	b.n	14b42 <z_prf+0x4de>
		if (exp < 0) {
   14ce2:	2466      	movs	r4, #102	; 0x66
   14ce4:	e7f7      	b.n	14cd6 <z_prf+0x672>
		_ldiv5(&ltemp);
   14ce6:	a814      	add	r0, sp, #80	; 0x50
   14ce8:	f015 fc31 	bl	2a54e <_ldiv5>
		_rlrshift(&ltemp);
   14cec:	a814      	add	r0, sp, #80	; 0x50
   14cee:	f015 fc1c 	bl	2a52a <_rlrshift>
   14cf2:	e72b      	b.n	14b4c <z_prf+0x4e8>
			*buf++ = '0';
   14cf4:	46bb      	mov	fp, r7
   14cf6:	2330      	movs	r3, #48	; 0x30
   14cf8:	f80b 3b01 	strb.w	r3, [fp], #1
			zero.predot = zero.postdot = zero.trail = 0;
   14cfc:	f04f 0a00 	mov.w	sl, #0
   14d00:	e755      	b.n	14bae <z_prf+0x54a>
			*buf++ = _get_digit(&fract, &digit_count);
   14d02:	a911      	add	r1, sp, #68	; 0x44
   14d04:	a812      	add	r0, sp, #72	; 0x48
   14d06:	f015 fc4e 	bl	2a5a6 <_get_digit>
			precision--;
   14d0a:	3d01      	subs	r5, #1
			*buf++ = _get_digit(&fract, &digit_count);
   14d0c:	f80b 0b01 	strb.w	r0, [fp], #1
			precision--;
   14d10:	e760      	b.n	14bd4 <z_prf+0x570>
			zero.predot = zero.postdot = zero.trail = 0;
   14d12:	4637      	mov	r7, r6
   14d14:	e75e      	b.n	14bd4 <z_prf+0x570>
   14d16:	2700      	movs	r7, #0
   14d18:	e762      	b.n	14be0 <z_prf+0x57c>
		*buf = _get_digit(&fract, &digit_count);
   14d1a:	a911      	add	r1, sp, #68	; 0x44
   14d1c:	a812      	add	r0, sp, #72	; 0x48
   14d1e:	f015 fc42 	bl	2a5a6 <_get_digit>
		if (falt || (precision > 0)) {
   14d22:	9b06      	ldr	r3, [sp, #24]
		*buf = _get_digit(&fract, &digit_count);
   14d24:	7038      	strb	r0, [r7, #0]
		if (*buf++ != '0') {
   14d26:	2830      	cmp	r0, #48	; 0x30
			decexp--;
   14d28:	bf18      	it	ne
   14d2a:	f106 36ff 	addne.w	r6, r6, #4294967295	; 0xffffffff
		if (falt || (precision > 0)) {
   14d2e:	2b00      	cmp	r3, #0
   14d30:	d13b      	bne.n	14daa <z_prf+0x746>
   14d32:	2d00      	cmp	r5, #0
   14d34:	dc39      	bgt.n	14daa <z_prf+0x746>
		if (*buf++ != '0') {
   14d36:	f107 0b01 	add.w	fp, r7, #1
	if (prune_zero) {
   14d3a:	f1b8 0f00 	cmp.w	r8, #0
   14d3e:	d045      	beq.n	14dcc <z_prf+0x768>
			zero.predot = zero.postdot = zero.trail = 0;
   14d40:	f04f 0a00 	mov.w	sl, #0
   14d44:	4657      	mov	r7, sl
		while (*--buf == '0')
   14d46:	465b      	mov	r3, fp
   14d48:	f81b 2d01 	ldrb.w	r2, [fp, #-1]!
   14d4c:	2a30      	cmp	r2, #48	; 0x30
   14d4e:	d0fa      	beq.n	14d46 <z_prf+0x6e2>
		if (*buf != '.') {
   14d50:	2a2e      	cmp	r2, #46	; 0x2e
   14d52:	bf18      	it	ne
   14d54:	469b      	movne	fp, r3
   14d56:	2500      	movs	r5, #0
	if ((c == 'e') || (c == 'E')) {
   14d58:	f004 03df 	and.w	r3, r4, #223	; 0xdf
   14d5c:	2b45      	cmp	r3, #69	; 0x45
   14d5e:	f47f af43 	bne.w	14be8 <z_prf+0x584>
		if (decexp < 0) {
   14d62:	2e00      	cmp	r6, #0
		*buf++ = c;
   14d64:	465a      	mov	r2, fp
			decexp = -decexp;
   14d66:	bfba      	itte	lt
   14d68:	4276      	neglt	r6, r6
			*buf++ = '-';
   14d6a:	232d      	movlt	r3, #45	; 0x2d
			*buf++ = '+';
   14d6c:	232b      	movge	r3, #43	; 0x2b
		if (decexp >= 100) {
   14d6e:	2e63      	cmp	r6, #99	; 0x63
		*buf++ = c;
   14d70:	f802 4b02 	strb.w	r4, [r2], #2
			*buf++ = '-';
   14d74:	f88b 3001 	strb.w	r3, [fp, #1]
		if (decexp >= 100) {
   14d78:	dd0a      	ble.n	14d90 <z_prf+0x72c>
			*buf++ = (decexp / 100) + '0';
   14d7a:	2164      	movs	r1, #100	; 0x64
   14d7c:	fb96 f3f1 	sdiv	r3, r6, r1
   14d80:	f103 0030 	add.w	r0, r3, #48	; 0x30
   14d84:	f10b 0203 	add.w	r2, fp, #3
   14d88:	f88b 0002 	strb.w	r0, [fp, #2]
			decexp %= 100;
   14d8c:	fb01 6613 	mls	r6, r1, r3, r6
		*buf++ = (decexp / 10) + '0';
   14d90:	210a      	movs	r1, #10
   14d92:	4693      	mov	fp, r2
   14d94:	fb96 f3f1 	sdiv	r3, r6, r1
		decexp %= 10;
   14d98:	fb01 6613 	mls	r6, r1, r3, r6
		*buf++ = (decexp / 10) + '0';
   14d9c:	f103 0030 	add.w	r0, r3, #48	; 0x30
		*buf++ = decexp + '0';
   14da0:	3630      	adds	r6, #48	; 0x30
		*buf++ = (decexp / 10) + '0';
   14da2:	f80b 0b02 	strb.w	r0, [fp], #2
		*buf++ = decexp + '0';
   14da6:	7056      	strb	r6, [r2, #1]
   14da8:	e71e      	b.n	14be8 <z_prf+0x584>
			*buf++ = '.';
   14daa:	232e      	movs	r3, #46	; 0x2e
   14dac:	f107 0b02 	add.w	fp, r7, #2
   14db0:	707b      	strb	r3, [r7, #1]
		while (precision > 0 && digit_count > 0) {
   14db2:	2d00      	cmp	r5, #0
   14db4:	ddc1      	ble.n	14d3a <z_prf+0x6d6>
   14db6:	9b11      	ldr	r3, [sp, #68]	; 0x44
   14db8:	2b00      	cmp	r3, #0
   14dba:	ddbe      	ble.n	14d3a <z_prf+0x6d6>
			*buf++ = _get_digit(&fract, &digit_count);
   14dbc:	a911      	add	r1, sp, #68	; 0x44
   14dbe:	a812      	add	r0, sp, #72	; 0x48
   14dc0:	f015 fbf1 	bl	2a5a6 <_get_digit>
			precision--;
   14dc4:	3d01      	subs	r5, #1
			*buf++ = _get_digit(&fract, &digit_count);
   14dc6:	f80b 0b01 	strb.w	r0, [fp], #1
			precision--;
   14dca:	e7f2      	b.n	14db2 <z_prf+0x74e>
			zero.predot = zero.postdot = zero.trail = 0;
   14dcc:	46c2      	mov	sl, r8
   14dce:	4647      	mov	r7, r8
   14dd0:	e7c2      	b.n	14d58 <z_prf+0x6f4>
					prefix = 1;
   14dd2:	f04f 0801 	mov.w	r8, #1
   14dd6:	e62f      	b.n	14a38 <z_prf+0x3d4>
				switch (i) {
   14dd8:	46b1      	mov	r9, r6
   14dda:	2f68      	cmp	r7, #104	; 0x68
   14ddc:	f859 3b04 	ldr.w	r3, [r9], #4
   14de0:	d005      	beq.n	14dee <z_prf+0x78a>
   14de2:	dc01      	bgt.n	14de8 <z_prf+0x784>
   14de4:	2f48      	cmp	r7, #72	; 0x48
   14de6:	d007      	beq.n	14df8 <z_prf+0x794>
					*va_arg(vargs, int *) = count;
   14de8:	9a00      	ldr	r2, [sp, #0]
   14dea:	601a      	str	r2, [r3, #0]
					break;
   14dec:	e001      	b.n	14df2 <z_prf+0x78e>
					*va_arg(vargs, short *) = count;
   14dee:	9a00      	ldr	r2, [sp, #0]
   14df0:	801a      	strh	r2, [r3, #0]
				continue;
   14df2:	464e      	mov	r6, r9
   14df4:	9a05      	ldr	r2, [sp, #20]
   14df6:	e43d      	b.n	14674 <z_prf+0x10>
					*va_arg(vargs, char *) = count;
   14df8:	9a00      	ldr	r2, [sp, #0]
   14dfa:	701a      	strb	r2, [r3, #0]
					break;
   14dfc:	e7f9      	b.n	14df2 <z_prf+0x78e>
				val = (uintptr_t) va_arg(vargs, void *);
   14dfe:	46b1      	mov	r9, r6
		*buf++ = '0';
   14e00:	f647 0330 	movw	r3, #30768	; 0x7830
	len = _to_x(buf, value, 16);
   14e04:	2210      	movs	r2, #16
   14e06:	f859 1b04 	ldr.w	r1, [r9], #4
		*buf++ = '0';
   14e0a:	f8ad 305c 	strh.w	r3, [sp, #92]	; 0x5c
	len = _to_x(buf, value, 16);
   14e0e:	f10d 005e 	add.w	r0, sp, #94	; 0x5e
   14e12:	f015 fb68 	bl	2a4e6 <_to_x>
				prefix = 2;
   14e16:	f04f 0802 	mov.w	r8, #2
	return len + (buf - buf0);
   14e1a:	1c86      	adds	r6, r0, #2
				break;
   14e1c:	e52c      	b.n	14878 <z_prf+0x214>
					if (cptr[clen] == '\0') {
   14e1e:	5d9a      	ldrb	r2, [r3, r6]
   14e20:	2a00      	cmp	r2, #0
   14e22:	d04a      	beq.n	14eba <z_prf+0x856>
				for (clen = 0; clen < precision; clen++) {
   14e24:	3601      	adds	r6, #1
   14e26:	e53c      	b.n	148a2 <z_prf+0x23e>
	if (alt_form) {
   14e28:	ac17      	add	r4, sp, #92	; 0x5c
	return (buf - buf0) + _to_x(buf, value, 8);
   14e2a:	2208      	movs	r2, #8
   14e2c:	4620      	mov	r0, r4
   14e2e:	f015 fb5a 	bl	2a4e6 <_to_x>
   14e32:	ae17      	add	r6, sp, #92	; 0x5c
   14e34:	1ba6      	subs	r6, r4, r6
   14e36:	4406      	add	r6, r0
			prefix = 0;
   14e38:	f04f 0800 	mov.w	r8, #0
   14e3c:	e51c      	b.n	14878 <z_prf+0x214>
		*buf++ = '0';
   14e3e:	f10d 045d 	add.w	r4, sp, #93	; 0x5d
   14e42:	e7f2      	b.n	14e2a <z_prf+0x7c6>
				} else if (c == 'u') {
   14e44:	2c75      	cmp	r4, #117	; 0x75
   14e46:	d105      	bne.n	14e54 <z_prf+0x7f0>
	return _to_x(buf, value, 10);
   14e48:	220a      	movs	r2, #10
   14e4a:	a817      	add	r0, sp, #92	; 0x5c
   14e4c:	f015 fb4b 	bl	2a4e6 <_to_x>
   14e50:	4606      	mov	r6, r0
   14e52:	e7f1      	b.n	14e38 <z_prf+0x7d4>
	if (alt_form) {
   14e54:	9b06      	ldr	r3, [sp, #24]
   14e56:	b193      	cbz	r3, 14e7e <z_prf+0x81a>
		*buf++ = '0';
   14e58:	f647 0330 	movw	r3, #30768	; 0x7830
   14e5c:	f8ad 305c 	strh.w	r3, [sp, #92]	; 0x5c
		*buf++ = 'x';
   14e60:	f10d 075e 	add.w	r7, sp, #94	; 0x5e
	len = _to_x(buf, value, 16);
   14e64:	2210      	movs	r2, #16
   14e66:	4638      	mov	r0, r7
   14e68:	f015 fb3d 	bl	2a4e6 <_to_x>
	if (prefix == 'X') {
   14e6c:	2c58      	cmp	r4, #88	; 0x58
   14e6e:	d008      	beq.n	14e82 <z_prf+0x81e>
	return len + (buf - buf0);
   14e70:	ae17      	add	r6, sp, #92	; 0x5c
						prefix = 2;
   14e72:	9b06      	ldr	r3, [sp, #24]
	return len + (buf - buf0);
   14e74:	1bbe      	subs	r6, r7, r6
   14e76:	4406      	add	r6, r0
						prefix = 2;
   14e78:	ea4f 0843 	mov.w	r8, r3, lsl #1
   14e7c:	e4fc      	b.n	14878 <z_prf+0x214>
	if (alt_form) {
   14e7e:	af17      	add	r7, sp, #92	; 0x5c
   14e80:	e7f0      	b.n	14e64 <z_prf+0x800>
   14e82:	aa17      	add	r2, sp, #92	; 0x5c
		if (*buf >= 'a' && *buf <= 'z') {
   14e84:	f812 3b01 	ldrb.w	r3, [r2], #1
   14e88:	f1a3 0161 	sub.w	r1, r3, #97	; 0x61
   14e8c:	2919      	cmp	r1, #25
   14e8e:	d803      	bhi.n	14e98 <z_prf+0x834>
			*buf += 'A' - 'a';
   14e90:	3b20      	subs	r3, #32
   14e92:	f802 3c01 	strb.w	r3, [r2, #-1]
   14e96:	e7f5      	b.n	14e84 <z_prf+0x820>
	} while (*buf++);
   14e98:	f812 3c01 	ldrb.w	r3, [r2, #-1]
   14e9c:	2b00      	cmp	r3, #0
   14e9e:	d1f1      	bne.n	14e84 <z_prf+0x820>
   14ea0:	e7e6      	b.n	14e70 <z_prf+0x80c>
				PUTC('%');
   14ea2:	9904      	ldr	r1, [sp, #16]
   14ea4:	4620      	mov	r0, r4
   14ea6:	f7ff bbee 	b.w	14686 <z_prf+0x22>
				count++;
   14eaa:	9b00      	ldr	r3, [sp, #0]
   14eac:	3301      	adds	r3, #1
				count += 2;
   14eae:	9300      	str	r3, [sp, #0]
				continue;
   14eb0:	46b1      	mov	r9, r6
   14eb2:	e79e      	b.n	14df2 <z_prf+0x78e>
					prefix = 1;
   14eb4:	f04f 0801 	mov.w	r8, #1
   14eb8:	e4de      	b.n	14878 <z_prf+0x214>
   14eba:	4615      	mov	r5, r2
   14ebc:	e4f6      	b.n	148ac <z_prf+0x248>
			cptr = buf;
   14ebe:	ab17      	add	r3, sp, #92	; 0x5c
				zero_head = 0;
   14ec0:	2200      	movs	r2, #0
   14ec2:	e507      	b.n	148d4 <z_prf+0x270>
   14ec4:	ab17      	add	r3, sp, #92	; 0x5c
   14ec6:	9a08      	ldr	r2, [sp, #32]
   14ec8:	e504      	b.n	148d4 <z_prf+0x270>
   14eca:	e9cd 3207 	strd	r3, r2, [sp, #28]
					PUTC(' ');
   14ece:	9904      	ldr	r1, [sp, #16]
   14ed0:	9b01      	ldr	r3, [sp, #4]
   14ed2:	2020      	movs	r0, #32
   14ed4:	4798      	blx	r3
   14ed6:	3001      	adds	r0, #1
   14ed8:	e9dd 3207 	ldrd	r3, r2, [sp, #28]
   14edc:	f43f abd8 	beq.w	14690 <z_prf+0x2c>
				while (width-- > 0) {
   14ee0:	f11b 3bff 	adds.w	fp, fp, #4294967295	; 0xffffffff
   14ee4:	d2f1      	bcs.n	14eca <z_prf+0x866>
				count += width;
   14ee6:	9900      	ldr	r1, [sp, #0]
   14ee8:	4421      	add	r1, r4
   14eea:	9100      	str	r1, [sp, #0]
				while (width-- > 0) {
   14eec:	465c      	mov	r4, fp
   14eee:	e4fb      	b.n	148e8 <z_prf+0x284>
   14ef0:	46a3      	mov	fp, r4
   14ef2:	e7f5      	b.n	14ee0 <z_prf+0x87c>
				PUTC(*cptr++);
   14ef4:	f813 0b01 	ldrb.w	r0, [r3], #1
   14ef8:	9307      	str	r3, [sp, #28]
   14efa:	9904      	ldr	r1, [sp, #16]
   14efc:	9b01      	ldr	r3, [sp, #4]
   14efe:	9208      	str	r2, [sp, #32]
   14f00:	4798      	blx	r3
   14f02:	3001      	adds	r0, #1
   14f04:	e9dd 3207 	ldrd	r3, r2, [sp, #28]
   14f08:	f47f acf0 	bne.w	148ec <z_prf+0x288>
   14f0c:	f7ff bbc0 	b.w	14690 <z_prf+0x2c>
   14f10:	33333332 	.word	0x33333332
				PUTC('0');
   14f14:	9904      	ldr	r1, [sp, #16]
   14f16:	9b01      	ldr	r3, [sp, #4]
   14f18:	9207      	str	r2, [sp, #28]
   14f1a:	2030      	movs	r0, #48	; 0x30
   14f1c:	4798      	blx	r3
   14f1e:	3001      	adds	r0, #1
   14f20:	9a07      	ldr	r2, [sp, #28]
   14f22:	f47f ace6 	bne.w	148f2 <z_prf+0x28e>
   14f26:	f7ff bbb3 	b.w	14690 <z_prf+0x2c>
					PUTC(c);
   14f2a:	9904      	ldr	r1, [sp, #16]
   14f2c:	9b01      	ldr	r3, [sp, #4]
   14f2e:	4798      	blx	r3
   14f30:	3001      	adds	r0, #1
   14f32:	f43f abad 	beq.w	14690 <z_prf+0x2c>
					c = *++cptr;
   14f36:	f81b 0f01 	ldrb.w	r0, [fp, #1]!
   14f3a:	e4e7      	b.n	1490c <z_prf+0x2a8>
					PUTC('0');
   14f3c:	9904      	ldr	r1, [sp, #16]
   14f3e:	9b01      	ldr	r3, [sp, #4]
   14f40:	2030      	movs	r0, #48	; 0x30
   14f42:	4798      	blx	r3
   14f44:	3001      	adds	r0, #1
   14f46:	f47f ace9 	bne.w	1491c <z_prf+0x2b8>
   14f4a:	f7ff bba1 	b.w	14690 <z_prf+0x2c>
					PUTC('0');
   14f4e:	9904      	ldr	r1, [sp, #16]
   14f50:	9b01      	ldr	r3, [sp, #4]
   14f52:	2030      	movs	r0, #48	; 0x30
   14f54:	4798      	blx	r3
   14f56:	3001      	adds	r0, #1
   14f58:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
   14f5c:	f47f acf6 	bne.w	1494c <z_prf+0x2e8>
   14f60:	f7ff bb96 	b.w	14690 <z_prf+0x2c>
					PUTC(c);
   14f64:	9904      	ldr	r1, [sp, #16]
   14f66:	9b01      	ldr	r3, [sp, #4]
   14f68:	4798      	blx	r3
   14f6a:	3001      	adds	r0, #1
   14f6c:	f43f ab90 	beq.w	14690 <z_prf+0x2c>
					c = *++cptr;
   14f70:	f81b 0f01 	ldrb.w	r0, [fp, #1]!
   14f74:	e4f4      	b.n	14960 <z_prf+0x2fc>
					PUTC('0');
   14f76:	9904      	ldr	r1, [sp, #16]
   14f78:	9b01      	ldr	r3, [sp, #4]
   14f7a:	2030      	movs	r0, #48	; 0x30
   14f7c:	4798      	blx	r3
   14f7e:	3001      	adds	r0, #1
   14f80:	f107 37ff 	add.w	r7, r7, #4294967295	; 0xffffffff
   14f84:	f47f acf7 	bne.w	14976 <z_prf+0x312>
   14f88:	f7ff bb82 	b.w	14690 <z_prf+0x2c>
				PUTC(*cptr++);
   14f8c:	9904      	ldr	r1, [sp, #16]
   14f8e:	f81b 0b01 	ldrb.w	r0, [fp], #1
   14f92:	9b01      	ldr	r3, [sp, #4]
   14f94:	4798      	blx	r3
   14f96:	3001      	adds	r0, #1
   14f98:	f43f ab7a 	beq.w	14690 <z_prf+0x2c>
   14f9c:	eba6 030b 	sub.w	r3, r6, fp
			while (clen-- > 0) {
   14fa0:	2b00      	cmp	r3, #0
   14fa2:	dcf3      	bgt.n	14f8c <z_prf+0x928>
			count += clen;
   14fa4:	9b00      	ldr	r3, [sp, #0]
   14fa6:	9a06      	ldr	r2, [sp, #24]
			if (width > 0) {
   14fa8:	2c00      	cmp	r4, #0
			count += clen;
   14faa:	4413      	add	r3, r2
   14fac:	9300      	str	r3, [sp, #0]
			if (width > 0) {
   14fae:	f77f af20 	ble.w	14df2 <z_prf+0x78e>
   14fb2:	4625      	mov	r5, r4
   14fb4:	e006      	b.n	14fc4 <z_prf+0x960>
					PUTC(' ');
   14fb6:	9904      	ldr	r1, [sp, #16]
   14fb8:	9b01      	ldr	r3, [sp, #4]
   14fba:	2020      	movs	r0, #32
   14fbc:	4798      	blx	r3
   14fbe:	3001      	adds	r0, #1
   14fc0:	f43f ab66 	beq.w	14690 <z_prf+0x2c>
				while (width-- > 0) {
   14fc4:	f115 35ff 	adds.w	r5, r5, #4294967295	; 0xffffffff
   14fc8:	d2f5      	bcs.n	14fb6 <z_prf+0x952>
				count += width;
   14fca:	9b00      	ldr	r3, [sp, #0]
   14fcc:	4423      	add	r3, r4
   14fce:	9300      	str	r3, [sp, #0]
   14fd0:	e70f      	b.n	14df2 <z_prf+0x78e>
   14fd2:	bf00      	nop

00014fd4 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
   14fd4:	4b01      	ldr	r3, [pc, #4]	; (14fdc <__stdout_hook_install+0x8>)
   14fd6:	6018      	str	r0, [r3, #0]
}
   14fd8:	4770      	bx	lr
   14fda:	bf00      	nop
   14fdc:	2000f94c 	.word	0x2000f94c

00014fe0 <snprintf>:
	return 0; /* indicate keep going so we get the total count */
}

int snprintf(char *_MLIBC_RESTRICT s, size_t len,
	     const char *_MLIBC_RESTRICT format, ...)
{
   14fe0:	b40c      	push	{r2, r3}
   14fe2:	b51f      	push	{r0, r1, r2, r3, r4, lr}

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
   14fe4:	b909      	cbnz	r1, 14fea <snprintf+0xa>
		s = &dummy; /* write final NUL to dummy, can't change *s */
   14fe6:	f10d 0003 	add.w	r0, sp, #3
	}

	p.ptr = s;
	p.len = (int) len;
   14fea:	e9cd 0102 	strd	r0, r1, [sp, #8]

	va_start(vargs, format);
   14fee:	ab07      	add	r3, sp, #28
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
   14ff0:	9a06      	ldr	r2, [sp, #24]
   14ff2:	4806      	ldr	r0, [pc, #24]	; (1500c <snprintf+0x2c>)
	va_start(vargs, format);
   14ff4:	9301      	str	r3, [sp, #4]
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
   14ff6:	a902      	add	r1, sp, #8
   14ff8:	f7ff fb34 	bl	14664 <z_prf>
	va_end(vargs);

	*(p.ptr) = 0;
   14ffc:	9b02      	ldr	r3, [sp, #8]
   14ffe:	2200      	movs	r2, #0
   15000:	701a      	strb	r2, [r3, #0]
	return r;
}
   15002:	b005      	add	sp, #20
   15004:	f85d eb04 	ldr.w	lr, [sp], #4
   15008:	b002      	add	sp, #8
   1500a:	4770      	bx	lr
   1500c:	0002a5db 	.word	0x0002a5db

00015010 <nordicsemi_nrf52_init>:
   15010:	f04f 0320 	mov.w	r3, #32
   15014:	f3ef 8211 	mrs	r2, BASEPRI
   15018:	f383 8811 	msr	BASEPRI, r3
   1501c:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
   15020:	4906      	ldr	r1, [pc, #24]	; (1503c <nordicsemi_nrf52_init+0x2c>)
   15022:	2301      	movs	r3, #1
   15024:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
#endif

#if NRF_POWER_HAS_DCDCEN
NRF_STATIC_INLINE void nrf_power_dcdcen_set(NRF_POWER_Type * p_reg, bool enable)
{
    p_reg->DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) <<
   15028:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
   1502c:	f8c1 3578 	str.w	r3, [r1, #1400]	; 0x578
	__asm__ volatile(
   15030:	f382 8811 	msr	BASEPRI, r2
   15034:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
   15038:	2000      	movs	r0, #0
   1503a:	4770      	bx	lr
   1503c:	4001e000 	.word	0x4001e000

00015040 <sys_arch_reboot>:
    *p_gpregret = val;
   15040:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   15044:	b2c0      	uxtb	r0, r0
   15046:	f8c3 051c 	str.w	r0, [r3, #1308]	; 0x51c
  __ASM volatile ("dsb 0xF":::"memory");
   1504a:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   1504e:	4905      	ldr	r1, [pc, #20]	; (15064 <sys_arch_reboot+0x24>)
   15050:	4b05      	ldr	r3, [pc, #20]	; (15068 <sys_arch_reboot+0x28>)
   15052:	68ca      	ldr	r2, [r1, #12]
   15054:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   15058:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   1505a:	60cb      	str	r3, [r1, #12]
   1505c:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
   15060:	bf00      	nop
   15062:	e7fd      	b.n	15060 <sys_arch_reboot+0x20>
   15064:	e000ed00 	.word	0xe000ed00
   15068:	05fa0004 	.word	0x05fa0004

0001506c <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
   1506c:	b120      	cbz	r0, 15078 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
   1506e:	4b03      	ldr	r3, [pc, #12]	; (1507c <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
   15070:	0180      	lsls	r0, r0, #6
   15072:	f043 0301 	orr.w	r3, r3, #1
   15076:	4718      	bx	r3

void arch_busy_wait(u32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
   15078:	4770      	bx	lr
   1507a:	bf00      	nop
   1507c:	0002dd70 	.word	0x0002dd70

00015080 <bt_hex_real>:
	static const char hex[] = "0123456789abcdef";
	static char str[129];
	const u8_t *b = buf;
	int i;

	len = MIN(len, (sizeof(str) - 1) / 2);
   15080:	2940      	cmp	r1, #64	; 0x40
   15082:	4b0e      	ldr	r3, [pc, #56]	; (150bc <bt_hex_real+0x3c>)
{
   15084:	b570      	push	{r4, r5, r6, lr}
	len = MIN(len, (sizeof(str) - 1) / 2);
   15086:	bf28      	it	cs
   15088:	2140      	movcs	r1, #64	; 0x40

	for (i = 0; i < len; i++) {
		str[i * 2]     = hex[b[i] >> 4];
   1508a:	4c0d      	ldr	r4, [pc, #52]	; (150c0 <bt_hex_real+0x40>)
   1508c:	1846      	adds	r6, r0, r1
   1508e:	461d      	mov	r5, r3
	for (i = 0; i < len; i++) {
   15090:	42b0      	cmp	r0, r6
   15092:	f103 0302 	add.w	r3, r3, #2
   15096:	d104      	bne.n	150a2 <bt_hex_real+0x22>
		str[i * 2 + 1] = hex[b[i] & 0xf];
	}

	str[i * 2] = '\0';
   15098:	2300      	movs	r3, #0
   1509a:	f805 3011 	strb.w	r3, [r5, r1, lsl #1]

	return str;
}
   1509e:	4807      	ldr	r0, [pc, #28]	; (150bc <bt_hex_real+0x3c>)
   150a0:	bd70      	pop	{r4, r5, r6, pc}
		str[i * 2]     = hex[b[i] >> 4];
   150a2:	7802      	ldrb	r2, [r0, #0]
   150a4:	0912      	lsrs	r2, r2, #4
   150a6:	5ca2      	ldrb	r2, [r4, r2]
   150a8:	f803 2c02 	strb.w	r2, [r3, #-2]
		str[i * 2 + 1] = hex[b[i] & 0xf];
   150ac:	f810 2b01 	ldrb.w	r2, [r0], #1
   150b0:	f002 020f 	and.w	r2, r2, #15
   150b4:	5ca2      	ldrb	r2, [r4, r2]
   150b6:	f803 2c01 	strb.w	r2, [r3, #-1]
   150ba:	e7e9      	b.n	15090 <bt_hex_real+0x10>
   150bc:	20003d63 	.word	0x20003d63
   150c0:	00030645 	.word	0x00030645

000150c4 <bt_addr_le_str_real>:

	return str;
}

const char *bt_addr_le_str_real(const bt_addr_le_t *addr)
{
   150c4:	b530      	push	{r4, r5, lr}
	switch (addr->type) {
   150c6:	7803      	ldrb	r3, [r0, #0]
   150c8:	b08b      	sub	sp, #44	; 0x2c
   150ca:	4604      	mov	r4, r0
   150cc:	ad07      	add	r5, sp, #28
   150ce:	2b03      	cmp	r3, #3
   150d0:	d821      	bhi.n	15116 <bt_addr_le_str_real+0x52>
   150d2:	e8df f003 	tbb	[pc, r3]
   150d6:	1a02      	.short	0x1a02
   150d8:	1e1c      	.short	0x1e1c
		strcpy(type, "public");
   150da:	4912      	ldr	r1, [pc, #72]	; (15124 <bt_addr_le_str_real+0x60>)
		strcpy(type, "random");
   150dc:	4628      	mov	r0, r5
   150de:	f015 f942 	bl	2a366 <strcpy>
	return snprintk(str, len, "%02X:%02X:%02X:%02X:%02X:%02X (%s)",
   150e2:	7863      	ldrb	r3, [r4, #1]
   150e4:	9304      	str	r3, [sp, #16]
   150e6:	78a3      	ldrb	r3, [r4, #2]
   150e8:	9303      	str	r3, [sp, #12]
   150ea:	78e3      	ldrb	r3, [r4, #3]
   150ec:	9302      	str	r3, [sp, #8]
   150ee:	7923      	ldrb	r3, [r4, #4]
   150f0:	9301      	str	r3, [sp, #4]
   150f2:	7963      	ldrb	r3, [r4, #5]
   150f4:	9300      	str	r3, [sp, #0]
   150f6:	9505      	str	r5, [sp, #20]
   150f8:	79a3      	ldrb	r3, [r4, #6]
   150fa:	4a0b      	ldr	r2, [pc, #44]	; (15128 <bt_addr_le_str_real+0x64>)
   150fc:	480b      	ldr	r0, [pc, #44]	; (1512c <bt_addr_le_str_real+0x68>)
   150fe:	211e      	movs	r1, #30
   15100:	f013 f82d 	bl	2815e <snprintk>
	static char str[BT_ADDR_LE_STR_LEN];

	bt_addr_le_to_str(addr, str, sizeof(str));

	return str;
}
   15104:	4809      	ldr	r0, [pc, #36]	; (1512c <bt_addr_le_str_real+0x68>)
   15106:	b00b      	add	sp, #44	; 0x2c
   15108:	bd30      	pop	{r4, r5, pc}
		strcpy(type, "random");
   1510a:	4909      	ldr	r1, [pc, #36]	; (15130 <bt_addr_le_str_real+0x6c>)
   1510c:	e7e6      	b.n	150dc <bt_addr_le_str_real+0x18>
		strcpy(type, "public-id");
   1510e:	4909      	ldr	r1, [pc, #36]	; (15134 <bt_addr_le_str_real+0x70>)
   15110:	e7e4      	b.n	150dc <bt_addr_le_str_real+0x18>
		strcpy(type, "random-id");
   15112:	4909      	ldr	r1, [pc, #36]	; (15138 <bt_addr_le_str_real+0x74>)
   15114:	e7e2      	b.n	150dc <bt_addr_le_str_real+0x18>
		snprintk(type, sizeof(type), "0x%02x", addr->type);
   15116:	4a09      	ldr	r2, [pc, #36]	; (1513c <bt_addr_le_str_real+0x78>)
   15118:	210a      	movs	r1, #10
   1511a:	4628      	mov	r0, r5
   1511c:	f013 f81f 	bl	2815e <snprintk>
		break;
   15120:	e7df      	b.n	150e2 <bt_addr_le_str_real+0x1e>
   15122:	bf00      	nop
   15124:	0002e8a6 	.word	0x0002e8a6
   15128:	0002e8c8 	.word	0x0002e8c8
   1512c:	20003de4 	.word	0x20003de4
   15130:	0002e8ad 	.word	0x0002e8ad
   15134:	0002e8b4 	.word	0x0002e8b4
   15138:	0002e8be 	.word	0x0002e8be
   1513c:	0003161a 	.word	0x0003161a

00015140 <uuid_to_uuid128>:
	.val = { BT_UUID_128_ENCODE(
		0x00000000, 0x0000, 0x1000, 0x8000, 0x00805F9B34FB) }
};

static void uuid_to_uuid128(const struct bt_uuid *src, struct bt_uuid_128 *dst)
{
   15140:	b4f0      	push	{r4, r5, r6, r7}
	switch (src->type) {
   15142:	7802      	ldrb	r2, [r0, #0]
   15144:	2a01      	cmp	r2, #1
{
   15146:	4604      	mov	r4, r0
   15148:	460b      	mov	r3, r1
	switch (src->type) {
   1514a:	d017      	beq.n	1517c <uuid_to_uuid128+0x3c>
   1514c:	b11a      	cbz	r2, 15156 <uuid_to_uuid128+0x16>
   1514e:	2a02      	cmp	r2, #2
   15150:	d02c      	beq.n	151ac <uuid_to_uuid128+0x6c>
		return;
	case BT_UUID_TYPE_128:
		memcpy(dst, src, sizeof(*dst));
		return;
	}
}
   15152:	bcf0      	pop	{r4, r5, r6, r7}
   15154:	4770      	bx	lr
		*dst = uuid128_base;
   15156:	4a18      	ldr	r2, [pc, #96]	; (151b8 <uuid_to_uuid128+0x78>)
   15158:	460d      	mov	r5, r1
   1515a:	f102 0710 	add.w	r7, r2, #16
   1515e:	6810      	ldr	r0, [r2, #0]
   15160:	6851      	ldr	r1, [r2, #4]
   15162:	462e      	mov	r6, r5
   15164:	c603      	stmia	r6!, {r0, r1}
   15166:	3208      	adds	r2, #8
   15168:	42ba      	cmp	r2, r7
   1516a:	4635      	mov	r5, r6
   1516c:	d1f7      	bne.n	1515e <uuid_to_uuid128+0x1e>
   1516e:	7812      	ldrb	r2, [r2, #0]
   15170:	7032      	strb	r2, [r6, #0]
		sys_put_le16(BT_UUID_16(src)->val,
   15172:	8862      	ldrh	r2, [r4, #2]
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le16(u16_t val, u8_t dst[2])
{
	dst[0] = val;
   15174:	735a      	strb	r2, [r3, #13]
	dst[1] = val >> 8;
   15176:	0a12      	lsrs	r2, r2, #8
   15178:	739a      	strb	r2, [r3, #14]
   1517a:	e7ea      	b.n	15152 <uuid_to_uuid128+0x12>
		*dst = uuid128_base;
   1517c:	4a0e      	ldr	r2, [pc, #56]	; (151b8 <uuid_to_uuid128+0x78>)
   1517e:	460d      	mov	r5, r1
   15180:	f102 0710 	add.w	r7, r2, #16
   15184:	6810      	ldr	r0, [r2, #0]
   15186:	6851      	ldr	r1, [r2, #4]
   15188:	462e      	mov	r6, r5
   1518a:	c603      	stmia	r6!, {r0, r1}
   1518c:	3208      	adds	r2, #8
   1518e:	42ba      	cmp	r2, r7
   15190:	4635      	mov	r5, r6
   15192:	d1f7      	bne.n	15184 <uuid_to_uuid128+0x44>
   15194:	7812      	ldrb	r2, [r2, #0]
   15196:	7032      	strb	r2, [r6, #0]
		sys_put_le32(BT_UUID_32(src)->val,
   15198:	6862      	ldr	r2, [r4, #4]
	dst[0] = val;
   1519a:	735a      	strb	r2, [r3, #13]
	dst[1] = val >> 8;
   1519c:	f3c2 2107 	ubfx	r1, r2, #8, #8
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le32(u32_t val, u8_t dst[4])
{
	sys_put_le16(val, dst);
	sys_put_le16(val >> 16, &dst[2]);
   151a0:	0c12      	lsrs	r2, r2, #16
	dst[0] = val;
   151a2:	73da      	strb	r2, [r3, #15]
	dst[1] = val >> 8;
   151a4:	0a12      	lsrs	r2, r2, #8
   151a6:	7399      	strb	r1, [r3, #14]
   151a8:	741a      	strb	r2, [r3, #16]
   151aa:	e7d2      	b.n	15152 <uuid_to_uuid128+0x12>
		memcpy(dst, src, sizeof(*dst));
   151ac:	4601      	mov	r1, r0
   151ae:	2211      	movs	r2, #17
   151b0:	4618      	mov	r0, r3
}
   151b2:	bcf0      	pop	{r4, r5, r6, r7}
		memcpy(dst, src, sizeof(*dst));
   151b4:	f015 b94b 	b.w	2a44e <memcpy>
   151b8:	0003065d 	.word	0x0003065d

000151bc <ver_str>:
	return 0;
}

#if defined(CONFIG_BT_DEBUG)
static const char *ver_str(u8_t ver)
{
   151bc:	b570      	push	{r4, r5, r6, lr}
	const char * const str[] = {
   151be:	4d0b      	ldr	r5, [pc, #44]	; (151ec <ver_str+0x30>)
{
   151c0:	4606      	mov	r6, r0
	const char * const str[] = {
   151c2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
   151c4:	b08c      	sub	sp, #48	; 0x30
	const char * const str[] = {
   151c6:	ac01      	add	r4, sp, #4
   151c8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   151ca:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   151cc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   151ce:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
		"1.0b", "1.1", "1.2", "2.0", "2.1", "3.0", "4.0", "4.1", "4.2",
		"5.0", "5.1",
	};

	if (ver < ARRAY_SIZE(str)) {
   151d2:	2e0a      	cmp	r6, #10
	const char * const str[] = {
   151d4:	e884 0007 	stmia.w	r4, {r0, r1, r2}
		return str[ver];
   151d8:	bf9b      	ittet	ls
   151da:	ab0c      	addls	r3, sp, #48	; 0x30
   151dc:	eb03 0686 	addls.w	r6, r3, r6, lsl #2
	}

	return "unknown";
   151e0:	4803      	ldrhi	r0, [pc, #12]	; (151f0 <ver_str+0x34>)
		return str[ver];
   151e2:	f856 0c2c 	ldrls.w	r0, [r6, #-44]
}
   151e6:	b00c      	add	sp, #48	; 0x30
   151e8:	bd70      	pop	{r4, r5, r6, pc}
   151ea:	bf00      	nop
   151ec:	0002dd0c 	.word	0x0002dd0c
   151f0:	0002f1cd 	.word	0x0002f1cd

000151f4 <hci_data_buf_overflow>:
	BT_WARN("Data buffer overflow (link type 0x%02x)", evt->link_type);
   151f4:	4b0a      	ldr	r3, [pc, #40]	; (15220 <hci_data_buf_overflow+0x2c>)
   151f6:	681b      	ldr	r3, [r3, #0]
   151f8:	f013 0f06 	tst.w	r3, #6
   151fc:	d00f      	beq.n	1521e <hci_data_buf_overflow+0x2a>
   151fe:	2302      	movs	r3, #2
   15200:	f04f 0200 	mov.w	r2, #0
	struct bt_hci_evt_data_buf_overflow *evt = (void *)buf->data;
   15204:	6881      	ldr	r1, [r0, #8]
   15206:	4807      	ldr	r0, [pc, #28]	; (15224 <hci_data_buf_overflow+0x30>)
	BT_WARN("Data buffer overflow (link type 0x%02x)", evt->link_type);
   15208:	7809      	ldrb	r1, [r1, #0]
   1520a:	f363 0207 	bfi	r2, r3, #0, #8
   1520e:	4b06      	ldr	r3, [pc, #24]	; (15228 <hci_data_buf_overflow+0x34>)
   15210:	1a1b      	subs	r3, r3, r0
   15212:	08db      	lsrs	r3, r3, #3
   15214:	f363 128f 	bfi	r2, r3, #6, #10
   15218:	4804      	ldr	r0, [pc, #16]	; (1522c <hci_data_buf_overflow+0x38>)
   1521a:	f013 bb9b 	b.w	28954 <log_1>
}
   1521e:	4770      	bx	lr
   15220:	20010004 	.word	0x20010004
   15224:	0002db28 	.word	0x0002db28
   15228:	0002dc00 	.word	0x0002dc00
   1522c:	00030a09 	.word	0x00030a09

00015230 <le_data_len_change>:
	u16_t handle = sys_le16_to_cpu(evt->handle);
   15230:	6883      	ldr	r3, [r0, #8]
{
   15232:	b510      	push	{r4, lr}
	u16_t handle = sys_le16_to_cpu(evt->handle);
   15234:	881c      	ldrh	r4, [r3, #0]
	conn = bt_conn_lookup_handle(handle);
   15236:	4620      	mov	r0, r4
   15238:	f002 ff0c 	bl	18054 <bt_conn_lookup_handle>
	if (!conn) {
   1523c:	b9a0      	cbnz	r0, 15268 <le_data_len_change+0x38>
		BT_ERR("Unable to lookup conn for handle %u", handle);
   1523e:	4b0d      	ldr	r3, [pc, #52]	; (15274 <le_data_len_change+0x44>)
   15240:	681b      	ldr	r3, [r3, #0]
   15242:	075b      	lsls	r3, r3, #29
   15244:	d014      	beq.n	15270 <le_data_len_change+0x40>
   15246:	2301      	movs	r3, #1
   15248:	f04f 0200 	mov.w	r2, #0
   1524c:	f363 0207 	bfi	r2, r3, #0, #8
   15250:	4909      	ldr	r1, [pc, #36]	; (15278 <le_data_len_change+0x48>)
   15252:	4b0a      	ldr	r3, [pc, #40]	; (1527c <le_data_len_change+0x4c>)
   15254:	480a      	ldr	r0, [pc, #40]	; (15280 <le_data_len_change+0x50>)
   15256:	1a5b      	subs	r3, r3, r1
   15258:	08db      	lsrs	r3, r3, #3
   1525a:	4621      	mov	r1, r4
   1525c:	f363 128f 	bfi	r2, r3, #6, #10
}
   15260:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		BT_ERR("Unable to lookup conn for handle %u", handle);
   15264:	f013 bb76 	b.w	28954 <log_1>
}
   15268:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_conn_unref(conn);
   1526c:	f015 bbcc 	b.w	2aa08 <bt_conn_unref>
}
   15270:	bd10      	pop	{r4, pc}
   15272:	bf00      	nop
   15274:	20010004 	.word	0x20010004
   15278:	0002db28 	.word	0x0002db28
   1527c:	0002dc00 	.word	0x0002dc00
   15280:	00030ce4 	.word	0x00030ce4

00015284 <le_conn_update_complete>:
{
   15284:	b573      	push	{r0, r1, r4, r5, r6, lr}
	struct bt_hci_evt_le_conn_update_complete *evt = (void *)buf->data;
   15286:	6885      	ldr	r5, [r0, #8]
	handle = sys_le16_to_cpu(evt->handle);
   15288:	f8b5 6001 	ldrh.w	r6, [r5, #1]
	conn = bt_conn_lookup_handle(handle);
   1528c:	4630      	mov	r0, r6
   1528e:	f002 fee1 	bl	18054 <bt_conn_lookup_handle>
	if (!conn) {
   15292:	4604      	mov	r4, r0
   15294:	b9a0      	cbnz	r0, 152c0 <le_conn_update_complete+0x3c>
		BT_ERR("Unable to lookup conn for handle %u", handle);
   15296:	4b23      	ldr	r3, [pc, #140]	; (15324 <le_conn_update_complete+0xa0>)
   15298:	681b      	ldr	r3, [r3, #0]
   1529a:	075a      	lsls	r2, r3, #29
   1529c:	d00e      	beq.n	152bc <le_conn_update_complete+0x38>
   1529e:	2301      	movs	r3, #1
   152a0:	f04f 0200 	mov.w	r2, #0
   152a4:	f363 0207 	bfi	r2, r3, #0, #8
   152a8:	491f      	ldr	r1, [pc, #124]	; (15328 <le_conn_update_complete+0xa4>)
   152aa:	4b20      	ldr	r3, [pc, #128]	; (1532c <le_conn_update_complete+0xa8>)
   152ac:	4820      	ldr	r0, [pc, #128]	; (15330 <le_conn_update_complete+0xac>)
   152ae:	1a5b      	subs	r3, r3, r1
   152b0:	08db      	lsrs	r3, r3, #3
   152b2:	f363 128f 	bfi	r2, r3, #6, #10
   152b6:	4631      	mov	r1, r6
   152b8:	f013 fb4c 	bl	28954 <log_1>
}
   152bc:	b002      	add	sp, #8
   152be:	bd70      	pop	{r4, r5, r6, pc}
	if (!evt->status) {
   152c0:	782b      	ldrb	r3, [r5, #0]
   152c2:	b9bb      	cbnz	r3, 152f4 <le_conn_update_complete+0x70>
		conn->le.interval = sys_le16_to_cpu(evt->interval);
   152c4:	792a      	ldrb	r2, [r5, #4]
   152c6:	78eb      	ldrb	r3, [r5, #3]
   152c8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   152cc:	f8a0 3086 	strh.w	r3, [r0, #134]	; 0x86
		conn->le.latency = sys_le16_to_cpu(evt->latency);
   152d0:	79aa      	ldrb	r2, [r5, #6]
   152d2:	796b      	ldrb	r3, [r5, #5]
   152d4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   152d8:	f8a0 308c 	strh.w	r3, [r0, #140]	; 0x8c
		conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
   152dc:	79eb      	ldrb	r3, [r5, #7]
   152de:	7a2a      	ldrb	r2, [r5, #8]
   152e0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   152e4:	f8a0 308e 	strh.w	r3, [r0, #142]	; 0x8e
		notify_le_param_updated(conn);
   152e8:	f002 fb88 	bl	179fc <notify_le_param_updated>
	bt_conn_unref(conn);
   152ec:	4620      	mov	r0, r4
   152ee:	f015 fb8b 	bl	2aa08 <bt_conn_unref>
   152f2:	e7e3      	b.n	152bc <le_conn_update_complete+0x38>
	} else if (evt->status == BT_HCI_ERR_UNSUPP_REMOTE_FEATURE &&
   152f4:	2b1a      	cmp	r3, #26
   152f6:	d1f9      	bne.n	152ec <le_conn_update_complete+0x68>
   152f8:	78c3      	ldrb	r3, [r0, #3]
   152fa:	2b01      	cmp	r3, #1
   152fc:	d1f6      	bne.n	152ec <le_conn_update_complete+0x68>
static inline bool atomic_test_and_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
	atomic_val_t old;

	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   152fe:	f44f 6180 	mov.w	r1, #1024	; 0x400
   15302:	3004      	adds	r0, #4
   15304:	f015 fa14 	bl	2a730 <atomic_or>
		   conn->role == BT_HCI_ROLE_SLAVE &&
   15308:	0543      	lsls	r3, r0, #21
   1530a:	d4ef      	bmi.n	152ec <le_conn_update_complete+0x68>
		param.interval_min = conn->le.interval_min;
   1530c:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
   15310:	9300      	str	r3, [sp, #0]
		bt_l2cap_update_conn_param(conn, &param);
   15312:	4669      	mov	r1, sp
		param.latency = conn->le.pending_latency;
   15314:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
   15318:	9301      	str	r3, [sp, #4]
		bt_l2cap_update_conn_param(conn, &param);
   1531a:	4620      	mov	r0, r4
   1531c:	f003 fbc8 	bl	18ab0 <bt_l2cap_update_conn_param>
   15320:	e7e4      	b.n	152ec <le_conn_update_complete+0x68>
   15322:	bf00      	nop
   15324:	20010004 	.word	0x20010004
   15328:	0002db28 	.word	0x0002db28
   1532c:	0002dc00 	.word	0x0002dc00
   15330:	00030ce4 	.word	0x00030ce4

00015334 <hci_vendor_event>:
		BT_WARN("Unhandled vendor-specific event: %s",
   15334:	4b0f      	ldr	r3, [pc, #60]	; (15374 <hci_vendor_event+0x40>)
   15336:	681b      	ldr	r3, [r3, #0]
   15338:	f013 0f06 	tst.w	r3, #6
{
   1533c:	b510      	push	{r4, lr}
		BT_WARN("Unhandled vendor-specific event: %s",
   1533e:	d017      	beq.n	15370 <hci_vendor_event+0x3c>
   15340:	2302      	movs	r3, #2
   15342:	f04f 0400 	mov.w	r4, #0
   15346:	4a0c      	ldr	r2, [pc, #48]	; (15378 <hci_vendor_event+0x44>)
   15348:	8981      	ldrh	r1, [r0, #12]
   1534a:	6880      	ldr	r0, [r0, #8]
   1534c:	f363 0407 	bfi	r4, r3, #0, #8
   15350:	4b0a      	ldr	r3, [pc, #40]	; (1537c <hci_vendor_event+0x48>)
   15352:	1a9b      	subs	r3, r3, r2
   15354:	08db      	lsrs	r3, r3, #3
   15356:	f363 148f 	bfi	r4, r3, #6, #10
   1535a:	f7ff fe91 	bl	15080 <bt_hex_real>
   1535e:	f7fb fecd 	bl	110fc <log_strdup>
   15362:	4622      	mov	r2, r4
   15364:	4601      	mov	r1, r0
}
   15366:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		BT_WARN("Unhandled vendor-specific event: %s",
   1536a:	4805      	ldr	r0, [pc, #20]	; (15380 <hci_vendor_event+0x4c>)
   1536c:	f013 baf2 	b.w	28954 <log_1>
}
   15370:	bd10      	pop	{r4, pc}
   15372:	bf00      	nop
   15374:	20010004 	.word	0x20010004
   15378:	0002db28 	.word	0x0002db28
   1537c:	0002dc00 	.word	0x0002dc00
   15380:	00030c84 	.word	0x00030c84

00015384 <handle_event>:
{
   15384:	b573      	push	{r0, r1, r4, r5, r6, lr}
   15386:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   1538a:	4604      	mov	r4, r0
   1538c:	4608      	mov	r0, r1
		if (handler->event != event) {
   1538e:	7811      	ldrb	r1, [r2, #0]
   15390:	42a1      	cmp	r1, r4
   15392:	d023      	beq.n	153dc <handle_event+0x58>
			continue;
   15394:	3208      	adds	r2, #8
	for (i = 0; i < num_handlers; i++) {
   15396:	4293      	cmp	r3, r2
   15398:	d1f9      	bne.n	1538e <handle_event+0xa>
	BT_WARN("Unhandled event 0x%02x len %u: %s", event,
   1539a:	4b20      	ldr	r3, [pc, #128]	; (1541c <handle_event+0x98>)
   1539c:	681b      	ldr	r3, [r3, #0]
   1539e:	f013 0f06 	tst.w	r3, #6
   153a2:	d019      	beq.n	153d8 <handle_event+0x54>
   153a4:	2302      	movs	r3, #2
   153a6:	f04f 0500 	mov.w	r5, #0
   153aa:	4a1d      	ldr	r2, [pc, #116]	; (15420 <handle_event+0x9c>)
   153ac:	8986      	ldrh	r6, [r0, #12]
   153ae:	6880      	ldr	r0, [r0, #8]
   153b0:	f363 0507 	bfi	r5, r3, #0, #8
   153b4:	4b1b      	ldr	r3, [pc, #108]	; (15424 <handle_event+0xa0>)
   153b6:	1a9b      	subs	r3, r3, r2
   153b8:	08db      	lsrs	r3, r3, #3
   153ba:	4631      	mov	r1, r6
   153bc:	f363 158f 	bfi	r5, r3, #6, #10
   153c0:	f7ff fe5e 	bl	15080 <bt_hex_real>
   153c4:	f7fb fe9a 	bl	110fc <log_strdup>
   153c8:	f8ad 5000 	strh.w	r5, [sp]
   153cc:	4603      	mov	r3, r0
   153ce:	4632      	mov	r2, r6
   153d0:	4621      	mov	r1, r4
   153d2:	4815      	ldr	r0, [pc, #84]	; (15428 <handle_event+0xa4>)
   153d4:	f013 faea 	bl	289ac <log_3>
}
   153d8:	b002      	add	sp, #8
   153da:	bd70      	pop	{r4, r5, r6, pc}
		if (buf->len < handler->min_len) {
   153dc:	8981      	ldrh	r1, [r0, #12]
   153de:	7853      	ldrb	r3, [r2, #1]
   153e0:	428b      	cmp	r3, r1
   153e2:	d915      	bls.n	15410 <handle_event+0x8c>
			BT_ERR("Too small (%u bytes) event 0x%02x",
   153e4:	4b0d      	ldr	r3, [pc, #52]	; (1541c <handle_event+0x98>)
   153e6:	681b      	ldr	r3, [r3, #0]
   153e8:	075b      	lsls	r3, r3, #29
   153ea:	d0f5      	beq.n	153d8 <handle_event+0x54>
   153ec:	2201      	movs	r2, #1
   153ee:	f04f 0300 	mov.w	r3, #0
   153f2:	f362 0307 	bfi	r3, r2, #0, #8
   153f6:	480a      	ldr	r0, [pc, #40]	; (15420 <handle_event+0x9c>)
   153f8:	4a0a      	ldr	r2, [pc, #40]	; (15424 <handle_event+0xa0>)
   153fa:	1a12      	subs	r2, r2, r0
   153fc:	08d2      	lsrs	r2, r2, #3
   153fe:	480b      	ldr	r0, [pc, #44]	; (1542c <handle_event+0xa8>)
   15400:	f362 138f 	bfi	r3, r2, #6, #10
   15404:	4622      	mov	r2, r4
}
   15406:	b002      	add	sp, #8
   15408:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			BT_ERR("Too small (%u bytes) event 0x%02x",
   1540c:	f013 bab6 	b.w	2897c <log_2>
		handler->handler(buf);
   15410:	6853      	ldr	r3, [r2, #4]
}
   15412:	b002      	add	sp, #8
   15414:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		handler->handler(buf);
   15418:	4718      	bx	r3
   1541a:	bf00      	nop
   1541c:	20010004 	.word	0x20010004
   15420:	0002db28 	.word	0x0002db28
   15424:	0002dc00 	.word	0x0002dc00
   15428:	0003097f 	.word	0x0003097f
   1542c:	0003095d 	.word	0x0003095d

00015430 <hci_le_meta_event>:
{
   15430:	b510      	push	{r4, lr}
	evt = net_buf_pull_mem(buf, sizeof(*evt));
   15432:	2101      	movs	r1, #1
{
   15434:	4604      	mov	r4, r0
	evt = net_buf_pull_mem(buf, sizeof(*evt));
   15436:	3008      	adds	r0, #8
   15438:	f017 fbd3 	bl	2cbe2 <net_buf_simple_pull_mem>
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
   1543c:	4621      	mov	r1, r4
   1543e:	2308      	movs	r3, #8
   15440:	4a02      	ldr	r2, [pc, #8]	; (1544c <hci_le_meta_event+0x1c>)
   15442:	7800      	ldrb	r0, [r0, #0]
}
   15444:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	handle_event(evt->subevent, buf, meta_events, ARRAY_SIZE(meta_events));
   15448:	f7ff bf9c 	b.w	15384 <handle_event>
   1544c:	0002e444 	.word	0x0002e444

00015450 <hci_cmd_done>:
{
   15450:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   15454:	4606      	mov	r6, r0
   15456:	b085      	sub	sp, #20
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
   15458:	7990      	ldrb	r0, [r2, #6]
   1545a:	f8df 8108 	ldr.w	r8, [pc, #264]	; 15564 <hci_cmd_done+0x114>
{
   1545e:	460f      	mov	r7, r1
   15460:	4615      	mov	r5, r2
	if (net_buf_pool_get(buf->pool_id) != &hci_cmd_pool) {
   15462:	f00f fe97 	bl	25194 <net_buf_pool_get>
   15466:	4580      	cmp	r8, r0
   15468:	d01f      	beq.n	154aa <hci_cmd_done+0x5a>
		BT_WARN("opcode 0x%04x pool id %u pool %p != &hci_cmd_pool %p",
   1546a:	4b38      	ldr	r3, [pc, #224]	; (1554c <hci_cmd_done+0xfc>)
   1546c:	681b      	ldr	r3, [r3, #0]
   1546e:	f013 0f06 	tst.w	r3, #6
   15472:	d017      	beq.n	154a4 <hci_cmd_done+0x54>
   15474:	2302      	movs	r3, #2
   15476:	f04f 0400 	mov.w	r4, #0
   1547a:	f363 0407 	bfi	r4, r3, #0, #8
   1547e:	4a34      	ldr	r2, [pc, #208]	; (15550 <hci_cmd_done+0x100>)
   15480:	4b34      	ldr	r3, [pc, #208]	; (15554 <hci_cmd_done+0x104>)
   15482:	79a8      	ldrb	r0, [r5, #6]
   15484:	9600      	str	r6, [sp, #0]
   15486:	1ad2      	subs	r2, r2, r3
   15488:	08d2      	lsrs	r2, r2, #3
   1548a:	f362 148f 	bfi	r4, r2, #6, #10
   1548e:	9001      	str	r0, [sp, #4]
   15490:	f00f fe80 	bl	25194 <net_buf_pool_get>
   15494:	4623      	mov	r3, r4
   15496:	e9cd 0802 	strd	r0, r8, [sp, #8]
   1549a:	2204      	movs	r2, #4
   1549c:	4669      	mov	r1, sp
   1549e:	482e      	ldr	r0, [pc, #184]	; (15558 <hci_cmd_done+0x108>)
   154a0:	f013 fa9f 	bl	289e2 <log_n>
}
   154a4:	b005      	add	sp, #20
   154a6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (cmd(buf)->opcode != opcode) {
   154aa:	4628      	mov	r0, r5
   154ac:	f00f fe78 	bl	251a0 <net_buf_id>
   154b0:	4c2a      	ldr	r4, [pc, #168]	; (1555c <hci_cmd_done+0x10c>)
   154b2:	f04f 080c 	mov.w	r8, #12
   154b6:	fb08 4000 	mla	r0, r8, r0, r4
   154ba:	8843      	ldrh	r3, [r0, #2]
   154bc:	42b3      	cmp	r3, r6
   154be:	d01a      	beq.n	154f6 <hci_cmd_done+0xa6>
		BT_WARN("OpCode 0x%04x completed instead of expected 0x%04x",
   154c0:	4b22      	ldr	r3, [pc, #136]	; (1554c <hci_cmd_done+0xfc>)
   154c2:	681b      	ldr	r3, [r3, #0]
   154c4:	f013 0f06 	tst.w	r3, #6
   154c8:	d015      	beq.n	154f6 <hci_cmd_done+0xa6>
   154ca:	2302      	movs	r3, #2
   154cc:	f04f 0900 	mov.w	r9, #0
   154d0:	f363 0907 	bfi	r9, r3, #0, #8
   154d4:	4a1e      	ldr	r2, [pc, #120]	; (15550 <hci_cmd_done+0x100>)
   154d6:	4b1f      	ldr	r3, [pc, #124]	; (15554 <hci_cmd_done+0x104>)
   154d8:	1ad2      	subs	r2, r2, r3
   154da:	08d2      	lsrs	r2, r2, #3
   154dc:	4628      	mov	r0, r5
   154de:	f362 198f 	bfi	r9, r2, #6, #10
   154e2:	f00f fe5d 	bl	251a0 <net_buf_id>
   154e6:	fb08 4000 	mla	r0, r8, r0, r4
   154ea:	464b      	mov	r3, r9
   154ec:	8842      	ldrh	r2, [r0, #2]
   154ee:	481c      	ldr	r0, [pc, #112]	; (15560 <hci_cmd_done+0x110>)
   154f0:	4631      	mov	r1, r6
   154f2:	f013 fa43 	bl	2897c <log_2>
	if (cmd(buf)->state && !status) {
   154f6:	4628      	mov	r0, r5
   154f8:	f00f fe52 	bl	251a0 <net_buf_id>
   154fc:	260c      	movs	r6, #12
   154fe:	fb06 4000 	mla	r0, r6, r0, r4
   15502:	6843      	ldr	r3, [r0, #4]
   15504:	b15b      	cbz	r3, 1551e <hci_cmd_done+0xce>
   15506:	b957      	cbnz	r7, 1551e <hci_cmd_done+0xce>
		struct cmd_state_set *update = cmd(buf)->state;
   15508:	4628      	mov	r0, r5
   1550a:	f00f fe49 	bl	251a0 <net_buf_id>
   1550e:	fb06 4000 	mla	r0, r6, r0, r4
   15512:	6843      	ldr	r3, [r0, #4]
		atomic_set_bit_to(update->target, update->bit, update->val);
   15514:	7a1a      	ldrb	r2, [r3, #8]
   15516:	e9d3 0100 	ldrd	r0, r1, [r3]
   1551a:	f015 f927 	bl	2a76c <atomic_set_bit_to>
	if (cmd(buf)->sync) {
   1551e:	4628      	mov	r0, r5
   15520:	f00f fe3e 	bl	251a0 <net_buf_id>
   15524:	260c      	movs	r6, #12
   15526:	fb06 4000 	mla	r0, r6, r0, r4
   1552a:	6883      	ldr	r3, [r0, #8]
   1552c:	2b00      	cmp	r3, #0
   1552e:	d0b9      	beq.n	154a4 <hci_cmd_done+0x54>
		cmd(buf)->status = status;
   15530:	4628      	mov	r0, r5
   15532:	f00f fe35 	bl	251a0 <net_buf_id>
   15536:	4370      	muls	r0, r6
   15538:	5427      	strb	r7, [r4, r0]
		k_sem_give(cmd(buf)->sync);
   1553a:	4628      	mov	r0, r5
   1553c:	f00f fe30 	bl	251a0 <net_buf_id>
   15540:	fb06 4000 	mla	r0, r6, r0, r4
   15544:	6880      	ldr	r0, [r0, #8]
	z_impl_k_sem_give(sem);
   15546:	f011 fddf 	bl	27108 <z_impl_k_sem_give>
   1554a:	e7ab      	b.n	154a4 <hci_cmd_done+0x54>
   1554c:	20010004 	.word	0x20010004
   15550:	0002dc00 	.word	0x0002dc00
   15554:	0002db28 	.word	0x0002db28
   15558:	000309a1 	.word	0x000309a1
   1555c:	200009fc 	.word	0x200009fc
   15560:	000309d6 	.word	0x000309d6
   15564:	200101e0 	.word	0x200101e0

00015568 <id_find>:
	memcpy(addrs, bt_dev.id_addr, to_copy * sizeof(bt_addr_le_t));
	*count = to_copy;
}

static int id_find(const bt_addr_le_t *addr)
{
   15568:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u8_t id;

	for (id = 0U; id < bt_dev.id_count; id++) {
   1556a:	4e0b      	ldr	r6, [pc, #44]	; (15598 <id_find+0x30>)
{
   1556c:	4607      	mov	r7, r0
	for (id = 0U; id < bt_dev.id_count; id++) {
   1556e:	2500      	movs	r5, #0
   15570:	79f3      	ldrb	r3, [r6, #7]
   15572:	b2ec      	uxtb	r4, r5
   15574:	42a3      	cmp	r3, r4
   15576:	d802      	bhi.n	1557e <id_find+0x16>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
			return id;
		}
	}

	return -ENOENT;
   15578:	f06f 0401 	mvn.w	r4, #1
   1557c:	e009      	b.n	15592 <id_find+0x2a>
		if (!bt_addr_le_cmp(addr, &bt_dev.id_addr[id])) {
   1557e:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
	return memcmp(a, b, sizeof(*a));
}

static inline int bt_addr_le_cmp(const bt_addr_le_t *a, const bt_addr_le_t *b)
{
	return memcmp(a, b, sizeof(*a));
   15582:	2207      	movs	r2, #7
   15584:	4431      	add	r1, r6
   15586:	4638      	mov	r0, r7
   15588:	f014 ff3a 	bl	2a400 <memcmp>
   1558c:	3501      	adds	r5, #1
   1558e:	2800      	cmp	r0, #0
   15590:	d1ee      	bne.n	15570 <id_find+0x8>
}
   15592:	4620      	mov	r0, r4
   15594:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   15596:	bf00      	nop
   15598:	2000f720 	.word	0x2000f720

0001559c <slave_update_conn_param>:
{
   1559c:	b508      	push	{r3, lr}
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_UPDATE)) {
   1559e:	2108      	movs	r1, #8
{
   155a0:	4603      	mov	r3, r0
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_UPDATE)) {
   155a2:	3004      	adds	r0, #4
   155a4:	f015 f900 	bl	2a7a8 <atomic_test_bit>
   155a8:	b940      	cbnz	r0, 155bc <slave_update_conn_param+0x20>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   155aa:	f103 0150 	add.w	r1, r3, #80	; 0x50
   155ae:	f241 3288 	movw	r2, #5000	; 0x1388
   155b2:	4803      	ldr	r0, [pc, #12]	; (155c0 <slave_update_conn_param+0x24>)
}
   155b4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   155b8:	f011 bf40 	b.w	2743c <k_delayed_work_submit_to_queue>
   155bc:	bd08      	pop	{r3, pc}
   155be:	bf00      	nop
   155c0:	20003b5c 	.word	0x20003b5c

000155c4 <hci_num_completed_packets>:
{
   155c4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
				BT_ERR("packets count mismatch");
   155c8:	4b54      	ldr	r3, [pc, #336]	; (1571c <hci_num_completed_packets+0x158>)
   155ca:	4c55      	ldr	r4, [pc, #340]	; (15720 <hci_num_completed_packets+0x15c>)
	struct bt_hci_evt_num_completed_packets *evt = (void *)buf->data;
   155cc:	f8d0 9008 	ldr.w	r9, [r0, #8]
				BT_ERR("packets count mismatch");
   155d0:	1ae4      	subs	r4, r4, r3
   155d2:	f3c4 04c9 	ubfx	r4, r4, #3, #10
	for (i = 0; i < evt->num_handles; i++) {
   155d6:	2500      	movs	r5, #0
   155d8:	f899 3000 	ldrb.w	r3, [r9]
   155dc:	429d      	cmp	r5, r3
   155de:	db02      	blt.n	155e6 <hci_num_completed_packets+0x22>
}
   155e0:	b003      	add	sp, #12
   155e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		handle = sys_le16_to_cpu(evt->h[i].handle);
   155e6:	eb09 0385 	add.w	r3, r9, r5, lsl #2
   155ea:	f8b3 b001 	ldrh.w	fp, [r3, #1]
		count = sys_le16_to_cpu(evt->h[i].count);
   155ee:	f8b3 6003 	ldrh.w	r6, [r3, #3]
	__asm__ volatile(
   155f2:	f04f 0320 	mov.w	r3, #32
   155f6:	f3ef 8211 	mrs	r2, BASEPRI
   155fa:	f383 8811 	msr	BASEPRI, r3
   155fe:	f3bf 8f6f 	isb	sy
		conn = bt_conn_lookup_handle(handle);
   15602:	4658      	mov	r0, fp
   15604:	9201      	str	r2, [sp, #4]
   15606:	f002 fd25 	bl	18054 <bt_conn_lookup_handle>
		if (!conn) {
   1560a:	9a01      	ldr	r2, [sp, #4]
   1560c:	4682      	mov	sl, r0
   1560e:	b9b0      	cbnz	r0, 1563e <hci_num_completed_packets+0x7a>
	__asm__ volatile(
   15610:	f382 8811 	msr	BASEPRI, r2
   15614:	f3bf 8f6f 	isb	sy
			BT_ERR("No connection for handle %u", handle);
   15618:	4b42      	ldr	r3, [pc, #264]	; (15724 <hci_num_completed_packets+0x160>)
   1561a:	681b      	ldr	r3, [r3, #0]
   1561c:	0759      	lsls	r1, r3, #29
   1561e:	d00c      	beq.n	1563a <hci_num_completed_packets+0x76>
   15620:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
   15624:	f043 0301 	orr.w	r3, r3, #1
   15628:	f363 0707 	bfi	r7, r3, #0, #8
   1562c:	f364 178f 	bfi	r7, r4, #6, #10
   15630:	463a      	mov	r2, r7
   15632:	4659      	mov	r1, fp
   15634:	483c      	ldr	r0, [pc, #240]	; (15728 <hci_num_completed_packets+0x164>)
   15636:	f013 f98d 	bl	28954 <log_1>
	for (i = 0; i < evt->num_handles; i++) {
   1563a:	3501      	adds	r5, #1
   1563c:	e7cc      	b.n	155d8 <hci_num_completed_packets+0x14>
   1563e:	f382 8811 	msr	BASEPRI, r2
   15642:	f3bf 8f6f 	isb	sy
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   15646:	f100 0b28 	add.w	fp, r0, #40	; 0x28
		while (count--) {
   1564a:	2e00      	cmp	r6, #0
   1564c:	d03a      	beq.n	156c4 <hci_num_completed_packets+0x100>
	__asm__ volatile(
   1564e:	f04f 0220 	mov.w	r2, #32
   15652:	f3ef 8111 	mrs	r1, BASEPRI
   15656:	f382 8811 	msr	BASEPRI, r2
   1565a:	f3bf 8f6f 	isb	sy
			if (conn->pending_no_cb) {
   1565e:	f8da 201c 	ldr.w	r2, [sl, #28]
   15662:	b172      	cbz	r2, 15682 <hci_num_completed_packets+0xbe>
				conn->pending_no_cb--;
   15664:	3a01      	subs	r2, #1
   15666:	f8ca 201c 	str.w	r2, [sl, #28]
	__asm__ volatile(
   1566a:	f381 8811 	msr	BASEPRI, r1
   1566e:	f3bf 8f6f 	isb	sy
			k_sem_give(bt_conn_get_pkts(conn));
   15672:	4650      	mov	r0, sl
   15674:	f002 f9be 	bl	179f4 <bt_conn_get_pkts>
   15678:	3e01      	subs	r6, #1
   1567a:	f011 fd45 	bl	27108 <z_impl_k_sem_give>
   1567e:	b2b6      	uxth	r6, r6
   15680:	e7e3      	b.n	1564a <hci_num_completed_packets+0x86>
 *
 * @return a boolean, true if it's empty, false otherwise
 */
static inline bool sys_slist_is_empty(sys_slist_t *list);

Z_GENLIST_IS_EMPTY(slist)
   15682:	f8da 2014 	ldr.w	r2, [sl, #20]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
   15686:	b142      	cbz	r2, 1569a <hci_num_completed_packets+0xd6>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   15688:	f8da 0018 	ldr.w	r0, [sl, #24]
   1568c:	6813      	ldr	r3, [r2, #0]
	list->head = node;
   1568e:	f8ca 3014 	str.w	r3, [sl, #20]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   15692:	4282      	cmp	r2, r0
	list->tail = node;
   15694:	bf08      	it	eq
   15696:	f8ca 3018 	streq.w	r3, [sl, #24]
   1569a:	f381 8811 	msr	BASEPRI, r1
   1569e:	f3bf 8f6f 	isb	sy
			if (!node) {
   156a2:	b99a      	cbnz	r2, 156cc <hci_num_completed_packets+0x108>
				BT_ERR("packets count mismatch");
   156a4:	4a1f      	ldr	r2, [pc, #124]	; (15724 <hci_num_completed_packets+0x160>)
   156a6:	6812      	ldr	r2, [r2, #0]
   156a8:	0752      	lsls	r2, r2, #29
   156aa:	d00b      	beq.n	156c4 <hci_num_completed_packets+0x100>
   156ac:	f028 023f 	bic.w	r2, r8, #63	; 0x3f
   156b0:	f042 0201 	orr.w	r2, r2, #1
   156b4:	f362 0807 	bfi	r8, r2, #0, #8
   156b8:	f364 188f 	bfi	r8, r4, #6, #10
   156bc:	4641      	mov	r1, r8
   156be:	481b      	ldr	r0, [pc, #108]	; (1572c <hci_num_completed_packets+0x168>)
   156c0:	f013 f93b 	bl	2893a <log_0>
		bt_conn_unref(conn);
   156c4:	4650      	mov	r0, sl
   156c6:	f015 f99f 	bl	2aa08 <bt_conn_unref>
   156ca:	e7b6      	b.n	1563a <hci_num_completed_packets+0x76>
	__asm__ volatile(
   156cc:	f04f 0120 	mov.w	r1, #32
   156d0:	f3ef 8011 	mrs	r0, BASEPRI
   156d4:	f381 8811 	msr	BASEPRI, r1
   156d8:	f3bf 8f6f 	isb	sy
			tx->pending_no_cb = 0U;
   156dc:	2300      	movs	r3, #0
			conn->pending_no_cb = tx->pending_no_cb;
   156de:	68d1      	ldr	r1, [r2, #12]
   156e0:	f8ca 101c 	str.w	r1, [sl, #28]
	parent->next = child;
   156e4:	6013      	str	r3, [r2, #0]
Z_GENLIST_APPEND(slist, snode)
   156e6:	f8da 1024 	ldr.w	r1, [sl, #36]	; 0x24
			tx->pending_no_cb = 0U;
   156ea:	60d3      	str	r3, [r2, #12]
   156ec:	b989      	cbnz	r1, 15712 <hci_num_completed_packets+0x14e>
	list->head = node;
   156ee:	e9ca 2208 	strd	r2, r2, [sl, #32]
	__asm__ volatile(
   156f2:	f380 8811 	msr	BASEPRI, r0
   156f6:	f3bf 8f6f 	isb	sy
   156fa:	2101      	movs	r1, #1
   156fc:	f10a 0030 	add.w	r0, sl, #48	; 0x30
   15700:	f015 f816 	bl	2a730 <atomic_or>
   15704:	07c3      	lsls	r3, r0, #31
   15706:	d4b4      	bmi.n	15672 <hci_num_completed_packets+0xae>
		k_queue_append(&work_q->queue, work);
   15708:	4659      	mov	r1, fp
   1570a:	4809      	ldr	r0, [pc, #36]	; (15730 <hci_num_completed_packets+0x16c>)
   1570c:	f017 fcf9 	bl	2d102 <k_queue_append>
   15710:	e7af      	b.n	15672 <hci_num_completed_packets+0xae>
	parent->next = child;
   15712:	600a      	str	r2, [r1, #0]
	list->tail = node;
   15714:	f8ca 2024 	str.w	r2, [sl, #36]	; 0x24
   15718:	e7eb      	b.n	156f2 <hci_num_completed_packets+0x12e>
   1571a:	bf00      	nop
   1571c:	0002db28 	.word	0x0002db28
   15720:	0002dc00 	.word	0x0002dc00
   15724:	20010004 	.word	0x20010004
   15728:	00030be4 	.word	0x00030be4
   1572c:	00030c00 	.word	0x00030c00
   15730:	20003b5c 	.word	0x20003b5c

00015734 <hci_cmd_status>:
{
   15734:	b538      	push	{r3, r4, r5, lr}
	evt = net_buf_pull_mem(buf, sizeof(*evt));
   15736:	2104      	movs	r1, #4
{
   15738:	4604      	mov	r4, r0
	evt = net_buf_pull_mem(buf, sizeof(*evt));
   1573a:	3008      	adds	r0, #8
   1573c:	f017 fa51 	bl	2cbe2 <net_buf_simple_pull_mem>
	ncmd = evt->ncmd;
   15740:	7845      	ldrb	r5, [r0, #1]
	hci_cmd_done(opcode, evt->status, buf);
   15742:	7801      	ldrb	r1, [r0, #0]
   15744:	8840      	ldrh	r0, [r0, #2]
   15746:	4622      	mov	r2, r4
   15748:	f7ff fe82 	bl	15450 <hci_cmd_done>
	if (ncmd) {
   1574c:	b125      	cbz	r5, 15758 <hci_cmd_status+0x24>
   1574e:	4803      	ldr	r0, [pc, #12]	; (1575c <hci_cmd_status+0x28>)
}
   15750:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   15754:	f011 bcd8 	b.w	27108 <z_impl_k_sem_give>
   15758:	bd38      	pop	{r3, r4, r5, pc}
   1575a:	bf00      	nop
   1575c:	2000f7c8 	.word	0x2000f7c8

00015760 <hci_cmd_complete>:
{
   15760:	b538      	push	{r3, r4, r5, lr}
	evt = net_buf_pull_mem(buf, sizeof(*evt));
   15762:	2103      	movs	r1, #3
{
   15764:	4604      	mov	r4, r0
	evt = net_buf_pull_mem(buf, sizeof(*evt));
   15766:	3008      	adds	r0, #8
   15768:	f017 fa3b 	bl	2cbe2 <net_buf_simple_pull_mem>
	status = buf->data[0];
   1576c:	68a3      	ldr	r3, [r4, #8]
	ncmd = evt->ncmd;
   1576e:	7805      	ldrb	r5, [r0, #0]
	hci_cmd_done(opcode, status, buf);
   15770:	7819      	ldrb	r1, [r3, #0]
   15772:	f8b0 0001 	ldrh.w	r0, [r0, #1]
   15776:	4622      	mov	r2, r4
   15778:	f7ff fe6a 	bl	15450 <hci_cmd_done>
	if (ncmd) {
   1577c:	b125      	cbz	r5, 15788 <hci_cmd_complete+0x28>
   1577e:	4803      	ldr	r0, [pc, #12]	; (1578c <hci_cmd_complete+0x2c>)
}
   15780:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   15784:	f011 bcc0 	b.w	27108 <z_impl_k_sem_give>
   15788:	bd38      	pop	{r3, r4, r5, pc}
   1578a:	bf00      	nop
   1578c:	2000f7c8 	.word	0x2000f7c8

00015790 <bt_hci_cmd_create>:
{
   15790:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15794:	4681      	mov	r9, r0
   15796:	468a      	mov	sl, r1
	buf = net_buf_alloc(&hci_cmd_pool, K_FOREVER);
   15798:	4816      	ldr	r0, [pc, #88]	; (157f4 <bt_hci_cmd_create+0x64>)
	cmd(buf)->opcode = opcode;
   1579a:	4f17      	ldr	r7, [pc, #92]	; (157f8 <bt_hci_cmd_create+0x68>)
	buf = net_buf_alloc(&hci_cmd_pool, K_FOREVER);
   1579c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   157a0:	f017 f9ba 	bl	2cb18 <net_buf_alloc_fixed>
   157a4:	4604      	mov	r4, r0
	net_buf_reserve(buf, BT_BUF_RESERVE);
   157a6:	f100 0808 	add.w	r8, r0, #8
   157aa:	2100      	movs	r1, #0
 *  @param buf   Bluetooth buffer
 *  @param type  The BT_* type to set the buffer to
 */
static inline void bt_buf_set_type(struct net_buf *buf, enum bt_buf_type type)
{
	*(u8_t *)net_buf_user_data(buf) = type;
   157ac:	2600      	movs	r6, #0
   157ae:	4640      	mov	r0, r8
   157b0:	f017 f9d1 	bl	2cb56 <net_buf_simple_reserve>
   157b4:	7526      	strb	r6, [r4, #20]
	cmd(buf)->opcode = opcode;
   157b6:	4620      	mov	r0, r4
   157b8:	f00f fcf2 	bl	251a0 <net_buf_id>
   157bc:	250c      	movs	r5, #12
   157be:	fb05 7000 	mla	r0, r5, r0, r7
   157c2:	f8a0 9002 	strh.w	r9, [r0, #2]
	cmd(buf)->sync = NULL;
   157c6:	4620      	mov	r0, r4
   157c8:	f00f fcea 	bl	251a0 <net_buf_id>
   157cc:	fb05 7000 	mla	r0, r5, r0, r7
   157d0:	6086      	str	r6, [r0, #8]
	cmd(buf)->state = NULL;
   157d2:	4620      	mov	r0, r4
   157d4:	f00f fce4 	bl	251a0 <net_buf_id>
   157d8:	fb05 7000 	mla	r0, r5, r0, r7
	hdr = net_buf_add(buf, sizeof(*hdr));
   157dc:	2103      	movs	r1, #3
	cmd(buf)->state = NULL;
   157de:	6046      	str	r6, [r0, #4]
	hdr = net_buf_add(buf, sizeof(*hdr));
   157e0:	4640      	mov	r0, r8
   157e2:	f017 f9cd 	bl	2cb80 <net_buf_simple_add>
	hdr->param_len = param_len;
   157e6:	f880 a002 	strb.w	sl, [r0, #2]
	hdr->opcode = sys_cpu_to_le16(opcode);
   157ea:	f8a0 9000 	strh.w	r9, [r0]
}
   157ee:	4620      	mov	r0, r4
   157f0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   157f4:	200101e0 	.word	0x200101e0
   157f8:	200009fc 	.word	0x200009fc

000157fc <bt_hci_cmd_send_sync>:
{
   157fc:	b5f0      	push	{r4, r5, r6, r7, lr}
   157fe:	4615      	mov	r5, r2
   15800:	b087      	sub	sp, #28
	if (!buf) {
   15802:	460c      	mov	r4, r1
   15804:	b919      	cbnz	r1, 1580e <bt_hci_cmd_send_sync+0x12>
		buf = bt_hci_cmd_create(opcode, 0);
   15806:	f7ff ffc3 	bl	15790 <bt_hci_cmd_create>
		if (!buf) {
   1580a:	4604      	mov	r4, r0
   1580c:	b3a8      	cbz	r0, 1587a <bt_hci_cmd_send_sync+0x7e>
	z_impl_k_sem_init(sem, initial_count, limit);
   1580e:	2201      	movs	r2, #1
   15810:	2100      	movs	r1, #0
   15812:	4668      	mov	r0, sp
   15814:	f017 fdf7 	bl	2d406 <z_impl_k_sem_init>
	cmd(buf)->sync = &sync_sem;
   15818:	4620      	mov	r0, r4
   1581a:	f00f fcc1 	bl	251a0 <net_buf_id>
   1581e:	4f18      	ldr	r7, [pc, #96]	; (15880 <bt_hci_cmd_send_sync+0x84>)
   15820:	260c      	movs	r6, #12
   15822:	fb06 7000 	mla	r0, r6, r0, r7
   15826:	f8c0 d008 	str.w	sp, [r0, #8]
	net_buf_ref(buf);
   1582a:	4620      	mov	r0, r4
   1582c:	f017 f9a4 	bl	2cb78 <net_buf_ref>
	net_buf_put(&bt_dev.cmd_tx_queue, buf);
   15830:	4621      	mov	r1, r4
   15832:	4814      	ldr	r0, [pc, #80]	; (15884 <bt_hci_cmd_send_sync+0x88>)
   15834:	f017 f993 	bl	2cb5e <net_buf_put>
	return z_impl_k_sem_take(sem, timeout);
   15838:	f242 7110 	movw	r1, #10000	; 0x2710
   1583c:	4668      	mov	r0, sp
   1583e:	f011 fc8f 	bl	27160 <z_impl_k_sem_take>
	if (cmd(buf)->status) {
   15842:	4620      	mov	r0, r4
   15844:	f00f fcac 	bl	251a0 <net_buf_id>
   15848:	4370      	muls	r0, r6
   1584a:	5c3b      	ldrb	r3, [r7, r0]
   1584c:	b173      	cbz	r3, 1586c <bt_hci_cmd_send_sync+0x70>
		switch (cmd(buf)->status) {
   1584e:	4620      	mov	r0, r4
   15850:	f00f fca6 	bl	251a0 <net_buf_id>
   15854:	4370      	muls	r0, r6
   15856:	5c3b      	ldrb	r3, [r7, r0]
   15858:	2b09      	cmp	r3, #9
			err = -EIO;
   1585a:	bf0c      	ite	eq
   1585c:	f06f 053c 	mvneq.w	r5, #60	; 0x3c
   15860:	f06f 0504 	mvnne.w	r5, #4
			net_buf_unref(buf);
   15864:	4620      	mov	r0, r4
   15866:	f00f fd31 	bl	252cc <net_buf_unref>
   1586a:	e003      	b.n	15874 <bt_hci_cmd_send_sync+0x78>
		if (rsp) {
   1586c:	2d00      	cmp	r5, #0
   1586e:	d0f9      	beq.n	15864 <bt_hci_cmd_send_sync+0x68>
			*rsp = buf;
   15870:	602c      	str	r4, [r5, #0]
		err = 0;
   15872:	461d      	mov	r5, r3
}
   15874:	4628      	mov	r0, r5
   15876:	b007      	add	sp, #28
   15878:	bdf0      	pop	{r4, r5, r6, r7, pc}
			return -ENOBUFS;
   1587a:	f06f 0536 	mvn.w	r5, #54	; 0x36
   1587e:	e7f9      	b.n	15874 <bt_hci_cmd_send_sync+0x78>
   15880:	200009fc 	.word	0x200009fc
   15884:	2000f7e4 	.word	0x2000f7e4

00015888 <set_le_scan_enable>:
{
   15888:	b530      	push	{r4, r5, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_SCAN_ENABLE, sizeof(*cp));
   1588a:	2102      	movs	r1, #2
{
   1588c:	b085      	sub	sp, #20
   1588e:	4604      	mov	r4, r0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_SCAN_ENABLE, sizeof(*cp));
   15890:	f242 000c 	movw	r0, #8204	; 0x200c
   15894:	f7ff ff7c 	bl	15790 <bt_hci_cmd_create>
	if (!buf) {
   15898:	4605      	mov	r5, r0
   1589a:	b340      	cbz	r0, 158ee <set_le_scan_enable+0x66>
	cp = net_buf_add(buf, sizeof(*cp));
   1589c:	2102      	movs	r1, #2
   1589e:	3008      	adds	r0, #8
   158a0:	f017 f96e 	bl	2cb80 <net_buf_simple_add>
	if (enable == BT_HCI_LE_SCAN_ENABLE) {
   158a4:	2c01      	cmp	r4, #1
	cp = net_buf_add(buf, sizeof(*cp));
   158a6:	4603      	mov	r3, r0
	if (enable == BT_HCI_LE_SCAN_ENABLE) {
   158a8:	d11e      	bne.n	158e8 <set_le_scan_enable+0x60>
		cp->filter_dup = atomic_test_bit(bt_dev.flags,
   158aa:	210d      	movs	r1, #13
   158ac:	4811      	ldr	r0, [pc, #68]	; (158f4 <set_le_scan_enable+0x6c>)
   158ae:	f014 ff7b 	bl	2a7a8 <atomic_test_bit>
   158b2:	7058      	strb	r0, [r3, #1]
	cp->enable = enable;
   158b4:	701c      	strb	r4, [r3, #0]
	state->target = target;
   158b6:	4b0f      	ldr	r3, [pc, #60]	; (158f4 <set_le_scan_enable+0x6c>)
   158b8:	9301      	str	r3, [sp, #4]
	cmd_state_set_init(&state, bt_dev.flags, BT_DEV_SCANNING,
   158ba:	f004 0401 	and.w	r4, r4, #1
	state->bit = bit;
   158be:	230a      	movs	r3, #10
	cmd(buf)->state = &state;
   158c0:	4628      	mov	r0, r5
	state->bit = bit;
   158c2:	9302      	str	r3, [sp, #8]
	cmd_state_set_init(&state, bt_dev.flags, BT_DEV_SCANNING,
   158c4:	f88d 400c 	strb.w	r4, [sp, #12]
	cmd(buf)->state = &state;
   158c8:	f00f fc6a 	bl	251a0 <net_buf_id>
   158cc:	4a0a      	ldr	r2, [pc, #40]	; (158f8 <set_le_scan_enable+0x70>)
   158ce:	230c      	movs	r3, #12
   158d0:	fb03 2000 	mla	r0, r3, r0, r2
   158d4:	ab01      	add	r3, sp, #4
   158d6:	6043      	str	r3, [r0, #4]
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_SCAN_ENABLE, buf, NULL);
   158d8:	2200      	movs	r2, #0
   158da:	4629      	mov	r1, r5
   158dc:	f242 000c 	movw	r0, #8204	; 0x200c
   158e0:	f7ff ff8c 	bl	157fc <bt_hci_cmd_send_sync>
}
   158e4:	b005      	add	sp, #20
   158e6:	bd30      	pop	{r4, r5, pc}
		cp->filter_dup = BT_HCI_LE_SCAN_FILTER_DUP_DISABLE;
   158e8:	2200      	movs	r2, #0
   158ea:	7042      	strb	r2, [r0, #1]
   158ec:	e7e2      	b.n	158b4 <set_le_scan_enable+0x2c>
		return -ENOBUFS;
   158ee:	f06f 0036 	mvn.w	r0, #54	; 0x36
   158f2:	e7f7      	b.n	158e4 <set_le_scan_enable+0x5c>
   158f4:	2000f790 	.word	0x2000f790
   158f8:	200009fc 	.word	0x200009fc

000158fc <set_random_address>:
{
   158fc:	b570      	push	{r4, r5, r6, lr}
	return memcmp(a, b, sizeof(*a));
   158fe:	4d15      	ldr	r5, [pc, #84]	; (15954 <set_random_address+0x58>)
   15900:	2206      	movs	r2, #6
   15902:	f105 010a 	add.w	r1, r5, #10
   15906:	4606      	mov	r6, r0
   15908:	f014 fd7a 	bl	2a400 <memcmp>
	if (!bt_addr_cmp(addr, &bt_dev.random_addr.a)) {
   1590c:	4604      	mov	r4, r0
   1590e:	b1d8      	cbz	r0, 15948 <set_random_address+0x4c>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, sizeof(*addr));
   15910:	2106      	movs	r1, #6
   15912:	f242 0005 	movw	r0, #8197	; 0x2005
   15916:	f7ff ff3b 	bl	15790 <bt_hci_cmd_create>
	if (!buf) {
   1591a:	4604      	mov	r4, r0
   1591c:	b1b0      	cbz	r0, 1594c <set_random_address+0x50>
	net_buf_add_mem(buf, addr, sizeof(*addr));
   1591e:	2206      	movs	r2, #6
   15920:	4631      	mov	r1, r6
   15922:	3008      	adds	r0, #8
   15924:	f017 f932 	bl	2cb8c <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_RANDOM_ADDRESS, buf, NULL);
   15928:	4621      	mov	r1, r4
   1592a:	2200      	movs	r2, #0
   1592c:	f242 0005 	movw	r0, #8197	; 0x2005
   15930:	f7ff ff64 	bl	157fc <bt_hci_cmd_send_sync>
	if (err) {
   15934:	4604      	mov	r4, r0
   15936:	b938      	cbnz	r0, 15948 <set_random_address+0x4c>
}

static inline void bt_addr_copy(bt_addr_t *dst, const bt_addr_t *src)
{
	memcpy(dst, src, sizeof(*dst));
   15938:	2206      	movs	r2, #6
   1593a:	4631      	mov	r1, r6
   1593c:	f105 000a 	add.w	r0, r5, #10
   15940:	f014 fd85 	bl	2a44e <memcpy>
	bt_dev.random_addr.type = BT_ADDR_LE_RANDOM;
   15944:	2301      	movs	r3, #1
   15946:	726b      	strb	r3, [r5, #9]
}
   15948:	4620      	mov	r0, r4
   1594a:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOBUFS;
   1594c:	f06f 0436 	mvn.w	r4, #54	; 0x36
   15950:	e7fa      	b.n	15948 <set_random_address+0x4c>
   15952:	bf00      	nop
   15954:	2000f720 	.word	0x2000f720

00015958 <set_advertise_enable>:
{
   15958:	b530      	push	{r4, r5, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
   1595a:	2101      	movs	r1, #1
{
   1595c:	b085      	sub	sp, #20
   1595e:	4605      	mov	r5, r0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_ENABLE, 1);
   15960:	f242 000a 	movw	r0, #8202	; 0x200a
   15964:	f7ff ff14 	bl	15790 <bt_hci_cmd_create>
	if (!buf) {
   15968:	4604      	mov	r4, r0
   1596a:	b1e8      	cbz	r0, 159a8 <set_advertise_enable+0x50>
	if (enable) {
   1596c:	3008      	adds	r0, #8
   1596e:	b1cd      	cbz	r5, 159a4 <set_advertise_enable+0x4c>
		net_buf_add_u8(buf, BT_HCI_LE_ADV_ENABLE);
   15970:	2101      	movs	r1, #1
		net_buf_add_u8(buf, BT_HCI_LE_ADV_DISABLE);
   15972:	f017 f914 	bl	2cb9e <net_buf_simple_add_u8>
	state->target = target;
   15976:	4b0e      	ldr	r3, [pc, #56]	; (159b0 <set_advertise_enable+0x58>)
   15978:	9301      	str	r3, [sp, #4]
	cmd(buf)->state = &state;
   1597a:	4620      	mov	r0, r4
	state->bit = bit;
   1597c:	2306      	movs	r3, #6
   1597e:	9302      	str	r3, [sp, #8]
	state->val = val;
   15980:	f88d 500c 	strb.w	r5, [sp, #12]
	cmd(buf)->state = &state;
   15984:	f00f fc0c 	bl	251a0 <net_buf_id>
   15988:	4a0a      	ldr	r2, [pc, #40]	; (159b4 <set_advertise_enable+0x5c>)
   1598a:	230c      	movs	r3, #12
   1598c:	fb03 2000 	mla	r0, r3, r0, r2
   15990:	ab01      	add	r3, sp, #4
   15992:	6043      	str	r3, [r0, #4]
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_ENABLE, buf, NULL);
   15994:	2200      	movs	r2, #0
   15996:	4621      	mov	r1, r4
   15998:	f242 000a 	movw	r0, #8202	; 0x200a
   1599c:	f7ff ff2e 	bl	157fc <bt_hci_cmd_send_sync>
}
   159a0:	b005      	add	sp, #20
   159a2:	bd30      	pop	{r4, r5, pc}
		net_buf_add_u8(buf, BT_HCI_LE_ADV_DISABLE);
   159a4:	4629      	mov	r1, r5
   159a6:	e7e4      	b.n	15972 <set_advertise_enable+0x1a>
		return -ENOBUFS;
   159a8:	f06f 0036 	mvn.w	r0, #54	; 0x36
   159ac:	e7f8      	b.n	159a0 <set_advertise_enable+0x48>
   159ae:	bf00      	nop
   159b0:	2000f790 	.word	0x2000f790
   159b4:	200009fc 	.word	0x200009fc

000159b8 <set_ad>:
{
   159b8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   159bc:	460c      	mov	r4, r1
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
   159be:	2120      	movs	r1, #32
{
   159c0:	4682      	mov	sl, r0
   159c2:	4691      	mov	r9, r2
	buf = bt_hci_cmd_create(hci_op, sizeof(*set_data));
   159c4:	f7ff fee4 	bl	15790 <bt_hci_cmd_create>
	if (!buf) {
   159c8:	4607      	mov	r7, r0
   159ca:	2800      	cmp	r0, #0
   159cc:	d05d      	beq.n	15a8a <set_ad+0xd2>
	set_data = net_buf_add(buf, sizeof(*set_data));
   159ce:	2120      	movs	r1, #32
   159d0:	3008      	adds	r0, #8
   159d2:	f017 f8d5 	bl	2cb80 <net_buf_simple_add>
	(void)memset(set_data, 0, sizeof(*set_data));
   159d6:	2220      	movs	r2, #32
   159d8:	2100      	movs	r1, #0
	set_data = net_buf_add(buf, sizeof(*set_data));
   159da:	4605      	mov	r5, r0
	(void)memset(set_data, 0, sizeof(*set_data));
   159dc:	f014 fd61 	bl	2a4a2 <memset>
	for (c = 0; c < ad_len; c++) {
   159e0:	eb04 09c9 	add.w	r9, r4, r9, lsl #3
   159e4:	45a1      	cmp	r9, r4
   159e6:	d106      	bne.n	159f6 <set_ad+0x3e>
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
   159e8:	4639      	mov	r1, r7
   159ea:	4650      	mov	r0, sl
   159ec:	2200      	movs	r2, #0
}
   159ee:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return bt_hci_cmd_send_sync(hci_op, buf, NULL);
   159f2:	f7ff bf03 	b.w	157fc <bt_hci_cmd_send_sync>
		for (i = 0; i < ad[c].len; i++) {
   159f6:	6826      	ldr	r6, [r4, #0]
   159f8:	f04f 0b00 	mov.w	fp, #0
   159fc:	6863      	ldr	r3, [r4, #4]
   159fe:	455b      	cmp	r3, fp
   15a00:	d801      	bhi.n	15a06 <set_ad+0x4e>
   15a02:	3408      	adds	r4, #8
   15a04:	e7ee      	b.n	159e4 <set_ad+0x2c>
			if (set_data->len + len + 2 > 31) {
   15a06:	782b      	ldrb	r3, [r5, #0]
			int len = data[i].data_len;
   15a08:	7872      	ldrb	r2, [r6, #1]
			u8_t type = data[i].type;
   15a0a:	7831      	ldrb	r1, [r6, #0]
			if (set_data->len + len + 2 > 31) {
   15a0c:	1c98      	adds	r0, r3, #2
   15a0e:	eb00 0c02 	add.w	ip, r0, r2
   15a12:	f1bc 0f1f 	cmp.w	ip, #31
   15a16:	dd1d      	ble.n	15a54 <set_ad+0x9c>
				if (type != BT_DATA_NAME_COMPLETE || !len) {
   15a18:	2909      	cmp	r1, #9
				len = 31 - (set_data->len + 2);
   15a1a:	f1c3 021d 	rsb	r2, r3, #29
				if (type != BT_DATA_NAME_COMPLETE || !len) {
   15a1e:	d100      	bne.n	15a22 <set_ad+0x6a>
   15a20:	b9ba      	cbnz	r2, 15a52 <set_ad+0x9a>
					net_buf_unref(buf);
   15a22:	4638      	mov	r0, r7
   15a24:	f00f fc52 	bl	252cc <net_buf_unref>
					BT_ERR("Too big advertising data");
   15a28:	4b1a      	ldr	r3, [pc, #104]	; (15a94 <set_ad+0xdc>)
   15a2a:	681b      	ldr	r3, [r3, #0]
   15a2c:	075b      	lsls	r3, r3, #29
   15a2e:	d00d      	beq.n	15a4c <set_ad+0x94>
   15a30:	2301      	movs	r3, #1
   15a32:	f04f 0100 	mov.w	r1, #0
   15a36:	f363 0107 	bfi	r1, r3, #0, #8
   15a3a:	4a17      	ldr	r2, [pc, #92]	; (15a98 <set_ad+0xe0>)
   15a3c:	4b17      	ldr	r3, [pc, #92]	; (15a9c <set_ad+0xe4>)
   15a3e:	4818      	ldr	r0, [pc, #96]	; (15aa0 <set_ad+0xe8>)
   15a40:	1a9b      	subs	r3, r3, r2
   15a42:	08db      	lsrs	r3, r3, #3
   15a44:	f363 118f 	bfi	r1, r3, #6, #10
   15a48:	f012 ff77 	bl	2893a <log_0>
					return -EINVAL;
   15a4c:	f06f 0015 	mvn.w	r0, #21
   15a50:	e01d      	b.n	15a8e <set_ad+0xd6>
				type = BT_DATA_NAME_SHORTENED;
   15a52:	2108      	movs	r1, #8
			set_data->data[set_data->len++] = len + 1;
   15a54:	eb05 0c03 	add.w	ip, r5, r3
   15a58:	3301      	adds	r3, #1
   15a5a:	fa4f f882 	sxtb.w	r8, r2
			set_data->data[set_data->len++] = type;
   15a5e:	fa55 f383 	uxtab	r3, r5, r3
			set_data->data[set_data->len++] = len + 1;
   15a62:	f108 0e01 	add.w	lr, r8, #1
			set_data->data[set_data->len++] = type;
   15a66:	b2c0      	uxtb	r0, r0
			set_data->data[set_data->len++] = len + 1;
   15a68:	f88c e001 	strb.w	lr, [ip, #1]
			set_data->data[set_data->len++] = type;
   15a6c:	7028      	strb	r0, [r5, #0]
   15a6e:	7059      	strb	r1, [r3, #1]
			memcpy(&set_data->data[set_data->len], data[i].data,
   15a70:	3001      	adds	r0, #1
   15a72:	6871      	ldr	r1, [r6, #4]
   15a74:	4428      	add	r0, r5
   15a76:	f014 fcea 	bl	2a44e <memcpy>
			set_data->len += len;
   15a7a:	782b      	ldrb	r3, [r5, #0]
   15a7c:	4498      	add	r8, r3
   15a7e:	f885 8000 	strb.w	r8, [r5]
		for (i = 0; i < ad[c].len; i++) {
   15a82:	f10b 0b01 	add.w	fp, fp, #1
   15a86:	3608      	adds	r6, #8
   15a88:	e7b8      	b.n	159fc <set_ad+0x44>
		return -ENOBUFS;
   15a8a:	f06f 0036 	mvn.w	r0, #54	; 0x36
}
   15a8e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15a92:	bf00      	nop
   15a94:	20010004 	.word	0x20010004
   15a98:	0002db28 	.word	0x0002db28
   15a9c:	0002dc00 	.word	0x0002dc00
   15aa0:	00030d08 	.word	0x00030d08

00015aa4 <le_adv_update>:
}

static int le_adv_update(const struct bt_data *ad, size_t ad_len,
			 const struct bt_data *sd, size_t sd_len,
			 bool connectable, bool use_name)
{
   15aa4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15aa8:	b086      	sub	sp, #24
	struct bt_ad d[2] = {};
	struct bt_data data;
	int err;

	d[0].data = ad;
	d[0].len = ad_len;
   15aaa:	e9cd 0102 	strd	r0, r1, [sp, #8]
{
   15aae:	4615      	mov	r5, r2
   15ab0:	461e      	mov	r6, r3

	err = set_ad(BT_HCI_OP_LE_SET_ADV_DATA, d, 1);
   15ab2:	2201      	movs	r2, #1
	struct bt_ad d[2] = {};
   15ab4:	2300      	movs	r3, #0
	err = set_ad(BT_HCI_OP_LE_SET_ADV_DATA, d, 1);
   15ab6:	a902      	add	r1, sp, #8
   15ab8:	f242 0008 	movw	r0, #8200	; 0x2008
{
   15abc:	f89d 7030 	ldrb.w	r7, [sp, #48]	; 0x30
   15ac0:	f89d 8034 	ldrb.w	r8, [sp, #52]	; 0x34
	struct bt_ad d[2] = {};
   15ac4:	e9cd 3304 	strd	r3, r3, [sp, #16]
	err = set_ad(BT_HCI_OP_LE_SET_ADV_DATA, d, 1);
   15ac8:	f7ff ff76 	bl	159b8 <set_ad>
	if (err) {
   15acc:	4604      	mov	r4, r0
   15ace:	bb10      	cbnz	r0, 15b16 <le_adv_update+0x72>
		return err;
	}

	d[0].data = sd;
	d[0].len = sd_len;
   15ad0:	e9cd 5602 	strd	r5, r6, [sp, #8]

	if (use_name) {
   15ad4:	f1b8 0f00 	cmp.w	r8, #0
   15ad8:	d011      	beq.n	15afe <le_adv_update+0x5a>
		const char *name;

		if (sd) {
   15ada:	b115      	cbz	r5, 15ae2 <le_adv_update+0x3e>
	for (i = 0; i < ad_len; i++) {
   15adc:	4602      	mov	r2, r0
   15ade:	42b2      	cmp	r2, r6
   15ae0:	d11d      	bne.n	15b1e <le_adv_update+0x7a>
				return -EINVAL;
			}
		}

		name = bt_get_name();
		data = (struct bt_data)BT_DATA(
   15ae2:	4d14      	ldr	r5, [pc, #80]	; (15b34 <le_adv_update+0x90>)
   15ae4:	4628      	mov	r0, r5
   15ae6:	f014 fc69 	bl	2a3bc <strlen>
   15aea:	2309      	movs	r3, #9
   15aec:	f88d 3000 	strb.w	r3, [sp]
			BT_DATA_NAME_COMPLETE,
			name, strlen(name));

		d[1].data = &data;
		d[1].len = 1;
   15af0:	2301      	movs	r3, #1
		data = (struct bt_data)BT_DATA(
   15af2:	f88d 0001 	strb.w	r0, [sp, #1]
   15af6:	9501      	str	r5, [sp, #4]
		d[1].data = &data;
   15af8:	f8cd d010 	str.w	sp, [sp, #16]
		d[1].len = 1;
   15afc:	9305      	str	r3, [sp, #20]
	 * by previous calls.
	 * Clearing sd is done by calling set_ad() with NULL data and
	 * zero len.
	 * So following condition check is unusual but correct.
	 */
	if (d[0].data || d[1].data || connectable) {
   15afe:	9b02      	ldr	r3, [sp, #8]
   15b00:	b913      	cbnz	r3, 15b08 <le_adv_update+0x64>
   15b02:	9b04      	ldr	r3, [sp, #16]
   15b04:	b903      	cbnz	r3, 15b08 <le_adv_update+0x64>
   15b06:	b137      	cbz	r7, 15b16 <le_adv_update+0x72>
		err = set_ad(BT_HCI_OP_LE_SET_SCAN_RSP_DATA, d, 2);
   15b08:	2202      	movs	r2, #2
   15b0a:	a902      	add	r1, sp, #8
   15b0c:	f242 0009 	movw	r0, #8201	; 0x2009
   15b10:	f7ff ff52 	bl	159b8 <set_ad>
   15b14:	4604      	mov	r4, r0
			return err;
		}
	}

	return 0;
}
   15b16:	4620      	mov	r0, r4
   15b18:	b006      	add	sp, #24
   15b1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (ad[i].type == BT_DATA_NAME_COMPLETE ||
   15b1e:	f815 1032 	ldrb.w	r1, [r5, r2, lsl #3]
   15b22:	3908      	subs	r1, #8
   15b24:	2901      	cmp	r1, #1
   15b26:	d901      	bls.n	15b2c <le_adv_update+0x88>
	for (i = 0; i < ad_len; i++) {
   15b28:	3201      	adds	r2, #1
   15b2a:	e7d8      	b.n	15ade <le_adv_update+0x3a>
				return -EINVAL;
   15b2c:	f06f 0415 	mvn.w	r4, #21
   15b30:	e7f1      	b.n	15b16 <le_adv_update+0x72>
   15b32:	bf00      	nop
   15b34:	00030cc1 	.word	0x00030cc1

00015b38 <bt_data_parse>:
{
   15b38:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   15b3a:	4604      	mov	r4, r0
   15b3c:	460e      	mov	r6, r1
   15b3e:	4617      	mov	r7, r2
	while (ad->len > 1) {
   15b40:	88a3      	ldrh	r3, [r4, #4]
   15b42:	2b01      	cmp	r3, #1
   15b44:	d91b      	bls.n	15b7e <bt_data_parse+0x46>
		len = net_buf_simple_pull_u8(ad);
   15b46:	4620      	mov	r0, r4
   15b48:	f017 f853 	bl	2cbf2 <net_buf_simple_pull_u8>
		if (len == 0U) {
   15b4c:	4605      	mov	r5, r0
   15b4e:	b1b0      	cbz	r0, 15b7e <bt_data_parse+0x46>
		if (len > ad->len) {
   15b50:	88a2      	ldrh	r2, [r4, #4]
   15b52:	b283      	uxth	r3, r0
   15b54:	429a      	cmp	r2, r3
   15b56:	d214      	bcs.n	15b82 <bt_data_parse+0x4a>
			BT_WARN("Malformed data");
   15b58:	4b14      	ldr	r3, [pc, #80]	; (15bac <bt_data_parse+0x74>)
   15b5a:	681b      	ldr	r3, [r3, #0]
   15b5c:	f013 0f06 	tst.w	r3, #6
   15b60:	d00d      	beq.n	15b7e <bt_data_parse+0x46>
   15b62:	2302      	movs	r3, #2
   15b64:	f04f 0100 	mov.w	r1, #0
   15b68:	f363 0107 	bfi	r1, r3, #0, #8
   15b6c:	4a10      	ldr	r2, [pc, #64]	; (15bb0 <bt_data_parse+0x78>)
   15b6e:	4b11      	ldr	r3, [pc, #68]	; (15bb4 <bt_data_parse+0x7c>)
   15b70:	4811      	ldr	r0, [pc, #68]	; (15bb8 <bt_data_parse+0x80>)
   15b72:	1a9b      	subs	r3, r3, r2
   15b74:	08db      	lsrs	r3, r3, #3
   15b76:	f363 118f 	bfi	r1, r3, #6, #10
   15b7a:	f012 fede 	bl	2893a <log_0>
}
   15b7e:	b003      	add	sp, #12
   15b80:	bdf0      	pop	{r4, r5, r6, r7, pc}
		data.type = net_buf_simple_pull_u8(ad);
   15b82:	4620      	mov	r0, r4
   15b84:	f017 f835 	bl	2cbf2 <net_buf_simple_pull_u8>
		data.data_len = len - 1;
   15b88:	3d01      	subs	r5, #1
		data.type = net_buf_simple_pull_u8(ad);
   15b8a:	f88d 0000 	strb.w	r0, [sp]
		data.data = ad->data;
   15b8e:	6823      	ldr	r3, [r4, #0]
		data.data_len = len - 1;
   15b90:	f88d 5001 	strb.w	r5, [sp, #1]
		if (!func(&data, user_data)) {
   15b94:	4639      	mov	r1, r7
   15b96:	4668      	mov	r0, sp
		data.data = ad->data;
   15b98:	9301      	str	r3, [sp, #4]
		if (!func(&data, user_data)) {
   15b9a:	47b0      	blx	r6
   15b9c:	2800      	cmp	r0, #0
   15b9e:	d0ee      	beq.n	15b7e <bt_data_parse+0x46>
		net_buf_simple_pull(ad, len - 1);
   15ba0:	4629      	mov	r1, r5
   15ba2:	4620      	mov	r0, r4
   15ba4:	f017 f815 	bl	2cbd2 <net_buf_simple_pull>
   15ba8:	e7ca      	b.n	15b40 <bt_data_parse+0x8>
   15baa:	bf00      	nop
   15bac:	20010004 	.word	0x20010004
   15bb0:	0002db28 	.word	0x0002db28
   15bb4:	0002dc00 	.word	0x0002dc00
   15bb8:	0003066e 	.word	0x0003066e

00015bbc <id_create.isra.25>:
static void id_create(u8_t id, bt_addr_le_t *addr, u8_t *irk)
   15bbc:	b530      	push	{r4, r5, lr}
   15bbe:	4d14      	ldr	r5, [pc, #80]	; (15c10 <id_create.isra.25+0x54>)
   15bc0:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
   15bc4:	b085      	sub	sp, #20
   15bc6:	4405      	add	r5, r0
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
   15bc8:	460c      	mov	r4, r1
   15bca:	b179      	cbz	r1, 15bec <id_create.isra.25+0x30>
   15bcc:	2300      	movs	r3, #0
	return memcmp(a, b, sizeof(*a));
   15bce:	2207      	movs	r2, #7
   15bd0:	4669      	mov	r1, sp
   15bd2:	4620      	mov	r0, r4
   15bd4:	9300      	str	r3, [sp, #0]
   15bd6:	f8cd 3003 	str.w	r3, [sp, #3]
   15bda:	f014 fc11 	bl	2a400 <memcmp>
   15bde:	b128      	cbz	r0, 15bec <id_create.isra.25+0x30>
		bt_addr_le_copy(&bt_dev.id_addr[id], addr);
   15be0:	4621      	mov	r1, r4
   15be2:	4628      	mov	r0, r5
			bt_addr_le_copy(addr, &bt_dev.id_addr[id]);
   15be4:	f014 fda1 	bl	2a72a <bt_addr_le_copy>
}
   15be8:	b005      	add	sp, #20
   15bea:	bd30      	pop	{r4, r5, pc}
			bt_addr_le_create_static(&new_addr);
   15bec:	a802      	add	r0, sp, #8
   15bee:	f014 fe18 	bl	2a822 <bt_addr_le_create_static>
		} while (id_find(&new_addr) >= 0);
   15bf2:	a802      	add	r0, sp, #8
   15bf4:	f7ff fcb8 	bl	15568 <id_find>
   15bf8:	2800      	cmp	r0, #0
   15bfa:	daf7      	bge.n	15bec <id_create.isra.25+0x30>
		bt_addr_le_copy(&bt_dev.id_addr[id], &new_addr);
   15bfc:	a902      	add	r1, sp, #8
   15bfe:	4628      	mov	r0, r5
   15c00:	f014 fd93 	bl	2a72a <bt_addr_le_copy>
		if (addr) {
   15c04:	2c00      	cmp	r4, #0
   15c06:	d0ef      	beq.n	15be8 <id_create.isra.25+0x2c>
			bt_addr_le_copy(addr, &bt_dev.id_addr[id]);
   15c08:	4629      	mov	r1, r5
   15c0a:	4620      	mov	r0, r4
   15c0c:	e7ea      	b.n	15be4 <id_create.isra.25+0x28>
   15c0e:	bf00      	nop
   15c10:	2000f720 	.word	0x2000f720

00015c14 <bt_send>:
	return bt_dev.drv->send(buf);
   15c14:	4b02      	ldr	r3, [pc, #8]	; (15c20 <bt_send+0xc>)
   15c16:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
   15c1a:	691b      	ldr	r3, [r3, #16]
   15c1c:	4718      	bx	r3
   15c1e:	bf00      	nop
   15c20:	2000f720 	.word	0x2000f720

00015c24 <bt_hci_cmd_send>:
{
   15c24:	b538      	push	{r3, r4, r5, lr}
   15c26:	4604      	mov	r4, r0
	if (!buf) {
   15c28:	460d      	mov	r5, r1
   15c2a:	b919      	cbnz	r1, 15c34 <bt_hci_cmd_send+0x10>
		buf = bt_hci_cmd_create(opcode, 0);
   15c2c:	f7ff fdb0 	bl	15790 <bt_hci_cmd_create>
		if (!buf) {
   15c30:	4605      	mov	r5, r0
   15c32:	b330      	cbz	r0, 15c82 <bt_hci_cmd_send+0x5e>
	if (opcode == BT_HCI_OP_HOST_NUM_COMPLETED_PACKETS) {
   15c34:	f640 4335 	movw	r3, #3125	; 0xc35
   15c38:	429c      	cmp	r4, r3
   15c3a:	d11c      	bne.n	15c76 <bt_hci_cmd_send+0x52>
		err = bt_send(buf);
   15c3c:	4628      	mov	r0, r5
   15c3e:	f7ff ffe9 	bl	15c14 <bt_send>
		if (err) {
   15c42:	4604      	mov	r4, r0
   15c44:	b1a8      	cbz	r0, 15c72 <bt_hci_cmd_send+0x4e>
			BT_ERR("Unable to send to driver (err %d)", err);
   15c46:	4b10      	ldr	r3, [pc, #64]	; (15c88 <bt_hci_cmd_send+0x64>)
   15c48:	681b      	ldr	r3, [r3, #0]
   15c4a:	075b      	lsls	r3, r3, #29
   15c4c:	d00e      	beq.n	15c6c <bt_hci_cmd_send+0x48>
   15c4e:	2301      	movs	r3, #1
   15c50:	f04f 0200 	mov.w	r2, #0
   15c54:	f363 0207 	bfi	r2, r3, #0, #8
   15c58:	490c      	ldr	r1, [pc, #48]	; (15c8c <bt_hci_cmd_send+0x68>)
   15c5a:	4b0d      	ldr	r3, [pc, #52]	; (15c90 <bt_hci_cmd_send+0x6c>)
   15c5c:	1a5b      	subs	r3, r3, r1
   15c5e:	08db      	lsrs	r3, r3, #3
   15c60:	4601      	mov	r1, r0
   15c62:	f363 128f 	bfi	r2, r3, #6, #10
   15c66:	480b      	ldr	r0, [pc, #44]	; (15c94 <bt_hci_cmd_send+0x70>)
   15c68:	f012 fe74 	bl	28954 <log_1>
			net_buf_unref(buf);
   15c6c:	4628      	mov	r0, r5
   15c6e:	f00f fb2d 	bl	252cc <net_buf_unref>
}
   15c72:	4620      	mov	r0, r4
   15c74:	bd38      	pop	{r3, r4, r5, pc}
	net_buf_put(&bt_dev.cmd_tx_queue, buf);
   15c76:	4629      	mov	r1, r5
   15c78:	4807      	ldr	r0, [pc, #28]	; (15c98 <bt_hci_cmd_send+0x74>)
   15c7a:	f016 ff70 	bl	2cb5e <net_buf_put>
	return 0;
   15c7e:	2400      	movs	r4, #0
   15c80:	e7f7      	b.n	15c72 <bt_hci_cmd_send+0x4e>
			return -ENOBUFS;
   15c82:	f06f 0436 	mvn.w	r4, #54	; 0x36
   15c86:	e7f4      	b.n	15c72 <bt_hci_cmd_send+0x4e>
   15c88:	20010004 	.word	0x20010004
   15c8c:	0002db28 	.word	0x0002db28
   15c90:	0002dc00 	.word	0x0002dc00
   15c94:	00030741 	.word	0x00030741
   15c98:	2000f7e4 	.word	0x2000f7e4

00015c9c <start_le_scan>:
{
   15c9c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   15c9e:	4605      	mov	r5, r0
   15ca0:	460e      	mov	r6, r1
   15ca2:	4614      	mov	r4, r2
	(void)memset(&set_param, 0, sizeof(set_param));
   15ca4:	2100      	movs	r1, #0
   15ca6:	2207      	movs	r2, #7
   15ca8:	4668      	mov	r0, sp
   15caa:	f014 fbfa 	bl	2a4a2 <memset>
		set_param.addr_type =  bt_dev.id_addr[0].type;
   15cae:	4824      	ldr	r0, [pc, #144]	; (15d40 <start_le_scan+0xa4>)
	set_param.scan_type = scan_type;
   15cb0:	f88d 5000 	strb.w	r5, [sp]
		set_param.filter_policy = BT_HCI_LE_SCAN_FP_NO_WHITELIST;
   15cb4:	2300      	movs	r3, #0
   15cb6:	f88d 3006 	strb.w	r3, [sp, #6]
		if (!IS_ENABLED(CONFIG_BT_SCAN_WITH_IDENTITY) &&
   15cba:	2d01      	cmp	r5, #1
		set_param.addr_type =  bt_dev.id_addr[0].type;
   15cbc:	7803      	ldrb	r3, [r0, #0]
	set_param.interval = sys_cpu_to_le16(interval);
   15cbe:	f8ad 6001 	strh.w	r6, [sp, #1]
	set_param.window = sys_cpu_to_le16(window);
   15cc2:	f8ad 4003 	strh.w	r4, [sp, #3]
		set_param.addr_type =  bt_dev.id_addr[0].type;
   15cc6:	f88d 3005 	strb.w	r3, [sp, #5]
		if (!IS_ENABLED(CONFIG_BT_SCAN_WITH_IDENTITY) &&
   15cca:	d128      	bne.n	15d1e <start_le_scan+0x82>
		    !atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING)) {
   15ccc:	2106      	movs	r1, #6
   15cce:	3070      	adds	r0, #112	; 0x70
   15cd0:	f014 fd6a 	bl	2a7a8 <atomic_test_bit>
		    scan_type == BT_HCI_LE_SCAN_ACTIVE &&
   15cd4:	bb18      	cbnz	r0, 15d1e <start_le_scan+0x82>
			err = le_set_private_addr(BT_ID_DEFAULT);
   15cd6:	f014 fd70 	bl	2a7ba <le_set_private_addr.isra.22>
			if (err) {
   15cda:	4604      	mov	r4, r0
   15cdc:	bb48      	cbnz	r0, 15d32 <start_le_scan+0x96>
			set_param.addr_type = BT_ADDR_LE_RANDOM;
   15cde:	f88d 5005 	strb.w	r5, [sp, #5]
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_SCAN_PARAM, sizeof(set_param));
   15ce2:	2107      	movs	r1, #7
   15ce4:	f242 000b 	movw	r0, #8203	; 0x200b
   15ce8:	f7ff fd52 	bl	15790 <bt_hci_cmd_create>
	if (!buf) {
   15cec:	4604      	mov	r4, r0
   15cee:	b318      	cbz	r0, 15d38 <start_le_scan+0x9c>
	net_buf_add_mem(buf, &set_param, sizeof(set_param));
   15cf0:	2207      	movs	r2, #7
   15cf2:	4669      	mov	r1, sp
   15cf4:	3008      	adds	r0, #8
   15cf6:	f016 ff49 	bl	2cb8c <net_buf_simple_add_mem>
	bt_hci_cmd_send(BT_HCI_OP_LE_SET_SCAN_PARAM, buf);
   15cfa:	4621      	mov	r1, r4
   15cfc:	f242 000b 	movw	r0, #8203	; 0x200b
   15d00:	f7ff ff90 	bl	15c24 <bt_hci_cmd_send>
	err = set_le_scan_enable(BT_HCI_LE_SCAN_ENABLE);
   15d04:	2001      	movs	r0, #1
   15d06:	f7ff fdbf 	bl	15888 <set_le_scan_enable>
	if (err) {
   15d0a:	4604      	mov	r4, r0
   15d0c:	b988      	cbnz	r0, 15d32 <start_le_scan+0x96>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_ACTIVE_SCAN,
   15d0e:	1e6b      	subs	r3, r5, #1
   15d10:	425a      	negs	r2, r3
   15d12:	415a      	adcs	r2, r3
   15d14:	210c      	movs	r1, #12
   15d16:	480b      	ldr	r0, [pc, #44]	; (15d44 <start_le_scan+0xa8>)
   15d18:	f014 fd28 	bl	2a76c <atomic_set_bit_to>
	return 0;
   15d1c:	e009      	b.n	15d32 <start_le_scan+0x96>
		} else if (set_param.addr_type == BT_ADDR_LE_RANDOM) {
   15d1e:	f89d 3005 	ldrb.w	r3, [sp, #5]
   15d22:	2b01      	cmp	r3, #1
   15d24:	d1dd      	bne.n	15ce2 <start_le_scan+0x46>
			err = set_random_address(&bt_dev.id_addr[0].a);
   15d26:	4808      	ldr	r0, [pc, #32]	; (15d48 <start_le_scan+0xac>)
   15d28:	f7ff fde8 	bl	158fc <set_random_address>
			if (err) {
   15d2c:	4604      	mov	r4, r0
   15d2e:	2800      	cmp	r0, #0
   15d30:	d0d7      	beq.n	15ce2 <start_le_scan+0x46>
}
   15d32:	4620      	mov	r0, r4
   15d34:	b002      	add	sp, #8
   15d36:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOBUFS;
   15d38:	f06f 0436 	mvn.w	r4, #54	; 0x36
   15d3c:	e7f9      	b.n	15d32 <start_le_scan+0x96>
   15d3e:	bf00      	nop
   15d40:	2000f720 	.word	0x2000f720
   15d44:	2000f790 	.word	0x2000f790
   15d48:	2000f721 	.word	0x2000f721

00015d4c <bt_le_scan_update>:
{
   15d4c:	b570      	push	{r4, r5, r6, lr}
	if (atomic_test_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
   15d4e:	210b      	movs	r1, #11
{
   15d50:	4606      	mov	r6, r0
	if (atomic_test_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
   15d52:	481a      	ldr	r0, [pc, #104]	; (15dbc <bt_le_scan_update+0x70>)
   15d54:	f014 fd28 	bl	2a7a8 <atomic_test_bit>
   15d58:	4603      	mov	r3, r0
   15d5a:	b108      	cbz	r0, 15d60 <bt_le_scan_update+0x14>
			return 0;
   15d5c:	2000      	movs	r0, #0
   15d5e:	e029      	b.n	15db4 <bt_le_scan_update+0x68>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING)) {
   15d60:	210a      	movs	r1, #10
   15d62:	4816      	ldr	r0, [pc, #88]	; (15dbc <bt_le_scan_update+0x70>)
   15d64:	f014 fd20 	bl	2a7a8 <atomic_test_bit>
   15d68:	b9f8      	cbnz	r0, 15daa <bt_le_scan_update+0x5e>
		conn = bt_conn_lookup_state_le(NULL, BT_CONN_CONNECT);
   15d6a:	2103      	movs	r1, #3
   15d6c:	2000      	movs	r0, #0
   15d6e:	f002 f9bd 	bl	180ec <bt_conn_lookup_state_le>
		if (conn) {
   15d72:	4605      	mov	r5, r0
   15d74:	b9f8      	cbnz	r0, 15db6 <bt_le_scan_update+0x6a>
		conn = bt_conn_lookup_state_le(NULL, BT_CONN_CONNECT_SCAN);
   15d76:	2101      	movs	r1, #1
   15d78:	f002 f9b8 	bl	180ec <bt_conn_lookup_state_le>
		if (!conn) {
   15d7c:	4604      	mov	r4, r0
   15d7e:	2800      	cmp	r0, #0
   15d80:	d0ec      	beq.n	15d5c <bt_le_scan_update+0x10>
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);

	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   15d82:	f44f 5100 	mov.w	r1, #8192	; 0x2000
   15d86:	480d      	ldr	r0, [pc, #52]	; (15dbc <bt_le_scan_update+0x70>)
   15d88:	f014 fcd2 	bl	2a730 <atomic_or>
		bt_conn_unref(conn);
   15d8c:	4620      	mov	r0, r4
   15d8e:	f014 fe3b 	bl	2aa08 <bt_conn_unref>
			window = CONFIG_BT_BACKGROUND_SCAN_WINDOW;
   15d92:	2e00      	cmp	r6, #0
		return start_le_scan(BT_HCI_LE_SCAN_PASSIVE, interval, window);
   15d94:	4628      	mov	r0, r5
   15d96:	bf15      	itete	ne
   15d98:	2230      	movne	r2, #48	; 0x30
   15d9a:	2212      	moveq	r2, #18
   15d9c:	2160      	movne	r1, #96	; 0x60
   15d9e:	f44f 6100 	moveq.w	r1, #2048	; 0x800
}
   15da2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return start_le_scan(BT_HCI_LE_SCAN_PASSIVE, interval, window);
   15da6:	f7ff bf79 	b.w	15c9c <start_le_scan>
		err = set_le_scan_enable(BT_HCI_LE_SCAN_DISABLE);
   15daa:	4618      	mov	r0, r3
   15dac:	f7ff fd6c 	bl	15888 <set_le_scan_enable>
		if (err) {
   15db0:	2800      	cmp	r0, #0
   15db2:	d0da      	beq.n	15d6a <bt_le_scan_update+0x1e>
}
   15db4:	bd70      	pop	{r4, r5, r6, pc}
			bt_conn_unref(conn);
   15db6:	f014 fe27 	bl	2aa08 <bt_conn_unref>
   15dba:	e7cf      	b.n	15d5c <bt_le_scan_update+0x10>
   15dbc:	2000f790 	.word	0x2000f790

00015dc0 <hci_disconn_complete>:
{
   15dc0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct bt_hci_evt_disconn_complete *evt = (void *)buf->data;
   15dc2:	6886      	ldr	r6, [r0, #8]
	if (evt->status) {
   15dc4:	7835      	ldrb	r5, [r6, #0]
   15dc6:	2d00      	cmp	r5, #0
   15dc8:	d146      	bne.n	15e58 <hci_disconn_complete+0x98>
	u16_t handle = sys_le16_to_cpu(evt->handle);
   15dca:	f8b6 7001 	ldrh.w	r7, [r6, #1]
	conn = bt_conn_lookup_handle(handle);
   15dce:	4638      	mov	r0, r7
   15dd0:	f002 f940 	bl	18054 <bt_conn_lookup_handle>
	if (!conn) {
   15dd4:	4604      	mov	r4, r0
   15dd6:	bb08      	cbnz	r0, 15e1c <hci_disconn_complete+0x5c>
		BT_ERR("Unable to look up conn with handle %u", handle);
   15dd8:	4b20      	ldr	r3, [pc, #128]	; (15e5c <hci_disconn_complete+0x9c>)
   15dda:	681b      	ldr	r3, [r3, #0]
   15ddc:	075b      	lsls	r3, r3, #29
   15dde:	d00e      	beq.n	15dfe <hci_disconn_complete+0x3e>
   15de0:	2301      	movs	r3, #1
   15de2:	f04f 0200 	mov.w	r2, #0
   15de6:	f363 0207 	bfi	r2, r3, #0, #8
   15dea:	491d      	ldr	r1, [pc, #116]	; (15e60 <hci_disconn_complete+0xa0>)
   15dec:	4b1d      	ldr	r3, [pc, #116]	; (15e64 <hci_disconn_complete+0xa4>)
   15dee:	481e      	ldr	r0, [pc, #120]	; (15e68 <hci_disconn_complete+0xa8>)
   15df0:	1a5b      	subs	r3, r3, r1
   15df2:	08db      	lsrs	r3, r3, #3
   15df4:	f363 128f 	bfi	r2, r3, #6, #10
   15df8:	4639      	mov	r1, r7
   15dfa:	f012 fdab 	bl	28954 <log_1>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
   15dfe:	2109      	movs	r1, #9
   15e00:	481a      	ldr	r0, [pc, #104]	; (15e6c <hci_disconn_complete+0xac>)
   15e02:	f014 fcd1 	bl	2a7a8 <atomic_test_bit>
   15e06:	b338      	cbz	r0, 15e58 <hci_disconn_complete+0x98>
	    !atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING)) {
   15e08:	2106      	movs	r1, #6
   15e0a:	4818      	ldr	r0, [pc, #96]	; (15e6c <hci_disconn_complete+0xac>)
   15e0c:	f014 fccc 	bl	2a7a8 <atomic_test_bit>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
   15e10:	bb10      	cbnz	r0, 15e58 <hci_disconn_complete+0x98>
		set_advertise_enable(true);
   15e12:	2001      	movs	r0, #1
}
   15e14:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		set_advertise_enable(true);
   15e18:	f7ff bd9e 	b.w	15958 <set_advertise_enable>
	conn->err = evt->reason;
   15e1c:	78f3      	ldrb	r3, [r6, #3]
   15e1e:	7243      	strb	r3, [r0, #9]
	bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   15e20:	4629      	mov	r1, r5
   15e22:	f002 f82d 	bl	17e80 <bt_conn_set_state>
	if (conn->type != BT_CONN_TYPE_LE) {
   15e26:	78a3      	ldrb	r3, [r4, #2]
	conn->handle = 0U;
   15e28:	8025      	strh	r5, [r4, #0]
	if (conn->type != BT_CONN_TYPE_LE) {
   15e2a:	2b01      	cmp	r3, #1
   15e2c:	d004      	beq.n	15e38 <hci_disconn_complete+0x78>
		bt_conn_unref(conn);
   15e2e:	4620      	mov	r0, r4
}
   15e30:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		bt_conn_unref(conn);
   15e34:	f014 bde8 	b.w	2aa08 <bt_conn_unref>
	if (atomic_test_bit(conn->flags, BT_CONN_AUTO_CONNECT)) {
   15e38:	4629      	mov	r1, r5
   15e3a:	1d20      	adds	r0, r4, #4
   15e3c:	f014 fcb4 	bl	2a7a8 <atomic_test_bit>
   15e40:	b130      	cbz	r0, 15e50 <hci_disconn_complete+0x90>
		bt_conn_set_state(conn, BT_CONN_CONNECT_SCAN);
   15e42:	4620      	mov	r0, r4
   15e44:	4619      	mov	r1, r3
   15e46:	f002 f81b 	bl	17e80 <bt_conn_set_state>
		bt_le_scan_update(false);
   15e4a:	4628      	mov	r0, r5
   15e4c:	f7ff ff7e 	bl	15d4c <bt_le_scan_update>
	bt_conn_unref(conn);
   15e50:	4620      	mov	r0, r4
   15e52:	f014 fdd9 	bl	2aa08 <bt_conn_unref>
   15e56:	e7d2      	b.n	15dfe <hci_disconn_complete+0x3e>
}
   15e58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   15e5a:	bf00      	nop
   15e5c:	20010004 	.word	0x20010004
   15e60:	0002db28 	.word	0x0002db28
   15e64:	0002dc00 	.word	0x0002dc00
   15e68:	00030a31 	.word	0x00030a31
   15e6c:	2000f790 	.word	0x2000f790

00015e70 <le_adv_report>:
{
   15e70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u8_t num_reports = net_buf_pull_u8(buf);
   15e74:	f100 0608 	add.w	r6, r0, #8
{
   15e78:	b085      	sub	sp, #20
   15e7a:	4604      	mov	r4, r0
	u8_t num_reports = net_buf_pull_u8(buf);
   15e7c:	4630      	mov	r0, r6
   15e7e:	f016 feb8 	bl	2cbf2 <net_buf_simple_pull_u8>
		if (scan_dev_found_cb) {
   15e82:	f8df a1dc 	ldr.w	sl, [pc, #476]	; 16060 <le_adv_report+0x1f0>
	u8_t num_reports = net_buf_pull_u8(buf);
   15e86:	9000      	str	r0, [sp, #0]
	while (num_reports--) {
   15e88:	9b00      	ldr	r3, [sp, #0]
   15e8a:	b1a3      	cbz	r3, 15eb6 <le_adv_report+0x46>
		if (buf->len < sizeof(*info)) {
   15e8c:	89a3      	ldrh	r3, [r4, #12]
   15e8e:	2b08      	cmp	r3, #8
   15e90:	d814      	bhi.n	15ebc <le_adv_report+0x4c>
			BT_ERR("Unexpected end of buffer");
   15e92:	4b6d      	ldr	r3, [pc, #436]	; (16048 <le_adv_report+0x1d8>)
   15e94:	681b      	ldr	r3, [r3, #0]
   15e96:	075b      	lsls	r3, r3, #29
   15e98:	d00d      	beq.n	15eb6 <le_adv_report+0x46>
   15e9a:	2301      	movs	r3, #1
   15e9c:	f04f 0100 	mov.w	r1, #0
   15ea0:	f363 0107 	bfi	r1, r3, #0, #8
   15ea4:	4a69      	ldr	r2, [pc, #420]	; (1604c <le_adv_report+0x1dc>)
   15ea6:	4b6a      	ldr	r3, [pc, #424]	; (16050 <le_adv_report+0x1e0>)
   15ea8:	486a      	ldr	r0, [pc, #424]	; (16054 <le_adv_report+0x1e4>)
   15eaa:	1a9b      	subs	r3, r3, r2
   15eac:	08db      	lsrs	r3, r3, #3
   15eae:	f363 118f 	bfi	r1, r3, #6, #10
   15eb2:	f012 fd42 	bl	2893a <log_0>
}
   15eb6:	b005      	add	sp, #20
   15eb8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		info = net_buf_pull_mem(buf, sizeof(*info));
   15ebc:	2109      	movs	r1, #9
   15ebe:	4630      	mov	r0, r6
   15ec0:	f016 fe8f 	bl	2cbe2 <net_buf_simple_pull_mem>
		rssi = info->data[info->length];
   15ec4:	7a03      	ldrb	r3, [r0, #8]
		if (info->addr.type == BT_ADDR_LE_PUBLIC_ID ||
   15ec6:	4680      	mov	r8, r0
		rssi = info->data[info->length];
   15ec8:	4403      	add	r3, r0
		info = net_buf_pull_mem(buf, sizeof(*info));
   15eca:	4605      	mov	r5, r0
		rssi = info->data[info->length];
   15ecc:	f893 b009 	ldrb.w	fp, [r3, #9]
		if (info->addr.type == BT_ADDR_LE_PUBLIC_ID ||
   15ed0:	f818 3f01 	ldrb.w	r3, [r8, #1]!
   15ed4:	3b02      	subs	r3, #2
   15ed6:	2b01      	cmp	r3, #1
			bt_addr_le_copy(&id_addr, &info->addr);
   15ed8:	4641      	mov	r1, r8
   15eda:	a802      	add	r0, sp, #8
		if (info->addr.type == BT_ADDR_LE_PUBLIC_ID ||
   15edc:	f200 809f 	bhi.w	1601e <le_adv_report+0x1ae>
			bt_addr_le_copy(&id_addr, &info->addr);
   15ee0:	f014 fc23 	bl	2a72a <bt_addr_le_copy>
			id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
   15ee4:	f89d 3008 	ldrb.w	r3, [sp, #8]
   15ee8:	3b02      	subs	r3, #2
   15eea:	f88d 3008 	strb.w	r3, [sp, #8]
		if (scan_dev_found_cb) {
   15eee:	f8da 3000 	ldr.w	r3, [sl]
   15ef2:	b1ab      	cbz	r3, 15f20 <le_adv_report+0xb0>
 * @param state Storage for the state.
 */
static inline void net_buf_simple_save(struct net_buf_simple *buf,
				       struct net_buf_simple_state *state)
{
	state->offset = net_buf_simple_headroom(buf);
   15ef4:	4630      	mov	r0, r6
   15ef6:	f016 fe8c 	bl	2cc12 <net_buf_simple_headroom>
	state->len = buf->len;
   15efa:	89a3      	ldrh	r3, [r4, #12]
   15efc:	9301      	str	r3, [sp, #4]
			buf->len = info->length;
   15efe:	7a2b      	ldrb	r3, [r5, #8]
   15f00:	81a3      	strh	r3, [r4, #12]
	state->offset = net_buf_simple_headroom(buf);
   15f02:	4681      	mov	r9, r0
			scan_dev_found_cb(&id_addr, rssi, info->evt_type,
   15f04:	4633      	mov	r3, r6
   15f06:	782a      	ldrb	r2, [r5, #0]
   15f08:	f8da 7000 	ldr.w	r7, [sl]
   15f0c:	fa4f f18b 	sxtb.w	r1, fp
   15f10:	a802      	add	r0, sp, #8
   15f12:	47b8      	blx	r7
 * @param state Stored state.
 */
static inline void net_buf_simple_restore(struct net_buf_simple *buf,
					  struct net_buf_simple_state *state)
{
	buf->data = buf->__buf + state->offset;
   15f14:	6923      	ldr	r3, [r4, #16]
   15f16:	fa13 f389 	uxtah	r3, r3, r9
   15f1a:	60a3      	str	r3, [r4, #8]
	buf->len = state->len;
   15f1c:	9b01      	ldr	r3, [sp, #4]
   15f1e:	81a3      	strh	r3, [r4, #12]
	if (atomic_test_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
   15f20:	210b      	movs	r1, #11
   15f22:	484d      	ldr	r0, [pc, #308]	; (16058 <le_adv_report+0x1e8>)
		check_pending_conn(&id_addr, &info->addr, info->evt_type);
   15f24:	782b      	ldrb	r3, [r5, #0]
	if (atomic_test_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
   15f26:	f014 fc3f 	bl	2a7a8 <atomic_test_bit>
   15f2a:	4681      	mov	r9, r0
   15f2c:	2800      	cmp	r0, #0
   15f2e:	d16c      	bne.n	1600a <le_adv_report+0x19a>
	if (evtype != BT_LE_ADV_IND && evtype != BT_LE_ADV_DIRECT_IND) {
   15f30:	2b01      	cmp	r3, #1
   15f32:	d86a      	bhi.n	1600a <le_adv_report+0x19a>
	conn = bt_conn_lookup_state_le(id_addr, BT_CONN_CONNECT_SCAN);
   15f34:	2101      	movs	r1, #1
   15f36:	a802      	add	r0, sp, #8
   15f38:	f002 f8d8 	bl	180ec <bt_conn_lookup_state_le>
	if (!conn) {
   15f3c:	4607      	mov	r7, r0
   15f3e:	2800      	cmp	r0, #0
   15f40:	d063      	beq.n	1600a <le_adv_report+0x19a>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING) &&
   15f42:	210a      	movs	r1, #10
   15f44:	4844      	ldr	r0, [pc, #272]	; (16058 <le_adv_report+0x1e8>)
   15f46:	f014 fc2f 	bl	2a7a8 <atomic_test_bit>
   15f4a:	2800      	cmp	r0, #0
   15f4c:	d16a      	bne.n	16024 <le_adv_report+0x1b4>
	bt_addr_le_copy(&conn->le.resp_addr, addr);
   15f4e:	4641      	mov	r1, r8
   15f50:	f107 007e 	add.w	r0, r7, #126	; 0x7e
   15f54:	f014 fbe9 	bl	2a72a <bt_addr_le_copy>
		const bt_addr_le_t *own_addr = &bt_dev.id_addr[conn->id];
   15f58:	f897 8008 	ldrb.w	r8, [r7, #8]
		if (own_addr->type == BT_ADDR_LE_RANDOM) {
   15f5c:	4a3f      	ldr	r2, [pc, #252]	; (1605c <le_adv_report+0x1ec>)
   15f5e:	ea4f 09c8 	mov.w	r9, r8, lsl #3
   15f62:	eba9 0308 	sub.w	r3, r9, r8
   15f66:	5cd3      	ldrb	r3, [r2, r3]
   15f68:	2b01      	cmp	r3, #1
   15f6a:	d108      	bne.n	15f7e <le_adv_report+0x10e>
			err = set_random_address(&own_addr->a);
   15f6c:	2007      	movs	r0, #7
   15f6e:	fb10 3008 	smlabb	r0, r0, r8, r3
   15f72:	4b3a      	ldr	r3, [pc, #232]	; (1605c <le_adv_report+0x1ec>)
   15f74:	4418      	add	r0, r3
   15f76:	f7ff fcc1 	bl	158fc <set_random_address>
			if (err) {
   15f7a:	2800      	cmp	r0, #0
   15f7c:	d157      	bne.n	1602e <le_adv_report+0x1be>
		own_addr_type = own_addr->type;
   15f7e:	4b37      	ldr	r3, [pc, #220]	; (1605c <le_adv_report+0x1ec>)
   15f80:	eba9 0808 	sub.w	r8, r9, r8
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CREATE_CONN, sizeof(*cp));
   15f84:	2119      	movs	r1, #25
   15f86:	f242 000d 	movw	r0, #8205	; 0x200d
		own_addr_type = own_addr->type;
   15f8a:	f813 9008 	ldrb.w	r9, [r3, r8]
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CREATE_CONN, sizeof(*cp));
   15f8e:	f7ff fbff 	bl	15790 <bt_hci_cmd_create>
	if (!buf) {
   15f92:	4683      	mov	fp, r0
   15f94:	2800      	cmp	r0, #0
   15f96:	d04a      	beq.n	1602e <le_adv_report+0x1be>
	cp = net_buf_add(buf, sizeof(*cp));
   15f98:	2119      	movs	r1, #25
   15f9a:	3008      	adds	r0, #8
   15f9c:	f016 fdf0 	bl	2cb80 <net_buf_simple_add>
	(void)memset(cp, 0, sizeof(*cp));
   15fa0:	2219      	movs	r2, #25
	cp = net_buf_add(buf, sizeof(*cp));
   15fa2:	4680      	mov	r8, r0
	(void)memset(cp, 0, sizeof(*cp));
   15fa4:	2100      	movs	r1, #0
   15fa6:	f014 fa7c 	bl	2a4a2 <memset>
	cp->scan_interval = sys_cpu_to_le16(BT_GAP_SCAN_FAST_INTERVAL);
   15faa:	2200      	movs	r2, #0
   15fac:	2360      	movs	r3, #96	; 0x60
   15fae:	f888 3000 	strb.w	r3, [r8]
   15fb2:	f888 2001 	strb.w	r2, [r8, #1]
	cp->scan_window = cp->scan_interval;
   15fb6:	f888 3002 	strb.w	r3, [r8, #2]
   15fba:	f888 2003 	strb.w	r2, [r8, #3]
	bt_addr_le_copy(&cp->peer_addr, peer_addr);
   15fbe:	f107 0170 	add.w	r1, r7, #112	; 0x70
   15fc2:	f108 0005 	add.w	r0, r8, #5
   15fc6:	f014 fbb0 	bl	2a72a <bt_addr_le_copy>
	cp->own_addr_type = own_addr_type;
   15fca:	f888 900c 	strb.w	r9, [r8, #12]
	cp->conn_interval_min = sys_cpu_to_le16(conn->le.interval_min);
   15fce:	f8b7 3088 	ldrh.w	r3, [r7, #136]	; 0x88
   15fd2:	f8a8 300d 	strh.w	r3, [r8, #13]
	cp->conn_interval_max = sys_cpu_to_le16(conn->le.interval_max);
   15fd6:	f8b7 308a 	ldrh.w	r3, [r7, #138]	; 0x8a
   15fda:	f8a8 300f 	strh.w	r3, [r8, #15]
	cp->conn_latency = sys_cpu_to_le16(conn->le.latency);
   15fde:	f8b7 308c 	ldrh.w	r3, [r7, #140]	; 0x8c
   15fe2:	f8a8 3011 	strh.w	r3, [r8, #17]
	cp->supervision_timeout = sys_cpu_to_le16(conn->le.timeout);
   15fe6:	f8b7 308e 	ldrh.w	r3, [r7, #142]	; 0x8e
   15fea:	f8a8 3013 	strh.w	r3, [r8, #19]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CREATE_CONN, buf, NULL);
   15fee:	2200      	movs	r2, #0
   15ff0:	4659      	mov	r1, fp
   15ff2:	f242 000d 	movw	r0, #8205	; 0x200d
   15ff6:	f7ff fc01 	bl	157fc <bt_hci_cmd_send_sync>
	if (hci_le_create_conn(conn)) {
   15ffa:	b9c0      	cbnz	r0, 1602e <le_adv_report+0x1be>
	bt_conn_set_state(conn, BT_CONN_CONNECT);
   15ffc:	4638      	mov	r0, r7
   15ffe:	2103      	movs	r1, #3
   16000:	f001 ff3e 	bl	17e80 <bt_conn_set_state>
	bt_conn_unref(conn);
   16004:	4638      	mov	r0, r7
   16006:	f014 fcff 	bl	2aa08 <bt_conn_unref>
		net_buf_pull(buf, info->length + sizeof(rssi));
   1600a:	7a29      	ldrb	r1, [r5, #8]
   1600c:	4630      	mov	r0, r6
   1600e:	3101      	adds	r1, #1
   16010:	f016 fddf 	bl	2cbd2 <net_buf_simple_pull>
   16014:	9b00      	ldr	r3, [sp, #0]
   16016:	3b01      	subs	r3, #1
   16018:	b2db      	uxtb	r3, r3
   1601a:	9300      	str	r3, [sp, #0]
   1601c:	e734      	b.n	15e88 <le_adv_report+0x18>
			bt_addr_le_copy(&id_addr,
   1601e:	f014 fb84 	bl	2a72a <bt_addr_le_copy>
   16022:	e764      	b.n	15eee <le_adv_report+0x7e>
	    set_le_scan_enable(BT_HCI_LE_SCAN_DISABLE)) {
   16024:	4648      	mov	r0, r9
   16026:	f7ff fc2f 	bl	15888 <set_le_scan_enable>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING) &&
   1602a:	2800      	cmp	r0, #0
   1602c:	d08f      	beq.n	15f4e <le_adv_report+0xde>
	conn->err = BT_HCI_ERR_UNSPECIFIED;
   1602e:	231f      	movs	r3, #31
   16030:	727b      	strb	r3, [r7, #9]
	bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   16032:	2100      	movs	r1, #0
   16034:	4638      	mov	r0, r7
   16036:	f001 ff23 	bl	17e80 <bt_conn_set_state>
	bt_conn_unref(conn);
   1603a:	4638      	mov	r0, r7
   1603c:	f014 fce4 	bl	2aa08 <bt_conn_unref>
	bt_le_scan_update(false);
   16040:	2000      	movs	r0, #0
   16042:	f7ff fe83 	bl	15d4c <bt_le_scan_update>
   16046:	e7e0      	b.n	1600a <le_adv_report+0x19a>
   16048:	20010004 	.word	0x20010004
   1604c:	0002db28 	.word	0x0002db28
   16050:	0002dc00 	.word	0x0002dc00
   16054:	00030ca8 	.word	0x00030ca8
   16058:	2000f790 	.word	0x2000f790
   1605c:	2000f720 	.word	0x2000f720
   16060:	20000a18 	.word	0x20000a18

00016064 <hci_le_set_data_len.isra.28>:
static void hci_le_set_data_len(struct bt_conn *conn)
   16064:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   16066:	4607      	mov	r7, r0
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_MAX_DATA_LEN, NULL, &rsp);
   16068:	aa01      	add	r2, sp, #4
   1606a:	2100      	movs	r1, #0
   1606c:	f242 002f 	movw	r0, #8239	; 0x202f
   16070:	f7ff fbc4 	bl	157fc <bt_hci_cmd_send_sync>
	if (err) {
   16074:	b198      	cbz	r0, 1609e <hci_le_set_data_len.isra.28+0x3a>
		BT_ERR("Failed to read DLE max data len");
   16076:	4b2a      	ldr	r3, [pc, #168]	; (16120 <hci_le_set_data_len.isra.28+0xbc>)
   16078:	681b      	ldr	r3, [r3, #0]
   1607a:	0759      	lsls	r1, r3, #29
   1607c:	d00d      	beq.n	1609a <hci_le_set_data_len.isra.28+0x36>
   1607e:	2301      	movs	r3, #1
   16080:	f04f 0100 	mov.w	r1, #0
   16084:	f363 0107 	bfi	r1, r3, #0, #8
   16088:	4a26      	ldr	r2, [pc, #152]	; (16124 <hci_le_set_data_len.isra.28+0xc0>)
   1608a:	4b27      	ldr	r3, [pc, #156]	; (16128 <hci_le_set_data_len.isra.28+0xc4>)
   1608c:	4827      	ldr	r0, [pc, #156]	; (1612c <hci_le_set_data_len.isra.28+0xc8>)
   1608e:	1a9b      	subs	r3, r3, r2
   16090:	08db      	lsrs	r3, r3, #3
   16092:	f363 118f 	bfi	r1, r3, #6, #10
		BT_ERR("Failed to send LE Set Data Length Command");
   16096:	f012 fc50 	bl	2893a <log_0>
}
   1609a:	b003      	add	sp, #12
   1609c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	rp = (void *)rsp->data;
   1609e:	9801      	ldr	r0, [sp, #4]
   160a0:	6883      	ldr	r3, [r0, #8]
	tx_octets = sys_le16_to_cpu(rp->max_tx_octets);
   160a2:	f8b3 6001 	ldrh.w	r6, [r3, #1]
	tx_time = sys_le16_to_cpu(rp->max_tx_time);
   160a6:	f8b3 5003 	ldrh.w	r5, [r3, #3]
	net_buf_unref(rsp);
   160aa:	f00f f90f 	bl	252cc <net_buf_unref>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_DATA_LEN, sizeof(*cp));
   160ae:	2106      	movs	r1, #6
   160b0:	f242 0022 	movw	r0, #8226	; 0x2022
   160b4:	f7ff fb6c 	bl	15790 <bt_hci_cmd_create>
	if (!buf) {
   160b8:	4604      	mov	r4, r0
   160ba:	b980      	cbnz	r0, 160de <hci_le_set_data_len.isra.28+0x7a>
		BT_ERR("Failed to create LE Set Data Length Command");
   160bc:	4b18      	ldr	r3, [pc, #96]	; (16120 <hci_le_set_data_len.isra.28+0xbc>)
   160be:	681b      	ldr	r3, [r3, #0]
   160c0:	075a      	lsls	r2, r3, #29
   160c2:	d0ea      	beq.n	1609a <hci_le_set_data_len.isra.28+0x36>
   160c4:	2301      	movs	r3, #1
   160c6:	f04f 0100 	mov.w	r1, #0
   160ca:	f363 0107 	bfi	r1, r3, #0, #8
   160ce:	4a15      	ldr	r2, [pc, #84]	; (16124 <hci_le_set_data_len.isra.28+0xc0>)
   160d0:	4b15      	ldr	r3, [pc, #84]	; (16128 <hci_le_set_data_len.isra.28+0xc4>)
   160d2:	4817      	ldr	r0, [pc, #92]	; (16130 <hci_le_set_data_len.isra.28+0xcc>)
   160d4:	1a9b      	subs	r3, r3, r2
   160d6:	08db      	lsrs	r3, r3, #3
   160d8:	f363 118f 	bfi	r1, r3, #6, #10
   160dc:	e7db      	b.n	16096 <hci_le_set_data_len.isra.28+0x32>
	cp = net_buf_add(buf, sizeof(*cp));
   160de:	2106      	movs	r1, #6
   160e0:	3008      	adds	r0, #8
   160e2:	f016 fd4d 	bl	2cb80 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
   160e6:	883b      	ldrh	r3, [r7, #0]
   160e8:	8003      	strh	r3, [r0, #0]
	cp->tx_octets = sys_cpu_to_le16(tx_octets);
   160ea:	8046      	strh	r6, [r0, #2]
	cp->tx_time = sys_cpu_to_le16(tx_time);
   160ec:	8085      	strh	r5, [r0, #4]
	err = bt_hci_cmd_send(BT_HCI_OP_LE_SET_DATA_LEN, buf);
   160ee:	4621      	mov	r1, r4
   160f0:	f242 0022 	movw	r0, #8226	; 0x2022
   160f4:	f7ff fd96 	bl	15c24 <bt_hci_cmd_send>
	if (err) {
   160f8:	2800      	cmp	r0, #0
   160fa:	d0ce      	beq.n	1609a <hci_le_set_data_len.isra.28+0x36>
		BT_ERR("Failed to send LE Set Data Length Command");
   160fc:	4b08      	ldr	r3, [pc, #32]	; (16120 <hci_le_set_data_len.isra.28+0xbc>)
   160fe:	681b      	ldr	r3, [r3, #0]
   16100:	075b      	lsls	r3, r3, #29
   16102:	d0ca      	beq.n	1609a <hci_le_set_data_len.isra.28+0x36>
   16104:	2301      	movs	r3, #1
   16106:	f04f 0100 	mov.w	r1, #0
   1610a:	f363 0107 	bfi	r1, r3, #0, #8
   1610e:	4a05      	ldr	r2, [pc, #20]	; (16124 <hci_le_set_data_len.isra.28+0xc0>)
   16110:	4b05      	ldr	r3, [pc, #20]	; (16128 <hci_le_set_data_len.isra.28+0xc4>)
   16112:	4808      	ldr	r0, [pc, #32]	; (16134 <hci_le_set_data_len.isra.28+0xd0>)
   16114:	1a9b      	subs	r3, r3, r2
   16116:	08db      	lsrs	r3, r3, #3
   16118:	f363 118f 	bfi	r1, r3, #6, #10
   1611c:	e7bb      	b.n	16096 <hci_le_set_data_len.isra.28+0x32>
   1611e:	bf00      	nop
   16120:	20010004 	.word	0x20010004
   16124:	0002db28 	.word	0x0002db28
   16128:	0002dc00 	.word	0x0002dc00
   1612c:	00030b6e 	.word	0x00030b6e
   16130:	00030b8e 	.word	0x00030b8e
   16134:	00030bba 	.word	0x00030bba

00016138 <le_phy_update_complete>:
{
   16138:	b538      	push	{r3, r4, r5, lr}
	u16_t handle = sys_le16_to_cpu(evt->handle);
   1613a:	6883      	ldr	r3, [r0, #8]
   1613c:	f8b3 5001 	ldrh.w	r5, [r3, #1]
	conn = bt_conn_lookup_handle(handle);
   16140:	4628      	mov	r0, r5
   16142:	f001 ff87 	bl	18054 <bt_conn_lookup_handle>
	if (!conn) {
   16146:	4604      	mov	r4, r0
   16148:	b9a0      	cbnz	r0, 16174 <le_phy_update_complete+0x3c>
		BT_ERR("Unable to lookup conn for handle %u", handle);
   1614a:	4b1a      	ldr	r3, [pc, #104]	; (161b4 <le_phy_update_complete+0x7c>)
   1614c:	681b      	ldr	r3, [r3, #0]
   1614e:	0758      	lsls	r0, r3, #29
   16150:	d02e      	beq.n	161b0 <le_phy_update_complete+0x78>
   16152:	2301      	movs	r3, #1
   16154:	f04f 0200 	mov.w	r2, #0
   16158:	f363 0207 	bfi	r2, r3, #0, #8
   1615c:	4916      	ldr	r1, [pc, #88]	; (161b8 <le_phy_update_complete+0x80>)
   1615e:	4b17      	ldr	r3, [pc, #92]	; (161bc <le_phy_update_complete+0x84>)
   16160:	4817      	ldr	r0, [pc, #92]	; (161c0 <le_phy_update_complete+0x88>)
   16162:	1a5b      	subs	r3, r3, r1
   16164:	08db      	lsrs	r3, r3, #3
   16166:	f363 128f 	bfi	r2, r3, #6, #10
   1616a:	4629      	mov	r1, r5
}
   1616c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		BT_ERR("Unable to lookup conn for handle %u", handle);
   16170:	f012 bbf0 	b.w	28954 <log_1>
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   16174:	f06f 0180 	mvn.w	r1, #128	; 0x80
   16178:	3004      	adds	r0, #4
   1617a:	f014 fae8 	bl	2a74e <atomic_and>
	if (!IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) ||
   1617e:	0601      	lsls	r1, r0, #24
   16180:	d511      	bpl.n	161a6 <le_phy_update_complete+0x6e>
	    BT_FEAT_LE_DLE(bt_dev.le.features) &&
   16182:	4b10      	ldr	r3, [pc, #64]	; (161c4 <le_phy_update_complete+0x8c>)
	if (IS_ENABLED(CONFIG_BT_DATA_LEN_UPDATE) &&
   16184:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
   16188:	069a      	lsls	r2, r3, #26
   1618a:	d506      	bpl.n	1619a <le_phy_update_complete+0x62>
	    BT_FEAT_LE_DLE(bt_dev.le.features) &&
   1618c:	f894 3094 	ldrb.w	r3, [r4, #148]	; 0x94
   16190:	069b      	lsls	r3, r3, #26
   16192:	d502      	bpl.n	1619a <le_phy_update_complete+0x62>
		hci_le_set_data_len(conn);
   16194:	4620      	mov	r0, r4
   16196:	f7ff ff65 	bl	16064 <hci_le_set_data_len.isra.28>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   1619a:	78e3      	ldrb	r3, [r4, #3]
   1619c:	2b01      	cmp	r3, #1
   1619e:	d102      	bne.n	161a6 <le_phy_update_complete+0x6e>
		slave_update_conn_param(conn);
   161a0:	4620      	mov	r0, r4
   161a2:	f7ff f9fb 	bl	1559c <slave_update_conn_param>
	bt_conn_unref(conn);
   161a6:	4620      	mov	r0, r4
}
   161a8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_conn_unref(conn);
   161ac:	f014 bc2c 	b.w	2aa08 <bt_conn_unref>
}
   161b0:	bd38      	pop	{r3, r4, r5, pc}
   161b2:	bf00      	nop
   161b4:	20010004 	.word	0x20010004
   161b8:	0002db28 	.word	0x0002db28
   161bc:	0002dc00 	.word	0x0002dc00
   161c0:	00030ce4 	.word	0x00030ce4
   161c4:	2000f720 	.word	0x2000f720

000161c8 <le_conn_param_neg_reply>:
{
   161c8:	b570      	push	{r4, r5, r6, lr}
   161ca:	4606      	mov	r6, r0
   161cc:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY,
   161ce:	f242 0021 	movw	r0, #8225	; 0x2021
   161d2:	2103      	movs	r1, #3
   161d4:	f7ff fadc 	bl	15790 <bt_hci_cmd_create>
	if (!buf) {
   161d8:	4604      	mov	r4, r0
   161da:	b998      	cbnz	r0, 16204 <le_conn_param_neg_reply+0x3c>
		BT_ERR("Unable to allocate buffer");
   161dc:	4b10      	ldr	r3, [pc, #64]	; (16220 <le_conn_param_neg_reply+0x58>)
   161de:	681b      	ldr	r3, [r3, #0]
   161e0:	075b      	lsls	r3, r3, #29
   161e2:	d01c      	beq.n	1621e <le_conn_param_neg_reply+0x56>
   161e4:	2301      	movs	r3, #1
   161e6:	f04f 0100 	mov.w	r1, #0
   161ea:	f363 0107 	bfi	r1, r3, #0, #8
   161ee:	4a0d      	ldr	r2, [pc, #52]	; (16224 <le_conn_param_neg_reply+0x5c>)
   161f0:	4b0d      	ldr	r3, [pc, #52]	; (16228 <le_conn_param_neg_reply+0x60>)
   161f2:	480e      	ldr	r0, [pc, #56]	; (1622c <le_conn_param_neg_reply+0x64>)
   161f4:	1a9b      	subs	r3, r3, r2
   161f6:	08db      	lsrs	r3, r3, #3
   161f8:	f363 118f 	bfi	r1, r3, #6, #10
}
   161fc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_ERR("Unable to allocate buffer");
   16200:	f012 bb9b 	b.w	2893a <log_0>
	cp = net_buf_add(buf, sizeof(*cp));
   16204:	2103      	movs	r1, #3
   16206:	3008      	adds	r0, #8
   16208:	f016 fcba 	bl	2cb80 <net_buf_simple_add>
	cp->reason = sys_cpu_to_le16(reason);
   1620c:	7085      	strb	r5, [r0, #2]
	cp->handle = sys_cpu_to_le16(handle);
   1620e:	8006      	strh	r6, [r0, #0]
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
   16210:	4621      	mov	r1, r4
   16212:	f242 0021 	movw	r0, #8225	; 0x2021
}
   16216:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_NEG_REPLY, buf);
   1621a:	f7ff bd03 	b.w	15c24 <bt_hci_cmd_send>
}
   1621e:	bd70      	pop	{r4, r5, r6, pc}
   16220:	20010004 	.word	0x20010004
   16224:	0002db28 	.word	0x0002db28
   16228:	0002dc00 	.word	0x0002dc00
   1622c:	00030cca 	.word	0x00030cca

00016230 <le_conn_param_req>:
{
   16230:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct bt_hci_evt_le_conn_param_req *evt = (void *)buf->data;
   16232:	6883      	ldr	r3, [r0, #8]
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
   16234:	78d9      	ldrb	r1, [r3, #3]
   16236:	789a      	ldrb	r2, [r3, #2]
	handle = sys_le16_to_cpu(evt->handle);
   16238:	881e      	ldrh	r6, [r3, #0]
	param.interval_min = sys_le16_to_cpu(evt->interval_min);
   1623a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   1623e:	f8ad 2000 	strh.w	r2, [sp]
	param.interval_max = sys_le16_to_cpu(evt->interval_max);
   16242:	7959      	ldrb	r1, [r3, #5]
   16244:	791a      	ldrb	r2, [r3, #4]
   16246:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   1624a:	f8ad 2002 	strh.w	r2, [sp, #2]
	param.latency = sys_le16_to_cpu(evt->latency);
   1624e:	799a      	ldrb	r2, [r3, #6]
   16250:	79d9      	ldrb	r1, [r3, #7]
   16252:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   16256:	f8ad 2004 	strh.w	r2, [sp, #4]
	param.timeout = sys_le16_to_cpu(evt->timeout);
   1625a:	7a1a      	ldrb	r2, [r3, #8]
   1625c:	7a5b      	ldrb	r3, [r3, #9]
	handle = sys_le16_to_cpu(evt->handle);
   1625e:	b2b4      	uxth	r4, r6
	param.timeout = sys_le16_to_cpu(evt->timeout);
   16260:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
	conn = bt_conn_lookup_handle(handle);
   16264:	4620      	mov	r0, r4
	param.timeout = sys_le16_to_cpu(evt->timeout);
   16266:	f8ad 3006 	strh.w	r3, [sp, #6]
	conn = bt_conn_lookup_handle(handle);
   1626a:	f001 fef3 	bl	18054 <bt_conn_lookup_handle>
	if (!conn) {
   1626e:	4607      	mov	r7, r0
   16270:	b9c0      	cbnz	r0, 162a4 <le_conn_param_req+0x74>
		BT_ERR("Unable to lookup conn for handle %u", handle);
   16272:	4b24      	ldr	r3, [pc, #144]	; (16304 <le_conn_param_req+0xd4>)
   16274:	681b      	ldr	r3, [r3, #0]
   16276:	075b      	lsls	r3, r3, #29
   16278:	d00e      	beq.n	16298 <le_conn_param_req+0x68>
   1627a:	2301      	movs	r3, #1
   1627c:	f04f 0200 	mov.w	r2, #0
   16280:	f363 0207 	bfi	r2, r3, #0, #8
   16284:	4920      	ldr	r1, [pc, #128]	; (16308 <le_conn_param_req+0xd8>)
   16286:	4b21      	ldr	r3, [pc, #132]	; (1630c <le_conn_param_req+0xdc>)
   16288:	4821      	ldr	r0, [pc, #132]	; (16310 <le_conn_param_req+0xe0>)
   1628a:	1a5b      	subs	r3, r3, r1
   1628c:	08db      	lsrs	r3, r3, #3
   1628e:	f363 128f 	bfi	r2, r3, #6, #10
   16292:	4621      	mov	r1, r4
   16294:	f012 fb5e 	bl	28954 <log_1>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_UNKNOWN_CONN_ID);
   16298:	2102      	movs	r1, #2
   1629a:	4620      	mov	r0, r4
   1629c:	f7ff ff94 	bl	161c8 <le_conn_param_neg_reply>
}
   162a0:	b003      	add	sp, #12
   162a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!le_param_req(conn, &param)) {
   162a4:	4669      	mov	r1, sp
   162a6:	f001 fbdd 	bl	17a64 <le_param_req>
   162aa:	b938      	cbnz	r0, 162bc <le_conn_param_req+0x8c>
		le_conn_param_neg_reply(handle, BT_HCI_ERR_INVALID_LL_PARAM);
   162ac:	211e      	movs	r1, #30
   162ae:	4620      	mov	r0, r4
   162b0:	f7ff ff8a 	bl	161c8 <le_conn_param_neg_reply>
	bt_conn_unref(conn);
   162b4:	4638      	mov	r0, r7
   162b6:	f014 fba7 	bl	2aa08 <bt_conn_unref>
   162ba:	e7f1      	b.n	162a0 <le_conn_param_req+0x70>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, sizeof(*cp));
   162bc:	210e      	movs	r1, #14
   162be:	f242 0020 	movw	r0, #8224	; 0x2020
   162c2:	f7ff fa65 	bl	15790 <bt_hci_cmd_create>
	if (!buf) {
   162c6:	4605      	mov	r5, r0
   162c8:	2800      	cmp	r0, #0
   162ca:	d0f3      	beq.n	162b4 <le_conn_param_req+0x84>
	cp = net_buf_add(buf, sizeof(*cp));
   162cc:	210e      	movs	r1, #14
   162ce:	3008      	adds	r0, #8
   162d0:	f016 fc56 	bl	2cb80 <net_buf_simple_add>
	(void)memset(cp, 0, sizeof(*cp));
   162d4:	220e      	movs	r2, #14
	cp = net_buf_add(buf, sizeof(*cp));
   162d6:	4604      	mov	r4, r0
	(void)memset(cp, 0, sizeof(*cp));
   162d8:	2100      	movs	r1, #0
   162da:	f014 f8e2 	bl	2a4a2 <memset>
	cp->interval_min = sys_cpu_to_le16(param->interval_min);
   162de:	f8bd 3000 	ldrh.w	r3, [sp]
   162e2:	8063      	strh	r3, [r4, #2]
	cp->interval_max = sys_cpu_to_le16(param->interval_max);
   162e4:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   162e8:	80a3      	strh	r3, [r4, #4]
	cp->latency = sys_cpu_to_le16(param->latency);
   162ea:	f8bd 3004 	ldrh.w	r3, [sp, #4]
   162ee:	80e3      	strh	r3, [r4, #6]
	cp->timeout = sys_cpu_to_le16(param->timeout);
   162f0:	f8bd 3006 	ldrh.w	r3, [sp, #6]
	cp->handle = sys_cpu_to_le16(handle);
   162f4:	8026      	strh	r6, [r4, #0]
	cp->timeout = sys_cpu_to_le16(param->timeout);
   162f6:	8123      	strh	r3, [r4, #8]
	return bt_hci_cmd_send(BT_HCI_OP_LE_CONN_PARAM_REQ_REPLY, buf);
   162f8:	4629      	mov	r1, r5
   162fa:	f242 0020 	movw	r0, #8224	; 0x2020
   162fe:	f7ff fc91 	bl	15c24 <bt_hci_cmd_send>
   16302:	e7d7      	b.n	162b4 <le_conn_param_req+0x84>
   16304:	20010004 	.word	0x20010004
   16308:	0002db28 	.word	0x0002db28
   1630c:	0002dc00 	.word	0x0002dc00
   16310:	00030ce4 	.word	0x00030ce4

00016314 <le_remote_feat_complete>:
{
   16314:	b570      	push	{r4, r5, r6, lr}
	struct bt_hci_evt_le_remote_feat_complete *evt = (void *)buf->data;
   16316:	6885      	ldr	r5, [r0, #8]
	u16_t handle = sys_le16_to_cpu(evt->handle);
   16318:	f8b5 6001 	ldrh.w	r6, [r5, #1]
	conn = bt_conn_lookup_handle(handle);
   1631c:	4630      	mov	r0, r6
   1631e:	f001 fe99 	bl	18054 <bt_conn_lookup_handle>
	if (!conn) {
   16322:	4604      	mov	r4, r0
   16324:	b9a0      	cbnz	r0, 16350 <le_remote_feat_complete+0x3c>
		BT_ERR("Unable to lookup conn for handle %u", handle);
   16326:	4b22      	ldr	r3, [pc, #136]	; (163b0 <le_remote_feat_complete+0x9c>)
   16328:	681b      	ldr	r3, [r3, #0]
   1632a:	075c      	lsls	r4, r3, #29
   1632c:	d03f      	beq.n	163ae <le_remote_feat_complete+0x9a>
   1632e:	2301      	movs	r3, #1
   16330:	f04f 0200 	mov.w	r2, #0
   16334:	f363 0207 	bfi	r2, r3, #0, #8
   16338:	491e      	ldr	r1, [pc, #120]	; (163b4 <le_remote_feat_complete+0xa0>)
   1633a:	4b1f      	ldr	r3, [pc, #124]	; (163b8 <le_remote_feat_complete+0xa4>)
   1633c:	481f      	ldr	r0, [pc, #124]	; (163bc <le_remote_feat_complete+0xa8>)
   1633e:	1a5b      	subs	r3, r3, r1
   16340:	08db      	lsrs	r3, r3, #3
   16342:	4631      	mov	r1, r6
   16344:	f363 128f 	bfi	r2, r3, #6, #10
}
   16348:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_ERR("Unable to lookup conn for handle %u", handle);
   1634c:	f012 bb02 	b.w	28954 <log_1>
	if (!evt->status) {
   16350:	782b      	ldrb	r3, [r5, #0]
   16352:	b923      	cbnz	r3, 1635e <le_remote_feat_complete+0x4a>
		memcpy(conn->le.features, evt->features,
   16354:	2208      	movs	r2, #8
   16356:	1ce9      	adds	r1, r5, #3
   16358:	3094      	adds	r0, #148	; 0x94
   1635a:	f014 f878 	bl	2a44e <memcpy>
	    BT_FEAT_LE_PHY_2M(bt_dev.le.features) &&
   1635e:	4d18      	ldr	r5, [pc, #96]	; (163c0 <le_remote_feat_complete+0xac>)
	if (IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) &&
   16360:	f895 2079 	ldrb.w	r2, [r5, #121]	; 0x79
   16364:	07d0      	lsls	r0, r2, #31
   16366:	d510      	bpl.n	1638a <le_remote_feat_complete+0x76>
	    BT_FEAT_LE_PHY_2M(bt_dev.le.features) &&
   16368:	f894 3095 	ldrb.w	r3, [r4, #149]	; 0x95
   1636c:	07d9      	lsls	r1, r3, #31
   1636e:	d50c      	bpl.n	1638a <le_remote_feat_complete+0x76>
		err = hci_le_set_phy(conn);
   16370:	4620      	mov	r0, r4
   16372:	f014 fa64 	bl	2a83e <hci_le_set_phy.isra.30>
		if (!err) {
   16376:	b940      	cbnz	r0, 1638a <le_remote_feat_complete+0x76>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   16378:	2180      	movs	r1, #128	; 0x80
   1637a:	1d20      	adds	r0, r4, #4
   1637c:	f014 f9d8 	bl	2a730 <atomic_or>
	bt_conn_unref(conn);
   16380:	4620      	mov	r0, r4
}
   16382:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_conn_unref(conn);
   16386:	f014 bb3f 	b.w	2aa08 <bt_conn_unref>
	if (IS_ENABLED(CONFIG_BT_DATA_LEN_UPDATE) &&
   1638a:	f895 3078 	ldrb.w	r3, [r5, #120]	; 0x78
   1638e:	069a      	lsls	r2, r3, #26
   16390:	d506      	bpl.n	163a0 <le_remote_feat_complete+0x8c>
	    BT_FEAT_LE_DLE(bt_dev.le.features) &&
   16392:	f894 3094 	ldrb.w	r3, [r4, #148]	; 0x94
   16396:	069b      	lsls	r3, r3, #26
   16398:	d502      	bpl.n	163a0 <le_remote_feat_complete+0x8c>
		hci_le_set_data_len(conn);
   1639a:	4620      	mov	r0, r4
   1639c:	f7ff fe62 	bl	16064 <hci_le_set_data_len.isra.28>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   163a0:	78e3      	ldrb	r3, [r4, #3]
   163a2:	2b01      	cmp	r3, #1
   163a4:	d1ec      	bne.n	16380 <le_remote_feat_complete+0x6c>
		slave_update_conn_param(conn);
   163a6:	4620      	mov	r0, r4
   163a8:	f7ff f8f8 	bl	1559c <slave_update_conn_param>
   163ac:	e7e8      	b.n	16380 <le_remote_feat_complete+0x6c>
}
   163ae:	bd70      	pop	{r4, r5, r6, pc}
   163b0:	20010004 	.word	0x20010004
   163b4:	0002db28 	.word	0x0002db28
   163b8:	0002dc00 	.word	0x0002dc00
   163bc:	00030ce4 	.word	0x00030ce4
   163c0:	2000f720 	.word	0x2000f720

000163c4 <enh_conn_complete>:
{
   163c4:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	if (evt->status) {
   163c8:	7803      	ldrb	r3, [r0, #0]
{
   163ca:	4605      	mov	r5, r0
	if (evt->status) {
   163cc:	2b00      	cmp	r3, #0
   163ce:	d03e      	beq.n	1644e <enh_conn_complete+0x8a>
		conn = find_pending_connect(NULL);
   163d0:	2000      	movs	r0, #0
   163d2:	f014 f9dc 	bl	2a78e <find_pending_connect>
		if (!conn) {
   163d6:	4604      	mov	r4, r0
   163d8:	b3b0      	cbz	r0, 16448 <enh_conn_complete+0x84>
		conn->err = evt->status;
   163da:	7829      	ldrb	r1, [r5, #0]
   163dc:	7241      	strb	r1, [r0, #9]
			if (conn->err == BT_HCI_ERR_ADV_TIMEOUT) {
   163de:	293c      	cmp	r1, #60	; 0x3c
   163e0:	d10f      	bne.n	16402 <enh_conn_complete+0x3e>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   163e2:	f06f 0140 	mvn.w	r1, #64	; 0x40
   163e6:	4885      	ldr	r0, [pc, #532]	; (165fc <enh_conn_complete+0x238>)
   163e8:	f014 f9b1 	bl	2a74e <atomic_and>
				bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   163ec:	2100      	movs	r1, #0
					bt_conn_set_state(conn,
   163ee:	4620      	mov	r0, r4
   163f0:	f001 fd46 	bl	17e80 <bt_conn_set_state>
	bt_conn_unref(conn);
   163f4:	4620      	mov	r0, r4
   163f6:	f014 fb07 	bl	2aa08 <bt_conn_unref>
		bt_le_scan_update(false);
   163fa:	2000      	movs	r0, #0
   163fc:	f7ff fca6 	bl	15d4c <bt_le_scan_update>
   16400:	e022      	b.n	16448 <enh_conn_complete+0x84>
			if (conn->err == BT_HCI_ERR_UNKNOWN_CONN_ID) {
   16402:	2902      	cmp	r1, #2
   16404:	d10a      	bne.n	1641c <enh_conn_complete+0x58>
				bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   16406:	2100      	movs	r1, #0
   16408:	f001 fd3a 	bl	17e80 <bt_conn_set_state>
				if (atomic_test_bit(conn->flags,
   1640c:	2100      	movs	r1, #0
   1640e:	1d20      	adds	r0, r4, #4
   16410:	f014 f9ca 	bl	2a7a8 <atomic_test_bit>
   16414:	2800      	cmp	r0, #0
   16416:	d0ed      	beq.n	163f4 <enh_conn_complete+0x30>
					bt_conn_set_state(conn,
   16418:	2101      	movs	r1, #1
   1641a:	e7e8      	b.n	163ee <enh_conn_complete+0x2a>
		BT_WARN("Unexpected status 0x%02x", evt->status);
   1641c:	4b78      	ldr	r3, [pc, #480]	; (16600 <enh_conn_complete+0x23c>)
   1641e:	681b      	ldr	r3, [r3, #0]
   16420:	f013 0f06 	tst.w	r3, #6
   16424:	d00d      	beq.n	16442 <enh_conn_complete+0x7e>
   16426:	2302      	movs	r3, #2
   16428:	f04f 0200 	mov.w	r2, #0
   1642c:	f363 0207 	bfi	r2, r3, #0, #8
   16430:	4874      	ldr	r0, [pc, #464]	; (16604 <enh_conn_complete+0x240>)
   16432:	4b75      	ldr	r3, [pc, #468]	; (16608 <enh_conn_complete+0x244>)
   16434:	1a1b      	subs	r3, r3, r0
   16436:	08db      	lsrs	r3, r3, #3
   16438:	f363 128f 	bfi	r2, r3, #6, #10
   1643c:	4873      	ldr	r0, [pc, #460]	; (1660c <enh_conn_complete+0x248>)
   1643e:	f012 fa89 	bl	28954 <log_1>
		bt_conn_unref(conn);
   16442:	4620      	mov	r0, r4
   16444:	f014 fae0 	bl	2aa08 <bt_conn_unref>
}
   16448:	b004      	add	sp, #16
   1644a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	bt_addr_le_copy(&id_addr, &evt->peer_addr);
   1644e:	1d04      	adds	r4, r0, #4
	u16_t handle = sys_le16_to_cpu(evt->handle);
   16450:	f8b0 7001 	ldrh.w	r7, [r0, #1]
	bt_addr_le_copy(&id_addr, &evt->peer_addr);
   16454:	4621      	mov	r1, r4
   16456:	a802      	add	r0, sp, #8
   16458:	f014 f967 	bl	2a72a <bt_addr_le_copy>
	if (id_addr.type == BT_ADDR_LE_PUBLIC_ID ||
   1645c:	f89d 3008 	ldrb.w	r3, [sp, #8]
   16460:	3b02      	subs	r3, #2
   16462:	b2db      	uxtb	r3, r3
   16464:	2b01      	cmp	r3, #1
	u16_t handle = sys_le16_to_cpu(evt->handle);
   16466:	b2be      	uxth	r6, r7
	if (id_addr.type == BT_ADDR_LE_PUBLIC_ID ||
   16468:	d836      	bhi.n	164d8 <enh_conn_complete+0x114>
	memcpy(dst, src, sizeof(*dst));
   1646a:	2206      	movs	r2, #6
   1646c:	f105 0111 	add.w	r1, r5, #17
   16470:	f10d 0001 	add.w	r0, sp, #1
		id_addr.type -= BT_ADDR_LE_PUBLIC_ID;
   16474:	f88d 3008 	strb.w	r3, [sp, #8]
   16478:	f013 ffe9 	bl	2a44e <memcpy>
		peer_addr.type = BT_ADDR_LE_RANDOM;
   1647c:	2301      	movs	r3, #1
   1647e:	f88d 3000 	strb.w	r3, [sp]
	conn = find_pending_connect(&id_addr);
   16482:	a802      	add	r0, sp, #8
   16484:	f014 f983 	bl	2a78e <find_pending_connect>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   16488:	78eb      	ldrb	r3, [r5, #3]
   1648a:	2b01      	cmp	r3, #1
	conn = find_pending_connect(&id_addr);
   1648c:	4604      	mov	r4, r0
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   1648e:	d10e      	bne.n	164ae <enh_conn_complete+0xea>
   16490:	f8df 8180 	ldr.w	r8, [pc, #384]	; 16614 <enh_conn_complete+0x250>
   16494:	f06f 0140 	mvn.w	r1, #64	; 0x40
   16498:	f108 0070 	add.w	r0, r8, #112	; 0x70
   1649c:	f014 f957 	bl	2a74e <atomic_and>
		if (!conn) {
   164a0:	b9fc      	cbnz	r4, 164e2 <enh_conn_complete+0x11e>
			conn = bt_conn_add_le(bt_dev.adv_id, &id_addr);
   164a2:	a902      	add	r1, sp, #8
   164a4:	f898 0008 	ldrb.w	r0, [r8, #8]
   164a8:	f001 fc9c 	bl	17de4 <bt_conn_add_le>
   164ac:	4604      	mov	r4, r0
	if (!conn) {
   164ae:	b9c4      	cbnz	r4, 164e2 <enh_conn_complete+0x11e>
		BT_ERR("Unable to add new conn for handle %u", handle);
   164b0:	4b53      	ldr	r3, [pc, #332]	; (16600 <enh_conn_complete+0x23c>)
   164b2:	681b      	ldr	r3, [r3, #0]
   164b4:	0758      	lsls	r0, r3, #29
   164b6:	d0c7      	beq.n	16448 <enh_conn_complete+0x84>
   164b8:	2301      	movs	r3, #1
   164ba:	f04f 0200 	mov.w	r2, #0
   164be:	f363 0207 	bfi	r2, r3, #0, #8
   164c2:	4950      	ldr	r1, [pc, #320]	; (16604 <enh_conn_complete+0x240>)
   164c4:	4b50      	ldr	r3, [pc, #320]	; (16608 <enh_conn_complete+0x244>)
   164c6:	4852      	ldr	r0, [pc, #328]	; (16610 <enh_conn_complete+0x24c>)
   164c8:	1a5b      	subs	r3, r3, r1
   164ca:	08db      	lsrs	r3, r3, #3
   164cc:	f363 128f 	bfi	r2, r3, #6, #10
   164d0:	4631      	mov	r1, r6
   164d2:	f012 fa3f 	bl	28954 <log_1>
   164d6:	e7b7      	b.n	16448 <enh_conn_complete+0x84>
		bt_addr_le_copy(&peer_addr, &evt->peer_addr);
   164d8:	4621      	mov	r1, r4
   164da:	4668      	mov	r0, sp
   164dc:	f014 f925 	bl	2a72a <bt_addr_le_copy>
   164e0:	e7cf      	b.n	16482 <enh_conn_complete+0xbe>
	conn->handle = handle;
   164e2:	4620      	mov	r0, r4
	bt_addr_le_copy(&conn->le.dst, &id_addr);
   164e4:	a902      	add	r1, sp, #8
	conn->handle = handle;
   164e6:	f820 7b70 	strh.w	r7, [r0], #112
	bt_addr_le_copy(&conn->le.dst, &id_addr);
   164ea:	f014 f91e 	bl	2a72a <bt_addr_le_copy>
	conn->le.interval = sys_le16_to_cpu(evt->interval);
   164ee:	7e2a      	ldrb	r2, [r5, #24]
   164f0:	7deb      	ldrb	r3, [r5, #23]
   164f2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   164f6:	f8a4 3086 	strh.w	r3, [r4, #134]	; 0x86
	conn->le.latency = sys_le16_to_cpu(evt->latency);
   164fa:	7eaa      	ldrb	r2, [r5, #26]
   164fc:	7e6b      	ldrb	r3, [r5, #25]
   164fe:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   16502:	f8a4 308c 	strh.w	r3, [r4, #140]	; 0x8c
	conn->le.timeout = sys_le16_to_cpu(evt->supv_timeout);
   16506:	7eeb      	ldrb	r3, [r5, #27]
   16508:	7f2a      	ldrb	r2, [r5, #28]
   1650a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1650e:	f8a4 308e 	strh.w	r3, [r4, #142]	; 0x8e
	conn->role = evt->role;
   16512:	78ee      	ldrb	r6, [r5, #3]
   16514:	70e6      	strb	r6, [r4, #3]
	conn->err = 0U;
   16516:	f04f 0800 	mov.w	r8, #0
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   1651a:	2e01      	cmp	r6, #1
	conn->err = 0U;
   1651c:	f884 8009 	strb.w	r8, [r4, #9]
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   16520:	d11d      	bne.n	1655e <enh_conn_complete+0x19a>
		bt_addr_le_copy(&conn->le.init_addr, &peer_addr);
   16522:	4669      	mov	r1, sp
   16524:	f104 0077 	add.w	r0, r4, #119	; 0x77
   16528:	f014 f8ff 	bl	2a72a <bt_addr_le_copy>
					&bt_dev.id_addr[conn->id]);
   1652c:	7a21      	ldrb	r1, [r4, #8]
   1652e:	4f39      	ldr	r7, [pc, #228]	; (16614 <enh_conn_complete+0x250>)
   16530:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
			bt_addr_le_copy(&conn->le.resp_addr,
   16534:	4439      	add	r1, r7
   16536:	f104 007e 	add.w	r0, r4, #126	; 0x7e
   1653a:	f014 f8f6 	bl	2a72a <bt_addr_le_copy>
		if (atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
   1653e:	2109      	movs	r1, #9
   16540:	f107 0070 	add.w	r0, r7, #112	; 0x70
   16544:	f014 f930 	bl	2a7a8 <atomic_test_bit>
   16548:	b148      	cbz	r0, 1655e <enh_conn_complete+0x19a>
		    BT_LE_STATES_SLAVE_CONN_ADV(bt_dev.le.states)) {
   1654a:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
   1654e:	4642      	mov	r2, r8
   16550:	f001 0340 	and.w	r3, r1, #64	; 0x40
		if (atomic_test_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING) &&
   16554:	4313      	orrs	r3, r2
   16556:	d002      	beq.n	1655e <enh_conn_complete+0x19a>
			set_advertise_enable(true);
   16558:	4630      	mov	r0, r6
   1655a:	f7ff f9fd 	bl	15958 <set_advertise_enable>
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   1655e:	78e3      	ldrb	r3, [r4, #3]
   16560:	b96b      	cbnz	r3, 1657e <enh_conn_complete+0x1ba>
		bt_addr_le_copy(&conn->le.resp_addr, &peer_addr);
   16562:	4669      	mov	r1, sp
   16564:	f104 007e 	add.w	r0, r4, #126	; 0x7e
   16568:	f014 f8df 	bl	2a72a <bt_addr_le_copy>
					&bt_dev.id_addr[conn->id]);
   1656c:	7a21      	ldrb	r1, [r4, #8]
			bt_addr_le_copy(&conn->le.init_addr,
   1656e:	4b29      	ldr	r3, [pc, #164]	; (16614 <enh_conn_complete+0x250>)
					&bt_dev.id_addr[conn->id]);
   16570:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
			bt_addr_le_copy(&conn->le.init_addr,
   16574:	4419      	add	r1, r3
   16576:	f104 0077 	add.w	r0, r4, #119	; 0x77
   1657a:	f014 f8d6 	bl	2a72a <bt_addr_le_copy>
	bt_conn_set_state(conn, BT_CONN_CONNECTED);
   1657e:	2104      	movs	r1, #4
   16580:	4620      	mov	r0, r4
   16582:	f001 fc7d 	bl	17e80 <bt_conn_set_state>
	if (conn->state != BT_CONN_CONNECTED) {
   16586:	7aa3      	ldrb	r3, [r4, #10]
   16588:	2b04      	cmp	r3, #4
   1658a:	f47f af33 	bne.w	163f4 <enh_conn_complete+0x30>
	if ((evt->role == BT_HCI_ROLE_MASTER) ||
   1658e:	78eb      	ldrb	r3, [r5, #3]
   16590:	b123      	cbz	r3, 1659c <enh_conn_complete+0x1d8>
	    BT_FEAT_LE_SLAVE_FEATURE_XCHG(bt_dev.le.features)) {
   16592:	4b20      	ldr	r3, [pc, #128]	; (16614 <enh_conn_complete+0x250>)
	if ((evt->role == BT_HCI_ROLE_MASTER) ||
   16594:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
   16598:	0719      	lsls	r1, r3, #28
   1659a:	d512      	bpl.n	165c2 <enh_conn_complete+0x1fe>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_READ_REMOTE_FEATURES,
   1659c:	2102      	movs	r1, #2
   1659e:	f242 0016 	movw	r0, #8214	; 0x2016
   165a2:	f7ff f8f5 	bl	15790 <bt_hci_cmd_create>
	if (!buf) {
   165a6:	4605      	mov	r5, r0
   165a8:	b158      	cbz	r0, 165c2 <enh_conn_complete+0x1fe>
	cp = net_buf_add(buf, sizeof(*cp));
   165aa:	2102      	movs	r1, #2
   165ac:	3008      	adds	r0, #8
   165ae:	f016 fae7 	bl	2cb80 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
   165b2:	8823      	ldrh	r3, [r4, #0]
   165b4:	8003      	strh	r3, [r0, #0]
	bt_hci_cmd_send(BT_HCI_OP_LE_READ_REMOTE_FEATURES, buf);
   165b6:	4629      	mov	r1, r5
   165b8:	f242 0016 	movw	r0, #8214	; 0x2016
   165bc:	f7ff fb32 	bl	15c24 <bt_hci_cmd_send>
		if (!err) {
   165c0:	e718      	b.n	163f4 <enh_conn_complete+0x30>
	    BT_FEAT_LE_PHY_2M(bt_dev.le.features)) {
   165c2:	4d14      	ldr	r5, [pc, #80]	; (16614 <enh_conn_complete+0x250>)
	if (IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) &&
   165c4:	f895 2079 	ldrb.w	r2, [r5, #121]	; 0x79
   165c8:	07d2      	lsls	r2, r2, #31
   165ca:	d508      	bpl.n	165de <enh_conn_complete+0x21a>
		err = hci_le_set_phy(conn);
   165cc:	4620      	mov	r0, r4
   165ce:	f014 f936 	bl	2a83e <hci_le_set_phy.isra.30>
		if (!err) {
   165d2:	b920      	cbnz	r0, 165de <enh_conn_complete+0x21a>
	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   165d4:	2180      	movs	r1, #128	; 0x80
   165d6:	1d20      	adds	r0, r4, #4
   165d8:	f014 f8aa 	bl	2a730 <atomic_or>
   165dc:	e70a      	b.n	163f4 <enh_conn_complete+0x30>
	if (IS_ENABLED(CONFIG_BT_DATA_LEN_UPDATE) &&
   165de:	f895 3078 	ldrb.w	r3, [r5, #120]	; 0x78
   165e2:	069b      	lsls	r3, r3, #26
   165e4:	d502      	bpl.n	165ec <enh_conn_complete+0x228>
		hci_le_set_data_len(conn);
   165e6:	4620      	mov	r0, r4
   165e8:	f7ff fd3c 	bl	16064 <hci_le_set_data_len.isra.28>
	if (IS_ENABLED(CONFIG_BT_PERIPHERAL) &&
   165ec:	78e3      	ldrb	r3, [r4, #3]
   165ee:	2b01      	cmp	r3, #1
   165f0:	f47f af00 	bne.w	163f4 <enh_conn_complete+0x30>
		slave_update_conn_param(conn);
   165f4:	4620      	mov	r0, r4
   165f6:	f7fe ffd1 	bl	1559c <slave_update_conn_param>
   165fa:	e6fb      	b.n	163f4 <enh_conn_complete+0x30>
   165fc:	2000f790 	.word	0x2000f790
   16600:	20010004 	.word	0x20010004
   16604:	0002db28 	.word	0x0002db28
   16608:	0002dc00 	.word	0x0002dc00
   1660c:	0003091f 	.word	0x0003091f
   16610:	00030938 	.word	0x00030938
   16614:	2000f720 	.word	0x2000f720

00016618 <hci_tx_thread>:
{
   16618:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1661c:	4b58      	ldr	r3, [pc, #352]	; (16780 <hci_tx_thread+0x168>)
		BT_ERR("Uncleared pending sent_cmd");
   1661e:	4a59      	ldr	r2, [pc, #356]	; (16784 <hci_tx_thread+0x16c>)
   16620:	1a9b      	subs	r3, r3, r2
   16622:	f3c3 03c9 	ubfx	r3, r3, #3, #10
   16626:	9301      	str	r3, [sp, #4]
		events[0].state = K_POLL_STATE_NOT_READY;
   16628:	4a57      	ldr	r2, [pc, #348]	; (16788 <hci_tx_thread+0x170>)
   1662a:	68d3      	ldr	r3, [r2, #12]
   1662c:	f36f 3310 	bfc	r3, #12, #5
   16630:	60d3      	str	r3, [r2, #12]
			ev_count += bt_conn_prepare_events(&events[1]);
   16632:	f102 0014 	add.w	r0, r2, #20
   16636:	f001 fb8d 	bl	17d54 <bt_conn_prepare_events>
   1663a:	1c47      	adds	r7, r0, #1
	return z_impl_k_poll(events, num_events, timeout);
   1663c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16640:	4639      	mov	r1, r7
   16642:	4851      	ldr	r0, [pc, #324]	; (16788 <hci_tx_thread+0x170>)
   16644:	f011 f8be 	bl	277c4 <z_impl_k_poll>
		BT_ASSERT(err == 0);
   16648:	b140      	cbz	r0, 1665c <hci_tx_thread+0x44>
   1664a:	4850      	ldr	r0, [pc, #320]	; (1678c <hci_tx_thread+0x174>)
   1664c:	f011 fd7a 	bl	28144 <printk>
   16650:	4040      	eors	r0, r0
   16652:	f380 8811 	msr	BASEPRI, r0
   16656:	f04f 0003 	mov.w	r0, #3
   1665a:	df02      	svc	2
{
   1665c:	4d4a      	ldr	r5, [pc, #296]	; (16788 <hci_tx_thread+0x170>)
			BT_WARN("Unexpected k_poll event state %u", ev->state);
   1665e:	f8df b150 	ldr.w	fp, [pc, #336]	; 167b0 <hci_tx_thread+0x198>
	return z_impl_k_sem_take(sem, timeout);
   16662:	4c4b      	ldr	r4, [pc, #300]	; (16790 <hci_tx_thread+0x178>)
	for (; count; ev++, count--) {
   16664:	b917      	cbnz	r7, 1666c <hci_tx_thread+0x54>
	z_impl_k_yield();
   16666:	f010 fcd5 	bl	27014 <z_impl_k_yield>
   1666a:	e7dd      	b.n	16628 <hci_tx_thread+0x10>
		switch (ev->state) {
   1666c:	68e9      	ldr	r1, [r5, #12]
   1666e:	f3c1 3104 	ubfx	r1, r1, #12, #5
   16672:	2901      	cmp	r1, #1
   16674:	d966      	bls.n	16744 <hci_tx_thread+0x12c>
   16676:	2904      	cmp	r1, #4
   16678:	d16e      	bne.n	16758 <hci_tx_thread+0x140>
			if (ev->tag == BT_EVENT_CMD_TX) {
   1667a:	7b29      	ldrb	r1, [r5, #12]
   1667c:	2900      	cmp	r1, #0
   1667e:	d164      	bne.n	1674a <hci_tx_thread+0x132>
	buf = net_buf_get(&bt_dev.cmd_tx_queue, K_NO_WAIT);
   16680:	4844      	ldr	r0, [pc, #272]	; (16794 <hci_tx_thread+0x17c>)
   16682:	f016 fa4f 	bl	2cb24 <net_buf_get>
	BT_ASSERT(buf);
   16686:	4606      	mov	r6, r0
   16688:	b940      	cbnz	r0, 1669c <hci_tx_thread+0x84>
   1668a:	4843      	ldr	r0, [pc, #268]	; (16798 <hci_tx_thread+0x180>)
   1668c:	f011 fd5a 	bl	28144 <printk>
   16690:	4040      	eors	r0, r0
   16692:	f380 8811 	msr	BASEPRI, r0
   16696:	f04f 0003 	mov.w	r0, #3
   1669a:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
   1669c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   166a0:	483e      	ldr	r0, [pc, #248]	; (1679c <hci_tx_thread+0x184>)
   166a2:	f010 fd5d 	bl	27160 <z_impl_k_sem_take>
	if (bt_dev.sent_cmd) {
   166a6:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
   166aa:	b1bb      	cbz	r3, 166dc <hci_tx_thread+0xc4>
		BT_ERR("Uncleared pending sent_cmd");
   166ac:	f8db 3000 	ldr.w	r3, [fp]
   166b0:	075a      	lsls	r2, r3, #29
   166b2:	d00c      	beq.n	166ce <hci_tx_thread+0xb6>
   166b4:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   166b8:	f043 0301 	orr.w	r3, r3, #1
   166bc:	f363 0807 	bfi	r8, r3, #0, #8
   166c0:	9b01      	ldr	r3, [sp, #4]
   166c2:	4837      	ldr	r0, [pc, #220]	; (167a0 <hci_tx_thread+0x188>)
   166c4:	f363 188f 	bfi	r8, r3, #6, #10
   166c8:	4641      	mov	r1, r8
   166ca:	f012 f936 	bl	2893a <log_0>
		net_buf_unref(bt_dev.sent_cmd);
   166ce:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
   166d2:	f00e fdfb 	bl	252cc <net_buf_unref>
		bt_dev.sent_cmd = NULL;
   166d6:	2300      	movs	r3, #0
   166d8:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
	bt_dev.sent_cmd = net_buf_ref(buf);
   166dc:	4630      	mov	r0, r6
   166de:	f016 fa4b 	bl	2cb78 <net_buf_ref>
   166e2:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
	err = bt_send(buf);
   166e6:	4630      	mov	r0, r6
   166e8:	f7ff fa94 	bl	15c14 <bt_send>
	if (err) {
   166ec:	4601      	mov	r1, r0
   166ee:	b348      	cbz	r0, 16744 <hci_tx_thread+0x12c>
		BT_ERR("Unable to send to driver (err %d)", err);
   166f0:	f8db 3000 	ldr.w	r3, [fp]
   166f4:	075b      	lsls	r3, r3, #29
   166f6:	d00c      	beq.n	16712 <hci_tx_thread+0xfa>
   166f8:	f029 033f 	bic.w	r3, r9, #63	; 0x3f
   166fc:	f043 0301 	orr.w	r3, r3, #1
   16700:	f363 0907 	bfi	r9, r3, #0, #8
   16704:	9b01      	ldr	r3, [sp, #4]
   16706:	4827      	ldr	r0, [pc, #156]	; (167a4 <hci_tx_thread+0x18c>)
   16708:	f363 198f 	bfi	r9, r3, #6, #10
   1670c:	464a      	mov	r2, r9
   1670e:	f012 f921 	bl	28954 <log_1>
	z_impl_k_sem_give(sem);
   16712:	4822      	ldr	r0, [pc, #136]	; (1679c <hci_tx_thread+0x184>)
   16714:	f010 fcf8 	bl	27108 <z_impl_k_sem_give>
		hci_cmd_done(cmd(buf)->opcode, BT_HCI_ERR_UNSPECIFIED,
   16718:	4630      	mov	r0, r6
   1671a:	f00e fd41 	bl	251a0 <net_buf_id>
   1671e:	4a22      	ldr	r2, [pc, #136]	; (167a8 <hci_tx_thread+0x190>)
   16720:	230c      	movs	r3, #12
   16722:	fb03 2000 	mla	r0, r3, r0, r2
   16726:	211f      	movs	r1, #31
   16728:	2200      	movs	r2, #0
   1672a:	8840      	ldrh	r0, [r0, #2]
   1672c:	f7fe fe90 	bl	15450 <hci_cmd_done>
		net_buf_unref(bt_dev.sent_cmd);
   16730:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
   16734:	f00e fdca 	bl	252cc <net_buf_unref>
		bt_dev.sent_cmd = NULL;
   16738:	2300      	movs	r3, #0
		net_buf_unref(buf);
   1673a:	4630      	mov	r0, r6
		bt_dev.sent_cmd = NULL;
   1673c:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
		net_buf_unref(buf);
   16740:	f00e fdc4 	bl	252cc <net_buf_unref>
	for (; count; ev++, count--) {
   16744:	3514      	adds	r5, #20
   16746:	3f01      	subs	r7, #1
   16748:	e78c      	b.n	16664 <hci_tx_thread+0x4c>
				if (ev->tag == BT_EVENT_CONN_TX_QUEUE) {
   1674a:	2901      	cmp	r1, #1
   1674c:	d1fa      	bne.n	16744 <hci_tx_thread+0x12c>
					conn = CONTAINER_OF(ev->fifo,
   1674e:	6928      	ldr	r0, [r5, #16]
					bt_conn_process_tx(conn);
   16750:	3834      	subs	r0, #52	; 0x34
   16752:	f001 feff 	bl	18554 <bt_conn_process_tx>
   16756:	e7f5      	b.n	16744 <hci_tx_thread+0x12c>
			BT_WARN("Unexpected k_poll event state %u", ev->state);
   16758:	f8db 3000 	ldr.w	r3, [fp]
   1675c:	f013 0f06 	tst.w	r3, #6
   16760:	d0f0      	beq.n	16744 <hci_tx_thread+0x12c>
   16762:	f02a 033f 	bic.w	r3, sl, #63	; 0x3f
   16766:	f043 0302 	orr.w	r3, r3, #2
   1676a:	f363 0a07 	bfi	sl, r3, #0, #8
   1676e:	9b01      	ldr	r3, [sp, #4]
   16770:	480e      	ldr	r0, [pc, #56]	; (167ac <hci_tx_thread+0x194>)
   16772:	f363 1a8f 	bfi	sl, r3, #6, #10
   16776:	4652      	mov	r2, sl
   16778:	f012 f8ec 	bl	28954 <log_1>
   1677c:	e7e2      	b.n	16744 <hci_tx_thread+0x12c>
   1677e:	bf00      	nop
   16780:	0002dc00 	.word	0x0002dc00
   16784:	0002db28 	.word	0x0002db28
   16788:	2000f950 	.word	0x2000f950
   1678c:	00030c17 	.word	0x00030c17
   16790:	2000f720 	.word	0x2000f720
   16794:	2000f7e4 	.word	0x2000f7e4
   16798:	00030c32 	.word	0x00030c32
   1679c:	2000f7c8 	.word	0x2000f7c8
   167a0:	00030c48 	.word	0x00030c48
   167a4:	00030741 	.word	0x00030741
   167a8:	200009fc 	.word	0x200009fc
   167ac:	00030c63 	.word	0x00030c63
   167b0:	20010004 	.word	0x20010004

000167b4 <bt_recv>:
{
   167b4:	b570      	push	{r4, r5, r6, lr}
	 * pointer to an enum causes issues on qemu_x86 because the true
	 * size is 8-bit, but the enum is 32-bit on qemu_x86. So we put in
	 * a temporary cast to 8-bit to ensure only 8 bits are read from
	 * the pointer.
	 */
	return (enum bt_buf_type)(*(u8_t *)net_buf_user_data(buf));
   167b6:	7d01      	ldrb	r1, [r0, #20]
	switch (bt_buf_get_type(buf)) {
   167b8:	2901      	cmp	r1, #1
{
   167ba:	4604      	mov	r4, r0
	switch (bt_buf_get_type(buf)) {
   167bc:	d057      	beq.n	1686e <bt_recv+0xba>
   167be:	2903      	cmp	r1, #3
   167c0:	d17f      	bne.n	168c2 <bt_recv+0x10e>
	BT_ASSERT(buf->len >= sizeof(*hdr));
   167c2:	8983      	ldrh	r3, [r0, #12]
   167c4:	2b03      	cmp	r3, #3
   167c6:	d808      	bhi.n	167da <bt_recv+0x26>
   167c8:	484a      	ldr	r0, [pc, #296]	; (168f4 <bt_recv+0x140>)
   167ca:	f011 fcbb 	bl	28144 <printk>
   167ce:	4040      	eors	r0, r0
   167d0:	f380 8811 	msr	BASEPRI, r0
   167d4:	f04f 0003 	mov.w	r0, #3
   167d8:	df02      	svc	2
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
   167da:	2104      	movs	r1, #4
   167dc:	f104 0008 	add.w	r0, r4, #8
   167e0:	f016 f9ff 	bl	2cbe2 <net_buf_simple_pull_mem>
	if (buf->len != len) {
   167e4:	89a1      	ldrh	r1, [r4, #12]
	len = sys_le16_to_cpu(hdr->len);
   167e6:	8842      	ldrh	r2, [r0, #2]
	handle = sys_le16_to_cpu(hdr->handle);
   167e8:	8806      	ldrh	r6, [r0, #0]
	acl(buf)->id = BT_CONN_ID_INVALID;
   167ea:	23ff      	movs	r3, #255	; 0xff
	acl(buf)->handle = bt_acl_handle(handle);
   167ec:	f3c6 000b 	ubfx	r0, r6, #0, #12
	if (buf->len != len) {
   167f0:	428a      	cmp	r2, r1
	acl(buf)->handle = bt_acl_handle(handle);
   167f2:	82e0      	strh	r0, [r4, #22]
	acl(buf)->id = BT_CONN_ID_INVALID;
   167f4:	7563      	strb	r3, [r4, #21]
	if (buf->len != len) {
   167f6:	d015      	beq.n	16824 <bt_recv+0x70>
		BT_ERR("ACL data length mismatch (%u != %u)", buf->len, len);
   167f8:	4b3f      	ldr	r3, [pc, #252]	; (168f8 <bt_recv+0x144>)
   167fa:	681b      	ldr	r3, [r3, #0]
   167fc:	0758      	lsls	r0, r3, #29
   167fe:	d00d      	beq.n	1681c <bt_recv+0x68>
   16800:	2001      	movs	r0, #1
   16802:	f04f 0300 	mov.w	r3, #0
   16806:	f360 0307 	bfi	r3, r0, #0, #8
   1680a:	4d3c      	ldr	r5, [pc, #240]	; (168fc <bt_recv+0x148>)
   1680c:	483c      	ldr	r0, [pc, #240]	; (16900 <bt_recv+0x14c>)
   1680e:	1b40      	subs	r0, r0, r5
   16810:	08c0      	lsrs	r0, r0, #3
   16812:	f360 138f 	bfi	r3, r0, #6, #10
   16816:	483b      	ldr	r0, [pc, #236]	; (16904 <bt_recv+0x150>)
   16818:	f012 f8b0 	bl	2897c <log_2>
	net_buf_unref(buf);
   1681c:	4620      	mov	r0, r4
   1681e:	f00e fd55 	bl	252cc <net_buf_unref>
   16822:	e022      	b.n	1686a <bt_recv+0xb6>
	conn = bt_conn_lookup_handle(acl(buf)->handle);
   16824:	f001 fc16 	bl	18054 <bt_conn_lookup_handle>
	if (!conn) {
   16828:	4605      	mov	r5, r0
   1682a:	b998      	cbnz	r0, 16854 <bt_recv+0xa0>
		BT_ERR("Unable to find conn for handle %u", acl(buf)->handle);
   1682c:	4b32      	ldr	r3, [pc, #200]	; (168f8 <bt_recv+0x144>)
   1682e:	681b      	ldr	r3, [r3, #0]
   16830:	075a      	lsls	r2, r3, #29
   16832:	d0f3      	beq.n	1681c <bt_recv+0x68>
   16834:	2301      	movs	r3, #1
   16836:	f04f 0200 	mov.w	r2, #0
   1683a:	f363 0207 	bfi	r2, r3, #0, #8
   1683e:	492f      	ldr	r1, [pc, #188]	; (168fc <bt_recv+0x148>)
   16840:	4b2f      	ldr	r3, [pc, #188]	; (16900 <bt_recv+0x14c>)
   16842:	4831      	ldr	r0, [pc, #196]	; (16908 <bt_recv+0x154>)
   16844:	1a5b      	subs	r3, r3, r1
   16846:	08db      	lsrs	r3, r3, #3
   16848:	f363 128f 	bfi	r2, r3, #6, #10
   1684c:	8ae1      	ldrh	r1, [r4, #22]
   1684e:	f012 f881 	bl	28954 <log_1>
   16852:	e7e3      	b.n	1681c <bt_recv+0x68>
	acl(buf)->id = bt_conn_index(conn);
   16854:	f001 fede 	bl	18614 <bt_conn_index>
	bt_conn_recv(conn, buf, flags);
   16858:	0b32      	lsrs	r2, r6, #12
	acl(buf)->id = bt_conn_index(conn);
   1685a:	7560      	strb	r0, [r4, #21]
	bt_conn_recv(conn, buf, flags);
   1685c:	4621      	mov	r1, r4
   1685e:	4628      	mov	r0, r5
   16860:	f001 f928 	bl	17ab4 <bt_conn_recv>
	bt_conn_unref(conn);
   16864:	4628      	mov	r0, r5
   16866:	f014 f8cf 	bl	2aa08 <bt_conn_unref>
		return 0;
   1686a:	2000      	movs	r0, #0
}
   1686c:	bd70      	pop	{r4, r5, r6, pc}
	BT_ASSERT(buf->len >= sizeof(*hdr));
   1686e:	8983      	ldrh	r3, [r0, #12]
   16870:	2b01      	cmp	r3, #1
   16872:	d808      	bhi.n	16886 <bt_recv+0xd2>
   16874:	481f      	ldr	r0, [pc, #124]	; (168f4 <bt_recv+0x140>)
   16876:	f011 fc65 	bl	28144 <printk>
   1687a:	4040      	eors	r0, r0
   1687c:	f380 8811 	msr	BASEPRI, r0
   16880:	f04f 0003 	mov.w	r0, #3
   16884:	df02      	svc	2
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
   16886:	2102      	movs	r1, #2
   16888:	f104 0008 	add.w	r0, r4, #8
   1688c:	f016 f9a9 	bl	2cbe2 <net_buf_simple_pull_mem>
	BT_ASSERT(!bt_hci_evt_is_prio(hdr->evt));
   16890:	7802      	ldrb	r2, [r0, #0]
   16892:	2a1a      	cmp	r2, #26
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
   16894:	4605      	mov	r5, r0
 * @return true if the event can be processed in the RX thread, false
 *         if it cannot.
 */
static inline bool bt_hci_evt_is_prio(u8_t evt)
{
	switch (evt) {
   16896:	d80d      	bhi.n	168b4 <bt_recv+0x100>
   16898:	2301      	movs	r3, #1
   1689a:	4093      	lsls	r3, r2
   1689c:	4a1b      	ldr	r2, [pc, #108]	; (1690c <bt_recv+0x158>)
   1689e:	4213      	tst	r3, r2
   168a0:	d008      	beq.n	168b4 <bt_recv+0x100>
	BT_ASSERT(!bt_hci_evt_is_prio(hdr->evt));
   168a2:	481b      	ldr	r0, [pc, #108]	; (16910 <bt_recv+0x15c>)
   168a4:	f011 fc4e 	bl	28144 <printk>
   168a8:	4040      	eors	r0, r0
   168aa:	f380 8811 	msr	BASEPRI, r0
   168ae:	f04f 0003 	mov.w	r0, #3
   168b2:	df02      	svc	2
	handle_event(hdr->evt, buf, normal_events, ARRAY_SIZE(normal_events));
   168b4:	2303      	movs	r3, #3
   168b6:	4a17      	ldr	r2, [pc, #92]	; (16914 <bt_recv+0x160>)
   168b8:	7828      	ldrb	r0, [r5, #0]
   168ba:	4621      	mov	r1, r4
   168bc:	f7fe fd62 	bl	15384 <handle_event>
   168c0:	e7ac      	b.n	1681c <bt_recv+0x68>
		BT_ERR("Invalid buf type %u", bt_buf_get_type(buf));
   168c2:	4b0d      	ldr	r3, [pc, #52]	; (168f8 <bt_recv+0x144>)
   168c4:	681b      	ldr	r3, [r3, #0]
   168c6:	075b      	lsls	r3, r3, #29
   168c8:	d00d      	beq.n	168e6 <bt_recv+0x132>
   168ca:	2301      	movs	r3, #1
   168cc:	f04f 0200 	mov.w	r2, #0
   168d0:	f363 0207 	bfi	r2, r3, #0, #8
   168d4:	4809      	ldr	r0, [pc, #36]	; (168fc <bt_recv+0x148>)
   168d6:	4b0a      	ldr	r3, [pc, #40]	; (16900 <bt_recv+0x14c>)
   168d8:	1a1b      	subs	r3, r3, r0
   168da:	08db      	lsrs	r3, r3, #3
   168dc:	f363 128f 	bfi	r2, r3, #6, #10
   168e0:	480d      	ldr	r0, [pc, #52]	; (16918 <bt_recv+0x164>)
   168e2:	f012 f837 	bl	28954 <log_1>
		net_buf_unref(buf);
   168e6:	4620      	mov	r0, r4
   168e8:	f00e fcf0 	bl	252cc <net_buf_unref>
		return -EINVAL;
   168ec:	f06f 0015 	mvn.w	r0, #21
   168f0:	e7bc      	b.n	1686c <bt_recv+0xb8>
   168f2:	bf00      	nop
   168f4:	00030791 	.word	0x00030791
   168f8:	20010004 	.word	0x20010004
   168fc:	0002db28 	.word	0x0002db28
   16900:	0002dc00 	.word	0x0002dc00
   16904:	000307bc 	.word	0x000307bc
   16908:	000307e0 	.word	0x000307e0
   1690c:	0408c000 	.word	0x0408c000
   16910:	00030802 	.word	0x00030802
   16914:	0002e4d4 	.word	0x0002e4d4
   16918:	00030832 	.word	0x00030832

0001691c <bt_recv_prio>:
{
   1691c:	b538      	push	{r3, r4, r5, lr}
	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
   1691e:	7d03      	ldrb	r3, [r0, #20]
   16920:	2b01      	cmp	r3, #1
{
   16922:	4604      	mov	r4, r0
	BT_ASSERT(bt_buf_get_type(buf) == BT_BUF_EVT);
   16924:	d008      	beq.n	16938 <bt_recv_prio+0x1c>
   16926:	481b      	ldr	r0, [pc, #108]	; (16994 <bt_recv_prio+0x78>)
   16928:	f011 fc0c 	bl	28144 <printk>
   1692c:	4040      	eors	r0, r0
   1692e:	f380 8811 	msr	BASEPRI, r0
   16932:	f04f 0003 	mov.w	r0, #3
   16936:	df02      	svc	2
	BT_ASSERT(buf->len >= sizeof(*hdr));
   16938:	89a3      	ldrh	r3, [r4, #12]
   1693a:	2b01      	cmp	r3, #1
   1693c:	d808      	bhi.n	16950 <bt_recv_prio+0x34>
   1693e:	4816      	ldr	r0, [pc, #88]	; (16998 <bt_recv_prio+0x7c>)
   16940:	f011 fc00 	bl	28144 <printk>
   16944:	4040      	eors	r0, r0
   16946:	f380 8811 	msr	BASEPRI, r0
   1694a:	f04f 0003 	mov.w	r0, #3
   1694e:	df02      	svc	2
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
   16950:	2102      	movs	r1, #2
   16952:	f104 0008 	add.w	r0, r4, #8
   16956:	f016 f944 	bl	2cbe2 <net_buf_simple_pull_mem>
	BT_ASSERT(bt_hci_evt_is_prio(hdr->evt));
   1695a:	7802      	ldrb	r2, [r0, #0]
   1695c:	2a1a      	cmp	r2, #26
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
   1695e:	4605      	mov	r5, r0
   16960:	d804      	bhi.n	1696c <bt_recv_prio+0x50>
   16962:	2301      	movs	r3, #1
   16964:	4093      	lsls	r3, r2
   16966:	4a0d      	ldr	r2, [pc, #52]	; (1699c <bt_recv_prio+0x80>)
   16968:	4213      	tst	r3, r2
   1696a:	d108      	bne.n	1697e <bt_recv_prio+0x62>
	BT_ASSERT(bt_hci_evt_is_prio(hdr->evt));
   1696c:	480c      	ldr	r0, [pc, #48]	; (169a0 <bt_recv_prio+0x84>)
   1696e:	f011 fbe9 	bl	28144 <printk>
   16972:	4040      	eors	r0, r0
   16974:	f380 8811 	msr	BASEPRI, r0
   16978:	f04f 0003 	mov.w	r0, #3
   1697c:	df02      	svc	2
	handle_event(hdr->evt, buf, prio_events, ARRAY_SIZE(prio_events));
   1697e:	2304      	movs	r3, #4
   16980:	4a08      	ldr	r2, [pc, #32]	; (169a4 <bt_recv_prio+0x88>)
   16982:	7828      	ldrb	r0, [r5, #0]
   16984:	4621      	mov	r1, r4
   16986:	f7fe fcfd 	bl	15384 <handle_event>
	net_buf_unref(buf);
   1698a:	4620      	mov	r0, r4
   1698c:	f00e fc9e 	bl	252cc <net_buf_unref>
}
   16990:	2000      	movs	r0, #0
   16992:	bd38      	pop	{r3, r4, r5, pc}
   16994:	00030846 	.word	0x00030846
   16998:	00030791 	.word	0x00030791
   1699c:	0408c000 	.word	0x0408c000
   169a0:	0003087b 	.word	0x0003087b
   169a4:	0002e4fc 	.word	0x0002e4fc

000169a8 <bt_hci_driver_register>:
	if (bt_dev.drv) {
   169a8:	4a08      	ldr	r2, [pc, #32]	; (169cc <bt_hci_driver_register+0x24>)
   169aa:	f8d2 30d4 	ldr.w	r3, [r2, #212]	; 0xd4
   169ae:	b93b      	cbnz	r3, 169c0 <bt_hci_driver_register+0x18>
	if (!drv->open || !drv->send) {
   169b0:	68c1      	ldr	r1, [r0, #12]
   169b2:	b141      	cbz	r1, 169c6 <bt_hci_driver_register+0x1e>
   169b4:	6901      	ldr	r1, [r0, #16]
   169b6:	b131      	cbz	r1, 169c6 <bt_hci_driver_register+0x1e>
	bt_dev.drv = drv;
   169b8:	f8c2 00d4 	str.w	r0, [r2, #212]	; 0xd4
	return 0;
   169bc:	4618      	mov	r0, r3
   169be:	4770      	bx	lr
		return -EALREADY;
   169c0:	f06f 0044 	mvn.w	r0, #68	; 0x44
   169c4:	4770      	bx	lr
		return -EINVAL;
   169c6:	f06f 0015 	mvn.w	r0, #21
}
   169ca:	4770      	bx	lr
   169cc:	2000f720 	.word	0x2000f720

000169d0 <bt_finalize_init>:
{
   169d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   169d4:	4c41      	ldr	r4, [pc, #260]	; (16adc <bt_finalize_init+0x10c>)
   169d6:	4d42      	ldr	r5, [pc, #264]	; (16ae0 <bt_finalize_init+0x110>)
	BT_INFO("Identity%s: %s", bt_dev.id_count > 1 ? "[0]" : "",
   169d8:	4f42      	ldr	r7, [pc, #264]	; (16ae4 <bt_finalize_init+0x114>)
{
   169da:	b087      	sub	sp, #28
   169dc:	2102      	movs	r1, #2
   169de:	f104 0070 	add.w	r0, r4, #112	; 0x70
   169e2:	f013 fea5 	bl	2a730 <atomic_or>
		bt_le_scan_update(false);
   169e6:	2000      	movs	r0, #0
   169e8:	f7ff f9b0 	bl	15d4c <bt_le_scan_update>
	BT_INFO("Identity%s: %s", bt_dev.id_count > 1 ? "[0]" : "",
   169ec:	4b3e      	ldr	r3, [pc, #248]	; (16ae8 <bt_finalize_init+0x118>)
   169ee:	1aed      	subs	r5, r5, r3
   169f0:	683b      	ldr	r3, [r7, #0]
   169f2:	f003 0307 	and.w	r3, r3, #7
   169f6:	2b02      	cmp	r3, #2
   169f8:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   169fc:	d917      	bls.n	16a2e <bt_finalize_init+0x5e>
   169fe:	2303      	movs	r3, #3
   16a00:	f04f 0900 	mov.w	r9, #0
   16a04:	4939      	ldr	r1, [pc, #228]	; (16aec <bt_finalize_init+0x11c>)
   16a06:	4e3a      	ldr	r6, [pc, #232]	; (16af0 <bt_finalize_init+0x120>)
   16a08:	f363 0907 	bfi	r9, r3, #0, #8
   16a0c:	79e3      	ldrb	r3, [r4, #7]
   16a0e:	4620      	mov	r0, r4
   16a10:	2b01      	cmp	r3, #1
   16a12:	bf88      	it	hi
   16a14:	460e      	movhi	r6, r1
   16a16:	f7fe fb55 	bl	150c4 <bt_addr_le_str_real>
   16a1a:	f7fa fb6f 	bl	110fc <log_strdup>
   16a1e:	f365 198f 	bfi	r9, r5, #6, #10
   16a22:	4602      	mov	r2, r0
   16a24:	464b      	mov	r3, r9
   16a26:	4631      	mov	r1, r6
   16a28:	4832      	ldr	r0, [pc, #200]	; (16af4 <bt_finalize_init+0x124>)
   16a2a:	f011 ffa7 	bl	2897c <log_2>
		BT_INFO("Identity[%d]: %s",
   16a2e:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 16b00 <bt_finalize_init+0x130>
{
   16a32:	2601      	movs	r6, #1
	for (i = 1; i < bt_dev.id_count; i++) {
   16a34:	79e2      	ldrb	r2, [r4, #7]
   16a36:	683b      	ldr	r3, [r7, #0]
   16a38:	4296      	cmp	r6, r2
   16a3a:	f003 0307 	and.w	r3, r3, #7
   16a3e:	db34      	blt.n	16aaa <bt_finalize_init+0xda>
	BT_INFO("HCI: version %s (0x%02x) revision 0x%04x, manufacturer 0x%04x",
   16a40:	2b02      	cmp	r3, #2
   16a42:	d92f      	bls.n	16aa4 <bt_finalize_init+0xd4>
   16a44:	f894 8010 	ldrb.w	r8, [r4, #16]
   16a48:	2303      	movs	r3, #3
   16a4a:	f04f 0600 	mov.w	r6, #0
   16a4e:	4640      	mov	r0, r8
   16a50:	f363 0607 	bfi	r6, r3, #0, #8
   16a54:	f7fe fbb2 	bl	151bc <ver_str>
   16a58:	8a63      	ldrh	r3, [r4, #18]
   16a5a:	9304      	str	r3, [sp, #16]
   16a5c:	f365 168f 	bfi	r6, r5, #6, #10
   16a60:	8ae3      	ldrh	r3, [r4, #22]
   16a62:	9305      	str	r3, [sp, #20]
   16a64:	e9cd 0802 	strd	r0, r8, [sp, #8]
   16a68:	4633      	mov	r3, r6
   16a6a:	2204      	movs	r2, #4
   16a6c:	a902      	add	r1, sp, #8
   16a6e:	4822      	ldr	r0, [pc, #136]	; (16af8 <bt_finalize_init+0x128>)
   16a70:	f011 ffb7 	bl	289e2 <log_n>
	BT_INFO("LMP: version %s (0x%02x) subver 0x%04x",
   16a74:	683b      	ldr	r3, [r7, #0]
   16a76:	f003 0307 	and.w	r3, r3, #7
   16a7a:	2b02      	cmp	r3, #2
   16a7c:	d912      	bls.n	16aa4 <bt_finalize_init+0xd4>
   16a7e:	2303      	movs	r3, #3
   16a80:	f04f 0600 	mov.w	r6, #0
   16a84:	f363 0607 	bfi	r6, r3, #0, #8
   16a88:	f365 168f 	bfi	r6, r5, #6, #10
   16a8c:	7c65      	ldrb	r5, [r4, #17]
   16a8e:	4628      	mov	r0, r5
   16a90:	f7fe fb94 	bl	151bc <ver_str>
   16a94:	f8ad 6000 	strh.w	r6, [sp]
   16a98:	4601      	mov	r1, r0
   16a9a:	8aa3      	ldrh	r3, [r4, #20]
   16a9c:	4817      	ldr	r0, [pc, #92]	; (16afc <bt_finalize_init+0x12c>)
   16a9e:	462a      	mov	r2, r5
   16aa0:	f011 ff84 	bl	289ac <log_3>
}
   16aa4:	b007      	add	sp, #28
   16aa6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		BT_INFO("Identity[%d]: %s",
   16aaa:	2b02      	cmp	r3, #2
   16aac:	d914      	bls.n	16ad8 <bt_finalize_init+0x108>
   16aae:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   16ab2:	ebc6 00c6 	rsb	r0, r6, r6, lsl #3
   16ab6:	f043 0303 	orr.w	r3, r3, #3
   16aba:	4420      	add	r0, r4
   16abc:	f363 0807 	bfi	r8, r3, #0, #8
   16ac0:	f7fe fb00 	bl	150c4 <bt_addr_le_str_real>
   16ac4:	f7fa fb1a 	bl	110fc <log_strdup>
   16ac8:	f365 188f 	bfi	r8, r5, #6, #10
   16acc:	4602      	mov	r2, r0
   16ace:	4643      	mov	r3, r8
   16ad0:	4631      	mov	r1, r6
   16ad2:	4648      	mov	r0, r9
   16ad4:	f011 ff52 	bl	2897c <log_2>
	for (i = 1; i < bt_dev.id_count; i++) {
   16ad8:	3601      	adds	r6, #1
   16ada:	e7ab      	b.n	16a34 <bt_finalize_init+0x64>
   16adc:	2000f720 	.word	0x2000f720
   16ae0:	0002dc00 	.word	0x0002dc00
   16ae4:	20010004 	.word	0x20010004
   16ae8:	0002db28 	.word	0x0002db28
   16aec:	000306b8 	.word	0x000306b8
   16af0:	0002f979 	.word	0x0002f979
   16af4:	000306bc 	.word	0x000306bc
   16af8:	000306dc 	.word	0x000306dc
   16afc:	0003071a 	.word	0x0003071a
   16b00:	000306cb 	.word	0x000306cb

00016b04 <bt_get_name>:
}
   16b04:	4800      	ldr	r0, [pc, #0]	; (16b08 <bt_get_name+0x4>)
   16b06:	4770      	bx	lr
   16b08:	00030cc1 	.word	0x00030cc1

00016b0c <bt_id_get>:
{
   16b0c:	b538      	push	{r3, r4, r5, lr}
   16b0e:	460d      	mov	r5, r1
	size_t to_copy = MIN(*count, bt_dev.id_count);
   16b10:	4905      	ldr	r1, [pc, #20]	; (16b28 <bt_id_get+0x1c>)
   16b12:	682b      	ldr	r3, [r5, #0]
   16b14:	79cc      	ldrb	r4, [r1, #7]
   16b16:	429c      	cmp	r4, r3
   16b18:	bf28      	it	cs
   16b1a:	461c      	movcs	r4, r3
	memcpy(addrs, bt_dev.id_addr, to_copy * sizeof(bt_addr_le_t));
   16b1c:	ebc4 02c4 	rsb	r2, r4, r4, lsl #3
   16b20:	f013 fc95 	bl	2a44e <memcpy>
	*count = to_copy;
   16b24:	602c      	str	r4, [r5, #0]
}
   16b26:	bd38      	pop	{r3, r4, r5, pc}
   16b28:	2000f720 	.word	0x2000f720

00016b2c <bt_id_create>:
{
   16b2c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   16b2e:	460c      	mov	r4, r1
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
   16b30:	4606      	mov	r6, r0
   16b32:	b928      	cbnz	r0, 16b40 <bt_id_create+0x14>
	if (!IS_ENABLED(CONFIG_BT_PRIVACY) && irk) {
   16b34:	b38c      	cbz	r4, 16b9a <bt_id_create+0x6e>
			return -EINVAL;
   16b36:	f06f 0415 	mvn.w	r4, #21
}
   16b3a:	4620      	mov	r0, r4
   16b3c:	b002      	add	sp, #8
   16b3e:	bd70      	pop	{r4, r5, r6, pc}
	if (addr && bt_addr_le_cmp(addr, BT_ADDR_LE_ANY)) {
   16b40:	2300      	movs	r3, #0
	return memcmp(a, b, sizeof(*a));
   16b42:	2207      	movs	r2, #7
   16b44:	4669      	mov	r1, sp
   16b46:	9300      	str	r3, [sp, #0]
   16b48:	f8cd 3003 	str.w	r3, [sp, #3]
   16b4c:	f013 fc58 	bl	2a400 <memcmp>
   16b50:	2800      	cmp	r0, #0
   16b52:	d0ef      	beq.n	16b34 <bt_id_create+0x8>
		if (addr->type != BT_ADDR_LE_RANDOM ||
   16b54:	7833      	ldrb	r3, [r6, #0]
   16b56:	2b01      	cmp	r3, #1
   16b58:	d104      	bne.n	16b64 <bt_id_create+0x38>
   16b5a:	79b3      	ldrb	r3, [r6, #6]
   16b5c:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   16b60:	2bc0      	cmp	r3, #192	; 0xc0
   16b62:	d012      	beq.n	16b8a <bt_id_create+0x5e>
			BT_ERR("Only static random identity address supported");
   16b64:	4b1a      	ldr	r3, [pc, #104]	; (16bd0 <bt_id_create+0xa4>)
   16b66:	681b      	ldr	r3, [r3, #0]
   16b68:	075b      	lsls	r3, r3, #29
   16b6a:	d0e4      	beq.n	16b36 <bt_id_create+0xa>
   16b6c:	2301      	movs	r3, #1
   16b6e:	f04f 0100 	mov.w	r1, #0
   16b72:	f363 0107 	bfi	r1, r3, #0, #8
   16b76:	4a17      	ldr	r2, [pc, #92]	; (16bd4 <bt_id_create+0xa8>)
   16b78:	4b17      	ldr	r3, [pc, #92]	; (16bd8 <bt_id_create+0xac>)
   16b7a:	4818      	ldr	r0, [pc, #96]	; (16bdc <bt_id_create+0xb0>)
   16b7c:	1a9b      	subs	r3, r3, r2
   16b7e:	08db      	lsrs	r3, r3, #3
   16b80:	f363 118f 	bfi	r1, r3, #6, #10
   16b84:	f011 fed9 	bl	2893a <log_0>
   16b88:	e7d5      	b.n	16b36 <bt_id_create+0xa>
		if (id_find(addr) >= 0) {
   16b8a:	4630      	mov	r0, r6
   16b8c:	f7fe fcec 	bl	15568 <id_find>
   16b90:	2800      	cmp	r0, #0
   16b92:	dbcf      	blt.n	16b34 <bt_id_create+0x8>
			return -EALREADY;
   16b94:	f06f 0444 	mvn.w	r4, #68	; 0x44
   16b98:	e7cf      	b.n	16b3a <bt_id_create+0xe>
	if (bt_dev.id_count == ARRAY_SIZE(bt_dev.id_addr)) {
   16b9a:	4b11      	ldr	r3, [pc, #68]	; (16be0 <bt_id_create+0xb4>)
   16b9c:	79dd      	ldrb	r5, [r3, #7]
   16b9e:	2d01      	cmp	r5, #1
   16ba0:	d013      	beq.n	16bca <bt_id_create+0x9e>
	new_id = bt_dev.id_count++;
   16ba2:	1c6a      	adds	r2, r5, #1
   16ba4:	71da      	strb	r2, [r3, #7]
   16ba6:	462c      	mov	r4, r5
	if (new_id == BT_ID_DEFAULT &&
   16ba8:	b955      	cbnz	r5, 16bc0 <bt_id_create+0x94>
	    !atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   16baa:	2101      	movs	r1, #1
   16bac:	f103 0070 	add.w	r0, r3, #112	; 0x70
   16bb0:	f013 fdfa 	bl	2a7a8 <atomic_test_bit>
	if (new_id == BT_ID_DEFAULT &&
   16bb4:	b920      	cbnz	r0, 16bc0 <bt_id_create+0x94>
   16bb6:	2108      	movs	r1, #8
   16bb8:	f103 0070 	add.w	r0, r3, #112	; 0x70
   16bbc:	f013 fdb8 	bl	2a730 <atomic_or>
	id_create(new_id, addr, irk);
   16bc0:	4631      	mov	r1, r6
   16bc2:	4628      	mov	r0, r5
   16bc4:	f7fe fffa 	bl	15bbc <id_create.isra.25>
	return new_id;
   16bc8:	e7b7      	b.n	16b3a <bt_id_create+0xe>
		return -ENOMEM;
   16bca:	f06f 040b 	mvn.w	r4, #11
   16bce:	e7b4      	b.n	16b3a <bt_id_create+0xe>
   16bd0:	20010004 	.word	0x20010004
   16bd4:	0002db28 	.word	0x0002db28
   16bd8:	0002dc00 	.word	0x0002dc00
   16bdc:	00030763 	.word	0x00030763
   16be0:	2000f720 	.word	0x2000f720

00016be4 <bt_setup_id_addr>:
{
   16be4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (!bt_dev.id_count) {
   16be8:	4d42      	ldr	r5, [pc, #264]	; (16cf4 <bt_setup_id_addr+0x110>)
   16bea:	79ef      	ldrb	r7, [r5, #7]
{
   16bec:	b085      	sub	sp, #20
   16bee:	462e      	mov	r6, r5
	if (!bt_dev.id_count) {
   16bf0:	b95f      	cbnz	r7, 16c0a <bt_setup_id_addr+0x26>
	if (!(bt_dev.vs_commands[1] & BIT(0))) {
   16bf2:	f895 3062 	ldrb.w	r3, [r5, #98]	; 0x62
   16bf6:	f013 0401 	ands.w	r4, r3, #1
   16bfa:	d11b      	bne.n	16c34 <bt_setup_id_addr+0x50>
		BT_WARN("Read Static Addresses command not available");
   16bfc:	4b3e      	ldr	r3, [pc, #248]	; (16cf8 <bt_setup_id_addr+0x114>)
   16bfe:	681b      	ldr	r3, [r3, #0]
   16c00:	f013 0f06 	tst.w	r3, #6
   16c04:	d106      	bne.n	16c14 <bt_setup_id_addr+0x30>
		bt_dev.id_count = bt_read_static_addr(addrs);
   16c06:	2300      	movs	r3, #0
   16c08:	71f3      	strb	r3, [r6, #7]
	return bt_id_create(NULL, NULL);
   16c0a:	2100      	movs	r1, #0
   16c0c:	4608      	mov	r0, r1
   16c0e:	f7ff ff8d 	bl	16b2c <bt_id_create>
   16c12:	e061      	b.n	16cd8 <bt_setup_id_addr+0xf4>
		BT_WARN("Read Static Addresses command not available");
   16c14:	2302      	movs	r3, #2
   16c16:	f04f 0100 	mov.w	r1, #0
   16c1a:	f363 0107 	bfi	r1, r3, #0, #8
   16c1e:	4a37      	ldr	r2, [pc, #220]	; (16cfc <bt_setup_id_addr+0x118>)
   16c20:	4b37      	ldr	r3, [pc, #220]	; (16d00 <bt_setup_id_addr+0x11c>)
   16c22:	4838      	ldr	r0, [pc, #224]	; (16d04 <bt_setup_id_addr+0x120>)
   16c24:	1a9b      	subs	r3, r3, r2
   16c26:	08db      	lsrs	r3, r3, #3
   16c28:	f363 118f 	bfi	r1, r3, #6, #10
   16c2c:	f011 fe85 	bl	2893a <log_0>
		bt_dev.id_count = bt_read_static_addr(addrs);
   16c30:	71ec      	strb	r4, [r5, #7]
		if (bt_dev.id_count) {
   16c32:	e7ea      	b.n	16c0a <bt_setup_id_addr+0x26>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_STATIC_ADDRS, NULL, &rsp);
   16c34:	aa01      	add	r2, sp, #4
   16c36:	4639      	mov	r1, r7
   16c38:	f64f 4009 	movw	r0, #64521	; 0xfc09
   16c3c:	f7fe fdde 	bl	157fc <bt_hci_cmd_send_sync>
	if (err) {
   16c40:	4604      	mov	r4, r0
   16c42:	b1a0      	cbz	r0, 16c6e <bt_setup_id_addr+0x8a>
		BT_WARN("Failed to read static addresses");
   16c44:	4b2c      	ldr	r3, [pc, #176]	; (16cf8 <bt_setup_id_addr+0x114>)
   16c46:	681b      	ldr	r3, [r3, #0]
   16c48:	f013 0f06 	tst.w	r3, #6
   16c4c:	d0db      	beq.n	16c06 <bt_setup_id_addr+0x22>
   16c4e:	2302      	movs	r3, #2
   16c50:	f04f 0100 	mov.w	r1, #0
   16c54:	f363 0107 	bfi	r1, r3, #0, #8
   16c58:	4a28      	ldr	r2, [pc, #160]	; (16cfc <bt_setup_id_addr+0x118>)
   16c5a:	4b29      	ldr	r3, [pc, #164]	; (16d00 <bt_setup_id_addr+0x11c>)
   16c5c:	482a      	ldr	r0, [pc, #168]	; (16d08 <bt_setup_id_addr+0x124>)
   16c5e:	1a9b      	subs	r3, r3, r2
   16c60:	08db      	lsrs	r3, r3, #3
   16c62:	f363 118f 	bfi	r1, r3, #6, #10
   16c66:	f011 fe68 	bl	2893a <log_0>
		bt_dev.id_count = bt_read_static_addr(addrs);
   16c6a:	71ef      	strb	r7, [r5, #7]
		if (bt_dev.id_count) {
   16c6c:	e7cd      	b.n	16c0a <bt_setup_id_addr+0x26>
	rp = (void *)rsp->data;
   16c6e:	9b01      	ldr	r3, [sp, #4]
   16c70:	6899      	ldr	r1, [r3, #8]
	cnt = MIN(rp->num_addrs, CONFIG_BT_ID_MAX);
   16c72:	784d      	ldrb	r5, [r1, #1]
   16c74:	1c2f      	adds	r7, r5, #0
   16c76:	bf18      	it	ne
   16c78:	2701      	movne	r7, #1
	for (i = 0; i < cnt; i++) {
   16c7a:	4603      	mov	r3, r0
		addr[i].type = BT_ADDR_LE_RANDOM;
   16c7c:	f04f 0901 	mov.w	r9, #1
		bt_addr_copy(&addr[i].a, &rp->a[i].bdaddr);
   16c80:	f101 0802 	add.w	r8, r1, #2
	for (i = 0; i < cnt; i++) {
   16c84:	429f      	cmp	r7, r3
   16c86:	dc2a      	bgt.n	16cde <bt_setup_id_addr+0xfa>
	net_buf_unref(rsp);
   16c88:	9801      	ldr	r0, [sp, #4]
   16c8a:	f00e fb1f 	bl	252cc <net_buf_unref>
	if (!cnt) {
   16c8e:	b995      	cbnz	r5, 16cb6 <bt_setup_id_addr+0xd2>
		BT_WARN("No static addresses stored in controller");
   16c90:	4b19      	ldr	r3, [pc, #100]	; (16cf8 <bt_setup_id_addr+0x114>)
   16c92:	681b      	ldr	r3, [r3, #0]
   16c94:	f013 0f06 	tst.w	r3, #6
   16c98:	d00d      	beq.n	16cb6 <bt_setup_id_addr+0xd2>
   16c9a:	2302      	movs	r3, #2
   16c9c:	f04f 0100 	mov.w	r1, #0
   16ca0:	f363 0107 	bfi	r1, r3, #0, #8
   16ca4:	4a15      	ldr	r2, [pc, #84]	; (16cfc <bt_setup_id_addr+0x118>)
   16ca6:	4b16      	ldr	r3, [pc, #88]	; (16d00 <bt_setup_id_addr+0x11c>)
   16ca8:	4818      	ldr	r0, [pc, #96]	; (16d0c <bt_setup_id_addr+0x128>)
   16caa:	1a9b      	subs	r3, r3, r2
   16cac:	08db      	lsrs	r3, r3, #3
   16cae:	f363 118f 	bfi	r1, r3, #6, #10
   16cb2:	f011 fe42 	bl	2893a <log_0>
		bt_dev.id_count = bt_read_static_addr(addrs);
   16cb6:	71f7      	strb	r7, [r6, #7]
		if (bt_dev.id_count) {
   16cb8:	2d00      	cmp	r5, #0
   16cba:	d0a6      	beq.n	16c0a <bt_setup_id_addr+0x26>
   16cbc:	ad02      	add	r5, sp, #8
				id_create(i, &addrs[i], NULL);
   16cbe:	4629      	mov	r1, r5
   16cc0:	b2e0      	uxtb	r0, r4
   16cc2:	f7fe ff7b 	bl	15bbc <id_create.isra.25>
			for (i = 0; i < bt_dev.id_count; i++) {
   16cc6:	79f3      	ldrb	r3, [r6, #7]
   16cc8:	3401      	adds	r4, #1
   16cca:	42a3      	cmp	r3, r4
   16ccc:	f105 0507 	add.w	r5, r5, #7
   16cd0:	dcf5      	bgt.n	16cbe <bt_setup_id_addr+0xda>
			return set_random_address(&bt_dev.id_addr[0].a);
   16cd2:	480f      	ldr	r0, [pc, #60]	; (16d10 <bt_setup_id_addr+0x12c>)
   16cd4:	f7fe fe12 	bl	158fc <set_random_address>
}
   16cd8:	b005      	add	sp, #20
   16cda:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	memcpy(dst, src, sizeof(*dst));
   16cde:	2206      	movs	r2, #6
   16ce0:	4641      	mov	r1, r8
   16ce2:	f10d 0009 	add.w	r0, sp, #9
		addr[i].type = BT_ADDR_LE_RANDOM;
   16ce6:	f88d 9008 	strb.w	r9, [sp, #8]
   16cea:	f013 fbb0 	bl	2a44e <memcpy>
	for (i = 0; i < cnt; i++) {
   16cee:	2301      	movs	r3, #1
   16cf0:	e7c8      	b.n	16c84 <bt_setup_id_addr+0xa0>
   16cf2:	bf00      	nop
   16cf4:	2000f720 	.word	0x2000f720
   16cf8:	20010004 	.word	0x20010004
   16cfc:	0002db28 	.word	0x0002db28
   16d00:	0002dc00 	.word	0x0002dc00
   16d04:	000308aa 	.word	0x000308aa
   16d08:	000308d6 	.word	0x000308d6
   16d0c:	000308f6 	.word	0x000308f6
   16d10:	2000f721 	.word	0x2000f721

00016d14 <hci_init>:
{
   16d14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
   16d18:	4d5e      	ldr	r5, [pc, #376]	; (16e94 <hci_init+0x180>)
   16d1a:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
   16d1e:	6899      	ldr	r1, [r3, #8]
   16d20:	f011 0101 	ands.w	r1, r1, #1
{
   16d24:	b08a      	sub	sp, #40	; 0x28
	if (!(bt_dev.drv->quirks & BT_QUIRK_NO_RESET)) {
   16d26:	d124      	bne.n	16d72 <hci_init+0x5e>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_RESET, NULL, &rsp);
   16d28:	aa05      	add	r2, sp, #20
   16d2a:	f640 4003 	movw	r0, #3075	; 0xc03
   16d2e:	f7fe fd65 	bl	157fc <bt_hci_cmd_send_sync>
		if (err) {
   16d32:	4604      	mov	r4, r0
   16d34:	2800      	cmp	r0, #0
   16d36:	f040 809a 	bne.w	16e6e <hci_init+0x15a>
		hci_reset_complete(rsp);
   16d3a:	9b05      	ldr	r3, [sp, #20]
	u8_t status = buf->data[0];
   16d3c:	689b      	ldr	r3, [r3, #8]
	if (status) {
   16d3e:	781b      	ldrb	r3, [r3, #0]
   16d40:	b9a3      	cbnz	r3, 16d6c <hci_init+0x58>
	scan_dev_found_cb = NULL;
   16d42:	4a55      	ldr	r2, [pc, #340]	; (16e98 <hci_init+0x184>)
   16d44:	6013      	str	r3, [r2, #0]
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   16d46:	462b      	mov	r3, r5
   16d48:	f3bf 8f5b 	dmb	ish
   16d4c:	f853 2f70 	ldr.w	r2, [r3, #112]!
   16d50:	f3bf 8f5b 	dmb	ish
	flags = (atomic_get(bt_dev.flags) & BT_DEV_PERSISTENT_FLAGS);
   16d54:	f002 020d 	and.w	r2, r2, #13
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   16d58:	f3bf 8f5b 	dmb	ish
   16d5c:	e853 1f00 	ldrex	r1, [r3]
   16d60:	e843 2000 	strex	r0, r2, [r3]
   16d64:	2800      	cmp	r0, #0
   16d66:	d1f9      	bne.n	16d5c <hci_init+0x48>
   16d68:	f3bf 8f5b 	dmb	ish
		net_buf_unref(rsp);
   16d6c:	9805      	ldr	r0, [sp, #20]
   16d6e:	f00e faad 	bl	252cc <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_FEATURES, NULL, &rsp);
   16d72:	aa05      	add	r2, sp, #20
   16d74:	2100      	movs	r1, #0
   16d76:	f241 0003 	movw	r0, #4099	; 0x1003
   16d7a:	f7fe fd3f 	bl	157fc <bt_hci_cmd_send_sync>
	if (err) {
   16d7e:	4604      	mov	r4, r0
   16d80:	2800      	cmp	r0, #0
   16d82:	d174      	bne.n	16e6e <hci_init+0x15a>
	read_local_features_complete(rsp);
   16d84:	9b05      	ldr	r3, [sp, #20]
	memcpy(bt_dev.features[0], rp->features, sizeof(bt_dev.features[0]));
   16d86:	4845      	ldr	r0, [pc, #276]	; (16e9c <hci_init+0x188>)
   16d88:	6899      	ldr	r1, [r3, #8]
   16d8a:	2208      	movs	r2, #8
   16d8c:	3101      	adds	r1, #1
   16d8e:	f013 fb5e 	bl	2a44e <memcpy>
	net_buf_unref(rsp);
   16d92:	9805      	ldr	r0, [sp, #20]
   16d94:	f00e fa9a 	bl	252cc <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_LOCAL_VERSION_INFO, NULL,
   16d98:	4621      	mov	r1, r4
   16d9a:	aa05      	add	r2, sp, #20
   16d9c:	f241 0001 	movw	r0, #4097	; 0x1001
   16da0:	f7fe fd2c 	bl	157fc <bt_hci_cmd_send_sync>
	if (err) {
   16da4:	4604      	mov	r4, r0
   16da6:	2800      	cmp	r0, #0
   16da8:	d161      	bne.n	16e6e <hci_init+0x15a>
	read_local_ver_complete(rsp);
   16daa:	9805      	ldr	r0, [sp, #20]
   16dac:	6883      	ldr	r3, [r0, #8]
	bt_dev.hci_version = rp->hci_version;
   16dae:	785a      	ldrb	r2, [r3, #1]
   16db0:	742a      	strb	r2, [r5, #16]
	bt_dev.hci_revision = sys_le16_to_cpu(rp->hci_revision);
   16db2:	78d9      	ldrb	r1, [r3, #3]
   16db4:	789a      	ldrb	r2, [r3, #2]
   16db6:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   16dba:	826a      	strh	r2, [r5, #18]
	bt_dev.lmp_version = rp->lmp_version;
   16dbc:	791a      	ldrb	r2, [r3, #4]
   16dbe:	746a      	strb	r2, [r5, #17]
	bt_dev.lmp_subversion = sys_le16_to_cpu(rp->lmp_subversion);
   16dc0:	7a19      	ldrb	r1, [r3, #8]
   16dc2:	79da      	ldrb	r2, [r3, #7]
   16dc4:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   16dc8:	82aa      	strh	r2, [r5, #20]
	bt_dev.manufacturer = sys_le16_to_cpu(rp->manufacturer);
   16dca:	795a      	ldrb	r2, [r3, #5]
   16dcc:	799b      	ldrb	r3, [r3, #6]
   16dce:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
   16dd2:	82eb      	strh	r3, [r5, #22]
	net_buf_unref(rsp);
   16dd4:	f00e fa7a 	bl	252cc <net_buf_unref>
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_USER_ID_ADDR)) {
   16dd8:	2103      	movs	r1, #3
   16dda:	4831      	ldr	r0, [pc, #196]	; (16ea0 <hci_init+0x18c>)
   16ddc:	f013 fce4 	bl	2a7a8 <atomic_test_bit>
   16de0:	4601      	mov	r1, r0
   16de2:	bb48      	cbnz	r0, 16e38 <hci_init+0x124>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BD_ADDR, NULL, &rsp);
   16de4:	aa05      	add	r2, sp, #20
   16de6:	f241 0009 	movw	r0, #4105	; 0x1009
   16dea:	f7fe fd07 	bl	157fc <bt_hci_cmd_send_sync>
		if (err) {
   16dee:	4604      	mov	r4, r0
   16df0:	2800      	cmp	r0, #0
   16df2:	d13c      	bne.n	16e6e <hci_init+0x15a>
		read_bdaddr_complete(rsp);
   16df4:	9b05      	ldr	r3, [sp, #20]
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
   16df6:	9001      	str	r0, [sp, #4]
   16df8:	689e      	ldr	r6, [r3, #8]
   16dfa:	f8ad 0008 	strh.w	r0, [sp, #8]
   16dfe:	3601      	adds	r6, #1
	return memcmp(a, b, sizeof(*a));
   16e00:	2206      	movs	r2, #6
   16e02:	a901      	add	r1, sp, #4
   16e04:	4630      	mov	r0, r6
   16e06:	f013 fafb 	bl	2a400 <memcmp>
   16e0a:	b190      	cbz	r0, 16e32 <hci_init+0x11e>
	    !bt_addr_cmp(&rp->bdaddr, BT_ADDR_NONE)) {
   16e0c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   16e10:	2206      	movs	r2, #6
   16e12:	a903      	add	r1, sp, #12
   16e14:	4630      	mov	r0, r6
   16e16:	9303      	str	r3, [sp, #12]
   16e18:	f8ad 3010 	strh.w	r3, [sp, #16]
   16e1c:	f013 faf0 	bl	2a400 <memcmp>
	if (!bt_addr_cmp(&rp->bdaddr, BT_ADDR_ANY) ||
   16e20:	b138      	cbz	r0, 16e32 <hci_init+0x11e>
	memcpy(dst, src, sizeof(*dst));
   16e22:	2206      	movs	r2, #6
   16e24:	4631      	mov	r1, r6
   16e26:	481f      	ldr	r0, [pc, #124]	; (16ea4 <hci_init+0x190>)
   16e28:	f013 fb11 	bl	2a44e <memcpy>
	bt_dev.id_count = 1U;
   16e2c:	2301      	movs	r3, #1
	bt_dev.id_addr[0].type = BT_ADDR_LE_PUBLIC;
   16e2e:	702c      	strb	r4, [r5, #0]
	bt_dev.id_count = 1U;
   16e30:	71eb      	strb	r3, [r5, #7]
		net_buf_unref(rsp);
   16e32:	9805      	ldr	r0, [sp, #20]
   16e34:	f00e fa4a 	bl	252cc <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_SUPPORTED_COMMANDS, NULL,
   16e38:	aa05      	add	r2, sp, #20
   16e3a:	2100      	movs	r1, #0
   16e3c:	f241 0002 	movw	r0, #4098	; 0x1002
   16e40:	f7fe fcdc 	bl	157fc <bt_hci_cmd_send_sync>
	if (err) {
   16e44:	4604      	mov	r4, r0
   16e46:	b990      	cbnz	r0, 16e6e <hci_init+0x15a>
	read_supported_commands_complete(rsp);
   16e48:	9b05      	ldr	r3, [sp, #20]
	memcpy(bt_dev.supported_commands, rp->commands,
   16e4a:	4817      	ldr	r0, [pc, #92]	; (16ea8 <hci_init+0x194>)
   16e4c:	6899      	ldr	r1, [r3, #8]
   16e4e:	2240      	movs	r2, #64	; 0x40
   16e50:	3101      	adds	r1, #1
   16e52:	f013 fafc 	bl	2a44e <memcpy>
	net_buf_unref(rsp);
   16e56:	9805      	ldr	r0, [sp, #20]
   16e58:	f00e fa38 	bl	252cc <net_buf_unref>
	if (!BT_FEAT_LE(bt_dev.features)) {
   16e5c:	7f2b      	ldrb	r3, [r5, #28]
   16e5e:	065e      	lsls	r6, r3, #25
   16e60:	d42c      	bmi.n	16ebc <hci_init+0x1a8>
		BT_ERR("Non-LE capable controller detected!");
   16e62:	4b12      	ldr	r3, [pc, #72]	; (16eac <hci_init+0x198>)
   16e64:	681b      	ldr	r3, [r3, #0]
   16e66:	075d      	lsls	r5, r3, #29
   16e68:	d105      	bne.n	16e76 <hci_init+0x162>
		return -ENODEV;
   16e6a:	f06f 0412 	mvn.w	r4, #18
}
   16e6e:	4620      	mov	r0, r4
   16e70:	b00a      	add	sp, #40	; 0x28
   16e72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		BT_ERR("Non-LE capable controller detected!");
   16e76:	2301      	movs	r3, #1
   16e78:	f04f 0100 	mov.w	r1, #0
   16e7c:	f363 0107 	bfi	r1, r3, #0, #8
   16e80:	4a0b      	ldr	r2, [pc, #44]	; (16eb0 <hci_init+0x19c>)
   16e82:	4b0c      	ldr	r3, [pc, #48]	; (16eb4 <hci_init+0x1a0>)
   16e84:	480c      	ldr	r0, [pc, #48]	; (16eb8 <hci_init+0x1a4>)
   16e86:	1a9b      	subs	r3, r3, r2
   16e88:	08db      	lsrs	r3, r3, #3
   16e8a:	f363 118f 	bfi	r1, r3, #6, #10
   16e8e:	f011 fd54 	bl	2893a <log_0>
   16e92:	e7ea      	b.n	16e6a <hci_init+0x156>
   16e94:	2000f720 	.word	0x2000f720
   16e98:	20000a18 	.word	0x20000a18
   16e9c:	2000f738 	.word	0x2000f738
   16ea0:	2000f790 	.word	0x2000f790
   16ea4:	2000f721 	.word	0x2000f721
   16ea8:	2000f740 	.word	0x2000f740
   16eac:	20010004 	.word	0x20010004
   16eb0:	0002db28 	.word	0x0002db28
   16eb4:	0002dc00 	.word	0x0002dc00
   16eb8:	00030a57 	.word	0x00030a57
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
   16ebc:	4621      	mov	r1, r4
   16ebe:	aa05      	add	r2, sp, #20
   16ec0:	f242 0003 	movw	r0, #8195	; 0x2003
   16ec4:	f7fe fc9a 	bl	157fc <bt_hci_cmd_send_sync>
	if (err) {
   16ec8:	4604      	mov	r4, r0
   16eca:	2800      	cmp	r0, #0
   16ecc:	d1cf      	bne.n	16e6e <hci_init+0x15a>
	read_le_features_complete(rsp);
   16ece:	9b05      	ldr	r3, [sp, #20]
	memcpy(bt_dev.le.features, rp->features, sizeof(bt_dev.le.features));
   16ed0:	4890      	ldr	r0, [pc, #576]	; (17114 <hci_init+0x400>)
   16ed2:	6899      	ldr	r1, [r3, #8]
   16ed4:	2208      	movs	r2, #8
   16ed6:	3101      	adds	r1, #1
   16ed8:	f013 fab9 	bl	2a44e <memcpy>
	net_buf_unref(rsp);
   16edc:	9805      	ldr	r0, [sp, #20]
   16ede:	f00e f9f5 	bl	252cc <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_BUFFER_SIZE,
   16ee2:	4621      	mov	r1, r4
   16ee4:	aa05      	add	r2, sp, #20
   16ee6:	f242 0002 	movw	r0, #8194	; 0x2002
   16eea:	f7fe fc87 	bl	157fc <bt_hci_cmd_send_sync>
	if (err) {
   16eee:	4604      	mov	r4, r0
   16ef0:	2800      	cmp	r0, #0
   16ef2:	d1bc      	bne.n	16e6e <hci_init+0x15a>
	le_read_buffer_size_complete(rsp);
   16ef4:	9b05      	ldr	r3, [sp, #20]
   16ef6:	689b      	ldr	r3, [r3, #8]
	bt_dev.le.mtu = sys_le16_to_cpu(rp->le_max_len);
   16ef8:	f8b3 2001 	ldrh.w	r2, [r3, #1]
   16efc:	f8a5 2088 	strh.w	r2, [r5, #136]	; 0x88
   16f00:	b291      	uxth	r1, r2
	if (!bt_dev.le.mtu) {
   16f02:	b121      	cbz	r1, 16f0e <hci_init+0x1fa>
	k_sem_init(&bt_dev.le.pkts, rp->le_max_num, rp->le_max_num);
   16f04:	78da      	ldrb	r2, [r3, #3]
	z_impl_k_sem_init(sem, initial_count, limit);
   16f06:	4884      	ldr	r0, [pc, #528]	; (17118 <hci_init+0x404>)
   16f08:	4611      	mov	r1, r2
   16f0a:	f016 fa7c 	bl	2d406 <z_impl_k_sem_init>
	net_buf_unref(rsp);
   16f0e:	9805      	ldr	r0, [sp, #20]
   16f10:	f00e f9dc 	bl	252cc <net_buf_unref>
	if (BT_FEAT_BREDR(bt_dev.features)) {
   16f14:	7f2c      	ldrb	r4, [r5, #28]
   16f16:	f014 0420 	ands.w	r4, r4, #32
   16f1a:	f000 80b2 	beq.w	17082 <hci_init+0x36e>
	if (BT_CMD_LE_STATES(bt_dev.supported_commands)) {
   16f1e:	f895 303c 	ldrb.w	r3, [r5, #60]	; 0x3c
   16f22:	071c      	lsls	r4, r3, #28
   16f24:	d511      	bpl.n	16f4a <hci_init+0x236>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_SUPP_STATES, NULL,
   16f26:	aa05      	add	r2, sp, #20
   16f28:	2100      	movs	r1, #0
   16f2a:	f242 001c 	movw	r0, #8220	; 0x201c
   16f2e:	f7fe fc65 	bl	157fc <bt_hci_cmd_send_sync>
		if (err) {
   16f32:	4604      	mov	r4, r0
   16f34:	2800      	cmp	r0, #0
   16f36:	d19a      	bne.n	16e6e <hci_init+0x15a>
		le_read_supp_states_complete(rsp);
   16f38:	9805      	ldr	r0, [sp, #20]
 *
 *  @return 64-bit integer in host endianness.
 */
static inline u64_t sys_get_le64(const u8_t src[8])
{
	return ((u64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
   16f3a:	6883      	ldr	r3, [r0, #8]
   16f3c:	f853 2f01 	ldr.w	r2, [r3, #1]!
   16f40:	685b      	ldr	r3, [r3, #4]
	bt_dev.le.states = sys_get_le64(rp->le_states);
   16f42:	e9c5 2320 	strd	r2, r3, [r5, #128]	; 0x80
		net_buf_unref(rsp);
   16f46:	f00e f9c1 	bl	252cc <net_buf_unref>
	if (IS_ENABLED(CONFIG_BT_CONN) &&
   16f4a:	f895 3078 	ldrb.w	r3, [r5, #120]	; 0x78
   16f4e:	0698      	lsls	r0, r3, #26
   16f50:	f100 80b3 	bmi.w	170ba <hci_init+0x3a6>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_EVENT_MASK, sizeof(*cp_mask));
   16f54:	2108      	movs	r1, #8
   16f56:	f242 0001 	movw	r0, #8193	; 0x2001
   16f5a:	f7fe fc19 	bl	15790 <bt_hci_cmd_create>
	if (!buf) {
   16f5e:	4604      	mov	r4, r0
   16f60:	2800      	cmp	r0, #0
   16f62:	f000 8095 	beq.w	17090 <hci_init+0x37c>
	cp_mask = net_buf_add(buf, sizeof(*cp_mask));
   16f66:	2108      	movs	r1, #8
   16f68:	4408      	add	r0, r1
   16f6a:	f015 fe09 	bl	2cb80 <net_buf_simple_add>
		if (BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features)) {
   16f6e:	f895 2078 	ldrb.w	r2, [r5, #120]	; 0x78
			mask |= BT_EVT_MASK_LE_CONN_PARAM_REQ;
   16f72:	f012 0f02 	tst.w	r2, #2
   16f76:	bf14      	ite	ne
   16f78:	232f      	movne	r3, #47	; 0x2f
   16f7a:	230f      	moveq	r3, #15
		if (IS_ENABLED(CONFIG_BT_DATA_LEN_UPDATE) &&
   16f7c:	0691      	lsls	r1, r2, #26
		if (IS_ENABLED(CONFIG_BT_PHY_UPDATE) &&
   16f7e:	f895 2079 	ldrb.w	r2, [r5, #121]	; 0x79
			mask |= BT_EVT_MASK_LE_DATA_LEN_CHANGE;
   16f82:	bf48      	it	mi
   16f84:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40
		if (IS_ENABLED(CONFIG_BT_PHY_UPDATE) &&
   16f88:	f012 0f09 	tst.w	r2, #9
			mask |= BT_EVT_MASK_LE_PHY_UPDATE_COMPLETE;
   16f8c:	bf18      	it	ne
   16f8e:	f443 6300 	orrne.w	r3, r3, #2048	; 0x800
	dst[0] = val;
   16f92:	2200      	movs	r2, #0
   16f94:	7003      	strb	r3, [r0, #0]
	dst[1] = val >> 8;
   16f96:	f3c3 2307 	ubfx	r3, r3, #8, #8
   16f9a:	7043      	strb	r3, [r0, #1]
	dst[0] = val;
   16f9c:	7082      	strb	r2, [r0, #2]
	dst[1] = val >> 8;
   16f9e:	70c2      	strb	r2, [r0, #3]
	dst[0] = val;
   16fa0:	7102      	strb	r2, [r0, #4]
	dst[1] = val >> 8;
   16fa2:	7142      	strb	r2, [r0, #5]
	dst[0] = val;
   16fa4:	7182      	strb	r2, [r0, #6]
	dst[1] = val >> 8;
   16fa6:	71c2      	strb	r2, [r0, #7]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_EVENT_MASK, buf, NULL);
   16fa8:	4621      	mov	r1, r4
   16faa:	f242 0001 	movw	r0, #8193	; 0x2001
   16fae:	f7fe fc25 	bl	157fc <bt_hci_cmd_send_sync>
	if (err) {
   16fb2:	4604      	mov	r4, r0
   16fb4:	2800      	cmp	r0, #0
   16fb6:	f47f af5a 	bne.w	16e6e <hci_init+0x15a>
	if (BT_FEAT_BREDR(bt_dev.features)) {
   16fba:	7f2b      	ldrb	r3, [r5, #28]
   16fbc:	069a      	lsls	r2, r3, #26
   16fbe:	d41e      	bmi.n	16ffe <hci_init+0x2ea>
	if (bt_dev.le.mtu) {
   16fc0:	f8b5 1088 	ldrh.w	r1, [r5, #136]	; 0x88
   16fc4:	b9d9      	cbnz	r1, 16ffe <hci_init+0x2ea>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_READ_BUFFER_SIZE, NULL, &rsp);
   16fc6:	aa05      	add	r2, sp, #20
   16fc8:	f241 0005 	movw	r0, #4101	; 0x1005
   16fcc:	f7fe fc16 	bl	157fc <bt_hci_cmd_send_sync>
	if (err) {
   16fd0:	4604      	mov	r4, r0
   16fd2:	2800      	cmp	r0, #0
   16fd4:	f47f af4b 	bne.w	16e6e <hci_init+0x15a>
	if (bt_dev.le.mtu) {
   16fd8:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
   16fdc:	b963      	cbnz	r3, 16ff8 <hci_init+0x2e4>
	read_buffer_size_complete(rsp);
   16fde:	9b05      	ldr	r3, [sp, #20]
   16fe0:	689b      	ldr	r3, [r3, #8]
	bt_dev.le.mtu = sys_le16_to_cpu(rp->acl_max_len);
   16fe2:	785a      	ldrb	r2, [r3, #1]
   16fe4:	7899      	ldrb	r1, [r3, #2]
   16fe6:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
   16fea:	f8a5 2088 	strh.w	r2, [r5, #136]	; 0x88
	k_sem_init(&bt_dev.le.pkts, pkts, pkts);
   16fee:	889a      	ldrh	r2, [r3, #4]
   16ff0:	4849      	ldr	r0, [pc, #292]	; (17118 <hci_init+0x404>)
   16ff2:	4611      	mov	r1, r2
   16ff4:	f016 fa07 	bl	2d406 <z_impl_k_sem_init>
	net_buf_unref(rsp);
   16ff8:	9805      	ldr	r0, [sp, #20]
   16ffa:	f00e f967 	bl	252cc <net_buf_unref>
	buf = bt_hci_cmd_create(BT_HCI_OP_SET_EVENT_MASK, sizeof(*ev));
   16ffe:	2108      	movs	r1, #8
   17000:	f640 4001 	movw	r0, #3073	; 0xc01
   17004:	f7fe fbc4 	bl	15790 <bt_hci_cmd_create>
	if (!buf) {
   17008:	4604      	mov	r4, r0
   1700a:	2800      	cmp	r0, #0
   1700c:	d040      	beq.n	17090 <hci_init+0x37c>
	ev = net_buf_add(buf, sizeof(*ev));
   1700e:	2108      	movs	r1, #8
   17010:	4408      	add	r0, r1
   17012:	f015 fdb5 	bl	2cb80 <net_buf_simple_add>
	dst[0] = val;
   17016:	2310      	movs	r3, #16
   17018:	7003      	strb	r3, [r0, #0]
	dst[1] = val >> 8;
   1701a:	2388      	movs	r3, #136	; 0x88
   1701c:	7043      	strb	r3, [r0, #1]
   1701e:	2302      	movs	r3, #2
	dst[0] = val;
   17020:	2200      	movs	r2, #0
	dst[1] = val >> 8;
   17022:	70c3      	strb	r3, [r0, #3]
   17024:	2320      	movs	r3, #32
	dst[0] = val;
   17026:	7082      	strb	r2, [r0, #2]
   17028:	7102      	strb	r2, [r0, #4]
	dst[1] = val >> 8;
   1702a:	7142      	strb	r2, [r0, #5]
	dst[0] = val;
   1702c:	7182      	strb	r2, [r0, #6]
	dst[1] = val >> 8;
   1702e:	71c3      	strb	r3, [r0, #7]
	return bt_hci_cmd_send_sync(BT_HCI_OP_SET_EVENT_MASK, buf, NULL);
   17030:	4621      	mov	r1, r4
   17032:	f640 4001 	movw	r0, #3073	; 0xc01
   17036:	f7fe fbe1 	bl	157fc <bt_hci_cmd_send_sync>
	if (err) {
   1703a:	4601      	mov	r1, r0
   1703c:	2800      	cmp	r0, #0
   1703e:	f040 8134 	bne.w	172aa <hci_init+0x596>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_VERSION_INFO, NULL, &rsp);
   17042:	466a      	mov	r2, sp
   17044:	f64f 4001 	movw	r0, #64513	; 0xfc01
   17048:	f7fe fbd8 	bl	157fc <bt_hci_cmd_send_sync>
	if (err) {
   1704c:	4e33      	ldr	r6, [pc, #204]	; (1711c <hci_init+0x408>)
		BT_WARN("Vendor HCI extensions not available");
   1704e:	6833      	ldr	r3, [r6, #0]
	if (err) {
   17050:	2800      	cmp	r0, #0
   17052:	d06b      	beq.n	1712c <hci_init+0x418>
		BT_WARN("Vendor HCI extensions not available");
   17054:	f013 0f06 	tst.w	r3, #6
   17058:	d00d      	beq.n	17076 <hci_init+0x362>
   1705a:	2302      	movs	r3, #2
   1705c:	f04f 0100 	mov.w	r1, #0
   17060:	f363 0107 	bfi	r1, r3, #0, #8
   17064:	4a2e      	ldr	r2, [pc, #184]	; (17120 <hci_init+0x40c>)
   17066:	4b2f      	ldr	r3, [pc, #188]	; (17124 <hci_init+0x410>)
   17068:	482f      	ldr	r0, [pc, #188]	; (17128 <hci_init+0x414>)
   1706a:	1a9b      	subs	r3, r3, r2
   1706c:	08db      	lsrs	r3, r3, #3
   1706e:	f363 118f 	bfi	r1, r3, #6, #10
		BT_WARN("Failed to read supported vendor commands");
   17072:	f011 fc62 	bl	2893a <log_0>
	if (!IS_ENABLED(CONFIG_BT_SETTINGS) && !bt_dev.id_count) {
   17076:	79eb      	ldrb	r3, [r5, #7]
   17078:	2b00      	cmp	r3, #0
   1707a:	f000 80fd 	beq.w	17278 <hci_init+0x564>
	return 0;
   1707e:	2400      	movs	r4, #0
   17080:	e6f5      	b.n	16e6e <hci_init+0x15a>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP,
   17082:	2102      	movs	r1, #2
   17084:	f640 406d 	movw	r0, #3181	; 0xc6d
   17088:	f7fe fb82 	bl	15790 <bt_hci_cmd_create>
		if (!buf) {
   1708c:	4606      	mov	r6, r0
   1708e:	b910      	cbnz	r0, 17096 <hci_init+0x382>
		return -ENOBUFS;
   17090:	f06f 0436 	mvn.w	r4, #54	; 0x36
   17094:	e6eb      	b.n	16e6e <hci_init+0x15a>
		cp_le = net_buf_add(buf, sizeof(*cp_le));
   17096:	2102      	movs	r1, #2
   17098:	3008      	adds	r0, #8
   1709a:	f015 fd71 	bl	2cb80 <net_buf_simple_add>
		cp_le->le = 0x01;
   1709e:	2301      	movs	r3, #1
		cp_le->simul = 0x00;
   170a0:	7044      	strb	r4, [r0, #1]
		cp_le->le = 0x01;
   170a2:	7003      	strb	r3, [r0, #0]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_LE_HOST_SUPP, buf,
   170a4:	4622      	mov	r2, r4
   170a6:	4631      	mov	r1, r6
   170a8:	f640 406d 	movw	r0, #3181	; 0xc6d
   170ac:	f7fe fba6 	bl	157fc <bt_hci_cmd_send_sync>
		if (err) {
   170b0:	4604      	mov	r4, r0
   170b2:	2800      	cmp	r0, #0
   170b4:	f43f af33 	beq.w	16f1e <hci_init+0x20a>
   170b8:	e6d9      	b.n	16e6e <hci_init+0x15a>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_MAX_DATA_LEN, NULL,
   170ba:	aa05      	add	r2, sp, #20
   170bc:	2100      	movs	r1, #0
   170be:	f242 002f 	movw	r0, #8239	; 0x202f
   170c2:	f7fe fb9b 	bl	157fc <bt_hci_cmd_send_sync>
		if (err) {
   170c6:	4604      	mov	r4, r0
   170c8:	2800      	cmp	r0, #0
   170ca:	f47f aed0 	bne.w	16e6e <hci_init+0x15a>
		rp = (void *)rsp->data;
   170ce:	9805      	ldr	r0, [sp, #20]
   170d0:	6883      	ldr	r3, [r0, #8]
		tx_octets = sys_le16_to_cpu(rp->max_tx_octets);
   170d2:	f8b3 8001 	ldrh.w	r8, [r3, #1]
		tx_time = sys_le16_to_cpu(rp->max_tx_time);
   170d6:	f8b3 7003 	ldrh.w	r7, [r3, #3]
		net_buf_unref(rsp);
   170da:	f00e f8f7 	bl	252cc <net_buf_unref>
		buf = bt_hci_cmd_create(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
   170de:	2104      	movs	r1, #4
   170e0:	f242 0024 	movw	r0, #8228	; 0x2024
   170e4:	f7fe fb54 	bl	15790 <bt_hci_cmd_create>
		if (!buf) {
   170e8:	4606      	mov	r6, r0
   170ea:	2800      	cmp	r0, #0
   170ec:	d0d0      	beq.n	17090 <hci_init+0x37c>
		cp = net_buf_add(buf, sizeof(*cp));
   170ee:	2104      	movs	r1, #4
   170f0:	3008      	adds	r0, #8
   170f2:	f015 fd45 	bl	2cb80 <net_buf_simple_add>
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
   170f6:	4622      	mov	r2, r4
		cp->max_tx_octets = sys_cpu_to_le16(tx_octets);
   170f8:	f8a0 8000 	strh.w	r8, [r0]
		cp->max_tx_time = sys_cpu_to_le16(tx_time);
   170fc:	8047      	strh	r7, [r0, #2]
		err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_WRITE_DEFAULT_DATA_LEN,
   170fe:	4631      	mov	r1, r6
   17100:	f242 0024 	movw	r0, #8228	; 0x2024
   17104:	f7fe fb7a 	bl	157fc <bt_hci_cmd_send_sync>
		if (err) {
   17108:	4604      	mov	r4, r0
   1710a:	2800      	cmp	r0, #0
   1710c:	f43f af22 	beq.w	16f54 <hci_init+0x240>
   17110:	e6ad      	b.n	16e6e <hci_init+0x15a>
   17112:	bf00      	nop
   17114:	2000f798 	.word	0x2000f798
   17118:	2000f7ac 	.word	0x2000f7ac
   1711c:	20010004 	.word	0x20010004
   17120:	0002db28 	.word	0x0002db28
   17124:	0002dc00 	.word	0x0002dc00
   17128:	00030a7b 	.word	0x00030a7b
	BT_INFO("HW Platform: %s (0x%04x)",
   1712c:	f003 0307 	and.w	r3, r3, #7
   17130:	2b02      	cmp	r3, #2
   17132:	d954      	bls.n	171de <hci_init+0x4ca>
	rp.info = (void *)rsp->data;
   17134:	9b00      	ldr	r3, [sp, #0]
   17136:	4f5e      	ldr	r7, [pc, #376]	; (172b0 <hci_init+0x59c>)
   17138:	689c      	ldr	r4, [r3, #8]
	BT_INFO("HW Platform: %s (0x%04x)",
   1713a:	485e      	ldr	r0, [pc, #376]	; (172b4 <hci_init+0x5a0>)
   1713c:	2203      	movs	r2, #3
   1713e:	f04f 0300 	mov.w	r3, #0
   17142:	f362 0307 	bfi	r3, r2, #0, #8
   17146:	4a5c      	ldr	r2, [pc, #368]	; (172b8 <hci_init+0x5a4>)
   17148:	1abf      	subs	r7, r7, r2
   1714a:	f8b4 2001 	ldrh.w	r2, [r4, #1]
	if (platform < ARRAY_SIZE(plat_str)) {
   1714e:	2a03      	cmp	r2, #3
		return plat_str[platform];
   17150:	bf96      	itet	ls
   17152:	495a      	ldrls	r1, [pc, #360]	; (172bc <hci_init+0x5a8>)
	return "unknown";
   17154:	495a      	ldrhi	r1, [pc, #360]	; (172c0 <hci_init+0x5ac>)
		return plat_str[platform];
   17156:	f851 1022 	ldrls.w	r1, [r1, r2, lsl #2]
	BT_INFO("HW Platform: %s (0x%04x)",
   1715a:	f3c7 07c9 	ubfx	r7, r7, #3, #10
   1715e:	f367 138f 	bfi	r3, r7, #6, #10
   17162:	f011 fc0b 	bl	2897c <log_2>
	BT_INFO("HW Variant: %s (0x%04x)",
   17166:	6833      	ldr	r3, [r6, #0]
   17168:	f003 0307 	and.w	r3, r3, #7
   1716c:	2b02      	cmp	r3, #2
   1716e:	d936      	bls.n	171de <hci_init+0x4ca>
	if (platform != BT_HCI_VS_HW_PLAT_NORDIC) {
   17170:	f8b4 1001 	ldrh.w	r1, [r4, #1]
	BT_INFO("HW Variant: %s (0x%04x)",
   17174:	2203      	movs	r2, #3
   17176:	f04f 0300 	mov.w	r3, #0
   1717a:	f362 0307 	bfi	r3, r2, #0, #8
	if (platform != BT_HCI_VS_HW_PLAT_NORDIC) {
   1717e:	2902      	cmp	r1, #2
	BT_INFO("HW Variant: %s (0x%04x)",
   17180:	f367 138f 	bfi	r3, r7, #6, #10
   17184:	f8b4 2003 	ldrh.w	r2, [r4, #3]
	if (platform != BT_HCI_VS_HW_PLAT_NORDIC) {
   17188:	d146      	bne.n	17218 <hci_init+0x504>
	if (variant < ARRAY_SIZE(nordic_str)) {
   1718a:	2a03      	cmp	r2, #3
   1718c:	d844      	bhi.n	17218 <hci_init+0x504>
		return nordic_str[variant];
   1718e:	494d      	ldr	r1, [pc, #308]	; (172c4 <hci_init+0x5b0>)
   17190:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
	BT_INFO("HW Variant: %s (0x%04x)",
   17194:	484c      	ldr	r0, [pc, #304]	; (172c8 <hci_init+0x5b4>)
   17196:	f011 fbf1 	bl	2897c <log_2>
	BT_INFO("Firmware: %s (0x%02x) Version %u.%u Build %u",
   1719a:	6833      	ldr	r3, [r6, #0]
   1719c:	f003 0307 	and.w	r3, r3, #7
   171a0:	2b02      	cmp	r3, #2
   171a2:	d91c      	bls.n	171de <hci_init+0x4ca>
   171a4:	2203      	movs	r2, #3
   171a6:	f04f 0300 	mov.w	r3, #0
   171aa:	f362 0307 	bfi	r3, r2, #0, #8
   171ae:	7962      	ldrb	r2, [r4, #5]
   171b0:	4846      	ldr	r0, [pc, #280]	; (172cc <hci_init+0x5b8>)
	if (variant < ARRAY_SIZE(var_str)) {
   171b2:	2a03      	cmp	r2, #3
		return var_str[variant];
   171b4:	bf96      	itet	ls
   171b6:	4946      	ldrls	r1, [pc, #280]	; (172d0 <hci_init+0x5bc>)
	return "unknown";
   171b8:	4941      	ldrhi	r1, [pc, #260]	; (172c0 <hci_init+0x5ac>)
		return var_str[variant];
   171ba:	f851 1022 	ldrls.w	r1, [r1, r2, lsl #2]
	BT_INFO("Firmware: %s (0x%02x) Version %u.%u Build %u",
   171be:	e9cd 1205 	strd	r1, r2, [sp, #20]
   171c2:	79a2      	ldrb	r2, [r4, #6]
   171c4:	9207      	str	r2, [sp, #28]
   171c6:	f8b4 2007 	ldrh.w	r2, [r4, #7]
   171ca:	9208      	str	r2, [sp, #32]
   171cc:	f8d4 2009 	ldr.w	r2, [r4, #9]
   171d0:	9209      	str	r2, [sp, #36]	; 0x24
   171d2:	f367 138f 	bfi	r3, r7, #6, #10
   171d6:	2205      	movs	r2, #5
   171d8:	a905      	add	r1, sp, #20
   171da:	f011 fc02 	bl	289e2 <log_n>
	net_buf_unref(rsp);
   171de:	9800      	ldr	r0, [sp, #0]
   171e0:	f00e f874 	bl	252cc <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_COMMANDS,
   171e4:	466a      	mov	r2, sp
   171e6:	2100      	movs	r1, #0
   171e8:	f64f 4002 	movw	r0, #64514	; 0xfc02
   171ec:	f7fe fb06 	bl	157fc <bt_hci_cmd_send_sync>
	if (err) {
   171f0:	4604      	mov	r4, r0
   171f2:	b198      	cbz	r0, 1721c <hci_init+0x508>
		BT_WARN("Failed to read supported vendor features");
   171f4:	6833      	ldr	r3, [r6, #0]
   171f6:	f013 0f06 	tst.w	r3, #6
   171fa:	f43f af3c 	beq.w	17076 <hci_init+0x362>
   171fe:	2302      	movs	r3, #2
   17200:	f04f 0100 	mov.w	r1, #0
   17204:	f363 0107 	bfi	r1, r3, #0, #8
   17208:	4a2b      	ldr	r2, [pc, #172]	; (172b8 <hci_init+0x5a4>)
   1720a:	4b29      	ldr	r3, [pc, #164]	; (172b0 <hci_init+0x59c>)
   1720c:	4831      	ldr	r0, [pc, #196]	; (172d4 <hci_init+0x5c0>)
   1720e:	1a9b      	subs	r3, r3, r2
   17210:	08db      	lsrs	r3, r3, #3
   17212:	f363 118f 	bfi	r1, r3, #6, #10
   17216:	e72c      	b.n	17072 <hci_init+0x35e>
		return "unknown";
   17218:	4929      	ldr	r1, [pc, #164]	; (172c0 <hci_init+0x5ac>)
   1721a:	e7bb      	b.n	17194 <hci_init+0x480>
	rp.cmds = (void *)rsp->data;
   1721c:	9b00      	ldr	r3, [sp, #0]
	memcpy(bt_dev.vs_commands, rp.cmds->commands, BT_DEV_VS_CMDS_MAX);
   1721e:	482e      	ldr	r0, [pc, #184]	; (172d8 <hci_init+0x5c4>)
   17220:	6899      	ldr	r1, [r3, #8]
   17222:	2202      	movs	r2, #2
   17224:	3101      	adds	r1, #1
   17226:	f013 f912 	bl	2a44e <memcpy>
	net_buf_unref(rsp);
   1722a:	9800      	ldr	r0, [sp, #0]
   1722c:	f00e f84e 	bl	252cc <net_buf_unref>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_VS_READ_SUPPORTED_FEATURES,
   17230:	466a      	mov	r2, sp
   17232:	4621      	mov	r1, r4
   17234:	f64f 4003 	movw	r0, #64515	; 0xfc03
   17238:	f7fe fae0 	bl	157fc <bt_hci_cmd_send_sync>
	if (err) {
   1723c:	b188      	cbz	r0, 17262 <hci_init+0x54e>
		BT_WARN("Failed to read supported vendor commands");
   1723e:	6833      	ldr	r3, [r6, #0]
   17240:	f013 0f06 	tst.w	r3, #6
   17244:	f43f af17 	beq.w	17076 <hci_init+0x362>
   17248:	2302      	movs	r3, #2
   1724a:	f04f 0100 	mov.w	r1, #0
   1724e:	f363 0107 	bfi	r1, r3, #0, #8
   17252:	4a19      	ldr	r2, [pc, #100]	; (172b8 <hci_init+0x5a4>)
   17254:	4b16      	ldr	r3, [pc, #88]	; (172b0 <hci_init+0x59c>)
   17256:	4821      	ldr	r0, [pc, #132]	; (172dc <hci_init+0x5c8>)
   17258:	1a9b      	subs	r3, r3, r2
   1725a:	08db      	lsrs	r3, r3, #3
   1725c:	f363 118f 	bfi	r1, r3, #6, #10
   17260:	e707      	b.n	17072 <hci_init+0x35e>
	rp.feat = (void *)rsp->data;
   17262:	9b00      	ldr	r3, [sp, #0]
	memcpy(bt_dev.vs_features, rp.feat->features, BT_DEV_VS_FEAT_MAX);
   17264:	481e      	ldr	r0, [pc, #120]	; (172e0 <hci_init+0x5cc>)
   17266:	6899      	ldr	r1, [r3, #8]
   17268:	2201      	movs	r2, #1
   1726a:	4411      	add	r1, r2
   1726c:	f013 f8ef 	bl	2a44e <memcpy>
	net_buf_unref(rsp);
   17270:	9800      	ldr	r0, [sp, #0]
   17272:	f00e f82b 	bl	252cc <net_buf_unref>
   17276:	e6fe      	b.n	17076 <hci_init+0x362>
		err = bt_setup_id_addr();
   17278:	f7ff fcb4 	bl	16be4 <bt_setup_id_addr>
		if (err) {
   1727c:	4604      	mov	r4, r0
   1727e:	2800      	cmp	r0, #0
   17280:	f43f aefd 	beq.w	1707e <hci_init+0x36a>
			BT_ERR("Unable to set identity address");
   17284:	6833      	ldr	r3, [r6, #0]
   17286:	075b      	lsls	r3, r3, #29
   17288:	f43f adf1 	beq.w	16e6e <hci_init+0x15a>
   1728c:	2301      	movs	r3, #1
   1728e:	f04f 0100 	mov.w	r1, #0
   17292:	f363 0107 	bfi	r1, r3, #0, #8
   17296:	4a08      	ldr	r2, [pc, #32]	; (172b8 <hci_init+0x5a4>)
   17298:	4b05      	ldr	r3, [pc, #20]	; (172b0 <hci_init+0x59c>)
   1729a:	4812      	ldr	r0, [pc, #72]	; (172e4 <hci_init+0x5d0>)
   1729c:	1a9b      	subs	r3, r3, r2
   1729e:	08db      	lsrs	r3, r3, #3
   172a0:	f363 118f 	bfi	r1, r3, #6, #10
   172a4:	f011 fb49 	bl	2893a <log_0>
   172a8:	e5e1      	b.n	16e6e <hci_init+0x15a>
   172aa:	4604      	mov	r4, r0
   172ac:	e5df      	b.n	16e6e <hci_init+0x15a>
   172ae:	bf00      	nop
   172b0:	0002dc00 	.word	0x0002dc00
   172b4:	00030a9f 	.word	0x00030a9f
   172b8:	0002db28 	.word	0x0002db28
   172bc:	0002e4ec 	.word	0x0002e4ec
   172c0:	0002f1cd 	.word	0x0002f1cd
   172c4:	0002e4c4 	.word	0x0002e4c4
   172c8:	00030ab8 	.word	0x00030ab8
   172cc:	00030ad0 	.word	0x00030ad0
   172d0:	0002e51c 	.word	0x0002e51c
   172d4:	00030afd 	.word	0x00030afd
   172d8:	2000f781 	.word	0x2000f781
   172dc:	00030b26 	.word	0x00030b26
   172e0:	2000f780 	.word	0x2000f780
   172e4:	00030b4f 	.word	0x00030b4f

000172e8 <bt_enable>:
{
   172e8:	b570      	push	{r4, r5, r6, lr}
	if (!bt_dev.drv) {
   172ea:	4d39      	ldr	r5, [pc, #228]	; (173d0 <bt_enable+0xe8>)
   172ec:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
{
   172f0:	b086      	sub	sp, #24
   172f2:	4606      	mov	r6, r0
	if (!bt_dev.drv) {
   172f4:	b9a3      	cbnz	r3, 17320 <bt_enable+0x38>
		BT_ERR("No HCI driver registered");
   172f6:	4b37      	ldr	r3, [pc, #220]	; (173d4 <bt_enable+0xec>)
   172f8:	681b      	ldr	r3, [r3, #0]
   172fa:	0759      	lsls	r1, r3, #29
   172fc:	d00d      	beq.n	1731a <bt_enable+0x32>
   172fe:	2301      	movs	r3, #1
   17300:	f04f 0100 	mov.w	r1, #0
   17304:	f363 0107 	bfi	r1, r3, #0, #8
   17308:	4a33      	ldr	r2, [pc, #204]	; (173d8 <bt_enable+0xf0>)
   1730a:	4b34      	ldr	r3, [pc, #208]	; (173dc <bt_enable+0xf4>)
   1730c:	4834      	ldr	r0, [pc, #208]	; (173e0 <bt_enable+0xf8>)
   1730e:	1a9b      	subs	r3, r3, r2
   17310:	08db      	lsrs	r3, r3, #3
   17312:	f363 118f 	bfi	r1, r3, #6, #10
   17316:	f011 fb10 	bl	2893a <log_0>
		return -ENODEV;
   1731a:	f06f 0412 	mvn.w	r4, #18
   1731e:	e035      	b.n	1738c <bt_enable+0xa4>
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   17320:	2101      	movs	r1, #1
   17322:	f105 0070 	add.w	r0, r5, #112	; 0x70
   17326:	f013 fa03 	bl	2a730 <atomic_or>
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_ENABLE)) {
   1732a:	f010 0001 	ands.w	r0, r0, #1
   1732e:	d14b      	bne.n	173c8 <bt_enable+0xe0>
	ready_cb = cb;
   17330:	4b2c      	ldr	r3, [pc, #176]	; (173e4 <bt_enable+0xfc>)
   17332:	601e      	str	r6, [r3, #0]
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   17334:	f06f 0308 	mvn.w	r3, #8
   17338:	e9cd 0302 	strd	r0, r3, [sp, #8]
   1733c:	e9cd 0004 	strd	r0, r0, [sp, #16]
   17340:	e9cd 0000 	strd	r0, r0, [sp]
   17344:	4b28      	ldr	r3, [pc, #160]	; (173e8 <bt_enable+0x100>)
   17346:	4929      	ldr	r1, [pc, #164]	; (173ec <bt_enable+0x104>)
   17348:	4829      	ldr	r0, [pc, #164]	; (173f0 <bt_enable+0x108>)
   1734a:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1734e:	f00f ff7f 	bl	27250 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
   17352:	4928      	ldr	r1, [pc, #160]	; (173f4 <bt_enable+0x10c>)
   17354:	4826      	ldr	r0, [pc, #152]	; (173f0 <bt_enable+0x108>)
   17356:	f016 f86a 	bl	2d42e <z_impl_k_thread_name_set>
	err = bt_dev.drv->open();
   1735a:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
   1735e:	68db      	ldr	r3, [r3, #12]
   17360:	4798      	blx	r3
	if (err) {
   17362:	4604      	mov	r4, r0
   17364:	b1a8      	cbz	r0, 17392 <bt_enable+0xaa>
		BT_ERR("HCI driver open failed (%d)", err);
   17366:	4b1b      	ldr	r3, [pc, #108]	; (173d4 <bt_enable+0xec>)
   17368:	681b      	ldr	r3, [r3, #0]
   1736a:	075a      	lsls	r2, r3, #29
   1736c:	d00e      	beq.n	1738c <bt_enable+0xa4>
   1736e:	2301      	movs	r3, #1
   17370:	f04f 0200 	mov.w	r2, #0
   17374:	f363 0207 	bfi	r2, r3, #0, #8
   17378:	4917      	ldr	r1, [pc, #92]	; (173d8 <bt_enable+0xf0>)
   1737a:	4b18      	ldr	r3, [pc, #96]	; (173dc <bt_enable+0xf4>)
   1737c:	1a5b      	subs	r3, r3, r1
   1737e:	08db      	lsrs	r3, r3, #3
   17380:	4601      	mov	r1, r0
   17382:	f363 128f 	bfi	r2, r3, #6, #10
   17386:	481c      	ldr	r0, [pc, #112]	; (173f8 <bt_enable+0x110>)
   17388:	f011 fae4 	bl	28954 <log_1>
}
   1738c:	4620      	mov	r0, r4
   1738e:	b006      	add	sp, #24
   17390:	bd70      	pop	{r4, r5, r6, pc}
	if (!cb) {
   17392:	b966      	cbnz	r6, 173ae <bt_enable+0xc6>
	err = hci_init();
   17394:	f7ff fcbe 	bl	16d14 <hci_init>
	if (err) {
   17398:	4604      	mov	r4, r0
   1739a:	2800      	cmp	r0, #0
   1739c:	d1f6      	bne.n	1738c <bt_enable+0xa4>
		err = bt_conn_init();
   1739e:	f001 f945 	bl	1862c <bt_conn_init>
		if (err) {
   173a2:	4604      	mov	r4, r0
   173a4:	2800      	cmp	r0, #0
   173a6:	d1f1      	bne.n	1738c <bt_enable+0xa4>
	bt_finalize_init();
   173a8:	f7ff fb12 	bl	169d0 <bt_finalize_init>
	return 0;
   173ac:	e7ee      	b.n	1738c <bt_enable+0xa4>
   173ae:	2101      	movs	r1, #1
   173b0:	f105 006c 	add.w	r0, r5, #108	; 0x6c
   173b4:	f013 f9bc 	bl	2a730 <atomic_or>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   173b8:	07c3      	lsls	r3, r0, #31
   173ba:	d4e7      	bmi.n	1738c <bt_enable+0xa4>
		k_queue_append(&work_q->queue, work);
   173bc:	f105 0164 	add.w	r1, r5, #100	; 0x64
   173c0:	480e      	ldr	r0, [pc, #56]	; (173fc <bt_enable+0x114>)
   173c2:	f015 fe9e 	bl	2d102 <k_queue_append>
   173c6:	e7e1      	b.n	1738c <bt_enable+0xa4>
		return -EALREADY;
   173c8:	f06f 0444 	mvn.w	r4, #68	; 0x44
   173cc:	e7de      	b.n	1738c <bt_enable+0xa4>
   173ce:	bf00      	nop
   173d0:	2000f720 	.word	0x2000f720
   173d4:	20010004 	.word	0x20010004
   173d8:	0002db28 	.word	0x0002db28
   173dc:	0002dc00 	.word	0x0002dc00
   173e0:	0003067d 	.word	0x0003067d
   173e4:	20000a14 	.word	0x20000a14
   173e8:	00016619 	.word	0x00016619
   173ec:	20006b10 	.word	0x20006b10
   173f0:	20000a1c 	.word	0x20000a1c
   173f4:	00030696 	.word	0x00030696
   173f8:	0003069c 	.word	0x0003069c
   173fc:	20003b5c 	.word	0x20003b5c

00017400 <init_work>:
{
   17400:	b510      	push	{r4, lr}
	err = hci_init();
   17402:	f7ff fc87 	bl	16d14 <hci_init>
	if (err) {
   17406:	4604      	mov	r4, r0
   17408:	b928      	cbnz	r0, 17416 <init_work+0x16>
		err = bt_conn_init();
   1740a:	f001 f90f 	bl	1862c <bt_conn_init>
		if (err) {
   1740e:	4604      	mov	r4, r0
   17410:	b908      	cbnz	r0, 17416 <init_work+0x16>
	bt_finalize_init();
   17412:	f7ff fadd 	bl	169d0 <bt_finalize_init>
	if (ready_cb) {
   17416:	4b04      	ldr	r3, [pc, #16]	; (17428 <init_work+0x28>)
   17418:	681b      	ldr	r3, [r3, #0]
   1741a:	b11b      	cbz	r3, 17424 <init_work+0x24>
		ready_cb(err);
   1741c:	4620      	mov	r0, r4
}
   1741e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ready_cb(err);
   17422:	4718      	bx	r3
}
   17424:	bd10      	pop	{r4, pc}
   17426:	bf00      	nop
   17428:	20000a14 	.word	0x20000a14

0001742c <bt_le_adv_start_internal>:

int bt_le_adv_start_internal(const struct bt_le_adv_param *param,
			     const struct bt_data *ad, size_t ad_len,
			     const struct bt_data *sd, size_t sd_len,
			     const bt_addr_le_t *peer)
{
   1742c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	const bt_addr_le_t *id_addr;
	struct net_buf *buf;
	bool dir_adv = (peer != NULL);
	int err = 0;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   17430:	4e85      	ldr	r6, [pc, #532]	; (17648 <bt_le_adv_start_internal+0x21c>)
{
   17432:	b08b      	sub	sp, #44	; 0x2c
   17434:	4605      	mov	r5, r0
   17436:	468a      	mov	sl, r1
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   17438:	f106 0070 	add.w	r0, r6, #112	; 0x70
   1743c:	2101      	movs	r1, #1
{
   1743e:	4693      	mov	fp, r2
   17440:	4699      	mov	r9, r3
   17442:	f8dd 8054 	ldr.w	r8, [sp, #84]	; 0x54
	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   17446:	f013 f9af 	bl	2a7a8 <atomic_test_bit>
   1744a:	2800      	cmp	r0, #0
   1744c:	f000 80f3 	beq.w	17636 <bt_le_adv_start_internal+0x20a>
	if (param->id >= bt_dev.id_count ||
   17450:	7828      	ldrb	r0, [r5, #0]
   17452:	79f3      	ldrb	r3, [r6, #7]
   17454:	4283      	cmp	r3, r0
   17456:	d805      	bhi.n	17464 <bt_le_adv_start_internal+0x38>
		return -EAGAIN;
	}

	if (!valid_adv_param(param, dir_adv)) {
		return -EINVAL;
   17458:	f06f 0415 	mvn.w	r4, #21

	atomic_set_bit_to(bt_dev.flags, BT_DEV_ADVERTISING_CONNECTABLE,
			  param->options & BT_LE_ADV_OPT_CONNECTABLE);

	return 0;
}
   1745c:	4620      	mov	r0, r4
   1745e:	b00b      	add	sp, #44	; 0x2c
   17460:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	    !bt_addr_le_cmp(&bt_dev.id_addr[param->id], BT_ADDR_LE_ANY)) {
   17464:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
   17468:	2300      	movs	r3, #0
	return memcmp(a, b, sizeof(*a));
   1746a:	2207      	movs	r2, #7
   1746c:	a904      	add	r1, sp, #16
   1746e:	4430      	add	r0, r6
   17470:	9304      	str	r3, [sp, #16]
   17472:	f8cd 3013 	str.w	r3, [sp, #19]
   17476:	f012 ffc3 	bl	2a400 <memcmp>
	if (param->id >= bt_dev.id_count ||
   1747a:	2800      	cmp	r0, #0
   1747c:	d0ec      	beq.n	17458 <bt_le_adv_start_internal+0x2c>
	if (!(param->options & BT_LE_ADV_OPT_CONNECTABLE)) {
   1747e:	786b      	ldrb	r3, [r5, #1]
   17480:	07dc      	lsls	r4, r3, #31
   17482:	d405      	bmi.n	17490 <bt_le_adv_start_internal+0x64>
		if (bt_dev.hci_version < BT_HCI_VERSION_5_0 &&
   17484:	7c32      	ldrb	r2, [r6, #16]
   17486:	2a08      	cmp	r2, #8
   17488:	d802      	bhi.n	17490 <bt_le_adv_start_internal+0x64>
   1748a:	886a      	ldrh	r2, [r5, #2]
   1748c:	2a9f      	cmp	r2, #159	; 0x9f
   1748e:	d9e3      	bls.n	17458 <bt_le_adv_start_internal+0x2c>
	if (is_wl_empty() &&
   17490:	0658      	lsls	r0, r3, #25
   17492:	d4e1      	bmi.n	17458 <bt_le_adv_start_internal+0x2c>
	    ((param->options & BT_LE_ADV_OPT_FILTER_SCAN_REQ) ||
   17494:	0619      	lsls	r1, r3, #24
   17496:	d4df      	bmi.n	17458 <bt_le_adv_start_internal+0x2c>
	if ((param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) || !dir_adv) {
   17498:	06da      	lsls	r2, r3, #27
   1749a:	d402      	bmi.n	174a2 <bt_le_adv_start_internal+0x76>
   1749c:	f1b8 0f00 	cmp.w	r8, #0
   174a0:	d108      	bne.n	174b4 <bt_le_adv_start_internal+0x88>
		if (param->interval_min > param->interval_max ||
   174a2:	886a      	ldrh	r2, [r5, #2]
   174a4:	88ab      	ldrh	r3, [r5, #4]
   174a6:	429a      	cmp	r2, r3
   174a8:	d8d6      	bhi.n	17458 <bt_le_adv_start_internal+0x2c>
   174aa:	2a1f      	cmp	r2, #31
   174ac:	d9d4      	bls.n	17458 <bt_le_adv_start_internal+0x2c>
		    param->interval_min < 0x0020 ||
   174ae:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
   174b2:	d8d1      	bhi.n	17458 <bt_le_adv_start_internal+0x2c>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING)) {
   174b4:	2106      	movs	r1, #6
   174b6:	4865      	ldr	r0, [pc, #404]	; (1764c <bt_le_adv_start_internal+0x220>)
   174b8:	f013 f976 	bl	2a7a8 <atomic_test_bit>
   174bc:	4601      	mov	r1, r0
   174be:	2800      	cmp	r0, #0
   174c0:	f040 80bc 	bne.w	1763c <bt_le_adv_start_internal+0x210>
	(void)memset(&set_param, 0, sizeof(set_param));
   174c4:	220f      	movs	r2, #15
   174c6:	a806      	add	r0, sp, #24
   174c8:	f012 ffeb 	bl	2a4a2 <memset>
	set_param.min_interval = sys_cpu_to_le16(param->interval_min);
   174cc:	886b      	ldrh	r3, [r5, #2]
   174ce:	f8ad 3018 	strh.w	r3, [sp, #24]
	set_param.max_interval = sys_cpu_to_le16(param->interval_max);
   174d2:	88ab      	ldrh	r3, [r5, #4]
   174d4:	f8ad 301a 	strh.w	r3, [sp, #26]
	set_param.channel_map  = 0x07;
   174d8:	2307      	movs	r3, #7
   174da:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
	if (bt_dev.adv_id != param->id) {
   174de:	7a32      	ldrb	r2, [r6, #8]
   174e0:	782b      	ldrb	r3, [r5, #0]
   174e2:	429a      	cmp	r2, r3
   174e4:	d004      	beq.n	174f0 <bt_le_adv_start_internal+0xc4>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   174e6:	f46f 3180 	mvn.w	r1, #65536	; 0x10000
   174ea:	4858      	ldr	r0, [pc, #352]	; (1764c <bt_le_adv_start_internal+0x220>)
   174ec:	f013 f92f 	bl	2a74e <atomic_and>
	bt_dev.adv_id = param->id;
   174f0:	782f      	ldrb	r7, [r5, #0]
   174f2:	7237      	strb	r7, [r6, #8]
		set_param.filter_policy = BT_LE_ADV_FP_NO_WHITELIST;
   174f4:	2300      	movs	r3, #0
   174f6:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
	if (param->options & BT_LE_ADV_OPT_CONNECTABLE) {
   174fa:	786b      	ldrb	r3, [r5, #1]
   174fc:	f013 0201 	ands.w	r2, r3, #1
   17500:	d061      	beq.n	175c6 <bt_le_adv_start_internal+0x19a>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
   17502:	00fb      	lsls	r3, r7, #3
   17504:	1bd9      	subs	r1, r3, r7
   17506:	5c71      	ldrb	r1, [r6, r1]
   17508:	2901      	cmp	r1, #1
   1750a:	d009      	beq.n	17520 <bt_le_adv_start_internal+0xf4>
			set_param.own_addr_type = id_addr->type;
   1750c:	1bdf      	subs	r7, r3, r7
   1750e:	5df3      	ldrb	r3, [r6, r7]
   17510:	f88d 301d 	strb.w	r3, [sp, #29]
		if (dir_adv) {
   17514:	f1b8 0f00 	cmp.w	r8, #0
   17518:	d110      	bne.n	1753c <bt_le_adv_start_internal+0x110>
			set_param.type = BT_LE_ADV_IND;
   1751a:	f88d 801c 	strb.w	r8, [sp, #28]
   1751e:	e019      	b.n	17554 <bt_le_adv_start_internal+0x128>
				err = set_random_address(&id_addr->a);
   17520:	2007      	movs	r0, #7
   17522:	fb10 1007 	smlabb	r0, r0, r7, r1
   17526:	4430      	add	r0, r6
   17528:	e9cd 2302 	strd	r2, r3, [sp, #8]
   1752c:	f7fe f9e6 	bl	158fc <set_random_address>
				if (err) {
   17530:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   17534:	4604      	mov	r4, r0
   17536:	2800      	cmp	r0, #0
   17538:	d0e8      	beq.n	1750c <bt_le_adv_start_internal+0xe0>
   1753a:	e78f      	b.n	1745c <bt_le_adv_start_internal+0x30>
			if (param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) {
   1753c:	786b      	ldrb	r3, [r5, #1]
				set_param.type = BT_LE_ADV_DIRECT_IND_LOW_DUTY;
   1753e:	f013 0f10 	tst.w	r3, #16
   17542:	bf18      	it	ne
   17544:	2204      	movne	r2, #4
			bt_addr_le_copy(&set_param.direct_addr, peer);
   17546:	4641      	mov	r1, r8
   17548:	f10d 001e 	add.w	r0, sp, #30
   1754c:	f88d 201c 	strb.w	r2, [sp, #28]
   17550:	f013 f8eb 	bl	2a72a <bt_addr_le_copy>
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_ADV_PARAM, sizeof(set_param));
   17554:	210f      	movs	r1, #15
   17556:	f242 0006 	movw	r0, #8198	; 0x2006
   1755a:	f7fe f919 	bl	15790 <bt_hci_cmd_create>
	if (!buf) {
   1755e:	4604      	mov	r4, r0
   17560:	2800      	cmp	r0, #0
   17562:	d06e      	beq.n	17642 <bt_le_adv_start_internal+0x216>
	net_buf_add_mem(buf, &set_param, sizeof(set_param));
   17564:	220f      	movs	r2, #15
   17566:	a906      	add	r1, sp, #24
   17568:	3008      	adds	r0, #8
   1756a:	f015 fb0f 	bl	2cb8c <net_buf_simple_add_mem>
	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_ADV_PARAM, buf, NULL);
   1756e:	4621      	mov	r1, r4
   17570:	2200      	movs	r2, #0
   17572:	f242 0006 	movw	r0, #8198	; 0x2006
   17576:	f7fe f941 	bl	157fc <bt_hci_cmd_send_sync>
	if (err) {
   1757a:	4604      	mov	r4, r0
   1757c:	2800      	cmp	r0, #0
   1757e:	f47f af6d 	bne.w	1745c <bt_le_adv_start_internal+0x30>
	if (!dir_adv) {
   17582:	f1b8 0f00 	cmp.w	r8, #0
   17586:	d045      	beq.n	17614 <bt_le_adv_start_internal+0x1e8>
	err = set_advertise_enable(true);
   17588:	2001      	movs	r0, #1
   1758a:	f7fe f9e5 	bl	15958 <set_advertise_enable>
	if (err) {
   1758e:	4604      	mov	r4, r0
   17590:	2800      	cmp	r0, #0
   17592:	f47f af63 	bne.w	1745c <bt_le_adv_start_internal+0x30>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_KEEP_ADVERTISING,
   17596:	786a      	ldrb	r2, [r5, #1]
   17598:	482c      	ldr	r0, [pc, #176]	; (1764c <bt_le_adv_start_internal+0x220>)
   1759a:	f082 0202 	eor.w	r2, r2, #2
   1759e:	f3c2 0240 	ubfx	r2, r2, #1, #1
   175a2:	2109      	movs	r1, #9
   175a4:	f013 f8e2 	bl	2a76c <atomic_set_bit_to>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_ADVERTISING_NAME,
   175a8:	786a      	ldrb	r2, [r5, #1]
   175aa:	4828      	ldr	r0, [pc, #160]	; (1764c <bt_le_adv_start_internal+0x220>)
   175ac:	f3c2 02c0 	ubfx	r2, r2, #3, #1
   175b0:	2107      	movs	r1, #7
   175b2:	f013 f8db 	bl	2a76c <atomic_set_bit_to>
	atomic_set_bit_to(bt_dev.flags, BT_DEV_ADVERTISING_CONNECTABLE,
   175b6:	786a      	ldrb	r2, [r5, #1]
   175b8:	4824      	ldr	r0, [pc, #144]	; (1764c <bt_le_adv_start_internal+0x220>)
   175ba:	f002 0201 	and.w	r2, r2, #1
   175be:	2108      	movs	r1, #8
   175c0:	f013 f8d4 	bl	2a76c <atomic_set_bit_to>
	return 0;
   175c4:	e74a      	b.n	1745c <bt_le_adv_start_internal+0x30>
		if (param->options & BT_LE_ADV_OPT_USE_IDENTITY) {
   175c6:	075b      	lsls	r3, r3, #29
   175c8:	d51d      	bpl.n	17606 <bt_le_adv_start_internal+0x1da>
			if (id_addr->type == BT_ADDR_LE_RANDOM) {
   175ca:	00fb      	lsls	r3, r7, #3
   175cc:	1bd9      	subs	r1, r3, r7
   175ce:	5c71      	ldrb	r1, [r6, r1]
   175d0:	2901      	cmp	r1, #1
   175d2:	d116      	bne.n	17602 <bt_le_adv_start_internal+0x1d6>
				err = set_random_address(&id_addr->a);
   175d4:	2007      	movs	r0, #7
   175d6:	fb10 1007 	smlabb	r0, r0, r7, r1
   175da:	4430      	add	r0, r6
   175dc:	9302      	str	r3, [sp, #8]
   175de:	f7fe f98d 	bl	158fc <set_random_address>
   175e2:	9b02      	ldr	r3, [sp, #8]
   175e4:	4604      	mov	r4, r0
			set_param.own_addr_type = id_addr->type;
   175e6:	1bdf      	subs	r7, r3, r7
   175e8:	5df3      	ldrb	r3, [r6, r7]
			set_param.own_addr_type = BT_ADDR_LE_RANDOM;
   175ea:	f88d 301d 	strb.w	r3, [sp, #29]
		if (err) {
   175ee:	2c00      	cmp	r4, #0
   175f0:	f47f af34 	bne.w	1745c <bt_le_adv_start_internal+0x30>
		if (sd) {
   175f4:	f1b9 0f00 	cmp.w	r9, #0
   175f8:	d00a      	beq.n	17610 <bt_le_adv_start_internal+0x1e4>
			set_param.type = BT_LE_ADV_SCAN_IND;
   175fa:	2302      	movs	r3, #2
			set_param.type = BT_LE_ADV_NONCONN_IND;
   175fc:	f88d 301c 	strb.w	r3, [sp, #28]
   17600:	e7a8      	b.n	17554 <bt_le_adv_start_internal+0x128>
	int err = 0;
   17602:	4614      	mov	r4, r2
   17604:	e7ef      	b.n	175e6 <bt_le_adv_start_internal+0x1ba>
			err = le_set_private_addr(param->id);
   17606:	f013 f8d8 	bl	2a7ba <le_set_private_addr.isra.22>
			set_param.own_addr_type = BT_ADDR_LE_RANDOM;
   1760a:	2301      	movs	r3, #1
			err = le_set_private_addr(param->id);
   1760c:	4604      	mov	r4, r0
			set_param.own_addr_type = BT_ADDR_LE_RANDOM;
   1760e:	e7ec      	b.n	175ea <bt_le_adv_start_internal+0x1be>
			set_param.type = BT_LE_ADV_NONCONN_IND;
   17610:	2303      	movs	r3, #3
   17612:	e7f3      	b.n	175fc <bt_le_adv_start_internal+0x1d0>
				    param->options & BT_LE_ADV_OPT_CONNECTABLE,
   17614:	786b      	ldrb	r3, [r5, #1]
		err = le_adv_update(ad, ad_len, sd, sd_len,
   17616:	f3c3 02c0 	ubfx	r2, r3, #3, #1
   1761a:	f003 0301 	and.w	r3, r3, #1
   1761e:	9201      	str	r2, [sp, #4]
   17620:	9300      	str	r3, [sp, #0]
   17622:	464a      	mov	r2, r9
   17624:	9b14      	ldr	r3, [sp, #80]	; 0x50
   17626:	4659      	mov	r1, fp
   17628:	4650      	mov	r0, sl
   1762a:	f7fe fa3b 	bl	15aa4 <le_adv_update>
		if (err) {
   1762e:	4604      	mov	r4, r0
   17630:	2800      	cmp	r0, #0
   17632:	d0a9      	beq.n	17588 <bt_le_adv_start_internal+0x15c>
   17634:	e712      	b.n	1745c <bt_le_adv_start_internal+0x30>
		return -EAGAIN;
   17636:	f06f 040a 	mvn.w	r4, #10
   1763a:	e70f      	b.n	1745c <bt_le_adv_start_internal+0x30>
		return -EALREADY;
   1763c:	f06f 0444 	mvn.w	r4, #68	; 0x44
   17640:	e70c      	b.n	1745c <bt_le_adv_start_internal+0x30>
		return -ENOBUFS;
   17642:	f06f 0436 	mvn.w	r4, #54	; 0x36
   17646:	e709      	b.n	1745c <bt_le_adv_start_internal+0x30>
   17648:	2000f720 	.word	0x2000f720
   1764c:	2000f790 	.word	0x2000f790

00017650 <bt_le_adv_stop>:

	return bt_le_adv_start_internal(param, ad, ad_len, sd, sd_len, NULL);
}

int bt_le_adv_stop(void)
{
   17650:	b510      	push	{r4, lr}
   17652:	f46f 7100 	mvn.w	r1, #512	; 0x200
   17656:	4810      	ldr	r0, [pc, #64]	; (17698 <bt_le_adv_stop+0x48>)
   17658:	f013 f879 	bl	2a74e <atomic_and>
	/* Make sure advertising is not re-enabled later even if it's not
	 * currently enabled (i.e. BT_DEV_ADVERTISING is not set).
	 */
	atomic_clear_bit(bt_dev.flags, BT_DEV_KEEP_ADVERTISING);

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_ADVERTISING)) {
   1765c:	2106      	movs	r1, #6
   1765e:	480e      	ldr	r0, [pc, #56]	; (17698 <bt_le_adv_stop+0x48>)
   17660:	f013 f8a2 	bl	2a7a8 <atomic_test_bit>
   17664:	b910      	cbnz	r0, 1766c <bt_le_adv_stop+0x1c>
		return 0;
   17666:	2400      	movs	r4, #0
			le_set_private_addr(bt_dev.adv_id);
		}
	}

	return 0;
}
   17668:	4620      	mov	r0, r4
   1766a:	bd10      	pop	{r4, pc}
	err = set_advertise_enable(false);
   1766c:	2000      	movs	r0, #0
   1766e:	f7fe f973 	bl	15958 <set_advertise_enable>
	if (err) {
   17672:	4604      	mov	r4, r0
   17674:	2800      	cmp	r0, #0
   17676:	d1f7      	bne.n	17668 <bt_le_adv_stop+0x18>
		if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING) &&
   17678:	210a      	movs	r1, #10
   1767a:	4807      	ldr	r0, [pc, #28]	; (17698 <bt_le_adv_stop+0x48>)
   1767c:	f013 f894 	bl	2a7a8 <atomic_test_bit>
   17680:	2800      	cmp	r0, #0
   17682:	d0f0      	beq.n	17666 <bt_le_adv_stop+0x16>
		    atomic_test_bit(bt_dev.flags, BT_DEV_ACTIVE_SCAN)) {
   17684:	210c      	movs	r1, #12
   17686:	4804      	ldr	r0, [pc, #16]	; (17698 <bt_le_adv_stop+0x48>)
   17688:	f013 f88e 	bl	2a7a8 <atomic_test_bit>
		if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING) &&
   1768c:	2800      	cmp	r0, #0
   1768e:	d0ea      	beq.n	17666 <bt_le_adv_stop+0x16>
			le_set_private_addr(bt_dev.adv_id);
   17690:	f013 f893 	bl	2a7ba <le_set_private_addr.isra.22>
   17694:	e7e8      	b.n	17668 <bt_le_adv_stop+0x18>
   17696:	bf00      	nop
   17698:	2000f790 	.word	0x2000f790

0001769c <bt_le_scan_start>:

	return true;
}

int bt_le_scan_start(const struct bt_le_scan_param *param, bt_le_scan_cb_t cb)
{
   1769c:	b570      	push	{r4, r5, r6, lr}
   1769e:	4605      	mov	r5, r0
   176a0:	460e      	mov	r6, r1
	int err;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   176a2:	4828      	ldr	r0, [pc, #160]	; (17744 <bt_le_scan_start+0xa8>)
   176a4:	2101      	movs	r1, #1
   176a6:	f013 f87f 	bl	2a7a8 <atomic_test_bit>
   176aa:	2800      	cmp	r0, #0
   176ac:	d041      	beq.n	17732 <bt_le_scan_start+0x96>
	if (param->type != BT_HCI_LE_SCAN_PASSIVE &&
   176ae:	782b      	ldrb	r3, [r5, #0]
   176b0:	2b01      	cmp	r3, #1
   176b2:	d841      	bhi.n	17738 <bt_le_scan_start+0x9c>
	if (param->filter_dup &
   176b4:	786b      	ldrb	r3, [r5, #1]
   176b6:	f013 0ffc 	tst.w	r3, #252	; 0xfc
   176ba:	d13d      	bne.n	17738 <bt_le_scan_start+0x9c>
	if (is_wl_empty() &&
   176bc:	079b      	lsls	r3, r3, #30
   176be:	d43b      	bmi.n	17738 <bt_le_scan_start+0x9c>
	if (param->interval < 0x0004 || param->interval > 0x4000) {
   176c0:	8869      	ldrh	r1, [r5, #2]
   176c2:	1f0b      	subs	r3, r1, #4
   176c4:	b29b      	uxth	r3, r3
   176c6:	f643 70fc 	movw	r0, #16380	; 0x3ffc
   176ca:	4283      	cmp	r3, r0
   176cc:	d834      	bhi.n	17738 <bt_le_scan_start+0x9c>
	if (param->window < 0x0004 || param->window > 0x4000) {
   176ce:	88aa      	ldrh	r2, [r5, #4]
   176d0:	1f13      	subs	r3, r2, #4
   176d2:	b29b      	uxth	r3, r3
   176d4:	4283      	cmp	r3, r0
   176d6:	d82f      	bhi.n	17738 <bt_le_scan_start+0x9c>
	if (param->window > param->interval) {
   176d8:	4291      	cmp	r1, r2
   176da:	d32d      	bcc.n	17738 <bt_le_scan_start+0x9c>
	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
   176dc:	f44f 6100 	mov.w	r1, #2048	; 0x800
   176e0:	4818      	ldr	r0, [pc, #96]	; (17744 <bt_le_scan_start+0xa8>)
   176e2:	f013 f825 	bl	2a730 <atomic_or>
	if (!valid_le_scan_param(param)) {
		return -EINVAL;
	}

	/* Return if active scan is already enabled */
	if (atomic_test_and_set_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
   176e6:	f410 6300 	ands.w	r3, r0, #2048	; 0x800
   176ea:	d128      	bne.n	1773e <bt_le_scan_start+0xa2>
		return -EALREADY;
	}

	if (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING)) {
   176ec:	210a      	movs	r1, #10
   176ee:	4815      	ldr	r0, [pc, #84]	; (17744 <bt_le_scan_start+0xa8>)
   176f0:	f013 f85a 	bl	2a7a8 <atomic_test_bit>
   176f4:	b158      	cbz	r0, 1770e <bt_le_scan_start+0x72>
		err = set_le_scan_enable(BT_HCI_LE_SCAN_DISABLE);
   176f6:	4618      	mov	r0, r3
   176f8:	f7fe f8c6 	bl	15888 <set_le_scan_enable>
		if (err) {
   176fc:	4604      	mov	r4, r0
   176fe:	b130      	cbz	r0, 1770e <bt_le_scan_start+0x72>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   17700:	f46f 6100 	mvn.w	r1, #2048	; 0x800
   17704:	480f      	ldr	r0, [pc, #60]	; (17744 <bt_le_scan_start+0xa8>)
   17706:	f013 f822 	bl	2a74e <atomic_and>
	}

	scan_dev_found_cb = cb;

	return 0;
}
   1770a:	4620      	mov	r0, r4
   1770c:	bd70      	pop	{r4, r5, r6, pc}
	atomic_set_bit_to(bt_dev.flags, BT_DEV_SCAN_FILTER_DUP,
   1770e:	786a      	ldrb	r2, [r5, #1]
   17710:	480c      	ldr	r0, [pc, #48]	; (17744 <bt_le_scan_start+0xa8>)
   17712:	f002 0201 	and.w	r2, r2, #1
   17716:	210d      	movs	r1, #13
   17718:	f013 f828 	bl	2a76c <atomic_set_bit_to>
	err = start_le_scan(param->type, param->interval, param->window);
   1771c:	88aa      	ldrh	r2, [r5, #4]
   1771e:	8869      	ldrh	r1, [r5, #2]
   17720:	7828      	ldrb	r0, [r5, #0]
   17722:	f7fe fabb 	bl	15c9c <start_le_scan>
	if (err) {
   17726:	4604      	mov	r4, r0
   17728:	2800      	cmp	r0, #0
   1772a:	d1e9      	bne.n	17700 <bt_le_scan_start+0x64>
	scan_dev_found_cb = cb;
   1772c:	4b06      	ldr	r3, [pc, #24]	; (17748 <bt_le_scan_start+0xac>)
   1772e:	601e      	str	r6, [r3, #0]
	return 0;
   17730:	e7eb      	b.n	1770a <bt_le_scan_start+0x6e>
		return -EAGAIN;
   17732:	f06f 040a 	mvn.w	r4, #10
   17736:	e7e8      	b.n	1770a <bt_le_scan_start+0x6e>
		return -EINVAL;
   17738:	f06f 0415 	mvn.w	r4, #21
   1773c:	e7e5      	b.n	1770a <bt_le_scan_start+0x6e>
		return -EALREADY;
   1773e:	f06f 0444 	mvn.w	r4, #68	; 0x44
   17742:	e7e2      	b.n	1770a <bt_le_scan_start+0x6e>
   17744:	2000f790 	.word	0x2000f790
   17748:	20000a18 	.word	0x20000a18

0001774c <bt_le_scan_stop>:

int bt_le_scan_stop(void)
{
   1774c:	b508      	push	{r3, lr}
	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   1774e:	f46f 6100 	mvn.w	r1, #2048	; 0x800
   17752:	4807      	ldr	r0, [pc, #28]	; (17770 <bt_le_scan_stop+0x24>)
   17754:	f012 fffb 	bl	2a74e <atomic_and>
	/* Return if active scanning is already disabled */
	if (!atomic_test_and_clear_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
   17758:	0503      	lsls	r3, r0, #20
   1775a:	d506      	bpl.n	1776a <bt_le_scan_stop+0x1e>
		return -EALREADY;
	}

	scan_dev_found_cb = NULL;
   1775c:	4b05      	ldr	r3, [pc, #20]	; (17774 <bt_le_scan_stop+0x28>)
   1775e:	2000      	movs	r0, #0
   17760:	6018      	str	r0, [r3, #0]

	return bt_le_scan_update(false);
}
   17762:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return bt_le_scan_update(false);
   17766:	f7fe baf1 	b.w	15d4c <bt_le_scan_update>
}
   1776a:	f06f 0044 	mvn.w	r0, #68	; 0x44
   1776e:	bd08      	pop	{r3, pc}
   17770:	2000f790 	.word	0x2000f790
   17774:	20000a18 	.word	0x20000a18

00017778 <bt_buf_get_rx>:
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_SET_HOST_CHAN_CLASSIF,
				    buf, NULL);
}

struct net_buf *bt_buf_get_rx(enum bt_buf_type type, s32_t timeout)
{
   17778:	b538      	push	{r3, r4, r5, lr}
   1777a:	4605      	mov	r5, r0
		buf = net_buf_alloc(&hci_rx_pool, timeout);
	} else {
		buf = net_buf_alloc(&acl_in_pool, timeout);
	}
#else
	buf = net_buf_alloc(&hci_rx_pool, timeout);
   1777c:	4805      	ldr	r0, [pc, #20]	; (17794 <bt_buf_get_rx+0x1c>)
   1777e:	f015 f9cb 	bl	2cb18 <net_buf_alloc_fixed>
#endif

	if (buf) {
   17782:	4604      	mov	r4, r0
   17784:	b120      	cbz	r0, 17790 <bt_buf_get_rx+0x18>
		net_buf_reserve(buf, BT_BUF_RESERVE);
   17786:	2100      	movs	r1, #0
   17788:	3008      	adds	r0, #8
   1778a:	f015 f9e4 	bl	2cb56 <net_buf_simple_reserve>
	*(u8_t *)net_buf_user_data(buf) = type;
   1778e:	7525      	strb	r5, [r4, #20]
		bt_buf_set_type(buf, type);
	}

	return buf;
}
   17790:	4620      	mov	r0, r4
   17792:	bd38      	pop	{r3, r4, r5, pc}
   17794:	20010200 	.word	0x20010200

00017798 <bt_buf_get_cmd_complete>:

struct net_buf *bt_buf_get_cmd_complete(s32_t timeout)
{
   17798:	b510      	push	{r4, lr}
   1779a:	4601      	mov	r1, r0
	__asm__ volatile(
   1779c:	f04f 0320 	mov.w	r3, #32
   177a0:	f3ef 8011 	mrs	r0, BASEPRI
   177a4:	f383 8811 	msr	BASEPRI, r3
   177a8:	f3bf 8f6f 	isb	sy
	struct net_buf *buf;
	unsigned int key;

	key = irq_lock();
	buf = bt_dev.sent_cmd;
   177ac:	4a0c      	ldr	r2, [pc, #48]	; (177e0 <bt_buf_get_cmd_complete+0x48>)
	bt_dev.sent_cmd = NULL;
   177ae:	2300      	movs	r3, #0
	buf = bt_dev.sent_cmd;
   177b0:	f8d2 40c0 	ldr.w	r4, [r2, #192]	; 0xc0
	bt_dev.sent_cmd = NULL;
   177b4:	f8c2 30c0 	str.w	r3, [r2, #192]	; 0xc0
	__asm__ volatile(
   177b8:	f380 8811 	msr	BASEPRI, r0
   177bc:	f3bf 8f6f 	isb	sy
	irq_unlock(key);

	BT_DBG("sent_cmd %p", buf);

	if (buf) {
   177c0:	b924      	cbnz	r4, 177cc <bt_buf_get_cmd_complete+0x34>
		net_buf_reserve(buf, BT_BUF_RESERVE);

		return buf;
	}

	return bt_buf_get_rx(BT_BUF_EVT, timeout);
   177c2:	2001      	movs	r0, #1
}
   177c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
   177c8:	f7ff bfd6 	b.w	17778 <bt_buf_get_rx>
   177cc:	2201      	movs	r2, #1
		net_buf_reserve(buf, BT_BUF_RESERVE);
   177ce:	f104 0008 	add.w	r0, r4, #8
   177d2:	7522      	strb	r2, [r4, #20]
		buf->len = 0U;
   177d4:	81a3      	strh	r3, [r4, #12]
		net_buf_reserve(buf, BT_BUF_RESERVE);
   177d6:	4619      	mov	r1, r3
   177d8:	f015 f9bd 	bl	2cb56 <net_buf_simple_reserve>
}
   177dc:	4620      	mov	r0, r4
   177de:	bd10      	pop	{r4, pc}
   177e0:	2000f720 	.word	0x2000f720

000177e4 <bt_buf_get_evt>:

struct net_buf *bt_buf_get_evt(u8_t evt, bool discardable, s32_t timeout)
{
	switch (evt) {
   177e4:	280e      	cmp	r0, #14
{
   177e6:	460b      	mov	r3, r1
   177e8:	b510      	push	{r4, lr}
   177ea:	4611      	mov	r1, r2
	switch (evt) {
   177ec:	d315      	bcc.n	1781a <bt_buf_get_evt+0x36>
   177ee:	280f      	cmp	r0, #15
   177f0:	d90e      	bls.n	17810 <bt_buf_get_evt+0x2c>
   177f2:	2813      	cmp	r0, #19
   177f4:	d111      	bne.n	1781a <bt_buf_get_evt+0x36>
#if defined(CONFIG_BT_CONN)
	case BT_HCI_EVT_NUM_COMPLETED_PACKETS:
		{
			struct net_buf *buf;

			buf = net_buf_alloc(&num_complete_pool, timeout);
   177f6:	480d      	ldr	r0, [pc, #52]	; (1782c <bt_buf_get_evt+0x48>)
	default:
#if defined(CONFIG_BT_DISCARDABLE_BUF_COUNT)
		if (discardable) {
			struct net_buf *buf;

			buf = net_buf_alloc(&discardable_pool, timeout);
   177f8:	f015 f98e 	bl	2cb18 <net_buf_alloc_fixed>
			if (buf) {
   177fc:	4604      	mov	r4, r0
   177fe:	b128      	cbz	r0, 1780c <bt_buf_get_evt+0x28>
				net_buf_reserve(buf, BT_BUF_RESERVE);
   17800:	2100      	movs	r1, #0
   17802:	3008      	adds	r0, #8
   17804:	f015 f9a7 	bl	2cb56 <net_buf_simple_reserve>
   17808:	2301      	movs	r3, #1
   1780a:	7523      	strb	r3, [r4, #20]
		}
#endif /* CONFIG_BT_DISCARDABLE_BUF_COUNT */

		return bt_buf_get_rx(BT_BUF_EVT, timeout);
	}
}
   1780c:	4620      	mov	r0, r4
   1780e:	bd10      	pop	{r4, pc}
		return bt_buf_get_cmd_complete(timeout);
   17810:	4610      	mov	r0, r2
}
   17812:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return bt_buf_get_cmd_complete(timeout);
   17816:	f7ff bfbf 	b.w	17798 <bt_buf_get_cmd_complete>
		if (discardable) {
   1781a:	b10b      	cbz	r3, 17820 <bt_buf_get_evt+0x3c>
			buf = net_buf_alloc(&discardable_pool, timeout);
   1781c:	4804      	ldr	r0, [pc, #16]	; (17830 <bt_buf_get_evt+0x4c>)
   1781e:	e7eb      	b.n	177f8 <bt_buf_get_evt+0x14>
		return bt_buf_get_rx(BT_BUF_EVT, timeout);
   17820:	2001      	movs	r0, #1
}
   17822:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return bt_buf_get_rx(BT_BUF_EVT, timeout);
   17826:	f7ff bfa7 	b.w	17778 <bt_buf_get_rx>
   1782a:	bf00      	nop
   1782c:	20010220 	.word	0x20010220
   17830:	200101a0 	.word	0x200101a0

00017834 <tx_free>:
	return bt_l2cap_update_conn_param(conn, param);
}

static void tx_free(struct bt_conn_tx *tx)
{
	tx->cb = NULL;
   17834:	2300      	movs	r3, #0
{
   17836:	4601      	mov	r1, r0
	tx->user_data = NULL;
   17838:	e9c0 3301 	strd	r3, r3, [r0, #4]
	tx->pending_no_cb = 0U;
   1783c:	60c3      	str	r3, [r0, #12]
	k_fifo_put(&free_tx, tx);
   1783e:	4801      	ldr	r0, [pc, #4]	; (17844 <tx_free+0x10>)
   17840:	f015 bc5f 	b.w	2d102 <k_queue_append>
   17844:	200100e8 	.word	0x200100e8

00017848 <notify_connected>:
{
   17848:	b538      	push	{r3, r4, r5, lr}
	for (cb = callback_list; cb; cb = cb->_next) {
   1784a:	4b09      	ldr	r3, [pc, #36]	; (17870 <notify_connected+0x28>)
   1784c:	681c      	ldr	r4, [r3, #0]
{
   1784e:	4605      	mov	r5, r0
   17850:	7a69      	ldrb	r1, [r5, #9]
	for (cb = callback_list; cb; cb = cb->_next) {
   17852:	b92c      	cbnz	r4, 17860 <notify_connected+0x18>
	if (!conn->err) {
   17854:	b951      	cbnz	r1, 1786c <notify_connected+0x24>
		bt_gatt_connected(conn);
   17856:	4628      	mov	r0, r5
}
   17858:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		bt_gatt_connected(conn);
   1785c:	f003 be62 	b.w	1b524 <bt_gatt_connected>
		if (cb->connected) {
   17860:	6823      	ldr	r3, [r4, #0]
   17862:	b10b      	cbz	r3, 17868 <notify_connected+0x20>
			cb->connected(conn, conn->err);
   17864:	4628      	mov	r0, r5
   17866:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
   17868:	6924      	ldr	r4, [r4, #16]
   1786a:	e7f1      	b.n	17850 <notify_connected+0x8>
}
   1786c:	bd38      	pop	{r3, r4, r5, pc}
   1786e:	bf00      	nop
   17870:	20000a88 	.word	0x20000a88

00017874 <send_frag>:
	return 0;
}

static bool send_frag(struct bt_conn *conn, struct net_buf *buf, u8_t flags,
		      bool always_consume)
{
   17874:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   17878:	4604      	mov	r4, r0
   1787a:	460e      	mov	r6, r1
   1787c:	4691      	mov	r9, r2
   1787e:	461f      	mov	r7, r3
	struct bt_conn_tx *tx = tx_data(buf)->tx;
   17880:	694d      	ldr	r5, [r1, #20]
	return z_impl_k_sem_take(sem, timeout);
   17882:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   17886:	4846      	ldr	r0, [pc, #280]	; (179a0 <send_frag+0x12c>)
   17888:	f00f fc6a 	bl	27160 <z_impl_k_sem_take>

	/* Wait until the controller can accept ACL packets */
	k_sem_take(bt_conn_get_pkts(conn), K_FOREVER);

	/* Check for disconnection while waiting for pkts_sem */
	if (conn->state != BT_CONN_CONNECTED) {
   1788c:	7aa1      	ldrb	r1, [r4, #10]
   1788e:	2904      	cmp	r1, #4
   17890:	d155      	bne.n	1793e <send_frag+0xca>
		goto fail;
	}

	hdr = net_buf_push(buf, sizeof(*hdr));
   17892:	f106 0008 	add.w	r0, r6, #8
   17896:	f015 f994 	bl	2cbc2 <net_buf_simple_push>
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
   1789a:	8822      	ldrh	r2, [r4, #0]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   1789c:	89b3      	ldrh	r3, [r6, #12]
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
   1789e:	ea42 3209 	orr.w	r2, r2, r9, lsl #12
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   178a2:	3b04      	subs	r3, #4
	hdr->handle = sys_cpu_to_le16(bt_acl_handle_pack(conn->handle, flags));
   178a4:	8002      	strh	r2, [r0, #0]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   178a6:	8043      	strh	r3, [r0, #2]
	__asm__ volatile(
   178a8:	f04f 0320 	mov.w	r3, #32
   178ac:	f3ef 8211 	mrs	r2, BASEPRI
   178b0:	f383 8811 	msr	BASEPRI, r3
   178b4:	f3bf 8f6f 	isb	sy

	/* Add to pending, it must be done before bt_buf_set_type */
	key = irq_lock();
	if (tx) {
   178b8:	2d00      	cmp	r5, #0
   178ba:	d052      	beq.n	17962 <send_frag+0xee>
	parent->next = child;
   178bc:	2300      	movs	r3, #0
   178be:	602b      	str	r3, [r5, #0]
Z_GENLIST_APPEND(slist, snode)
   178c0:	69a3      	ldr	r3, [r4, #24]
   178c2:	2b00      	cmp	r3, #0
   178c4:	d14a      	bne.n	1795c <send_frag+0xe8>
	list->head = node;
   178c6:	e9c4 5505 	strd	r5, r5, [r4, #20]
	__asm__ volatile(
   178ca:	f382 8811 	msr	BASEPRI, r2
   178ce:	f3bf 8f6f 	isb	sy
   178d2:	2302      	movs	r3, #2
   178d4:	7533      	strb	r3, [r6, #20]
	}
	irq_unlock(key);

	bt_buf_set_type(buf, BT_BUF_ACL_OUT);

	err = bt_send(buf);
   178d6:	4630      	mov	r0, r6
   178d8:	f7fe f99c 	bl	15c14 <bt_send>
	if (err) {
   178dc:	4601      	mov	r1, r0
   178de:	2800      	cmp	r0, #0
   178e0:	d05b      	beq.n	1799a <send_frag+0x126>
		BT_ERR("Unable to send to driver (err %d)", err);
   178e2:	4b30      	ldr	r3, [pc, #192]	; (179a4 <send_frag+0x130>)
   178e4:	681b      	ldr	r3, [r3, #0]
   178e6:	075b      	lsls	r3, r3, #29
   178e8:	d00d      	beq.n	17906 <send_frag+0x92>
   178ea:	2301      	movs	r3, #1
   178ec:	f04f 0200 	mov.w	r2, #0
   178f0:	f363 0207 	bfi	r2, r3, #0, #8
   178f4:	482c      	ldr	r0, [pc, #176]	; (179a8 <send_frag+0x134>)
   178f6:	4b2d      	ldr	r3, [pc, #180]	; (179ac <send_frag+0x138>)
   178f8:	1a1b      	subs	r3, r3, r0
   178fa:	08db      	lsrs	r3, r3, #3
   178fc:	f363 128f 	bfi	r2, r3, #6, #10
   17900:	482b      	ldr	r0, [pc, #172]	; (179b0 <send_frag+0x13c>)
   17902:	f011 f827 	bl	28954 <log_1>
	__asm__ volatile(
   17906:	f04f 0320 	mov.w	r3, #32
   1790a:	f3ef 8111 	mrs	r1, BASEPRI
   1790e:	f383 8811 	msr	BASEPRI, r3
   17912:	f3bf 8f6f 	isb	sy
		key = irq_lock();
		/* Roll back the pending TX info */
		if (tx) {
   17916:	2d00      	cmp	r5, #0
   17918:	d039      	beq.n	1798e <send_frag+0x11a>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1791a:	6963      	ldr	r3, [r4, #20]
   1791c:	2200      	movs	r2, #0
   1791e:	b153      	cbz	r3, 17936 <send_frag+0xc2>
   17920:	429d      	cmp	r5, r3
   17922:	d131      	bne.n	17988 <send_frag+0x114>
Z_GENLIST_REMOVE(slist, snode)
   17924:	682b      	ldr	r3, [r5, #0]
   17926:	bb4a      	cbnz	r2, 1797c <send_frag+0x108>
   17928:	69a2      	ldr	r2, [r4, #24]
	list->head = node;
   1792a:	6163      	str	r3, [r4, #20]
Z_GENLIST_REMOVE(slist, snode)
   1792c:	4295      	cmp	r5, r2
   1792e:	d100      	bne.n	17932 <send_frag+0xbe>
	list->tail = node;
   17930:	61a3      	str	r3, [r4, #24]
	parent->next = child;
   17932:	2300      	movs	r3, #0
   17934:	602b      	str	r3, [r5, #0]
	__asm__ volatile(
   17936:	f381 8811 	msr	BASEPRI, r1
   1793a:	f3bf 8f6f 	isb	sy
	z_impl_k_sem_give(sem);
   1793e:	4818      	ldr	r0, [pc, #96]	; (179a0 <send_frag+0x12c>)
   17940:	f00f fbe2 	bl	27108 <z_impl_k_sem_give>

	return true;

fail:
	k_sem_give(bt_conn_get_pkts(conn));
	if (tx) {
   17944:	b115      	cbz	r5, 1794c <send_frag+0xd8>
		tx_free(tx);
   17946:	4628      	mov	r0, r5
   17948:	f7ff ff74 	bl	17834 <tx_free>
	}

	if (always_consume) {
   1794c:	b11f      	cbz	r7, 17956 <send_frag+0xe2>
		net_buf_unref(buf);
   1794e:	4630      	mov	r0, r6
   17950:	f00d fcbc 	bl	252cc <net_buf_unref>
	}
	return false;
   17954:	2700      	movs	r7, #0
}
   17956:	4638      	mov	r0, r7
   17958:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1795c:	601d      	str	r5, [r3, #0]
	list->tail = node;
   1795e:	61a5      	str	r5, [r4, #24]
   17960:	e7b3      	b.n	178ca <send_frag+0x56>
		tail_tx = (void *)sys_slist_peek_tail(&conn->tx_pending);
   17962:	69a3      	ldr	r3, [r4, #24]
		if (tail_tx) {
   17964:	b133      	cbz	r3, 17974 <send_frag+0x100>
			pending_no_cb = &tail_tx->pending_no_cb;
   17966:	f103 080c 	add.w	r8, r3, #12
   1796a:	68db      	ldr	r3, [r3, #12]
		(*pending_no_cb)++;
   1796c:	3301      	adds	r3, #1
   1796e:	f8c8 3000 	str.w	r3, [r8]
   17972:	e7aa      	b.n	178ca <send_frag+0x56>
			pending_no_cb = &conn->pending_no_cb;
   17974:	f104 081c 	add.w	r8, r4, #28
   17978:	69e3      	ldr	r3, [r4, #28]
   1797a:	e7f7      	b.n	1796c <send_frag+0xf8>
	parent->next = child;
   1797c:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   1797e:	69a3      	ldr	r3, [r4, #24]
   17980:	429d      	cmp	r5, r3
	list->tail = node;
   17982:	bf08      	it	eq
   17984:	61a2      	streq	r2, [r4, #24]
   17986:	e7d4      	b.n	17932 <send_frag+0xbe>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   17988:	461a      	mov	r2, r3
   1798a:	681b      	ldr	r3, [r3, #0]
   1798c:	e7c7      	b.n	1791e <send_frag+0xaa>
			(*pending_no_cb)--;
   1798e:	f8d8 3000 	ldr.w	r3, [r8]
   17992:	3b01      	subs	r3, #1
   17994:	f8c8 3000 	str.w	r3, [r8]
   17998:	e7cd      	b.n	17936 <send_frag+0xc2>
	return true;
   1799a:	2701      	movs	r7, #1
   1799c:	e7db      	b.n	17956 <send_frag+0xe2>
   1799e:	bf00      	nop
   179a0:	2000f7ac 	.word	0x2000f7ac
   179a4:	2000ffa0 	.word	0x2000ffa0
   179a8:	0002db28 	.word	0x0002db28
   179ac:	0002db38 	.word	0x0002db38
   179b0:	00030741 	.word	0x00030741

000179b4 <conn_cleanup>:

static struct k_poll_signal conn_change =
		K_POLL_SIGNAL_INITIALIZER(conn_change);

static void conn_cleanup(struct bt_conn *conn)
{
   179b4:	b570      	push	{r4, r5, r6, lr}
   179b6:	4605      	mov	r5, r0
	struct net_buf *buf;

	/* Give back any allocated buffers */
	while ((buf = net_buf_get(&conn->tx_queue, K_NO_WAIT))) {
   179b8:	f100 0634 	add.w	r6, r0, #52	; 0x34
   179bc:	2100      	movs	r1, #0
   179be:	4630      	mov	r0, r6
   179c0:	f015 f8b0 	bl	2cb24 <net_buf_get>
   179c4:	4604      	mov	r4, r0
   179c6:	b950      	cbnz	r0, 179de <conn_cleanup+0x2a>
	}

	__ASSERT(sys_slist_is_empty(&conn->tx_pending), "Pending TX packets");
	__ASSERT_NO_MSG(conn->pending_no_cb == 0);

	bt_conn_reset_rx_state(conn);
   179c8:	4628      	mov	r0, r5
   179ca:	f012 ffb1 	bl	2a930 <bt_conn_reset_rx_state>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   179ce:	4622      	mov	r2, r4
   179d0:	f105 0150 	add.w	r1, r5, #80	; 0x50
   179d4:	4806      	ldr	r0, [pc, #24]	; (179f0 <conn_cleanup+0x3c>)

	k_delayed_work_submit(&conn->update_work, K_NO_WAIT);
}
   179d6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   179da:	f00f bd2f 	b.w	2743c <k_delayed_work_submit_to_queue>
		if (tx_data(buf)->tx) {
   179de:	6960      	ldr	r0, [r4, #20]
   179e0:	b108      	cbz	r0, 179e6 <conn_cleanup+0x32>
			tx_free(tx_data(buf)->tx);
   179e2:	f7ff ff27 	bl	17834 <tx_free>
		net_buf_unref(buf);
   179e6:	4620      	mov	r0, r4
   179e8:	f00d fc70 	bl	252cc <net_buf_unref>
   179ec:	e7e6      	b.n	179bc <conn_cleanup+0x8>
   179ee:	bf00      	nop
   179f0:	20003b5c 	.word	0x20003b5c

000179f4 <bt_conn_get_pkts>:
}
   179f4:	4800      	ldr	r0, [pc, #0]	; (179f8 <bt_conn_get_pkts+0x4>)
   179f6:	4770      	bx	lr
   179f8:	2000f7ac 	.word	0x2000f7ac

000179fc <notify_le_param_updated>:
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
   179fc:	1d02      	adds	r2, r0, #4
{
   179fe:	b570      	push	{r4, r5, r6, lr}
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
   17a00:	2109      	movs	r1, #9
{
   17a02:	4604      	mov	r4, r0
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
   17a04:	4610      	mov	r0, r2
   17a06:	f012 ff8c 	bl	2a922 <atomic_test_bit>
   17a0a:	b1c8      	cbz	r0, 17a40 <notify_le_param_updated+0x44>
	    conn->le.interval >= conn->le.interval_min &&
   17a0c:	f8b4 3086 	ldrh.w	r3, [r4, #134]	; 0x86
	if (atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET) &&
   17a10:	f8b4 1088 	ldrh.w	r1, [r4, #136]	; 0x88
   17a14:	4299      	cmp	r1, r3
   17a16:	d813      	bhi.n	17a40 <notify_le_param_updated+0x44>
	    conn->le.interval >= conn->le.interval_min &&
   17a18:	f8b4 108a 	ldrh.w	r1, [r4, #138]	; 0x8a
   17a1c:	4299      	cmp	r1, r3
   17a1e:	d30f      	bcc.n	17a40 <notify_le_param_updated+0x44>
	    conn->le.latency == conn->le.pending_latency &&
   17a20:	e9d4 1323 	ldrd	r1, r3, [r4, #140]	; 0x8c
   17a24:	4299      	cmp	r1, r3
   17a26:	d10b      	bne.n	17a40 <notify_le_param_updated+0x44>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   17a28:	f3bf 8f5b 	dmb	ish
   17a2c:	e852 3f00 	ldrex	r3, [r2]
   17a30:	f423 7300 	bic.w	r3, r3, #512	; 0x200
   17a34:	e842 3100 	strex	r1, r3, [r2]
   17a38:	2900      	cmp	r1, #0
   17a3a:	d1f7      	bne.n	17a2c <notify_le_param_updated+0x30>
   17a3c:	f3bf 8f5b 	dmb	ish
	for (cb = callback_list; cb; cb = cb->_next) {
   17a40:	4b07      	ldr	r3, [pc, #28]	; (17a60 <notify_le_param_updated+0x64>)
   17a42:	681d      	ldr	r5, [r3, #0]
   17a44:	b905      	cbnz	r5, 17a48 <notify_le_param_updated+0x4c>
}
   17a46:	bd70      	pop	{r4, r5, r6, pc}
		if (cb->le_param_updated) {
   17a48:	68ee      	ldr	r6, [r5, #12]
   17a4a:	b13e      	cbz	r6, 17a5c <notify_le_param_updated+0x60>
			cb->le_param_updated(conn, conn->le.interval,
   17a4c:	f8b4 308e 	ldrh.w	r3, [r4, #142]	; 0x8e
   17a50:	f8b4 208c 	ldrh.w	r2, [r4, #140]	; 0x8c
   17a54:	f8b4 1086 	ldrh.w	r1, [r4, #134]	; 0x86
   17a58:	4620      	mov	r0, r4
   17a5a:	47b0      	blx	r6
	for (cb = callback_list; cb; cb = cb->_next) {
   17a5c:	692d      	ldr	r5, [r5, #16]
   17a5e:	e7f1      	b.n	17a44 <notify_le_param_updated+0x48>
   17a60:	20000a88 	.word	0x20000a88

00017a64 <le_param_req>:
{
   17a64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   17a66:	4607      	mov	r7, r0
	if (!bt_le_conn_params_valid(param)) {
   17a68:	4608      	mov	r0, r1
{
   17a6a:	460e      	mov	r6, r1
	if (!bt_le_conn_params_valid(param)) {
   17a6c:	f012 feb9 	bl	2a7e2 <bt_le_conn_params_valid>
   17a70:	4605      	mov	r5, r0
   17a72:	b910      	cbnz	r0, 17a7a <le_param_req+0x16>
		return false;
   17a74:	2500      	movs	r5, #0
}
   17a76:	4628      	mov	r0, r5
   17a78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (cb = callback_list; cb; cb = cb->_next) {
   17a7a:	4b09      	ldr	r3, [pc, #36]	; (17aa0 <le_param_req+0x3c>)
   17a7c:	681c      	ldr	r4, [r3, #0]
   17a7e:	2c00      	cmp	r4, #0
   17a80:	d0f9      	beq.n	17a76 <le_param_req+0x12>
		if (!cb->le_param_req) {
   17a82:	68a3      	ldr	r3, [r4, #8]
   17a84:	b90b      	cbnz	r3, 17a8a <le_param_req+0x26>
	for (cb = callback_list; cb; cb = cb->_next) {
   17a86:	6924      	ldr	r4, [r4, #16]
   17a88:	e7f9      	b.n	17a7e <le_param_req+0x1a>
		if (!cb->le_param_req(conn, param)) {
   17a8a:	4631      	mov	r1, r6
   17a8c:	4638      	mov	r0, r7
   17a8e:	4798      	blx	r3
   17a90:	2800      	cmp	r0, #0
   17a92:	d0ef      	beq.n	17a74 <le_param_req+0x10>
		if (!bt_le_conn_params_valid(param)) {
   17a94:	4630      	mov	r0, r6
   17a96:	f012 fea4 	bl	2a7e2 <bt_le_conn_params_valid>
   17a9a:	2800      	cmp	r0, #0
   17a9c:	d1f3      	bne.n	17a86 <le_param_req+0x22>
   17a9e:	e7e9      	b.n	17a74 <le_param_req+0x10>
   17aa0:	20000a88 	.word	0x20000a88

00017aa4 <bt_conn_cb_register>:
	cb->_next = callback_list;
   17aa4:	4b02      	ldr	r3, [pc, #8]	; (17ab0 <bt_conn_cb_register+0xc>)
   17aa6:	681a      	ldr	r2, [r3, #0]
   17aa8:	6102      	str	r2, [r0, #16]
	callback_list = cb;
   17aaa:	6018      	str	r0, [r3, #0]
}
   17aac:	4770      	bx	lr
   17aae:	bf00      	nop
   17ab0:	20000a88 	.word	0x20000a88

00017ab4 <bt_conn_recv>:
{
   17ab4:	b570      	push	{r4, r5, r6, lr}
   17ab6:	4616      	mov	r6, r2
   17ab8:	4604      	mov	r4, r0
   17aba:	460d      	mov	r5, r1
	tx_notify(conn);
   17abc:	f012 ff5d 	bl	2a97a <tx_notify>
	switch (flags) {
   17ac0:	2e01      	cmp	r6, #1
   17ac2:	d024      	beq.n	17b0e <bt_conn_recv+0x5a>
   17ac4:	2e02      	cmp	r6, #2
   17ac6:	f040 8095 	bne.w	17bf4 <bt_conn_recv+0x140>
		len = sys_le16_to_cpu(hdr->len);
   17aca:	68ab      	ldr	r3, [r5, #8]
   17acc:	881e      	ldrh	r6, [r3, #0]
		if (conn->rx_len) {
   17ace:	89a3      	ldrh	r3, [r4, #12]
   17ad0:	b1a3      	cbz	r3, 17afc <bt_conn_recv+0x48>
			BT_ERR("Unexpected first L2CAP frame");
   17ad2:	4b55      	ldr	r3, [pc, #340]	; (17c28 <bt_conn_recv+0x174>)
   17ad4:	681b      	ldr	r3, [r3, #0]
   17ad6:	075b      	lsls	r3, r3, #29
   17ad8:	d00d      	beq.n	17af6 <bt_conn_recv+0x42>
   17ada:	2301      	movs	r3, #1
   17adc:	f04f 0100 	mov.w	r1, #0
   17ae0:	f363 0107 	bfi	r1, r3, #0, #8
   17ae4:	4a51      	ldr	r2, [pc, #324]	; (17c2c <bt_conn_recv+0x178>)
   17ae6:	4b52      	ldr	r3, [pc, #328]	; (17c30 <bt_conn_recv+0x17c>)
   17ae8:	4852      	ldr	r0, [pc, #328]	; (17c34 <bt_conn_recv+0x180>)
   17aea:	1a9b      	subs	r3, r3, r2
   17aec:	08db      	lsrs	r3, r3, #3
   17aee:	f363 118f 	bfi	r1, r3, #6, #10
   17af2:	f010 ff22 	bl	2893a <log_0>
			bt_conn_reset_rx_state(conn);
   17af6:	4620      	mov	r0, r4
   17af8:	f012 ff1a 	bl	2a930 <bt_conn_reset_rx_state>
		conn->rx_len = (sizeof(*hdr) + len) - buf->len;
   17afc:	89ab      	ldrh	r3, [r5, #12]
   17afe:	1af3      	subs	r3, r6, r3
   17b00:	3304      	adds	r3, #4
   17b02:	b29b      	uxth	r3, r3
   17b04:	81a3      	strh	r3, [r4, #12]
		if (conn->rx_len) {
   17b06:	2b00      	cmp	r3, #0
   17b08:	d05b      	beq.n	17bc2 <bt_conn_recv+0x10e>
			conn->rx = buf;
   17b0a:	6125      	str	r5, [r4, #16]
}
   17b0c:	bd70      	pop	{r4, r5, r6, pc}
		if (!conn->rx_len) {
   17b0e:	89a3      	ldrh	r3, [r4, #12]
   17b10:	b9cb      	cbnz	r3, 17b46 <bt_conn_recv+0x92>
			BT_ERR("Unexpected L2CAP continuation");
   17b12:	4b45      	ldr	r3, [pc, #276]	; (17c28 <bt_conn_recv+0x174>)
   17b14:	681b      	ldr	r3, [r3, #0]
   17b16:	075e      	lsls	r6, r3, #29
   17b18:	d00d      	beq.n	17b36 <bt_conn_recv+0x82>
   17b1a:	2301      	movs	r3, #1
   17b1c:	f04f 0100 	mov.w	r1, #0
   17b20:	f363 0107 	bfi	r1, r3, #0, #8
   17b24:	4a41      	ldr	r2, [pc, #260]	; (17c2c <bt_conn_recv+0x178>)
   17b26:	4b42      	ldr	r3, [pc, #264]	; (17c30 <bt_conn_recv+0x17c>)
   17b28:	4843      	ldr	r0, [pc, #268]	; (17c38 <bt_conn_recv+0x184>)
   17b2a:	1a9b      	subs	r3, r3, r2
   17b2c:	08db      	lsrs	r3, r3, #3
   17b2e:	f363 118f 	bfi	r1, r3, #6, #10
   17b32:	f010 ff02 	bl	2893a <log_0>
			bt_conn_reset_rx_state(conn);
   17b36:	4620      	mov	r0, r4
   17b38:	f012 fefa 	bl	2a930 <bt_conn_reset_rx_state>
		net_buf_unref(buf);
   17b3c:	4628      	mov	r0, r5
}
   17b3e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		net_buf_unref(buf);
   17b42:	f00d bbc3 	b.w	252cc <net_buf_unref>
		if (buf->len > conn->rx_len) {
   17b46:	89ae      	ldrh	r6, [r5, #12]
   17b48:	42b3      	cmp	r3, r6
   17b4a:	d210      	bcs.n	17b6e <bt_conn_recv+0xba>
			BT_ERR("L2CAP data overflow");
   17b4c:	4b36      	ldr	r3, [pc, #216]	; (17c28 <bt_conn_recv+0x174>)
   17b4e:	681b      	ldr	r3, [r3, #0]
   17b50:	0758      	lsls	r0, r3, #29
   17b52:	d0f0      	beq.n	17b36 <bt_conn_recv+0x82>
   17b54:	2301      	movs	r3, #1
   17b56:	f04f 0100 	mov.w	r1, #0
   17b5a:	f363 0107 	bfi	r1, r3, #0, #8
   17b5e:	4a33      	ldr	r2, [pc, #204]	; (17c2c <bt_conn_recv+0x178>)
   17b60:	4b33      	ldr	r3, [pc, #204]	; (17c30 <bt_conn_recv+0x17c>)
   17b62:	4836      	ldr	r0, [pc, #216]	; (17c3c <bt_conn_recv+0x188>)
   17b64:	1a9b      	subs	r3, r3, r2
   17b66:	08db      	lsrs	r3, r3, #3
   17b68:	f363 118f 	bfi	r1, r3, #6, #10
   17b6c:	e7e1      	b.n	17b32 <bt_conn_recv+0x7e>
		if (buf->len > net_buf_tailroom(conn->rx)) {
   17b6e:	6920      	ldr	r0, [r4, #16]
   17b70:	3008      	adds	r0, #8
   17b72:	f015 f852 	bl	2cc1a <net_buf_simple_tailroom>
   17b76:	4286      	cmp	r6, r0
   17b78:	d910      	bls.n	17b9c <bt_conn_recv+0xe8>
			BT_ERR("Not enough buffer space for L2CAP data");
   17b7a:	4b2b      	ldr	r3, [pc, #172]	; (17c28 <bt_conn_recv+0x174>)
   17b7c:	681b      	ldr	r3, [r3, #0]
   17b7e:	0759      	lsls	r1, r3, #29
   17b80:	d0d9      	beq.n	17b36 <bt_conn_recv+0x82>
   17b82:	2301      	movs	r3, #1
   17b84:	f04f 0100 	mov.w	r1, #0
   17b88:	f363 0107 	bfi	r1, r3, #0, #8
   17b8c:	4a27      	ldr	r2, [pc, #156]	; (17c2c <bt_conn_recv+0x178>)
   17b8e:	4b28      	ldr	r3, [pc, #160]	; (17c30 <bt_conn_recv+0x17c>)
   17b90:	482b      	ldr	r0, [pc, #172]	; (17c40 <bt_conn_recv+0x18c>)
   17b92:	1a9b      	subs	r3, r3, r2
   17b94:	08db      	lsrs	r3, r3, #3
   17b96:	f363 118f 	bfi	r1, r3, #6, #10
   17b9a:	e7ca      	b.n	17b32 <bt_conn_recv+0x7e>
		net_buf_add_mem(conn->rx, buf->data, buf->len);
   17b9c:	6920      	ldr	r0, [r4, #16]
   17b9e:	89aa      	ldrh	r2, [r5, #12]
   17ba0:	68a9      	ldr	r1, [r5, #8]
   17ba2:	3008      	adds	r0, #8
   17ba4:	f014 fff2 	bl	2cb8c <net_buf_simple_add_mem>
		conn->rx_len -= buf->len;
   17ba8:	89a3      	ldrh	r3, [r4, #12]
   17baa:	89aa      	ldrh	r2, [r5, #12]
   17bac:	1a9b      	subs	r3, r3, r2
   17bae:	81a3      	strh	r3, [r4, #12]
		net_buf_unref(buf);
   17bb0:	4628      	mov	r0, r5
   17bb2:	f00d fb8b 	bl	252cc <net_buf_unref>
		if (conn->rx_len) {
   17bb6:	89a3      	ldrh	r3, [r4, #12]
   17bb8:	2b00      	cmp	r3, #0
   17bba:	d1a7      	bne.n	17b0c <bt_conn_recv+0x58>
		buf = conn->rx;
   17bbc:	6925      	ldr	r5, [r4, #16]
		conn->rx_len = 0U;
   17bbe:	81a3      	strh	r3, [r4, #12]
		conn->rx = NULL;
   17bc0:	6123      	str	r3, [r4, #16]
	len = sys_le16_to_cpu(hdr->len);
   17bc2:	68ab      	ldr	r3, [r5, #8]
	if (sizeof(*hdr) + len != buf->len) {
   17bc4:	89aa      	ldrh	r2, [r5, #12]
   17bc6:	8819      	ldrh	r1, [r3, #0]
   17bc8:	1d0b      	adds	r3, r1, #4
   17bca:	4293      	cmp	r3, r2
   17bcc:	d026      	beq.n	17c1c <bt_conn_recv+0x168>
		BT_ERR("ACL len mismatch (%u != %u)", len, buf->len);
   17bce:	4b16      	ldr	r3, [pc, #88]	; (17c28 <bt_conn_recv+0x174>)
   17bd0:	681b      	ldr	r3, [r3, #0]
   17bd2:	075b      	lsls	r3, r3, #29
   17bd4:	d0b2      	beq.n	17b3c <bt_conn_recv+0x88>
   17bd6:	2001      	movs	r0, #1
   17bd8:	f04f 0300 	mov.w	r3, #0
   17bdc:	f360 0307 	bfi	r3, r0, #0, #8
   17be0:	4c12      	ldr	r4, [pc, #72]	; (17c2c <bt_conn_recv+0x178>)
   17be2:	4813      	ldr	r0, [pc, #76]	; (17c30 <bt_conn_recv+0x17c>)
   17be4:	1b00      	subs	r0, r0, r4
   17be6:	08c0      	lsrs	r0, r0, #3
   17be8:	f360 138f 	bfi	r3, r0, #6, #10
   17bec:	4815      	ldr	r0, [pc, #84]	; (17c44 <bt_conn_recv+0x190>)
   17bee:	f010 fec5 	bl	2897c <log_2>
   17bf2:	e7a3      	b.n	17b3c <bt_conn_recv+0x88>
		BT_ERR("Unexpected ACL flags (0x%02x)", flags);
   17bf4:	4b0c      	ldr	r3, [pc, #48]	; (17c28 <bt_conn_recv+0x174>)
   17bf6:	681b      	ldr	r3, [r3, #0]
   17bf8:	075a      	lsls	r2, r3, #29
   17bfa:	d09c      	beq.n	17b36 <bt_conn_recv+0x82>
   17bfc:	2301      	movs	r3, #1
   17bfe:	f04f 0200 	mov.w	r2, #0
   17c02:	f363 0207 	bfi	r2, r3, #0, #8
   17c06:	4909      	ldr	r1, [pc, #36]	; (17c2c <bt_conn_recv+0x178>)
   17c08:	4b09      	ldr	r3, [pc, #36]	; (17c30 <bt_conn_recv+0x17c>)
   17c0a:	480f      	ldr	r0, [pc, #60]	; (17c48 <bt_conn_recv+0x194>)
   17c0c:	1a5b      	subs	r3, r3, r1
   17c0e:	08db      	lsrs	r3, r3, #3
   17c10:	f363 128f 	bfi	r2, r3, #6, #10
   17c14:	4631      	mov	r1, r6
   17c16:	f010 fe9d 	bl	28954 <log_1>
   17c1a:	e78c      	b.n	17b36 <bt_conn_recv+0x82>
	bt_l2cap_recv(conn, buf);
   17c1c:	4629      	mov	r1, r5
   17c1e:	4620      	mov	r0, r4
}
   17c20:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_l2cap_recv(conn, buf);
   17c24:	f000 bef8 	b.w	18a18 <bt_l2cap_recv>
   17c28:	2000ffa0 	.word	0x2000ffa0
   17c2c:	0002db28 	.word	0x0002db28
   17c30:	0002db38 	.word	0x0002db38
   17c34:	00030e57 	.word	0x00030e57
   17c38:	00030e74 	.word	0x00030e74
   17c3c:	00030e92 	.word	0x00030e92
   17c40:	00030ea6 	.word	0x00030ea6
   17c44:	00030eeb 	.word	0x00030eeb
   17c48:	00030ecd 	.word	0x00030ecd

00017c4c <bt_conn_send_cb>:
{
   17c4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   17c50:	4698      	mov	r8, r3
	if (conn->state != BT_CONN_CONNECTED) {
   17c52:	7a83      	ldrb	r3, [r0, #10]
   17c54:	2b04      	cmp	r3, #4
{
   17c56:	4606      	mov	r6, r0
   17c58:	460d      	mov	r5, r1
   17c5a:	4617      	mov	r7, r2
	if (conn->state != BT_CONN_CONNECTED) {
   17c5c:	d017      	beq.n	17c8e <bt_conn_send_cb+0x42>
		BT_ERR("not connected!");
   17c5e:	4b35      	ldr	r3, [pc, #212]	; (17d34 <bt_conn_send_cb+0xe8>)
   17c60:	681b      	ldr	r3, [r3, #0]
   17c62:	075a      	lsls	r2, r3, #29
   17c64:	d00d      	beq.n	17c82 <bt_conn_send_cb+0x36>
   17c66:	2301      	movs	r3, #1
   17c68:	f04f 0100 	mov.w	r1, #0
   17c6c:	f363 0107 	bfi	r1, r3, #0, #8
   17c70:	4a31      	ldr	r2, [pc, #196]	; (17d38 <bt_conn_send_cb+0xec>)
   17c72:	4b32      	ldr	r3, [pc, #200]	; (17d3c <bt_conn_send_cb+0xf0>)
   17c74:	4832      	ldr	r0, [pc, #200]	; (17d40 <bt_conn_send_cb+0xf4>)
   17c76:	1a9b      	subs	r3, r3, r2
   17c78:	08db      	lsrs	r3, r3, #3
   17c7a:	f363 118f 	bfi	r1, r3, #6, #10
   17c7e:	f010 fe5c 	bl	2893a <log_0>
		net_buf_unref(buf);
   17c82:	4628      	mov	r0, r5
   17c84:	f00d fb22 	bl	252cc <net_buf_unref>
			return -ENOTCONN;
   17c88:	f06f 0038 	mvn.w	r0, #56	; 0x38
   17c8c:	e025      	b.n	17cda <bt_conn_send_cb+0x8e>
	if (cb) {
   17c8e:	2a00      	cmp	r2, #0
   17c90:	d04e      	beq.n	17d30 <bt_conn_send_cb+0xe4>
	return z_impl_k_current_get();
   17c92:	f00f fa33 	bl	270fc <z_impl_k_current_get>
	if (k_current_get() == &k_sys_work_q.thread) {
   17c96:	4b2b      	ldr	r3, [pc, #172]	; (17d44 <bt_conn_send_cb+0xf8>)
   17c98:	4283      	cmp	r3, r0
	return z_impl_k_queue_get(queue, timeout);
   17c9a:	482b      	ldr	r0, [pc, #172]	; (17d48 <bt_conn_send_cb+0xfc>)
   17c9c:	bf0c      	ite	eq
   17c9e:	2100      	moveq	r1, #0
   17ca0:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   17ca4:	f015 fa56 	bl	2d154 <z_impl_k_queue_get>
   17ca8:	4604      	mov	r4, r0
		if (!tx) {
   17caa:	b9c0      	cbnz	r0, 17cde <bt_conn_send_cb+0x92>
			BT_ERR("Unable to allocate TX context");
   17cac:	4b21      	ldr	r3, [pc, #132]	; (17d34 <bt_conn_send_cb+0xe8>)
   17cae:	681b      	ldr	r3, [r3, #0]
   17cb0:	075b      	lsls	r3, r3, #29
   17cb2:	d00d      	beq.n	17cd0 <bt_conn_send_cb+0x84>
   17cb4:	2301      	movs	r3, #1
   17cb6:	f04f 0100 	mov.w	r1, #0
   17cba:	f363 0107 	bfi	r1, r3, #0, #8
   17cbe:	4a1e      	ldr	r2, [pc, #120]	; (17d38 <bt_conn_send_cb+0xec>)
   17cc0:	4b1e      	ldr	r3, [pc, #120]	; (17d3c <bt_conn_send_cb+0xf0>)
   17cc2:	4822      	ldr	r0, [pc, #136]	; (17d4c <bt_conn_send_cb+0x100>)
   17cc4:	1a9b      	subs	r3, r3, r2
   17cc6:	08db      	lsrs	r3, r3, #3
   17cc8:	f363 118f 	bfi	r1, r3, #6, #10
   17ccc:	f010 fe35 	bl	2893a <log_0>
			net_buf_unref(buf);
   17cd0:	4628      	mov	r0, r5
   17cd2:	f00d fafb 	bl	252cc <net_buf_unref>
			return -ENOBUFS;
   17cd6:	f06f 0036 	mvn.w	r0, #54	; 0x36
}
   17cda:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (conn->state != BT_CONN_CONNECTED) {
   17cde:	7ab3      	ldrb	r3, [r6, #10]
   17ce0:	2b04      	cmp	r3, #4
   17ce2:	d019      	beq.n	17d18 <bt_conn_send_cb+0xcc>
			BT_WARN("Disconnected while allocating context");
   17ce4:	4b13      	ldr	r3, [pc, #76]	; (17d34 <bt_conn_send_cb+0xe8>)
   17ce6:	681b      	ldr	r3, [r3, #0]
   17ce8:	f013 0f06 	tst.w	r3, #6
   17cec:	d00d      	beq.n	17d0a <bt_conn_send_cb+0xbe>
   17cee:	2302      	movs	r3, #2
   17cf0:	f04f 0100 	mov.w	r1, #0
   17cf4:	f363 0107 	bfi	r1, r3, #0, #8
   17cf8:	4a0f      	ldr	r2, [pc, #60]	; (17d38 <bt_conn_send_cb+0xec>)
   17cfa:	4b10      	ldr	r3, [pc, #64]	; (17d3c <bt_conn_send_cb+0xf0>)
   17cfc:	4814      	ldr	r0, [pc, #80]	; (17d50 <bt_conn_send_cb+0x104>)
   17cfe:	1a9b      	subs	r3, r3, r2
   17d00:	08db      	lsrs	r3, r3, #3
   17d02:	f363 118f 	bfi	r1, r3, #6, #10
   17d06:	f010 fe18 	bl	2893a <log_0>
			net_buf_unref(buf);
   17d0a:	4628      	mov	r0, r5
   17d0c:	f00d fade 	bl	252cc <net_buf_unref>
			tx_free(tx);
   17d10:	4620      	mov	r0, r4
   17d12:	f7ff fd8f 	bl	17834 <tx_free>
   17d16:	e7b7      	b.n	17c88 <bt_conn_send_cb+0x3c>
		tx->pending_no_cb = 0U;
   17d18:	2300      	movs	r3, #0
		tx->user_data = user_data;
   17d1a:	e9c0 7801 	strd	r7, r8, [r0, #4]
		tx->pending_no_cb = 0U;
   17d1e:	60c3      	str	r3, [r0, #12]
		tx_data(buf)->tx = tx;
   17d20:	6168      	str	r0, [r5, #20]
	net_buf_put(&conn->tx_queue, buf);
   17d22:	f106 0034 	add.w	r0, r6, #52	; 0x34
   17d26:	4629      	mov	r1, r5
   17d28:	f014 ff19 	bl	2cb5e <net_buf_put>
	return 0;
   17d2c:	2000      	movs	r0, #0
   17d2e:	e7d4      	b.n	17cda <bt_conn_send_cb+0x8e>
		tx_data(buf)->tx = NULL;
   17d30:	616a      	str	r2, [r5, #20]
   17d32:	e7f6      	b.n	17d22 <bt_conn_send_cb+0xd6>
   17d34:	2000ffa0 	.word	0x2000ffa0
   17d38:	0002db28 	.word	0x0002db28
   17d3c:	0002db38 	.word	0x0002db38
   17d40:	00030f07 	.word	0x00030f07
   17d44:	20003b6c 	.word	0x20003b6c
   17d48:	200100e8 	.word	0x200100e8
   17d4c:	00030f16 	.word	0x00030f16
   17d50:	00030f34 	.word	0x00030f34

00017d54 <bt_conn_prepare_events>:

int bt_conn_prepare_events(struct k_poll_event events[])
{
   17d54:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	int i, ev_count = 0;

	BT_DBG("");

	conn_change.signaled = 0U;
   17d58:	4b20      	ldr	r3, [pc, #128]	; (17ddc <bt_conn_prepare_events+0x88>)
   17d5a:	4d21      	ldr	r5, [pc, #132]	; (17de0 <bt_conn_prepare_events+0x8c>)
   17d5c:	2400      	movs	r4, #0
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
   17d5e:	4622      	mov	r2, r4
   17d60:	2101      	movs	r1, #1
{
   17d62:	4680      	mov	r8, r0
	conn_change.signaled = 0U;
   17d64:	609c      	str	r4, [r3, #8]
	k_poll_event_init(&events[ev_count++], K_POLL_TYPE_SIGNAL,
   17d66:	f00f fd19 	bl	2779c <k_poll_event_init>
   17d6a:	2601      	movs	r6, #1
			continue;
		}

		BT_DBG("Adding conn %p to poll list", conn);

		k_poll_event_init(&events[ev_count],
   17d6c:	f04f 0914 	mov.w	r9, #20
			conn_cleanup(conn);
   17d70:	f1a5 0a4c 	sub.w	sl, r5, #76	; 0x4c
		if (!atomic_get(&conn->ref)) {
   17d74:	4628      	mov	r0, r5
   17d76:	f012 fdce 	bl	2a916 <atomic_get>
   17d7a:	b1b8      	cbz	r0, 17dac <bt_conn_prepare_events+0x58>
		if (conn->state == BT_CONN_DISCONNECTED &&
   17d7c:	f815 3c42 	ldrb.w	r3, [r5, #-66]
   17d80:	b9e3      	cbnz	r3, 17dbc <bt_conn_prepare_events+0x68>
   17d82:	f3bf 8f5b 	dmb	ish
   17d86:	f1a5 0348 	sub.w	r3, r5, #72	; 0x48
   17d8a:	e853 2f00 	ldrex	r2, [r3]
   17d8e:	f022 0140 	bic.w	r1, r2, #64	; 0x40
   17d92:	e843 1000 	strex	r0, r1, [r3]
   17d96:	2800      	cmp	r0, #0
   17d98:	d1f7      	bne.n	17d8a <bt_conn_prepare_events+0x36>
   17d9a:	f3bf 8f5b 	dmb	ish
   17d9e:	0653      	lsls	r3, r2, #25
   17da0:	d50c      	bpl.n	17dbc <bt_conn_prepare_events+0x68>
			conn_cleanup(conn);
   17da2:	20a0      	movs	r0, #160	; 0xa0
   17da4:	fb00 a004 	mla	r0, r0, r4, sl
   17da8:	f7ff fe04 	bl	179b4 <conn_cleanup>
	for (i = 0; i < ARRAY_SIZE(conns); i++) {
   17dac:	3401      	adds	r4, #1
   17dae:	2c05      	cmp	r4, #5
   17db0:	f105 05a0 	add.w	r5, r5, #160	; 0xa0
   17db4:	d1de      	bne.n	17d74 <bt_conn_prepare_events+0x20>
				  &conn->tx_queue);
		events[ev_count++].tag = BT_EVENT_CONN_TX_QUEUE;
	}

	return ev_count;
}
   17db6:	4630      	mov	r0, r6
   17db8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (conn->state != BT_CONN_CONNECTED) {
   17dbc:	f815 1c42 	ldrb.w	r1, [r5, #-66]
   17dc0:	2904      	cmp	r1, #4
   17dc2:	d1f3      	bne.n	17dac <bt_conn_prepare_events+0x58>
		k_poll_event_init(&events[ev_count],
   17dc4:	fb09 8706 	mla	r7, r9, r6, r8
   17dc8:	f1a5 0318 	sub.w	r3, r5, #24
   17dcc:	2200      	movs	r2, #0
   17dce:	4638      	mov	r0, r7
   17dd0:	f00f fce4 	bl	2779c <k_poll_event_init>
		events[ev_count++].tag = BT_EVENT_CONN_TX_QUEUE;
   17dd4:	2301      	movs	r3, #1
   17dd6:	3601      	adds	r6, #1
   17dd8:	733b      	strb	r3, [r7, #12]
   17dda:	e7e7      	b.n	17dac <bt_conn_prepare_events+0x58>
   17ddc:	2000f9dc 	.word	0x2000f9dc
   17de0:	20000bd8 	.word	0x20000bd8

00017de4 <bt_conn_add_le>:
		net_buf_unref(buf);
	}
}

struct bt_conn *bt_conn_add_le(u8_t id, const bt_addr_le_t *peer)
{
   17de4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   17de8:	4d20      	ldr	r5, [pc, #128]	; (17e6c <bt_conn_add_le+0x88>)
   17dea:	4682      	mov	sl, r0
   17dec:	4689      	mov	r9, r1
	for (i = 0; i < ARRAY_SIZE(conns); i++) {
   17dee:	2300      	movs	r3, #0
   17df0:	22a0      	movs	r2, #160	; 0xa0
		if (!atomic_get(&conns[i].ref)) {
   17df2:	4628      	mov	r0, r5
   17df4:	fb02 f603 	mul.w	r6, r2, r3
   17df8:	f012 fd8d 	bl	2a916 <atomic_get>
   17dfc:	4607      	mov	r7, r0
   17dfe:	bb68      	cbnz	r0, 17e5c <bt_conn_add_le+0x78>
			conn = &conns[i];
   17e00:	f8df 8078 	ldr.w	r8, [pc, #120]	; 17e7c <bt_conn_add_le+0x98>
   17e04:	eb08 0406 	add.w	r4, r8, r6
	(void)memset(conn, 0, sizeof(*conn));
   17e08:	4601      	mov	r1, r0
   17e0a:	22a0      	movs	r2, #160	; 0xa0
   17e0c:	4620      	mov	r0, r4
   17e0e:	f012 fb48 	bl	2a4a2 <memset>
	k_delayed_work_init(&conn->update_work, conn_update_timeout);
   17e12:	f106 0050 	add.w	r0, r6, #80	; 0x50
   17e16:	4916      	ldr	r1, [pc, #88]	; (17e70 <bt_conn_add_le+0x8c>)
   17e18:	4440      	add	r0, r8
   17e1a:	f015 fb9a 	bl	2d552 <k_delayed_work_init>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   17e1e:	4b15      	ldr	r3, [pc, #84]	; (17e74 <bt_conn_add_le+0x90>)
   17e20:	62a7      	str	r7, [r4, #40]	; 0x28
   17e22:	e9c4 370b 	strd	r3, r7, [r4, #44]	; 0x2c
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   17e26:	2701      	movs	r7, #1
   17e28:	f3bf 8f5b 	dmb	ish
   17e2c:	e855 3f00 	ldrex	r3, [r5]
   17e30:	e845 7200 	strex	r2, r7, [r5]
   17e34:	2a00      	cmp	r2, #0
   17e36:	d1f9      	bne.n	17e2c <bt_conn_add_le+0x48>
   17e38:	f3bf 8f5b 	dmb	ish
	if (!conn) {
		return NULL;
	}

	conn->id = id;
	bt_addr_le_copy(&conn->le.dst, peer);
   17e3c:	f106 0070 	add.w	r0, r6, #112	; 0x70
	conn->id = id;
   17e40:	f884 a008 	strb.w	sl, [r4, #8]
}

static inline void bt_addr_le_copy(bt_addr_le_t *dst, const bt_addr_le_t *src)
{
	memcpy(dst, src, sizeof(*dst));
   17e44:	2207      	movs	r2, #7
   17e46:	4649      	mov	r1, r9
   17e48:	4440      	add	r0, r8
   17e4a:	f012 fb00 	bl	2a44e <memcpy>
#if defined(CONFIG_BT_SMP)
	conn->sec_level = BT_SECURITY_L1;
	conn->required_sec_level = BT_SECURITY_L1;
#endif /* CONFIG_BT_SMP */
	conn->type = BT_CONN_TYPE_LE;
	conn->le.interval_min = BT_GAP_INIT_CONN_INT_MIN;
   17e4e:	4b0a      	ldr	r3, [pc, #40]	; (17e78 <bt_conn_add_le+0x94>)
	conn->type = BT_CONN_TYPE_LE;
   17e50:	70a7      	strb	r7, [r4, #2]
	conn->le.interval_min = BT_GAP_INIT_CONN_INT_MIN;
   17e52:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
	conn->le.interval_max = BT_GAP_INIT_CONN_INT_MAX;

	return conn;
}
   17e56:	4620      	mov	r0, r4
   17e58:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	for (i = 0; i < ARRAY_SIZE(conns); i++) {
   17e5c:	3301      	adds	r3, #1
   17e5e:	2b05      	cmp	r3, #5
   17e60:	f105 05a0 	add.w	r5, r5, #160	; 0xa0
   17e64:	d1c5      	bne.n	17df2 <bt_conn_add_le+0xe>
		return NULL;
   17e66:	2400      	movs	r4, #0
   17e68:	e7f5      	b.n	17e56 <bt_conn_add_le+0x72>
   17e6a:	bf00      	nop
   17e6c:	20000bd8 	.word	0x20000bd8
   17e70:	000183d5 	.word	0x000183d5
   17e74:	0002a9c1 	.word	0x0002a9c1
   17e78:	00280018 	.word	0x00280018
   17e7c:	20000b8c 	.word	0x20000b8c

00017e80 <bt_conn_set_state>:
		k_sem_give(bt_conn_get_pkts(conn));
	}
}

void bt_conn_set_state(struct bt_conn *conn, bt_conn_state_t state)
{
   17e80:	b570      	push	{r4, r5, r6, lr}
	bt_conn_state_t old_state;

	BT_DBG("%s -> %s", state2str(conn->state), state2str(state));

	if (conn->state == state) {
   17e82:	7a85      	ldrb	r5, [r0, #10]
   17e84:	42a9      	cmp	r1, r5
{
   17e86:	4604      	mov	r4, r0
   17e88:	460e      	mov	r6, r1
	if (conn->state == state) {
   17e8a:	d115      	bne.n	17eb8 <bt_conn_set_state+0x38>
		BT_WARN("no transition");
   17e8c:	4b69      	ldr	r3, [pc, #420]	; (18034 <bt_conn_set_state+0x1b4>)
   17e8e:	681b      	ldr	r3, [r3, #0]
   17e90:	f013 0f06 	tst.w	r3, #6
   17e94:	f000 80aa 	beq.w	17fec <bt_conn_set_state+0x16c>
   17e98:	2302      	movs	r3, #2
   17e9a:	f04f 0100 	mov.w	r1, #0
   17e9e:	f363 0107 	bfi	r1, r3, #0, #8
   17ea2:	4a65      	ldr	r2, [pc, #404]	; (18038 <bt_conn_set_state+0x1b8>)
   17ea4:	4b65      	ldr	r3, [pc, #404]	; (1803c <bt_conn_set_state+0x1bc>)
   17ea6:	4866      	ldr	r0, [pc, #408]	; (18040 <bt_conn_set_state+0x1c0>)
   17ea8:	1a9b      	subs	r3, r3, r2
   17eaa:	08db      	lsrs	r3, r3, #3
   17eac:	f363 118f 	bfi	r1, r3, #6, #10
	default:
		BT_WARN("no valid (%u) state was set", state);

		break;
	}
}
   17eb0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_WARN("no transition");
   17eb4:	f010 bd41 	b.w	2893a <log_0>
	conn->state = state;
   17eb8:	72a1      	strb	r1, [r4, #10]
	switch (old_state) {
   17eba:	b155      	cbz	r5, 17ed2 <bt_conn_set_state+0x52>
   17ebc:	2d03      	cmp	r5, #3
   17ebe:	d00c      	beq.n	17eda <bt_conn_set_state+0x5a>
	switch (conn->state) {
   17ec0:	7aa3      	ldrb	r3, [r4, #10]
   17ec2:	2b05      	cmp	r3, #5
   17ec4:	f200 809f 	bhi.w	18006 <bt_conn_set_state+0x186>
   17ec8:	e8df f003 	tbb	[pc, r3]
   17ecc:	91909024 	.word	0x91909024
   17ed0:	900e      	.short	0x900e
	bt_conn_foreach(BT_CONN_TYPE_ALL, disconnect_all, &id);
}

struct bt_conn *bt_conn_ref(struct bt_conn *conn)
{
	atomic_inc(&conn->ref);
   17ed2:	304c      	adds	r0, #76	; 0x4c
   17ed4:	f012 fd44 	bl	2a960 <atomic_inc>

	BT_DBG("handle %u ref %u", conn->handle, atomic_get(&conn->ref));

	return conn;
   17ed8:	e7f2      	b.n	17ec0 <bt_conn_set_state+0x40>
		if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   17eda:	7883      	ldrb	r3, [r0, #2]
   17edc:	2b01      	cmp	r3, #1
   17ede:	d1ef      	bne.n	17ec0 <bt_conn_set_state+0x40>
			k_delayed_work_cancel(&conn->update_work);
   17ee0:	3050      	adds	r0, #80	; 0x50
   17ee2:	f015 fb3e 	bl	2d562 <k_delayed_work_cancel>
   17ee6:	e7eb      	b.n	17ec0 <bt_conn_set_state+0x40>
		if (conn->type == BT_CONN_TYPE_SCO) {
   17ee8:	78a3      	ldrb	r3, [r4, #2]
   17eea:	2b04      	cmp	r3, #4
   17eec:	d07e      	beq.n	17fec <bt_conn_set_state+0x16c>
	z_impl_k_queue_init(queue);
   17eee:	f104 0034 	add.w	r0, r4, #52	; 0x34
   17ef2:	f015 f8fe 	bl	2d0f2 <z_impl_k_queue_init>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&signal, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(signal, result);
   17ef6:	2100      	movs	r1, #0
   17ef8:	4852      	ldr	r0, [pc, #328]	; (18044 <bt_conn_set_state+0x1c4>)
   17efa:	f00f fcb7 	bl	2786c <z_impl_k_poll_signal_raise>
	list->head = NULL;
   17efe:	2300      	movs	r3, #0
		bt_l2cap_connected(conn);
   17f00:	4620      	mov	r0, r4
	list->tail = NULL;
   17f02:	e9c4 3311 	strd	r3, r3, [r4, #68]	; 0x44
   17f06:	f000 fc57 	bl	187b8 <bt_l2cap_connected>
		notify_connected(conn);
   17f0a:	4620      	mov	r0, r4
}
   17f0c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		notify_connected(conn);
   17f10:	f7ff bc9a 	b.w	17848 <notify_connected>
		if (conn->type == BT_CONN_TYPE_SCO) {
   17f14:	78a3      	ldrb	r3, [r4, #2]
   17f16:	2b04      	cmp	r3, #4
   17f18:	d105      	bne.n	17f26 <bt_conn_set_state+0xa6>
}

void bt_conn_unref(struct bt_conn *conn)
{
	atomic_dec(&conn->ref);
   17f1a:	f104 004c 	add.w	r0, r4, #76	; 0x4c
}
   17f1e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	atomic_dec(&conn->ref);
   17f22:	f012 bd10 	b.w	2a946 <atomic_dec>
		if (old_state == BT_CONN_CONNECTED ||
   17f26:	1f2b      	subs	r3, r5, #4
   17f28:	2b01      	cmp	r3, #1
   17f2a:	d851      	bhi.n	17fd0 <bt_conn_set_state+0x150>
	z_impl_k_sem_give(sem);
   17f2c:	4d46      	ldr	r5, [pc, #280]	; (18048 <bt_conn_set_state+0x1c8>)
		tx->pending_no_cb = 0U;
   17f2e:	2600      	movs	r6, #0
	__asm__ volatile(
   17f30:	f04f 0320 	mov.w	r3, #32
   17f34:	f3ef 8211 	mrs	r2, BASEPRI
   17f38:	f383 8811 	msr	BASEPRI, r3
   17f3c:	f3bf 8f6f 	isb	sy
		if (conn->pending_no_cb) {
   17f40:	69e3      	ldr	r3, [r4, #28]
   17f42:	b14b      	cbz	r3, 17f58 <bt_conn_set_state+0xd8>
			conn->pending_no_cb--;
   17f44:	3b01      	subs	r3, #1
   17f46:	61e3      	str	r3, [r4, #28]
	__asm__ volatile(
   17f48:	f382 8811 	msr	BASEPRI, r2
   17f4c:	f3bf 8f6f 	isb	sy
   17f50:	4628      	mov	r0, r5
   17f52:	f00f f8d9 	bl	27108 <z_impl_k_sem_give>
   17f56:	e7eb      	b.n	17f30 <bt_conn_set_state+0xb0>
Z_GENLIST_IS_EMPTY(slist)
   17f58:	6960      	ldr	r0, [r4, #20]
Z_GENLIST_GET(slist, snode)
   17f5a:	b128      	cbz	r0, 17f68 <bt_conn_set_state+0xe8>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   17f5c:	69a1      	ldr	r1, [r4, #24]
   17f5e:	6803      	ldr	r3, [r0, #0]
	list->head = node;
   17f60:	6163      	str	r3, [r4, #20]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   17f62:	4288      	cmp	r0, r1
	list->tail = node;
   17f64:	bf08      	it	eq
   17f66:	61a3      	streq	r3, [r4, #24]
   17f68:	f382 8811 	msr	BASEPRI, r2
   17f6c:	f3bf 8f6f 	isb	sy
		if (!node) {
   17f70:	b188      	cbz	r0, 17f96 <bt_conn_set_state+0x116>
	__asm__ volatile(
   17f72:	f04f 0220 	mov.w	r2, #32
   17f76:	f3ef 8311 	mrs	r3, BASEPRI
   17f7a:	f382 8811 	msr	BASEPRI, r2
   17f7e:	f3bf 8f6f 	isb	sy
		conn->pending_no_cb = tx->pending_no_cb;
   17f82:	68c2      	ldr	r2, [r0, #12]
   17f84:	61e2      	str	r2, [r4, #28]
		tx->pending_no_cb = 0U;
   17f86:	60c6      	str	r6, [r0, #12]
	__asm__ volatile(
   17f88:	f383 8811 	msr	BASEPRI, r3
   17f8c:	f3bf 8f6f 	isb	sy
		tx_free(tx);
   17f90:	f7ff fc50 	bl	17834 <tx_free>
   17f94:	e7dc      	b.n	17f50 <bt_conn_set_state+0xd0>
			tx_notify(conn);
   17f96:	4620      	mov	r0, r4
   17f98:	f012 fcef 	bl	2a97a <tx_notify>
			if (conn->type == BT_CONN_TYPE_LE) {
   17f9c:	78a3      	ldrb	r3, [r4, #2]
   17f9e:	2b01      	cmp	r3, #1
   17fa0:	d103      	bne.n	17faa <bt_conn_set_state+0x12a>
				k_delayed_work_cancel(&conn->update_work);
   17fa2:	f104 0050 	add.w	r0, r4, #80	; 0x50
   17fa6:	f015 fadc 	bl	2d562 <k_delayed_work_cancel>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   17faa:	f3bf 8f5b 	dmb	ish
   17fae:	3404      	adds	r4, #4
   17fb0:	e854 3f00 	ldrex	r3, [r4]
   17fb4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   17fb8:	e844 3200 	strex	r2, r3, [r4]
   17fbc:	2a00      	cmp	r2, #0
   17fbe:	d1f7      	bne.n	17fb0 <bt_conn_set_state+0x130>
   17fc0:	f3bf 8f5b 	dmb	ish
	return z_impl_k_poll_signal_raise(signal, result);
   17fc4:	2100      	movs	r1, #0
   17fc6:	481f      	ldr	r0, [pc, #124]	; (18044 <bt_conn_set_state+0x1c4>)
}
   17fc8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   17fcc:	f00f bc4e 	b.w	2786c <z_impl_k_poll_signal_raise>
		} else if (old_state == BT_CONN_CONNECT) {
   17fd0:	2d03      	cmp	r5, #3
   17fd2:	d103      	bne.n	17fdc <bt_conn_set_state+0x15c>
			notify_connected(conn);
   17fd4:	4620      	mov	r0, r4
   17fd6:	f7ff fc37 	bl	17848 <notify_connected>
   17fda:	e79e      	b.n	17f1a <bt_conn_set_state+0x9a>
		} else if (old_state == BT_CONN_CONNECT_SCAN) {
   17fdc:	2d01      	cmp	r5, #1
   17fde:	d103      	bne.n	17fe8 <bt_conn_set_state+0x168>
			if (conn->err) {
   17fe0:	7a63      	ldrb	r3, [r4, #9]
   17fe2:	2b00      	cmp	r3, #0
   17fe4:	d099      	beq.n	17f1a <bt_conn_set_state+0x9a>
   17fe6:	e7f5      	b.n	17fd4 <bt_conn_set_state+0x154>
		} else if (old_state == BT_CONN_CONNECT_DIR_ADV) {
   17fe8:	2d02      	cmp	r5, #2
   17fea:	d0f9      	beq.n	17fe0 <bt_conn_set_state+0x160>
}
   17fec:	bd70      	pop	{r4, r5, r6, pc}
		if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   17fee:	78a3      	ldrb	r3, [r4, #2]
   17ff0:	2b01      	cmp	r3, #1
   17ff2:	d1fb      	bne.n	17fec <bt_conn_set_state+0x16c>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   17ff4:	f104 0150 	add.w	r1, r4, #80	; 0x50
   17ff8:	f640 32b8 	movw	r2, #3000	; 0xbb8
   17ffc:	4813      	ldr	r0, [pc, #76]	; (1804c <bt_conn_set_state+0x1cc>)
}
   17ffe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   18002:	f00f ba1b 	b.w	2743c <k_delayed_work_submit_to_queue>
		BT_WARN("no valid (%u) state was set", state);
   18006:	4b0b      	ldr	r3, [pc, #44]	; (18034 <bt_conn_set_state+0x1b4>)
   18008:	681b      	ldr	r3, [r3, #0]
   1800a:	f013 0f06 	tst.w	r3, #6
   1800e:	d0ed      	beq.n	17fec <bt_conn_set_state+0x16c>
   18010:	2302      	movs	r3, #2
   18012:	f04f 0200 	mov.w	r2, #0
   18016:	f363 0207 	bfi	r2, r3, #0, #8
   1801a:	4907      	ldr	r1, [pc, #28]	; (18038 <bt_conn_set_state+0x1b8>)
   1801c:	4b07      	ldr	r3, [pc, #28]	; (1803c <bt_conn_set_state+0x1bc>)
   1801e:	480c      	ldr	r0, [pc, #48]	; (18050 <bt_conn_set_state+0x1d0>)
   18020:	1a5b      	subs	r3, r3, r1
   18022:	08db      	lsrs	r3, r3, #3
   18024:	4631      	mov	r1, r6
   18026:	f363 128f 	bfi	r2, r3, #6, #10
}
   1802a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		BT_WARN("no valid (%u) state was set", state);
   1802e:	f010 bc91 	b.w	28954 <log_1>
   18032:	bf00      	nop
   18034:	2000ffa0 	.word	0x2000ffa0
   18038:	0002db28 	.word	0x0002db28
   1803c:	0002db38 	.word	0x0002db38
   18040:	00030f5a 	.word	0x00030f5a
   18044:	2000f9dc 	.word	0x2000f9dc
   18048:	2000f7ac 	.word	0x2000f7ac
   1804c:	20003b5c 	.word	0x20003b5c
   18050:	00030f68 	.word	0x00030f68

00018054 <bt_conn_lookup_handle>:
	for (i = 0; i < ARRAY_SIZE(conns); i++) {
   18054:	4b0f      	ldr	r3, [pc, #60]	; (18094 <bt_conn_lookup_handle+0x40>)
{
   18056:	b510      	push	{r4, lr}
   18058:	2200      	movs	r2, #0
   1805a:	4604      	mov	r4, r0
		if (!atomic_get(&conns[i].ref)) {
   1805c:	4618      	mov	r0, r3
   1805e:	f012 fc5a 	bl	2a916 <atomic_get>
   18062:	b178      	cbz	r0, 18084 <bt_conn_lookup_handle+0x30>
		if (conns[i].state != BT_CONN_CONNECTED &&
   18064:	f813 1c42 	ldrb.w	r1, [r3, #-66]
   18068:	3904      	subs	r1, #4
   1806a:	2901      	cmp	r1, #1
   1806c:	d80a      	bhi.n	18084 <bt_conn_lookup_handle+0x30>
		if (conns[i].handle == handle) {
   1806e:	f833 1c4c 	ldrh.w	r1, [r3, #-76]
   18072:	42a1      	cmp	r1, r4
   18074:	d106      	bne.n	18084 <bt_conn_lookup_handle+0x30>
			return bt_conn_ref(&conns[i]);
   18076:	4c08      	ldr	r4, [pc, #32]	; (18098 <bt_conn_lookup_handle+0x44>)
	atomic_inc(&conn->ref);
   18078:	4618      	mov	r0, r3
			return bt_conn_ref(&conns[i]);
   1807a:	4414      	add	r4, r2
	atomic_inc(&conn->ref);
   1807c:	f012 fc70 	bl	2a960 <atomic_inc>
}
   18080:	4620      	mov	r0, r4
   18082:	bd10      	pop	{r4, pc}
   18084:	32a0      	adds	r2, #160	; 0xa0
	for (i = 0; i < ARRAY_SIZE(conns); i++) {
   18086:	f5b2 7f48 	cmp.w	r2, #800	; 0x320
   1808a:	f103 03a0 	add.w	r3, r3, #160	; 0xa0
   1808e:	d1e5      	bne.n	1805c <bt_conn_lookup_handle+0x8>
	return NULL;
   18090:	2400      	movs	r4, #0
   18092:	e7f5      	b.n	18080 <bt_conn_lookup_handle+0x2c>
   18094:	20000bd8 	.word	0x20000bd8
   18098:	20000b8c 	.word	0x20000b8c

0001809c <bt_conn_lookup_addr_le>:
{
   1809c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   180a0:	4c11      	ldr	r4, [pc, #68]	; (180e8 <bt_conn_lookup_addr_le+0x4c>)
   180a2:	4607      	mov	r7, r0
   180a4:	4688      	mov	r8, r1
	for (i = 0; i < ARRAY_SIZE(conns); i++) {
   180a6:	2600      	movs	r6, #0
		if (!atomic_get(&conns[i].ref)) {
   180a8:	4620      	mov	r0, r4
   180aa:	f012 fc34 	bl	2a916 <atomic_get>
   180ae:	b1a0      	cbz	r0, 180da <bt_conn_lookup_addr_le+0x3e>
		if (conns[i].type != BT_CONN_TYPE_LE) {
   180b0:	f814 3c4a 	ldrb.w	r3, [r4, #-74]
   180b4:	2b01      	cmp	r3, #1
   180b6:	d110      	bne.n	180da <bt_conn_lookup_addr_le+0x3e>
		if (conns[i].id == id &&
   180b8:	f814 3c44 	ldrb.w	r3, [r4, #-68]
   180bc:	42bb      	cmp	r3, r7
   180be:	d10c      	bne.n	180da <bt_conn_lookup_addr_le+0x3e>
   180c0:	f1a4 054c 	sub.w	r5, r4, #76	; 0x4c
		    !bt_conn_addr_le_cmp(&conns[i], peer)) {
   180c4:	4641      	mov	r1, r8
   180c6:	4628      	mov	r0, r5
   180c8:	f012 fc7f 	bl	2a9ca <bt_conn_addr_le_cmp>
		if (conns[i].id == id &&
   180cc:	b928      	cbnz	r0, 180da <bt_conn_lookup_addr_le+0x3e>
	atomic_inc(&conn->ref);
   180ce:	4620      	mov	r0, r4
   180d0:	f012 fc46 	bl	2a960 <atomic_inc>
}
   180d4:	4628      	mov	r0, r5
   180d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (i = 0; i < ARRAY_SIZE(conns); i++) {
   180da:	3601      	adds	r6, #1
   180dc:	2e05      	cmp	r6, #5
   180de:	f104 04a0 	add.w	r4, r4, #160	; 0xa0
   180e2:	d1e1      	bne.n	180a8 <bt_conn_lookup_addr_le+0xc>
	return NULL;
   180e4:	2500      	movs	r5, #0
   180e6:	e7f5      	b.n	180d4 <bt_conn_lookup_addr_le+0x38>
   180e8:	20000bd8 	.word	0x20000bd8

000180ec <bt_conn_lookup_state_le>:
{
   180ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   180ee:	4c13      	ldr	r4, [pc, #76]	; (1813c <bt_conn_lookup_state_le+0x50>)
   180f0:	4605      	mov	r5, r0
   180f2:	460f      	mov	r7, r1
   180f4:	2600      	movs	r6, #0
		if (!atomic_get(&conns[i].ref)) {
   180f6:	4620      	mov	r0, r4
   180f8:	f012 fc0d 	bl	2a916 <atomic_get>
   180fc:	b1b0      	cbz	r0, 1812c <bt_conn_lookup_state_le+0x40>
		if (conns[i].type != BT_CONN_TYPE_LE) {
   180fe:	f814 3c4a 	ldrb.w	r3, [r4, #-74]
   18102:	2b01      	cmp	r3, #1
   18104:	d112      	bne.n	1812c <bt_conn_lookup_state_le+0x40>
		if (peer && bt_conn_addr_le_cmp(&conns[i], peer)) {
   18106:	b955      	cbnz	r5, 1811e <bt_conn_lookup_state_le+0x32>
		if (conns[i].state == state) {
   18108:	f814 3c42 	ldrb.w	r3, [r4, #-66]
   1810c:	42bb      	cmp	r3, r7
   1810e:	d10d      	bne.n	1812c <bt_conn_lookup_state_le+0x40>
			return bt_conn_ref(&conns[i]);
   18110:	4d0b      	ldr	r5, [pc, #44]	; (18140 <bt_conn_lookup_state_le+0x54>)
	atomic_inc(&conn->ref);
   18112:	4620      	mov	r0, r4
			return bt_conn_ref(&conns[i]);
   18114:	4435      	add	r5, r6
	atomic_inc(&conn->ref);
   18116:	f012 fc23 	bl	2a960 <atomic_inc>
}
   1811a:	4628      	mov	r0, r5
   1811c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (peer && bt_conn_addr_le_cmp(&conns[i], peer)) {
   1811e:	4629      	mov	r1, r5
   18120:	f1a4 004c 	sub.w	r0, r4, #76	; 0x4c
   18124:	f012 fc51 	bl	2a9ca <bt_conn_addr_le_cmp>
   18128:	2800      	cmp	r0, #0
   1812a:	d0ed      	beq.n	18108 <bt_conn_lookup_state_le+0x1c>
   1812c:	36a0      	adds	r6, #160	; 0xa0
	for (i = 0; i < ARRAY_SIZE(conns); i++) {
   1812e:	f5b6 7f48 	cmp.w	r6, #800	; 0x320
   18132:	f104 04a0 	add.w	r4, r4, #160	; 0xa0
   18136:	d1de      	bne.n	180f6 <bt_conn_lookup_state_le+0xa>
	return NULL;
   18138:	2500      	movs	r5, #0
   1813a:	e7ee      	b.n	1811a <bt_conn_lookup_state_le+0x2e>
   1813c:	20000bd8 	.word	0x20000bd8
   18140:	20000b8c 	.word	0x20000b8c

00018144 <bt_conn_get_info>:
{
	return &conn->le.dst;
}

int bt_conn_get_info(const struct bt_conn *conn, struct bt_conn_info *info)
{
   18144:	b510      	push	{r4, lr}
	info->type = conn->type;
   18146:	7882      	ldrb	r2, [r0, #2]
   18148:	700a      	strb	r2, [r1, #0]
	info->role = conn->role;
   1814a:	78c4      	ldrb	r4, [r0, #3]
   1814c:	704c      	strb	r4, [r1, #1]
	info->id = conn->id;
   1814e:	7a03      	ldrb	r3, [r0, #8]
   18150:	708b      	strb	r3, [r1, #2]

	switch (conn->type) {
   18152:	2a01      	cmp	r2, #1
   18154:	d11c      	bne.n	18190 <bt_conn_get_info+0x4c>
	case BT_CONN_TYPE_LE:
		info->le.dst = &conn->le.dst;
   18156:	f100 0270 	add.w	r2, r0, #112	; 0x70
   1815a:	608a      	str	r2, [r1, #8]
		info->le.src = &bt_dev.id_addr[conn->id];
   1815c:	4a0e      	ldr	r2, [pc, #56]	; (18198 <bt_conn_get_info+0x54>)
   1815e:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   18162:	4413      	add	r3, r2
   18164:	604b      	str	r3, [r1, #4]
		if (conn->role == BT_HCI_ROLE_MASTER) {
   18166:	f100 027e 	add.w	r2, r0, #126	; 0x7e
   1816a:	f100 0377 	add.w	r3, r0, #119	; 0x77
   1816e:	b964      	cbnz	r4, 1818a <bt_conn_get_info+0x46>
			info->le.local = &conn->le.init_addr;
			info->le.remote = &conn->le.resp_addr;
   18170:	e9c1 3203 	strd	r3, r2, [r1, #12]
		} else {
			info->le.local = &conn->le.resp_addr;
			info->le.remote = &conn->le.init_addr;
		}
		info->le.interval = conn->le.interval;
   18174:	f8b0 3086 	ldrh.w	r3, [r0, #134]	; 0x86
   18178:	828b      	strh	r3, [r1, #20]
		info->le.latency = conn->le.latency;
   1817a:	f8b0 308c 	ldrh.w	r3, [r0, #140]	; 0x8c
   1817e:	82cb      	strh	r3, [r1, #22]
		info->le.timeout = conn->le.timeout;
   18180:	f8b0 308e 	ldrh.w	r3, [r0, #142]	; 0x8e
   18184:	830b      	strh	r3, [r1, #24]
		return 0;
   18186:	2000      	movs	r0, #0
		return 0;
#endif
	}

	return -EINVAL;
}
   18188:	bd10      	pop	{r4, pc}
			info->le.remote = &conn->le.init_addr;
   1818a:	e9c1 2303 	strd	r2, r3, [r1, #12]
   1818e:	e7f1      	b.n	18174 <bt_conn_get_info+0x30>
	return -EINVAL;
   18190:	f06f 0015 	mvn.w	r0, #21
   18194:	e7f8      	b.n	18188 <bt_conn_get_info+0x44>
   18196:	bf00      	nop
   18198:	2000f720 	.word	0x2000f720

0001819c <bt_conn_create_le>:
}
#endif /* defined(CONFIG_BT_WHITELIST) */

struct bt_conn *bt_conn_create_le(const bt_addr_le_t *peer,
				  const struct bt_le_conn_param *param)
{
   1819c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1819e:	4606      	mov	r6, r0
   181a0:	460d      	mov	r5, r1
	struct bt_conn *conn;
	bt_addr_le_t dst;

	if (!atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   181a2:	483c      	ldr	r0, [pc, #240]	; (18294 <bt_conn_create_le+0xf8>)
   181a4:	2101      	movs	r1, #1
   181a6:	f012 fbbc 	bl	2a922 <atomic_test_bit>
   181aa:	b908      	cbnz	r0, 181b0 <bt_conn_create_le+0x14>
		case BT_CONN_DISCONNECTED:
			BT_WARN("Found valid but disconnected conn object");
			goto start_scan;
		default:
			bt_conn_unref(conn);
			return NULL;
   181ac:	2400      	movs	r4, #0
   181ae:	e024      	b.n	181fa <bt_conn_create_le+0x5e>
	if (!bt_le_conn_params_valid(param)) {
   181b0:	4628      	mov	r0, r5
   181b2:	f012 fb16 	bl	2a7e2 <bt_le_conn_params_valid>
   181b6:	2800      	cmp	r0, #0
   181b8:	d0f8      	beq.n	181ac <bt_conn_create_le+0x10>
	if (atomic_test_bit(bt_dev.flags, BT_DEV_EXPLICIT_SCAN)) {
   181ba:	210b      	movs	r1, #11
   181bc:	4835      	ldr	r0, [pc, #212]	; (18294 <bt_conn_create_le+0xf8>)
   181be:	f012 fbb0 	bl	2a922 <atomic_test_bit>
   181c2:	2800      	cmp	r0, #0
   181c4:	d1f2      	bne.n	181ac <bt_conn_create_le+0x10>
	conn = bt_conn_lookup_addr_le(BT_ID_DEFAULT, peer);
   181c6:	4631      	mov	r1, r6
   181c8:	f7ff ff68 	bl	1809c <bt_conn_lookup_addr_le>
	if (conn) {
   181cc:	4604      	mov	r4, r0
   181ce:	2800      	cmp	r0, #0
   181d0:	d041      	beq.n	18256 <bt_conn_create_le+0xba>
		switch (conn->state) {
   181d2:	7a83      	ldrb	r3, [r0, #10]
   181d4:	2b04      	cmp	r3, #4
   181d6:	d83a      	bhi.n	1824e <bt_conn_create_le+0xb2>
   181d8:	e8df f003 	tbb	[pc, r3]
   181dc:	0f390312 	.word	0x0f390312
   181e0:	0f          	.byte	0x0f
   181e1:	00          	.byte	0x00
	conn->le.interval_min = param->interval_min;
   181e2:	882b      	ldrh	r3, [r5, #0]
   181e4:	f8a0 3088 	strh.w	r3, [r0, #136]	; 0x88
	conn->le.interval_max = param->interval_max;
   181e8:	886b      	ldrh	r3, [r5, #2]
   181ea:	f8a0 308a 	strh.w	r3, [r0, #138]	; 0x8a
	conn->le.latency = param->latency;
   181ee:	88ab      	ldrh	r3, [r5, #4]
   181f0:	f8a0 308c 	strh.w	r3, [r0, #140]	; 0x8c
	conn->le.timeout = param->timeout;
   181f4:	88eb      	ldrh	r3, [r5, #6]
   181f6:	f8a0 308e 	strh.w	r3, [r0, #142]	; 0x8e
	bt_conn_set_state(conn, BT_CONN_CONNECT_SCAN);

	bt_le_scan_update(true);

	return conn;
}
   181fa:	4620      	mov	r0, r4
   181fc:	b002      	add	sp, #8
   181fe:	bd70      	pop	{r4, r5, r6, pc}
			BT_WARN("Found valid but disconnected conn object");
   18200:	4b25      	ldr	r3, [pc, #148]	; (18298 <bt_conn_create_le+0xfc>)
   18202:	681b      	ldr	r3, [r3, #0]
   18204:	f013 0f06 	tst.w	r3, #6
   18208:	d00d      	beq.n	18226 <bt_conn_create_le+0x8a>
   1820a:	2302      	movs	r3, #2
   1820c:	f04f 0100 	mov.w	r1, #0
   18210:	f363 0107 	bfi	r1, r3, #0, #8
   18214:	4a21      	ldr	r2, [pc, #132]	; (1829c <bt_conn_create_le+0x100>)
   18216:	4b22      	ldr	r3, [pc, #136]	; (182a0 <bt_conn_create_le+0x104>)
   18218:	4822      	ldr	r0, [pc, #136]	; (182a4 <bt_conn_create_le+0x108>)
   1821a:	1a9b      	subs	r3, r3, r2
   1821c:	08db      	lsrs	r3, r3, #3
   1821e:	f363 118f 	bfi	r1, r3, #6, #10
   18222:	f010 fb8a 	bl	2893a <log_0>
	conn->le.interval_min = param->interval_min;
   18226:	882b      	ldrh	r3, [r5, #0]
   18228:	f8a4 3088 	strh.w	r3, [r4, #136]	; 0x88
	conn->le.interval_max = param->interval_max;
   1822c:	886b      	ldrh	r3, [r5, #2]
   1822e:	f8a4 308a 	strh.w	r3, [r4, #138]	; 0x8a
	conn->le.latency = param->latency;
   18232:	88ab      	ldrh	r3, [r5, #4]
   18234:	f8a4 308c 	strh.w	r3, [r4, #140]	; 0x8c
	conn->le.timeout = param->timeout;
   18238:	88eb      	ldrh	r3, [r5, #6]
   1823a:	f8a4 308e 	strh.w	r3, [r4, #142]	; 0x8e
	bt_conn_set_state(conn, BT_CONN_CONNECT_SCAN);
   1823e:	4620      	mov	r0, r4
   18240:	2101      	movs	r1, #1
   18242:	f7ff fe1d 	bl	17e80 <bt_conn_set_state>
	bt_le_scan_update(true);
   18246:	2001      	movs	r0, #1
   18248:	f7fd fd80 	bl	15d4c <bt_le_scan_update>
	return conn;
   1824c:	e7d5      	b.n	181fa <bt_conn_create_le+0x5e>
	atomic_dec(&conn->ref);
   1824e:	304c      	adds	r0, #76	; 0x4c
   18250:	f012 fb79 	bl	2a946 <atomic_dec>
   18254:	e7aa      	b.n	181ac <bt_conn_create_le+0x10>
	if (peer->type == BT_ADDR_LE_PUBLIC_ID ||
   18256:	7833      	ldrb	r3, [r6, #0]
   18258:	3b02      	subs	r3, #2
   1825a:	2b01      	cmp	r3, #1
   1825c:	d811      	bhi.n	18282 <bt_conn_create_le+0xe6>
   1825e:	2207      	movs	r2, #7
   18260:	4631      	mov	r1, r6
   18262:	4668      	mov	r0, sp
   18264:	f012 f8f3 	bl	2a44e <memcpy>
		dst.type -= BT_ADDR_LE_PUBLIC_ID;
   18268:	f89d 3000 	ldrb.w	r3, [sp]
   1826c:	3b02      	subs	r3, #2
   1826e:	f88d 3000 	strb.w	r3, [sp]
	conn = bt_conn_add_le(BT_ID_DEFAULT, &dst);
   18272:	4669      	mov	r1, sp
   18274:	2000      	movs	r0, #0
   18276:	f7ff fdb5 	bl	17de4 <bt_conn_add_le>
	if (!conn) {
   1827a:	4604      	mov	r4, r0
   1827c:	2800      	cmp	r0, #0
   1827e:	d1d2      	bne.n	18226 <bt_conn_create_le+0x8a>
   18280:	e794      	b.n	181ac <bt_conn_create_le+0x10>
		bt_addr_le_copy(&dst, bt_lookup_id_addr(BT_ID_DEFAULT, peer));
   18282:	4631      	mov	r1, r6
   18284:	f012 faab 	bl	2a7de <bt_lookup_id_addr>
   18288:	2207      	movs	r2, #7
   1828a:	4601      	mov	r1, r0
   1828c:	4668      	mov	r0, sp
   1828e:	f012 f8de 	bl	2a44e <memcpy>
   18292:	e7ee      	b.n	18272 <bt_conn_create_le+0xd6>
   18294:	2000f790 	.word	0x2000f790
   18298:	2000ffa0 	.word	0x2000ffa0
   1829c:	0002db28 	.word	0x0002db28
   182a0:	0002db38 	.word	0x0002db38
   182a4:	00030e08 	.word	0x00030e08

000182a8 <bt_le_set_auto_conn>:

#if !defined(CONFIG_BT_WHITELIST)
int bt_le_set_auto_conn(const bt_addr_le_t *addr,
			const struct bt_le_conn_param *param)
{
   182a8:	b570      	push	{r4, r5, r6, lr}
   182aa:	4606      	mov	r6, r0
	struct bt_conn *conn;

	if (param && !bt_le_conn_params_valid(param)) {
   182ac:	460d      	mov	r5, r1
   182ae:	2900      	cmp	r1, #0
   182b0:	d141      	bne.n	18336 <bt_le_set_auto_conn+0x8e>
		return -EINVAL;
	}

	/* Only default identity is supported */
	conn = bt_conn_lookup_addr_le(BT_ID_DEFAULT, addr);
   182b2:	4631      	mov	r1, r6
   182b4:	2000      	movs	r0, #0
   182b6:	f7ff fef1 	bl	1809c <bt_conn_lookup_addr_le>
	if (!conn) {
   182ba:	4604      	mov	r4, r0
   182bc:	b928      	cbnz	r0, 182ca <bt_le_set_auto_conn+0x22>
		conn = bt_conn_add_le(BT_ID_DEFAULT, addr);
   182be:	4631      	mov	r1, r6
   182c0:	f7ff fd90 	bl	17de4 <bt_conn_add_le>
		if (!conn) {
   182c4:	4604      	mov	r4, r0
   182c6:	2800      	cmp	r0, #0
   182c8:	d056      	beq.n	18378 <bt_le_set_auto_conn+0xd0>
			return -ENOMEM;
		}
	}

	if (param) {
   182ca:	1d23      	adds	r3, r4, #4
   182cc:	f104 064c 	add.w	r6, r4, #76	; 0x4c
   182d0:	2d00      	cmp	r5, #0
   182d2:	d038      	beq.n	18346 <bt_le_set_auto_conn+0x9e>
	conn->le.interval_min = param->interval_min;
   182d4:	882a      	ldrh	r2, [r5, #0]
   182d6:	f8a4 2088 	strh.w	r2, [r4, #136]	; 0x88
	conn->le.interval_max = param->interval_max;
   182da:	886a      	ldrh	r2, [r5, #2]
   182dc:	f8a4 208a 	strh.w	r2, [r4, #138]	; 0x8a
	conn->le.latency = param->latency;
   182e0:	88aa      	ldrh	r2, [r5, #4]
   182e2:	f8a4 208c 	strh.w	r2, [r4, #140]	; 0x8c
	conn->le.timeout = param->timeout;
   182e6:	88ea      	ldrh	r2, [r5, #6]
   182e8:	f8a4 208e 	strh.w	r2, [r4, #142]	; 0x8e
   182ec:	f3bf 8f5b 	dmb	ish
   182f0:	e853 2f00 	ldrex	r2, [r3]
   182f4:	f042 0101 	orr.w	r1, r2, #1
   182f8:	e843 1000 	strex	r0, r1, [r3]
   182fc:	2800      	cmp	r0, #0
   182fe:	d1f7      	bne.n	182f0 <bt_le_set_auto_conn+0x48>
   18300:	f3bf 8f5b 	dmb	ish
		bt_conn_set_param_le(conn, param);

		if (!atomic_test_and_set_bit(conn->flags,
   18304:	07d2      	lsls	r2, r2, #31
   18306:	d402      	bmi.n	1830e <bt_le_set_auto_conn+0x66>
	atomic_inc(&conn->ref);
   18308:	4630      	mov	r0, r6
   1830a:	f012 fb29 	bl	2a960 <atomic_inc>
				bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
			}
		}
	}

	if (conn->state == BT_CONN_DISCONNECTED &&
   1830e:	7aa3      	ldrb	r3, [r4, #10]
   18310:	b963      	cbnz	r3, 1832c <bt_le_set_auto_conn+0x84>
	    atomic_test_bit(bt_dev.flags, BT_DEV_READY)) {
   18312:	2101      	movs	r1, #1
   18314:	481a      	ldr	r0, [pc, #104]	; (18380 <bt_le_set_auto_conn+0xd8>)
   18316:	f012 fb04 	bl	2a922 <atomic_test_bit>
	if (conn->state == BT_CONN_DISCONNECTED &&
   1831a:	b138      	cbz	r0, 1832c <bt_le_set_auto_conn+0x84>
		if (param) {
   1831c:	b11d      	cbz	r5, 18326 <bt_le_set_auto_conn+0x7e>
			bt_conn_set_state(conn, BT_CONN_CONNECT_SCAN);
   1831e:	2101      	movs	r1, #1
   18320:	4620      	mov	r0, r4
   18322:	f7ff fdad 	bl	17e80 <bt_conn_set_state>
		}
		bt_le_scan_update(false);
   18326:	2000      	movs	r0, #0
   18328:	f7fd fd10 	bl	15d4c <bt_le_scan_update>
	atomic_dec(&conn->ref);
   1832c:	4630      	mov	r0, r6
   1832e:	f012 fb0a 	bl	2a946 <atomic_dec>
	}

	bt_conn_unref(conn);

	return 0;
   18332:	2000      	movs	r0, #0
   18334:	e006      	b.n	18344 <bt_le_set_auto_conn+0x9c>
	if (param && !bt_le_conn_params_valid(param)) {
   18336:	4608      	mov	r0, r1
   18338:	f012 fa53 	bl	2a7e2 <bt_le_conn_params_valid>
   1833c:	2800      	cmp	r0, #0
   1833e:	d1b8      	bne.n	182b2 <bt_le_set_auto_conn+0xa>
		return -EINVAL;
   18340:	f06f 0015 	mvn.w	r0, #21
}
   18344:	bd70      	pop	{r4, r5, r6, pc}
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   18346:	f3bf 8f5b 	dmb	ish
   1834a:	e853 2f00 	ldrex	r2, [r3]
   1834e:	f022 0101 	bic.w	r1, r2, #1
   18352:	e843 1000 	strex	r0, r1, [r3]
   18356:	2800      	cmp	r0, #0
   18358:	d1f7      	bne.n	1834a <bt_le_set_auto_conn+0xa2>
   1835a:	f3bf 8f5b 	dmb	ish
		if (atomic_test_and_clear_bit(conn->flags,
   1835e:	07d3      	lsls	r3, r2, #31
   18360:	d5d5      	bpl.n	1830e <bt_le_set_auto_conn+0x66>
	atomic_dec(&conn->ref);
   18362:	4630      	mov	r0, r6
   18364:	f012 faef 	bl	2a946 <atomic_dec>
			if (conn->state == BT_CONN_CONNECT_SCAN) {
   18368:	7aa3      	ldrb	r3, [r4, #10]
   1836a:	2b01      	cmp	r3, #1
   1836c:	d1cf      	bne.n	1830e <bt_le_set_auto_conn+0x66>
				bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   1836e:	4629      	mov	r1, r5
   18370:	4620      	mov	r0, r4
   18372:	f7ff fd85 	bl	17e80 <bt_conn_set_state>
   18376:	e7ca      	b.n	1830e <bt_le_set_auto_conn+0x66>
			return -ENOMEM;
   18378:	f06f 000b 	mvn.w	r0, #11
   1837c:	e7e2      	b.n	18344 <bt_le_set_auto_conn+0x9c>
   1837e:	bf00      	nop
   18380:	2000f790 	.word	0x2000f790

00018384 <send_conn_le_param_update>:
{
   18384:	b538      	push	{r3, r4, r5, lr}
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
   18386:	4b12      	ldr	r3, [pc, #72]	; (183d0 <send_conn_le_param_update+0x4c>)
   18388:	f893 3078 	ldrb.w	r3, [r3, #120]	; 0x78
   1838c:	079a      	lsls	r2, r3, #30
{
   1838e:	4604      	mov	r4, r0
   18390:	460d      	mov	r5, r1
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
   18392:	d407      	bmi.n	183a4 <send_conn_le_param_update+0x20>
	     !atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_L2CAP)) ||
   18394:	78e3      	ldrb	r3, [r4, #3]
   18396:	b17b      	cbz	r3, 183b8 <send_conn_le_param_update+0x34>
	return bt_l2cap_update_conn_param(conn, param);
   18398:	4629      	mov	r1, r5
   1839a:	4620      	mov	r0, r4
}
   1839c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return bt_l2cap_update_conn_param(conn, param);
   183a0:	f000 bb86 	b.w	18ab0 <bt_l2cap_update_conn_param>
	if ((BT_FEAT_LE_CONN_PARAM_REQ_PROC(bt_dev.le.features) &&
   183a4:	f890 3094 	ldrb.w	r3, [r0, #148]	; 0x94
   183a8:	079b      	lsls	r3, r3, #30
   183aa:	d5f3      	bpl.n	18394 <send_conn_le_param_update+0x10>
	     !atomic_test_bit(conn->flags, BT_CONN_SLAVE_PARAM_L2CAP)) ||
   183ac:	210a      	movs	r1, #10
   183ae:	3004      	adds	r0, #4
   183b0:	f012 fab7 	bl	2a922 <atomic_test_bit>
	     BT_FEAT_LE_CONN_PARAM_REQ_PROC(conn->le.features) &&
   183b4:	2800      	cmp	r0, #0
   183b6:	d1ed      	bne.n	18394 <send_conn_le_param_update+0x10>
		rc = bt_conn_le_conn_update(conn, param);
   183b8:	4629      	mov	r1, r5
   183ba:	4620      	mov	r0, r4
   183bc:	f012 fb7c 	bl	2aab8 <bt_conn_le_conn_update>
		if (rc == 0) {
   183c0:	b928      	cbnz	r0, 183ce <send_conn_le_param_update+0x4a>
			conn->le.pending_latency = param->latency;
   183c2:	88ab      	ldrh	r3, [r5, #4]
   183c4:	f8a4 3090 	strh.w	r3, [r4, #144]	; 0x90
			conn->le.pending_timeout = param->timeout;
   183c8:	88eb      	ldrh	r3, [r5, #6]
   183ca:	f8a4 3092 	strh.w	r3, [r4, #146]	; 0x92
}
   183ce:	bd38      	pop	{r3, r4, r5, pc}
   183d0:	2000f720 	.word	0x2000f720

000183d4 <conn_update_timeout>:
{
   183d4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	if (conn->state == BT_CONN_DISCONNECTED) {
   183d6:	f810 3c46 	ldrb.w	r3, [r0, #-70]
{
   183da:	4604      	mov	r4, r0
	struct bt_conn *conn = CONTAINER_OF(work, struct bt_conn, update_work);
   183dc:	f1a0 0650 	sub.w	r6, r0, #80	; 0x50
	if (conn->state == BT_CONN_DISCONNECTED) {
   183e0:	b993      	cbnz	r3, 18408 <conn_update_timeout+0x34>
		bt_l2cap_disconnected(conn);
   183e2:	4630      	mov	r0, r6
   183e4:	f012 fbc3 	bl	2ab6e <bt_l2cap_disconnected>
	for (cb = callback_list; cb; cb = cb->_next) {
   183e8:	4b23      	ldr	r3, [pc, #140]	; (18478 <conn_update_timeout+0xa4>)
   183ea:	681d      	ldr	r5, [r3, #0]
   183ec:	b925      	cbnz	r5, 183f8 <conn_update_timeout+0x24>
	atomic_dec(&conn->ref);
   183ee:	1f20      	subs	r0, r4, #4
   183f0:	f012 faa9 	bl	2a946 <atomic_dec>
}
   183f4:	b004      	add	sp, #16
   183f6:	bd70      	pop	{r4, r5, r6, pc}
		if (cb->disconnected) {
   183f8:	686b      	ldr	r3, [r5, #4]
   183fa:	b11b      	cbz	r3, 18404 <conn_update_timeout+0x30>
			cb->disconnected(conn, conn->err);
   183fc:	f814 1c47 	ldrb.w	r1, [r4, #-71]
   18400:	4630      	mov	r0, r6
   18402:	4798      	blx	r3
	for (cb = callback_list; cb; cb = cb->_next) {
   18404:	692d      	ldr	r5, [r5, #16]
   18406:	e7f1      	b.n	183ec <conn_update_timeout+0x18>
	if (conn->type != BT_CONN_TYPE_LE) {
   18408:	f810 3c4e 	ldrb.w	r3, [r0, #-78]
   1840c:	2b01      	cmp	r3, #1
   1840e:	d1f1      	bne.n	183f4 <conn_update_timeout+0x20>
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   18410:	f810 1c4d 	ldrb.w	r1, [r0, #-77]
   18414:	b921      	cbnz	r1, 18420 <conn_update_timeout+0x4c>
		bt_hci_cmd_send(BT_HCI_OP_LE_CREATE_CONN_CANCEL, NULL);
   18416:	f242 000e 	movw	r0, #8206	; 0x200e
   1841a:	f7fd fc03 	bl	15c24 <bt_hci_cmd_send>
		return;
   1841e:	e7e9      	b.n	183f4 <conn_update_timeout+0x20>
	if (atomic_test_and_clear_bit(conn->flags, BT_CONN_SLAVE_PARAM_SET)) {
   18420:	f1a0 054c 	sub.w	r5, r0, #76	; 0x4c
   18424:	f3bf 8f5b 	dmb	ish
   18428:	e855 3f00 	ldrex	r3, [r5]
   1842c:	f423 7200 	bic.w	r2, r3, #512	; 0x200
   18430:	e845 2100 	strex	r1, r2, [r5]
   18434:	2900      	cmp	r1, #0
   18436:	d1f7      	bne.n	18428 <conn_update_timeout+0x54>
   18438:	f3bf 8f5b 	dmb	ish
   1843c:	059b      	lsls	r3, r3, #22
   1843e:	d514      	bpl.n	1846a <conn_update_timeout+0x96>
		param = BT_LE_CONN_PARAM(conn->le.interval_min,
   18440:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   18442:	9300      	str	r3, [sp, #0]
   18444:	6c23      	ldr	r3, [r4, #64]	; 0x40
   18446:	9301      	str	r3, [sp, #4]
		send_conn_le_param_update(conn, param);
   18448:	4669      	mov	r1, sp
		send_conn_le_param_update(conn, param);
   1844a:	4630      	mov	r0, r6
   1844c:	f7ff ff9a 	bl	18384 <send_conn_le_param_update>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   18450:	f3bf 8f5b 	dmb	ish
   18454:	e855 3f00 	ldrex	r3, [r5]
   18458:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   1845c:	e845 3200 	strex	r2, r3, [r5]
   18460:	2a00      	cmp	r2, #0
   18462:	d1f7      	bne.n	18454 <conn_update_timeout+0x80>
   18464:	f3bf 8f5b 	dmb	ish
   18468:	e7c4      	b.n	183f4 <conn_update_timeout+0x20>
		param = BT_LE_CONN_PARAM(CONFIG_BT_PERIPHERAL_PREF_MIN_INT,
   1846a:	4a04      	ldr	r2, [pc, #16]	; (1847c <conn_update_timeout+0xa8>)
   1846c:	6851      	ldr	r1, [r2, #4]
   1846e:	6810      	ldr	r0, [r2, #0]
   18470:	ab02      	add	r3, sp, #8
   18472:	c303      	stmia	r3!, {r0, r1}
		send_conn_le_param_update(conn, param);
   18474:	a902      	add	r1, sp, #8
   18476:	e7e8      	b.n	1844a <conn_update_timeout+0x76>
   18478:	20000a88 	.word	0x20000a88
   1847c:	0002dd4c 	.word	0x0002dd4c

00018480 <bt_conn_create_pdu_timeout>:
		if (!buf) {
			BT_WARN("Unable to allocate buffer with K_NO_WAIT");
			buf = net_buf_alloc(pool, timeout);
		}
	} else {
		buf = net_buf_alloc(pool, timeout);
   18480:	4b13      	ldr	r3, [pc, #76]	; (184d0 <bt_conn_create_pdu_timeout+0x50>)
{
   18482:	b570      	push	{r4, r5, r6, lr}
		buf = net_buf_alloc(pool, timeout);
   18484:	2800      	cmp	r0, #0
   18486:	bf08      	it	eq
   18488:	4618      	moveq	r0, r3
{
   1848a:	460e      	mov	r6, r1
		buf = net_buf_alloc(pool, timeout);
   1848c:	4611      	mov	r1, r2
{
   1848e:	4615      	mov	r5, r2
		buf = net_buf_alloc(pool, timeout);
   18490:	f014 fb42 	bl	2cb18 <net_buf_alloc_fixed>
	}

	if (!buf) {
   18494:	4604      	mov	r4, r0
   18496:	b9a8      	cbnz	r0, 184c4 <bt_conn_create_pdu_timeout+0x44>
		BT_WARN("Unable to allocate buffer: timeout %d", timeout);
   18498:	4b0e      	ldr	r3, [pc, #56]	; (184d4 <bt_conn_create_pdu_timeout+0x54>)
   1849a:	681b      	ldr	r3, [r3, #0]
   1849c:	f013 0f06 	tst.w	r3, #6
   184a0:	d00e      	beq.n	184c0 <bt_conn_create_pdu_timeout+0x40>
   184a2:	2302      	movs	r3, #2
   184a4:	f04f 0200 	mov.w	r2, #0
   184a8:	f363 0207 	bfi	r2, r3, #0, #8
   184ac:	490a      	ldr	r1, [pc, #40]	; (184d8 <bt_conn_create_pdu_timeout+0x58>)
   184ae:	4b0b      	ldr	r3, [pc, #44]	; (184dc <bt_conn_create_pdu_timeout+0x5c>)
   184b0:	480b      	ldr	r0, [pc, #44]	; (184e0 <bt_conn_create_pdu_timeout+0x60>)
   184b2:	1a5b      	subs	r3, r3, r1
   184b4:	08db      	lsrs	r3, r3, #3
   184b6:	f363 128f 	bfi	r2, r3, #6, #10
   184ba:	4629      	mov	r1, r5
   184bc:	f010 fa4a 	bl	28954 <log_1>

	reserve += sizeof(struct bt_hci_acl_hdr) + BT_BUF_RESERVE;
	net_buf_reserve(buf, reserve);

	return buf;
}
   184c0:	4620      	mov	r0, r4
   184c2:	bd70      	pop	{r4, r5, r6, pc}
	net_buf_reserve(buf, reserve);
   184c4:	1d31      	adds	r1, r6, #4
   184c6:	3008      	adds	r0, #8
   184c8:	f014 fb45 	bl	2cb56 <net_buf_simple_reserve>
	return buf;
   184cc:	e7f8      	b.n	184c0 <bt_conn_create_pdu_timeout+0x40>
   184ce:	bf00      	nop
   184d0:	20010180 	.word	0x20010180
   184d4:	2000ffa0 	.word	0x2000ffa0
   184d8:	0002db28 	.word	0x0002db28
   184dc:	0002db38 	.word	0x0002db38
   184e0:	00030e31 	.word	0x00030e31

000184e4 <create_frag.isra.13>:
static struct net_buf *create_frag(struct bt_conn *conn, struct net_buf *buf)
   184e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   184e8:	4606      	mov	r6, r0
   184ea:	460c      	mov	r4, r1
	frag = bt_conn_create_pdu(&frag_pool, 0);
   184ec:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   184f0:	2100      	movs	r1, #0
   184f2:	4816      	ldr	r0, [pc, #88]	; (1854c <create_frag.isra.13+0x68>)
   184f4:	f7ff ffc4 	bl	18480 <bt_conn_create_pdu_timeout>
	if (conn->state != BT_CONN_CONNECTED) {
   184f8:	7833      	ldrb	r3, [r6, #0]
   184fa:	2b04      	cmp	r3, #4
	frag = bt_conn_create_pdu(&frag_pool, 0);
   184fc:	4605      	mov	r5, r0
	if (conn->state != BT_CONN_CONNECTED) {
   184fe:	f04f 0600 	mov.w	r6, #0
   18502:	d005      	beq.n	18510 <create_frag.isra.13+0x2c>
		net_buf_unref(frag);
   18504:	f00c fee2 	bl	252cc <net_buf_unref>
		return NULL;
   18508:	4635      	mov	r5, r6
}
   1850a:	4628      	mov	r0, r5
   1850c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	tx_data(frag)->tx = NULL;
   18510:	6146      	str	r6, [r0, #20]
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
   18512:	f100 0708 	add.w	r7, r0, #8
	return bt_dev.le.mtu;
   18516:	4e0e      	ldr	r6, [pc, #56]	; (18550 <create_frag.isra.13+0x6c>)
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
   18518:	4638      	mov	r0, r7
   1851a:	f8b6 8088 	ldrh.w	r8, [r6, #136]	; 0x88
   1851e:	f014 fb7c 	bl	2cc1a <net_buf_simple_tailroom>
   18522:	4580      	cmp	r8, r0
   18524:	d20c      	bcs.n	18540 <create_frag.isra.13+0x5c>
	return bt_dev.le.mtu;
   18526:	f8b6 6088 	ldrh.w	r6, [r6, #136]	; 0x88
	net_buf_add_mem(frag, buf->data, frag_len);
   1852a:	f854 1f08 	ldr.w	r1, [r4, #8]!
   1852e:	4632      	mov	r2, r6
   18530:	4638      	mov	r0, r7
   18532:	f014 fb2b 	bl	2cb8c <net_buf_simple_add_mem>
	net_buf_pull(buf, frag_len);
   18536:	4631      	mov	r1, r6
   18538:	4620      	mov	r0, r4
   1853a:	f014 fb4a 	bl	2cbd2 <net_buf_simple_pull>
	return frag;
   1853e:	e7e4      	b.n	1850a <create_frag.isra.13+0x26>
	frag_len = MIN(conn_mtu(conn), net_buf_tailroom(frag));
   18540:	4638      	mov	r0, r7
   18542:	f014 fb6a 	bl	2cc1a <net_buf_simple_tailroom>
   18546:	b286      	uxth	r6, r0
   18548:	e7ef      	b.n	1852a <create_frag.isra.13+0x46>
   1854a:	bf00      	nop
   1854c:	200101c0 	.word	0x200101c0
   18550:	2000f720 	.word	0x2000f720

00018554 <bt_conn_process_tx>:
{
   18554:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (conn->state == BT_CONN_DISCONNECTED &&
   18556:	7a83      	ldrb	r3, [r0, #10]
{
   18558:	4605      	mov	r5, r0
	if (conn->state == BT_CONN_DISCONNECTED &&
   1855a:	b993      	cbnz	r3, 18582 <bt_conn_process_tx+0x2e>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1855c:	f3bf 8f5b 	dmb	ish
   18560:	1d03      	adds	r3, r0, #4
   18562:	e853 2f00 	ldrex	r2, [r3]
   18566:	f022 0140 	bic.w	r1, r2, #64	; 0x40
   1856a:	e843 1400 	strex	r4, r1, [r3]
   1856e:	2c00      	cmp	r4, #0
   18570:	d1f7      	bne.n	18562 <bt_conn_process_tx+0xe>
   18572:	f3bf 8f5b 	dmb	ish
   18576:	0653      	lsls	r3, r2, #25
   18578:	d503      	bpl.n	18582 <bt_conn_process_tx+0x2e>
}
   1857a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		conn_cleanup(conn);
   1857e:	f7ff ba19 	b.w	179b4 <conn_cleanup>
	buf = net_buf_get(&conn->tx_queue, K_NO_WAIT);
   18582:	2100      	movs	r1, #0
   18584:	f105 0034 	add.w	r0, r5, #52	; 0x34
   18588:	f014 facc 	bl	2cb24 <net_buf_get>
	BT_ASSERT(buf);
   1858c:	4604      	mov	r4, r0
   1858e:	b940      	cbnz	r0, 185a2 <bt_conn_process_tx+0x4e>
   18590:	481e      	ldr	r0, [pc, #120]	; (1860c <bt_conn_process_tx+0xb8>)
   18592:	f00f fdd7 	bl	28144 <printk>
   18596:	4040      	eors	r0, r0
   18598:	f380 8811 	msr	BASEPRI, r0
   1859c:	f04f 0003 	mov.w	r0, #3
   185a0:	df02      	svc	2
	return bt_dev.le.mtu;
   185a2:	4e1b      	ldr	r6, [pc, #108]	; (18610 <bt_conn_process_tx+0xbc>)
	if (buf->len <= conn_mtu(conn)) {
   185a4:	89a1      	ldrh	r1, [r4, #12]
   185a6:	f8b6 2088 	ldrh.w	r2, [r6, #136]	; 0x88
   185aa:	4291      	cmp	r1, r2
   185ac:	d807      	bhi.n	185be <bt_conn_process_tx+0x6a>
		return send_frag(conn, buf, BT_ACL_START_NO_FLUSH, false);
   185ae:	2300      	movs	r3, #0
   185b0:	461a      	mov	r2, r3
	return send_frag(conn, buf, BT_ACL_CONT, false);
   185b2:	4621      	mov	r1, r4
   185b4:	4628      	mov	r0, r5
   185b6:	f7ff f95d 	bl	17874 <send_frag>
	if (!send_buf(conn, buf)) {
   185ba:	b140      	cbz	r0, 185ce <bt_conn_process_tx+0x7a>
}
   185bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	frag = create_frag(conn, buf);
   185be:	f105 070a 	add.w	r7, r5, #10
   185c2:	4621      	mov	r1, r4
   185c4:	4638      	mov	r0, r7
   185c6:	f7ff ff8d 	bl	184e4 <create_frag.isra.13>
	if (!frag) {
   185ca:	4601      	mov	r1, r0
   185cc:	b920      	cbnz	r0, 185d8 <bt_conn_process_tx+0x84>
		net_buf_unref(buf);
   185ce:	4620      	mov	r0, r4
}
   185d0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		net_buf_unref(buf);
   185d4:	f00c be7a 	b.w	252cc <net_buf_unref>
	if (!send_frag(conn, frag, BT_ACL_START_NO_FLUSH, true)) {
   185d8:	2301      	movs	r3, #1
   185da:	2200      	movs	r2, #0
		if (!send_frag(conn, frag, BT_ACL_CONT, true)) {
   185dc:	4628      	mov	r0, r5
   185de:	f7ff f949 	bl	17874 <send_frag>
   185e2:	2800      	cmp	r0, #0
   185e4:	d0f3      	beq.n	185ce <bt_conn_process_tx+0x7a>
	while (buf->len > conn_mtu(conn)) {
   185e6:	89a2      	ldrh	r2, [r4, #12]
   185e8:	f8b6 3088 	ldrh.w	r3, [r6, #136]	; 0x88
   185ec:	429a      	cmp	r2, r3
   185ee:	d802      	bhi.n	185f6 <bt_conn_process_tx+0xa2>
	return send_frag(conn, buf, BT_ACL_CONT, false);
   185f0:	2300      	movs	r3, #0
   185f2:	2201      	movs	r2, #1
   185f4:	e7dd      	b.n	185b2 <bt_conn_process_tx+0x5e>
		frag = create_frag(conn, buf);
   185f6:	4621      	mov	r1, r4
   185f8:	4638      	mov	r0, r7
   185fa:	f7ff ff73 	bl	184e4 <create_frag.isra.13>
		if (!frag) {
   185fe:	4601      	mov	r1, r0
   18600:	2800      	cmp	r0, #0
   18602:	d0e4      	beq.n	185ce <bt_conn_process_tx+0x7a>
		if (!send_frag(conn, frag, BT_ACL_CONT, true)) {
   18604:	2301      	movs	r3, #1
   18606:	461a      	mov	r2, r3
   18608:	e7e8      	b.n	185dc <bt_conn_process_tx+0x88>
   1860a:	bf00      	nop
   1860c:	00030c32 	.word	0x00030c32
   18610:	2000f720 	.word	0x2000f720

00018614 <bt_conn_index>:
}
#endif /* CONFIG_BT_SMP || CONFIG_BT_BREDR */

u8_t bt_conn_index(struct bt_conn *conn)
{
	u8_t index = conn - conns;
   18614:	4b03      	ldr	r3, [pc, #12]	; (18624 <bt_conn_index+0x10>)
   18616:	1ac0      	subs	r0, r0, r3
   18618:	4b03      	ldr	r3, [pc, #12]	; (18628 <bt_conn_index+0x14>)
   1861a:	1140      	asrs	r0, r0, #5
   1861c:	4358      	muls	r0, r3

	__ASSERT(index < CONFIG_BT_MAX_CONN, "Invalid bt_conn pointer");
	return index;
}
   1861e:	b2c0      	uxtb	r0, r0
   18620:	4770      	bx	lr
   18622:	bf00      	nop
   18624:	20000b8c 	.word	0x20000b8c
   18628:	cccccccd 	.word	0xcccccccd

0001862c <bt_conn_init>:

	return bt_conn_ref(conn);
}

int bt_conn_init(void)
{
   1862c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1862e:	4d17      	ldr	r5, [pc, #92]	; (1868c <bt_conn_init+0x60>)
	int err, i;

	for (i = 0; i < ARRAY_SIZE(conn_tx); i++) {
		k_fifo_put(&free_tx, &conn_tx[i]);
   18630:	4e17      	ldr	r6, [pc, #92]	; (18690 <bt_conn_init+0x64>)
	for (i = 0; i < ARRAY_SIZE(conn_tx); i++) {
   18632:	2400      	movs	r4, #0
		k_fifo_put(&free_tx, &conn_tx[i]);
   18634:	4629      	mov	r1, r5
   18636:	4630      	mov	r0, r6
	for (i = 0; i < ARRAY_SIZE(conn_tx); i++) {
   18638:	3401      	adds	r4, #1
		k_fifo_put(&free_tx, &conn_tx[i]);
   1863a:	f014 fd62 	bl	2d102 <k_queue_append>
	for (i = 0; i < ARRAY_SIZE(conn_tx); i++) {
   1863e:	2c10      	cmp	r4, #16
   18640:	f105 0510 	add.w	r5, r5, #16
   18644:	d1f6      	bne.n	18634 <bt_conn_init+0x8>
	}

	bt_att_init();
   18646:	f012 fdda 	bl	2b1fe <bt_att_init>

	err = bt_smp_init();
   1864a:	f013 f94b 	bl	2b8e4 <bt_smp_init>
	if (err) {
   1864e:	4605      	mov	r5, r0
   18650:	b9d0      	cbnz	r0, 18688 <bt_conn_init+0x5c>
		return err;
	}

	bt_l2cap_init();
   18652:	f012 fae7 	bl	2ac24 <bt_l2cap_init>

	/* Initialize background scan */
	if (IS_ENABLED(CONFIG_BT_CENTRAL)) {
		for (i = 0; i < ARRAY_SIZE(conns); i++) {
   18656:	4c0f      	ldr	r4, [pc, #60]	; (18694 <bt_conn_init+0x68>)
   18658:	462e      	mov	r6, r5

			if (!atomic_get(&conn->ref)) {
				continue;
			}

			if (atomic_test_bit(conn->flags,
   1865a:	462f      	mov	r7, r5
			if (!atomic_get(&conn->ref)) {
   1865c:	4620      	mov	r0, r4
   1865e:	f012 f95a 	bl	2a916 <atomic_get>
   18662:	b160      	cbz	r0, 1867e <bt_conn_init+0x52>
			if (atomic_test_bit(conn->flags,
   18664:	2100      	movs	r1, #0
   18666:	f1a4 0048 	sub.w	r0, r4, #72	; 0x48
   1866a:	f012 f95a 	bl	2a922 <atomic_test_bit>
   1866e:	b130      	cbz	r0, 1867e <bt_conn_init+0x52>
					    BT_CONN_AUTO_CONNECT)) {
				/* Only the default identity is supported */
				conn->id = BT_ID_DEFAULT;
   18670:	f804 7c44 	strb.w	r7, [r4, #-68]
				bt_conn_set_state(conn, BT_CONN_CONNECT_SCAN);
   18674:	2101      	movs	r1, #1
   18676:	f1a4 004c 	sub.w	r0, r4, #76	; 0x4c
   1867a:	f7ff fc01 	bl	17e80 <bt_conn_set_state>
		for (i = 0; i < ARRAY_SIZE(conns); i++) {
   1867e:	3601      	adds	r6, #1
   18680:	2e05      	cmp	r6, #5
   18682:	f104 04a0 	add.w	r4, r4, #160	; 0xa0
   18686:	d1e9      	bne.n	1865c <bt_conn_init+0x30>
			}
		}
	}

	return 0;
}
   18688:	4628      	mov	r0, r5
   1868a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1868c:	20000a8c 	.word	0x20000a8c
   18690:	200100e8 	.word	0x200100e8
   18694:	20000bd8 	.word	0x20000bd8

00018698 <l2cap_accept>:
	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_l2cap_pool); i++) {
		struct bt_l2cap *l2cap = &bt_l2cap_pool[i];

		if (l2cap->chan.chan.conn) {
   18698:	4a13      	ldr	r2, [pc, #76]	; (186e8 <l2cap_accept+0x50>)
{
   1869a:	b570      	push	{r4, r5, r6, lr}
	for (i = 0; i < ARRAY_SIZE(bt_l2cap_pool); i++) {
   1869c:	2400      	movs	r4, #0
   1869e:	26ac      	movs	r6, #172	; 0xac
		if (l2cap->chan.chan.conn) {
   186a0:	fb06 f504 	mul.w	r5, r6, r4
   186a4:	58ab      	ldr	r3, [r5, r2]
   186a6:	b1c3      	cbz	r3, 186da <l2cap_accept+0x42>
	for (i = 0; i < ARRAY_SIZE(bt_l2cap_pool); i++) {
   186a8:	3401      	adds	r4, #1
   186aa:	2c05      	cmp	r4, #5
   186ac:	d1f8      	bne.n	186a0 <l2cap_accept+0x8>
		*chan = &l2cap->chan.chan;

		return 0;
	}

	BT_ERR("No available L2CAP context for conn %p", conn);
   186ae:	4b0f      	ldr	r3, [pc, #60]	; (186ec <l2cap_accept+0x54>)
   186b0:	681b      	ldr	r3, [r3, #0]
   186b2:	075b      	lsls	r3, r3, #29
   186b4:	d00e      	beq.n	186d4 <l2cap_accept+0x3c>
   186b6:	2301      	movs	r3, #1
   186b8:	f04f 0200 	mov.w	r2, #0
   186bc:	f363 0207 	bfi	r2, r3, #0, #8
   186c0:	490b      	ldr	r1, [pc, #44]	; (186f0 <l2cap_accept+0x58>)
   186c2:	4b0c      	ldr	r3, [pc, #48]	; (186f4 <l2cap_accept+0x5c>)
   186c4:	1a5b      	subs	r3, r3, r1
   186c6:	08db      	lsrs	r3, r3, #3
   186c8:	4601      	mov	r1, r0
   186ca:	f363 128f 	bfi	r2, r3, #6, #10
   186ce:	480a      	ldr	r0, [pc, #40]	; (186f8 <l2cap_accept+0x60>)
   186d0:	f010 f940 	bl	28954 <log_1>

	return -ENOMEM;
   186d4:	f06f 000b 	mvn.w	r0, #11
   186d8:	e004      	b.n	186e4 <l2cap_accept+0x4c>
		l2cap->chan.chan.ops = &ops;
   186da:	442a      	add	r2, r5
   186dc:	4807      	ldr	r0, [pc, #28]	; (186fc <l2cap_accept+0x64>)
   186de:	6050      	str	r0, [r2, #4]
		*chan = &l2cap->chan.chan;
   186e0:	600a      	str	r2, [r1, #0]
		return 0;
   186e2:	4618      	mov	r0, r3
}
   186e4:	bd70      	pop	{r4, r5, r6, pc}
   186e6:	bf00      	nop
   186e8:	20000eac 	.word	0x20000eac
   186ec:	20010008 	.word	0x20010008
   186f0:	0002db28 	.word	0x0002db28
   186f4:	0002dc08 	.word	0x0002dc08
   186f8:	00030fce 	.word	0x00030fce
   186fc:	2000f9ec 	.word	0x2000f9ec

00018700 <l2cap_create_le_sig_pdu.isra.8>:
static struct net_buf *l2cap_create_le_sig_pdu(struct net_buf *buf,
   18700:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   18702:	4605      	mov	r5, r0
   18704:	460f      	mov	r7, r1
   18706:	4616      	mov	r6, r2
	return bt_conn_create_pdu_timeout(pool,
   18708:	2104      	movs	r1, #4
   1870a:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
   1870e:	2000      	movs	r0, #0
   18710:	f7ff feb6 	bl	18480 <bt_conn_create_pdu_timeout>
	if (!buf) {
   18714:	4604      	mov	r4, r0
   18716:	b9a0      	cbnz	r0, 18742 <l2cap_create_le_sig_pdu.isra.8+0x42>
		BT_ERR("Unable to allocate buffer for op 0x%02x", code);
   18718:	4b0e      	ldr	r3, [pc, #56]	; (18754 <l2cap_create_le_sig_pdu.isra.8+0x54>)
   1871a:	681b      	ldr	r3, [r3, #0]
   1871c:	075b      	lsls	r3, r3, #29
   1871e:	d00e      	beq.n	1873e <l2cap_create_le_sig_pdu.isra.8+0x3e>
   18720:	2301      	movs	r3, #1
   18722:	f04f 0200 	mov.w	r2, #0
   18726:	f363 0207 	bfi	r2, r3, #0, #8
   1872a:	490b      	ldr	r1, [pc, #44]	; (18758 <l2cap_create_le_sig_pdu.isra.8+0x58>)
   1872c:	4b0b      	ldr	r3, [pc, #44]	; (1875c <l2cap_create_le_sig_pdu.isra.8+0x5c>)
   1872e:	480c      	ldr	r0, [pc, #48]	; (18760 <l2cap_create_le_sig_pdu.isra.8+0x60>)
   18730:	1a5b      	subs	r3, r3, r1
   18732:	08db      	lsrs	r3, r3, #3
   18734:	f363 128f 	bfi	r2, r3, #6, #10
   18738:	4629      	mov	r1, r5
   1873a:	f010 f90b 	bl	28954 <log_1>
}
   1873e:	4620      	mov	r0, r4
   18740:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	hdr = net_buf_add(buf, sizeof(*hdr));
   18742:	2104      	movs	r1, #4
   18744:	3008      	adds	r0, #8
   18746:	f014 fa1b 	bl	2cb80 <net_buf_simple_add>
	hdr->code = code;
   1874a:	7005      	strb	r5, [r0, #0]
	hdr->ident = ident;
   1874c:	7047      	strb	r7, [r0, #1]
	hdr->len = sys_cpu_to_le16(len);
   1874e:	8046      	strh	r6, [r0, #2]
	return buf;
   18750:	e7f5      	b.n	1873e <l2cap_create_le_sig_pdu.isra.8+0x3e>
   18752:	bf00      	nop
   18754:	20010008 	.word	0x20010008
   18758:	0002db28 	.word	0x0002db28
   1875c:	0002dc08 	.word	0x0002dc08
   18760:	00030ff5 	.word	0x00030ff5

00018764 <l2cap_rtx_timeout>:
{
   18764:	b538      	push	{r3, r4, r5, lr}
	BT_ERR("chan %p timeout", chan);
   18766:	4b10      	ldr	r3, [pc, #64]	; (187a8 <l2cap_rtx_timeout+0x44>)
   18768:	681b      	ldr	r3, [r3, #0]
   1876a:	f013 0f07 	tst.w	r3, #7
{
   1876e:	4605      	mov	r5, r0
   18770:	f1a0 0410 	sub.w	r4, r0, #16
	BT_ERR("chan %p timeout", chan);
   18774:	d00e      	beq.n	18794 <l2cap_rtx_timeout+0x30>
   18776:	2301      	movs	r3, #1
   18778:	f04f 0200 	mov.w	r2, #0
   1877c:	f363 0207 	bfi	r2, r3, #0, #8
   18780:	490a      	ldr	r1, [pc, #40]	; (187ac <l2cap_rtx_timeout+0x48>)
   18782:	4b0b      	ldr	r3, [pc, #44]	; (187b0 <l2cap_rtx_timeout+0x4c>)
   18784:	480b      	ldr	r0, [pc, #44]	; (187b4 <l2cap_rtx_timeout+0x50>)
   18786:	1a5b      	subs	r3, r3, r1
   18788:	08db      	lsrs	r3, r3, #3
   1878a:	f363 128f 	bfi	r2, r3, #6, #10
   1878e:	4621      	mov	r1, r4
   18790:	f010 f8e0 	bl	28954 <log_1>
	bt_l2cap_chan_remove(chan->chan.conn, &chan->chan);
   18794:	f855 0c10 	ldr.w	r0, [r5, #-16]
   18798:	4621      	mov	r1, r4
   1879a:	f012 f9b7 	bl	2ab0c <bt_l2cap_chan_remove>
	bt_l2cap_chan_del(&chan->chan);
   1879e:	4620      	mov	r0, r4
}
   187a0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bt_l2cap_chan_del(&chan->chan);
   187a4:	f012 b9d2 	b.w	2ab4c <bt_l2cap_chan_del>
   187a8:	20010008 	.word	0x20010008
   187ac:	0002db28 	.word	0x0002db28
   187b0:	0002dc08 	.word	0x0002dc08
   187b4:	000310da 	.word	0x000310da

000187b8 <bt_l2cap_connected>:
{
   187b8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	Z_STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
   187bc:	4e21      	ldr	r6, [pc, #132]	; (18844 <bt_l2cap_connected+0x8c>)
   187be:	4f22      	ldr	r7, [pc, #136]	; (18848 <bt_l2cap_connected+0x90>)
	k_delayed_work_init(&chan->rtx_work, l2cap_rtx_timeout);
   187c0:	f8df 8088 	ldr.w	r8, [pc, #136]	; 1884c <bt_l2cap_connected+0x94>
{
   187c4:	4605      	mov	r5, r0
	Z_STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
   187c6:	42be      	cmp	r6, r7
   187c8:	d302      	bcc.n	187d0 <bt_l2cap_connected+0x18>
}
   187ca:	b002      	add	sp, #8
   187cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (fchan->accept(conn, &chan) < 0) {
   187d0:	6873      	ldr	r3, [r6, #4]
   187d2:	a901      	add	r1, sp, #4
   187d4:	4628      	mov	r0, r5
   187d6:	4798      	blx	r3
   187d8:	2800      	cmp	r0, #0
   187da:	db2d      	blt.n	18838 <bt_l2cap_connected+0x80>
		ch = BT_L2CAP_LE_CHAN(chan);
   187dc:	9c01      	ldr	r4, [sp, #4]
		ch->rx.cid = fchan->cid;
   187de:	8833      	ldrh	r3, [r6, #0]
   187e0:	86a3      	strh	r3, [r4, #52]	; 0x34
		ch->tx.cid = fchan->cid;
   187e2:	f8a4 3054 	strh.w	r3, [r4, #84]	; 0x54
	k_delayed_work_init(&chan->rtx_work, l2cap_rtx_timeout);
   187e6:	4641      	mov	r1, r8
   187e8:	f104 0010 	add.w	r0, r4, #16
   187ec:	f014 feb1 	bl	2d552 <k_delayed_work_init>
	parent->next = child;
   187f0:	2300      	movs	r3, #0
   187f2:	60a3      	str	r3, [r4, #8]
Z_GENLIST_APPEND(slist, snode)
   187f4:	6ca9      	ldr	r1, [r5, #72]	; 0x48
	sys_slist_append(&conn->channels, &chan->node);
   187f6:	f104 0208 	add.w	r2, r4, #8
   187fa:	b9f9      	cbnz	r1, 1883c <bt_l2cap_connected+0x84>
	list->head = node;
   187fc:	e9c5 2211 	strd	r2, r2, [r5, #68]	; 0x44
		if (chan->ops->connected) {
   18800:	9801      	ldr	r0, [sp, #4]
	chan->destroy = destroy;
   18802:	60e3      	str	r3, [r4, #12]
		if (chan->ops->connected) {
   18804:	6843      	ldr	r3, [r0, #4]
	chan->conn = conn;
   18806:	6025      	str	r5, [r4, #0]
		if (chan->ops->connected) {
   18808:	681b      	ldr	r3, [r3, #0]
   1880a:	b103      	cbz	r3, 1880e <bt_l2cap_connected+0x56>
			chan->ops->connected(chan);
   1880c:	4798      	blx	r3
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1880e:	9b01      	ldr	r3, [sp, #4]
   18810:	f3bf 8f5b 	dmb	ish
   18814:	3330      	adds	r3, #48	; 0x30
   18816:	e853 2f00 	ldrex	r2, [r3]
   1881a:	f042 0201 	orr.w	r2, r2, #1
   1881e:	e843 2100 	strex	r1, r2, [r3]
   18822:	2900      	cmp	r1, #0
   18824:	d1f7      	bne.n	18816 <bt_l2cap_connected+0x5e>
   18826:	f3bf 8f5b 	dmb	ish
		if (chan->ops->status) {
   1882a:	9801      	ldr	r0, [sp, #4]
   1882c:	6843      	ldr	r3, [r0, #4]
   1882e:	699b      	ldr	r3, [r3, #24]
   18830:	b113      	cbz	r3, 18838 <bt_l2cap_connected+0x80>
			chan->ops->status(chan, chan->status);
   18832:	f100 0130 	add.w	r1, r0, #48	; 0x30
   18836:	4798      	blx	r3
	Z_STRUCT_SECTION_FOREACH(bt_l2cap_fixed_chan, fchan) {
   18838:	3608      	adds	r6, #8
   1883a:	e7c4      	b.n	187c6 <bt_l2cap_connected+0xe>
	parent->next = child;
   1883c:	600a      	str	r2, [r1, #0]
	list->tail = node;
   1883e:	64aa      	str	r2, [r5, #72]	; 0x48
   18840:	e7de      	b.n	18800 <bt_l2cap_connected+0x48>
   18842:	bf00      	nop
   18844:	0002db00 	.word	0x0002db00
   18848:	0002db18 	.word	0x0002db18
   1884c:	00018765 	.word	0x00018765

00018850 <l2cap_recv>:
{
   18850:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (buf->len < sizeof(*hdr)) {
   18852:	898b      	ldrh	r3, [r1, #12]
   18854:	2b03      	cmp	r3, #3
{
   18856:	b085      	sub	sp, #20
   18858:	4606      	mov	r6, r0
   1885a:	460d      	mov	r5, r1
	if (buf->len < sizeof(*hdr)) {
   1885c:	d812      	bhi.n	18884 <l2cap_recv+0x34>
		BT_ERR("Too small L2CAP signaling PDU");
   1885e:	4b65      	ldr	r3, [pc, #404]	; (189f4 <l2cap_recv+0x1a4>)
   18860:	681b      	ldr	r3, [r3, #0]
   18862:	075d      	lsls	r5, r3, #29
   18864:	d02a      	beq.n	188bc <l2cap_recv+0x6c>
   18866:	2301      	movs	r3, #1
   18868:	f04f 0100 	mov.w	r1, #0
   1886c:	f363 0107 	bfi	r1, r3, #0, #8
   18870:	4a61      	ldr	r2, [pc, #388]	; (189f8 <l2cap_recv+0x1a8>)
   18872:	4b62      	ldr	r3, [pc, #392]	; (189fc <l2cap_recv+0x1ac>)
   18874:	4862      	ldr	r0, [pc, #392]	; (18a00 <l2cap_recv+0x1b0>)
   18876:	1a9b      	subs	r3, r3, r2
   18878:	08db      	lsrs	r3, r3, #3
   1887a:	f363 118f 	bfi	r1, r3, #6, #10
		BT_ERR("Invalid ident value in L2CAP PDU");
   1887e:	f010 f85c 	bl	2893a <log_0>
   18882:	e01b      	b.n	188bc <l2cap_recv+0x6c>
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
   18884:	2104      	movs	r1, #4
   18886:	f105 0008 	add.w	r0, r5, #8
   1888a:	f014 f9aa 	bl	2cbe2 <net_buf_simple_pull_mem>
	if (buf->len != len) {
   1888e:	89a9      	ldrh	r1, [r5, #12]
	len = sys_le16_to_cpu(hdr->len);
   18890:	8842      	ldrh	r2, [r0, #2]
	if (buf->len != len) {
   18892:	428a      	cmp	r2, r1
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
   18894:	4604      	mov	r4, r0
	if (buf->len != len) {
   18896:	d014      	beq.n	188c2 <l2cap_recv+0x72>
		BT_ERR("L2CAP length mismatch (%u != %u)", buf->len, len);
   18898:	4b56      	ldr	r3, [pc, #344]	; (189f4 <l2cap_recv+0x1a4>)
   1889a:	681b      	ldr	r3, [r3, #0]
   1889c:	075c      	lsls	r4, r3, #29
   1889e:	d00d      	beq.n	188bc <l2cap_recv+0x6c>
   188a0:	2001      	movs	r0, #1
   188a2:	f04f 0300 	mov.w	r3, #0
   188a6:	f360 0307 	bfi	r3, r0, #0, #8
   188aa:	4c53      	ldr	r4, [pc, #332]	; (189f8 <l2cap_recv+0x1a8>)
   188ac:	4853      	ldr	r0, [pc, #332]	; (189fc <l2cap_recv+0x1ac>)
   188ae:	1b00      	subs	r0, r0, r4
   188b0:	08c0      	lsrs	r0, r0, #3
   188b2:	f360 138f 	bfi	r3, r0, #6, #10
   188b6:	4853      	ldr	r0, [pc, #332]	; (18a04 <l2cap_recv+0x1b4>)
   188b8:	f010 f860 	bl	2897c <log_2>
}
   188bc:	2000      	movs	r0, #0
   188be:	b005      	add	sp, #20
   188c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (!hdr->ident) {
   188c2:	7841      	ldrb	r1, [r0, #1]
   188c4:	b971      	cbnz	r1, 188e4 <l2cap_recv+0x94>
		BT_ERR("Invalid ident value in L2CAP PDU");
   188c6:	4b4b      	ldr	r3, [pc, #300]	; (189f4 <l2cap_recv+0x1a4>)
   188c8:	681b      	ldr	r3, [r3, #0]
   188ca:	0758      	lsls	r0, r3, #29
   188cc:	d0f6      	beq.n	188bc <l2cap_recv+0x6c>
   188ce:	2301      	movs	r3, #1
   188d0:	f363 0107 	bfi	r1, r3, #0, #8
   188d4:	4a48      	ldr	r2, [pc, #288]	; (189f8 <l2cap_recv+0x1a8>)
   188d6:	4b49      	ldr	r3, [pc, #292]	; (189fc <l2cap_recv+0x1ac>)
   188d8:	484b      	ldr	r0, [pc, #300]	; (18a08 <l2cap_recv+0x1b8>)
   188da:	1a9b      	subs	r3, r3, r2
   188dc:	08db      	lsrs	r3, r3, #3
   188de:	f363 118f 	bfi	r1, r3, #6, #10
   188e2:	e7cc      	b.n	1887e <l2cap_recv+0x2e>
	switch (hdr->code) {
   188e4:	7800      	ldrb	r0, [r0, #0]
   188e6:	2812      	cmp	r0, #18
   188e8:	d02d      	beq.n	18946 <l2cap_recv+0xf6>
   188ea:	2813      	cmp	r0, #19
   188ec:	d018      	beq.n	18920 <l2cap_recv+0xd0>
   188ee:	2801      	cmp	r0, #1
   188f0:	d0e4      	beq.n	188bc <l2cap_recv+0x6c>
		BT_WARN("Unknown L2CAP PDU code 0x%02x", hdr->code);
   188f2:	4b40      	ldr	r3, [pc, #256]	; (189f4 <l2cap_recv+0x1a4>)
   188f4:	681b      	ldr	r3, [r3, #0]
   188f6:	f013 0f06 	tst.w	r3, #6
   188fa:	d00e      	beq.n	1891a <l2cap_recv+0xca>
   188fc:	2302      	movs	r3, #2
   188fe:	f04f 0200 	mov.w	r2, #0
   18902:	f363 0207 	bfi	r2, r3, #0, #8
   18906:	493c      	ldr	r1, [pc, #240]	; (189f8 <l2cap_recv+0x1a8>)
   18908:	4b3c      	ldr	r3, [pc, #240]	; (189fc <l2cap_recv+0x1ac>)
   1890a:	1a5b      	subs	r3, r3, r1
   1890c:	08db      	lsrs	r3, r3, #3
   1890e:	4601      	mov	r1, r0
   18910:	f363 128f 	bfi	r2, r3, #6, #10
   18914:	483d      	ldr	r0, [pc, #244]	; (18a0c <l2cap_recv+0x1bc>)
   18916:	f010 f81d 	bl	28954 <log_1>
		l2cap_send_reject(chan->conn, hdr->ident,
   1891a:	7861      	ldrb	r1, [r4, #1]
   1891c:	6830      	ldr	r0, [r6, #0]
   1891e:	e029      	b.n	18974 <l2cap_recv+0x124>
	if (buf->len < sizeof(*rsp)) {
   18920:	2a01      	cmp	r2, #1
   18922:	d8cb      	bhi.n	188bc <l2cap_recv+0x6c>
		BT_ERR("Too small LE conn param rsp");
   18924:	4b33      	ldr	r3, [pc, #204]	; (189f4 <l2cap_recv+0x1a4>)
   18926:	681b      	ldr	r3, [r3, #0]
   18928:	075a      	lsls	r2, r3, #29
   1892a:	d0c7      	beq.n	188bc <l2cap_recv+0x6c>
   1892c:	2301      	movs	r3, #1
   1892e:	f04f 0100 	mov.w	r1, #0
   18932:	f363 0107 	bfi	r1, r3, #0, #8
   18936:	4a30      	ldr	r2, [pc, #192]	; (189f8 <l2cap_recv+0x1a8>)
   18938:	4b30      	ldr	r3, [pc, #192]	; (189fc <l2cap_recv+0x1ac>)
   1893a:	4835      	ldr	r0, [pc, #212]	; (18a10 <l2cap_recv+0x1c0>)
   1893c:	1a9b      	subs	r3, r3, r2
   1893e:	08db      	lsrs	r3, r3, #3
   18940:	f363 118f 	bfi	r1, r3, #6, #10
   18944:	e79b      	b.n	1887e <l2cap_recv+0x2e>
	if (buf->len < sizeof(*req)) {
   18946:	2a07      	cmp	r2, #7
   18948:	d810      	bhi.n	1896c <l2cap_recv+0x11c>
		BT_ERR("Too small LE conn update param req");
   1894a:	4b2a      	ldr	r3, [pc, #168]	; (189f4 <l2cap_recv+0x1a4>)
   1894c:	681b      	ldr	r3, [r3, #0]
   1894e:	075b      	lsls	r3, r3, #29
   18950:	d0b4      	beq.n	188bc <l2cap_recv+0x6c>
   18952:	2301      	movs	r3, #1
   18954:	f04f 0100 	mov.w	r1, #0
   18958:	f363 0107 	bfi	r1, r3, #0, #8
   1895c:	4a26      	ldr	r2, [pc, #152]	; (189f8 <l2cap_recv+0x1a8>)
   1895e:	4b27      	ldr	r3, [pc, #156]	; (189fc <l2cap_recv+0x1ac>)
   18960:	482c      	ldr	r0, [pc, #176]	; (18a14 <l2cap_recv+0x1c4>)
   18962:	1a9b      	subs	r3, r3, r2
   18964:	08db      	lsrs	r3, r3, #3
   18966:	f363 118f 	bfi	r1, r3, #6, #10
   1896a:	e788      	b.n	1887e <l2cap_recv+0x2e>
			le_conn_param_update_req(l2cap, hdr->ident, buf);
   1896c:	6834      	ldr	r4, [r6, #0]
	if (conn->role != BT_HCI_ROLE_MASTER) {
   1896e:	78e6      	ldrb	r6, [r4, #3]
   18970:	b11e      	cbz	r6, 1897a <l2cap_recv+0x12a>
		l2cap_send_reject(conn, ident, BT_L2CAP_REJ_NOT_UNDERSTOOD,
   18972:	4620      	mov	r0, r4
		l2cap_send_reject(chan->conn, hdr->ident,
   18974:	f012 f92a 	bl	2abcc <l2cap_send_reject.constprop.14>
		break;
   18978:	e7a0      	b.n	188bc <l2cap_recv+0x6c>
	struct bt_l2cap_conn_param_req *req = (void *)buf->data;
   1897a:	68aa      	ldr	r2, [r5, #8]
	param.interval_min = sys_le16_to_cpu(req->min_interval);
   1897c:	7850      	ldrb	r0, [r2, #1]
   1897e:	7813      	ldrb	r3, [r2, #0]
   18980:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   18984:	f8ad 3008 	strh.w	r3, [sp, #8]
	param.interval_max = sys_le16_to_cpu(req->max_interval);
   18988:	78d0      	ldrb	r0, [r2, #3]
   1898a:	7893      	ldrb	r3, [r2, #2]
   1898c:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   18990:	f8ad 300a 	strh.w	r3, [sp, #10]
	param.latency = sys_le16_to_cpu(req->latency);
   18994:	7950      	ldrb	r0, [r2, #5]
   18996:	7913      	ldrb	r3, [r2, #4]
   18998:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   1899c:	f8ad 300c 	strh.w	r3, [sp, #12]
	param.timeout = sys_le16_to_cpu(req->timeout);
   189a0:	7993      	ldrb	r3, [r2, #6]
   189a2:	79d2      	ldrb	r2, [r2, #7]
	buf = l2cap_create_le_sig_pdu(buf, BT_L2CAP_CONN_PARAM_RSP, ident,
   189a4:	2013      	movs	r0, #19
	param.timeout = sys_le16_to_cpu(req->timeout);
   189a6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	buf = l2cap_create_le_sig_pdu(buf, BT_L2CAP_CONN_PARAM_RSP, ident,
   189aa:	2202      	movs	r2, #2
	param.timeout = sys_le16_to_cpu(req->timeout);
   189ac:	f8ad 300e 	strh.w	r3, [sp, #14]
	buf = l2cap_create_le_sig_pdu(buf, BT_L2CAP_CONN_PARAM_RSP, ident,
   189b0:	f7ff fea6 	bl	18700 <l2cap_create_le_sig_pdu.isra.8>
	if (!buf) {
   189b4:	4605      	mov	r5, r0
   189b6:	2800      	cmp	r0, #0
   189b8:	d080      	beq.n	188bc <l2cap_recv+0x6c>
	accepted = le_param_req(conn, &param);
   189ba:	a902      	add	r1, sp, #8
   189bc:	4620      	mov	r0, r4
   189be:	f7ff f851 	bl	17a64 <le_param_req>
	rsp = net_buf_add(buf, sizeof(*rsp));
   189c2:	2102      	movs	r1, #2
	accepted = le_param_req(conn, &param);
   189c4:	4607      	mov	r7, r0
	rsp = net_buf_add(buf, sizeof(*rsp));
   189c6:	f105 0008 	add.w	r0, r5, #8
   189ca:	f014 f8d9 	bl	2cb80 <net_buf_simple_add>
	if (accepted) {
   189ce:	f087 0301 	eor.w	r3, r7, #1
		rsp->result = sys_cpu_to_le16(BT_L2CAP_CONN_PARAM_ACCEPTED);
   189d2:	b2db      	uxtb	r3, r3
   189d4:	8003      	strh	r3, [r0, #0]
		     bt_conn_tx_cb_t cb, void *user_data);

static inline void bt_l2cap_send(struct bt_conn *conn, u16_t cid,
				 struct net_buf *buf)
{
	bt_l2cap_send_cb(conn, cid, buf, NULL, NULL);
   189d6:	462a      	mov	r2, r5
   189d8:	9600      	str	r6, [sp, #0]
   189da:	4633      	mov	r3, r6
   189dc:	2105      	movs	r1, #5
   189de:	4620      	mov	r0, r4
   189e0:	f012 f8db 	bl	2ab9a <bt_l2cap_send_cb>
	if (accepted) {
   189e4:	2f00      	cmp	r7, #0
   189e6:	f43f af69 	beq.w	188bc <l2cap_recv+0x6c>
		bt_conn_le_conn_update(conn, &param);
   189ea:	a902      	add	r1, sp, #8
   189ec:	4620      	mov	r0, r4
   189ee:	f012 f863 	bl	2aab8 <bt_conn_le_conn_update>
   189f2:	e763      	b.n	188bc <l2cap_recv+0x6c>
   189f4:	20010008 	.word	0x20010008
   189f8:	0002db28 	.word	0x0002db28
   189fc:	0002dc08 	.word	0x0002dc08
   18a00:	0003101d 	.word	0x0003101d
   18a04:	0003103b 	.word	0x0003103b
   18a08:	0003105c 	.word	0x0003105c
   18a0c:	000310bc 	.word	0x000310bc
   18a10:	0003107d 	.word	0x0003107d
   18a14:	00031099 	.word	0x00031099

00018a18 <bt_l2cap_recv>:
	if (buf->len < sizeof(*hdr)) {
   18a18:	898b      	ldrh	r3, [r1, #12]
   18a1a:	2b03      	cmp	r3, #3
{
   18a1c:	b570      	push	{r4, r5, r6, lr}
   18a1e:	4606      	mov	r6, r0
   18a20:	460c      	mov	r4, r1
	if (buf->len < sizeof(*hdr)) {
   18a22:	d816      	bhi.n	18a52 <bt_l2cap_recv+0x3a>
		BT_ERR("Too small L2CAP PDU received");
   18a24:	4b1d      	ldr	r3, [pc, #116]	; (18a9c <bt_l2cap_recv+0x84>)
   18a26:	681b      	ldr	r3, [r3, #0]
   18a28:	075b      	lsls	r3, r3, #29
   18a2a:	d00d      	beq.n	18a48 <bt_l2cap_recv+0x30>
   18a2c:	2301      	movs	r3, #1
   18a2e:	f04f 0100 	mov.w	r1, #0
   18a32:	f363 0107 	bfi	r1, r3, #0, #8
   18a36:	4a1a      	ldr	r2, [pc, #104]	; (18aa0 <bt_l2cap_recv+0x88>)
   18a38:	4b1a      	ldr	r3, [pc, #104]	; (18aa4 <bt_l2cap_recv+0x8c>)
   18a3a:	481b      	ldr	r0, [pc, #108]	; (18aa8 <bt_l2cap_recv+0x90>)
   18a3c:	1a9b      	subs	r3, r3, r2
   18a3e:	08db      	lsrs	r3, r3, #3
   18a40:	f363 118f 	bfi	r1, r3, #6, #10
   18a44:	f00f ff79 	bl	2893a <log_0>
	net_buf_unref(buf);
   18a48:	4620      	mov	r0, r4
}
   18a4a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	net_buf_unref(buf);
   18a4e:	f00c bc3d 	b.w	252cc <net_buf_unref>
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
   18a52:	2104      	movs	r1, #4
   18a54:	f104 0008 	add.w	r0, r4, #8
   18a58:	f014 f8c3 	bl	2cbe2 <net_buf_simple_pull_mem>
	cid = sys_le16_to_cpu(hdr->cid);
   18a5c:	8845      	ldrh	r5, [r0, #2]
	chan = bt_l2cap_le_lookup_rx_cid(conn, cid);
   18a5e:	4630      	mov	r0, r6
   18a60:	4629      	mov	r1, r5
   18a62:	f012 f8d5 	bl	2ac10 <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
   18a66:	b9a0      	cbnz	r0, 18a92 <bt_l2cap_recv+0x7a>
		BT_WARN("Ignoring data for unknown CID 0x%04x", cid);
   18a68:	4b0c      	ldr	r3, [pc, #48]	; (18a9c <bt_l2cap_recv+0x84>)
   18a6a:	681b      	ldr	r3, [r3, #0]
   18a6c:	f013 0f06 	tst.w	r3, #6
   18a70:	d0ea      	beq.n	18a48 <bt_l2cap_recv+0x30>
   18a72:	2302      	movs	r3, #2
   18a74:	f04f 0200 	mov.w	r2, #0
   18a78:	f363 0207 	bfi	r2, r3, #0, #8
   18a7c:	4908      	ldr	r1, [pc, #32]	; (18aa0 <bt_l2cap_recv+0x88>)
   18a7e:	4b09      	ldr	r3, [pc, #36]	; (18aa4 <bt_l2cap_recv+0x8c>)
   18a80:	480a      	ldr	r0, [pc, #40]	; (18aac <bt_l2cap_recv+0x94>)
   18a82:	1a5b      	subs	r3, r3, r1
   18a84:	08db      	lsrs	r3, r3, #3
   18a86:	f363 128f 	bfi	r2, r3, #6, #10
   18a8a:	4629      	mov	r1, r5
   18a8c:	f00f ff62 	bl	28954 <log_1>
   18a90:	e7da      	b.n	18a48 <bt_l2cap_recv+0x30>
	chan->ops->recv(chan, buf);
   18a92:	6843      	ldr	r3, [r0, #4]
   18a94:	4621      	mov	r1, r4
   18a96:	691b      	ldr	r3, [r3, #16]
   18a98:	4798      	blx	r3
   18a9a:	e7d5      	b.n	18a48 <bt_l2cap_recv+0x30>
   18a9c:	20010008 	.word	0x20010008
   18aa0:	0002db28 	.word	0x0002db28
   18aa4:	0002dc08 	.word	0x0002dc08
   18aa8:	00030f8c 	.word	0x00030f8c
   18aac:	00030fa9 	.word	0x00030fa9

00018ab0 <bt_l2cap_update_conn_param>:
{
   18ab0:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ident++;
   18ab2:	4b15      	ldr	r3, [pc, #84]	; (18b08 <bt_l2cap_update_conn_param+0x58>)
   18ab4:	781a      	ldrb	r2, [r3, #0]
   18ab6:	3201      	adds	r2, #1
	if (!ident) {
   18ab8:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
		ident++;
   18abc:	bf08      	it	eq
   18abe:	2201      	moveq	r2, #1
   18ac0:	701a      	strb	r2, [r3, #0]
{
   18ac2:	4605      	mov	r5, r0
   18ac4:	460c      	mov	r4, r1
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CONN_PARAM_REQ,
   18ac6:	2208      	movs	r2, #8
   18ac8:	7819      	ldrb	r1, [r3, #0]
   18aca:	2012      	movs	r0, #18
   18acc:	f7ff fe18 	bl	18700 <l2cap_create_le_sig_pdu.isra.8>
	if (!buf) {
   18ad0:	4606      	mov	r6, r0
   18ad2:	b1b0      	cbz	r0, 18b02 <bt_l2cap_update_conn_param+0x52>
	req = net_buf_add(buf, sizeof(*req));
   18ad4:	2108      	movs	r1, #8
   18ad6:	4408      	add	r0, r1
   18ad8:	f014 f852 	bl	2cb80 <net_buf_simple_add>
	req->min_interval = sys_cpu_to_le16(param->interval_min);
   18adc:	8823      	ldrh	r3, [r4, #0]
   18ade:	8003      	strh	r3, [r0, #0]
	req->max_interval = sys_cpu_to_le16(param->interval_max);
   18ae0:	8863      	ldrh	r3, [r4, #2]
   18ae2:	8043      	strh	r3, [r0, #2]
	req->latency = sys_cpu_to_le16(param->latency);
   18ae4:	88a3      	ldrh	r3, [r4, #4]
   18ae6:	8083      	strh	r3, [r0, #4]
	req->timeout = sys_cpu_to_le16(param->timeout);
   18ae8:	88e3      	ldrh	r3, [r4, #6]
   18aea:	80c3      	strh	r3, [r0, #6]
   18aec:	2400      	movs	r4, #0
   18aee:	9400      	str	r4, [sp, #0]
   18af0:	4623      	mov	r3, r4
   18af2:	4632      	mov	r2, r6
   18af4:	2105      	movs	r1, #5
   18af6:	4628      	mov	r0, r5
   18af8:	f012 f84f 	bl	2ab9a <bt_l2cap_send_cb>
	return 0;
   18afc:	4620      	mov	r0, r4
}
   18afe:	b002      	add	sp, #8
   18b00:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOMEM;
   18b02:	f06f 000b 	mvn.w	r0, #11
   18b06:	e7fa      	b.n	18afe <bt_l2cap_update_conn_param+0x4e>
   18b08:	20003e02 	.word	0x20003e02

00018b0c <find_type_cb>:
	u8_t value_len;
	u8_t err;
};

static u8_t find_type_cb(const struct bt_gatt_attr *attr, void *user_data)
{
   18b0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct find_type_data *data = user_data;
	struct bt_att *att = data->att;
   18b10:	680e      	ldr	r6, [r1, #0]
{
   18b12:	b092      	sub	sp, #72	; 0x48
   18b14:	4605      	mov	r5, r0
   18b16:	460c      	mov	r4, r1
	struct bt_conn *conn = att->chan.chan.conn;
	int read;
	u8_t uuid[16];

	/* Skip secondary services */
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   18b18:	2700      	movs	r7, #0
   18b1a:	f642 0301 	movw	r3, #10241	; 0x2801
   18b1e:	a902      	add	r1, sp, #8
   18b20:	6800      	ldr	r0, [r0, #0]
	struct bt_conn *conn = att->chan.chan.conn;
   18b22:	f8d6 8000 	ldr.w	r8, [r6]
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   18b26:	f88d 7008 	strb.w	r7, [sp, #8]
   18b2a:	f8ad 300a 	strh.w	r3, [sp, #10]
   18b2e:	f011 fdaa 	bl	2a686 <bt_uuid_cmp>
   18b32:	2800      	cmp	r0, #0
   18b34:	d043      	beq.n	18bbe <find_type_cb+0xb2>
		goto skip;
	}

	/* Update group end_handle if not a primary service */
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY)) {
   18b36:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   18b3a:	a903      	add	r1, sp, #12
   18b3c:	6828      	ldr	r0, [r5, #0]
   18b3e:	f88d 700c 	strb.w	r7, [sp, #12]
   18b42:	f8ad 300e 	strh.w	r3, [sp, #14]
   18b46:	f011 fd9e 	bl	2a686 <bt_uuid_cmp>
   18b4a:	b150      	cbz	r0, 18b62 <find_type_cb+0x56>
		if (data->group &&
   18b4c:	68a3      	ldr	r3, [r4, #8]
   18b4e:	b123      	cbz	r3, 18b5a <find_type_cb+0x4e>
		    attr->handle > sys_le16_to_cpu(data->group->end_handle)) {
   18b50:	8a2a      	ldrh	r2, [r5, #16]
		if (data->group &&
   18b52:	8859      	ldrh	r1, [r3, #2]
   18b54:	4291      	cmp	r1, r2
   18b56:	d200      	bcs.n	18b5a <find_type_cb+0x4e>
			data->group->end_handle = sys_cpu_to_le16(attr->handle);
   18b58:	805a      	strh	r2, [r3, #2]
		}
		return BT_GATT_ITER_CONTINUE;
   18b5a:	2001      	movs	r0, #1
	return BT_GATT_ITER_CONTINUE;

skip:
	data->group = NULL;
	return BT_GATT_ITER_CONTINUE;
}
   18b5c:	b012      	add	sp, #72	; 0x48
   18b5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (att->chan.tx.mtu - data->buf->len < sizeof(*data->group)) {
   18b62:	6862      	ldr	r2, [r4, #4]
   18b64:	f8b6 3056 	ldrh.w	r3, [r6, #86]	; 0x56
   18b68:	8992      	ldrh	r2, [r2, #12]
   18b6a:	1a9b      	subs	r3, r3, r2
   18b6c:	2b03      	cmp	r3, #3
   18b6e:	d9f5      	bls.n	18b5c <find_type_cb+0x50>
	read = attr->read(conn, attr, uuid, sizeof(uuid), 0);
   18b70:	2310      	movs	r3, #16
   18b72:	9000      	str	r0, [sp, #0]
   18b74:	686e      	ldr	r6, [r5, #4]
   18b76:	eb0d 0203 	add.w	r2, sp, r3
   18b7a:	4629      	mov	r1, r5
   18b7c:	4640      	mov	r0, r8
   18b7e:	47b0      	blx	r6
	if (read < 0) {
   18b80:	1e06      	subs	r6, r0, #0
   18b82:	db1c      	blt.n	18bbe <find_type_cb+0xb2>
	if (read != data->value_len) {
   18b84:	7c22      	ldrb	r2, [r4, #16]
   18b86:	68e0      	ldr	r0, [r4, #12]
   18b88:	4296      	cmp	r6, r2
   18b8a:	d046      	beq.n	18c1a <find_type_cb+0x10e>
		if (!bt_uuid_create(&recvd_uuid.uuid, data->value, data->value_len)) {
   18b8c:	4601      	mov	r1, r0
   18b8e:	a80d      	add	r0, sp, #52	; 0x34
   18b90:	f011 fda3 	bl	2a6da <bt_uuid_create>
   18b94:	b9b0      	cbnz	r0, 18bc4 <find_type_cb+0xb8>
			BT_WARN("Unable to create UUID: size %u", data->value_len);
   18b96:	4b23      	ldr	r3, [pc, #140]	; (18c24 <find_type_cb+0x118>)
   18b98:	681b      	ldr	r3, [r3, #0]
   18b9a:	f013 0f06 	tst.w	r3, #6
   18b9e:	d00e      	beq.n	18bbe <find_type_cb+0xb2>
   18ba0:	2302      	movs	r3, #2
   18ba2:	f04f 0200 	mov.w	r2, #0
   18ba6:	f363 0207 	bfi	r2, r3, #0, #8
   18baa:	491f      	ldr	r1, [pc, #124]	; (18c28 <find_type_cb+0x11c>)
   18bac:	4b1f      	ldr	r3, [pc, #124]	; (18c2c <find_type_cb+0x120>)
   18bae:	4820      	ldr	r0, [pc, #128]	; (18c30 <find_type_cb+0x124>)
   18bb0:	1a5b      	subs	r3, r3, r1
   18bb2:	08db      	lsrs	r3, r3, #3
   18bb4:	7c21      	ldrb	r1, [r4, #16]
   18bb6:	f363 128f 	bfi	r2, r3, #6, #10
			BT_WARN("Unable to create UUID: size %d", read);
   18bba:	f00f fecb 	bl	28954 <log_1>
	data->group = NULL;
   18bbe:	2300      	movs	r3, #0
   18bc0:	60a3      	str	r3, [r4, #8]
	return BT_GATT_ITER_CONTINUE;
   18bc2:	e7ca      	b.n	18b5a <find_type_cb+0x4e>
		if (!bt_uuid_create(&ref_uuid.uuid, uuid, read)) {
   18bc4:	b2f2      	uxtb	r2, r6
   18bc6:	a904      	add	r1, sp, #16
   18bc8:	a808      	add	r0, sp, #32
   18bca:	f011 fd86 	bl	2a6da <bt_uuid_create>
   18bce:	b990      	cbnz	r0, 18bf6 <find_type_cb+0xea>
			BT_WARN("Unable to create UUID: size %d", read);
   18bd0:	4b14      	ldr	r3, [pc, #80]	; (18c24 <find_type_cb+0x118>)
   18bd2:	681b      	ldr	r3, [r3, #0]
   18bd4:	f013 0f06 	tst.w	r3, #6
   18bd8:	d0f1      	beq.n	18bbe <find_type_cb+0xb2>
   18bda:	2302      	movs	r3, #2
   18bdc:	f04f 0200 	mov.w	r2, #0
   18be0:	f363 0207 	bfi	r2, r3, #0, #8
   18be4:	4910      	ldr	r1, [pc, #64]	; (18c28 <find_type_cb+0x11c>)
   18be6:	4b11      	ldr	r3, [pc, #68]	; (18c2c <find_type_cb+0x120>)
   18be8:	4812      	ldr	r0, [pc, #72]	; (18c34 <find_type_cb+0x128>)
   18bea:	1a5b      	subs	r3, r3, r1
   18bec:	08db      	lsrs	r3, r3, #3
   18bee:	f363 128f 	bfi	r2, r3, #6, #10
   18bf2:	4631      	mov	r1, r6
   18bf4:	e7e1      	b.n	18bba <find_type_cb+0xae>
		if (bt_uuid_cmp(&recvd_uuid.uuid, &ref_uuid.uuid)) {
   18bf6:	a908      	add	r1, sp, #32
   18bf8:	a80d      	add	r0, sp, #52	; 0x34
   18bfa:	f011 fd44 	bl	2a686 <bt_uuid_cmp>
	} else if (memcmp(data->value, uuid, read)) {
   18bfe:	2800      	cmp	r0, #0
   18c00:	d1dd      	bne.n	18bbe <find_type_cb+0xb2>
	data->group = net_buf_add(data->buf, sizeof(*data->group));
   18c02:	6860      	ldr	r0, [r4, #4]
	data->err = 0x00;
   18c04:	2300      	movs	r3, #0
   18c06:	7463      	strb	r3, [r4, #17]
	data->group = net_buf_add(data->buf, sizeof(*data->group));
   18c08:	2104      	movs	r1, #4
   18c0a:	3008      	adds	r0, #8
   18c0c:	f013 ffb8 	bl	2cb80 <net_buf_simple_add>
	data->group->start_handle = sys_cpu_to_le16(attr->handle);
   18c10:	8a2b      	ldrh	r3, [r5, #16]
	data->group = net_buf_add(data->buf, sizeof(*data->group));
   18c12:	60a0      	str	r0, [r4, #8]
	data->group->start_handle = sys_cpu_to_le16(attr->handle);
   18c14:	8003      	strh	r3, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(attr->handle);
   18c16:	8043      	strh	r3, [r0, #2]
	return BT_GATT_ITER_CONTINUE;
   18c18:	e79f      	b.n	18b5a <find_type_cb+0x4e>
	} else if (memcmp(data->value, uuid, read)) {
   18c1a:	4632      	mov	r2, r6
   18c1c:	a904      	add	r1, sp, #16
   18c1e:	f011 fbef 	bl	2a400 <memcmp>
   18c22:	e7ec      	b.n	18bfe <find_type_cb+0xf2>
   18c24:	2000ff9c 	.word	0x2000ff9c
   18c28:	0002db28 	.word	0x0002db28
   18c2c:	0002db30 	.word	0x0002db30
   18c30:	00031248 	.word	0x00031248
   18c34:	00031267 	.word	0x00031267

00018c38 <bt_att_connected>:
	bt_gatt_disconnected(ch->chan.conn);
	ch->chan.conn = NULL;
}

static void bt_att_connected(struct bt_l2cap_chan *chan)
{
   18c38:	b510      	push	{r4, lr}
   18c3a:	4604      	mov	r4, r0
	z_impl_k_queue_init(queue);
   18c3c:	30f4      	adds	r0, #244	; 0xf4
   18c3e:	f014 fa58 	bl	2d0f2 <z_impl_k_queue_init>
	k_fifo_init(&att->tx_queue);
#if CONFIG_BT_ATT_PREPARE_COUNT > 0
	k_fifo_init(&att->prep_queue);
#endif

	ch->tx.mtu = BT_ATT_DEFAULT_LE_MTU;
   18c42:	2317      	movs	r3, #23
   18c44:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
	ch->rx.mtu = BT_ATT_DEFAULT_LE_MTU;
   18c48:	86e3      	strh	r3, [r4, #54]	; 0x36

	k_delayed_work_init(&att->timeout_work, att_timeout);
   18c4a:	4904      	ldr	r1, [pc, #16]	; (18c5c <bt_att_connected+0x24>)
   18c4c:	f104 00bc 	add.w	r0, r4, #188	; 0xbc
   18c50:	f014 fc7f 	bl	2d552 <k_delayed_work_init>
	list->head = NULL;
   18c54:	2300      	movs	r3, #0
	list->tail = NULL;
   18c56:	e9c4 332d 	strd	r3, r3, [r4, #180]	; 0xb4
	sys_slist_init(&att->reqs);
}
   18c5a:	bd10      	pop	{r4, pc}
   18c5c:	00018fd1 	.word	0x00018fd1

00018c60 <att_send>:
{
   18c60:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   18c64:	4698      	mov	r8, r3
	if (hdr->code == BT_ATT_OP_SIGNED_WRITE_CMD) {
   18c66:	688b      	ldr	r3, [r1, #8]
   18c68:	781b      	ldrb	r3, [r3, #0]
   18c6a:	2bd2      	cmp	r3, #210	; 0xd2
{
   18c6c:	4607      	mov	r7, r0
   18c6e:	460c      	mov	r4, r1
   18c70:	4615      	mov	r5, r2
	if (hdr->code == BT_ATT_OP_SIGNED_WRITE_CMD) {
   18c72:	d11c      	bne.n	18cae <att_send+0x4e>
		err = bt_smp_sign(conn, buf);
   18c74:	f012 fe33 	bl	2b8de <bt_smp_sign>
		if (err) {
   18c78:	4606      	mov	r6, r0
   18c7a:	b1c0      	cbz	r0, 18cae <att_send+0x4e>
			BT_ERR("Error signing data");
   18c7c:	4b17      	ldr	r3, [pc, #92]	; (18cdc <att_send+0x7c>)
   18c7e:	681b      	ldr	r3, [r3, #0]
   18c80:	075b      	lsls	r3, r3, #29
   18c82:	d00d      	beq.n	18ca0 <att_send+0x40>
   18c84:	2301      	movs	r3, #1
   18c86:	f04f 0100 	mov.w	r1, #0
   18c8a:	f363 0107 	bfi	r1, r3, #0, #8
   18c8e:	4a14      	ldr	r2, [pc, #80]	; (18ce0 <att_send+0x80>)
   18c90:	4b14      	ldr	r3, [pc, #80]	; (18ce4 <att_send+0x84>)
   18c92:	4815      	ldr	r0, [pc, #84]	; (18ce8 <att_send+0x88>)
   18c94:	1a9b      	subs	r3, r3, r2
   18c96:	08db      	lsrs	r3, r3, #3
   18c98:	f363 118f 	bfi	r1, r3, #6, #10
   18c9c:	f00f fe4d 	bl	2893a <log_0>
			net_buf_unref(buf);
   18ca0:	4620      	mov	r0, r4
   18ca2:	f00c fb13 	bl	252cc <net_buf_unref>
}
   18ca6:	4630      	mov	r0, r6
   18ca8:	b002      	add	sp, #8
   18caa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf,
   18cae:	b95d      	cbnz	r5, 18cc8 <att_send+0x68>
	switch (att_op_get_type(buf->data[0])) {
   18cb0:	68a3      	ldr	r3, [r4, #8]
   18cb2:	7818      	ldrb	r0, [r3, #0]
   18cb4:	f011 ffb9 	bl	2ac2a <att_op_get_type>
   18cb8:	3801      	subs	r0, #1
   18cba:	b2c0      	uxtb	r0, r0
   18cbc:	2804      	cmp	r0, #4
   18cbe:	bf96      	itet	ls
   18cc0:	4b0a      	ldrls	r3, [pc, #40]	; (18cec <att_send+0x8c>)
   18cc2:	4d0b      	ldrhi	r5, [pc, #44]	; (18cf0 <att_send+0x90>)
   18cc4:	f853 5020 	ldrls.w	r5, [r3, r0, lsl #2]
	return bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf,
   18cc8:	f8cd 8000 	str.w	r8, [sp]
   18ccc:	462b      	mov	r3, r5
   18cce:	4622      	mov	r2, r4
   18cd0:	2104      	movs	r1, #4
   18cd2:	4638      	mov	r0, r7
   18cd4:	f011 ff61 	bl	2ab9a <bt_l2cap_send_cb>
   18cd8:	4606      	mov	r6, r0
   18cda:	e7e4      	b.n	18ca6 <att_send+0x46>
   18cdc:	2000ff9c 	.word	0x2000ff9c
   18ce0:	0002db28 	.word	0x0002db28
   18ce4:	0002db30 	.word	0x0002db30
   18ce8:	00031150 	.word	0x00031150
   18cec:	0002e54c 	.word	0x0002e54c
   18cf0:	0002af41 	.word	0x0002af41

00018cf4 <bt_att_accept>:
	att->req->buf = NULL;
}
#endif /* CONFIG_BT_SMP */

static int bt_att_accept(struct bt_conn *conn, struct bt_l2cap_chan **chan)
{
   18cf4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_req_pool); i++) {
		struct bt_att *att = &bt_req_pool[i];

		if (att->chan.chan.conn) {
   18cf8:	4f1b      	ldr	r7, [pc, #108]	; (18d68 <bt_att_accept+0x74>)
{
   18cfa:	4688      	mov	r8, r1
	for (i = 0; i < ARRAY_SIZE(bt_req_pool); i++) {
   18cfc:	2300      	movs	r3, #0
   18cfe:	f44f 7282 	mov.w	r2, #260	; 0x104
		if (att->chan.chan.conn) {
   18d02:	fb02 f503 	mul.w	r5, r2, r3
   18d06:	59ec      	ldr	r4, [r5, r7]
   18d08:	b1c4      	cbz	r4, 18d3c <bt_att_accept+0x48>
	for (i = 0; i < ARRAY_SIZE(bt_req_pool); i++) {
   18d0a:	3301      	adds	r3, #1
   18d0c:	2b05      	cmp	r3, #5
   18d0e:	d1f8      	bne.n	18d02 <bt_att_accept+0xe>
		*chan = &att->chan.chan;

		return 0;
	}

	BT_ERR("No available ATT context for conn %p", conn);
   18d10:	4b16      	ldr	r3, [pc, #88]	; (18d6c <bt_att_accept+0x78>)
   18d12:	681b      	ldr	r3, [r3, #0]
   18d14:	075b      	lsls	r3, r3, #29
   18d16:	d00e      	beq.n	18d36 <bt_att_accept+0x42>
   18d18:	2301      	movs	r3, #1
   18d1a:	f04f 0200 	mov.w	r2, #0
   18d1e:	f363 0207 	bfi	r2, r3, #0, #8
   18d22:	4913      	ldr	r1, [pc, #76]	; (18d70 <bt_att_accept+0x7c>)
   18d24:	4b13      	ldr	r3, [pc, #76]	; (18d74 <bt_att_accept+0x80>)
   18d26:	1a5b      	subs	r3, r3, r1
   18d28:	08db      	lsrs	r3, r3, #3
   18d2a:	4601      	mov	r1, r0
   18d2c:	f363 128f 	bfi	r2, r3, #6, #10
   18d30:	4811      	ldr	r0, [pc, #68]	; (18d78 <bt_att_accept+0x84>)
   18d32:	f00f fe0f 	bl	28954 <log_1>

	return -ENOMEM;
   18d36:	f06f 000b 	mvn.w	r0, #11
   18d3a:	e012      	b.n	18d62 <bt_att_accept+0x6e>
		struct bt_att *att = &bt_req_pool[i];
   18d3c:	197e      	adds	r6, r7, r5
		(void)memset(att, 0, sizeof(*att));
   18d3e:	f44f 7282 	mov.w	r2, #260	; 0x104
   18d42:	4621      	mov	r1, r4
   18d44:	4630      	mov	r0, r6
   18d46:	f011 fbac 	bl	2a4a2 <memset>
		att->chan.chan.ops = &ops;
   18d4a:	4b0c      	ldr	r3, [pc, #48]	; (18d7c <bt_att_accept+0x88>)
   18d4c:	6073      	str	r3, [r6, #4]
	z_impl_k_sem_init(sem, initial_count, limit);
   18d4e:	2206      	movs	r2, #6
		k_sem_init(&att->tx_sem, CONFIG_BT_ATT_TX_MAX,
   18d50:	f105 00dc 	add.w	r0, r5, #220	; 0xdc
   18d54:	4438      	add	r0, r7
   18d56:	4611      	mov	r1, r2
   18d58:	f014 fb55 	bl	2d406 <z_impl_k_sem_init>
		*chan = &att->chan.chan;
   18d5c:	f8c8 6000 	str.w	r6, [r8]
		return 0;
   18d60:	4620      	mov	r0, r4
}
   18d62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   18d66:	bf00      	nop
   18d68:	20001208 	.word	0x20001208
   18d6c:	2000ff9c 	.word	0x2000ff9c
   18d70:	0002db28 	.word	0x0002db28
   18d74:	0002db30 	.word	0x0002db30
   18d78:	0003116f 	.word	0x0003116f
   18d7c:	2000fa08 	.word	0x2000fa08

00018d80 <att_chan_get>:
	if (conn->state != BT_CONN_CONNECTED) {
   18d80:	7a81      	ldrb	r1, [r0, #10]
   18d82:	2904      	cmp	r1, #4
{
   18d84:	b510      	push	{r4, lr}
	if (conn->state != BT_CONN_CONNECTED) {
   18d86:	d015      	beq.n	18db4 <att_chan_get+0x34>
		BT_WARN("Not connected");
   18d88:	4b23      	ldr	r3, [pc, #140]	; (18e18 <att_chan_get+0x98>)
   18d8a:	681b      	ldr	r3, [r3, #0]
   18d8c:	f013 0f06 	tst.w	r3, #6
   18d90:	d101      	bne.n	18d96 <att_chan_get+0x16>
		return NULL;
   18d92:	2400      	movs	r4, #0
   18d94:	e024      	b.n	18de0 <att_chan_get+0x60>
		BT_WARN("Not connected");
   18d96:	2302      	movs	r3, #2
   18d98:	f04f 0100 	mov.w	r1, #0
   18d9c:	f363 0107 	bfi	r1, r3, #0, #8
   18da0:	4a1e      	ldr	r2, [pc, #120]	; (18e1c <att_chan_get+0x9c>)
   18da2:	4b1f      	ldr	r3, [pc, #124]	; (18e20 <att_chan_get+0xa0>)
   18da4:	481f      	ldr	r0, [pc, #124]	; (18e24 <att_chan_get+0xa4>)
   18da6:	1a9b      	subs	r3, r3, r2
   18da8:	08db      	lsrs	r3, r3, #3
   18daa:	f363 118f 	bfi	r1, r3, #6, #10
		BT_WARN("ATT context flagged as disconnected");
   18dae:	f00f fdc4 	bl	2893a <log_0>
   18db2:	e7ee      	b.n	18d92 <att_chan_get+0x12>
	chan = bt_l2cap_le_lookup_rx_cid(conn, BT_L2CAP_CID_ATT);
   18db4:	f011 ff2c 	bl	2ac10 <bt_l2cap_le_lookup_rx_cid>
	if (!chan) {
   18db8:	4604      	mov	r4, r0
   18dba:	b998      	cbnz	r0, 18de4 <att_chan_get+0x64>
		BT_ERR("Unable to find ATT channel");
   18dbc:	4b16      	ldr	r3, [pc, #88]	; (18e18 <att_chan_get+0x98>)
   18dbe:	681b      	ldr	r3, [r3, #0]
   18dc0:	075a      	lsls	r2, r3, #29
   18dc2:	d0e6      	beq.n	18d92 <att_chan_get+0x12>
   18dc4:	2301      	movs	r3, #1
   18dc6:	f04f 0100 	mov.w	r1, #0
   18dca:	f363 0107 	bfi	r1, r3, #0, #8
   18dce:	4a13      	ldr	r2, [pc, #76]	; (18e1c <att_chan_get+0x9c>)
   18dd0:	4b13      	ldr	r3, [pc, #76]	; (18e20 <att_chan_get+0xa0>)
   18dd2:	4815      	ldr	r0, [pc, #84]	; (18e28 <att_chan_get+0xa8>)
   18dd4:	1a9b      	subs	r3, r3, r2
   18dd6:	08db      	lsrs	r3, r3, #3
   18dd8:	f363 118f 	bfi	r1, r3, #6, #10
   18ddc:	f00f fdad 	bl	2893a <log_0>
}
   18de0:	4620      	mov	r0, r4
   18de2:	bd10      	pop	{r4, pc}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   18de4:	f3bf 8f5b 	dmb	ish
   18de8:	f8d0 30ac 	ldr.w	r3, [r0, #172]	; 0xac
   18dec:	f3bf 8f5b 	dmb	ish
	if (atomic_test_bit(att->flags, ATT_DISCONNECTED)) {
   18df0:	075b      	lsls	r3, r3, #29
   18df2:	d5f5      	bpl.n	18de0 <att_chan_get+0x60>
		BT_WARN("ATT context flagged as disconnected");
   18df4:	4b08      	ldr	r3, [pc, #32]	; (18e18 <att_chan_get+0x98>)
   18df6:	681b      	ldr	r3, [r3, #0]
   18df8:	f013 0f06 	tst.w	r3, #6
   18dfc:	d0c9      	beq.n	18d92 <att_chan_get+0x12>
   18dfe:	2302      	movs	r3, #2
   18e00:	f04f 0100 	mov.w	r1, #0
   18e04:	f363 0107 	bfi	r1, r3, #0, #8
   18e08:	4a04      	ldr	r2, [pc, #16]	; (18e1c <att_chan_get+0x9c>)
   18e0a:	4b05      	ldr	r3, [pc, #20]	; (18e20 <att_chan_get+0xa0>)
   18e0c:	4807      	ldr	r0, [pc, #28]	; (18e2c <att_chan_get+0xac>)
   18e0e:	1a9b      	subs	r3, r3, r2
   18e10:	08db      	lsrs	r3, r3, #3
   18e12:	f363 118f 	bfi	r1, r3, #6, #10
   18e16:	e7ca      	b.n	18dae <att_chan_get+0x2e>
   18e18:	2000ff9c 	.word	0x2000ff9c
   18e1c:	0002db28 	.word	0x0002db28
   18e20:	0002db30 	.word	0x0002db30
   18e24:	0002f247 	.word	0x0002f247
   18e28:	000310fa 	.word	0x000310fa
   18e2c:	00031115 	.word	0x00031115

00018e30 <att_req_sent>:
{
   18e30:	b538      	push	{r3, r4, r5, lr}
   18e32:	460d      	mov	r5, r1
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   18e34:	2104      	movs	r1, #4
{
   18e36:	4604      	mov	r4, r0
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   18e38:	f011 fedf 	bl	2abfa <bt_l2cap_le_lookup_tx_cid>
	if (att->req) {
   18e3c:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
   18e40:	b133      	cbz	r3, 18e50 <att_req_sent+0x20>
   18e42:	f100 01bc 	add.w	r1, r0, #188	; 0xbc
   18e46:	f247 5230 	movw	r2, #30000	; 0x7530
   18e4a:	4804      	ldr	r0, [pc, #16]	; (18e5c <att_req_sent+0x2c>)
   18e4c:	f00e faf6 	bl	2743c <k_delayed_work_submit_to_queue>
	att_pdu_sent(conn, user_data);
   18e50:	4629      	mov	r1, r5
   18e52:	4620      	mov	r0, r4
}
   18e54:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	att_pdu_sent(conn, user_data);
   18e58:	f012 b872 	b.w	2af40 <att_pdu_sent>
   18e5c:	20003b5c 	.word	0x20003b5c

00018e60 <att_send_req>:
{
   18e60:	b573      	push	{r0, r1, r4, r5, r6, lr}
   18e62:	4605      	mov	r5, r0
   18e64:	460c      	mov	r4, r1
	att->req = req;
   18e66:	f8c5 10b0 	str.w	r1, [r5, #176]	; 0xb0
	return z_impl_k_sem_take(sem, timeout);
   18e6a:	2100      	movs	r1, #0
   18e6c:	30dc      	adds	r0, #220	; 0xdc
   18e6e:	f00e f977 	bl	27160 <z_impl_k_sem_take>
	if (k_sem_take(&att->tx_sem, K_NO_WAIT) < 0) {
   18e72:	2800      	cmp	r0, #0
   18e74:	da08      	bge.n	18e88 <att_send_req+0x28>
		k_fifo_put(&att->tx_queue, req->buf);
   18e76:	f105 00f4 	add.w	r0, r5, #244	; 0xf4
   18e7a:	6921      	ldr	r1, [r4, #16]
   18e7c:	f014 f941 	bl	2d102 <k_queue_append>
		return 0;
   18e80:	2500      	movs	r5, #0
}
   18e82:	4628      	mov	r0, r5
   18e84:	b002      	add	sp, #8
   18e86:	bd70      	pop	{r4, r5, r6, pc}
	net_buf_simple_save(&req->buf->b, &req->state);
   18e88:	6926      	ldr	r6, [r4, #16]
	state->offset = net_buf_simple_headroom(buf);
   18e8a:	f106 0008 	add.w	r0, r6, #8
   18e8e:	f013 fec0 	bl	2cc12 <net_buf_simple_headroom>
	state->len = buf->len;
   18e92:	89b3      	ldrh	r3, [r6, #12]
	state->offset = net_buf_simple_headroom(buf);
   18e94:	81a0      	strh	r0, [r4, #12]
	state->len = buf->len;
   18e96:	81e3      	strh	r3, [r4, #14]
	err = bt_l2cap_send_cb(att->chan.chan.conn, BT_L2CAP_CID_ATT,
   18e98:	6920      	ldr	r0, [r4, #16]
   18e9a:	682d      	ldr	r5, [r5, #0]
   18e9c:	f013 fe6c 	bl	2cb78 <net_buf_ref>
   18ea0:	6923      	ldr	r3, [r4, #16]
	switch (att_op_get_type(buf->data[0])) {
   18ea2:	689b      	ldr	r3, [r3, #8]
	err = bt_l2cap_send_cb(att->chan.chan.conn, BT_L2CAP_CID_ATT,
   18ea4:	4602      	mov	r2, r0
	switch (att_op_get_type(buf->data[0])) {
   18ea6:	7818      	ldrb	r0, [r3, #0]
   18ea8:	f011 febf 	bl	2ac2a <att_op_get_type>
   18eac:	3801      	subs	r0, #1
   18eae:	b2c0      	uxtb	r0, r0
   18eb0:	2804      	cmp	r0, #4
   18eb2:	bf96      	itet	ls
   18eb4:	4b08      	ldrls	r3, [pc, #32]	; (18ed8 <att_send_req+0x78>)
   18eb6:	4b09      	ldrhi	r3, [pc, #36]	; (18edc <att_send_req+0x7c>)
   18eb8:	f853 3020 	ldrls.w	r3, [r3, r0, lsl #2]
	err = bt_l2cap_send_cb(att->chan.chan.conn, BT_L2CAP_CID_ATT,
   18ebc:	2600      	movs	r6, #0
   18ebe:	4628      	mov	r0, r5
   18ec0:	9600      	str	r6, [sp, #0]
   18ec2:	2104      	movs	r1, #4
   18ec4:	f011 fe69 	bl	2ab9a <bt_l2cap_send_cb>
	if (err) {
   18ec8:	4605      	mov	r5, r0
   18eca:	2800      	cmp	r0, #0
   18ecc:	d0d9      	beq.n	18e82 <att_send_req+0x22>
		net_buf_unref(req->buf);
   18ece:	6920      	ldr	r0, [r4, #16]
   18ed0:	f00c f9fc 	bl	252cc <net_buf_unref>
		req->buf = NULL;
   18ed4:	6126      	str	r6, [r4, #16]
		return err;
   18ed6:	e7d4      	b.n	18e82 <att_send_req+0x22>
   18ed8:	0002e54c 	.word	0x0002e54c
   18edc:	0002af41 	.word	0x0002af41

00018ee0 <att_handle_rsp>:
{
   18ee0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   18ee4:	4604      	mov	r4, r0
	k_delayed_work_cancel(&att->timeout_work);
   18ee6:	30bc      	adds	r0, #188	; 0xbc
{
   18ee8:	461e      	mov	r6, r3
   18eea:	460f      	mov	r7, r1
   18eec:	4690      	mov	r8, r2
	k_delayed_work_cancel(&att->timeout_work);
   18eee:	f014 fb38 	bl	2d562 <k_delayed_work_cancel>
	if (!att->req) {
   18ef2:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
   18ef6:	bb2b      	cbnz	r3, 18f44 <att_handle_rsp+0x64>
		BT_WARN("No pending ATT request");
   18ef8:	4b23      	ldr	r3, [pc, #140]	; (18f88 <att_handle_rsp+0xa8>)
   18efa:	681b      	ldr	r3, [r3, #0]
   18efc:	f013 0f06 	tst.w	r3, #6
   18f00:	d00d      	beq.n	18f1e <att_handle_rsp+0x3e>
   18f02:	2302      	movs	r3, #2
   18f04:	f04f 0100 	mov.w	r1, #0
   18f08:	f363 0107 	bfi	r1, r3, #0, #8
   18f0c:	4a1f      	ldr	r2, [pc, #124]	; (18f8c <att_handle_rsp+0xac>)
   18f0e:	4b20      	ldr	r3, [pc, #128]	; (18f90 <att_handle_rsp+0xb0>)
   18f10:	4820      	ldr	r0, [pc, #128]	; (18f94 <att_handle_rsp+0xb4>)
   18f12:	1a9b      	subs	r3, r3, r2
   18f14:	08db      	lsrs	r3, r3, #3
   18f16:	f363 118f 	bfi	r1, r3, #6, #10
   18f1a:	f00f fd0e 	bl	2893a <log_0>
Z_GENLIST_IS_EMPTY(slist)
   18f1e:	f8d4 10b4 	ldr.w	r1, [r4, #180]	; 0xb4
Z_GENLIST_GET(slist, snode)
   18f22:	b159      	cbz	r1, 18f3c <att_handle_rsp+0x5c>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   18f24:	f8d4 20b8 	ldr.w	r2, [r4, #184]	; 0xb8
   18f28:	680b      	ldr	r3, [r1, #0]
	list->head = node;
   18f2a:	f8c4 30b4 	str.w	r3, [r4, #180]	; 0xb4
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   18f2e:	4291      	cmp	r1, r2
	list->tail = node;
   18f30:	bf08      	it	eq
   18f32:	f8c4 30b8 	streq.w	r3, [r4, #184]	; 0xb8
	att_send_req(att, ATT_REQ(node));
   18f36:	4620      	mov	r0, r4
   18f38:	f7ff ff92 	bl	18e60 <att_send_req>
}
   18f3c:	2000      	movs	r0, #0
   18f3e:	b002      	add	sp, #8
   18f40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (att->req == &cancel) {
   18f44:	4a14      	ldr	r2, [pc, #80]	; (18f98 <att_handle_rsp+0xb8>)
   18f46:	4293      	cmp	r3, r2
   18f48:	d103      	bne.n	18f52 <att_handle_rsp+0x72>
		att->req = NULL;
   18f4a:	2300      	movs	r3, #0
   18f4c:	f8c4 30b0 	str.w	r3, [r4, #176]	; 0xb0
		goto process;
   18f50:	e7e5      	b.n	18f1e <att_handle_rsp+0x3e>
	if (att->req->buf) {
   18f52:	6918      	ldr	r0, [r3, #16]
   18f54:	b128      	cbz	r0, 18f62 <att_handle_rsp+0x82>
		net_buf_unref(att->req->buf);
   18f56:	f00c f9b9 	bl	252cc <net_buf_unref>
		att->req->buf = NULL;
   18f5a:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
   18f5e:	2200      	movs	r2, #0
   18f60:	611a      	str	r2, [r3, #16]
	func = att->req->func;
   18f62:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
	func(att->chan.chan.conn, err, pdu, len, att->req);
   18f66:	6820      	ldr	r0, [r4, #0]
	func = att->req->func;
   18f68:	685d      	ldr	r5, [r3, #4]
	att->req->func = NULL;
   18f6a:	2200      	movs	r2, #0
   18f6c:	605a      	str	r2, [r3, #4]
	func(att->chan.chan.conn, err, pdu, len, att->req);
   18f6e:	4631      	mov	r1, r6
   18f70:	9300      	str	r3, [sp, #0]
   18f72:	463a      	mov	r2, r7
   18f74:	4643      	mov	r3, r8
   18f76:	47a8      	blx	r5
	if (!att->req->func) {
   18f78:	f8d4 00b0 	ldr.w	r0, [r4, #176]	; 0xb0
   18f7c:	6843      	ldr	r3, [r0, #4]
   18f7e:	2b00      	cmp	r3, #0
   18f80:	d1e3      	bne.n	18f4a <att_handle_rsp+0x6a>
		att_req_destroy(att->req);
   18f82:	f011 fe9f 	bl	2acc4 <att_req_destroy>
   18f86:	e7e0      	b.n	18f4a <att_handle_rsp+0x6a>
   18f88:	2000ff9c 	.word	0x2000ff9c
   18f8c:	0002db28 	.word	0x0002db28
   18f90:	0002db30 	.word	0x0002db30
   18f94:	00031139 	.word	0x00031139
   18f98:	2000171c 	.word	0x2000171c

00018f9c <att_error_rsp>:
	if (!att->req || att->req == &cancel) {
   18f9c:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
{
   18fa0:	b430      	push	{r4, r5}
	if (!att->req || att->req == &cancel) {
   18fa2:	b18b      	cbz	r3, 18fc8 <att_error_rsp+0x2c>
   18fa4:	4a09      	ldr	r2, [pc, #36]	; (18fcc <att_error_rsp+0x30>)
   18fa6:	4293      	cmp	r3, r2
   18fa8:	d00e      	beq.n	18fc8 <att_error_rsp+0x2c>
	if (att->req->buf) {
   18faa:	691a      	ldr	r2, [r3, #16]
	rsp = (void *)buf->data;
   18fac:	688c      	ldr	r4, [r1, #8]
	if (att->req->buf) {
   18fae:	b12a      	cbz	r2, 18fbc <att_error_rsp+0x20>
	buf->data = buf->__buf + state->offset;
   18fb0:	899d      	ldrh	r5, [r3, #12]
   18fb2:	6911      	ldr	r1, [r2, #16]
	buf->len = state->len;
   18fb4:	89db      	ldrh	r3, [r3, #14]
   18fb6:	8193      	strh	r3, [r2, #12]
	buf->data = buf->__buf + state->offset;
   18fb8:	4429      	add	r1, r5
   18fba:	6091      	str	r1, [r2, #8]
	err = rsp->error;
   18fbc:	78e3      	ldrb	r3, [r4, #3]
	return att_handle_rsp(att, NULL, 0, err);
   18fbe:	2200      	movs	r2, #0
   18fc0:	4611      	mov	r1, r2
}
   18fc2:	bc30      	pop	{r4, r5}
	return att_handle_rsp(att, NULL, 0, err);
   18fc4:	f7ff bf8c 	b.w	18ee0 <att_handle_rsp>
		err = BT_ATT_ERR_UNLIKELY;
   18fc8:	230e      	movs	r3, #14
   18fca:	e7f8      	b.n	18fbe <att_error_rsp+0x22>
   18fcc:	2000171c 	.word	0x2000171c

00018fd0 <att_timeout>:
{
   18fd0:	b538      	push	{r3, r4, r5, lr}
	BT_ERR("ATT Timeout");
   18fd2:	4b10      	ldr	r3, [pc, #64]	; (19014 <att_timeout+0x44>)
   18fd4:	681b      	ldr	r3, [r3, #0]
   18fd6:	075b      	lsls	r3, r3, #29
{
   18fd8:	4604      	mov	r4, r0
	struct bt_att *att = CONTAINER_OF(work, struct bt_att, timeout_work);
   18fda:	f1a0 05bc 	sub.w	r5, r0, #188	; 0xbc
	BT_ERR("ATT Timeout");
   18fde:	d00d      	beq.n	18ffc <att_timeout+0x2c>
   18fe0:	2301      	movs	r3, #1
   18fe2:	f04f 0100 	mov.w	r1, #0
   18fe6:	f363 0107 	bfi	r1, r3, #0, #8
   18fea:	4a0b      	ldr	r2, [pc, #44]	; (19018 <att_timeout+0x48>)
   18fec:	4b0b      	ldr	r3, [pc, #44]	; (1901c <att_timeout+0x4c>)
   18fee:	480c      	ldr	r0, [pc, #48]	; (19020 <att_timeout+0x50>)
   18ff0:	1a9b      	subs	r3, r3, r2
   18ff2:	08db      	lsrs	r3, r3, #3
   18ff4:	f363 118f 	bfi	r1, r3, #6, #10
   18ff8:	f00f fc9f 	bl	2893a <log_0>
	att_reset(att);
   18ffc:	4628      	mov	r0, r5
   18ffe:	f012 f897 	bl	2b130 <att_reset>
	bt_gatt_disconnected(ch->chan.conn);
   19002:	f854 0cbc 	ldr.w	r0, [r4, #-188]
   19006:	f002 fae5 	bl	1b5d4 <bt_gatt_disconnected>
	ch->chan.conn = NULL;
   1900a:	2300      	movs	r3, #0
   1900c:	f844 3cbc 	str.w	r3, [r4, #-188]
}
   19010:	bd38      	pop	{r3, r4, r5, pc}
   19012:	bf00      	nop
   19014:	2000ff9c 	.word	0x2000ff9c
   19018:	0002db28 	.word	0x0002db28
   1901c:	0002db30 	.word	0x0002db30
   19020:	00031163 	.word	0x00031163

00019024 <att_write_cmd>:
{
   19024:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct bt_conn *conn = att->chan.chan.conn;
   19026:	6804      	ldr	r4, [r0, #0]
{
   19028:	b089      	sub	sp, #36	; 0x24
	handle = net_buf_pull_le16(buf);
   1902a:	f101 0008 	add.w	r0, r1, #8
{
   1902e:	460d      	mov	r5, r1
	handle = net_buf_pull_le16(buf);
   19030:	f013 fde7 	bl	2cc02 <net_buf_simple_pull_le16>
	if (!bt_gatt_change_aware(conn, req ? true : false)) {
   19034:	2100      	movs	r1, #0
	handle = net_buf_pull_le16(buf);
   19036:	4606      	mov	r6, r0
	if (!bt_gatt_change_aware(conn, req ? true : false)) {
   19038:	4620      	mov	r0, r4
	return att_write_rsp(conn, 0, 0, handle, 0, buf->data, buf->len);
   1903a:	68af      	ldr	r7, [r5, #8]
   1903c:	89ad      	ldrh	r5, [r5, #12]
	if (!bt_gatt_change_aware(conn, req ? true : false)) {
   1903e:	f012 fc05 	bl	2b84c <bt_gatt_change_aware>
   19042:	b328      	cbz	r0, 19090 <att_write_cmd+0x6c>
	if (!handle) {
   19044:	b336      	cbz	r6, 19094 <att_write_cmd+0x70>
	(void)memset(&data, 0, sizeof(data));
   19046:	2218      	movs	r2, #24
   19048:	2100      	movs	r1, #0
   1904a:	a802      	add	r0, sp, #8
   1904c:	f011 fa29 	bl	2a4a2 <memset>
	data.req = req;
   19050:	2300      	movs	r3, #0
   19052:	f88d 3010 	strb.w	r3, [sp, #16]
	data.offset = offset;
   19056:	f8ad 301a 	strh.w	r3, [sp, #26]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
   1905a:	2301      	movs	r3, #1
   1905c:	f88d 301c 	strb.w	r3, [sp, #28]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
   19060:	4a0d      	ldr	r2, [pc, #52]	; (19098 <att_write_cmd+0x74>)
	data.conn = conn;
   19062:	9402      	str	r4, [sp, #8]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
   19064:	ab02      	add	r3, sp, #8
   19066:	4631      	mov	r1, r6
   19068:	4630      	mov	r0, r6
	data.value = value;
   1906a:	9705      	str	r7, [sp, #20]
	data.len = len;
   1906c:	f8ad 5018 	strh.w	r5, [sp, #24]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
   19070:	f011 fe48 	bl	2ad04 <bt_gatt_foreach_attr>
	if (data.err) {
   19074:	f89d 301c 	ldrb.w	r3, [sp, #28]
   19078:	b93b      	cbnz	r3, 1908a <att_write_cmd+0x66>
	if (data.buf) {
   1907a:	9a03      	ldr	r2, [sp, #12]
   1907c:	b12a      	cbz	r2, 1908a <att_write_cmd+0x66>
		(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf,
   1907e:	9300      	str	r3, [sp, #0]
   19080:	2104      	movs	r1, #4
   19082:	4b06      	ldr	r3, [pc, #24]	; (1909c <att_write_cmd+0x78>)
   19084:	4620      	mov	r0, r4
   19086:	f011 fd88 	bl	2ab9a <bt_l2cap_send_cb>
   1908a:	2000      	movs	r0, #0
}
   1908c:	b009      	add	sp, #36	; 0x24
   1908e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
   19090:	2012      	movs	r0, #18
   19092:	e7fb      	b.n	1908c <att_write_cmd+0x68>
		return BT_ATT_ERR_INVALID_HANDLE;
   19094:	2001      	movs	r0, #1
   19096:	e7f9      	b.n	1908c <att_write_cmd+0x68>
   19098:	0002affd 	.word	0x0002affd
   1909c:	0002afcb 	.word	0x0002afcb

000190a0 <bt_att_create_pdu>:
{
   190a0:	b538      	push	{r3, r4, r5, lr}
   190a2:	460d      	mov	r5, r1
   190a4:	4614      	mov	r4, r2
	att = att_chan_get(conn);
   190a6:	f7ff fe6b 	bl	18d80 <att_chan_get>
	if (!att) {
   190aa:	b910      	cbnz	r0, 190b2 <bt_att_create_pdu+0x12>
		return NULL;
   190ac:	2400      	movs	r4, #0
}
   190ae:	4620      	mov	r0, r4
   190b0:	bd38      	pop	{r3, r4, r5, pc}
	if (len + sizeof(op) > att->chan.tx.mtu) {
   190b2:	f8b0 1056 	ldrh.w	r1, [r0, #86]	; 0x56
   190b6:	1c62      	adds	r2, r4, #1
   190b8:	428a      	cmp	r2, r1
   190ba:	d913      	bls.n	190e4 <bt_att_create_pdu+0x44>
		BT_WARN("ATT MTU exceeded, max %u, wanted %zu",
   190bc:	4b1f      	ldr	r3, [pc, #124]	; (1913c <bt_att_create_pdu+0x9c>)
   190be:	681b      	ldr	r3, [r3, #0]
   190c0:	f013 0f06 	tst.w	r3, #6
   190c4:	d0f2      	beq.n	190ac <bt_att_create_pdu+0xc>
   190c6:	2002      	movs	r0, #2
   190c8:	f04f 0300 	mov.w	r3, #0
   190cc:	f360 0307 	bfi	r3, r0, #0, #8
   190d0:	4c1b      	ldr	r4, [pc, #108]	; (19140 <bt_att_create_pdu+0xa0>)
   190d2:	481c      	ldr	r0, [pc, #112]	; (19144 <bt_att_create_pdu+0xa4>)
   190d4:	1b00      	subs	r0, r0, r4
   190d6:	08c0      	lsrs	r0, r0, #3
   190d8:	f360 138f 	bfi	r3, r0, #6, #10
   190dc:	481a      	ldr	r0, [pc, #104]	; (19148 <bt_att_create_pdu+0xa8>)
   190de:	f00f fc4d 	bl	2897c <log_2>
   190e2:	e7e3      	b.n	190ac <bt_att_create_pdu+0xc>
	switch (att_op_get_type(op)) {
   190e4:	4628      	mov	r0, r5
   190e6:	f011 fda0 	bl	2ac2a <att_op_get_type>
   190ea:	2802      	cmp	r0, #2
   190ec:	d001      	beq.n	190f2 <bt_att_create_pdu+0x52>
   190ee:	2804      	cmp	r0, #4
   190f0:	d11b      	bne.n	1912a <bt_att_create_pdu+0x8a>
		buf = bt_l2cap_create_pdu_timeout(NULL, 0, ATT_TIMEOUT);
   190f2:	f247 5230 	movw	r2, #30000	; 0x7530
		buf = bt_l2cap_create_pdu(NULL, 0);
   190f6:	2100      	movs	r1, #0
   190f8:	4608      	mov	r0, r1
   190fa:	f011 fd4b 	bl	2ab94 <bt_l2cap_create_pdu_timeout>
   190fe:	4604      	mov	r4, r0
	if (!buf) {
   19100:	b9b0      	cbnz	r0, 19130 <bt_att_create_pdu+0x90>
		BT_ERR("Unable to allocate buffer for op 0x%02x", op);
   19102:	4b0e      	ldr	r3, [pc, #56]	; (1913c <bt_att_create_pdu+0x9c>)
   19104:	681b      	ldr	r3, [r3, #0]
   19106:	075b      	lsls	r3, r3, #29
   19108:	d0d0      	beq.n	190ac <bt_att_create_pdu+0xc>
   1910a:	2301      	movs	r3, #1
   1910c:	f04f 0200 	mov.w	r2, #0
   19110:	f363 0207 	bfi	r2, r3, #0, #8
   19114:	490a      	ldr	r1, [pc, #40]	; (19140 <bt_att_create_pdu+0xa0>)
   19116:	4b0b      	ldr	r3, [pc, #44]	; (19144 <bt_att_create_pdu+0xa4>)
   19118:	480c      	ldr	r0, [pc, #48]	; (1914c <bt_att_create_pdu+0xac>)
   1911a:	1a5b      	subs	r3, r3, r1
   1911c:	08db      	lsrs	r3, r3, #3
   1911e:	f363 128f 	bfi	r2, r3, #6, #10
   19122:	4629      	mov	r1, r5
   19124:	f00f fc16 	bl	28954 <log_1>
   19128:	e7c1      	b.n	190ae <bt_att_create_pdu+0xe>
		buf = bt_l2cap_create_pdu(NULL, 0);
   1912a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1912e:	e7e2      	b.n	190f6 <bt_att_create_pdu+0x56>
	hdr = net_buf_add(buf, sizeof(*hdr));
   19130:	2101      	movs	r1, #1
   19132:	3008      	adds	r0, #8
   19134:	f013 fd24 	bl	2cb80 <net_buf_simple_add>
	hdr->code = op;
   19138:	7005      	strb	r5, [r0, #0]
	return buf;
   1913a:	e7b8      	b.n	190ae <bt_att_create_pdu+0xe>
   1913c:	2000ff9c 	.word	0x2000ff9c
   19140:	0002db28 	.word	0x0002db28
   19144:	0002db30 	.word	0x0002db30
   19148:	00031194 	.word	0x00031194
   1914c:	00030ff5 	.word	0x00030ff5

00019150 <att_indicate>:
{
   19150:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct bt_conn *conn = att->chan.chan.conn;
   19152:	6804      	ldr	r4, [r0, #0]
	handle = net_buf_pull_le16(buf);
   19154:	f101 0008 	add.w	r0, r1, #8
{
   19158:	460d      	mov	r5, r1
	handle = net_buf_pull_le16(buf);
   1915a:	f013 fd52 	bl	2cc02 <net_buf_simple_pull_le16>
	bt_gatt_notification(conn, handle, buf->data, buf->len);
   1915e:	89ab      	ldrh	r3, [r5, #12]
   19160:	68aa      	ldr	r2, [r5, #8]
   19162:	4601      	mov	r1, r0
   19164:	4620      	mov	r0, r4
   19166:	f002 f9af 	bl	1b4c8 <bt_gatt_notification>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_CONFIRM, 0);
   1916a:	2200      	movs	r2, #0
   1916c:	211e      	movs	r1, #30
   1916e:	4620      	mov	r0, r4
   19170:	f7ff ff96 	bl	190a0 <bt_att_create_pdu>
	if (!buf) {
   19174:	4602      	mov	r2, r0
   19176:	b130      	cbz	r0, 19186 <att_indicate+0x36>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf, att_cfm_sent, NULL);
   19178:	2300      	movs	r3, #0
   1917a:	9300      	str	r3, [sp, #0]
   1917c:	2104      	movs	r1, #4
   1917e:	4b03      	ldr	r3, [pc, #12]	; (1918c <att_indicate+0x3c>)
   19180:	4620      	mov	r0, r4
   19182:	f011 fd0a 	bl	2ab9a <bt_l2cap_send_cb>
}
   19186:	2000      	movs	r0, #0
   19188:	b003      	add	sp, #12
   1918a:	bd30      	pop	{r4, r5, pc}
   1918c:	0002af99 	.word	0x0002af99

00019190 <att_mtu_req>:
	mtu_client = sys_le16_to_cpu(req->mtu);
   19190:	688b      	ldr	r3, [r1, #8]
{
   19192:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	mtu_client = sys_le16_to_cpu(req->mtu);
   19196:	881d      	ldrh	r5, [r3, #0]
	if (mtu_client < BT_ATT_DEFAULT_LE_MTU) {
   19198:	2d16      	cmp	r5, #22
{
   1919a:	4606      	mov	r6, r0
	if (mtu_client < BT_ATT_DEFAULT_LE_MTU) {
   1919c:	d922      	bls.n	191e4 <att_mtu_req+0x54>
	struct bt_conn *conn = att->chan.chan.conn;
   1919e:	f8d0 8000 	ldr.w	r8, [r0]
	pdu = bt_att_create_pdu(conn, BT_ATT_OP_MTU_RSP, sizeof(*rsp));
   191a2:	2202      	movs	r2, #2
   191a4:	2103      	movs	r1, #3
   191a6:	4640      	mov	r0, r8
   191a8:	f7ff ff7a 	bl	190a0 <bt_att_create_pdu>
	if (!pdu) {
   191ac:	4607      	mov	r7, r0
   191ae:	b1d8      	cbz	r0, 191e8 <att_mtu_req+0x58>
	rsp = net_buf_add(pdu, sizeof(*rsp));
   191b0:	2102      	movs	r1, #2
   191b2:	3008      	adds	r0, #8
   191b4:	f013 fce4 	bl	2cb80 <net_buf_simple_add>
	rsp->mtu = sys_cpu_to_le16(mtu_server);
   191b8:	2400      	movs	r4, #0
   191ba:	f06f 0303 	mvn.w	r3, #3
   191be:	7003      	strb	r3, [r0, #0]
   191c0:	7044      	strb	r4, [r0, #1]
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, pdu, att_rsp_sent, NULL);
   191c2:	4b0a      	ldr	r3, [pc, #40]	; (191ec <att_mtu_req+0x5c>)
   191c4:	9400      	str	r4, [sp, #0]
   191c6:	463a      	mov	r2, r7
   191c8:	2104      	movs	r1, #4
   191ca:	4640      	mov	r0, r8
   191cc:	f011 fce5 	bl	2ab9a <bt_l2cap_send_cb>
	att->chan.rx.mtu = MIN(mtu_client, mtu_server);
   191d0:	2dfc      	cmp	r5, #252	; 0xfc
   191d2:	bf28      	it	cs
   191d4:	25fc      	movcs	r5, #252	; 0xfc
   191d6:	86f5      	strh	r5, [r6, #54]	; 0x36
	att->chan.tx.mtu = att->chan.rx.mtu;
   191d8:	f8a6 5056 	strh.w	r5, [r6, #86]	; 0x56
	return 0;
   191dc:	4620      	mov	r0, r4
}
   191de:	b002      	add	sp, #8
   191e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_ATT_ERR_INVALID_PDU;
   191e4:	2004      	movs	r0, #4
   191e6:	e7fa      	b.n	191de <att_mtu_req+0x4e>
		return BT_ATT_ERR_UNLIKELY;
   191e8:	200e      	movs	r0, #14
   191ea:	e7f8      	b.n	191de <att_mtu_req+0x4e>
   191ec:	0002afcb 	.word	0x0002afcb

000191f0 <send_err_rsp.part.11>:
static void send_err_rsp(struct bt_conn *conn, u8_t req, u16_t handle,
   191f0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   191f4:	4688      	mov	r8, r1
   191f6:	4617      	mov	r7, r2
	buf = bt_att_create_pdu(conn, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
   191f8:	2101      	movs	r1, #1
   191fa:	2204      	movs	r2, #4
static void send_err_rsp(struct bt_conn *conn, u8_t req, u16_t handle,
   191fc:	4605      	mov	r5, r0
   191fe:	461e      	mov	r6, r3
	buf = bt_att_create_pdu(conn, BT_ATT_OP_ERROR_RSP, sizeof(*rsp));
   19200:	f7ff ff4e 	bl	190a0 <bt_att_create_pdu>
	if (!buf) {
   19204:	4604      	mov	r4, r0
   19206:	b180      	cbz	r0, 1922a <send_err_rsp.part.11+0x3a>
	rsp = net_buf_add(buf, sizeof(*rsp));
   19208:	2104      	movs	r1, #4
   1920a:	3008      	adds	r0, #8
   1920c:	f013 fcb8 	bl	2cb80 <net_buf_simple_add>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf, att_rsp_sent, NULL);
   19210:	2300      	movs	r3, #0
	rsp->request = req;
   19212:	f880 8000 	strb.w	r8, [r0]
	rsp->handle = sys_cpu_to_le16(handle);
   19216:	f8a0 7001 	strh.w	r7, [r0, #1]
	rsp->error = err;
   1921a:	70c6      	strb	r6, [r0, #3]
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, buf, att_rsp_sent, NULL);
   1921c:	4622      	mov	r2, r4
   1921e:	9300      	str	r3, [sp, #0]
   19220:	2104      	movs	r1, #4
   19222:	4b03      	ldr	r3, [pc, #12]	; (19230 <send_err_rsp.part.11+0x40>)
   19224:	4628      	mov	r0, r5
   19226:	f011 fcb8 	bl	2ab9a <bt_l2cap_send_cb>
}
   1922a:	b002      	add	sp, #8
   1922c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   19230:	0002afcb 	.word	0x0002afcb

00019234 <bt_att_recv>:
{
   19234:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (buf->len < sizeof(*hdr)) {
   19236:	898b      	ldrh	r3, [r1, #12]
{
   19238:	4604      	mov	r4, r0
   1923a:	460f      	mov	r7, r1
	if (buf->len < sizeof(*hdr)) {
   1923c:	b99b      	cbnz	r3, 19266 <bt_att_recv+0x32>
		BT_ERR("Too small ATT PDU received");
   1923e:	4b60      	ldr	r3, [pc, #384]	; (193c0 <bt_att_recv+0x18c>)
   19240:	681b      	ldr	r3, [r3, #0]
   19242:	0758      	lsls	r0, r3, #29
   19244:	d00d      	beq.n	19262 <bt_att_recv+0x2e>
   19246:	2301      	movs	r3, #1
   19248:	f04f 0100 	mov.w	r1, #0
   1924c:	f363 0107 	bfi	r1, r3, #0, #8
   19250:	4a5c      	ldr	r2, [pc, #368]	; (193c4 <bt_att_recv+0x190>)
   19252:	4b5d      	ldr	r3, [pc, #372]	; (193c8 <bt_att_recv+0x194>)
   19254:	485d      	ldr	r0, [pc, #372]	; (193cc <bt_att_recv+0x198>)
   19256:	1a9b      	subs	r3, r3, r2
   19258:	08db      	lsrs	r3, r3, #3
   1925a:	f363 118f 	bfi	r1, r3, #6, #10
			BT_WARN("Ignoring unexpected indication");
   1925e:	f00f fb6c 	bl	2893a <log_0>
}
   19262:	2000      	movs	r0, #0
   19264:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
   19266:	2101      	movs	r1, #1
   19268:	f107 0008 	add.w	r0, r7, #8
   1926c:	f013 fcb9 	bl	2cbe2 <net_buf_simple_pull_mem>
		if (hdr->code == handlers[i].op) {
   19270:	4a57      	ldr	r2, [pc, #348]	; (193d0 <bt_att_recv+0x19c>)
   19272:	7801      	ldrb	r1, [r0, #0]
	hdr = net_buf_pull_mem(buf, sizeof(*hdr));
   19274:	4605      	mov	r5, r0
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
   19276:	2300      	movs	r3, #0
   19278:	4610      	mov	r0, r2
		if (hdr->code == handlers[i].op) {
   1927a:	f812 6033 	ldrb.w	r6, [r2, r3, lsl #3]
   1927e:	428e      	cmp	r6, r1
   19280:	d127      	bne.n	192d2 <bt_att_recv+0x9e>
		if (handler->type == ATT_REQUEST &&
   19282:	00db      	lsls	r3, r3, #3
   19284:	441a      	add	r2, r3
   19286:	7896      	ldrb	r6, [r2, #2]
   19288:	2e01      	cmp	r6, #1
   1928a:	d146      	bne.n	1931a <bt_att_recv+0xe6>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1928c:	f3bf 8f5b 	dmb	ish
   19290:	f104 02ac 	add.w	r2, r4, #172	; 0xac
   19294:	e852 1f00 	ldrex	r1, [r2]
   19298:	f041 0c01 	orr.w	ip, r1, #1
   1929c:	e842 ce00 	strex	lr, ip, [r2]
   192a0:	f1be 0f00 	cmp.w	lr, #0
   192a4:	d1f6      	bne.n	19294 <bt_att_recv+0x60>
   192a6:	f3bf 8f5b 	dmb	ish
   192aa:	07c9      	lsls	r1, r1, #31
   192ac:	d55a      	bpl.n	19364 <bt_att_recv+0x130>
			BT_WARN("Ignoring unexpected request");
   192ae:	4b44      	ldr	r3, [pc, #272]	; (193c0 <bt_att_recv+0x18c>)
   192b0:	681b      	ldr	r3, [r3, #0]
   192b2:	f013 0f06 	tst.w	r3, #6
   192b6:	d0d4      	beq.n	19262 <bt_att_recv+0x2e>
   192b8:	2302      	movs	r3, #2
   192ba:	f04f 0100 	mov.w	r1, #0
   192be:	f363 0107 	bfi	r1, r3, #0, #8
   192c2:	4a40      	ldr	r2, [pc, #256]	; (193c4 <bt_att_recv+0x190>)
   192c4:	4b40      	ldr	r3, [pc, #256]	; (193c8 <bt_att_recv+0x194>)
   192c6:	4843      	ldr	r0, [pc, #268]	; (193d4 <bt_att_recv+0x1a0>)
   192c8:	1a9b      	subs	r3, r3, r2
   192ca:	08db      	lsrs	r3, r3, #3
   192cc:	f363 118f 	bfi	r1, r3, #6, #10
   192d0:	e7c5      	b.n	1925e <bt_att_recv+0x2a>
	for (i = 0, handler = NULL; i < ARRAY_SIZE(handlers); i++) {
   192d2:	3301      	adds	r3, #1
   192d4:	2b1b      	cmp	r3, #27
   192d6:	d1d0      	bne.n	1927a <bt_att_recv+0x46>
		BT_WARN("Unhandled ATT code 0x%02x", hdr->code);
   192d8:	4b39      	ldr	r3, [pc, #228]	; (193c0 <bt_att_recv+0x18c>)
   192da:	681b      	ldr	r3, [r3, #0]
   192dc:	f013 0f06 	tst.w	r3, #6
   192e0:	d00d      	beq.n	192fe <bt_att_recv+0xca>
   192e2:	2302      	movs	r3, #2
   192e4:	f04f 0200 	mov.w	r2, #0
   192e8:	f363 0207 	bfi	r2, r3, #0, #8
   192ec:	4835      	ldr	r0, [pc, #212]	; (193c4 <bt_att_recv+0x190>)
   192ee:	4b36      	ldr	r3, [pc, #216]	; (193c8 <bt_att_recv+0x194>)
   192f0:	1a1b      	subs	r3, r3, r0
   192f2:	08db      	lsrs	r3, r3, #3
   192f4:	f363 128f 	bfi	r2, r3, #6, #10
   192f8:	4837      	ldr	r0, [pc, #220]	; (193d8 <bt_att_recv+0x1a4>)
   192fa:	f00f fb2b 	bl	28954 <log_1>
		if (att_op_get_type(hdr->code) != ATT_COMMAND) {
   192fe:	7829      	ldrb	r1, [r5, #0]
   19300:	4608      	mov	r0, r1
   19302:	f011 fc92 	bl	2ac2a <att_op_get_type>
   19306:	2800      	cmp	r0, #0
   19308:	d0ab      	beq.n	19262 <bt_att_recv+0x2e>
	if (!req) {
   1930a:	2900      	cmp	r1, #0
   1930c:	d0a9      	beq.n	19262 <bt_att_recv+0x2e>
   1930e:	2306      	movs	r3, #6
   19310:	2200      	movs	r2, #0
   19312:	6820      	ldr	r0, [r4, #0]
   19314:	f7ff ff6c 	bl	191f0 <send_err_rsp.part.11>
   19318:	e7a3      	b.n	19262 <bt_att_recv+0x2e>
		} else if (handler->type == ATT_INDICATION &&
   1931a:	2e05      	cmp	r6, #5
   1931c:	d122      	bne.n	19364 <bt_att_recv+0x130>
   1931e:	f3bf 8f5b 	dmb	ish
   19322:	f104 02ac 	add.w	r2, r4, #172	; 0xac
   19326:	e852 1f00 	ldrex	r1, [r2]
   1932a:	f041 0c02 	orr.w	ip, r1, #2
   1932e:	e842 ce00 	strex	lr, ip, [r2]
   19332:	f1be 0f00 	cmp.w	lr, #0
   19336:	d1f6      	bne.n	19326 <bt_att_recv+0xf2>
   19338:	f3bf 8f5b 	dmb	ish
   1933c:	078a      	lsls	r2, r1, #30
   1933e:	d511      	bpl.n	19364 <bt_att_recv+0x130>
			BT_WARN("Ignoring unexpected indication");
   19340:	4b1f      	ldr	r3, [pc, #124]	; (193c0 <bt_att_recv+0x18c>)
   19342:	681b      	ldr	r3, [r3, #0]
   19344:	f013 0f06 	tst.w	r3, #6
   19348:	d08b      	beq.n	19262 <bt_att_recv+0x2e>
   1934a:	2302      	movs	r3, #2
   1934c:	f04f 0100 	mov.w	r1, #0
   19350:	f363 0107 	bfi	r1, r3, #0, #8
   19354:	4a1b      	ldr	r2, [pc, #108]	; (193c4 <bt_att_recv+0x190>)
   19356:	4b1c      	ldr	r3, [pc, #112]	; (193c8 <bt_att_recv+0x194>)
   19358:	4820      	ldr	r0, [pc, #128]	; (193dc <bt_att_recv+0x1a8>)
   1935a:	1a9b      	subs	r3, r3, r2
   1935c:	08db      	lsrs	r3, r3, #3
   1935e:	f363 118f 	bfi	r1, r3, #6, #10
   19362:	e77c      	b.n	1925e <bt_att_recv+0x2a>
	if (buf->len < handler->expect_len) {
   19364:	4403      	add	r3, r0
   19366:	89b9      	ldrh	r1, [r7, #12]
   19368:	785a      	ldrb	r2, [r3, #1]
   1936a:	428a      	cmp	r2, r1
   1936c:	d917      	bls.n	1939e <bt_att_recv+0x16a>
		BT_ERR("Invalid len %u for code 0x%02x", buf->len, hdr->code);
   1936e:	4b14      	ldr	r3, [pc, #80]	; (193c0 <bt_att_recv+0x18c>)
   19370:	681b      	ldr	r3, [r3, #0]
   19372:	075b      	lsls	r3, r3, #29
   19374:	d00e      	beq.n	19394 <bt_att_recv+0x160>
   19376:	2201      	movs	r2, #1
   19378:	f04f 0300 	mov.w	r3, #0
   1937c:	f362 0307 	bfi	r3, r2, #0, #8
   19380:	4810      	ldr	r0, [pc, #64]	; (193c4 <bt_att_recv+0x190>)
   19382:	4a11      	ldr	r2, [pc, #68]	; (193c8 <bt_att_recv+0x194>)
   19384:	1a12      	subs	r2, r2, r0
   19386:	08d2      	lsrs	r2, r2, #3
   19388:	f362 138f 	bfi	r3, r2, #6, #10
   1938c:	4814      	ldr	r0, [pc, #80]	; (193e0 <bt_att_recv+0x1ac>)
   1938e:	782a      	ldrb	r2, [r5, #0]
   19390:	f00f faf4 	bl	2897c <log_2>
	if (handler->type == ATT_REQUEST && err) {
   19394:	2e01      	cmp	r6, #1
   19396:	f47f af64 	bne.w	19262 <bt_att_recv+0x2e>
   1939a:	2304      	movs	r3, #4
   1939c:	e00a      	b.n	193b4 <bt_att_recv+0x180>
		err = handler->func(att, buf);
   1939e:	685b      	ldr	r3, [r3, #4]
   193a0:	4639      	mov	r1, r7
   193a2:	4620      	mov	r0, r4
   193a4:	4798      	blx	r3
	if (handler->type == ATT_REQUEST && err) {
   193a6:	2e01      	cmp	r6, #1
		err = handler->func(att, buf);
   193a8:	4603      	mov	r3, r0
	if (handler->type == ATT_REQUEST && err) {
   193aa:	f47f af5a 	bne.w	19262 <bt_att_recv+0x2e>
   193ae:	2800      	cmp	r0, #0
   193b0:	f43f af57 	beq.w	19262 <bt_att_recv+0x2e>
		send_err_rsp(chan->conn, hdr->code, 0, err);
   193b4:	7829      	ldrb	r1, [r5, #0]
	if (!req) {
   193b6:	2900      	cmp	r1, #0
   193b8:	f43f af53 	beq.w	19262 <bt_att_recv+0x2e>
   193bc:	e7a8      	b.n	19310 <bt_att_recv+0xdc>
   193be:	bf00      	nop
   193c0:	2000ff9c 	.word	0x2000ff9c
   193c4:	0002db28 	.word	0x0002db28
   193c8:	0002db30 	.word	0x0002db30
   193cc:	000311b9 	.word	0x000311b9
   193d0:	0002e560 	.word	0x0002e560
   193d4:	000311ee 	.word	0x000311ee
   193d8:	000311d4 	.word	0x000311d4
   193dc:	0003120a 	.word	0x0003120a
   193e0:	00031229 	.word	0x00031229

000193e4 <att_read_group_req>:
{
   193e4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	u8_t uuid_len = buf->len - sizeof(*req);
   193e8:	7b0c      	ldrb	r4, [r1, #12]
   193ea:	3c04      	subs	r4, #4
   193ec:	b2e4      	uxtb	r4, r4
	if (uuid_len != 2 && uuid_len != 16) {
   193ee:	2c02      	cmp	r4, #2
{
   193f0:	4680      	mov	r8, r0
   193f2:	b08f      	sub	sp, #60	; 0x3c
   193f4:	4608      	mov	r0, r1
	if (uuid_len != 2 && uuid_len != 16) {
   193f6:	d001      	beq.n	193fc <att_read_group_req+0x18>
   193f8:	2c10      	cmp	r4, #16
   193fa:	d16e      	bne.n	194da <att_read_group_req+0xf6>
	req = net_buf_pull_mem(buf, sizeof(*req));
   193fc:	2104      	movs	r1, #4
   193fe:	3008      	adds	r0, #8
	struct bt_conn *conn = att->chan.chan.conn;
   19400:	f8d8 9000 	ldr.w	r9, [r8]
	req = net_buf_pull_mem(buf, sizeof(*req));
   19404:	f013 fbed 	bl	2cbe2 <net_buf_simple_pull_mem>
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
   19408:	ae04      	add	r6, sp, #16
	start_handle = sys_le16_to_cpu(req->start_handle);
   1940a:	8805      	ldrh	r5, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
   1940c:	8847      	ldrh	r7, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
   1940e:	1d01      	adds	r1, r0, #4
   19410:	4622      	mov	r2, r4
   19412:	4630      	mov	r0, r6
   19414:	f011 f961 	bl	2a6da <bt_uuid_create>
   19418:	2800      	cmp	r0, #0
   1941a:	d060      	beq.n	194de <att_read_group_req+0xfa>
	if (!start || !end) {
   1941c:	2d00      	cmp	r5, #0
   1941e:	d036      	beq.n	1948e <att_read_group_req+0xaa>
   19420:	2400      	movs	r4, #0
   19422:	b39f      	cbz	r7, 1948c <att_read_group_req+0xa8>
	if (start > end) {
   19424:	42bd      	cmp	r5, r7
   19426:	d832      	bhi.n	1948e <att_read_group_req+0xaa>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
   19428:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   1942c:	a902      	add	r1, sp, #8
   1942e:	4630      	mov	r0, r6
   19430:	f88d 4008 	strb.w	r4, [sp, #8]
   19434:	f8ad 300a 	strh.w	r3, [sp, #10]
   19438:	f011 f925 	bl	2a686 <bt_uuid_cmp>
   1943c:	bb90      	cbnz	r0, 194a4 <att_read_group_req+0xc0>
	struct bt_conn *conn = att->chan.chan.conn;
   1943e:	f8d8 9000 	ldr.w	r9, [r8]
	(void)memset(&data, 0, sizeof(data));
   19442:	2214      	movs	r2, #20
   19444:	2100      	movs	r1, #0
   19446:	a809      	add	r0, sp, #36	; 0x24
   19448:	f011 f82b 	bl	2a4a2 <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_GROUP_RSP,
   1944c:	2201      	movs	r2, #1
   1944e:	2111      	movs	r1, #17
   19450:	4648      	mov	r0, r9
   19452:	f7ff fe25 	bl	190a0 <bt_att_create_pdu>
   19456:	900b      	str	r0, [sp, #44]	; 0x2c
	if (!data.buf) {
   19458:	2800      	cmp	r0, #0
   1945a:	d040      	beq.n	194de <att_read_group_req+0xfa>
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
   1945c:	2101      	movs	r1, #1
   1945e:	3008      	adds	r0, #8
	data.uuid = uuid;
   19460:	e9cd 8609 	strd	r8, r6, [sp, #36]	; 0x24
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
   19464:	f013 fb8c 	bl	2cb80 <net_buf_simple_add>
	data.rsp->len = 0U;
   19468:	2600      	movs	r6, #0
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
   1946a:	900c      	str	r0, [sp, #48]	; 0x30
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
   1946c:	ab09      	add	r3, sp, #36	; 0x24
	data.rsp->len = 0U;
   1946e:	7006      	strb	r6, [r0, #0]
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
   19470:	4a1c      	ldr	r2, [pc, #112]	; (194e4 <att_read_group_req+0x100>)
	data.group = NULL;
   19472:	960d      	str	r6, [sp, #52]	; 0x34
	bt_gatt_foreach_attr(start_handle, end_handle, read_group_cb, &data);
   19474:	4639      	mov	r1, r7
   19476:	4628      	mov	r0, r5
   19478:	f011 fc44 	bl	2ad04 <bt_gatt_foreach_attr>
	if (!data.rsp->len) {
   1947c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1947e:	781c      	ldrb	r4, [r3, #0]
   19480:	bb1c      	cbnz	r4, 194ca <att_read_group_req+0xe6>
		net_buf_unref(data.buf);
   19482:	980b      	ldr	r0, [sp, #44]	; 0x2c
   19484:	f00b ff22 	bl	252cc <net_buf_unref>
	if (!req) {
   19488:	230a      	movs	r3, #10
   1948a:	e018      	b.n	194be <att_read_group_req+0xda>
			*err = 0U;
   1948c:	463d      	mov	r5, r7
	if (!req) {
   1948e:	2301      	movs	r3, #1
   19490:	462a      	mov	r2, r5
   19492:	2110      	movs	r1, #16
   19494:	4648      	mov	r0, r9
   19496:	f7ff feab 	bl	191f0 <send_err_rsp.part.11>
		return 0;
   1949a:	2400      	movs	r4, #0
}
   1949c:	4620      	mov	r0, r4
   1949e:	b00f      	add	sp, #60	; 0x3c
   194a0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	    bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY)) {
   194a4:	f642 0301 	movw	r3, #10241	; 0x2801
   194a8:	a903      	add	r1, sp, #12
   194aa:	4630      	mov	r0, r6
   194ac:	f88d 400c 	strb.w	r4, [sp, #12]
   194b0:	f8ad 300e 	strh.w	r3, [sp, #14]
   194b4:	f011 f8e7 	bl	2a686 <bt_uuid_cmp>
	if (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) &&
   194b8:	2800      	cmp	r0, #0
   194ba:	d0c0      	beq.n	1943e <att_read_group_req+0x5a>
	if (!req) {
   194bc:	2310      	movs	r3, #16
   194be:	462a      	mov	r2, r5
   194c0:	2110      	movs	r1, #16
   194c2:	4648      	mov	r0, r9
   194c4:	f7ff fe94 	bl	191f0 <send_err_rsp.part.11>
		return 0;
   194c8:	e7e8      	b.n	1949c <att_read_group_req+0xb8>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
   194ca:	9600      	str	r6, [sp, #0]
   194cc:	4b06      	ldr	r3, [pc, #24]	; (194e8 <att_read_group_req+0x104>)
   194ce:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   194d0:	2104      	movs	r1, #4
   194d2:	4648      	mov	r0, r9
   194d4:	f011 fb61 	bl	2ab9a <bt_l2cap_send_cb>
	return 0;
   194d8:	e7df      	b.n	1949a <att_read_group_req+0xb6>
		return BT_ATT_ERR_INVALID_PDU;
   194da:	2404      	movs	r4, #4
   194dc:	e7de      	b.n	1949c <att_read_group_req+0xb8>
		return BT_ATT_ERR_UNLIKELY;
   194de:	240e      	movs	r4, #14
   194e0:	e7dc      	b.n	1949c <att_read_group_req+0xb8>
   194e2:	bf00      	nop
   194e4:	0002ad1b 	.word	0x0002ad1b
   194e8:	0002afcb 	.word	0x0002afcb

000194ec <att_read_mult_req>:
{
   194ec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct bt_conn *conn = att->chan.chan.conn;
   194f0:	6805      	ldr	r5, [r0, #0]
{
   194f2:	b089      	sub	sp, #36	; 0x24
	(void)memset(&data, 0, sizeof(data));
   194f4:	2214      	movs	r2, #20
{
   194f6:	4606      	mov	r6, r0
   194f8:	460c      	mov	r4, r1
	(void)memset(&data, 0, sizeof(data));
   194fa:	a803      	add	r0, sp, #12
   194fc:	2100      	movs	r1, #0
   194fe:	f010 ffd0 	bl	2a4a2 <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_RSP, 0);
   19502:	2200      	movs	r2, #0
   19504:	210f      	movs	r1, #15
   19506:	4628      	mov	r0, r5
   19508:	f7ff fdca 	bl	190a0 <bt_att_create_pdu>
   1950c:	9005      	str	r0, [sp, #20]
	if (!data.buf) {
   1950e:	b378      	cbz	r0, 19570 <att_read_mult_req+0x84>
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
   19510:	f8df 9064 	ldr.w	r9, [pc, #100]	; 19578 <att_read_mult_req+0x8c>
	data.att = att;
   19514:	9603      	str	r6, [sp, #12]
		handle = net_buf_pull_le16(buf);
   19516:	f104 0708 	add.w	r7, r4, #8
		data.err = BT_ATT_ERR_INVALID_HANDLE;
   1951a:	f04f 0801 	mov.w	r8, #1
	while (buf->len >= sizeof(u16_t)) {
   1951e:	89a3      	ldrh	r3, [r4, #12]
   19520:	2b01      	cmp	r3, #1
   19522:	d808      	bhi.n	19536 <att_read_mult_req+0x4a>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
   19524:	2400      	movs	r4, #0
   19526:	9400      	str	r4, [sp, #0]
   19528:	4b12      	ldr	r3, [pc, #72]	; (19574 <att_read_mult_req+0x88>)
   1952a:	9a05      	ldr	r2, [sp, #20]
   1952c:	2104      	movs	r1, #4
   1952e:	4628      	mov	r0, r5
   19530:	f011 fb33 	bl	2ab9a <bt_l2cap_send_cb>
	return 0;
   19534:	e018      	b.n	19568 <att_read_mult_req+0x7c>
		handle = net_buf_pull_le16(buf);
   19536:	4638      	mov	r0, r7
   19538:	f013 fb63 	bl	2cc02 <net_buf_simple_pull_le16>
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
   1953c:	ab03      	add	r3, sp, #12
   1953e:	464a      	mov	r2, r9
   19540:	4601      	mov	r1, r0
		handle = net_buf_pull_le16(buf);
   19542:	4606      	mov	r6, r0
		data.err = BT_ATT_ERR_INVALID_HANDLE;
   19544:	f88d 801c 	strb.w	r8, [sp, #28]
		bt_gatt_foreach_attr(handle, handle, read_cb, &data);
   19548:	f011 fbdc 	bl	2ad04 <bt_gatt_foreach_attr>
		if (data.err) {
   1954c:	f89d 301c 	ldrb.w	r3, [sp, #28]
   19550:	2b00      	cmp	r3, #0
   19552:	d0e4      	beq.n	1951e <att_read_mult_req+0x32>
			net_buf_unref(data.buf);
   19554:	9805      	ldr	r0, [sp, #20]
   19556:	f00b feb9 	bl	252cc <net_buf_unref>
	if (!req) {
   1955a:	f89d 301c 	ldrb.w	r3, [sp, #28]
   1955e:	4632      	mov	r2, r6
   19560:	210e      	movs	r1, #14
   19562:	4628      	mov	r0, r5
   19564:	f7ff fe44 	bl	191f0 <send_err_rsp.part.11>
			return 0;
   19568:	2000      	movs	r0, #0
}
   1956a:	b009      	add	sp, #36	; 0x24
   1956c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return BT_ATT_ERR_UNLIKELY;
   19570:	200e      	movs	r0, #14
   19572:	e7fa      	b.n	1956a <att_read_mult_req+0x7e>
   19574:	0002afcb 	.word	0x0002afcb
   19578:	0002b059 	.word	0x0002b059

0001957c <att_read_rsp>:
{
   1957c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct bt_conn *conn = att->chan.chan.conn;
   19580:	6805      	ldr	r5, [r0, #0]
{
   19582:	b088      	sub	sp, #32
   19584:	4604      	mov	r4, r0
   19586:	460f      	mov	r7, r1
	if (!bt_gatt_change_aware(conn, true)) {
   19588:	4628      	mov	r0, r5
   1958a:	2101      	movs	r1, #1
{
   1958c:	4690      	mov	r8, r2
   1958e:	461e      	mov	r6, r3
	if (!bt_gatt_change_aware(conn, true)) {
   19590:	f012 f95c 	bl	2b84c <bt_gatt_change_aware>
   19594:	b3a0      	cbz	r0, 19600 <att_read_rsp+0x84>
	if (!handle) {
   19596:	b3ae      	cbz	r6, 19604 <att_read_rsp+0x88>
	(void)memset(&data, 0, sizeof(data));
   19598:	2214      	movs	r2, #20
   1959a:	2100      	movs	r1, #0
   1959c:	a803      	add	r0, sp, #12
   1959e:	f010 ff80 	bl	2a4a2 <memset>
	data.buf = bt_att_create_pdu(conn, rsp, 0);
   195a2:	2200      	movs	r2, #0
   195a4:	4641      	mov	r1, r8
   195a6:	4628      	mov	r0, r5
   195a8:	f7ff fd7a 	bl	190a0 <bt_att_create_pdu>
   195ac:	9005      	str	r0, [sp, #20]
	if (!data.buf) {
   195ae:	b358      	cbz	r0, 19608 <att_read_rsp+0x8c>
	data.offset = offset;
   195b0:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
   195b4:	f8ad 3010 	strh.w	r3, [sp, #16]
	data.err = BT_ATT_ERR_INVALID_HANDLE;
   195b8:	2301      	movs	r3, #1
   195ba:	f88d 301c 	strb.w	r3, [sp, #28]
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
   195be:	4a13      	ldr	r2, [pc, #76]	; (1960c <att_read_rsp+0x90>)
	data.att = att;
   195c0:	9403      	str	r4, [sp, #12]
	bt_gatt_foreach_attr(handle, handle, read_cb, &data);
   195c2:	ab03      	add	r3, sp, #12
   195c4:	4631      	mov	r1, r6
   195c6:	4630      	mov	r0, r6
   195c8:	f011 fb9c 	bl	2ad04 <bt_gatt_foreach_attr>
	if (data.err) {
   195cc:	f89d 401c 	ldrb.w	r4, [sp, #28]
   195d0:	b174      	cbz	r4, 195f0 <att_read_rsp+0x74>
		net_buf_unref(data.buf);
   195d2:	9805      	ldr	r0, [sp, #20]
   195d4:	f00b fe7a 	bl	252cc <net_buf_unref>
	if (!req) {
   195d8:	f89d 301c 	ldrb.w	r3, [sp, #28]
   195dc:	4632      	mov	r2, r6
   195de:	4639      	mov	r1, r7
   195e0:	4628      	mov	r0, r5
   195e2:	f7ff fe05 	bl	191f0 <send_err_rsp.part.11>
		return 0;
   195e6:	2400      	movs	r4, #0
}
   195e8:	4620      	mov	r0, r4
   195ea:	b008      	add	sp, #32
   195ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
   195f0:	9400      	str	r4, [sp, #0]
   195f2:	4b07      	ldr	r3, [pc, #28]	; (19610 <att_read_rsp+0x94>)
   195f4:	9a05      	ldr	r2, [sp, #20]
   195f6:	2104      	movs	r1, #4
   195f8:	4628      	mov	r0, r5
   195fa:	f011 face 	bl	2ab9a <bt_l2cap_send_cb>
	return 0;
   195fe:	e7f3      	b.n	195e8 <att_read_rsp+0x6c>
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
   19600:	2412      	movs	r4, #18
   19602:	e7f1      	b.n	195e8 <att_read_rsp+0x6c>
		return BT_ATT_ERR_INVALID_HANDLE;
   19604:	2401      	movs	r4, #1
   19606:	e7ef      	b.n	195e8 <att_read_rsp+0x6c>
		return BT_ATT_ERR_UNLIKELY;
   19608:	240e      	movs	r4, #14
   1960a:	e7ed      	b.n	195e8 <att_read_rsp+0x6c>
   1960c:	0002b059 	.word	0x0002b059
   19610:	0002afcb 	.word	0x0002afcb

00019614 <att_read_type_req>:
{
   19614:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	u8_t uuid_len = buf->len - sizeof(*req);
   19618:	7b0c      	ldrb	r4, [r1, #12]
   1961a:	3c04      	subs	r4, #4
   1961c:	b2e4      	uxtb	r4, r4
	if (uuid_len != 2 && uuid_len != 16) {
   1961e:	2c02      	cmp	r4, #2
{
   19620:	4680      	mov	r8, r0
   19622:	b08f      	sub	sp, #60	; 0x3c
   19624:	4608      	mov	r0, r1
	if (uuid_len != 2 && uuid_len != 16) {
   19626:	d001      	beq.n	1962c <att_read_type_req+0x18>
   19628:	2c10      	cmp	r4, #16
   1962a:	d154      	bne.n	196d6 <att_read_type_req+0xc2>
	req = net_buf_pull_mem(buf, sizeof(*req));
   1962c:	2104      	movs	r1, #4
   1962e:	3008      	adds	r0, #8
	struct bt_conn *conn = att->chan.chan.conn;
   19630:	f8d8 7000 	ldr.w	r7, [r8]
	req = net_buf_pull_mem(buf, sizeof(*req));
   19634:	f013 fad5 	bl	2cbe2 <net_buf_simple_pull_mem>
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
   19638:	f10d 090c 	add.w	r9, sp, #12
	start_handle = sys_le16_to_cpu(req->start_handle);
   1963c:	8805      	ldrh	r5, [r0, #0]
	end_handle = sys_le16_to_cpu(req->end_handle);
   1963e:	8846      	ldrh	r6, [r0, #2]
	if (!bt_uuid_create(&u.uuid, req->uuid, uuid_len)) {
   19640:	1d01      	adds	r1, r0, #4
   19642:	4622      	mov	r2, r4
   19644:	4648      	mov	r0, r9
   19646:	f011 f848 	bl	2a6da <bt_uuid_create>
   1964a:	b188      	cbz	r0, 19670 <att_read_type_req+0x5c>
	if (!start || !end) {
   1964c:	b19d      	cbz	r5, 19676 <att_read_type_req+0x62>
   1964e:	b18e      	cbz	r6, 19674 <att_read_type_req+0x60>
	if (start > end) {
   19650:	42b5      	cmp	r5, r6
   19652:	d810      	bhi.n	19676 <att_read_type_req+0x62>
	struct bt_conn *conn = att->chan.chan.conn;
   19654:	f8d8 7000 	ldr.w	r7, [r8]
	(void)memset(&data, 0, sizeof(data));
   19658:	2218      	movs	r2, #24
   1965a:	2100      	movs	r1, #0
   1965c:	a808      	add	r0, sp, #32
   1965e:	f010 ff20 	bl	2a4a2 <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_RSP,
   19662:	2201      	movs	r2, #1
   19664:	2109      	movs	r1, #9
   19666:	4638      	mov	r0, r7
   19668:	f7ff fd1a 	bl	190a0 <bt_att_create_pdu>
   1966c:	900a      	str	r0, [sp, #40]	; 0x28
	if (!data.buf) {
   1966e:	b968      	cbnz	r0, 1968c <att_read_type_req+0x78>
		return BT_ATT_ERR_UNLIKELY;
   19670:	240e      	movs	r4, #14
   19672:	e007      	b.n	19684 <att_read_type_req+0x70>
			*err = 0U;
   19674:	4635      	mov	r5, r6
	if (!req) {
   19676:	2301      	movs	r3, #1
   19678:	462a      	mov	r2, r5
   1967a:	2108      	movs	r1, #8
   1967c:	4638      	mov	r0, r7
   1967e:	f7ff fdb7 	bl	191f0 <send_err_rsp.part.11>
		return 0;
   19682:	2400      	movs	r4, #0
}
   19684:	4620      	mov	r0, r4
   19686:	b00f      	add	sp, #60	; 0x3c
   19688:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
   1968c:	2101      	movs	r1, #1
   1968e:	3008      	adds	r0, #8
	data.uuid = uuid;
   19690:	e9cd 8908 	strd	r8, r9, [sp, #32]
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
   19694:	f013 fa74 	bl	2cb80 <net_buf_simple_add>
	data.rsp->len = 0U;
   19698:	f04f 0800 	mov.w	r8, #0
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
   1969c:	230a      	movs	r3, #10
	data.rsp = net_buf_add(data.buf, sizeof(*data.rsp));
   1969e:	900b      	str	r0, [sp, #44]	; 0x2c
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
   196a0:	4a0e      	ldr	r2, [pc, #56]	; (196dc <att_read_type_req+0xc8>)
	data.rsp->len = 0U;
   196a2:	f880 8000 	strb.w	r8, [r0]
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
   196a6:	4631      	mov	r1, r6
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
   196a8:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
	bt_gatt_foreach_attr(start_handle, end_handle, read_type_cb, &data);
   196ac:	4628      	mov	r0, r5
   196ae:	ab08      	add	r3, sp, #32
   196b0:	f011 fb28 	bl	2ad04 <bt_gatt_foreach_attr>
	if (data.err) {
   196b4:	f89d 4034 	ldrb.w	r4, [sp, #52]	; 0x34
   196b8:	b12c      	cbz	r4, 196c6 <att_read_type_req+0xb2>
		net_buf_unref(data.buf);
   196ba:	980a      	ldr	r0, [sp, #40]	; 0x28
   196bc:	f00b fe06 	bl	252cc <net_buf_unref>
	if (!req) {
   196c0:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
   196c4:	e7d8      	b.n	19678 <att_read_type_req+0x64>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
   196c6:	9400      	str	r4, [sp, #0]
   196c8:	4b05      	ldr	r3, [pc, #20]	; (196e0 <att_read_type_req+0xcc>)
   196ca:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   196cc:	2104      	movs	r1, #4
   196ce:	4638      	mov	r0, r7
   196d0:	f011 fa63 	bl	2ab9a <bt_l2cap_send_cb>
	return 0;
   196d4:	e7d6      	b.n	19684 <att_read_type_req+0x70>
		return BT_ATT_ERR_INVALID_PDU;
   196d6:	2404      	movs	r4, #4
   196d8:	e7d4      	b.n	19684 <att_read_type_req+0x70>
   196da:	bf00      	nop
   196dc:	0002ade9 	.word	0x0002ade9
   196e0:	0002afcb 	.word	0x0002afcb

000196e4 <att_find_type_req>:
{
   196e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   196e8:	4688      	mov	r8, r1
	struct bt_conn *conn = att->chan.chan.conn;
   196ea:	f8d0 b000 	ldr.w	fp, [r0]
{
   196ee:	b08b      	sub	sp, #44	; 0x2c
   196f0:	4681      	mov	r9, r0
	req = net_buf_pull_mem(buf, sizeof(*req));
   196f2:	2106      	movs	r1, #6
   196f4:	f108 0008 	add.w	r0, r8, #8
   196f8:	f013 fa73 	bl	2cbe2 <net_buf_simple_pull_mem>
	start_handle = sys_le16_to_cpu(req->start_handle);
   196fc:	8805      	ldrh	r5, [r0, #0]
	if (!start || !end) {
   196fe:	b1fd      	cbz	r5, 19740 <att_find_type_req+0x5c>
	end_handle = sys_le16_to_cpu(req->end_handle);
   19700:	8847      	ldrh	r7, [r0, #2]
	if (!start || !end) {
   19702:	b1e7      	cbz	r7, 1973e <att_find_type_req+0x5a>
	if (start > end) {
   19704:	42bd      	cmp	r5, r7
   19706:	d81b      	bhi.n	19740 <att_find_type_req+0x5c>
	type = sys_le16_to_cpu(req->type);
   19708:	8883      	ldrh	r3, [r0, #4]
	if (bt_uuid_cmp(BT_UUID_DECLARE_16(type), BT_UUID_GATT_PRIMARY)) {
   1970a:	f8ad 300e 	strh.w	r3, [sp, #14]
   1970e:	2400      	movs	r4, #0
   19710:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   19714:	a904      	add	r1, sp, #16
   19716:	a803      	add	r0, sp, #12
	value = buf->data;
   19718:	f8d8 a008 	ldr.w	sl, [r8, #8]
	if (bt_uuid_cmp(BT_UUID_DECLARE_16(type), BT_UUID_GATT_PRIMARY)) {
   1971c:	f88d 400c 	strb.w	r4, [sp, #12]
   19720:	f88d 4010 	strb.w	r4, [sp, #16]
   19724:	f8ad 3012 	strh.w	r3, [sp, #18]
   19728:	f010 ffad 	bl	2a686 <bt_uuid_cmp>
   1972c:	4606      	mov	r6, r0
   1972e:	b190      	cbz	r0, 19756 <att_find_type_req+0x72>
	if (!req) {
   19730:	230a      	movs	r3, #10
   19732:	462a      	mov	r2, r5
   19734:	2106      	movs	r1, #6
   19736:	4658      	mov	r0, fp
   19738:	f7ff fd5a 	bl	191f0 <send_err_rsp.part.11>
		return 0;
   1973c:	e007      	b.n	1974e <att_find_type_req+0x6a>
			*err = 0U;
   1973e:	463d      	mov	r5, r7
	if (!req) {
   19740:	2301      	movs	r3, #1
   19742:	462a      	mov	r2, r5
   19744:	2106      	movs	r1, #6
   19746:	4658      	mov	r0, fp
   19748:	f7ff fd52 	bl	191f0 <send_err_rsp.part.11>
		return 0;
   1974c:	2400      	movs	r4, #0
}
   1974e:	4620      	mov	r0, r4
   19750:	b00b      	add	sp, #44	; 0x2c
   19752:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	(void)memset(&data, 0, sizeof(data));
   19756:	2214      	movs	r2, #20
	return att_find_type_rsp(att, start_handle, end_handle, value,
   19758:	f898 400c 	ldrb.w	r4, [r8, #12]
	struct bt_conn *conn = att->chan.chan.conn;
   1975c:	f8d9 8000 	ldr.w	r8, [r9]
	(void)memset(&data, 0, sizeof(data));
   19760:	4601      	mov	r1, r0
   19762:	eb0d 0002 	add.w	r0, sp, r2
   19766:	f010 fe9c 	bl	2a4a2 <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_TYPE_RSP, 0);
   1976a:	4632      	mov	r2, r6
   1976c:	2107      	movs	r1, #7
   1976e:	4640      	mov	r0, r8
   19770:	f7ff fc96 	bl	190a0 <bt_att_create_pdu>
   19774:	9006      	str	r0, [sp, #24]
	if (!data.buf) {
   19776:	b310      	cbz	r0, 197be <att_find_type_req+0xda>
	data.err = BT_ATT_ERR_ATTRIBUTE_NOT_FOUND;
   19778:	230a      	movs	r3, #10
   1977a:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
   1977e:	4a11      	ldr	r2, [pc, #68]	; (197c4 <att_find_type_req+0xe0>)
	data.value_len = value_len;
   19780:	f88d 4024 	strb.w	r4, [sp, #36]	; 0x24
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
   19784:	ab05      	add	r3, sp, #20
   19786:	4639      	mov	r1, r7
   19788:	4628      	mov	r0, r5
	data.att = att;
   1978a:	f8cd 9014 	str.w	r9, [sp, #20]
	data.value = value;
   1978e:	e9cd 6a07 	strd	r6, sl, [sp, #28]
	bt_gatt_foreach_attr(start_handle, end_handle, find_type_cb, &data);
   19792:	f011 fab7 	bl	2ad04 <bt_gatt_foreach_attr>
	if (data.err) {
   19796:	f89d 4025 	ldrb.w	r4, [sp, #37]	; 0x25
   1979a:	b144      	cbz	r4, 197ae <att_find_type_req+0xca>
		net_buf_unref(data.buf);
   1979c:	9806      	ldr	r0, [sp, #24]
   1979e:	f00b fd95 	bl	252cc <net_buf_unref>
	if (!req) {
   197a2:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
   197a6:	462a      	mov	r2, r5
   197a8:	2106      	movs	r1, #6
   197aa:	4640      	mov	r0, r8
   197ac:	e7cc      	b.n	19748 <att_find_type_req+0x64>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
   197ae:	9400      	str	r4, [sp, #0]
   197b0:	4b05      	ldr	r3, [pc, #20]	; (197c8 <att_find_type_req+0xe4>)
   197b2:	9a06      	ldr	r2, [sp, #24]
   197b4:	2104      	movs	r1, #4
   197b6:	4640      	mov	r0, r8
   197b8:	f011 f9ef 	bl	2ab9a <bt_l2cap_send_cb>
	return 0;
   197bc:	e7c7      	b.n	1974e <att_find_type_req+0x6a>
		return BT_ATT_ERR_UNLIKELY;
   197be:	240e      	movs	r4, #14
	return att_find_type_rsp(att, start_handle, end_handle, value,
   197c0:	e7c5      	b.n	1974e <att_find_type_req+0x6a>
   197c2:	bf00      	nop
   197c4:	00018b0d 	.word	0x00018b0d
   197c8:	0002afcb 	.word	0x0002afcb

000197cc <att_find_info_req>:
{
   197cc:	b5f0      	push	{r4, r5, r6, r7, lr}
	req = (void *)buf->data;
   197ce:	688b      	ldr	r3, [r1, #8]
	struct bt_conn *conn = att->chan.chan.conn;
   197d0:	6806      	ldr	r6, [r0, #0]
	start_handle = sys_le16_to_cpu(req->start_handle);
   197d2:	881d      	ldrh	r5, [r3, #0]
{
   197d4:	b087      	sub	sp, #28
   197d6:	4607      	mov	r7, r0
	if (!start || !end) {
   197d8:	b195      	cbz	r5, 19800 <att_find_info_req+0x34>
	end_handle = sys_le16_to_cpu(req->end_handle);
   197da:	885c      	ldrh	r4, [r3, #2]
	if (!start || !end) {
   197dc:	b17c      	cbz	r4, 197fe <att_find_info_req+0x32>
	if (start > end) {
   197de:	42a5      	cmp	r5, r4
   197e0:	d80e      	bhi.n	19800 <att_find_info_req+0x34>
	(void)memset(&data, 0, sizeof(data));
   197e2:	2210      	movs	r2, #16
   197e4:	2100      	movs	r1, #0
   197e6:	a802      	add	r0, sp, #8
   197e8:	f010 fe5b 	bl	2a4a2 <memset>
	data.buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_INFO_RSP, 0);
   197ec:	2200      	movs	r2, #0
   197ee:	2105      	movs	r1, #5
   197f0:	4630      	mov	r0, r6
   197f2:	f7ff fc55 	bl	190a0 <bt_att_create_pdu>
   197f6:	9003      	str	r0, [sp, #12]
	if (!data.buf) {
   197f8:	b958      	cbnz	r0, 19812 <att_find_info_req+0x46>
		return BT_ATT_ERR_UNLIKELY;
   197fa:	200e      	movs	r0, #14
	return att_find_info_rsp(att, start_handle, end_handle);
   197fc:	e007      	b.n	1980e <att_find_info_req+0x42>
			*err = 0U;
   197fe:	4625      	mov	r5, r4
	if (!req) {
   19800:	2301      	movs	r3, #1
   19802:	462a      	mov	r2, r5
   19804:	2104      	movs	r1, #4
   19806:	4630      	mov	r0, r6
   19808:	f7ff fcf2 	bl	191f0 <send_err_rsp.part.11>
		return 0;
   1980c:	2000      	movs	r0, #0
}
   1980e:	b007      	add	sp, #28
   19810:	bdf0      	pop	{r4, r5, r6, r7, pc}
	bt_gatt_foreach_attr(start_handle, end_handle, find_info_cb, &data);
   19812:	4621      	mov	r1, r4
   19814:	ab02      	add	r3, sp, #8
   19816:	4a0a      	ldr	r2, [pc, #40]	; (19840 <att_find_info_req+0x74>)
	data.att = att;
   19818:	9702      	str	r7, [sp, #8]
	bt_gatt_foreach_attr(start_handle, end_handle, find_info_cb, &data);
   1981a:	4628      	mov	r0, r5
   1981c:	f011 fa72 	bl	2ad04 <bt_gatt_foreach_attr>
	if (!data.rsp) {
   19820:	9c04      	ldr	r4, [sp, #16]
   19822:	b924      	cbnz	r4, 1982e <att_find_info_req+0x62>
		net_buf_unref(data.buf);
   19824:	9803      	ldr	r0, [sp, #12]
   19826:	f00b fd51 	bl	252cc <net_buf_unref>
	if (!req) {
   1982a:	230a      	movs	r3, #10
   1982c:	e7e9      	b.n	19802 <att_find_info_req+0x36>
	(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf, att_rsp_sent,
   1982e:	2400      	movs	r4, #0
   19830:	9400      	str	r4, [sp, #0]
   19832:	4b04      	ldr	r3, [pc, #16]	; (19844 <att_find_info_req+0x78>)
   19834:	9a03      	ldr	r2, [sp, #12]
   19836:	2104      	movs	r1, #4
   19838:	4630      	mov	r0, r6
   1983a:	f011 f9ae 	bl	2ab9a <bt_l2cap_send_cb>
	return 0;
   1983e:	e7e5      	b.n	1980c <att_find_info_req+0x40>
   19840:	0002aea3 	.word	0x0002aea3
   19844:	0002afcb 	.word	0x0002afcb

00019848 <att_write_req>:
{
   19848:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct bt_conn *conn = att->chan.chan.conn;
   1984c:	6805      	ldr	r5, [r0, #0]
{
   1984e:	b089      	sub	sp, #36	; 0x24
	handle = net_buf_pull_le16(buf);
   19850:	f101 0008 	add.w	r0, r1, #8
{
   19854:	460c      	mov	r4, r1
	handle = net_buf_pull_le16(buf);
   19856:	f013 f9d4 	bl	2cc02 <net_buf_simple_pull_le16>
	if (!bt_gatt_change_aware(conn, req ? true : false)) {
   1985a:	2101      	movs	r1, #1
	handle = net_buf_pull_le16(buf);
   1985c:	4606      	mov	r6, r0
	if (!bt_gatt_change_aware(conn, req ? true : false)) {
   1985e:	4628      	mov	r0, r5
			     handle, 0, buf->data, buf->len);
   19860:	f8d4 9008 	ldr.w	r9, [r4, #8]
	return att_write_rsp(conn, BT_ATT_OP_WRITE_REQ, BT_ATT_OP_WRITE_RSP,
   19864:	89a4      	ldrh	r4, [r4, #12]
	if (!bt_gatt_change_aware(conn, req ? true : false)) {
   19866:	f011 fff1 	bl	2b84c <bt_gatt_change_aware>
   1986a:	2800      	cmp	r0, #0
   1986c:	d040      	beq.n	198f0 <att_write_req+0xa8>
	if (!handle) {
   1986e:	2e00      	cmp	r6, #0
   19870:	d040      	beq.n	198f4 <att_write_req+0xac>
	(void)memset(&data, 0, sizeof(data));
   19872:	2218      	movs	r2, #24
   19874:	2100      	movs	r1, #0
   19876:	a802      	add	r0, sp, #8
   19878:	f010 fe13 	bl	2a4a2 <memset>
		data.buf = bt_att_create_pdu(conn, rsp, 0);
   1987c:	2200      	movs	r2, #0
   1987e:	2113      	movs	r1, #19
   19880:	4628      	mov	r0, r5
   19882:	f7ff fc0d 	bl	190a0 <bt_att_create_pdu>
   19886:	9003      	str	r0, [sp, #12]
		if (!data.buf) {
   19888:	b380      	cbz	r0, 198ec <att_write_req+0xa4>
	data.err = BT_ATT_ERR_INVALID_HANDLE;
   1988a:	2301      	movs	r3, #1
   1988c:	f88d 301c 	strb.w	r3, [sp, #28]
	data.req = req;
   19890:	f04f 0812 	mov.w	r8, #18
	data.offset = offset;
   19894:	2700      	movs	r7, #0
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
   19896:	ab02      	add	r3, sp, #8
   19898:	4a17      	ldr	r2, [pc, #92]	; (198f8 <att_write_req+0xb0>)
	data.len = len;
   1989a:	f8ad 4018 	strh.w	r4, [sp, #24]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
   1989e:	4631      	mov	r1, r6
   198a0:	4630      	mov	r0, r6
	data.conn = conn;
   198a2:	9502      	str	r5, [sp, #8]
	data.req = req;
   198a4:	f88d 8010 	strb.w	r8, [sp, #16]
	data.offset = offset;
   198a8:	f8ad 701a 	strh.w	r7, [sp, #26]
	data.value = value;
   198ac:	f8cd 9014 	str.w	r9, [sp, #20]
	bt_gatt_foreach_attr(handle, handle, write_cb, &data);
   198b0:	f011 fa28 	bl	2ad04 <bt_gatt_foreach_attr>
	if (data.err) {
   198b4:	f89d 401c 	ldrb.w	r4, [sp, #28]
   198b8:	b174      	cbz	r4, 198d8 <att_write_req+0x90>
			net_buf_unref(data.buf);
   198ba:	9803      	ldr	r0, [sp, #12]
   198bc:	f00b fd06 	bl	252cc <net_buf_unref>
	if (!req) {
   198c0:	f89d 301c 	ldrb.w	r3, [sp, #28]
   198c4:	4632      	mov	r2, r6
   198c6:	4641      	mov	r1, r8
   198c8:	4628      	mov	r0, r5
   198ca:	f7ff fc91 	bl	191f0 <send_err_rsp.part.11>
		return req == BT_ATT_OP_EXEC_WRITE_REQ ? data.err : 0;
   198ce:	463c      	mov	r4, r7
}
   198d0:	4620      	mov	r0, r4
   198d2:	b009      	add	sp, #36	; 0x24
   198d4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (data.buf) {
   198d8:	9a03      	ldr	r2, [sp, #12]
   198da:	2a00      	cmp	r2, #0
   198dc:	d0f8      	beq.n	198d0 <att_write_req+0x88>
		(void)bt_l2cap_send_cb(conn, BT_L2CAP_CID_ATT, data.buf,
   198de:	9400      	str	r4, [sp, #0]
   198e0:	4b06      	ldr	r3, [pc, #24]	; (198fc <att_write_req+0xb4>)
   198e2:	2104      	movs	r1, #4
   198e4:	4628      	mov	r0, r5
   198e6:	f011 f958 	bl	2ab9a <bt_l2cap_send_cb>
   198ea:	e7f1      	b.n	198d0 <att_write_req+0x88>
			return BT_ATT_ERR_UNLIKELY;
   198ec:	240e      	movs	r4, #14
   198ee:	e7ef      	b.n	198d0 <att_write_req+0x88>
		return BT_ATT_ERR_DB_OUT_OF_SYNC;
   198f0:	2412      	movs	r4, #18
   198f2:	e7ed      	b.n	198d0 <att_write_req+0x88>
		return BT_ATT_ERR_INVALID_HANDLE;
   198f4:	2401      	movs	r4, #1
   198f6:	e7eb      	b.n	198d0 <att_write_req+0x88>
   198f8:	0002affd 	.word	0x0002affd
   198fc:	0002afcb 	.word	0x0002afcb

00019900 <bt_att_req_cancel>:

	return att_send_req(att, req);
}

void bt_att_req_cancel(struct bt_conn *conn, struct bt_att_req *req)
{
   19900:	b510      	push	{r4, lr}
   19902:	460c      	mov	r4, r1
	struct bt_att *att;

	BT_DBG("req %p", req);

	if (!conn || !req) {
   19904:	b370      	cbz	r0, 19964 <bt_att_req_cancel+0x64>
   19906:	b369      	cbz	r1, 19964 <bt_att_req_cancel+0x64>
		return;
	}

	att = att_chan_get(conn);
   19908:	f7ff fa3a 	bl	18d80 <att_chan_get>
	if (!att) {
   1990c:	b350      	cbz	r0, 19964 <bt_att_req_cancel+0x64>
		return;
	}

	/* Check if request is outstanding */
	if (att->req == req) {
   1990e:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
   19912:	429c      	cmp	r4, r3
   19914:	d107      	bne.n	19926 <bt_att_req_cancel+0x26>
		att->req = &cancel;
   19916:	4b14      	ldr	r3, [pc, #80]	; (19968 <bt_att_req_cancel+0x68>)
   19918:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
	} else {
		/* Remove request from the list */
		sys_slist_find_and_remove(&att->reqs, &req->node);
	}

	att_req_destroy(req);
   1991c:	4620      	mov	r0, r4
}
   1991e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	att_req_destroy(req);
   19922:	f011 b9cf 	b.w	2acc4 <att_req_destroy>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   19926:	f8d0 30b4 	ldr.w	r3, [r0, #180]	; 0xb4
   1992a:	2200      	movs	r2, #0
   1992c:	2b00      	cmp	r3, #0
   1992e:	d0f5      	beq.n	1991c <bt_att_req_cancel+0x1c>
   19930:	429c      	cmp	r4, r3
   19932:	d114      	bne.n	1995e <bt_att_req_cancel+0x5e>
Z_GENLIST_REMOVE(slist, snode)
   19934:	6823      	ldr	r3, [r4, #0]
   19936:	b952      	cbnz	r2, 1994e <bt_att_req_cancel+0x4e>
   19938:	f8d0 20b8 	ldr.w	r2, [r0, #184]	; 0xb8
	list->head = node;
   1993c:	f8c0 30b4 	str.w	r3, [r0, #180]	; 0xb4
Z_GENLIST_REMOVE(slist, snode)
   19940:	4294      	cmp	r4, r2
   19942:	d101      	bne.n	19948 <bt_att_req_cancel+0x48>
	list->tail = node;
   19944:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
	parent->next = child;
   19948:	2300      	movs	r3, #0
   1994a:	6023      	str	r3, [r4, #0]
   1994c:	e7e6      	b.n	1991c <bt_att_req_cancel+0x1c>
   1994e:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   19950:	f8d0 30b8 	ldr.w	r3, [r0, #184]	; 0xb8
   19954:	429c      	cmp	r4, r3
	list->tail = node;
   19956:	bf08      	it	eq
   19958:	f8c0 20b8 	streq.w	r2, [r0, #184]	; 0xb8
   1995c:	e7f4      	b.n	19948 <bt_att_req_cancel+0x48>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1995e:	461a      	mov	r2, r3
   19960:	681b      	ldr	r3, [r3, #0]
   19962:	e7e3      	b.n	1992c <bt_att_req_cancel+0x2c>
}
   19964:	bd10      	pop	{r4, pc}
   19966:	bf00      	nop
   19968:	2000171c 	.word	0x2000171c

0001996c <find_static_attr>:

	return BT_GATT_ITER_CONTINUE;
}

static u16_t find_static_attr(const struct bt_gatt_attr *attr)
{
   1996c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1996e:	490f      	ldr	r1, [pc, #60]	; (199ac <find_static_attr+0x40>)
	u16_t handle = 1;

	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   19970:	4f0f      	ldr	r7, [pc, #60]	; (199b0 <find_static_attr+0x44>)
	u16_t handle = 1;
   19972:	2501      	movs	r5, #1
		for (int i = 0; i < static_svc->attr_count; i++, handle++) {
			if (attr == &static_svc->attrs[i]) {
   19974:	f04f 0c14 	mov.w	ip, #20
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   19978:	f1a1 0308 	sub.w	r3, r1, #8
   1997c:	42bb      	cmp	r3, r7
   1997e:	d211      	bcs.n	199a4 <find_static_attr+0x38>
   19980:	f851 6c04 	ldr.w	r6, [r1, #-4]
		for (int i = 0; i < static_svc->attr_count; i++, handle++) {
   19984:	2200      	movs	r2, #0
   19986:	e006      	b.n	19996 <find_static_attr+0x2a>
			if (attr == &static_svc->attrs[i]) {
   19988:	f851 4c08 	ldr.w	r4, [r1, #-8]
   1998c:	fb0c 4402 	mla	r4, ip, r2, r4
   19990:	42a0      	cmp	r0, r4
   19992:	d008      	beq.n	199a6 <find_static_attr+0x3a>
		for (int i = 0; i < static_svc->attr_count; i++, handle++) {
   19994:	3201      	adds	r2, #1
   19996:	18ab      	adds	r3, r5, r2
   19998:	42b2      	cmp	r2, r6
   1999a:	b29b      	uxth	r3, r3
   1999c:	d1f4      	bne.n	19988 <find_static_attr+0x1c>
   1999e:	3108      	adds	r1, #8
   199a0:	461d      	mov	r5, r3
   199a2:	e7e9      	b.n	19978 <find_static_attr+0xc>
				return handle;
			}
		}
	}

	return 0;
   199a4:	2300      	movs	r3, #0
}
   199a6:	4618      	mov	r0, r3
   199a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   199aa:	bf00      	nop
   199ac:	0002db20 	.word	0x0002db20
   199b0:	0002db28 	.word	0x0002db28

000199b4 <gatt_subscription_remove>:
	bt_addr_le_copy(&params->_peer, &conn->le.dst);
}

static void gatt_subscription_remove(struct bt_conn *conn, sys_snode_t *prev,
				     struct bt_gatt_subscribe_params *params)
{
   199b4:	b570      	push	{r4, r5, r6, lr}
   199b6:	4614      	mov	r4, r2
   199b8:	4606      	mov	r6, r0
	/* Remove subscription from the list*/
	sys_slist_remove(&subscriptions, prev, &params->node);
   199ba:	322c      	adds	r2, #44	; 0x2c
   199bc:	4805      	ldr	r0, [pc, #20]	; (199d4 <gatt_subscription_remove+0x20>)
   199be:	f011 fc79 	bl	2b2b4 <sys_slist_remove>

	params->notify(conn, params, NULL, 0);
   199c2:	69e5      	ldr	r5, [r4, #28]
   199c4:	2300      	movs	r3, #0
   199c6:	4621      	mov	r1, r4
   199c8:	4630      	mov	r0, r6
   199ca:	46ac      	mov	ip, r5
   199cc:	461a      	mov	r2, r3
}
   199ce:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	params->notify(conn, params, NULL, 0);
   199d2:	4760      	bx	ip
   199d4:	200018c4 	.word	0x200018c4

000199d8 <gatt_notify>:
{
   199d8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   199dc:	4614      	mov	r4, r2
				sizeof(*nfy) + params->len);
   199de:	8992      	ldrh	r2, [r2, #12]
{
   199e0:	4689      	mov	r9, r1
	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY,
   199e2:	3202      	adds	r2, #2
   199e4:	211b      	movs	r1, #27
{
   199e6:	4680      	mov	r8, r0
	buf = bt_att_create_pdu(conn, BT_ATT_OP_NOTIFY,
   199e8:	f7ff fb5a 	bl	190a0 <bt_att_create_pdu>
	if (!buf) {
   199ec:	4605      	mov	r5, r0
   199ee:	b9b0      	cbnz	r0, 19a1e <gatt_notify+0x46>
		BT_WARN("No buffer available to send notification");
   199f0:	4b18      	ldr	r3, [pc, #96]	; (19a54 <gatt_notify+0x7c>)
   199f2:	681b      	ldr	r3, [r3, #0]
   199f4:	f013 0f06 	tst.w	r3, #6
   199f8:	d00d      	beq.n	19a16 <gatt_notify+0x3e>
   199fa:	2302      	movs	r3, #2
   199fc:	f04f 0100 	mov.w	r1, #0
   19a00:	f363 0107 	bfi	r1, r3, #0, #8
   19a04:	4a14      	ldr	r2, [pc, #80]	; (19a58 <gatt_notify+0x80>)
   19a06:	4b15      	ldr	r3, [pc, #84]	; (19a5c <gatt_notify+0x84>)
   19a08:	4815      	ldr	r0, [pc, #84]	; (19a60 <gatt_notify+0x88>)
   19a0a:	1a9b      	subs	r3, r3, r2
   19a0c:	08db      	lsrs	r3, r3, #3
   19a0e:	f363 118f 	bfi	r1, r3, #6, #10
   19a12:	f00e ff92 	bl	2893a <log_0>
}
   19a16:	f06f 000b 	mvn.w	r0, #11
   19a1a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	nfy = net_buf_add(buf, sizeof(*nfy));
   19a1e:	f100 0708 	add.w	r7, r0, #8
   19a22:	2102      	movs	r1, #2
   19a24:	4638      	mov	r0, r7
   19a26:	f013 f8ab 	bl	2cb80 <net_buf_simple_add>
	nfy->handle = sys_cpu_to_le16(handle);
   19a2a:	4606      	mov	r6, r0
	net_buf_add(buf, params->len);
   19a2c:	89a1      	ldrh	r1, [r4, #12]
	nfy->handle = sys_cpu_to_le16(handle);
   19a2e:	f826 9b02 	strh.w	r9, [r6], #2
	net_buf_add(buf, params->len);
   19a32:	4638      	mov	r0, r7
   19a34:	f013 f8a4 	bl	2cb80 <net_buf_simple_add>
	memcpy(nfy->value, params->data, params->len);
   19a38:	89a2      	ldrh	r2, [r4, #12]
   19a3a:	68a1      	ldr	r1, [r4, #8]
   19a3c:	4630      	mov	r0, r6
   19a3e:	f010 fd06 	bl	2a44e <memcpy>
	return bt_att_send(conn, buf, params->func, params->user_data);
   19a42:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
   19a46:	4629      	mov	r1, r5
   19a48:	4640      	mov	r0, r8
}
   19a4a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return bt_att_send(conn, buf, params->func, params->user_data);
   19a4e:	f011 bbdf 	b.w	2b210 <bt_att_send>
   19a52:	bf00      	nop
   19a54:	20010000 	.word	0x20010000
   19a58:	0002db28 	.word	0x0002db28
   19a5c:	0002dbf8 	.word	0x0002dbf8
   19a60:	0003138f 	.word	0x0003138f

00019a64 <disconnected_cb>:
{
   19a64:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
   19a68:	4b28      	ldr	r3, [pc, #160]	; (19b0c <disconnected_cb+0xa8>)
   19a6a:	6882      	ldr	r2, [r0, #8]
   19a6c:	429a      	cmp	r2, r3
{
   19a6e:	4681      	mov	r9, r0
   19a70:	4688      	mov	r8, r1
	if (attr->write != bt_gatt_attr_write_ccc) {
   19a72:	d121      	bne.n	19ab8 <disconnected_cb+0x54>
	ccc = attr->user_data;
   19a74:	68c6      	ldr	r6, [r0, #12]
	if (!ccc->value) {
   19a76:	8e73      	ldrh	r3, [r6, #50]	; 0x32
   19a78:	b1f3      	cbz	r3, 19ab8 <disconnected_cb+0x54>
   19a7a:	1c74      	adds	r4, r6, #1
   19a7c:	f106 0b33 	add.w	fp, r6, #51	; 0x33
	value_used = false;
   19a80:	2500      	movs	r5, #0
			if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   19a82:	f101 0a70 	add.w	sl, r1, #112	; 0x70
		if (!cfg->value) {
   19a86:	f8b4 3007 	ldrh.w	r3, [r4, #7]
   19a8a:	b15b      	cbz	r3, 19aa4 <disconnected_cb+0x40>
		if (conn->id != cfg->id ||
   19a8c:	f898 2008 	ldrb.w	r2, [r8, #8]
   19a90:	f814 3c01 	ldrb.w	r3, [r4, #-1]
   19a94:	429a      	cmp	r2, r3
   19a96:	d013      	beq.n	19ac0 <disconnected_cb+0x5c>
			tmp = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
   19a98:	4621      	mov	r1, r4
   19a9a:	f814 0c01 	ldrb.w	r0, [r4, #-1]
   19a9e:	f7fe fafd 	bl	1809c <bt_conn_lookup_addr_le>
			if (tmp) {
   19aa2:	bb30      	cbnz	r0, 19af2 <disconnected_cb+0x8e>
   19aa4:	340a      	adds	r4, #10
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   19aa6:	455c      	cmp	r4, fp
   19aa8:	d1ed      	bne.n	19a86 <disconnected_cb+0x22>
	if (!value_used) {
   19aaa:	b92d      	cbnz	r5, 19ab8 <disconnected_cb+0x54>
		if (ccc->cfg_changed) {
   19aac:	6b73      	ldr	r3, [r6, #52]	; 0x34
		ccc->value = 0U;
   19aae:	8675      	strh	r5, [r6, #50]	; 0x32
		if (ccc->cfg_changed) {
   19ab0:	b113      	cbz	r3, 19ab8 <disconnected_cb+0x54>
			ccc->cfg_changed(attr, ccc->value);
   19ab2:	4629      	mov	r1, r5
   19ab4:	4648      	mov	r0, r9
   19ab6:	4798      	blx	r3
}
   19ab8:	2001      	movs	r0, #1
   19aba:	b003      	add	sp, #12
   19abc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    bt_conn_addr_le_cmp(conn, &cfg->peer)) {
   19ac0:	4621      	mov	r1, r4
   19ac2:	4640      	mov	r0, r8
   19ac4:	f010 ff81 	bl	2a9ca <bt_conn_addr_le_cmp>
		if (conn->id != cfg->id ||
   19ac8:	2800      	cmp	r0, #0
   19aca:	d1e5      	bne.n	19a98 <disconnected_cb+0x34>
			if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   19acc:	4651      	mov	r1, sl
   19ace:	f898 0008 	ldrb.w	r0, [r8, #8]
   19ad2:	f010 ff0f 	bl	2a8f4 <bt_addr_le_is_bonded>
   19ad6:	4607      	mov	r7, r0
   19ad8:	b990      	cbnz	r0, 19b00 <disconnected_cb+0x9c>
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   19ada:	9000      	str	r0, [sp, #0]
   19adc:	4669      	mov	r1, sp
   19ade:	f8cd 0003 	str.w	r0, [sp, #3]
   19ae2:	4620      	mov	r0, r4
   19ae4:	f011 fc77 	bl	2b3d6 <bt_addr_le_copy>
	cfg->id = 0U;
   19ae8:	f804 7c01 	strb.w	r7, [r4, #-1]
	cfg->value = 0U;
   19aec:	f8a4 7007 	strh.w	r7, [r4, #7]
   19af0:	e7d8      	b.n	19aa4 <disconnected_cb+0x40>
				if (tmp->state == BT_CONN_CONNECTED) {
   19af2:	7a83      	ldrb	r3, [r0, #10]
					value_used = true;
   19af4:	2b04      	cmp	r3, #4
   19af6:	bf08      	it	eq
   19af8:	2501      	moveq	r5, #1
				bt_conn_unref(tmp);
   19afa:	f010 ff85 	bl	2aa08 <bt_conn_unref>
   19afe:	e7d1      	b.n	19aa4 <disconnected_cb+0x40>
				bt_addr_le_copy(&cfg->peer, &conn->le.dst);
   19b00:	4651      	mov	r1, sl
   19b02:	4620      	mov	r0, r4
   19b04:	f011 fc67 	bl	2b3d6 <bt_addr_le_copy>
   19b08:	e7cc      	b.n	19aa4 <disconnected_cb+0x40>
   19b0a:	bf00      	nop
   19b0c:	0001a0a1 	.word	0x0001a0a1

00019b10 <gatt_send.constprop.37>:
static int gatt_send(struct bt_conn *conn, struct net_buf *buf,
   19b10:	b538      	push	{r3, r4, r5, lr}
   19b12:	4614      	mov	r4, r2
	if (params) {
   19b14:	461a      	mov	r2, r3
   19b16:	b1eb      	cbz	r3, 19b54 <gatt_send.constprop.37+0x44>
		req->buf = buf;
   19b18:	6111      	str	r1, [r2, #16]
		req->func = func;
   19b1a:	605c      	str	r4, [r3, #4]
		req->destroy = destroy;
   19b1c:	2300      	movs	r3, #0
   19b1e:	6093      	str	r3, [r2, #8]
		err = bt_att_req_send(conn, req);
   19b20:	4611      	mov	r1, r2
   19b22:	f011 fba5 	bl	2b270 <bt_att_req_send>
		err = bt_att_send(conn, buf, NULL, NULL);
   19b26:	4604      	mov	r4, r0
	if (err) {
   19b28:	b190      	cbz	r0, 19b50 <gatt_send.constprop.37+0x40>
		BT_ERR("Error sending ATT PDU: %d", err);
   19b2a:	4b0c      	ldr	r3, [pc, #48]	; (19b5c <gatt_send.constprop.37+0x4c>)
   19b2c:	681b      	ldr	r3, [r3, #0]
   19b2e:	075b      	lsls	r3, r3, #29
   19b30:	d00e      	beq.n	19b50 <gatt_send.constprop.37+0x40>
   19b32:	2301      	movs	r3, #1
   19b34:	f04f 0200 	mov.w	r2, #0
   19b38:	f363 0207 	bfi	r2, r3, #0, #8
   19b3c:	4908      	ldr	r1, [pc, #32]	; (19b60 <gatt_send.constprop.37+0x50>)
   19b3e:	4b09      	ldr	r3, [pc, #36]	; (19b64 <gatt_send.constprop.37+0x54>)
   19b40:	1a5b      	subs	r3, r3, r1
   19b42:	08db      	lsrs	r3, r3, #3
   19b44:	4601      	mov	r1, r0
   19b46:	f363 128f 	bfi	r2, r3, #6, #10
   19b4a:	4807      	ldr	r0, [pc, #28]	; (19b68 <gatt_send.constprop.37+0x58>)
   19b4c:	f00e ff02 	bl	28954 <log_1>
}
   19b50:	4620      	mov	r0, r4
   19b52:	bd38      	pop	{r3, r4, r5, pc}
		err = bt_att_send(conn, buf, NULL, NULL);
   19b54:	f011 fb5c 	bl	2b210 <bt_att_send>
   19b58:	e7e5      	b.n	19b26 <gatt_send.constprop.37+0x16>
   19b5a:	bf00      	nop
   19b5c:	20010000 	.word	0x20010000
   19b60:	0002db28 	.word	0x0002db28
   19b64:	0002dbf8 	.word	0x0002dbf8
   19b68:	000313db 	.word	0x000313db

00019b6c <gatt_indicate>:
{
   19b6c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   19b70:	4614      	mov	r4, r2
				sizeof(*ind) + params->len);
   19b72:	8c92      	ldrh	r2, [r2, #36]	; 0x24
{
   19b74:	4689      	mov	r9, r1
	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE,
   19b76:	3202      	adds	r2, #2
   19b78:	211d      	movs	r1, #29
{
   19b7a:	4680      	mov	r8, r0
	buf = bt_att_create_pdu(conn, BT_ATT_OP_INDICATE,
   19b7c:	f7ff fa90 	bl	190a0 <bt_att_create_pdu>
	if (!buf) {
   19b80:	4605      	mov	r5, r0
   19b82:	b9b0      	cbnz	r0, 19bb2 <gatt_indicate+0x46>
		BT_WARN("No buffer available to send indication");
   19b84:	4b1a      	ldr	r3, [pc, #104]	; (19bf0 <gatt_indicate+0x84>)
   19b86:	681b      	ldr	r3, [r3, #0]
   19b88:	f013 0f06 	tst.w	r3, #6
   19b8c:	d00d      	beq.n	19baa <gatt_indicate+0x3e>
   19b8e:	2302      	movs	r3, #2
   19b90:	f04f 0100 	mov.w	r1, #0
   19b94:	f363 0107 	bfi	r1, r3, #0, #8
   19b98:	4a16      	ldr	r2, [pc, #88]	; (19bf4 <gatt_indicate+0x88>)
   19b9a:	4b17      	ldr	r3, [pc, #92]	; (19bf8 <gatt_indicate+0x8c>)
   19b9c:	4817      	ldr	r0, [pc, #92]	; (19bfc <gatt_indicate+0x90>)
   19b9e:	1a9b      	subs	r3, r3, r2
   19ba0:	08db      	lsrs	r3, r3, #3
   19ba2:	f363 118f 	bfi	r1, r3, #6, #10
   19ba6:	f00e fec8 	bl	2893a <log_0>
}
   19baa:	f06f 000b 	mvn.w	r0, #11
   19bae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ind = net_buf_add(buf, sizeof(*ind));
   19bb2:	f100 0608 	add.w	r6, r0, #8
   19bb6:	2102      	movs	r1, #2
   19bb8:	4630      	mov	r0, r6
   19bba:	f012 ffe1 	bl	2cb80 <net_buf_simple_add>
	ind->handle = sys_cpu_to_le16(handle);
   19bbe:	4607      	mov	r7, r0
	net_buf_add(buf, params->len);
   19bc0:	8ca1      	ldrh	r1, [r4, #36]	; 0x24
	ind->handle = sys_cpu_to_le16(handle);
   19bc2:	f827 9b02 	strh.w	r9, [r7], #2
	net_buf_add(buf, params->len);
   19bc6:	4630      	mov	r0, r6
   19bc8:	f012 ffda 	bl	2cb80 <net_buf_simple_add>
	memcpy(ind->value, params->data, params->len);
   19bcc:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
   19bce:	6a21      	ldr	r1, [r4, #32]
   19bd0:	4638      	mov	r0, r7
   19bd2:	f010 fc3c 	bl	2a44e <memcpy>
	if (!params->func) {
   19bd6:	69e3      	ldr	r3, [r4, #28]
   19bd8:	b933      	cbnz	r3, 19be8 <gatt_indicate+0x7c>
		return gatt_send(conn, buf, NULL, NULL, NULL);
   19bda:	461a      	mov	r2, r3
	return gatt_send(conn, buf, gatt_indicate_rsp, params, NULL);
   19bdc:	4629      	mov	r1, r5
   19bde:	4640      	mov	r0, r8
}
   19be0:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return gatt_send(conn, buf, gatt_indicate_rsp, params, NULL);
   19be4:	f7ff bf94 	b.w	19b10 <gatt_send.constprop.37>
   19be8:	4623      	mov	r3, r4
   19bea:	4a05      	ldr	r2, [pc, #20]	; (19c00 <gatt_indicate+0x94>)
   19bec:	e7f6      	b.n	19bdc <gatt_indicate+0x70>
   19bee:	bf00      	nop
   19bf0:	20010000 	.word	0x20010000
   19bf4:	0002db28 	.word	0x0002db28
   19bf8:	0002dbf8 	.word	0x0002dbf8
   19bfc:	00031368 	.word	0x00031368
   19c00:	0002b30f 	.word	0x0002b30f

00019c04 <find_sc_cfg>:
{
   19c04:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   19c08:	4c0e      	ldr	r4, [pc, #56]	; (19c44 <find_sc_cfg+0x40>)
   19c0a:	4607      	mov	r7, r0
   19c0c:	4688      	mov	r8, r1
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
   19c0e:	2600      	movs	r6, #0
   19c10:	4625      	mov	r5, r4
   19c12:	f04f 090c 	mov.w	r9, #12
		if (id == sc_cfg[i].id &&
   19c16:	7823      	ldrb	r3, [r4, #0]
   19c18:	42bb      	cmp	r3, r7
   19c1a:	d10b      	bne.n	19c34 <find_sc_cfg+0x30>
	return memcmp(a, b, sizeof(*a));
   19c1c:	2207      	movs	r2, #7
   19c1e:	4641      	mov	r1, r8
   19c20:	1c60      	adds	r0, r4, #1
   19c22:	fb09 fa06 	mul.w	sl, r9, r6
   19c26:	f010 fbeb 	bl	2a400 <memcmp>
   19c2a:	b918      	cbnz	r0, 19c34 <find_sc_cfg+0x30>
			return &sc_cfg[i];
   19c2c:	eb05 000a 	add.w	r0, r5, sl
}
   19c30:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	for (size_t i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
   19c34:	3601      	adds	r6, #1
   19c36:	2e05      	cmp	r6, #5
   19c38:	f104 040c 	add.w	r4, r4, #12
   19c3c:	d1eb      	bne.n	19c16 <find_sc_cfg+0x12>
	return NULL;
   19c3e:	2000      	movs	r0, #0
   19c40:	e7f6      	b.n	19c30 <find_sc_cfg+0x2c>
   19c42:	bf00      	nop
   19c44:	20003cb6 	.word	0x20003cb6

00019c48 <sc_save>:
{
   19c48:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   19c4c:	4680      	mov	r8, r0
   19c4e:	460f      	mov	r7, r1
   19c50:	4616      	mov	r6, r2
   19c52:	461d      	mov	r5, r3
	cfg = find_sc_cfg(id, peer);
   19c54:	f7ff ffd6 	bl	19c04 <find_sc_cfg>
	if (!cfg) {
   19c58:	4604      	mov	r4, r0
   19c5a:	bb08      	cbnz	r0, 19ca0 <sc_save+0x58>
		cfg = find_sc_cfg(BT_ID_DEFAULT, BT_ADDR_LE_ANY);
   19c5c:	4669      	mov	r1, sp
   19c5e:	9000      	str	r0, [sp, #0]
   19c60:	f8cd 0003 	str.w	r0, [sp, #3]
   19c64:	f7ff ffce 	bl	19c04 <find_sc_cfg>
		if (!cfg) {
   19c68:	4604      	mov	r4, r0
   19c6a:	b9a0      	cbnz	r0, 19c96 <sc_save+0x4e>
			BT_ERR("unable to save SC: no cfg left");
   19c6c:	4b13      	ldr	r3, [pc, #76]	; (19cbc <sc_save+0x74>)
   19c6e:	681b      	ldr	r3, [r3, #0]
   19c70:	075b      	lsls	r3, r3, #29
   19c72:	d00d      	beq.n	19c90 <sc_save+0x48>
   19c74:	2301      	movs	r3, #1
   19c76:	f04f 0100 	mov.w	r1, #0
   19c7a:	f363 0107 	bfi	r1, r3, #0, #8
   19c7e:	4a10      	ldr	r2, [pc, #64]	; (19cc0 <sc_save+0x78>)
   19c80:	4b10      	ldr	r3, [pc, #64]	; (19cc4 <sc_save+0x7c>)
   19c82:	4811      	ldr	r0, [pc, #68]	; (19cc8 <sc_save+0x80>)
   19c84:	1a9b      	subs	r3, r3, r2
   19c86:	08db      	lsrs	r3, r3, #3
   19c88:	f363 118f 	bfi	r1, r3, #6, #10
   19c8c:	f00e fe55 	bl	2893a <log_0>
}
   19c90:	b002      	add	sp, #8
   19c92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cfg->id = id;
   19c96:	f800 8b01 	strb.w	r8, [r0], #1
		bt_addr_le_copy(&cfg->peer, peer);
   19c9a:	4639      	mov	r1, r7
   19c9c:	f011 fb9b 	bl	2b3d6 <bt_addr_le_copy>
	if (!(cfg->data.start || cfg->data.end)) {
   19ca0:	8922      	ldrh	r2, [r4, #8]
   19ca2:	8963      	ldrh	r3, [r4, #10]
   19ca4:	b91a      	cbnz	r2, 19cae <sc_save+0x66>
   19ca6:	b923      	cbnz	r3, 19cb2 <sc_save+0x6a>
		cfg->data.start = start;
   19ca8:	8126      	strh	r6, [r4, #8]
		*end = new_end;
   19caa:	8165      	strh	r5, [r4, #10]
   19cac:	e7f0      	b.n	19c90 <sc_save+0x48>
	if (new_start >= *start && new_end <= *end) {
   19cae:	4296      	cmp	r6, r2
   19cb0:	d302      	bcc.n	19cb8 <sc_save+0x70>
   19cb2:	429d      	cmp	r5, r3
   19cb4:	d9ec      	bls.n	19c90 <sc_save+0x48>
   19cb6:	e7f8      	b.n	19caa <sc_save+0x62>
		*start = new_start;
   19cb8:	8126      	strh	r6, [r4, #8]
	if (*end < new_end) {
   19cba:	e7fa      	b.n	19cb2 <sc_save+0x6a>
   19cbc:	20010000 	.word	0x20010000
   19cc0:	0002db28 	.word	0x0002db28
   19cc4:	0002dbf8 	.word	0x0002dbf8
   19cc8:	000313f5 	.word	0x000313f5

00019ccc <notify_cb>:
{
   19ccc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (attr->write != bt_gatt_attr_write_ccc) {
   19cd0:	4b37      	ldr	r3, [pc, #220]	; (19db0 <notify_cb+0xe4>)
   19cd2:	6882      	ldr	r2, [r0, #8]
   19cd4:	429a      	cmp	r2, r3
{
   19cd6:	4607      	mov	r7, r0
   19cd8:	460d      	mov	r5, r1
	if (attr->write != bt_gatt_attr_write_ccc) {
   19cda:	d003      	beq.n	19ce4 <notify_cb+0x18>
		return BT_GATT_ITER_CONTINUE;
   19cdc:	2001      	movs	r0, #1
}
   19cde:	b003      	add	sp, #12
   19ce0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	ccc = attr->user_data;
   19ce4:	68c6      	ldr	r6, [r0, #12]
	if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) && ccc == &sc_ccc) {
   19ce6:	4b33      	ldr	r3, [pc, #204]	; (19db4 <notify_cb+0xe8>)
   19ce8:	429e      	cmp	r6, r3
   19cea:	d019      	beq.n	19d20 <notify_cb+0x54>
   19cec:	1c74      	adds	r4, r6, #1
   19cee:	f106 0833 	add.w	r8, r6, #51	; 0x33
   19cf2:	f04f 0900 	mov.w	r9, #0
		if (cfg->value != data->type) {
   19cf6:	f8b4 2007 	ldrh.w	r2, [r4, #7]
   19cfa:	88ab      	ldrh	r3, [r5, #4]
   19cfc:	429a      	cmp	r2, r3
   19cfe:	d10b      	bne.n	19d18 <notify_cb+0x4c>
		conn = bt_conn_lookup_addr_le(cfg->id, &cfg->peer);
   19d00:	4621      	mov	r1, r4
   19d02:	f814 0c01 	ldrb.w	r0, [r4, #-1]
   19d06:	f7fe f9c9 	bl	1809c <bt_conn_lookup_addr_le>
		if (!conn) {
   19d0a:	4682      	mov	sl, r0
   19d0c:	b120      	cbz	r0, 19d18 <notify_cb+0x4c>
		if (conn->state != BT_CONN_CONNECTED) {
   19d0e:	7a83      	ldrb	r3, [r0, #10]
   19d10:	2b04      	cmp	r3, #4
   19d12:	d02c      	beq.n	19d6e <notify_cb+0xa2>
			bt_conn_unref(conn);
   19d14:	f010 fe78 	bl	2aa08 <bt_conn_unref>
			continue;
   19d18:	340a      	adds	r4, #10
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   19d1a:	45a0      	cmp	r8, r4
   19d1c:	d1eb      	bne.n	19cf6 <notify_cb+0x2a>
   19d1e:	e7dd      	b.n	19cdc <notify_cb+0x10>
		for (i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
   19d20:	2400      	movs	r4, #0
   19d22:	f8df 8094 	ldr.w	r8, [pc, #148]	; 19db8 <notify_cb+0xec>
			if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
   19d26:	46a2      	mov	sl, r4
   19d28:	f108 0901 	add.w	r9, r8, #1
   19d2c:	2207      	movs	r2, #7
   19d2e:	4669      	mov	r1, sp
   19d30:	4648      	mov	r0, r9
   19d32:	f8cd a000 	str.w	sl, [sp]
   19d36:	f8cd a003 	str.w	sl, [sp, #3]
   19d3a:	f010 fb61 	bl	2a400 <memcmp>
   19d3e:	b168      	cbz	r0, 19d5c <notify_cb+0x90>
			conn = bt_conn_lookup_state_le(&cfg->peer,
   19d40:	2104      	movs	r1, #4
   19d42:	4648      	mov	r0, r9
   19d44:	f7fe f9d2 	bl	180ec <bt_conn_lookup_state_le>
			if (!conn) {
   19d48:	b970      	cbnz	r0, 19d68 <notify_cb+0x9c>
				sc = (struct sc_data *)data->ind_params->data;
   19d4a:	68ab      	ldr	r3, [r5, #8]
				sc_save(cfg->id, &cfg->peer,
   19d4c:	f898 0000 	ldrb.w	r0, [r8]
				sc = (struct sc_data *)data->ind_params->data;
   19d50:	6a1a      	ldr	r2, [r3, #32]
				sc_save(cfg->id, &cfg->peer,
   19d52:	4649      	mov	r1, r9
   19d54:	8853      	ldrh	r3, [r2, #2]
   19d56:	8812      	ldrh	r2, [r2, #0]
   19d58:	f7ff ff76 	bl	19c48 <sc_save>
		for (i = 0; i < ARRAY_SIZE(sc_cfg); i++) {
   19d5c:	3401      	adds	r4, #1
   19d5e:	2c05      	cmp	r4, #5
   19d60:	f108 080c 	add.w	r8, r8, #12
   19d64:	d1e0      	bne.n	19d28 <notify_cb+0x5c>
   19d66:	e7c1      	b.n	19cec <notify_cb+0x20>
			bt_conn_unref(conn);
   19d68:	f010 fe4e 	bl	2aa08 <bt_conn_unref>
   19d6c:	e7f6      	b.n	19d5c <notify_cb+0x90>
		if (ccc->cfg_match && !ccc->cfg_match(conn, attr)) {
   19d6e:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
   19d70:	b123      	cbz	r3, 19d7c <notify_cb+0xb0>
   19d72:	4639      	mov	r1, r7
   19d74:	4798      	blx	r3
   19d76:	b908      	cbnz	r0, 19d7c <notify_cb+0xb0>
			bt_conn_unref(conn);
   19d78:	4650      	mov	r0, sl
   19d7a:	e7cb      	b.n	19d14 <notify_cb+0x48>
		if (data->type == BT_GATT_CCC_INDICATE) {
   19d7c:	8a39      	ldrh	r1, [r7, #16]
   19d7e:	88ab      	ldrh	r3, [r5, #4]
   19d80:	68aa      	ldr	r2, [r5, #8]
   19d82:	3901      	subs	r1, #1
   19d84:	2b02      	cmp	r3, #2
   19d86:	b289      	uxth	r1, r1
			err = gatt_indicate(conn, attr->handle - 1,
   19d88:	4650      	mov	r0, sl
		if (data->type == BT_GATT_CCC_INDICATE) {
   19d8a:	d10b      	bne.n	19da4 <notify_cb+0xd8>
			err = gatt_indicate(conn, attr->handle - 1,
   19d8c:	f7ff feee 	bl	19b6c <gatt_indicate>
			err = gatt_notify(conn, attr->handle - 1,
   19d90:	4683      	mov	fp, r0
		bt_conn_unref(conn);
   19d92:	4650      	mov	r0, sl
   19d94:	f010 fe38 	bl	2aa08 <bt_conn_unref>
		if (err < 0) {
   19d98:	f1bb 0f00 	cmp.w	fp, #0
   19d9c:	db05      	blt.n	19daa <notify_cb+0xde>
		data->err = 0;
   19d9e:	f8c5 9000 	str.w	r9, [r5]
   19da2:	e7b9      	b.n	19d18 <notify_cb+0x4c>
			err = gatt_notify(conn, attr->handle - 1,
   19da4:	f7ff fe18 	bl	199d8 <gatt_notify>
   19da8:	e7f2      	b.n	19d90 <notify_cb+0xc4>
			return BT_GATT_ITER_STOP;
   19daa:	2000      	movs	r0, #0
   19dac:	e797      	b.n	19cde <notify_cb+0x12>
   19dae:	bf00      	nop
   19db0:	0001a0a1 	.word	0x0001a0a1
   19db4:	2000fa54 	.word	0x2000fa54
   19db8:	20003cb6 	.word	0x20003cb6

00019dbc <find_cf_cfg>:
{
   19dbc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   19dbe:	4c0d      	ldr	r4, [pc, #52]	; (19df4 <find_cf_cfg+0x38>)
   19dc0:	4606      	mov	r6, r0
   19dc2:	2500      	movs	r5, #0
   19dc4:	1c67      	adds	r7, r4, #1
		if (!conn) {
   19dc6:	1978      	adds	r0, r7, r5
   19dc8:	b956      	cbnz	r6, 19de0 <find_cf_cfg+0x24>
   19dca:	2207      	movs	r2, #7
   19dcc:	4669      	mov	r1, sp
			if (!bt_addr_le_cmp(&cf_cfg[i].peer, BT_ADDR_LE_ANY)) {
   19dce:	9600      	str	r6, [sp, #0]
   19dd0:	f8cd 6003 	str.w	r6, [sp, #3]
   19dd4:	f010 fb14 	bl	2a400 <memcmp>
		} else if (!bt_conn_addr_le_cmp(conn, &cf_cfg[i].peer)) {
   19dd8:	b938      	cbnz	r0, 19dea <find_cf_cfg+0x2e>
			return &cf_cfg[i];
   19dda:	1960      	adds	r0, r4, r5
}
   19ddc:	b003      	add	sp, #12
   19dde:	bdf0      	pop	{r4, r5, r6, r7, pc}
		} else if (!bt_conn_addr_le_cmp(conn, &cf_cfg[i].peer)) {
   19de0:	4601      	mov	r1, r0
   19de2:	4630      	mov	r0, r6
   19de4:	f010 fdf1 	bl	2a9ca <bt_conn_addr_le_cmp>
   19de8:	e7f6      	b.n	19dd8 <find_cf_cfg+0x1c>
   19dea:	3510      	adds	r5, #16
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
   19dec:	2d50      	cmp	r5, #80	; 0x50
   19dee:	d1ea      	bne.n	19dc6 <find_cf_cfg+0xa>
	return NULL;
   19df0:	2000      	movs	r0, #0
   19df2:	e7f3      	b.n	19ddc <find_cf_cfg+0x20>
   19df4:	20001730 	.word	0x20001730

00019df8 <gatt_write_ccc_rsp>:
}

static void gatt_write_ccc_rsp(struct bt_conn *conn, u8_t err,
			       const void *pdu, u16_t length,
			       void *user_data)
{
   19df8:	b570      	push	{r4, r5, r6, lr}
   19dfa:	9c04      	ldr	r4, [sp, #16]
   19dfc:	460e      	mov	r6, r1
   19dfe:	4605      	mov	r5, r0
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   19e00:	f06f 0102 	mvn.w	r1, #2
   19e04:	f104 0028 	add.w	r0, r4, #40	; 0x28
   19e08:	f011 faf1 	bl	2b3ee <atomic_and>
	BT_DBG("err 0x%02x", err);

	atomic_clear_bit(params->flags, BT_GATT_SUBSCRIBE_FLAG_WRITE_PENDING);

	/* if write to CCC failed we remove subscription and notify app */
	if (err) {
   19e0c:	b18e      	cbz	r6, 19e32 <gatt_write_ccc_rsp+0x3a>
		sys_snode_t *node, *tmp, *prev = NULL;

		SYS_SLIST_FOR_EACH_NODE_SAFE(&subscriptions, node, tmp) {
   19e0e:	4b0e      	ldr	r3, [pc, #56]	; (19e48 <gatt_write_ccc_rsp+0x50>)
   19e10:	681b      	ldr	r3, [r3, #0]
Z_GENLIST_PEEK_NEXT(slist, snode)
   19e12:	b1c3      	cbz	r3, 19e46 <gatt_write_ccc_rsp+0x4e>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   19e14:	6819      	ldr	r1, [r3, #0]
			if (node == &params->node) {
   19e16:	f104 022c 	add.w	r2, r4, #44	; 0x2c
   19e1a:	4293      	cmp	r3, r2
   19e1c:	d105      	bne.n	19e2a <gatt_write_ccc_rsp+0x32>
				gatt_subscription_remove(conn, tmp, params);
   19e1e:	4622      	mov	r2, r4
   19e20:	4628      	mov	r0, r5
		}
	} else if (!params->value) {
		/* Notify with NULL data to complete unsubscribe */
		params->notify(conn, params, NULL, 0);
	}
}
   19e22:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				gatt_subscription_remove(conn, tmp, params);
   19e26:	f7ff bdc5 	b.w	199b4 <gatt_subscription_remove>
Z_GENLIST_PEEK_NEXT(slist, snode)
   19e2a:	b161      	cbz	r1, 19e46 <gatt_write_ccc_rsp+0x4e>
   19e2c:	460b      	mov	r3, r1
   19e2e:	6809      	ldr	r1, [r1, #0]
   19e30:	e7f3      	b.n	19e1a <gatt_write_ccc_rsp+0x22>
	} else if (!params->value) {
   19e32:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
   19e34:	b93b      	cbnz	r3, 19e46 <gatt_write_ccc_rsp+0x4e>
		params->notify(conn, params, NULL, 0);
   19e36:	69e6      	ldr	r6, [r4, #28]
   19e38:	4621      	mov	r1, r4
   19e3a:	4628      	mov	r0, r5
   19e3c:	46b4      	mov	ip, r6
   19e3e:	461a      	mov	r2, r3
}
   19e40:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		params->notify(conn, params, NULL, 0);
   19e44:	4760      	bx	ip
}
   19e46:	bd70      	pop	{r4, r5, r6, pc}
   19e48:	200018c4 	.word	0x200018c4

00019e4c <gatt_write_ccc.constprop.27>:

static int gatt_write_ccc(struct bt_conn *conn, u16_t handle, u16_t value,
   19e4c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   19e50:	4689      	mov	r9, r1
   19e52:	4690      	mov	r8, r2
			  struct bt_gatt_subscribe_params *params)
{
	struct net_buf *buf;
	struct bt_att_write_req *req;

	buf = bt_att_create_pdu(conn, BT_ATT_OP_WRITE_REQ,
   19e54:	2112      	movs	r1, #18
   19e56:	2204      	movs	r2, #4
static int gatt_write_ccc(struct bt_conn *conn, u16_t handle, u16_t value,
   19e58:	4607      	mov	r7, r0
   19e5a:	461d      	mov	r5, r3
	buf = bt_att_create_pdu(conn, BT_ATT_OP_WRITE_REQ,
   19e5c:	f7ff f920 	bl	190a0 <bt_att_create_pdu>
				sizeof(*req) + sizeof(u16_t));
	if (!buf) {
   19e60:	4604      	mov	r4, r0
   19e62:	b308      	cbz	r0, 19ea8 <gatt_write_ccc.constprop.27+0x5c>
		return -ENOMEM;
	}

	req = net_buf_add(buf, sizeof(*req));
   19e64:	f100 0608 	add.w	r6, r0, #8
   19e68:	2102      	movs	r1, #2
   19e6a:	4630      	mov	r0, r6
   19e6c:	f012 fe88 	bl	2cb80 <net_buf_simple_add>
	req->handle = sys_cpu_to_le16(handle);
	net_buf_add_le16(buf, value);
   19e70:	4641      	mov	r1, r8
	req->handle = sys_cpu_to_le16(handle);
   19e72:	f8a0 9000 	strh.w	r9, [r0]
	net_buf_add_le16(buf, value);
   19e76:	4630      	mov	r0, r6
   19e78:	f012 fe99 	bl	2cbae <net_buf_simple_add_le16>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   19e7c:	f3bf 8f5b 	dmb	ish
   19e80:	f105 0328 	add.w	r3, r5, #40	; 0x28
   19e84:	e853 2f00 	ldrex	r2, [r3]
   19e88:	f042 0202 	orr.w	r2, r2, #2
   19e8c:	e843 2100 	strex	r1, r2, [r3]
   19e90:	2900      	cmp	r1, #0
   19e92:	d1f7      	bne.n	19e84 <gatt_write_ccc.constprop.27+0x38>
   19e94:	f3bf 8f5b 	dmb	ish

	BT_DBG("handle 0x%04x value 0x%04x", handle, value);

	atomic_set_bit(params->flags, BT_GATT_SUBSCRIBE_FLAG_WRITE_PENDING);

	return gatt_send(conn, buf, func, params, NULL);
   19e98:	462b      	mov	r3, r5
   19e9a:	4621      	mov	r1, r4
   19e9c:	4638      	mov	r0, r7
   19e9e:	4a04      	ldr	r2, [pc, #16]	; (19eb0 <gatt_write_ccc.constprop.27+0x64>)
}
   19ea0:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return gatt_send(conn, buf, func, params, NULL);
   19ea4:	f7ff be34 	b.w	19b10 <gatt_send.constprop.37>
}
   19ea8:	f06f 000b 	mvn.w	r0, #11
   19eac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   19eb0:	00019df9 	.word	0x00019df9

00019eb4 <cf_write>:
{
   19eb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   19eb8:	4690      	mov	r8, r2
   19eba:	f8bd 2018 	ldrh.w	r2, [sp, #24]
	if (offset > sizeof(cfg->data)) {
   19ebe:	2a01      	cmp	r2, #1
{
   19ec0:	4606      	mov	r6, r0
   19ec2:	461f      	mov	r7, r3
	if (offset > sizeof(cfg->data)) {
   19ec4:	d849      	bhi.n	19f5a <cf_write+0xa6>
	if (offset + len > sizeof(cfg->data)) {
   19ec6:	441a      	add	r2, r3
   19ec8:	2a01      	cmp	r2, #1
   19eca:	461c      	mov	r4, r3
   19ecc:	dc48      	bgt.n	19f60 <cf_write+0xac>
	cfg = find_cf_cfg(conn);
   19ece:	f7ff ff75 	bl	19dbc <find_cf_cfg>
	if (!cfg) {
   19ed2:	4605      	mov	r5, r0
   19ed4:	b9c8      	cbnz	r0, 19f0a <cf_write+0x56>
		cfg = find_cf_cfg(NULL);
   19ed6:	f7ff ff71 	bl	19dbc <find_cf_cfg>
	if (!cfg) {
   19eda:	4605      	mov	r5, r0
   19edc:	b9a8      	cbnz	r0, 19f0a <cf_write+0x56>
		BT_WARN("No space to store Client Supported Features");
   19ede:	4b22      	ldr	r3, [pc, #136]	; (19f68 <cf_write+0xb4>)
   19ee0:	681b      	ldr	r3, [r3, #0]
   19ee2:	f013 0f06 	tst.w	r3, #6
   19ee6:	d00d      	beq.n	19f04 <cf_write+0x50>
   19ee8:	2302      	movs	r3, #2
   19eea:	f04f 0100 	mov.w	r1, #0
   19eee:	f363 0107 	bfi	r1, r3, #0, #8
   19ef2:	4a1e      	ldr	r2, [pc, #120]	; (19f6c <cf_write+0xb8>)
   19ef4:	4b1e      	ldr	r3, [pc, #120]	; (19f70 <cf_write+0xbc>)
   19ef6:	481f      	ldr	r0, [pc, #124]	; (19f74 <cf_write+0xc0>)
   19ef8:	1a9b      	subs	r3, r3, r2
   19efa:	08db      	lsrs	r3, r3, #3
   19efc:	f363 118f 	bfi	r1, r3, #6, #10
   19f00:	f00e fd1b 	bl	2893a <log_0>
   19f04:	f06f 0410 	mvn.w	r4, #16
   19f08:	e024      	b.n	19f54 <cf_write+0xa0>
	for (i = 0U; i < len && i < last_byte; i++) {
   19f0a:	2300      	movs	r3, #0
   19f0c:	429f      	cmp	r7, r3
   19f0e:	d915      	bls.n	19f3c <cf_write+0x88>
   19f10:	b13b      	cbz	r3, 19f22 <cf_write+0x6e>
		cfg->data[i] |= value[i] & ((1 << last_bit) - 1);
   19f12:	f898 3000 	ldrb.w	r3, [r8]
   19f16:	7a2a      	ldrb	r2, [r5, #8]
   19f18:	f003 0301 	and.w	r3, r3, #1
   19f1c:	4313      	orrs	r3, r2
   19f1e:	722b      	strb	r3, [r5, #8]
		BT_DBG("byte %u: data 0x%02x value 0x%02x", i, cfg->data[i],
   19f20:	e00e      	b.n	19f40 <cf_write+0x8c>
   19f22:	7a29      	ldrb	r1, [r5, #8]
		u8_t chg_bits = value[i] ^ cfg->data[i];
   19f24:	f898 2000 	ldrb.w	r2, [r8]
   19f28:	404a      	eors	r2, r1
			if ((BIT(bit) & chg_bits) &&
   19f2a:	07d0      	lsls	r0, r2, #31
	for (i = 0U; i < len && i < last_byte; i++) {
   19f2c:	f04f 0301 	mov.w	r3, #1
			if ((BIT(bit) & chg_bits) &&
   19f30:	d5ec      	bpl.n	19f0c <cf_write+0x58>
   19f32:	07ca      	lsls	r2, r1, #31
   19f34:	d5ea      	bpl.n	19f0c <cf_write+0x58>
		return BT_GATT_ERR(BT_ATT_ERR_VALUE_NOT_ALLOWED);
   19f36:	f06f 0412 	mvn.w	r4, #18
   19f3a:	e00b      	b.n	19f54 <cf_write+0xa0>
	for (i = 0U; i < len && i < last_byte; i++) {
   19f3c:	2f00      	cmp	r7, #0
   19f3e:	d1e8      	bne.n	19f12 <cf_write+0x5e>
	bt_addr_le_copy(&cfg->peer, &conn->le.dst);
   19f40:	f106 0170 	add.w	r1, r6, #112	; 0x70
   19f44:	1c68      	adds	r0, r5, #1
   19f46:	f011 fa46 	bl	2b3d6 <bt_addr_le_copy>
	atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   19f4a:	2100      	movs	r1, #0
   19f4c:	f105 000c 	add.w	r0, r5, #12
   19f50:	f011 fa90 	bl	2b474 <atomic_set_bit>
}
   19f54:	4620      	mov	r0, r4
   19f56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   19f5a:	f06f 0406 	mvn.w	r4, #6
   19f5e:	e7f9      	b.n	19f54 <cf_write+0xa0>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
   19f60:	f06f 040c 	mvn.w	r4, #12
   19f64:	e7f6      	b.n	19f54 <cf_write+0xa0>
   19f66:	bf00      	nop
   19f68:	20010000 	.word	0x20010000
   19f6c:	0002db28 	.word	0x0002db28
   19f70:	0002dbf8 	.word	0x0002dbf8
   19f74:	000312f8 	.word	0x000312f8

00019f78 <sc_indicate_rsp>:
{
   19f78:	b510      	push	{r4, lr}
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   19f7a:	f06f 0102 	mvn.w	r1, #2
   19f7e:	4604      	mov	r4, r0
   19f80:	480d      	ldr	r0, [pc, #52]	; (19fb8 <sc_indicate_rsp+0x40>)
   19f82:	f011 fa34 	bl	2b3ee <atomic_and>
	if (atomic_test_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
   19f86:	2100      	movs	r1, #0
   19f88:	480b      	ldr	r0, [pc, #44]	; (19fb8 <sc_indicate_rsp+0x40>)
   19f8a:	f011 fa27 	bl	2b3dc <atomic_test_bit>
   19f8e:	b120      	cbz	r0, 19f9a <sc_indicate_rsp+0x22>
   19f90:	2200      	movs	r2, #0
   19f92:	490a      	ldr	r1, [pc, #40]	; (19fbc <sc_indicate_rsp+0x44>)
   19f94:	480a      	ldr	r0, [pc, #40]	; (19fc0 <sc_indicate_rsp+0x48>)
   19f96:	f00d fa51 	bl	2743c <k_delayed_work_submit_to_queue>
	cfg = find_cf_cfg(conn);
   19f9a:	4620      	mov	r0, r4
   19f9c:	f7ff ff0e 	bl	19dbc <find_cf_cfg>
	if (cfg && CF_ROBUST_CACHING(cfg)) {
   19fa0:	b140      	cbz	r0, 19fb4 <sc_indicate_rsp+0x3c>
   19fa2:	7a03      	ldrb	r3, [r0, #8]
   19fa4:	07db      	lsls	r3, r3, #31
   19fa6:	d505      	bpl.n	19fb4 <sc_indicate_rsp+0x3c>
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   19fa8:	2100      	movs	r1, #0
   19faa:	300c      	adds	r0, #12
}
   19fac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   19fb0:	f011 ba60 	b.w	2b474 <atomic_set_bit>
}
   19fb4:	bd10      	pop	{r4, pc}
   19fb6:	bf00      	nop
   19fb8:	200017f4 	.word	0x200017f4
   19fbc:	200017d4 	.word	0x200017d4
   19fc0:	20003b5c 	.word	0x20003b5c

00019fc4 <db_changed>:
{
   19fc4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   19fc6:	220a      	movs	r2, #10
   19fc8:	4916      	ldr	r1, [pc, #88]	; (1a024 <db_changed+0x60>)
   19fca:	4817      	ldr	r0, [pc, #92]	; (1a028 <db_changed+0x64>)
   19fcc:	4c17      	ldr	r4, [pc, #92]	; (1a02c <db_changed+0x68>)
   19fce:	f00d fa35 	bl	2743c <k_delayed_work_submit_to_queue>
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
   19fd2:	2600      	movs	r6, #0
		if (!bt_addr_le_cmp(&cfg->peer, BT_ADDR_LE_ANY)) {
   19fd4:	4637      	mov	r7, r6
   19fd6:	2207      	movs	r2, #7
   19fd8:	4669      	mov	r1, sp
   19fda:	4620      	mov	r0, r4
   19fdc:	9700      	str	r7, [sp, #0]
   19fde:	f8cd 7003 	str.w	r7, [sp, #3]
   19fe2:	f010 fa0d 	bl	2a400 <memcmp>
   19fe6:	b1a8      	cbz	r0, 1a014 <db_changed+0x50>
		if (CF_ROBUST_CACHING(cfg)) {
   19fe8:	79e3      	ldrb	r3, [r4, #7]
   19fea:	07db      	lsls	r3, r3, #31
   19fec:	d512      	bpl.n	1a014 <db_changed+0x50>
			atomic_clear_bit(cfg->flags, CF_OUT_OF_SYNC);
   19fee:	f104 050b 	add.w	r5, r4, #11
   19ff2:	f06f 0102 	mvn.w	r1, #2
   19ff6:	4628      	mov	r0, r5
   19ff8:	f011 f9f9 	bl	2b3ee <atomic_and>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   19ffc:	f3bf 8f5b 	dmb	ish
   1a000:	e855 3f00 	ldrex	r3, [r5]
   1a004:	f023 0301 	bic.w	r3, r3, #1
   1a008:	e845 3200 	strex	r2, r3, [r5]
   1a00c:	2a00      	cmp	r2, #0
   1a00e:	d1f7      	bne.n	1a000 <db_changed+0x3c>
   1a010:	f3bf 8f5b 	dmb	ish
	for (i = 0; i < ARRAY_SIZE(cf_cfg); i++) {
   1a014:	3601      	adds	r6, #1
   1a016:	2e05      	cmp	r6, #5
   1a018:	f104 0410 	add.w	r4, r4, #16
   1a01c:	d1db      	bne.n	19fd6 <db_changed+0x12>
}
   1a01e:	b003      	add	sp, #12
   1a020:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1a022:	bf00      	nop
   1a024:	20001788 	.word	0x20001788
   1a028:	20003b5c 	.word	0x20003b5c
   1a02c:	20001731 	.word	0x20001731

0001a030 <sc_indicate>:
{
   1a030:	b510      	push	{r4, lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1a032:	4a17      	ldr	r2, [pc, #92]	; (1a090 <sc_indicate+0x60>)
   1a034:	f3bf 8f5b 	dmb	ish
   1a038:	f102 034c 	add.w	r3, r2, #76	; 0x4c
   1a03c:	e853 4f00 	ldrex	r4, [r3]
   1a040:	f044 0c01 	orr.w	ip, r4, #1
   1a044:	e843 ce00 	strex	lr, ip, [r3]
   1a048:	f1be 0f00 	cmp.w	lr, #0
   1a04c:	d1f6      	bne.n	1a03c <sc_indicate+0xc>
   1a04e:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_set_bit(gatt_sc.flags, SC_RANGE_CHANGED)) {
   1a052:	f014 0f01 	tst.w	r4, #1
   1a056:	4613      	mov	r3, r2
   1a058:	d10d      	bne.n	1a076 <sc_indicate+0x46>
		gatt_sc.start = start;
   1a05a:	8510      	strh	r0, [r2, #40]	; 0x28
		gatt_sc.end = end;
   1a05c:	8551      	strh	r1, [r2, #42]	; 0x2a
	if (atomic_test_bit(gatt_sc.flags, SC_INDICATE_PENDING)) {
   1a05e:	2101      	movs	r1, #1
   1a060:	480c      	ldr	r0, [pc, #48]	; (1a094 <sc_indicate+0x64>)
   1a062:	f011 f9bb 	bl	2b3dc <atomic_test_bit>
   1a066:	b990      	cbnz	r0, 1a08e <sc_indicate+0x5e>
   1a068:	220a      	movs	r2, #10
   1a06a:	490b      	ldr	r1, [pc, #44]	; (1a098 <sc_indicate+0x68>)
   1a06c:	480b      	ldr	r0, [pc, #44]	; (1a09c <sc_indicate+0x6c>)
}
   1a06e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1a072:	f00d b9e3 	b.w	2743c <k_delayed_work_submit_to_queue>
	if (new_start >= *start && new_end <= *end) {
   1a076:	8d1c      	ldrh	r4, [r3, #40]	; 0x28
   1a078:	8d52      	ldrh	r2, [r2, #42]	; 0x2a
   1a07a:	4284      	cmp	r4, r0
   1a07c:	d803      	bhi.n	1a086 <sc_indicate+0x56>
   1a07e:	4291      	cmp	r1, r2
   1a080:	d905      	bls.n	1a08e <sc_indicate+0x5e>
		*end = new_end;
   1a082:	8559      	strh	r1, [r3, #42]	; 0x2a
   1a084:	e7eb      	b.n	1a05e <sc_indicate+0x2e>
	if (*end < new_end) {
   1a086:	4291      	cmp	r1, r2
		*start = new_start;
   1a088:	8518      	strh	r0, [r3, #40]	; 0x28
	if (*end < new_end) {
   1a08a:	d9e8      	bls.n	1a05e <sc_indicate+0x2e>
   1a08c:	e7f9      	b.n	1a082 <sc_indicate+0x52>
}
   1a08e:	bd10      	pop	{r4, pc}
   1a090:	200017a8 	.word	0x200017a8
   1a094:	200017f4 	.word	0x200017f4
   1a098:	200017d4 	.word	0x200017d4
   1a09c:	20003b5c 	.word	0x20003b5c

0001a0a0 <bt_gatt_attr_write_ccc>:
{
   1a0a0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   1a0a4:	461e      	mov	r6, r3
   1a0a6:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
	struct _bt_gatt_ccc *ccc = attr->user_data;
   1a0aa:	68cf      	ldr	r7, [r1, #12]
{
   1a0ac:	4680      	mov	r8, r0
   1a0ae:	4689      	mov	r9, r1
	if (offset) {
   1a0b0:	2b00      	cmp	r3, #0
   1a0b2:	d156      	bne.n	1a162 <bt_gatt_attr_write_ccc+0xc2>
	if (!len || len > sizeof(u16_t)) {
   1a0b4:	1e73      	subs	r3, r6, #1
   1a0b6:	2b01      	cmp	r3, #1
   1a0b8:	d856      	bhi.n	1a168 <bt_gatt_attr_write_ccc+0xc8>
	if (len < sizeof(u16_t)) {
   1a0ba:	2e01      	cmp	r6, #1
		value = *(u8_t *)buf;
   1a0bc:	7814      	ldrb	r4, [r2, #0]
	return ((u16_t)src[1] << 8) | src[0];
   1a0be:	bf18      	it	ne
   1a0c0:	7853      	ldrbne	r3, [r2, #1]
	cfg = find_ccc_cfg(conn, ccc);
   1a0c2:	4639      	mov	r1, r7
		value = *(u8_t *)buf;
   1a0c4:	bf0c      	ite	eq
   1a0c6:	b2a4      	uxtheq	r4, r4
   1a0c8:	ea44 2403 	orrne.w	r4, r4, r3, lsl #8
	cfg = find_ccc_cfg(conn, ccc);
   1a0cc:	f011 f9ef 	bl	2b4ae <find_ccc_cfg>
	if (!cfg) {
   1a0d0:	4605      	mov	r5, r0
   1a0d2:	bb38      	cbnz	r0, 1a124 <bt_gatt_attr_write_ccc+0x84>
		if (!value) {
   1a0d4:	b91c      	cbnz	r4, 1a0de <bt_gatt_attr_write_ccc+0x3e>
			return len;
   1a0d6:	4630      	mov	r0, r6
}
   1a0d8:	b003      	add	sp, #12
   1a0da:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		cfg = find_ccc_cfg(NULL, ccc);
   1a0de:	4639      	mov	r1, r7
   1a0e0:	f011 f9e5 	bl	2b4ae <find_ccc_cfg>
		if (!cfg) {
   1a0e4:	4605      	mov	r5, r0
   1a0e6:	b9a8      	cbnz	r0, 1a114 <bt_gatt_attr_write_ccc+0x74>
			BT_WARN("No space to store CCC cfg");
   1a0e8:	4b21      	ldr	r3, [pc, #132]	; (1a170 <bt_gatt_attr_write_ccc+0xd0>)
   1a0ea:	681b      	ldr	r3, [r3, #0]
   1a0ec:	f013 0f06 	tst.w	r3, #6
   1a0f0:	d00d      	beq.n	1a10e <bt_gatt_attr_write_ccc+0x6e>
   1a0f2:	2302      	movs	r3, #2
   1a0f4:	f04f 0100 	mov.w	r1, #0
   1a0f8:	f363 0107 	bfi	r1, r3, #0, #8
   1a0fc:	4a1d      	ldr	r2, [pc, #116]	; (1a174 <bt_gatt_attr_write_ccc+0xd4>)
   1a0fe:	4b1e      	ldr	r3, [pc, #120]	; (1a178 <bt_gatt_attr_write_ccc+0xd8>)
   1a100:	481e      	ldr	r0, [pc, #120]	; (1a17c <bt_gatt_attr_write_ccc+0xdc>)
   1a102:	1a9b      	subs	r3, r3, r2
   1a104:	08db      	lsrs	r3, r3, #3
   1a106:	f363 118f 	bfi	r1, r3, #6, #10
   1a10a:	f00e fc16 	bl	2893a <log_0>
			return BT_GATT_ERR(BT_ATT_ERR_INSUFFICIENT_RESOURCES);
   1a10e:	f06f 0010 	mvn.w	r0, #16
   1a112:	e7e1      	b.n	1a0d8 <bt_gatt_attr_write_ccc+0x38>
		bt_addr_le_copy(&cfg->peer, &conn->le.dst);
   1a114:	f108 0170 	add.w	r1, r8, #112	; 0x70
   1a118:	3001      	adds	r0, #1
   1a11a:	f011 f95c 	bl	2b3d6 <bt_addr_le_copy>
		cfg->id = conn->id;
   1a11e:	f898 3008 	ldrb.w	r3, [r8, #8]
   1a122:	702b      	strb	r3, [r5, #0]
	if (ccc->cfg_write && !ccc->cfg_write(conn, attr, value)) {
   1a124:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   1a126:	b99b      	cbnz	r3, 1a150 <bt_gatt_attr_write_ccc+0xb0>
	if (cfg->value != ccc->value) {
   1a128:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
	cfg->value = value;
   1a12a:	812c      	strh	r4, [r5, #8]
	if (cfg->value != ccc->value) {
   1a12c:	42a3      	cmp	r3, r4
   1a12e:	d003      	beq.n	1a138 <bt_gatt_attr_write_ccc+0x98>
		gatt_ccc_changed(attr, ccc);
   1a130:	4639      	mov	r1, r7
   1a132:	4648      	mov	r0, r9
   1a134:	f011 f8d1 	bl	2b2da <gatt_ccc_changed>
	if (!value) {
   1a138:	2c00      	cmp	r4, #0
   1a13a:	d1cc      	bne.n	1a0d6 <bt_gatt_attr_write_ccc+0x36>
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   1a13c:	4669      	mov	r1, sp
   1a13e:	1c68      	adds	r0, r5, #1
   1a140:	9400      	str	r4, [sp, #0]
   1a142:	f8cd 4003 	str.w	r4, [sp, #3]
   1a146:	f011 f946 	bl	2b3d6 <bt_addr_le_copy>
	cfg->id = 0U;
   1a14a:	702c      	strb	r4, [r5, #0]
	cfg->value = 0U;
   1a14c:	812c      	strh	r4, [r5, #8]
   1a14e:	e7c2      	b.n	1a0d6 <bt_gatt_attr_write_ccc+0x36>
	if (ccc->cfg_write && !ccc->cfg_write(conn, attr, value)) {
   1a150:	4622      	mov	r2, r4
   1a152:	4649      	mov	r1, r9
   1a154:	4640      	mov	r0, r8
   1a156:	4798      	blx	r3
   1a158:	2800      	cmp	r0, #0
   1a15a:	d1e5      	bne.n	1a128 <bt_gatt_attr_write_ccc+0x88>
		return BT_GATT_ERR(BT_ATT_ERR_WRITE_NOT_PERMITTED);
   1a15c:	f06f 0002 	mvn.w	r0, #2
   1a160:	e7ba      	b.n	1a0d8 <bt_gatt_attr_write_ccc+0x38>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   1a162:	f06f 0006 	mvn.w	r0, #6
   1a166:	e7b7      	b.n	1a0d8 <bt_gatt_attr_write_ccc+0x38>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
   1a168:	f06f 000c 	mvn.w	r0, #12
   1a16c:	e7b4      	b.n	1a0d8 <bt_gatt_attr_write_ccc+0x38>
   1a16e:	bf00      	nop
   1a170:	20010000 	.word	0x20010000
   1a174:	0002db28 	.word	0x0002db28
   1a178:	0002dbf8 	.word	0x0002dbf8
   1a17c:	0003128d 	.word	0x0003128d

0001a180 <bt_gatt_init>:
{
   1a180:	b510      	push	{r4, lr}
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   1a182:	4b17      	ldr	r3, [pc, #92]	; (1a1e0 <bt_gatt_init+0x60>)
   1a184:	f3bf 8f5b 	dmb	ish
   1a188:	2201      	movs	r2, #1
   1a18a:	e853 1f00 	ldrex	r1, [r3]
   1a18e:	2900      	cmp	r1, #0
   1a190:	d103      	bne.n	1a19a <bt_gatt_init+0x1a>
   1a192:	e843 2000 	strex	r0, r2, [r3]
   1a196:	2800      	cmp	r0, #0
   1a198:	d1f7      	bne.n	1a18a <bt_gatt_init+0xa>
   1a19a:	f3bf 8f5b 	dmb	ish
	if (!atomic_cas(&init, 0, 1)) {
   1a19e:	d11d      	bne.n	1a1dc <bt_gatt_init+0x5c>
   1a1a0:	4a10      	ldr	r2, [pc, #64]	; (1a1e4 <bt_gatt_init+0x64>)
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
   1a1a2:	4911      	ldr	r1, [pc, #68]	; (1a1e8 <bt_gatt_init+0x68>)
   1a1a4:	8813      	ldrh	r3, [r2, #0]
   1a1a6:	4c11      	ldr	r4, [pc, #68]	; (1a1ec <bt_gatt_init+0x6c>)
	if (!atomic_cas(&init, 0, 1)) {
   1a1a8:	2000      	movs	r0, #0
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
   1a1aa:	42a1      	cmp	r1, r4
   1a1ac:	d310      	bcc.n	1a1d0 <bt_gatt_init+0x50>
   1a1ae:	b100      	cbz	r0, 1a1b2 <bt_gatt_init+0x32>
   1a1b0:	8013      	strh	r3, [r2, #0]
	k_delayed_work_init(&db_hash_work, db_hash_process);
   1a1b2:	490f      	ldr	r1, [pc, #60]	; (1a1f0 <bt_gatt_init+0x70>)
   1a1b4:	480f      	ldr	r0, [pc, #60]	; (1a1f4 <bt_gatt_init+0x74>)
   1a1b6:	f013 f9cc 	bl	2d552 <k_delayed_work_init>
   1a1ba:	490e      	ldr	r1, [pc, #56]	; (1a1f4 <bt_gatt_init+0x74>)
   1a1bc:	480e      	ldr	r0, [pc, #56]	; (1a1f8 <bt_gatt_init+0x78>)
   1a1be:	220a      	movs	r2, #10
   1a1c0:	f00d f93c 	bl	2743c <k_delayed_work_submit_to_queue>
		k_delayed_work_init(&gatt_sc.work, sc_process);
   1a1c4:	490d      	ldr	r1, [pc, #52]	; (1a1fc <bt_gatt_init+0x7c>)
   1a1c6:	480e      	ldr	r0, [pc, #56]	; (1a200 <bt_gatt_init+0x80>)
}
   1a1c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		k_delayed_work_init(&gatt_sc.work, sc_process);
   1a1cc:	f013 b9c1 	b.w	2d552 <k_delayed_work_init>
		last_static_handle += svc->attr_count;
   1a1d0:	6848      	ldr	r0, [r1, #4]
   1a1d2:	4403      	add	r3, r0
   1a1d4:	b29b      	uxth	r3, r3
	Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, svc) {
   1a1d6:	3108      	adds	r1, #8
   1a1d8:	2001      	movs	r0, #1
   1a1da:	e7e6      	b.n	1a1aa <bt_gatt_init+0x2a>
}
   1a1dc:	bd10      	pop	{r4, pc}
   1a1de:	bf00      	nop
   1a1e0:	200017f8 	.word	0x200017f8
   1a1e4:	20003cb4 	.word	0x20003cb4
   1a1e8:	0002db18 	.word	0x0002db18
   1a1ec:	0002db28 	.word	0x0002db28
   1a1f0:	0002b725 	.word	0x0002b725
   1a1f4:	20001788 	.word	0x20001788
   1a1f8:	20003b5c 	.word	0x20003b5c
   1a1fc:	0001a6e5 	.word	0x0001a6e5
   1a200:	200017d4 	.word	0x200017d4

0001a204 <bt_gatt_service_unregister>:
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1a204:	4b10      	ldr	r3, [pc, #64]	; (1a248 <bt_gatt_service_unregister+0x44>)
   1a206:	681b      	ldr	r3, [r3, #0]
{
   1a208:	b510      	push	{r4, lr}
	if (!sys_slist_find_and_remove(&db, &svc->node)) {
   1a20a:	f100 0208 	add.w	r2, r0, #8
{
   1a20e:	4604      	mov	r4, r0
   1a210:	2100      	movs	r1, #0
   1a212:	b913      	cbnz	r3, 1a21a <bt_gatt_service_unregister+0x16>
		return -ENOENT;
   1a214:	f06f 0001 	mvn.w	r0, #1
   1a218:	e011      	b.n	1a23e <bt_gatt_service_unregister+0x3a>
   1a21a:	429a      	cmp	r2, r3
   1a21c:	d110      	bne.n	1a240 <bt_gatt_service_unregister+0x3c>
   1a21e:	480a      	ldr	r0, [pc, #40]	; (1a248 <bt_gatt_service_unregister+0x44>)
   1a220:	f011 f848 	bl	2b2b4 <sys_slist_remove>
		    svc->attrs[svc->attr_count - 1].handle);
   1a224:	e9d4 2300 	ldrd	r2, r3, [r4]
	sc_indicate(svc->attrs[0].handle,
   1a228:	2114      	movs	r1, #20
   1a22a:	fb01 2303 	mla	r3, r1, r3, r2
   1a22e:	8a10      	ldrh	r0, [r2, #16]
   1a230:	f833 1c04 	ldrh.w	r1, [r3, #-4]
   1a234:	f7ff fefc 	bl	1a030 <sc_indicate>
	db_changed();
   1a238:	f7ff fec4 	bl	19fc4 <db_changed>
	return 0;
   1a23c:	2000      	movs	r0, #0
}
   1a23e:	bd10      	pop	{r4, pc}
   1a240:	4619      	mov	r1, r3
   1a242:	681b      	ldr	r3, [r3, #0]
   1a244:	e7e5      	b.n	1a212 <bt_gatt_service_unregister+0xe>
   1a246:	bf00      	nop
   1a248:	20001780 	.word	0x20001780

0001a24c <bt_gatt_attr_value_handle>:
{
   1a24c:	b508      	push	{r3, lr}
	if ((attr != NULL)
   1a24e:	b188      	cbz	r0, 1a274 <bt_gatt_attr_value_handle+0x28>
	    && (attr->read == bt_gatt_attr_read_chrc)) {
   1a250:	6841      	ldr	r1, [r0, #4]
   1a252:	4b09      	ldr	r3, [pc, #36]	; (1a278 <bt_gatt_attr_value_handle+0x2c>)
   1a254:	4299      	cmp	r1, r3
   1a256:	d10d      	bne.n	1a274 <bt_gatt_attr_value_handle+0x28>
		handle = chrc->value_handle;
   1a258:	68c3      	ldr	r3, [r0, #12]
   1a25a:	889b      	ldrh	r3, [r3, #4]
		if (handle == 0) {
   1a25c:	b91b      	cbnz	r3, 1a266 <bt_gatt_attr_value_handle+0x1a>
			handle = (attr->handle ? : find_static_attr(attr)) + 1U;
   1a25e:	8a03      	ldrh	r3, [r0, #16]
   1a260:	b11b      	cbz	r3, 1a26a <bt_gatt_attr_value_handle+0x1e>
   1a262:	3301      	adds	r3, #1
   1a264:	b29b      	uxth	r3, r3
}
   1a266:	4618      	mov	r0, r3
   1a268:	bd08      	pop	{r3, pc}
			handle = (attr->handle ? : find_static_attr(attr)) + 1U;
   1a26a:	f7ff fb7f 	bl	1996c <find_static_attr>
   1a26e:	3001      	adds	r0, #1
   1a270:	b283      	uxth	r3, r0
	return handle;
   1a272:	e7f8      	b.n	1a266 <bt_gatt_attr_value_handle+0x1a>
	u16_t handle = 0;
   1a274:	2300      	movs	r3, #0
   1a276:	e7f6      	b.n	1a266 <bt_gatt_attr_value_handle+0x1a>
   1a278:	0002b6ad 	.word	0x0002b6ad

0001a27c <bt_gatt_foreach_attr_type>:
{
   1a27c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1a280:	b089      	sub	sp, #36	; 0x24
   1a282:	4698      	mov	r8, r3
   1a284:	f8bd 4048 	ldrh.w	r4, [sp, #72]	; 0x48
		num_matches = UINT16_MAX;
   1a288:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1a28c:	2c00      	cmp	r4, #0
   1a28e:	bf08      	it	eq
   1a290:	461c      	moveq	r4, r3
	if (start_handle <= last_static_handle) {
   1a292:	4b48      	ldr	r3, [pc, #288]	; (1a3b4 <bt_gatt_foreach_attr_type+0x138>)
   1a294:	881b      	ldrh	r3, [r3, #0]
   1a296:	4283      	cmp	r3, r0
{
   1a298:	4606      	mov	r6, r0
   1a29a:	468a      	mov	sl, r1
   1a29c:	4617      	mov	r7, r2
	if (start_handle <= last_static_handle) {
   1a29e:	d307      	bcc.n	1a2b0 <bt_gatt_foreach_attr_type+0x34>
   1a2a0:	f8df b11c 	ldr.w	fp, [pc, #284]	; 1a3c0 <bt_gatt_foreach_attr_type+0x144>
		u16_t handle = 1;
   1a2a4:	2501      	movs	r5, #1
		Z_STRUCT_SECTION_FOREACH(bt_gatt_service_static, static_svc) {
   1a2a6:	4b44      	ldr	r3, [pc, #272]	; (1a3b8 <bt_gatt_foreach_attr_type+0x13c>)
   1a2a8:	f1ab 0208 	sub.w	r2, fp, #8
   1a2ac:	429a      	cmp	r2, r3
   1a2ae:	d31d      	bcc.n	1a2ec <bt_gatt_foreach_attr_type+0x70>
	SYS_SLIST_FOR_EACH_CONTAINER(&db, svc, node) {
   1a2b0:	4b42      	ldr	r3, [pc, #264]	; (1a3bc <bt_gatt_foreach_attr_type+0x140>)
   1a2b2:	681d      	ldr	r5, [r3, #0]
   1a2b4:	2d00      	cmp	r5, #0
   1a2b6:	d04b      	beq.n	1a350 <bt_gatt_foreach_attr_type+0xd4>
   1a2b8:	3d08      	subs	r5, #8
			struct bt_gatt_attr *attr = &svc->attrs[i];
   1a2ba:	f04f 0914 	mov.w	r9, #20
	SYS_SLIST_FOR_EACH_CONTAINER(&db, svc, node) {
   1a2be:	2d00      	cmp	r5, #0
   1a2c0:	d046      	beq.n	1a350 <bt_gatt_foreach_attr_type+0xd4>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1a2c2:	68ab      	ldr	r3, [r5, #8]
		next = SYS_SLIST_PEEK_NEXT_CONTAINER(svc, node);
   1a2c4:	2b00      	cmp	r3, #0
   1a2c6:	d073      	beq.n	1a3b0 <bt_gatt_foreach_attr_type+0x134>
		if (next) {
   1a2c8:	f1b3 0b08 	subs.w	fp, r3, #8
   1a2cc:	d006      	beq.n	1a2dc <bt_gatt_foreach_attr_type+0x60>
			if (next->attrs[0].handle <= start_handle) {
   1a2ce:	f853 3c08 	ldr.w	r3, [r3, #-8]
   1a2d2:	8a1b      	ldrh	r3, [r3, #16]
   1a2d4:	42b3      	cmp	r3, r6
   1a2d6:	d904      	bls.n	1a2e2 <bt_gatt_foreach_attr_type+0x66>
   1a2d8:	f04f 0b00 	mov.w	fp, #0
		for (i = 0; i < svc->attr_count; i++) {
   1a2dc:	686b      	ldr	r3, [r5, #4]
   1a2de:	455b      	cmp	r3, fp
   1a2e0:	d840      	bhi.n	1a364 <bt_gatt_foreach_attr_type+0xe8>
   1a2e2:	68ad      	ldr	r5, [r5, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&db, svc, node) {
   1a2e4:	2d00      	cmp	r5, #0
   1a2e6:	d033      	beq.n	1a350 <bt_gatt_foreach_attr_type+0xd4>
   1a2e8:	3d08      	subs	r5, #8
   1a2ea:	e7e8      	b.n	1a2be <bt_gatt_foreach_attr_type+0x42>
			if (handle + static_svc->attr_count < start_handle) {
   1a2ec:	f85b 2c04 	ldr.w	r2, [fp, #-4]
   1a2f0:	442a      	add	r2, r5
   1a2f2:	42b2      	cmp	r2, r6
   1a2f4:	d233      	bcs.n	1a35e <bt_gatt_foreach_attr_type+0xe2>
				handle += static_svc->attr_count;
   1a2f6:	b295      	uxth	r5, r2
				continue;
   1a2f8:	f10b 0b08 	add.w	fp, fp, #8
   1a2fc:	e7d3      	b.n	1a2a6 <bt_gatt_foreach_attr_type+0x2a>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
   1a2fe:	9903      	ldr	r1, [sp, #12]
   1a300:	4638      	mov	r0, r7
   1a302:	f010 f9c0 	bl	2a686 <bt_uuid_cmp>
   1a306:	b1b8      	cbz	r0, 1a338 <bt_gatt_foreach_attr_type+0xbc>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
   1a308:	3501      	adds	r5, #1
   1a30a:	f109 0901 	add.w	r9, r9, #1
   1a30e:	b2ad      	uxth	r5, r5
   1a310:	f85b 2c04 	ldr.w	r2, [fp, #-4]
   1a314:	454a      	cmp	r2, r9
   1a316:	d9ef      	bls.n	1a2f8 <bt_gatt_foreach_attr_type+0x7c>
				memcpy(&attr, &static_svc->attrs[i],
   1a318:	f85b 1c08 	ldr.w	r1, [fp, #-8]
   1a31c:	2214      	movs	r2, #20
   1a31e:	fb02 1109 	mla	r1, r2, r9, r1
   1a322:	a803      	add	r0, sp, #12
   1a324:	f010 f893 	bl	2a44e <memcpy>
	if (attr->handle > end_handle) {
   1a328:	4555      	cmp	r5, sl
				attr.handle = handle;
   1a32a:	f8ad 501c 	strh.w	r5, [sp, #28]
	if (attr->handle > end_handle) {
   1a32e:	d80f      	bhi.n	1a350 <bt_gatt_foreach_attr_type+0xd4>
	if (attr->handle < start_handle) {
   1a330:	42b5      	cmp	r5, r6
   1a332:	d3e9      	bcc.n	1a308 <bt_gatt_foreach_attr_type+0x8c>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
   1a334:	2f00      	cmp	r7, #0
   1a336:	d1e2      	bne.n	1a2fe <bt_gatt_foreach_attr_type+0x82>
	if (attr_data && attr_data != attr->user_data) {
   1a338:	f1b8 0f00 	cmp.w	r8, #0
   1a33c:	d10b      	bne.n	1a356 <bt_gatt_foreach_attr_type+0xda>
	*num_matches -= 1;
   1a33e:	3c01      	subs	r4, #1
   1a340:	b2a4      	uxth	r4, r4
	result = func(attr, user_data);
   1a342:	9914      	ldr	r1, [sp, #80]	; 0x50
   1a344:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1a346:	a803      	add	r0, sp, #12
   1a348:	4798      	blx	r3
	if (!*num_matches) {
   1a34a:	b10c      	cbz	r4, 1a350 <bt_gatt_foreach_attr_type+0xd4>
				if (gatt_foreach_iter(&attr, start_handle,
   1a34c:	2800      	cmp	r0, #0
   1a34e:	d1db      	bne.n	1a308 <bt_gatt_foreach_attr_type+0x8c>
}
   1a350:	b009      	add	sp, #36	; 0x24
   1a352:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (attr_data && attr_data != attr->user_data) {
   1a356:	9a06      	ldr	r2, [sp, #24]
   1a358:	4590      	cmp	r8, r2
   1a35a:	d1d5      	bne.n	1a308 <bt_gatt_foreach_attr_type+0x8c>
   1a35c:	e7ef      	b.n	1a33e <bt_gatt_foreach_attr_type+0xc2>
			for (i = 0; i < static_svc->attr_count; i++, handle++) {
   1a35e:	f04f 0900 	mov.w	r9, #0
   1a362:	e7d5      	b.n	1a310 <bt_gatt_foreach_attr_type+0x94>
			struct bt_gatt_attr *attr = &svc->attrs[i];
   1a364:	6829      	ldr	r1, [r5, #0]
   1a366:	fb09 f20b 	mul.w	r2, r9, fp
   1a36a:	188b      	adds	r3, r1, r2
	if (attr->handle > end_handle) {
   1a36c:	8a18      	ldrh	r0, [r3, #16]
   1a36e:	4582      	cmp	sl, r0
   1a370:	d3ee      	bcc.n	1a350 <bt_gatt_foreach_attr_type+0xd4>
	if (attr->handle < start_handle) {
   1a372:	4286      	cmp	r6, r0
   1a374:	d815      	bhi.n	1a3a2 <bt_gatt_foreach_attr_type+0x126>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
   1a376:	b967      	cbnz	r7, 1a392 <bt_gatt_foreach_attr_type+0x116>
	if (attr_data && attr_data != attr->user_data) {
   1a378:	f1b8 0f00 	cmp.w	r8, #0
   1a37c:	d114      	bne.n	1a3a8 <bt_gatt_foreach_attr_type+0x12c>
	*num_matches -= 1;
   1a37e:	3c01      	subs	r4, #1
   1a380:	b2a4      	uxth	r4, r4
	result = func(attr, user_data);
   1a382:	4618      	mov	r0, r3
   1a384:	9914      	ldr	r1, [sp, #80]	; 0x50
   1a386:	9b13      	ldr	r3, [sp, #76]	; 0x4c
   1a388:	4798      	blx	r3
	if (!*num_matches) {
   1a38a:	2c00      	cmp	r4, #0
   1a38c:	d0e0      	beq.n	1a350 <bt_gatt_foreach_attr_type+0xd4>
			if (gatt_foreach_iter(attr,
   1a38e:	b940      	cbnz	r0, 1a3a2 <bt_gatt_foreach_attr_type+0x126>
   1a390:	e7de      	b.n	1a350 <bt_gatt_foreach_attr_type+0xd4>
	if (uuid && bt_uuid_cmp(uuid, attr->uuid)) {
   1a392:	5889      	ldr	r1, [r1, r2]
   1a394:	9301      	str	r3, [sp, #4]
   1a396:	4638      	mov	r0, r7
   1a398:	f010 f975 	bl	2a686 <bt_uuid_cmp>
   1a39c:	9b01      	ldr	r3, [sp, #4]
   1a39e:	2800      	cmp	r0, #0
   1a3a0:	d0ea      	beq.n	1a378 <bt_gatt_foreach_attr_type+0xfc>
		for (i = 0; i < svc->attr_count; i++) {
   1a3a2:	f10b 0b01 	add.w	fp, fp, #1
   1a3a6:	e799      	b.n	1a2dc <bt_gatt_foreach_attr_type+0x60>
	if (attr_data && attr_data != attr->user_data) {
   1a3a8:	68da      	ldr	r2, [r3, #12]
   1a3aa:	4590      	cmp	r8, r2
   1a3ac:	d1f9      	bne.n	1a3a2 <bt_gatt_foreach_attr_type+0x126>
   1a3ae:	e7e6      	b.n	1a37e <bt_gatt_foreach_attr_type+0x102>
		next = SYS_SLIST_PEEK_NEXT_CONTAINER(svc, node);
   1a3b0:	469b      	mov	fp, r3
   1a3b2:	e793      	b.n	1a2dc <bt_gatt_foreach_attr_type+0x60>
   1a3b4:	20003cb4 	.word	0x20003cb4
   1a3b8:	0002db28 	.word	0x0002db28
   1a3bc:	20001780 	.word	0x20001780
   1a3c0:	0002db20 	.word	0x0002db20

0001a3c4 <db_hash_gen.isra.19>:
static void db_hash_gen(bool store)
   1a3c4:	b510      	push	{r4, lr}
   1a3c6:	b0c8      	sub	sp, #288	; 0x120
	u8_t key[16] = {};
   1a3c8:	2210      	movs	r2, #16
   1a3ca:	2100      	movs	r1, #0
   1a3cc:	4668      	mov	r0, sp
   1a3ce:	f010 f868 	bl	2a4a2 <memset>
	if (tc_cmac_setup(&state.state, key, &sched) == TC_CRYPTO_FAIL) {
   1a3d2:	aa1c      	add	r2, sp, #112	; 0x70
   1a3d4:	4669      	mov	r1, sp
   1a3d6:	a804      	add	r0, sp, #16
   1a3d8:	f00e f887 	bl	284ea <tc_cmac_setup>
   1a3dc:	b998      	cbnz	r0, 1a406 <db_hash_gen.isra.19+0x42>
		BT_ERR("Unable to setup AES CMAC");
   1a3de:	4b1f      	ldr	r3, [pc, #124]	; (1a45c <db_hash_gen.isra.19+0x98>)
   1a3e0:	681b      	ldr	r3, [r3, #0]
   1a3e2:	075a      	lsls	r2, r3, #29
   1a3e4:	d00d      	beq.n	1a402 <db_hash_gen.isra.19+0x3e>
   1a3e6:	2301      	movs	r3, #1
   1a3e8:	f04f 0100 	mov.w	r1, #0
   1a3ec:	f363 0107 	bfi	r1, r3, #0, #8
   1a3f0:	4a1b      	ldr	r2, [pc, #108]	; (1a460 <db_hash_gen.isra.19+0x9c>)
   1a3f2:	4b1c      	ldr	r3, [pc, #112]	; (1a464 <db_hash_gen.isra.19+0xa0>)
   1a3f4:	481c      	ldr	r0, [pc, #112]	; (1a468 <db_hash_gen.isra.19+0xa4>)
   1a3f6:	1a9b      	subs	r3, r3, r2
   1a3f8:	08db      	lsrs	r3, r3, #3
   1a3fa:	f363 118f 	bfi	r1, r3, #6, #10
		BT_ERR("Unable to calculate hash");
   1a3fe:	f00e fa9c 	bl	2893a <log_0>
}
   1a402:	b048      	add	sp, #288	; 0x120
   1a404:	bd10      	pop	{r4, pc}
	bt_gatt_foreach_attr(0x0001, 0xffff, gen_hash_m, &state);
   1a406:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1a40a:	2001      	movs	r0, #1
   1a40c:	ab04      	add	r3, sp, #16
   1a40e:	4a17      	ldr	r2, [pc, #92]	; (1a46c <db_hash_gen.isra.19+0xa8>)
   1a410:	f011 f97d 	bl	2b70e <bt_gatt_foreach_attr>
	if (tc_cmac_final(db_hash, &state.state) == TC_CRYPTO_FAIL) {
   1a414:	a904      	add	r1, sp, #16
   1a416:	4816      	ldr	r0, [pc, #88]	; (1a470 <db_hash_gen.isra.19+0xac>)
   1a418:	f00e f8fd 	bl	28616 <tc_cmac_final>
   1a41c:	b980      	cbnz	r0, 1a440 <db_hash_gen.isra.19+0x7c>
		BT_ERR("Unable to calculate hash");
   1a41e:	4b0f      	ldr	r3, [pc, #60]	; (1a45c <db_hash_gen.isra.19+0x98>)
   1a420:	681b      	ldr	r3, [r3, #0]
   1a422:	075b      	lsls	r3, r3, #29
   1a424:	d0ed      	beq.n	1a402 <db_hash_gen.isra.19+0x3e>
   1a426:	2301      	movs	r3, #1
   1a428:	f04f 0100 	mov.w	r1, #0
   1a42c:	f363 0107 	bfi	r1, r3, #0, #8
   1a430:	4a0b      	ldr	r2, [pc, #44]	; (1a460 <db_hash_gen.isra.19+0x9c>)
   1a432:	4b0c      	ldr	r3, [pc, #48]	; (1a464 <db_hash_gen.isra.19+0xa0>)
   1a434:	480f      	ldr	r0, [pc, #60]	; (1a474 <db_hash_gen.isra.19+0xb0>)
   1a436:	1a9b      	subs	r3, r3, r2
   1a438:	08db      	lsrs	r3, r3, #3
   1a43a:	f363 118f 	bfi	r1, r3, #6, #10
   1a43e:	e7de      	b.n	1a3fe <db_hash_gen.isra.19+0x3a>
   1a440:	4b0b      	ldr	r3, [pc, #44]	; (1a470 <db_hash_gen.isra.19+0xac>)
 */
static inline void sys_mem_swap(void *buf, size_t length)
{
	size_t i;

	for (i = 0; i < (length/2); i++) {
   1a442:	2200      	movs	r2, #0
   1a444:	f103 0110 	add.w	r1, r3, #16
   1a448:	3201      	adds	r2, #1
		u8_t tmp = ((u8_t *)buf)[i];
   1a44a:	7818      	ldrb	r0, [r3, #0]

		((u8_t *)buf)[i] = ((u8_t *)buf)[length - 1 - i];
   1a44c:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
   1a450:	f803 4b01 	strb.w	r4, [r3], #1
	for (i = 0; i < (length/2); i++) {
   1a454:	2a08      	cmp	r2, #8
		((u8_t *)buf)[length - 1 - i] = tmp;
   1a456:	7008      	strb	r0, [r1, #0]
	for (i = 0; i < (length/2); i++) {
   1a458:	d1f6      	bne.n	1a448 <db_hash_gen.isra.19+0x84>
   1a45a:	e7d2      	b.n	1a402 <db_hash_gen.isra.19+0x3e>
   1a45c:	20010000 	.word	0x20010000
   1a460:	0002db28 	.word	0x0002db28
   1a464:	0002dbf8 	.word	0x0002dbf8
   1a468:	00031324 	.word	0x00031324
   1a46c:	0002b32b 	.word	0x0002b32b
   1a470:	20003e03 	.word	0x20003e03
   1a474:	0003133d 	.word	0x0003133d

0001a478 <bt_gatt_service_register>:
{
   1a478:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1a47c:	4605      	mov	r5, r0
   1a47e:	b085      	sub	sp, #20
	bt_gatt_init();
   1a480:	f7ff fe7e 	bl	1a180 <bt_gatt_init>
	if (!bt_uuid_cmp(svc->attrs[0].uuid, BT_UUID_GAP) ||
   1a484:	682b      	ldr	r3, [r5, #0]
   1a486:	2400      	movs	r4, #0
   1a488:	6818      	ldr	r0, [r3, #0]
   1a48a:	f88d 4004 	strb.w	r4, [sp, #4]
   1a48e:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
   1a492:	a901      	add	r1, sp, #4
   1a494:	f8ad 3006 	strh.w	r3, [sp, #6]
   1a498:	f010 f8f5 	bl	2a686 <bt_uuid_cmp>
   1a49c:	b920      	cbnz	r0, 1a4a8 <bt_gatt_service_register+0x30>
		return -EALREADY;
   1a49e:	f06f 0044 	mvn.w	r0, #68	; 0x44
}
   1a4a2:	b005      	add	sp, #20
   1a4a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	    !bt_uuid_cmp(svc->attrs[0].uuid, BT_UUID_GATT)) {
   1a4a8:	682b      	ldr	r3, [r5, #0]
   1a4aa:	a902      	add	r1, sp, #8
   1a4ac:	6818      	ldr	r0, [r3, #0]
   1a4ae:	f88d 4008 	strb.w	r4, [sp, #8]
   1a4b2:	f641 0301 	movw	r3, #6145	; 0x1801
   1a4b6:	f8ad 300a 	strh.w	r3, [sp, #10]
   1a4ba:	f010 f8e4 	bl	2a686 <bt_uuid_cmp>
	if (!bt_uuid_cmp(svc->attrs[0].uuid, BT_UUID_GAP) ||
   1a4be:	2800      	cmp	r0, #0
   1a4c0:	d0ed      	beq.n	1a49e <bt_gatt_service_register+0x26>
Z_GENLIST_IS_EMPTY(slist)
   1a4c2:	4c49      	ldr	r4, [pc, #292]	; (1a5e8 <bt_gatt_service_register+0x170>)
	struct bt_gatt_attr *attrs = svc->attrs;
   1a4c4:	f8d5 8000 	ldr.w	r8, [r5]
	if (sys_slist_is_empty(&db)) {
   1a4c8:	6826      	ldr	r6, [r4, #0]
	u16_t count = svc->attr_count;
   1a4ca:	f8b5 9004 	ldrh.w	r9, [r5, #4]
	if (sys_slist_is_empty(&db)) {
   1a4ce:	b936      	cbnz	r6, 1a4de <bt_gatt_service_register+0x66>
		handle = last_static_handle;
   1a4d0:	4b46      	ldr	r3, [pc, #280]	; (1a5ec <bt_gatt_service_register+0x174>)
   1a4d2:	881f      	ldrh	r7, [r3, #0]
	bt_gatt_foreach_attr(handle, handle, found_attr, &attr);
   1a4d4:	f8df b128 	ldr.w	fp, [pc, #296]	; 1a600 <bt_gatt_service_register+0x188>
	const struct bt_gatt_attr *attr = NULL;
   1a4d8:	f04f 0a00 	mov.w	sl, #0
   1a4dc:	e019      	b.n	1a512 <bt_gatt_service_register+0x9a>
	last = SYS_SLIST_PEEK_TAIL_CONTAINER(&db, last, node);
   1a4de:	6863      	ldr	r3, [r4, #4]
   1a4e0:	2b00      	cmp	r3, #0
   1a4e2:	d07f      	beq.n	1a5e4 <bt_gatt_service_register+0x16c>
	handle = last->attrs[last->attr_count - 1].handle;
   1a4e4:	e953 3202 	ldrd	r3, r2, [r3, #-8]
   1a4e8:	2114      	movs	r1, #20
   1a4ea:	fb01 3302 	mla	r3, r1, r2, r3
   1a4ee:	f833 7c04 	ldrh.w	r7, [r3, #-4]
   1a4f2:	463e      	mov	r6, r7
   1a4f4:	e7ee      	b.n	1a4d4 <bt_gatt_service_register+0x5c>
		if (!attrs->handle) {
   1a4f6:	f8b8 1010 	ldrh.w	r1, [r8, #16]
   1a4fa:	bb51      	cbnz	r1, 1a552 <bt_gatt_service_register+0xda>
			attrs->handle = ++handle;
   1a4fc:	1c79      	adds	r1, r7, #1
   1a4fe:	b289      	uxth	r1, r1
   1a500:	f8a8 1010 	strh.w	r1, [r8, #16]
	for (; attrs && count; attrs++, count--) {
   1a504:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
   1a508:	f108 0814 	add.w	r8, r8, #20
   1a50c:	fa1f f989 	uxth.w	r9, r9
   1a510:	460f      	mov	r7, r1
   1a512:	f1b8 0f00 	cmp.w	r8, #0
   1a516:	d002      	beq.n	1a51e <bt_gatt_service_register+0xa6>
   1a518:	f1b9 0f00 	cmp.w	r9, #0
   1a51c:	d1eb      	bne.n	1a4f6 <bt_gatt_service_register+0x7e>
	if (last_handle == 0 || svc->attrs[0].handle > last_handle) {
   1a51e:	682f      	ldr	r7, [r5, #0]
   1a520:	8a38      	ldrh	r0, [r7, #16]
   1a522:	b10e      	cbz	r6, 1a528 <bt_gatt_service_register+0xb0>
   1a524:	42b0      	cmp	r0, r6
   1a526:	d938      	bls.n	1a59a <bt_gatt_service_register+0x122>
	parent->next = child;
   1a528:	2200      	movs	r2, #0
		sys_slist_append(&db, &svc->node);
   1a52a:	f105 0308 	add.w	r3, r5, #8
   1a52e:	60aa      	str	r2, [r5, #8]
Z_GENLIST_APPEND(slist, snode)
   1a530:	6862      	ldr	r2, [r4, #4]
   1a532:	2a00      	cmp	r2, #0
   1a534:	d146      	bne.n	1a5c4 <bt_gatt_service_register+0x14c>
	list->head = node;
   1a536:	e9c4 3300 	strd	r3, r3, [r4]
		    svc->attrs[svc->attr_count - 1].handle);
   1a53a:	686b      	ldr	r3, [r5, #4]
	sc_indicate(svc->attrs[0].handle,
   1a53c:	2214      	movs	r2, #20
   1a53e:	fb02 7303 	mla	r3, r2, r3, r7
   1a542:	f833 1c04 	ldrh.w	r1, [r3, #-4]
   1a546:	f7ff fd73 	bl	1a030 <sc_indicate>
	db_changed();
   1a54a:	f7ff fd3b 	bl	19fc4 <db_changed>
	return 0;
   1a54e:	2000      	movs	r0, #0
   1a550:	e7a7      	b.n	1a4a2 <bt_gatt_service_register+0x2a>
		} else if (attrs->handle > handle) {
   1a552:	42b9      	cmp	r1, r7
   1a554:	d8d6      	bhi.n	1a504 <bt_gatt_service_register+0x8c>
	bt_gatt_foreach_attr(handle, handle, found_attr, &attr);
   1a556:	ab03      	add	r3, sp, #12
   1a558:	465a      	mov	r2, fp
   1a55a:	4608      	mov	r0, r1
	const struct bt_gatt_attr *attr = NULL;
   1a55c:	f8cd a00c 	str.w	sl, [sp, #12]
	bt_gatt_foreach_attr(handle, handle, found_attr, &attr);
   1a560:	f011 f8d5 	bl	2b70e <bt_gatt_foreach_attr>
	return attr;
   1a564:	9b03      	ldr	r3, [sp, #12]
		} else if (find_attr(attrs->handle)) {
   1a566:	b1b3      	cbz	r3, 1a596 <bt_gatt_service_register+0x11e>
			BT_ERR("Unable to register handle 0x%04x",
   1a568:	4b21      	ldr	r3, [pc, #132]	; (1a5f0 <bt_gatt_service_register+0x178>)
   1a56a:	681b      	ldr	r3, [r3, #0]
   1a56c:	075b      	lsls	r3, r3, #29
   1a56e:	d00f      	beq.n	1a590 <bt_gatt_service_register+0x118>
   1a570:	2301      	movs	r3, #1
   1a572:	f04f 0200 	mov.w	r2, #0
   1a576:	f363 0207 	bfi	r2, r3, #0, #8
   1a57a:	491e      	ldr	r1, [pc, #120]	; (1a5f4 <bt_gatt_service_register+0x17c>)
   1a57c:	4b1e      	ldr	r3, [pc, #120]	; (1a5f8 <bt_gatt_service_register+0x180>)
   1a57e:	481f      	ldr	r0, [pc, #124]	; (1a5fc <bt_gatt_service_register+0x184>)
   1a580:	1a5b      	subs	r3, r3, r1
   1a582:	08db      	lsrs	r3, r3, #3
   1a584:	f363 128f 	bfi	r2, r3, #6, #10
   1a588:	f8b8 1010 	ldrh.w	r1, [r8, #16]
   1a58c:	f00e f9e2 	bl	28954 <log_1>
			return -EINVAL;
   1a590:	f06f 0015 	mvn.w	r0, #21
   1a594:	e785      	b.n	1a4a2 <bt_gatt_service_register+0x2a>
		} else if (find_attr(attrs->handle)) {
   1a596:	4639      	mov	r1, r7
   1a598:	e7b4      	b.n	1a504 <bt_gatt_service_register+0x8c>
	SYS_SLIST_FOR_EACH_CONTAINER(&db, tmp, node) {
   1a59a:	6821      	ldr	r1, [r4, #0]
   1a59c:	2900      	cmp	r1, #0
   1a59e:	d0cc      	beq.n	1a53a <bt_gatt_service_register+0xc2>
   1a5a0:	f1a1 0308 	sub.w	r3, r1, #8
   1a5a4:	2200      	movs	r2, #0
   1a5a6:	2b00      	cmp	r3, #0
   1a5a8:	d0c7      	beq.n	1a53a <bt_gatt_service_register+0xc2>
		if (tmp->attrs[0].handle > svc->attrs[0].handle) {
   1a5aa:	681e      	ldr	r6, [r3, #0]
   1a5ac:	8a36      	ldrh	r6, [r6, #16]
   1a5ae:	4286      	cmp	r6, r0
   1a5b0:	d911      	bls.n	1a5d6 <bt_gatt_service_register+0x15e>
			if (prev) {
   1a5b2:	f105 0308 	add.w	r3, r5, #8
   1a5b6:	b142      	cbz	r2, 1a5ca <bt_gatt_service_register+0x152>
Z_GENLIST_INSERT(slist, snode)
   1a5b8:	6891      	ldr	r1, [r2, #8]
	parent->next = child;
   1a5ba:	60a9      	str	r1, [r5, #8]
Z_GENLIST_INSERT(slist, snode)
   1a5bc:	2900      	cmp	r1, #0
   1a5be:	d0b7      	beq.n	1a530 <bt_gatt_service_register+0xb8>
	parent->next = child;
   1a5c0:	6093      	str	r3, [r2, #8]
	if (err < 0) {
   1a5c2:	e7ba      	b.n	1a53a <bt_gatt_service_register+0xc2>
   1a5c4:	6013      	str	r3, [r2, #0]
	list->tail = node;
   1a5c6:	6063      	str	r3, [r4, #4]
   1a5c8:	e7b7      	b.n	1a53a <bt_gatt_service_register+0xc2>
Z_GENLIST_PREPEND(slist, snode)
   1a5ca:	6862      	ldr	r2, [r4, #4]
	parent->next = child;
   1a5cc:	60a9      	str	r1, [r5, #8]
	list->head = node;
   1a5ce:	6023      	str	r3, [r4, #0]
Z_GENLIST_PREPEND(slist, snode)
   1a5d0:	2a00      	cmp	r2, #0
   1a5d2:	d1b2      	bne.n	1a53a <bt_gatt_service_register+0xc2>
   1a5d4:	e7f7      	b.n	1a5c6 <bt_gatt_service_register+0x14e>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1a5d6:	689e      	ldr	r6, [r3, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&db, tmp, node) {
   1a5d8:	2e00      	cmp	r6, #0
   1a5da:	d0ae      	beq.n	1a53a <bt_gatt_service_register+0xc2>
   1a5dc:	461a      	mov	r2, r3
   1a5de:	f1a6 0308 	sub.w	r3, r6, #8
   1a5e2:	e7e0      	b.n	1a5a6 <bt_gatt_service_register+0x12e>
	handle = last->attrs[last->attr_count - 1].handle;
   1a5e4:	681b      	ldr	r3, [r3, #0]
   1a5e6:	deff      	udf	#255	; 0xff
   1a5e8:	20001780 	.word	0x20001780
   1a5ec:	20003cb4 	.word	0x20003cb4
   1a5f0:	20010000 	.word	0x20010000
   1a5f4:	0002db28 	.word	0x0002db28
   1a5f8:	0002dbf8 	.word	0x0002dbf8
   1a5fc:	000312d7 	.word	0x000312d7
   1a600:	0002b2d5 	.word	0x0002b2d5

0001a604 <bt_gatt_indicate>:
{
   1a604:	b570      	push	{r4, r5, r6, lr}
   1a606:	b08a      	sub	sp, #40	; 0x28
	attr = params->attr;
   1a608:	698b      	ldr	r3, [r1, #24]
   1a60a:	9304      	str	r3, [sp, #16]
{
   1a60c:	460e      	mov	r6, r1
	if (conn && conn->state != BT_CONN_CONNECTED) {
   1a60e:	4605      	mov	r5, r0
   1a610:	b110      	cbz	r0, 1a618 <bt_gatt_indicate+0x14>
   1a612:	7a82      	ldrb	r2, [r0, #10]
   1a614:	2a04      	cmp	r2, #4
   1a616:	d15b      	bne.n	1a6d0 <bt_gatt_indicate+0xcc>
	handle = attr->handle ? : find_static_attr(attr);
   1a618:	8a1c      	ldrh	r4, [r3, #16]
   1a61a:	b944      	cbnz	r4, 1a62e <bt_gatt_indicate+0x2a>
   1a61c:	4618      	mov	r0, r3
   1a61e:	f7ff f9a5 	bl	1996c <find_static_attr>
	if (!handle) {
   1a622:	4604      	mov	r4, r0
   1a624:	b918      	cbnz	r0, 1a62e <bt_gatt_indicate+0x2a>
		return -ENOENT;
   1a626:	f06f 0001 	mvn.w	r0, #1
}
   1a62a:	b00a      	add	sp, #40	; 0x28
   1a62c:	bd70      	pop	{r4, r5, r6, pc}
	if (params->uuid) {
   1a62e:	6972      	ldr	r2, [r6, #20]
   1a630:	b1b2      	cbz	r2, 1a660 <bt_gatt_indicate+0x5c>
		bt_gatt_foreach_attr_type(handle, 0xffff, params->uuid,
   1a632:	a904      	add	r1, sp, #16
   1a634:	9102      	str	r1, [sp, #8]
   1a636:	4929      	ldr	r1, [pc, #164]	; (1a6dc <bt_gatt_indicate+0xd8>)
   1a638:	9101      	str	r1, [sp, #4]
   1a63a:	2101      	movs	r1, #1
		attr = NULL;
   1a63c:	2300      	movs	r3, #0
		bt_gatt_foreach_attr_type(handle, 0xffff, params->uuid,
   1a63e:	9100      	str	r1, [sp, #0]
   1a640:	4620      	mov	r0, r4
   1a642:	f64f 71ff 	movw	r1, #65535	; 0xffff
		attr = NULL;
   1a646:	9304      	str	r3, [sp, #16]
		bt_gatt_foreach_attr_type(handle, 0xffff, params->uuid,
   1a648:	f7ff fe18 	bl	1a27c <bt_gatt_foreach_attr_type>
		if (!attr) {
   1a64c:	9804      	ldr	r0, [sp, #16]
   1a64e:	2800      	cmp	r0, #0
   1a650:	d0e9      	beq.n	1a626 <bt_gatt_indicate+0x22>
		handle = attr->handle ? : find_static_attr(attr);
   1a652:	8a04      	ldrh	r4, [r0, #16]
   1a654:	b924      	cbnz	r4, 1a660 <bt_gatt_indicate+0x5c>
   1a656:	f7ff f989 	bl	1996c <find_static_attr>
		if (!handle) {
   1a65a:	4604      	mov	r4, r0
   1a65c:	2800      	cmp	r0, #0
   1a65e:	d0e2      	beq.n	1a626 <bt_gatt_indicate+0x22>
	if (!bt_uuid_cmp(attr->uuid, BT_UUID_GATT_CHRC)) {
   1a660:	9b04      	ldr	r3, [sp, #16]
   1a662:	6818      	ldr	r0, [r3, #0]
   1a664:	2300      	movs	r3, #0
   1a666:	f88d 3014 	strb.w	r3, [sp, #20]
   1a66a:	a905      	add	r1, sp, #20
   1a66c:	f642 0303 	movw	r3, #10243	; 0x2803
   1a670:	f8ad 3016 	strh.w	r3, [sp, #22]
   1a674:	f010 f807 	bl	2a686 <bt_uuid_cmp>
   1a678:	b938      	cbnz	r0, 1a68a <bt_gatt_indicate+0x86>
		struct bt_gatt_chrc *chrc = params->attr->user_data;
   1a67a:	69b0      	ldr	r0, [r6, #24]
		if (!(chrc->properties & BT_GATT_CHRC_INDICATE)) {
   1a67c:	68c3      	ldr	r3, [r0, #12]
   1a67e:	799b      	ldrb	r3, [r3, #6]
   1a680:	069b      	lsls	r3, r3, #26
   1a682:	d528      	bpl.n	1a6d6 <bt_gatt_indicate+0xd2>
		handle = bt_gatt_attr_value_handle(params->attr);
   1a684:	f7ff fde2 	bl	1a24c <bt_gatt_attr_value_handle>
   1a688:	4604      	mov	r4, r0
	if (conn) {
   1a68a:	b12d      	cbz	r5, 1a698 <bt_gatt_indicate+0x94>
		return gatt_indicate(conn, handle, params);
   1a68c:	4632      	mov	r2, r6
   1a68e:	4621      	mov	r1, r4
   1a690:	4628      	mov	r0, r5
   1a692:	f7ff fa6b 	bl	19b6c <gatt_indicate>
   1a696:	e7c8      	b.n	1a62a <bt_gatt_indicate+0x26>
	data.err = -ENOTCONN;
   1a698:	f06f 0338 	mvn.w	r3, #56	; 0x38
   1a69c:	9307      	str	r3, [sp, #28]
	data.type = BT_GATT_CCC_INDICATE;
   1a69e:	2302      	movs	r3, #2
   1a6a0:	f8ad 3020 	strh.w	r3, [sp, #32]
	bt_gatt_foreach_attr_type(handle, 0xffff, BT_UUID_GATT_CCC, NULL, 1,
   1a6a4:	f642 1302 	movw	r3, #10498	; 0x2902
   1a6a8:	f8ad 301a 	strh.w	r3, [sp, #26]
   1a6ac:	ab07      	add	r3, sp, #28
   1a6ae:	9302      	str	r3, [sp, #8]
   1a6b0:	4b0b      	ldr	r3, [pc, #44]	; (1a6e0 <bt_gatt_indicate+0xdc>)
   1a6b2:	9301      	str	r3, [sp, #4]
   1a6b4:	2301      	movs	r3, #1
   1a6b6:	9300      	str	r3, [sp, #0]
   1a6b8:	4620      	mov	r0, r4
   1a6ba:	462b      	mov	r3, r5
   1a6bc:	aa06      	add	r2, sp, #24
   1a6be:	f64f 71ff 	movw	r1, #65535	; 0xffff
	data.ind_params = params;
   1a6c2:	9609      	str	r6, [sp, #36]	; 0x24
	bt_gatt_foreach_attr_type(handle, 0xffff, BT_UUID_GATT_CCC, NULL, 1,
   1a6c4:	f88d 5018 	strb.w	r5, [sp, #24]
   1a6c8:	f7ff fdd8 	bl	1a27c <bt_gatt_foreach_attr_type>
	return data.err;
   1a6cc:	9807      	ldr	r0, [sp, #28]
   1a6ce:	e7ac      	b.n	1a62a <bt_gatt_indicate+0x26>
		return -ENOTCONN;
   1a6d0:	f06f 0038 	mvn.w	r0, #56	; 0x38
   1a6d4:	e7a9      	b.n	1a62a <bt_gatt_indicate+0x26>
			return -EINVAL;
   1a6d6:	f06f 0015 	mvn.w	r0, #21
   1a6da:	e7a6      	b.n	1a62a <bt_gatt_indicate+0x26>
   1a6dc:	0002b443 	.word	0x0002b443
   1a6e0:	00019ccd 	.word	0x00019ccd

0001a6e4 <sc_process>:
{
   1a6e4:	b573      	push	{r0, r1, r4, r5, r6, lr}
	atomic_clear_bit(sc->flags, SC_RANGE_CHANGED);
   1a6e6:	f100 0520 	add.w	r5, r0, #32
{
   1a6ea:	4604      	mov	r4, r0
	sc_range[0] = sys_cpu_to_le16(sc->start);
   1a6ec:	f850 3c04 	ldr.w	r3, [r0, #-4]
   1a6f0:	9301      	str	r3, [sp, #4]
	atomic_clear_bit(sc->flags, SC_RANGE_CHANGED);
   1a6f2:	f1a0 062c 	sub.w	r6, r0, #44	; 0x2c
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   1a6f6:	f06f 0101 	mvn.w	r1, #1
   1a6fa:	4628      	mov	r0, r5
   1a6fc:	f010 fe77 	bl	2b3ee <atomic_and>
	sc->params.attr = &_1_gatt_svc.attrs[2];
   1a700:	4b0d      	ldr	r3, [pc, #52]	; (1a738 <sc_process+0x54>)
   1a702:	f844 3c14 	str.w	r3, [r4, #-20]
	sc->params.func = sc_indicate_rsp;
   1a706:	4b0d      	ldr	r3, [pc, #52]	; (1a73c <sc_process+0x58>)
   1a708:	f844 3c10 	str.w	r3, [r4, #-16]
	sc->params.data = &sc_range[0];
   1a70c:	ab01      	add	r3, sp, #4
	sc->start = 0U;
   1a70e:	2000      	movs	r0, #0
	sc->params.data = &sc_range[0];
   1a710:	f844 3c0c 	str.w	r3, [r4, #-12]
	sc->params.len = sizeof(sc_range);
   1a714:	2304      	movs	r3, #4
	sc->start = 0U;
   1a716:	f824 0c04 	strh.w	r0, [r4, #-4]
	sc->end = 0U;
   1a71a:	f824 0c02 	strh.w	r0, [r4, #-2]
	sc->params.len = sizeof(sc_range);
   1a71e:	f824 3c08 	strh.w	r3, [r4, #-8]
	if (bt_gatt_indicate(NULL, &sc->params)) {
   1a722:	4631      	mov	r1, r6
   1a724:	f7ff ff6e 	bl	1a604 <bt_gatt_indicate>
   1a728:	b918      	cbnz	r0, 1a732 <sc_process+0x4e>
	atomic_set_bit(sc->flags, SC_INDICATE_PENDING);
   1a72a:	2101      	movs	r1, #1
   1a72c:	4628      	mov	r0, r5
   1a72e:	f010 fea1 	bl	2b474 <atomic_set_bit>
}
   1a732:	b002      	add	sp, #8
   1a734:	bd70      	pop	{r4, r5, r6, pc}
   1a736:	bf00      	nop
   1a738:	0002e660 	.word	0x0002e660
   1a73c:	00019f79 	.word	0x00019f79

0001a740 <update_ccc>:
{
   1a740:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1a744:	4607      	mov	r7, r0
	if (attr->write != bt_gatt_attr_write_ccc) {
   1a746:	4a40      	ldr	r2, [pc, #256]	; (1a848 <update_ccc+0x108>)
   1a748:	6880      	ldr	r0, [r0, #8]
   1a74a:	4290      	cmp	r0, r2
   1a74c:	d177      	bne.n	1a83e <update_ccc+0xfe>
   1a74e:	4c3f      	ldr	r4, [pc, #252]	; (1a84c <update_ccc+0x10c>)
				BT_WARN("CCC %p not writable", attr);
   1a750:	4a3f      	ldr	r2, [pc, #252]	; (1a850 <update_ccc+0x110>)
	ccc = attr->user_data;
   1a752:	f8d7 800c 	ldr.w	r8, [r7, #12]
	struct bt_conn *conn = data->conn;
   1a756:	680d      	ldr	r5, [r1, #0]
				BT_WARN("CCC %p not writable", attr);
   1a758:	f8df a10c 	ldr.w	sl, [pc, #268]	; 1a868 <update_ccc+0x128>
   1a75c:	1aa4      	subs	r4, r4, r2
   1a75e:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   1a762:	f108 0601 	add.w	r6, r8, #1
   1a766:	f108 0933 	add.w	r9, r8, #51	; 0x33
		if (bt_conn_addr_le_cmp(conn, &ccc->cfg[i].peer)) {
   1a76a:	4631      	mov	r1, r6
   1a76c:	4628      	mov	r0, r5
   1a76e:	f010 f92c 	bl	2a9ca <bt_conn_addr_le_cmp>
   1a772:	b9c0      	cbnz	r0, 1a7a6 <update_ccc+0x66>
		err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_WRITE_MASK);
   1a774:	222a      	movs	r2, #42	; 0x2a
   1a776:	4639      	mov	r1, r7
   1a778:	4628      	mov	r0, r5
   1a77a:	f010 ffd7 	bl	2b72c <bt_gatt_check_perm>
			if (err == BT_ATT_ERR_WRITE_NOT_PERMITTED) {
   1a77e:	2803      	cmp	r0, #3
   1a780:	d115      	bne.n	1a7ae <update_ccc+0x6e>
				BT_WARN("CCC %p not writable", attr);
   1a782:	f8da 2000 	ldr.w	r2, [sl]
   1a786:	f012 0f06 	tst.w	r2, #6
   1a78a:	d00c      	beq.n	1a7a6 <update_ccc+0x66>
   1a78c:	f02b 023f 	bic.w	r2, fp, #63	; 0x3f
   1a790:	f042 0202 	orr.w	r2, r2, #2
   1a794:	f362 0b07 	bfi	fp, r2, #0, #8
   1a798:	f364 1b8f 	bfi	fp, r4, #6, #10
   1a79c:	465a      	mov	r2, fp
   1a79e:	4639      	mov	r1, r7
   1a7a0:	482c      	ldr	r0, [pc, #176]	; (1a854 <update_ccc+0x114>)
   1a7a2:	f00e f8d7 	bl	28954 <log_1>
   1a7a6:	360a      	adds	r6, #10
	for (i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   1a7a8:	454e      	cmp	r6, r9
   1a7aa:	d1de      	bne.n	1a76a <update_ccc+0x2a>
   1a7ac:	e047      	b.n	1a83e <update_ccc+0xfe>
		if (ccc->cfg[i].value) {
   1a7ae:	f8b6 2007 	ldrh.w	r2, [r6, #7]
   1a7b2:	2a00      	cmp	r2, #0
   1a7b4:	d0f7      	beq.n	1a7a6 <update_ccc+0x66>
			gatt_ccc_changed(attr, ccc);
   1a7b6:	4641      	mov	r1, r8
   1a7b8:	4638      	mov	r0, r7
   1a7ba:	f010 fd8e 	bl	2b2da <gatt_ccc_changed>
			if (IS_ENABLED(CONFIG_BT_GATT_SERVICE_CHANGED) &&
   1a7be:	4b26      	ldr	r3, [pc, #152]	; (1a858 <update_ccc+0x118>)
   1a7c0:	4598      	cmp	r8, r3
   1a7c2:	d13c      	bne.n	1a83e <update_ccc+0xfe>
	cfg = find_sc_cfg(conn->id, &conn->le.dst);
   1a7c4:	f105 0170 	add.w	r1, r5, #112	; 0x70
   1a7c8:	7a28      	ldrb	r0, [r5, #8]
   1a7ca:	f7ff fa1b 	bl	19c04 <find_sc_cfg>
	if (!cfg) {
   1a7ce:	4606      	mov	r6, r0
   1a7d0:	2800      	cmp	r0, #0
   1a7d2:	d034      	beq.n	1a83e <update_ccc+0xfe>
	if (!(cfg->data.start || cfg->data.end)) {
   1a7d4:	8902      	ldrh	r2, [r0, #8]
   1a7d6:	8943      	ldrh	r3, [r0, #10]
   1a7d8:	ea52 0103 	orrs.w	r1, r2, r3
   1a7dc:	d02f      	beq.n	1a83e <update_ccc+0xfe>
	index = bt_conn_index(conn);
   1a7de:	4628      	mov	r0, r5
	sc_range[0] = sys_cpu_to_le16(cfg->data.start);
   1a7e0:	f8ad 2004 	strh.w	r2, [sp, #4]
	sc_range[1] = sys_cpu_to_le16(cfg->data.end);
   1a7e4:	f8ad 3006 	strh.w	r3, [sp, #6]
	index = bt_conn_index(conn);
   1a7e8:	f7fd ff14 	bl	18614 <bt_conn_index>
	sc_restore_params[index].attr = &_1_gatt_svc.attrs[2];
   1a7ec:	491b      	ldr	r1, [pc, #108]	; (1a85c <update_ccc+0x11c>)
   1a7ee:	4a1c      	ldr	r2, [pc, #112]	; (1a860 <update_ccc+0x120>)
   1a7f0:	2328      	movs	r3, #40	; 0x28
   1a7f2:	fb03 1300 	mla	r3, r3, r0, r1
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
   1a7f6:	b200      	sxth	r0, r0
	sc_restore_params[index].attr = &_1_gatt_svc.attrs[2];
   1a7f8:	619a      	str	r2, [r3, #24]
	sc_restore_params[index].func = sc_restore_rsp;
   1a7fa:	4a1a      	ldr	r2, [pc, #104]	; (1a864 <update_ccc+0x124>)
   1a7fc:	61da      	str	r2, [r3, #28]
	sc_restore_params[index].data = &sc_range[0];
   1a7fe:	aa01      	add	r2, sp, #4
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
   1a800:	eb00 0080 	add.w	r0, r0, r0, lsl #2
	sc_restore_params[index].data = &sc_range[0];
   1a804:	621a      	str	r2, [r3, #32]
	sc_restore_params[index].len = sizeof(sc_range);
   1a806:	2204      	movs	r2, #4
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
   1a808:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
	sc_restore_params[index].len = sizeof(sc_range);
   1a80c:	849a      	strh	r2, [r3, #36]	; 0x24
	if (bt_gatt_indicate(conn, &sc_restore_params[index])) {
   1a80e:	4628      	mov	r0, r5
   1a810:	f7ff fef8 	bl	1a604 <bt_gatt_indicate>
   1a814:	b168      	cbz	r0, 1a832 <update_ccc+0xf2>
		BT_ERR("SC restore indication failed");
   1a816:	4b14      	ldr	r3, [pc, #80]	; (1a868 <update_ccc+0x128>)
   1a818:	681b      	ldr	r3, [r3, #0]
   1a81a:	075b      	lsls	r3, r3, #29
   1a81c:	d009      	beq.n	1a832 <update_ccc+0xf2>
   1a81e:	f04f 0100 	mov.w	r1, #0
   1a822:	2301      	movs	r3, #1
   1a824:	f363 0107 	bfi	r1, r3, #0, #8
   1a828:	f364 118f 	bfi	r1, r4, #6, #10
   1a82c:	480f      	ldr	r0, [pc, #60]	; (1a86c <update_ccc+0x12c>)
   1a82e:	f00e f884 	bl	2893a <log_0>
	memset(&cfg->data, 0, sizeof(cfg->data));
   1a832:	2204      	movs	r2, #4
   1a834:	2100      	movs	r1, #0
   1a836:	f106 0008 	add.w	r0, r6, #8
   1a83a:	f00f fe32 	bl	2a4a2 <memset>
}
   1a83e:	2001      	movs	r0, #1
   1a840:	b003      	add	sp, #12
   1a842:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1a846:	bf00      	nop
   1a848:	0001a0a1 	.word	0x0001a0a1
   1a84c:	0002dbf8 	.word	0x0002dbf8
   1a850:	0002db28 	.word	0x0002db28
   1a854:	00031423 	.word	0x00031423
   1a858:	2000fa54 	.word	0x2000fa54
   1a85c:	200017fc 	.word	0x200017fc
   1a860:	0002e660 	.word	0x0002e660
   1a864:	0002b493 	.word	0x0002b493
   1a868:	20010000 	.word	0x20010000
   1a86c:	00031437 	.word	0x00031437

0001a870 <bt_gatt_exchange_mtu>:
	if (conn->state != BT_CONN_CONNECTED) {
   1a870:	7a83      	ldrb	r3, [r0, #10]
   1a872:	2b04      	cmp	r3, #4
{
   1a874:	b570      	push	{r4, r5, r6, lr}
   1a876:	4605      	mov	r5, r0
   1a878:	460e      	mov	r6, r1
	if (conn->state != BT_CONN_CONNECTED) {
   1a87a:	d116      	bne.n	1a8aa <bt_gatt_exchange_mtu+0x3a>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_MTU_REQ, sizeof(*req));
   1a87c:	2202      	movs	r2, #2
   1a87e:	4611      	mov	r1, r2
   1a880:	f7fe fc0e 	bl	190a0 <bt_att_create_pdu>
	if (!buf) {
   1a884:	4604      	mov	r4, r0
   1a886:	b198      	cbz	r0, 1a8b0 <bt_gatt_exchange_mtu+0x40>
	req = net_buf_add(buf, sizeof(*req));
   1a888:	2102      	movs	r1, #2
   1a88a:	3008      	adds	r0, #8
   1a88c:	f012 f978 	bl	2cb80 <net_buf_simple_add>
	req->mtu = sys_cpu_to_le16(mtu);
   1a890:	f06f 0303 	mvn.w	r3, #3
   1a894:	7003      	strb	r3, [r0, #0]
   1a896:	2300      	movs	r3, #0
   1a898:	7043      	strb	r3, [r0, #1]
	return gatt_send(conn, buf, gatt_mtu_rsp, params, NULL);
   1a89a:	4621      	mov	r1, r4
   1a89c:	4633      	mov	r3, r6
   1a89e:	4628      	mov	r0, r5
   1a8a0:	4a05      	ldr	r2, [pc, #20]	; (1a8b8 <bt_gatt_exchange_mtu+0x48>)
}
   1a8a2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return gatt_send(conn, buf, gatt_mtu_rsp, params, NULL);
   1a8a6:	f7ff b933 	b.w	19b10 <gatt_send.constprop.37>
		return -ENOTCONN;
   1a8aa:	f06f 0038 	mvn.w	r0, #56	; 0x38
}
   1a8ae:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOMEM;
   1a8b0:	f06f 000b 	mvn.w	r0, #11
   1a8b4:	e7fb      	b.n	1a8ae <bt_gatt_exchange_mtu+0x3e>
   1a8b6:	bf00      	nop
   1a8b8:	0002b31f 	.word	0x0002b31f

0001a8bc <bt_gatt_discover>:
{
   1a8bc:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (conn->state != BT_CONN_CONNECTED) {
   1a8be:	7a83      	ldrb	r3, [r0, #10]
   1a8c0:	2b04      	cmp	r3, #4
{
   1a8c2:	b087      	sub	sp, #28
   1a8c4:	4605      	mov	r5, r0
   1a8c6:	460c      	mov	r4, r1
	if (conn->state != BT_CONN_CONNECTED) {
   1a8c8:	f040 80fe 	bne.w	1aac8 <bt_gatt_discover+0x20c>
	switch (params->type) {
   1a8cc:	f891 1024 	ldrb.w	r1, [r1, #36]	; 0x24
   1a8d0:	2905      	cmp	r1, #5
   1a8d2:	f200 80e5 	bhi.w	1aaa0 <bt_gatt_discover+0x1e4>
   1a8d6:	e8df f001 	tbb	[pc, r1]
   1a8da:	0303      	.short	0x0303
   1a8dc:	cf9b7c7c 	.word	0xcf9b7c7c
		if (params->uuid) {
   1a8e0:	6963      	ldr	r3, [r4, #20]
   1a8e2:	2b00      	cmp	r3, #0
   1a8e4:	d056      	beq.n	1a994 <bt_gatt_discover+0xd8>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_TYPE_REQ, sizeof(*req));
   1a8e6:	2206      	movs	r2, #6
   1a8e8:	4611      	mov	r1, r2
   1a8ea:	f7fe fbd9 	bl	190a0 <bt_att_create_pdu>
	if (!buf) {
   1a8ee:	4606      	mov	r6, r0
   1a8f0:	b918      	cbnz	r0, 1a8fa <bt_gatt_discover+0x3e>
		return -ENOMEM;
   1a8f2:	f06f 000b 	mvn.w	r0, #11
}
   1a8f6:	b007      	add	sp, #28
   1a8f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	req = net_buf_add(buf, sizeof(*req));
   1a8fa:	f100 0708 	add.w	r7, r0, #8
   1a8fe:	2106      	movs	r1, #6
   1a900:	4638      	mov	r0, r7
   1a902:	f012 f93d 	bl	2cb80 <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
   1a906:	8ba3      	ldrh	r3, [r4, #28]
   1a908:	8003      	strh	r3, [r0, #0]
	req->end_handle = sys_cpu_to_le16(params->end_handle);
   1a90a:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   1a90c:	8043      	strh	r3, [r0, #2]
	if (params->type == BT_GATT_DISCOVER_PRIMARY) {
   1a90e:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
   1a912:	bb2b      	cbnz	r3, 1a960 <bt_gatt_discover+0xa4>
		uuid = BT_UUID_GATT_PRIMARY;
   1a914:	f88d 3014 	strb.w	r3, [sp, #20]
   1a918:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   1a91c:	f8ad 3016 	strh.w	r3, [sp, #22]
   1a920:	ab05      	add	r3, sp, #20
	req->type = sys_cpu_to_le16(BT_UUID_16(uuid)->val);
   1a922:	885b      	ldrh	r3, [r3, #2]
   1a924:	8083      	strh	r3, [r0, #4]
	switch (params->uuid->type) {
   1a926:	6963      	ldr	r3, [r4, #20]
   1a928:	7819      	ldrb	r1, [r3, #0]
   1a92a:	b311      	cbz	r1, 1a972 <bt_gatt_discover+0xb6>
   1a92c:	2902      	cmp	r1, #2
   1a92e:	d02b      	beq.n	1a988 <bt_gatt_discover+0xcc>
		BT_ERR("Unknown UUID type %u", params->uuid->type);
   1a930:	4b67      	ldr	r3, [pc, #412]	; (1aad0 <bt_gatt_discover+0x214>)
   1a932:	681b      	ldr	r3, [r3, #0]
   1a934:	075a      	lsls	r2, r3, #29
   1a936:	d00d      	beq.n	1a954 <bt_gatt_discover+0x98>
   1a938:	2301      	movs	r3, #1
   1a93a:	f04f 0200 	mov.w	r2, #0
   1a93e:	f363 0207 	bfi	r2, r3, #0, #8
   1a942:	4864      	ldr	r0, [pc, #400]	; (1aad4 <bt_gatt_discover+0x218>)
   1a944:	4b64      	ldr	r3, [pc, #400]	; (1aad8 <bt_gatt_discover+0x21c>)
   1a946:	1a1b      	subs	r3, r3, r0
   1a948:	08db      	lsrs	r3, r3, #3
   1a94a:	f363 128f 	bfi	r2, r3, #6, #10
   1a94e:	4863      	ldr	r0, [pc, #396]	; (1aadc <bt_gatt_discover+0x220>)
   1a950:	f00e f800 	bl	28954 <log_1>
		net_buf_unref(buf);
   1a954:	4630      	mov	r0, r6
   1a956:	f00a fcb9 	bl	252cc <net_buf_unref>
	return -EINVAL;
   1a95a:	f06f 0015 	mvn.w	r0, #21
   1a95e:	e7ca      	b.n	1a8f6 <bt_gatt_discover+0x3a>
		uuid = BT_UUID_GATT_SECONDARY;
   1a960:	2300      	movs	r3, #0
   1a962:	f88d 3010 	strb.w	r3, [sp, #16]
   1a966:	f642 0301 	movw	r3, #10241	; 0x2801
   1a96a:	f8ad 3012 	strh.w	r3, [sp, #18]
   1a96e:	ab04      	add	r3, sp, #16
   1a970:	e7d7      	b.n	1a922 <bt_gatt_discover+0x66>
		net_buf_add_le16(buf, BT_UUID_16(params->uuid)->val);
   1a972:	8859      	ldrh	r1, [r3, #2]
   1a974:	4638      	mov	r0, r7
   1a976:	f012 f91a 	bl	2cbae <net_buf_simple_add_le16>
	return gatt_send(conn, buf, gatt_find_type_rsp, params, NULL);
   1a97a:	4a59      	ldr	r2, [pc, #356]	; (1aae0 <bt_gatt_discover+0x224>)
   1a97c:	4623      	mov	r3, r4
	return gatt_send(conn, buf, gatt_find_info_rsp, params, NULL);
   1a97e:	4631      	mov	r1, r6
   1a980:	4628      	mov	r0, r5
   1a982:	f7ff f8c5 	bl	19b10 <gatt_send.constprop.37>
   1a986:	e7b6      	b.n	1a8f6 <bt_gatt_discover+0x3a>
		net_buf_add_mem(buf, BT_UUID_128(params->uuid)->val, 16);
   1a988:	2210      	movs	r2, #16
   1a98a:	1c59      	adds	r1, r3, #1
   1a98c:	4638      	mov	r0, r7
   1a98e:	f012 f8fd 	bl	2cb8c <net_buf_simple_add_mem>
		break;
   1a992:	e7f2      	b.n	1a97a <bt_gatt_discover+0xbe>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_GROUP_REQ, sizeof(*req));
   1a994:	2204      	movs	r2, #4
   1a996:	2110      	movs	r1, #16
   1a998:	f7fe fb82 	bl	190a0 <bt_att_create_pdu>
	if (!buf) {
   1a99c:	4606      	mov	r6, r0
   1a99e:	2800      	cmp	r0, #0
   1a9a0:	d0a7      	beq.n	1a8f2 <bt_gatt_discover+0x36>
	req = net_buf_add(buf, sizeof(*req));
   1a9a2:	f100 0708 	add.w	r7, r0, #8
   1a9a6:	2104      	movs	r1, #4
   1a9a8:	4638      	mov	r0, r7
   1a9aa:	f012 f8e9 	bl	2cb80 <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
   1a9ae:	8ba3      	ldrh	r3, [r4, #28]
   1a9b0:	8003      	strh	r3, [r0, #0]
	req->end_handle = sys_cpu_to_le16(params->end_handle);
   1a9b2:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   1a9b4:	8043      	strh	r3, [r0, #2]
	if (params->type == BT_GATT_DISCOVER_PRIMARY) {
   1a9b6:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
   1a9ba:	b93b      	cbnz	r3, 1a9cc <bt_gatt_discover+0x110>
		net_buf_add_le16(buf, BT_UUID_16(BT_UUID_GATT_PRIMARY)->val);
   1a9bc:	f44f 5120 	mov.w	r1, #10240	; 0x2800
		net_buf_add_le16(buf, BT_UUID_16(BT_UUID_GATT_SECONDARY)->val);
   1a9c0:	4638      	mov	r0, r7
   1a9c2:	f012 f8f4 	bl	2cbae <net_buf_simple_add_le16>
	return gatt_send(conn, buf, gatt_read_group_rsp, params, NULL);
   1a9c6:	4623      	mov	r3, r4
   1a9c8:	4a46      	ldr	r2, [pc, #280]	; (1aae4 <bt_gatt_discover+0x228>)
   1a9ca:	e7d8      	b.n	1a97e <bt_gatt_discover+0xc2>
		net_buf_add_le16(buf, BT_UUID_16(BT_UUID_GATT_SECONDARY)->val);
   1a9cc:	f642 0101 	movw	r1, #10241	; 0x2801
   1a9d0:	e7f6      	b.n	1a9c0 <bt_gatt_discover+0x104>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_REQ, sizeof(*req));
   1a9d2:	2204      	movs	r2, #4
   1a9d4:	2108      	movs	r1, #8
   1a9d6:	f7fe fb63 	bl	190a0 <bt_att_create_pdu>
	if (!buf) {
   1a9da:	4606      	mov	r6, r0
   1a9dc:	2800      	cmp	r0, #0
   1a9de:	d088      	beq.n	1a8f2 <bt_gatt_discover+0x36>
	req = net_buf_add(buf, sizeof(*req));
   1a9e0:	f100 0708 	add.w	r7, r0, #8
   1a9e4:	2104      	movs	r1, #4
   1a9e6:	4638      	mov	r0, r7
   1a9e8:	f012 f8ca 	bl	2cb80 <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
   1a9ec:	8ba3      	ldrh	r3, [r4, #28]
   1a9ee:	8003      	strh	r3, [r0, #0]
	req->end_handle = sys_cpu_to_le16(params->end_handle);
   1a9f0:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   1a9f2:	8043      	strh	r3, [r0, #2]
	if (params->type == BT_GATT_DISCOVER_INCLUDE) {
   1a9f4:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
   1a9f8:	2b02      	cmp	r3, #2
		net_buf_add_le16(buf, BT_UUID_16(BT_UUID_GATT_INCLUDE)->val);
   1a9fa:	bf0c      	ite	eq
   1a9fc:	f642 0102 	movweq	r1, #10242	; 0x2802
		net_buf_add_le16(buf, BT_UUID_16(BT_UUID_GATT_CHRC)->val);
   1aa00:	f642 0103 	movwne	r1, #10243	; 0x2803
   1aa04:	4638      	mov	r0, r7
   1aa06:	f012 f8d2 	bl	2cbae <net_buf_simple_add_le16>
	return gatt_send(conn, buf, gatt_read_type_rsp, params, NULL);
   1aa0a:	4623      	mov	r3, r4
   1aa0c:	4a36      	ldr	r2, [pc, #216]	; (1aae8 <bt_gatt_discover+0x22c>)
   1aa0e:	e7b6      	b.n	1a97e <bt_gatt_discover+0xc2>
		if (params->uuid &&
   1aa10:	6960      	ldr	r0, [r4, #20]
   1aa12:	b388      	cbz	r0, 1aa78 <bt_gatt_discover+0x1bc>
		    (!bt_uuid_cmp(params->uuid, BT_UUID_GATT_PRIMARY) ||
   1aa14:	2600      	movs	r6, #0
   1aa16:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   1aa1a:	4669      	mov	r1, sp
   1aa1c:	f88d 6000 	strb.w	r6, [sp]
   1aa20:	f8ad 3002 	strh.w	r3, [sp, #2]
   1aa24:	f00f fe2f 	bl	2a686 <bt_uuid_cmp>
		if (params->uuid &&
   1aa28:	2800      	cmp	r0, #0
   1aa2a:	d096      	beq.n	1a95a <bt_gatt_discover+0x9e>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_SECONDARY) ||
   1aa2c:	f642 0301 	movw	r3, #10241	; 0x2801
   1aa30:	a901      	add	r1, sp, #4
   1aa32:	6960      	ldr	r0, [r4, #20]
   1aa34:	f88d 6004 	strb.w	r6, [sp, #4]
   1aa38:	f8ad 3006 	strh.w	r3, [sp, #6]
   1aa3c:	f00f fe23 	bl	2a686 <bt_uuid_cmp>
		    (!bt_uuid_cmp(params->uuid, BT_UUID_GATT_PRIMARY) ||
   1aa40:	2800      	cmp	r0, #0
   1aa42:	d08a      	beq.n	1a95a <bt_gatt_discover+0x9e>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_INCLUDE) ||
   1aa44:	f642 0302 	movw	r3, #10242	; 0x2802
   1aa48:	a902      	add	r1, sp, #8
   1aa4a:	6960      	ldr	r0, [r4, #20]
   1aa4c:	f88d 6008 	strb.w	r6, [sp, #8]
   1aa50:	f8ad 300a 	strh.w	r3, [sp, #10]
   1aa54:	f00f fe17 	bl	2a686 <bt_uuid_cmp>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_SECONDARY) ||
   1aa58:	2800      	cmp	r0, #0
   1aa5a:	f43f af7e 	beq.w	1a95a <bt_gatt_discover+0x9e>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_CHRC))) {
   1aa5e:	f642 0303 	movw	r3, #10243	; 0x2803
   1aa62:	a903      	add	r1, sp, #12
   1aa64:	6960      	ldr	r0, [r4, #20]
   1aa66:	f88d 600c 	strb.w	r6, [sp, #12]
   1aa6a:	f8ad 300e 	strh.w	r3, [sp, #14]
   1aa6e:	f00f fe0a 	bl	2a686 <bt_uuid_cmp>
		     !bt_uuid_cmp(params->uuid, BT_UUID_GATT_INCLUDE) ||
   1aa72:	2800      	cmp	r0, #0
   1aa74:	f43f af71 	beq.w	1a95a <bt_gatt_discover+0x9e>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_FIND_INFO_REQ, sizeof(*req));
   1aa78:	2204      	movs	r2, #4
   1aa7a:	4611      	mov	r1, r2
   1aa7c:	4628      	mov	r0, r5
   1aa7e:	f7fe fb0f 	bl	190a0 <bt_att_create_pdu>
	if (!buf) {
   1aa82:	4606      	mov	r6, r0
   1aa84:	2800      	cmp	r0, #0
   1aa86:	f43f af34 	beq.w	1a8f2 <bt_gatt_discover+0x36>
	req = net_buf_add(buf, sizeof(*req));
   1aa8a:	2104      	movs	r1, #4
   1aa8c:	3008      	adds	r0, #8
   1aa8e:	f012 f877 	bl	2cb80 <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->start_handle);
   1aa92:	8ba3      	ldrh	r3, [r4, #28]
   1aa94:	8003      	strh	r3, [r0, #0]
	req->end_handle = sys_cpu_to_le16(params->end_handle);
   1aa96:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   1aa98:	8043      	strh	r3, [r0, #2]
	return gatt_send(conn, buf, gatt_find_info_rsp, params, NULL);
   1aa9a:	4a14      	ldr	r2, [pc, #80]	; (1aaec <bt_gatt_discover+0x230>)
   1aa9c:	4623      	mov	r3, r4
   1aa9e:	e76e      	b.n	1a97e <bt_gatt_discover+0xc2>
		BT_ERR("Invalid discovery type: %u", params->type);
   1aaa0:	4b0b      	ldr	r3, [pc, #44]	; (1aad0 <bt_gatt_discover+0x214>)
   1aaa2:	681b      	ldr	r3, [r3, #0]
   1aaa4:	075b      	lsls	r3, r3, #29
   1aaa6:	f43f af58 	beq.w	1a95a <bt_gatt_discover+0x9e>
   1aaaa:	2301      	movs	r3, #1
   1aaac:	f04f 0200 	mov.w	r2, #0
   1aab0:	f363 0207 	bfi	r2, r3, #0, #8
   1aab4:	4807      	ldr	r0, [pc, #28]	; (1aad4 <bt_gatt_discover+0x218>)
   1aab6:	4b08      	ldr	r3, [pc, #32]	; (1aad8 <bt_gatt_discover+0x21c>)
   1aab8:	1a1b      	subs	r3, r3, r0
   1aaba:	08db      	lsrs	r3, r3, #3
   1aabc:	f363 128f 	bfi	r2, r3, #6, #10
   1aac0:	480b      	ldr	r0, [pc, #44]	; (1aaf0 <bt_gatt_discover+0x234>)
   1aac2:	f00d ff47 	bl	28954 <log_1>
   1aac6:	e748      	b.n	1a95a <bt_gatt_discover+0x9e>
		return -ENOTCONN;
   1aac8:	f06f 0038 	mvn.w	r0, #56	; 0x38
   1aacc:	e713      	b.n	1a8f6 <bt_gatt_discover+0x3a>
   1aace:	bf00      	nop
   1aad0:	20010000 	.word	0x20010000
   1aad4:	0002db28 	.word	0x0002db28
   1aad8:	0002dbf8 	.word	0x0002dbf8
   1aadc:	000312a7 	.word	0x000312a7
   1aae0:	0002b7ad 	.word	0x0002b7ad
   1aae4:	0001aaf5 	.word	0x0001aaf5
   1aae8:	0001ac29 	.word	0x0001ac29
   1aaec:	0001af39 	.word	0x0001af39
   1aaf0:	000312bc 	.word	0x000312bc

0001aaf4 <gatt_read_group_rsp>:
{
   1aaf4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1aaf8:	b08f      	sub	sp, #60	; 0x3c
   1aafa:	4690      	mov	r8, r2
   1aafc:	4681      	mov	r9, r0
   1aafe:	9d18      	ldr	r5, [sp, #96]	; 0x60
	if (err) {
   1ab00:	460a      	mov	r2, r1
   1ab02:	b131      	cbz	r1, 1ab12 <gatt_read_group_rsp+0x1e>
		params->func(conn, NULL, params);
   1ab04:	69ab      	ldr	r3, [r5, #24]
   1ab06:	462a      	mov	r2, r5
   1ab08:	2100      	movs	r1, #0
	params->func(conn, NULL, params);
   1ab0a:	4798      	blx	r3
}
   1ab0c:	b00f      	add	sp, #60	; 0x3c
   1ab0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (rsp->len) {
   1ab12:	f898 1000 	ldrb.w	r1, [r8]
   1ab16:	2906      	cmp	r1, #6
   1ab18:	d019      	beq.n	1ab4e <gatt_read_group_rsp+0x5a>
   1ab1a:	2914      	cmp	r1, #20
   1ab1c:	d016      	beq.n	1ab4c <gatt_read_group_rsp+0x58>
		BT_ERR("Invalid data len %u", rsp->len);
   1ab1e:	4b3e      	ldr	r3, [pc, #248]	; (1ac18 <gatt_read_group_rsp+0x124>)
   1ab20:	681b      	ldr	r3, [r3, #0]
   1ab22:	075b      	lsls	r3, r3, #29
   1ab24:	d00d      	beq.n	1ab42 <gatt_read_group_rsp+0x4e>
   1ab26:	2301      	movs	r3, #1
   1ab28:	f04f 0200 	mov.w	r2, #0
   1ab2c:	f363 0207 	bfi	r2, r3, #0, #8
   1ab30:	483a      	ldr	r0, [pc, #232]	; (1ac1c <gatt_read_group_rsp+0x128>)
   1ab32:	4b3b      	ldr	r3, [pc, #236]	; (1ac20 <gatt_read_group_rsp+0x12c>)
   1ab34:	1a1b      	subs	r3, r3, r0
   1ab36:	08db      	lsrs	r3, r3, #3
   1ab38:	f363 128f 	bfi	r2, r3, #6, #10
   1ab3c:	4839      	ldr	r0, [pc, #228]	; (1ac24 <gatt_read_group_rsp+0x130>)
   1ab3e:	f00d ff09 	bl	28954 <log_1>
	params->func(conn, NULL, params);
   1ab42:	69ab      	ldr	r3, [r5, #24]
   1ab44:	462a      	mov	r2, r5
   1ab46:	2100      	movs	r1, #0
   1ab48:	4648      	mov	r0, r9
   1ab4a:	e7de      	b.n	1ab0a <gatt_read_group_rsp+0x16>
		u.uuid.type = BT_UUID_TYPE_128;
   1ab4c:	2202      	movs	r2, #2
	for (length--, pdu = rsp->data; length >= rsp->len;
   1ab4e:	3b01      	subs	r3, #1
		u.uuid.type = BT_UUID_TYPE_128;
   1ab50:	f88d 2010 	strb.w	r2, [sp, #16]
	for (length--, pdu = rsp->data; length >= rsp->len;
   1ab54:	b29c      	uxth	r4, r3
   1ab56:	f108 0701 	add.w	r7, r8, #1
	u16_t start_handle, end_handle = 0U;
   1ab5a:	2600      	movs	r6, #0
	for (length--, pdu = rsp->data; length >= rsp->len;
   1ab5c:	f898 3000 	ldrb.w	r3, [r8]
   1ab60:	42a3      	cmp	r3, r4
   1ab62:	d909      	bls.n	1ab78 <gatt_read_group_rsp+0x84>
	if (length == 0U && end_handle) {
   1ab64:	2c00      	cmp	r4, #0
   1ab66:	d1ec      	bne.n	1ab42 <gatt_read_group_rsp+0x4e>
   1ab68:	2e00      	cmp	r6, #0
   1ab6a:	d0ea      	beq.n	1ab42 <gatt_read_group_rsp+0x4e>
	gatt_discover_next(conn, handle, params);
   1ab6c:	462a      	mov	r2, r5
   1ab6e:	4631      	mov	r1, r6
   1ab70:	4648      	mov	r0, r9
   1ab72:	f010 fdfe 	bl	2b772 <gatt_discover_next>
   1ab76:	e7c9      	b.n	1ab0c <gatt_read_group_rsp+0x18>
		struct bt_gatt_attr attr = {};
   1ab78:	2214      	movs	r2, #20
   1ab7a:	2100      	movs	r1, #0
   1ab7c:	a809      	add	r0, sp, #36	; 0x24
   1ab7e:	f00f fc90 	bl	2a4a2 <memset>
		start_handle = sys_le16_to_cpu(data->start_handle);
   1ab82:	f8b7 a000 	ldrh.w	sl, [r7]
   1ab86:	fa1f f38a 	uxth.w	r3, sl
		if (!start_handle) {
   1ab8a:	2b00      	cmp	r3, #0
   1ab8c:	d0d9      	beq.n	1ab42 <gatt_read_group_rsp+0x4e>
		end_handle = sys_le16_to_cpu(data->end_handle);
   1ab8e:	f8b7 b002 	ldrh.w	fp, [r7, #2]
   1ab92:	fa1f f68b 	uxth.w	r6, fp
		if (!end_handle || end_handle < start_handle) {
   1ab96:	2e00      	cmp	r6, #0
   1ab98:	d0d3      	beq.n	1ab42 <gatt_read_group_rsp+0x4e>
   1ab9a:	42b3      	cmp	r3, r6
   1ab9c:	d8d1      	bhi.n	1ab42 <gatt_read_group_rsp+0x4e>
		switch (u.uuid.type) {
   1ab9e:	f89d 3010 	ldrb.w	r3, [sp, #16]
   1aba2:	b30b      	cbz	r3, 1abe8 <gatt_read_group_rsp+0xf4>
   1aba4:	2b02      	cmp	r3, #2
   1aba6:	d026      	beq.n	1abf6 <gatt_read_group_rsp+0x102>
		if (params->type == BT_GATT_DISCOVER_PRIMARY) {
   1aba8:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   1abac:	bb43      	cbnz	r3, 1ac00 <gatt_read_group_rsp+0x10c>
			attr.uuid = BT_UUID_GATT_PRIMARY;
   1abae:	f88d 3004 	strb.w	r3, [sp, #4]
   1abb2:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   1abb6:	f8ad 3006 	strh.w	r3, [sp, #6]
   1abba:	ab01      	add	r3, sp, #4
   1abbc:	9309      	str	r3, [sp, #36]	; 0x24
		value.uuid = &u.uuid;
   1abbe:	ab04      	add	r3, sp, #16
   1abc0:	9302      	str	r3, [sp, #8]
		attr.user_data = &value;
   1abc2:	ab02      	add	r3, sp, #8
   1abc4:	930c      	str	r3, [sp, #48]	; 0x30
		value.end_handle = end_handle;
   1abc6:	f8ad b00c 	strh.w	fp, [sp, #12]
		attr.handle = start_handle;
   1abca:	f8ad a034 	strh.w	sl, [sp, #52]	; 0x34
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   1abce:	69ab      	ldr	r3, [r5, #24]
   1abd0:	462a      	mov	r2, r5
   1abd2:	a909      	add	r1, sp, #36	; 0x24
   1abd4:	4648      	mov	r0, r9
   1abd6:	4798      	blx	r3
   1abd8:	2800      	cmp	r0, #0
   1abda:	d097      	beq.n	1ab0c <gatt_read_group_rsp+0x18>
	     length -= rsp->len, pdu = (const u8_t *)pdu + rsp->len) {
   1abdc:	f898 2000 	ldrb.w	r2, [r8]
   1abe0:	1aa4      	subs	r4, r4, r2
   1abe2:	b2a4      	uxth	r4, r4
   1abe4:	4417      	add	r7, r2
   1abe6:	e7b9      	b.n	1ab5c <gatt_read_group_rsp+0x68>
			memcpy(&u.u16.val, data->value, sizeof(u.u16.val));
   1abe8:	2202      	movs	r2, #2
   1abea:	1d39      	adds	r1, r7, #4
   1abec:	f10d 0012 	add.w	r0, sp, #18
			memcpy(u.u128.val, data->value, sizeof(u.u128.val));
   1abf0:	f00f fc2d 	bl	2a44e <memcpy>
			break;
   1abf4:	e7d8      	b.n	1aba8 <gatt_read_group_rsp+0xb4>
			memcpy(u.u128.val, data->value, sizeof(u.u128.val));
   1abf6:	2210      	movs	r2, #16
   1abf8:	1d39      	adds	r1, r7, #4
   1abfa:	f10d 0011 	add.w	r0, sp, #17
   1abfe:	e7f7      	b.n	1abf0 <gatt_read_group_rsp+0xfc>
			attr.uuid = BT_UUID_GATT_SECONDARY;
   1ac00:	f04f 0300 	mov.w	r3, #0
   1ac04:	f88d 3000 	strb.w	r3, [sp]
   1ac08:	f642 0301 	movw	r3, #10241	; 0x2801
   1ac0c:	f8ad 3002 	strh.w	r3, [sp, #2]
   1ac10:	f8cd d024 	str.w	sp, [sp, #36]	; 0x24
   1ac14:	e7d3      	b.n	1abbe <gatt_read_group_rsp+0xca>
   1ac16:	bf00      	nop
   1ac18:	20010000 	.word	0x20010000
   1ac1c:	0002db28 	.word	0x0002db28
   1ac20:	0002dbf8 	.word	0x0002dbf8
   1ac24:	000313b8 	.word	0x000313b8

0001ac28 <gatt_read_type_rsp>:
{
   1ac28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ac2c:	b091      	sub	sp, #68	; 0x44
   1ac2e:	4690      	mov	r8, r2
   1ac30:	4607      	mov	r7, r0
   1ac32:	9e1a      	ldr	r6, [sp, #104]	; 0x68
	if (err) {
   1ac34:	460a      	mov	r2, r1
   1ac36:	b121      	cbz	r1, 1ac42 <gatt_read_type_rsp+0x1a>
		params->func(conn, NULL, params);
   1ac38:	69b3      	ldr	r3, [r6, #24]
   1ac3a:	4632      	mov	r2, r6
   1ac3c:	2100      	movs	r1, #0
	params->func(conn, NULL, params);
   1ac3e:	4798      	blx	r3
	if (!handle) {
   1ac40:	e085      	b.n	1ad4e <gatt_read_type_rsp+0x126>
	if (params->type == BT_GATT_DISCOVER_INCLUDE) {
   1ac42:	f896 0024 	ldrb.w	r0, [r6, #36]	; 0x24
   1ac46:	f898 1000 	ldrb.w	r1, [r8]
   1ac4a:	2802      	cmp	r0, #2
   1ac4c:	f040 808b 	bne.w	1ad66 <gatt_read_type_rsp+0x13e>
	switch (rsp->len) {
   1ac50:	2906      	cmp	r1, #6
   1ac52:	d01d      	beq.n	1ac90 <gatt_read_type_rsp+0x68>
   1ac54:	2908      	cmp	r1, #8
   1ac56:	f040 808a 	bne.w	1ad6e <gatt_read_type_rsp+0x146>
		u.uuid.type = BT_UUID_TYPE_16;
   1ac5a:	f88d 202c 	strb.w	r2, [sp, #44]	; 0x2c
	for (length--, pdu = rsp->data; length >= rsp->len;
   1ac5e:	1e5c      	subs	r4, r3, #1
   1ac60:	b2a4      	uxth	r4, r4
   1ac62:	f108 0501 	add.w	r5, r8, #1
	u16_t handle = 0U;
   1ac66:	f04f 0900 	mov.w	r9, #0
			value.uuid = &u.uuid;
   1ac6a:	f10d 0a2c 	add.w	sl, sp, #44	; 0x2c
	for (length--, pdu = rsp->data; length >= rsp->len;
   1ac6e:	f898 3000 	ldrb.w	r3, [r8]
   1ac72:	42a3      	cmp	r3, r4
   1ac74:	d90f      	bls.n	1ac96 <gatt_read_type_rsp+0x6e>
	if (length == 0U && handle) {
   1ac76:	2c00      	cmp	r4, #0
   1ac78:	f040 808b 	bne.w	1ad92 <gatt_read_type_rsp+0x16a>
   1ac7c:	f1b9 0f00 	cmp.w	r9, #0
   1ac80:	f000 8087 	beq.w	1ad92 <gatt_read_type_rsp+0x16a>
	gatt_discover_next(conn, handle, params);
   1ac84:	4632      	mov	r2, r6
   1ac86:	4649      	mov	r1, r9
   1ac88:	4638      	mov	r0, r7
   1ac8a:	f010 fd72 	bl	2b772 <gatt_discover_next>
   1ac8e:	e05e      	b.n	1ad4e <gatt_read_type_rsp+0x126>
		u.uuid.type = BT_UUID_TYPE_128;
   1ac90:	f88d 002c 	strb.w	r0, [sp, #44]	; 0x2c
		break;
   1ac94:	e7e3      	b.n	1ac5e <gatt_read_type_rsp+0x36>
		handle = sys_le16_to_cpu(data->handle);
   1ac96:	f8b5 b000 	ldrh.w	fp, [r5]
   1ac9a:	fa1f f98b 	uxth.w	r9, fp
		if (!handle) {
   1ac9e:	f1b9 0f00 	cmp.w	r9, #0
   1aca2:	d076      	beq.n	1ad92 <gatt_read_type_rsp+0x16a>
		value.start_handle = sys_le16_to_cpu(incl->start_handle);
   1aca4:	886b      	ldrh	r3, [r5, #2]
   1aca6:	f8ad 3014 	strh.w	r3, [sp, #20]
   1acaa:	b299      	uxth	r1, r3
		value.end_handle = sys_le16_to_cpu(incl->end_handle);
   1acac:	88ab      	ldrh	r3, [r5, #4]
   1acae:	f8ad 3016 	strh.w	r3, [sp, #22]
   1acb2:	b29a      	uxth	r2, r3
		switch (u.uuid.type) {
   1acb4:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
   1acb8:	b313      	cbz	r3, 1ad00 <gatt_read_type_rsp+0xd8>
   1acba:	2b02      	cmp	r3, #2
   1acbc:	d029      	beq.n	1ad12 <gatt_read_type_rsp+0xea>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   1acbe:	6971      	ldr	r1, [r6, #20]
   1acc0:	2900      	cmp	r1, #0
   1acc2:	d14a      	bne.n	1ad5a <gatt_read_type_rsp+0x132>
		attr = (&(struct bt_gatt_attr) {
   1acc4:	2210      	movs	r2, #16
   1acc6:	2100      	movs	r1, #0
   1acc8:	a807      	add	r0, sp, #28
   1acca:	f00f fbea 	bl	2a4a2 <memset>
			.uuid = BT_UUID_GATT_INCLUDE,
   1acce:	2300      	movs	r3, #0
   1acd0:	f88d 3008 	strb.w	r3, [sp, #8]
   1acd4:	f642 0302 	movw	r3, #10242	; 0x2802
   1acd8:	f8ad 300a 	strh.w	r3, [sp, #10]
		attr = (&(struct bt_gatt_attr) {
   1acdc:	ab02      	add	r3, sp, #8
   1acde:	9306      	str	r3, [sp, #24]
   1ace0:	ab04      	add	r3, sp, #16
   1ace2:	9309      	str	r3, [sp, #36]	; 0x24
		attr->handle = handle;
   1ace4:	f8ad b028 	strh.w	fp, [sp, #40]	; 0x28
		if (params->func(conn, attr, params) == BT_GATT_ITER_STOP) {
   1ace8:	69b3      	ldr	r3, [r6, #24]
   1acea:	4632      	mov	r2, r6
   1acec:	a906      	add	r1, sp, #24
   1acee:	4638      	mov	r0, r7
   1acf0:	4798      	blx	r3
   1acf2:	b360      	cbz	r0, 1ad4e <gatt_read_type_rsp+0x126>
	     length -= rsp->len, pdu = (const u8_t *)pdu + rsp->len) {
   1acf4:	f898 2000 	ldrb.w	r2, [r8]
   1acf8:	1aa4      	subs	r4, r4, r2
   1acfa:	b2a4      	uxth	r4, r4
   1acfc:	4415      	add	r5, r2
   1acfe:	e7b6      	b.n	1ac6e <gatt_read_type_rsp+0x46>
			value.uuid = &u.uuid;
   1ad00:	f8cd a010 	str.w	sl, [sp, #16]
			u.u16.val = sys_le16_to_cpu(incl->uuid16);
   1ad04:	79ab      	ldrb	r3, [r5, #6]
   1ad06:	79ea      	ldrb	r2, [r5, #7]
   1ad08:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1ad0c:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
			break;
   1ad10:	e7d5      	b.n	1acbe <gatt_read_type_rsp+0x96>
			params->_included.start_handle = value.start_handle;
   1ad12:	83f1      	strh	r1, [r6, #30]
			params->_included.end_handle = value.end_handle;
   1ad14:	8432      	strh	r2, [r6, #32]
			params->_included.attr_handle = handle;
   1ad16:	f8a6 901c 	strh.w	r9, [r6, #28]
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_REQ, sizeof(*req));
   1ad1a:	461a      	mov	r2, r3
   1ad1c:	210a      	movs	r1, #10
   1ad1e:	4638      	mov	r0, r7
   1ad20:	9301      	str	r3, [sp, #4]
   1ad22:	f7fe f9bd 	bl	190a0 <bt_att_create_pdu>
	if (!buf) {
   1ad26:	4604      	mov	r4, r0
   1ad28:	b1a0      	cbz	r0, 1ad54 <gatt_read_type_rsp+0x12c>
	req = net_buf_add(buf, sizeof(*req));
   1ad2a:	9b01      	ldr	r3, [sp, #4]
   1ad2c:	3008      	adds	r0, #8
   1ad2e:	4619      	mov	r1, r3
   1ad30:	f011 ff26 	bl	2cb80 <net_buf_simple_add>
	req->handle = sys_cpu_to_le16(params->_included.start_handle);
   1ad34:	8bf3      	ldrh	r3, [r6, #30]
   1ad36:	8003      	strh	r3, [r0, #0]
	return gatt_send(conn, buf, read_included_uuid_cb, params, NULL);
   1ad38:	4a48      	ldr	r2, [pc, #288]	; (1ae5c <gatt_read_type_rsp+0x234>)
   1ad3a:	4633      	mov	r3, r6
   1ad3c:	4621      	mov	r1, r4
   1ad3e:	4638      	mov	r0, r7
   1ad40:	f7fe fee6 	bl	19b10 <gatt_send.constprop.37>
			return read_included_uuid(conn, params);
   1ad44:	fa1f f980 	uxth.w	r9, r0
	if (!handle) {
   1ad48:	f1b9 0f00 	cmp.w	r9, #0
   1ad4c:	d19a      	bne.n	1ac84 <gatt_read_type_rsp+0x5c>
}
   1ad4e:	b011      	add	sp, #68	; 0x44
   1ad50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return -ENOMEM;
   1ad54:	f06f 000b 	mvn.w	r0, #11
   1ad58:	e7f4      	b.n	1ad44 <gatt_read_type_rsp+0x11c>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   1ad5a:	4650      	mov	r0, sl
   1ad5c:	f00f fc93 	bl	2a686 <bt_uuid_cmp>
   1ad60:	2800      	cmp	r0, #0
   1ad62:	d0af      	beq.n	1acc4 <gatt_read_type_rsp+0x9c>
   1ad64:	e7c6      	b.n	1acf4 <gatt_read_type_rsp+0xcc>
	switch (rsp->len) {
   1ad66:	2907      	cmp	r1, #7
   1ad68:	d019      	beq.n	1ad9e <gatt_read_type_rsp+0x176>
   1ad6a:	2915      	cmp	r1, #21
   1ad6c:	d016      	beq.n	1ad9c <gatt_read_type_rsp+0x174>
		BT_ERR("Invalid data len %u", rsp->len);
   1ad6e:	4b3c      	ldr	r3, [pc, #240]	; (1ae60 <gatt_read_type_rsp+0x238>)
   1ad70:	681b      	ldr	r3, [r3, #0]
   1ad72:	075b      	lsls	r3, r3, #29
   1ad74:	d00d      	beq.n	1ad92 <gatt_read_type_rsp+0x16a>
   1ad76:	2301      	movs	r3, #1
   1ad78:	f04f 0200 	mov.w	r2, #0
   1ad7c:	f363 0207 	bfi	r2, r3, #0, #8
   1ad80:	4838      	ldr	r0, [pc, #224]	; (1ae64 <gatt_read_type_rsp+0x23c>)
   1ad82:	4b39      	ldr	r3, [pc, #228]	; (1ae68 <gatt_read_type_rsp+0x240>)
   1ad84:	1a1b      	subs	r3, r3, r0
   1ad86:	08db      	lsrs	r3, r3, #3
   1ad88:	f363 128f 	bfi	r2, r3, #6, #10
   1ad8c:	4837      	ldr	r0, [pc, #220]	; (1ae6c <gatt_read_type_rsp+0x244>)
   1ad8e:	f00d fde1 	bl	28954 <log_1>
	params->func(conn, NULL, params);
   1ad92:	69b3      	ldr	r3, [r6, #24]
   1ad94:	4632      	mov	r2, r6
   1ad96:	2100      	movs	r1, #0
   1ad98:	4638      	mov	r0, r7
   1ad9a:	e750      	b.n	1ac3e <gatt_read_type_rsp+0x16>
		u.uuid.type = BT_UUID_TYPE_128;
   1ad9c:	2202      	movs	r2, #2
	for (length--, pdu = rsp->data; length >= rsp->len;
   1ad9e:	1e5c      	subs	r4, r3, #1
		u.uuid.type = BT_UUID_TYPE_128;
   1ada0:	f88d 2018 	strb.w	r2, [sp, #24]
	for (length--, pdu = rsp->data; length >= rsp->len;
   1ada4:	b2a4      	uxth	r4, r4
   1ada6:	f108 0501 	add.w	r5, r8, #1
	u16_t handle = 0U;
   1adaa:	f04f 0900 	mov.w	r9, #0
	for (length--, pdu = rsp->data; length >= rsp->len;
   1adae:	f898 3000 	ldrb.w	r3, [r8]
   1adb2:	42a3      	cmp	r3, r4
   1adb4:	f63f af5f 	bhi.w	1ac76 <gatt_read_type_rsp+0x4e>
		handle = sys_le16_to_cpu(data->handle);
   1adb8:	f8b5 b000 	ldrh.w	fp, [r5]
   1adbc:	fa1f f98b 	uxth.w	r9, fp
		if (!handle) {
   1adc0:	f1b9 0f00 	cmp.w	r9, #0
   1adc4:	d0e5      	beq.n	1ad92 <gatt_read_type_rsp+0x16a>
		switch (u.uuid.type) {
   1adc6:	f89d 3018 	ldrb.w	r3, [sp, #24]
   1adca:	2b00      	cmp	r3, #0
   1adcc:	d032      	beq.n	1ae34 <gatt_read_type_rsp+0x20c>
   1adce:	2b02      	cmp	r3, #2
   1add0:	d037      	beq.n	1ae42 <gatt_read_type_rsp+0x21a>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   1add2:	6971      	ldr	r1, [r6, #20]
   1add4:	f10d 0a18 	add.w	sl, sp, #24
   1add8:	2900      	cmp	r1, #0
   1adda:	d139      	bne.n	1ae50 <gatt_read_type_rsp+0x228>
		attr = (&(struct bt_gatt_attr)BT_GATT_CHRC(&u.uuid,
   1addc:	2300      	movs	r3, #0
   1adde:	930f      	str	r3, [sp, #60]	; 0x3c
   1ade0:	930d      	str	r3, [sp, #52]	; 0x34
   1ade2:	f88d 300c 	strb.w	r3, [sp, #12]
   1ade6:	f642 0303 	movw	r3, #10243	; 0x2803
   1adea:	f8ad 300e 	strh.w	r3, [sp, #14]
   1adee:	ab03      	add	r3, sp, #12
   1adf0:	930b      	str	r3, [sp, #44]	; 0x2c
   1adf2:	4b1f      	ldr	r3, [pc, #124]	; (1ae70 <gatt_read_type_rsp+0x248>)
   1adf4:	930c      	str	r3, [sp, #48]	; 0x30
   1adf6:	f8cd a010 	str.w	sl, [sp, #16]
   1adfa:	792a      	ldrb	r2, [r5, #4]
   1adfc:	78eb      	ldrb	r3, [r5, #3]
		attr->handle = handle;
   1adfe:	f8ad b03c 	strh.w	fp, [sp, #60]	; 0x3c
		attr = (&(struct bt_gatt_attr)BT_GATT_CHRC(&u.uuid,
   1ae02:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1ae06:	f8ad 3014 	strh.w	r3, [sp, #20]
   1ae0a:	78ab      	ldrb	r3, [r5, #2]
   1ae0c:	f88d 3016 	strb.w	r3, [sp, #22]
   1ae10:	ab04      	add	r3, sp, #16
   1ae12:	930e      	str	r3, [sp, #56]	; 0x38
   1ae14:	2301      	movs	r3, #1
   1ae16:	f88d 303e 	strb.w	r3, [sp, #62]	; 0x3e
		if (params->func(conn, attr, params) == BT_GATT_ITER_STOP) {
   1ae1a:	4632      	mov	r2, r6
   1ae1c:	69b3      	ldr	r3, [r6, #24]
   1ae1e:	a90b      	add	r1, sp, #44	; 0x2c
   1ae20:	4638      	mov	r0, r7
   1ae22:	4798      	blx	r3
   1ae24:	2800      	cmp	r0, #0
   1ae26:	d092      	beq.n	1ad4e <gatt_read_type_rsp+0x126>
	     length -= rsp->len, pdu = (const u8_t *)pdu + rsp->len) {
   1ae28:	f898 2000 	ldrb.w	r2, [r8]
   1ae2c:	1aa4      	subs	r4, r4, r2
   1ae2e:	b2a4      	uxth	r4, r4
   1ae30:	4415      	add	r5, r2
   1ae32:	e7bc      	b.n	1adae <gatt_read_type_rsp+0x186>
			u.u16.val = sys_le16_to_cpu(chrc->uuid16);
   1ae34:	796b      	ldrb	r3, [r5, #5]
   1ae36:	79aa      	ldrb	r2, [r5, #6]
   1ae38:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1ae3c:	f8ad 301a 	strh.w	r3, [sp, #26]
			break;
   1ae40:	e7c7      	b.n	1add2 <gatt_read_type_rsp+0x1aa>
			memcpy(u.u128.val, chrc->uuid, sizeof(chrc->uuid));
   1ae42:	2210      	movs	r2, #16
   1ae44:	1d69      	adds	r1, r5, #5
   1ae46:	f10d 0019 	add.w	r0, sp, #25
   1ae4a:	f00f fb00 	bl	2a44e <memcpy>
			break;
   1ae4e:	e7c0      	b.n	1add2 <gatt_read_type_rsp+0x1aa>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   1ae50:	4650      	mov	r0, sl
   1ae52:	f00f fc18 	bl	2a686 <bt_uuid_cmp>
   1ae56:	2800      	cmp	r0, #0
   1ae58:	d0c0      	beq.n	1addc <gatt_read_type_rsp+0x1b4>
   1ae5a:	e7e5      	b.n	1ae28 <gatt_read_type_rsp+0x200>
   1ae5c:	0001ae75 	.word	0x0001ae75
   1ae60:	20010000 	.word	0x20010000
   1ae64:	0002db28 	.word	0x0002db28
   1ae68:	0002dbf8 	.word	0x0002dbf8
   1ae6c:	000313b8 	.word	0x000313b8
   1ae70:	0002b6ad 	.word	0x0002b6ad

0001ae74 <read_included_uuid_cb>:
{
   1ae74:	b570      	push	{r4, r5, r6, lr}
   1ae76:	b08e      	sub	sp, #56	; 0x38
	if (length != 16U) {
   1ae78:	2b10      	cmp	r3, #16
{
   1ae7a:	4605      	mov	r5, r0
   1ae7c:	4611      	mov	r1, r2
   1ae7e:	9c12      	ldr	r4, [sp, #72]	; 0x48
	if (length != 16U) {
   1ae80:	d019      	beq.n	1aeb6 <read_included_uuid_cb+0x42>
		BT_ERR("Invalid data len %u", length);
   1ae82:	4a29      	ldr	r2, [pc, #164]	; (1af28 <read_included_uuid_cb+0xb4>)
   1ae84:	6812      	ldr	r2, [r2, #0]
   1ae86:	0752      	lsls	r2, r2, #29
   1ae88:	d00e      	beq.n	1aea8 <read_included_uuid_cb+0x34>
   1ae8a:	2101      	movs	r1, #1
   1ae8c:	f04f 0200 	mov.w	r2, #0
   1ae90:	f361 0207 	bfi	r2, r1, #0, #8
   1ae94:	4825      	ldr	r0, [pc, #148]	; (1af2c <read_included_uuid_cb+0xb8>)
   1ae96:	4926      	ldr	r1, [pc, #152]	; (1af30 <read_included_uuid_cb+0xbc>)
   1ae98:	1a40      	subs	r0, r0, r1
   1ae9a:	08c0      	lsrs	r0, r0, #3
   1ae9c:	f360 128f 	bfi	r2, r0, #6, #10
   1aea0:	4619      	mov	r1, r3
   1aea2:	4824      	ldr	r0, [pc, #144]	; (1af34 <read_included_uuid_cb+0xc0>)
   1aea4:	f00d fd56 	bl	28954 <log_1>
		params->func(conn, NULL, params);
   1aea8:	69a3      	ldr	r3, [r4, #24]
   1aeaa:	4622      	mov	r2, r4
   1aeac:	2100      	movs	r1, #0
   1aeae:	4628      	mov	r0, r5
   1aeb0:	4798      	blx	r3
}
   1aeb2:	b00e      	add	sp, #56	; 0x38
   1aeb4:	bd70      	pop	{r4, r5, r6, pc}
	value.start_handle = params->_included.start_handle;
   1aeb6:	8be2      	ldrh	r2, [r4, #30]
   1aeb8:	f8ad 200c 	strh.w	r2, [sp, #12]
	value.end_handle = params->_included.end_handle;
   1aebc:	8c22      	ldrh	r2, [r4, #32]
   1aebe:	f8ad 200e 	strh.w	r2, [sp, #14]
	u.uuid.type = BT_UUID_TYPE_128;
   1aec2:	2202      	movs	r2, #2
   1aec4:	f88d 2010 	strb.w	r2, [sp, #16]
	value.uuid = &u.uuid;
   1aec8:	ae04      	add	r6, sp, #16
	memcpy(u.u128.val, pdu, length);
   1aeca:	461a      	mov	r2, r3
   1aecc:	f10d 0011 	add.w	r0, sp, #17
	value.uuid = &u.uuid;
   1aed0:	9602      	str	r6, [sp, #8]
	memcpy(u.u128.val, pdu, length);
   1aed2:	f00f fabc 	bl	2a44e <memcpy>
	if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   1aed6:	6961      	ldr	r1, [r4, #20]
   1aed8:	b9f9      	cbnz	r1, 1af1a <read_included_uuid_cb+0xa6>
	attr = (&(struct bt_gatt_attr) {
   1aeda:	2210      	movs	r2, #16
   1aedc:	2100      	movs	r1, #0
   1aede:	a80a      	add	r0, sp, #40	; 0x28
   1aee0:	f00f fadf 	bl	2a4a2 <memset>
		.uuid = BT_UUID_GATT_INCLUDE,
   1aee4:	2300      	movs	r3, #0
   1aee6:	f88d 3004 	strb.w	r3, [sp, #4]
   1aeea:	f642 0302 	movw	r3, #10242	; 0x2802
   1aeee:	f8ad 3006 	strh.w	r3, [sp, #6]
	attr = (&(struct bt_gatt_attr) {
   1aef2:	ab01      	add	r3, sp, #4
   1aef4:	9309      	str	r3, [sp, #36]	; 0x24
   1aef6:	ab02      	add	r3, sp, #8
   1aef8:	930c      	str	r3, [sp, #48]	; 0x30
	attr->handle = params->_included.attr_handle;
   1aefa:	8ba3      	ldrh	r3, [r4, #28]
   1aefc:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
	if (params->func(conn, attr, params) == BT_GATT_ITER_STOP) {
   1af00:	4622      	mov	r2, r4
   1af02:	69a3      	ldr	r3, [r4, #24]
   1af04:	a909      	add	r1, sp, #36	; 0x24
   1af06:	4628      	mov	r0, r5
   1af08:	4798      	blx	r3
   1af0a:	2800      	cmp	r0, #0
   1af0c:	d0d1      	beq.n	1aeb2 <read_included_uuid_cb+0x3e>
	gatt_discover_next(conn, params->start_handle, params);
   1af0e:	4622      	mov	r2, r4
   1af10:	8ba1      	ldrh	r1, [r4, #28]
   1af12:	4628      	mov	r0, r5
   1af14:	f010 fc2d 	bl	2b772 <gatt_discover_next>
	return;
   1af18:	e7cb      	b.n	1aeb2 <read_included_uuid_cb+0x3e>
	if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   1af1a:	4630      	mov	r0, r6
   1af1c:	f00f fbb3 	bl	2a686 <bt_uuid_cmp>
   1af20:	2800      	cmp	r0, #0
   1af22:	d0da      	beq.n	1aeda <read_included_uuid_cb+0x66>
   1af24:	e7f3      	b.n	1af0e <read_included_uuid_cb+0x9a>
   1af26:	bf00      	nop
   1af28:	20010000 	.word	0x20010000
   1af2c:	0002dbf8 	.word	0x0002dbf8
   1af30:	0002db28 	.word	0x0002db28
   1af34:	000313b8 	.word	0x000313b8

0001af38 <gatt_find_info_rsp>:
{
   1af38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1af3c:	b091      	sub	sp, #68	; 0x44
   1af3e:	4682      	mov	sl, r0
   1af40:	9e1a      	ldr	r6, [sp, #104]	; 0x68
	if (err) {
   1af42:	4608      	mov	r0, r1
   1af44:	b9b1      	cbnz	r1, 1af74 <gatt_find_info_rsp+0x3c>
	switch (rsp->format) {
   1af46:	7811      	ldrb	r1, [r2, #0]
   1af48:	2901      	cmp	r1, #1
   1af4a:	d019      	beq.n	1af80 <gatt_find_info_rsp+0x48>
   1af4c:	2902      	cmp	r1, #2
   1af4e:	d02d      	beq.n	1afac <gatt_find_info_rsp+0x74>
		BT_ERR("Invalid format %u", rsp->format);
   1af50:	4b50      	ldr	r3, [pc, #320]	; (1b094 <gatt_find_info_rsp+0x15c>)
   1af52:	681b      	ldr	r3, [r3, #0]
   1af54:	075b      	lsls	r3, r3, #29
   1af56:	d00d      	beq.n	1af74 <gatt_find_info_rsp+0x3c>
   1af58:	2301      	movs	r3, #1
   1af5a:	f04f 0200 	mov.w	r2, #0
   1af5e:	f363 0207 	bfi	r2, r3, #0, #8
   1af62:	484d      	ldr	r0, [pc, #308]	; (1b098 <gatt_find_info_rsp+0x160>)
   1af64:	4b4d      	ldr	r3, [pc, #308]	; (1b09c <gatt_find_info_rsp+0x164>)
   1af66:	1a1b      	subs	r3, r3, r0
   1af68:	08db      	lsrs	r3, r3, #3
   1af6a:	f363 128f 	bfi	r2, r3, #6, #10
   1af6e:	484c      	ldr	r0, [pc, #304]	; (1b0a0 <gatt_find_info_rsp+0x168>)
   1af70:	f00d fcf0 	bl	28954 <log_1>
	params->func(conn, NULL, params);
   1af74:	69b3      	ldr	r3, [r6, #24]
   1af76:	4632      	mov	r2, r6
   1af78:	2100      	movs	r1, #0
   1af7a:	4650      	mov	r0, sl
   1af7c:	4798      	blx	r3
   1af7e:	e085      	b.n	1b08c <gatt_find_info_rsp+0x154>
		u.uuid.type = BT_UUID_TYPE_16;
   1af80:	f88d 0018 	strb.w	r0, [sp, #24]
		len = sizeof(*info.i16);
   1af84:	f04f 0804 	mov.w	r8, #4
	length--;
   1af88:	1e5c      	subs	r4, r3, #1
   1af8a:	b2a4      	uxth	r4, r4
	if (length < len) {
   1af8c:	4544      	cmp	r4, r8
   1af8e:	d3f1      	bcc.n	1af74 <gatt_find_info_rsp+0x3c>
	for (i = length / len, pdu = rsp->info; i != 0;
   1af90:	fbb4 f4f8 	udiv	r4, r4, r8
	bool skip = false;
   1af94:	2300      	movs	r3, #0
	for (i = length / len, pdu = rsp->info; i != 0;
   1af96:	1c55      	adds	r5, r2, #1
	u16_t handle = 0U;
   1af98:	9301      	str	r3, [sp, #4]
   1af9a:	af06      	add	r7, sp, #24
			if (!bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) ||
   1af9c:	4699      	mov	r9, r3
	for (i = length / len, pdu = rsp->info; i != 0;
   1af9e:	b954      	cbnz	r4, 1afb6 <gatt_find_info_rsp+0x7e>
	gatt_discover_next(conn, handle, params);
   1afa0:	4632      	mov	r2, r6
   1afa2:	9901      	ldr	r1, [sp, #4]
   1afa4:	4650      	mov	r0, sl
   1afa6:	f010 fbe4 	bl	2b772 <gatt_discover_next>
	return;
   1afaa:	e06f      	b.n	1b08c <gatt_find_info_rsp+0x154>
		u.uuid.type = BT_UUID_TYPE_128;
   1afac:	f88d 1018 	strb.w	r1, [sp, #24]
		len = sizeof(*info.i128);
   1afb0:	f04f 0812 	mov.w	r8, #18
		break;
   1afb4:	e7e8      	b.n	1af88 <gatt_find_info_rsp+0x50>
		handle = sys_le16_to_cpu(info.i16->handle);
   1afb6:	f8b5 b000 	ldrh.w	fp, [r5]
   1afba:	fa1f f28b 	uxth.w	r2, fp
   1afbe:	9201      	str	r2, [sp, #4]
		if (skip) {
   1afc0:	b11b      	cbz	r3, 1afca <gatt_find_info_rsp+0x92>
			skip = false;
   1afc2:	2300      	movs	r3, #0
	     i--, pdu = (const u8_t *)pdu + len) {
   1afc4:	3c01      	subs	r4, #1
   1afc6:	4445      	add	r5, r8
   1afc8:	e7e9      	b.n	1af9e <gatt_find_info_rsp+0x66>
		switch (u.uuid.type) {
   1afca:	f89d 3018 	ldrb.w	r3, [sp, #24]
   1afce:	2b00      	cmp	r3, #0
   1afd0:	d039      	beq.n	1b046 <gatt_find_info_rsp+0x10e>
   1afd2:	2b02      	cmp	r3, #2
   1afd4:	d03e      	beq.n	1b054 <gatt_find_info_rsp+0x11c>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   1afd6:	6971      	ldr	r1, [r6, #20]
   1afd8:	2900      	cmp	r1, #0
   1afda:	d142      	bne.n	1b062 <gatt_find_info_rsp+0x12a>
		if (params->type == BT_GATT_DISCOVER_DESCRIPTOR) {
   1afdc:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
   1afe0:	2b04      	cmp	r3, #4
   1afe2:	d144      	bne.n	1b06e <gatt_find_info_rsp+0x136>
			if (!bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) ||
   1afe4:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   1afe8:	a902      	add	r1, sp, #8
   1afea:	4638      	mov	r0, r7
   1afec:	f88d 9008 	strb.w	r9, [sp, #8]
   1aff0:	f8ad 300a 	strh.w	r3, [sp, #10]
   1aff4:	f00f fb47 	bl	2a686 <bt_uuid_cmp>
   1aff8:	2800      	cmp	r0, #0
   1affa:	d0e2      	beq.n	1afc2 <gatt_find_info_rsp+0x8a>
			    !bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY) ||
   1affc:	f642 0301 	movw	r3, #10241	; 0x2801
   1b000:	a903      	add	r1, sp, #12
   1b002:	4638      	mov	r0, r7
   1b004:	f88d 900c 	strb.w	r9, [sp, #12]
   1b008:	f8ad 300e 	strh.w	r3, [sp, #14]
   1b00c:	f00f fb3b 	bl	2a686 <bt_uuid_cmp>
			if (!bt_uuid_cmp(&u.uuid, BT_UUID_GATT_PRIMARY) ||
   1b010:	2800      	cmp	r0, #0
   1b012:	d0d6      	beq.n	1afc2 <gatt_find_info_rsp+0x8a>
			    !bt_uuid_cmp(&u.uuid, BT_UUID_GATT_INCLUDE)) {
   1b014:	f642 0302 	movw	r3, #10242	; 0x2802
   1b018:	a904      	add	r1, sp, #16
   1b01a:	4638      	mov	r0, r7
   1b01c:	f88d 9010 	strb.w	r9, [sp, #16]
   1b020:	f8ad 3012 	strh.w	r3, [sp, #18]
   1b024:	f00f fb2f 	bl	2a686 <bt_uuid_cmp>
			    !bt_uuid_cmp(&u.uuid, BT_UUID_GATT_SECONDARY) ||
   1b028:	2800      	cmp	r0, #0
   1b02a:	d0ca      	beq.n	1afc2 <gatt_find_info_rsp+0x8a>
			if (!bt_uuid_cmp(&u.uuid, BT_UUID_GATT_CHRC)) {
   1b02c:	f642 0303 	movw	r3, #10243	; 0x2803
   1b030:	a905      	add	r1, sp, #20
   1b032:	4638      	mov	r0, r7
   1b034:	f88d 9014 	strb.w	r9, [sp, #20]
   1b038:	f8ad 3016 	strh.w	r3, [sp, #22]
   1b03c:	f00f fb23 	bl	2a686 <bt_uuid_cmp>
   1b040:	b9a8      	cbnz	r0, 1b06e <gatt_find_info_rsp+0x136>
				skip = true;
   1b042:	2301      	movs	r3, #1
   1b044:	e7be      	b.n	1afc4 <gatt_find_info_rsp+0x8c>
			u.u16.val = sys_le16_to_cpu(info.i16->uuid);
   1b046:	78ab      	ldrb	r3, [r5, #2]
   1b048:	78ea      	ldrb	r2, [r5, #3]
   1b04a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1b04e:	f8ad 301a 	strh.w	r3, [sp, #26]
			break;
   1b052:	e7c0      	b.n	1afd6 <gatt_find_info_rsp+0x9e>
			memcpy(u.u128.val, info.i128->uuid, 16);
   1b054:	2210      	movs	r2, #16
   1b056:	1ca9      	adds	r1, r5, #2
   1b058:	f10d 0019 	add.w	r0, sp, #25
   1b05c:	f00f f9f7 	bl	2a44e <memcpy>
			break;
   1b060:	e7b9      	b.n	1afd6 <gatt_find_info_rsp+0x9e>
		if (params->uuid && bt_uuid_cmp(&u.uuid, params->uuid)) {
   1b062:	4638      	mov	r0, r7
   1b064:	f00f fb0f 	bl	2a686 <bt_uuid_cmp>
   1b068:	2800      	cmp	r0, #0
   1b06a:	d0b7      	beq.n	1afdc <gatt_find_info_rsp+0xa4>
   1b06c:	e7a9      	b.n	1afc2 <gatt_find_info_rsp+0x8a>
			BT_GATT_DESCRIPTOR(&u.uuid, 0, NULL, NULL, NULL));
   1b06e:	2210      	movs	r2, #16
   1b070:	2100      	movs	r1, #0
   1b072:	a80c      	add	r0, sp, #48	; 0x30
   1b074:	f00f fa15 	bl	2a4a2 <memset>
   1b078:	970b      	str	r7, [sp, #44]	; 0x2c
		attr->handle = handle;
   1b07a:	f8ad b03c 	strh.w	fp, [sp, #60]	; 0x3c
		if (params->func(conn, attr, params) == BT_GATT_ITER_STOP) {
   1b07e:	69b3      	ldr	r3, [r6, #24]
   1b080:	4632      	mov	r2, r6
   1b082:	a90b      	add	r1, sp, #44	; 0x2c
   1b084:	4650      	mov	r0, sl
   1b086:	4798      	blx	r3
   1b088:	2800      	cmp	r0, #0
   1b08a:	d19a      	bne.n	1afc2 <gatt_find_info_rsp+0x8a>
}
   1b08c:	b011      	add	sp, #68	; 0x44
   1b08e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1b092:	bf00      	nop
   1b094:	20010000 	.word	0x20010000
   1b098:	0002db28 	.word	0x0002db28
   1b09c:	0002dbf8 	.word	0x0002dbf8
   1b0a0:	00031356 	.word	0x00031356

0001b0a4 <bt_gatt_read>:
{
   1b0a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (conn->state != BT_CONN_CONNECTED) {
   1b0a8:	7a86      	ldrb	r6, [r0, #10]
   1b0aa:	2e04      	cmp	r6, #4
{
   1b0ac:	4605      	mov	r5, r0
   1b0ae:	460c      	mov	r4, r1
	if (conn->state != BT_CONN_CONNECTED) {
   1b0b0:	d169      	bne.n	1b186 <bt_gatt_read+0xe2>
	if (params->handle_count == 0) {
   1b0b2:	698a      	ldr	r2, [r1, #24]
   1b0b4:	bb42      	cbnz	r2, 1b108 <bt_gatt_read+0x64>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_TYPE_REQ, sizeof(*req));
   1b0b6:	4632      	mov	r2, r6
   1b0b8:	2108      	movs	r1, #8
   1b0ba:	f7fd fff1 	bl	190a0 <bt_att_create_pdu>
	if (!buf) {
   1b0be:	4607      	mov	r7, r0
   1b0c0:	b918      	cbnz	r0, 1b0ca <bt_gatt_read+0x26>
		return -ENOMEM;
   1b0c2:	f06f 000b 	mvn.w	r0, #11
}
   1b0c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	req = net_buf_add(buf, sizeof(*req));
   1b0ca:	f100 0808 	add.w	r8, r0, #8
   1b0ce:	4631      	mov	r1, r6
   1b0d0:	4640      	mov	r0, r8
   1b0d2:	f011 fd55 	bl	2cb80 <net_buf_simple_add>
	req->start_handle = sys_cpu_to_le16(params->by_uuid.start_handle);
   1b0d6:	8ba3      	ldrh	r3, [r4, #28]
   1b0d8:	8003      	strh	r3, [r0, #0]
	if (params->by_uuid.uuid->type == BT_UUID_TYPE_16) {
   1b0da:	6a21      	ldr	r1, [r4, #32]
	req->end_handle = sys_cpu_to_le16(params->by_uuid.end_handle);
   1b0dc:	8be3      	ldrh	r3, [r4, #30]
   1b0de:	8043      	strh	r3, [r0, #2]
	if (params->by_uuid.uuid->type == BT_UUID_TYPE_16) {
   1b0e0:	780b      	ldrb	r3, [r1, #0]
   1b0e2:	b95b      	cbnz	r3, 1b0fc <bt_gatt_read+0x58>
		net_buf_add_le16(buf, BT_UUID_16(params->by_uuid.uuid)->val);
   1b0e4:	8849      	ldrh	r1, [r1, #2]
   1b0e6:	4640      	mov	r0, r8
   1b0e8:	f011 fd61 	bl	2cbae <net_buf_simple_add_le16>
	return gatt_send(conn, buf, gatt_read_rsp, params, NULL);
   1b0ec:	4a27      	ldr	r2, [pc, #156]	; (1b18c <bt_gatt_read+0xe8>)
   1b0ee:	4623      	mov	r3, r4
   1b0f0:	4639      	mov	r1, r7
	return gatt_send(conn, buf, gatt_read_rsp, params, NULL);
   1b0f2:	4628      	mov	r0, r5
}
   1b0f4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return gatt_send(conn, buf, gatt_read_rsp, params, NULL);
   1b0f8:	f7fe bd0a 	b.w	19b10 <gatt_send.constprop.37>
		net_buf_add_mem(buf, BT_UUID_128(params->by_uuid.uuid)->val, 16);
   1b0fc:	2210      	movs	r2, #16
   1b0fe:	3101      	adds	r1, #1
   1b100:	4640      	mov	r0, r8
   1b102:	f011 fd43 	bl	2cb8c <net_buf_simple_add_mem>
	return gatt_send(conn, buf, gatt_read_rsp, params, NULL);
   1b106:	e7f1      	b.n	1b0ec <bt_gatt_read+0x48>
	if (params->handle_count > 1) {
   1b108:	2a01      	cmp	r2, #1
   1b10a:	d91a      	bls.n	1b142 <bt_gatt_read+0x9e>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_MULT_REQ,
   1b10c:	0052      	lsls	r2, r2, #1
   1b10e:	210e      	movs	r1, #14
   1b110:	f7fd ffc6 	bl	190a0 <bt_att_create_pdu>
	if (!buf) {
   1b114:	4606      	mov	r6, r0
   1b116:	2800      	cmp	r0, #0
   1b118:	d0d3      	beq.n	1b0c2 <bt_gatt_read+0x1e>
   1b11a:	2700      	movs	r7, #0
		net_buf_add_le16(buf, params->handles[i]);
   1b11c:	f100 0808 	add.w	r8, r0, #8
	for (i = 0U; i < params->handle_count; i++) {
   1b120:	69a2      	ldr	r2, [r4, #24]
   1b122:	b2fb      	uxtb	r3, r7
   1b124:	429a      	cmp	r2, r3
   1b126:	f107 0701 	add.w	r7, r7, #1
   1b12a:	d803      	bhi.n	1b134 <bt_gatt_read+0x90>
	return gatt_send(conn, buf, gatt_read_multiple_rsp, params, NULL);
   1b12c:	4a18      	ldr	r2, [pc, #96]	; (1b190 <bt_gatt_read+0xec>)
   1b12e:	4623      	mov	r3, r4
	return gatt_send(conn, buf, gatt_read_rsp, params, NULL);
   1b130:	4631      	mov	r1, r6
   1b132:	e7de      	b.n	1b0f2 <bt_gatt_read+0x4e>
		net_buf_add_le16(buf, params->handles[i]);
   1b134:	69e2      	ldr	r2, [r4, #28]
   1b136:	4640      	mov	r0, r8
   1b138:	f832 1013 	ldrh.w	r1, [r2, r3, lsl #1]
   1b13c:	f011 fd37 	bl	2cbae <net_buf_simple_add_le16>
   1b140:	e7ee      	b.n	1b120 <bt_gatt_read+0x7c>
	if (params->single.offset) {
   1b142:	8bcb      	ldrh	r3, [r1, #30]
   1b144:	b17b      	cbz	r3, 1b166 <bt_gatt_read+0xc2>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_BLOB_REQ, sizeof(*req));
   1b146:	4632      	mov	r2, r6
   1b148:	210c      	movs	r1, #12
   1b14a:	f7fd ffa9 	bl	190a0 <bt_att_create_pdu>
	if (!buf) {
   1b14e:	4607      	mov	r7, r0
   1b150:	2800      	cmp	r0, #0
   1b152:	d0b6      	beq.n	1b0c2 <bt_gatt_read+0x1e>
	req = net_buf_add(buf, sizeof(*req));
   1b154:	4631      	mov	r1, r6
   1b156:	3008      	adds	r0, #8
   1b158:	f011 fd12 	bl	2cb80 <net_buf_simple_add>
	req->handle = sys_cpu_to_le16(params->single.handle);
   1b15c:	8ba3      	ldrh	r3, [r4, #28]
   1b15e:	8003      	strh	r3, [r0, #0]
	req->offset = sys_cpu_to_le16(params->single.offset);
   1b160:	8be3      	ldrh	r3, [r4, #30]
   1b162:	8043      	strh	r3, [r0, #2]
   1b164:	e7c2      	b.n	1b0ec <bt_gatt_read+0x48>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_READ_REQ, sizeof(*req));
   1b166:	2202      	movs	r2, #2
   1b168:	210a      	movs	r1, #10
   1b16a:	f7fd ff99 	bl	190a0 <bt_att_create_pdu>
	if (!buf) {
   1b16e:	4606      	mov	r6, r0
   1b170:	2800      	cmp	r0, #0
   1b172:	d0a6      	beq.n	1b0c2 <bt_gatt_read+0x1e>
	req = net_buf_add(buf, sizeof(*req));
   1b174:	2102      	movs	r1, #2
   1b176:	3008      	adds	r0, #8
   1b178:	f011 fd02 	bl	2cb80 <net_buf_simple_add>
	req->handle = sys_cpu_to_le16(params->single.handle);
   1b17c:	8ba3      	ldrh	r3, [r4, #28]
   1b17e:	8003      	strh	r3, [r0, #0]
	return gatt_send(conn, buf, gatt_read_rsp, params, NULL);
   1b180:	4a02      	ldr	r2, [pc, #8]	; (1b18c <bt_gatt_read+0xe8>)
   1b182:	4623      	mov	r3, r4
   1b184:	e7d4      	b.n	1b130 <bt_gatt_read+0x8c>
		return -ENOTCONN;
   1b186:	f06f 0038 	mvn.w	r0, #56	; 0x38
   1b18a:	e79c      	b.n	1b0c6 <bt_gatt_read+0x22>
   1b18c:	0001b195 	.word	0x0001b195
   1b190:	0002b40d 	.word	0x0002b40d

0001b194 <gatt_read_rsp>:
{
   1b194:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   1b198:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   1b19a:	4606      	mov	r6, r0
   1b19c:	4690      	mov	r8, r2
   1b19e:	4699      	mov	r9, r3
	if (err || !length) {
   1b1a0:	460f      	mov	r7, r1
   1b1a2:	b901      	cbnz	r1, 1b1a6 <gatt_read_rsp+0x12>
   1b1a4:	b953      	cbnz	r3, 1b1bc <gatt_read_rsp+0x28>
		params->func(conn, err, params, NULL, 0);
   1b1a6:	2300      	movs	r3, #0
   1b1a8:	930a      	str	r3, [sp, #40]	; 0x28
   1b1aa:	6965      	ldr	r5, [r4, #20]
   1b1ac:	4622      	mov	r2, r4
   1b1ae:	4639      	mov	r1, r7
		params->func(conn, BT_ATT_ERR_UNLIKELY, params, NULL, 0);
   1b1b0:	4630      	mov	r0, r6
   1b1b2:	46ac      	mov	ip, r5
}
   1b1b4:	b003      	add	sp, #12
   1b1b6:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
		params->func(conn, BT_ATT_ERR_UNLIKELY, params, NULL, 0);
   1b1ba:	4760      	bx	ip
	if (!params->handle_count) {
   1b1bc:	69a3      	ldr	r3, [r4, #24]
   1b1be:	2b00      	cmp	r3, #0
   1b1c0:	d152      	bne.n	1b268 <gatt_read_rsp+0xd4>
	for (length--, pdu = rsp->data; length;
   1b1c2:	f109 35ff 	add.w	r5, r9, #4294967295	; 0xffffffff
   1b1c6:	b2ad      	uxth	r5, r5
   1b1c8:	f102 0901 	add.w	r9, r2, #1
   1b1cc:	2d00      	cmp	r5, #0
   1b1ce:	d02f      	beq.n	1b230 <gatt_read_rsp+0x9c>
		handle = sys_le16_to_cpu(data->handle);
   1b1d0:	f8b9 2000 	ldrh.w	r2, [r9]
   1b1d4:	b293      	uxth	r3, r2
		if (!handle) {
   1b1d6:	b9a3      	cbnz	r3, 1b202 <gatt_read_rsp+0x6e>
			BT_ERR("Invalid handle");
   1b1d8:	4b34      	ldr	r3, [pc, #208]	; (1b2ac <gatt_read_rsp+0x118>)
   1b1da:	681b      	ldr	r3, [r3, #0]
   1b1dc:	075b      	lsls	r3, r3, #29
   1b1de:	d062      	beq.n	1b2a6 <gatt_read_rsp+0x112>
   1b1e0:	2301      	movs	r3, #1
   1b1e2:	f04f 0100 	mov.w	r1, #0
   1b1e6:	f363 0107 	bfi	r1, r3, #0, #8
   1b1ea:	4a31      	ldr	r2, [pc, #196]	; (1b2b0 <gatt_read_rsp+0x11c>)
   1b1ec:	4b31      	ldr	r3, [pc, #196]	; (1b2b4 <gatt_read_rsp+0x120>)
   1b1ee:	4832      	ldr	r0, [pc, #200]	; (1b2b8 <gatt_read_rsp+0x124>)
   1b1f0:	1a9b      	subs	r3, r3, r2
   1b1f2:	08db      	lsrs	r3, r3, #3
   1b1f4:	f363 118f 	bfi	r1, r3, #6, #10
}
   1b1f8:	b003      	add	sp, #12
   1b1fa:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
			BT_ERR("Invalid handle");
   1b1fe:	f00d bb9c 	b.w	2893a <log_0>
		len = rsp->len > length ? length - 2 : rsp->len - 2;
   1b202:	f898 3000 	ldrb.w	r3, [r8]
		params->by_uuid.start_handle = handle;
   1b206:	83a2      	strh	r2, [r4, #28]
		len = rsp->len > length ? length - 2 : rsp->len - 2;
   1b208:	42ab      	cmp	r3, r5
   1b20a:	bf8c      	ite	hi
   1b20c:	1eab      	subhi	r3, r5, #2
   1b20e:	3b02      	subls	r3, #2
   1b210:	b29b      	uxth	r3, r3
		if (params->func(conn, 0, params, data->value, len) ==
   1b212:	9300      	str	r3, [sp, #0]
   1b214:	6967      	ldr	r7, [r4, #20]
   1b216:	f109 0302 	add.w	r3, r9, #2
   1b21a:	4622      	mov	r2, r4
   1b21c:	2100      	movs	r1, #0
   1b21e:	4630      	mov	r0, r6
   1b220:	47b8      	blx	r7
   1b222:	2800      	cmp	r0, #0
   1b224:	d03f      	beq.n	1b2a6 <gatt_read_rsp+0x112>
		if (rsp->len > length) {
   1b226:	f898 1000 	ldrb.w	r1, [r8]
   1b22a:	b28b      	uxth	r3, r1
   1b22c:	429d      	cmp	r5, r3
   1b22e:	d20b      	bcs.n	1b248 <gatt_read_rsp+0xb4>
	if (bt_gatt_read(conn, params) < 0) {
   1b230:	4621      	mov	r1, r4
   1b232:	4630      	mov	r0, r6
   1b234:	f7ff ff36 	bl	1b0a4 <bt_gatt_read>
   1b238:	2800      	cmp	r0, #0
   1b23a:	da34      	bge.n	1b2a6 <gatt_read_rsp+0x112>
		params->func(conn, BT_ATT_ERR_UNLIKELY, params, NULL, 0);
   1b23c:	2300      	movs	r3, #0
   1b23e:	930a      	str	r3, [sp, #40]	; 0x28
   1b240:	6965      	ldr	r5, [r4, #20]
		params->func(conn, BT_ATT_ERR_UNLIKELY, params, NULL, 0);
   1b242:	4622      	mov	r2, r4
   1b244:	210e      	movs	r1, #14
   1b246:	e7b3      	b.n	1b1b0 <gatt_read_rsp+0x1c>
		if (params->by_uuid.start_handle == params->by_uuid.end_handle) {
   1b248:	8ba2      	ldrh	r2, [r4, #28]
   1b24a:	8be0      	ldrh	r0, [r4, #30]
   1b24c:	4290      	cmp	r0, r2
   1b24e:	d105      	bne.n	1b25c <gatt_read_rsp+0xc8>
			params->func(conn, 0, params, NULL, 0);
   1b250:	2300      	movs	r3, #0
   1b252:	930a      	str	r3, [sp, #40]	; 0x28
   1b254:	6965      	ldr	r5, [r4, #20]
		params->func(conn, 0, params, NULL, 0);
   1b256:	4622      	mov	r2, r4
   1b258:	4619      	mov	r1, r3
   1b25a:	e7a9      	b.n	1b1b0 <gatt_read_rsp+0x1c>
		params->by_uuid.start_handle++;
   1b25c:	3201      	adds	r2, #1
	     length -= rsp->len, pdu = (const u8_t *)pdu + rsp->len) {
   1b25e:	1aed      	subs	r5, r5, r3
		params->by_uuid.start_handle++;
   1b260:	83a2      	strh	r2, [r4, #28]
	     length -= rsp->len, pdu = (const u8_t *)pdu + rsp->len) {
   1b262:	b2ad      	uxth	r5, r5
   1b264:	4489      	add	r9, r1
   1b266:	e7b1      	b.n	1b1cc <gatt_read_rsp+0x38>
	if (params->func(conn, 0, params, pdu, length) == BT_GATT_ITER_STOP) {
   1b268:	f8cd 9000 	str.w	r9, [sp]
   1b26c:	4613      	mov	r3, r2
   1b26e:	6965      	ldr	r5, [r4, #20]
   1b270:	4622      	mov	r2, r4
   1b272:	47a8      	blx	r5
   1b274:	b1b8      	cbz	r0, 1b2a6 <gatt_read_rsp+0x112>
	if (length < (bt_att_get_mtu(conn) - 1)) {
   1b276:	4630      	mov	r0, r6
   1b278:	f00f ffc3 	bl	2b202 <bt_att_get_mtu>
   1b27c:	3801      	subs	r0, #1
   1b27e:	4581      	cmp	r9, r0
   1b280:	da03      	bge.n	1b28a <gatt_read_rsp+0xf6>
		params->func(conn, 0, params, NULL, 0);
   1b282:	970a      	str	r7, [sp, #40]	; 0x28
   1b284:	6965      	ldr	r5, [r4, #20]
   1b286:	463b      	mov	r3, r7
   1b288:	e7e5      	b.n	1b256 <gatt_read_rsp+0xc2>
	params->single.offset += length;
   1b28a:	8be3      	ldrh	r3, [r4, #30]
   1b28c:	eb09 0503 	add.w	r5, r9, r3
   1b290:	83e5      	strh	r5, [r4, #30]
	if (bt_gatt_read(conn, params) < 0) {
   1b292:	4621      	mov	r1, r4
   1b294:	4630      	mov	r0, r6
   1b296:	f7ff ff05 	bl	1b0a4 <bt_gatt_read>
   1b29a:	2800      	cmp	r0, #0
   1b29c:	da03      	bge.n	1b2a6 <gatt_read_rsp+0x112>
		params->func(conn, BT_ATT_ERR_UNLIKELY, params, NULL, 0);
   1b29e:	970a      	str	r7, [sp, #40]	; 0x28
   1b2a0:	6965      	ldr	r5, [r4, #20]
   1b2a2:	463b      	mov	r3, r7
   1b2a4:	e7cd      	b.n	1b242 <gatt_read_rsp+0xae>
}
   1b2a6:	b003      	add	sp, #12
   1b2a8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1b2ac:	20010000 	.word	0x20010000
   1b2b0:	0002db28 	.word	0x0002db28
   1b2b4:	0002dbf8 	.word	0x0002dbf8
   1b2b8:	000313cc 	.word	0x000313cc

0001b2bc <bt_gatt_write>:
	if (conn->state != BT_CONN_CONNECTED) {
   1b2bc:	7a83      	ldrb	r3, [r0, #10]
   1b2be:	2b04      	cmp	r3, #4
{
   1b2c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1b2c4:	4606      	mov	r6, r0
   1b2c6:	460c      	mov	r4, r1
	if (conn->state != BT_CONN_CONNECTED) {
   1b2c8:	d161      	bne.n	1b38e <bt_gatt_write+0xd2>
	if (params->offset ||
   1b2ca:	8b4b      	ldrh	r3, [r1, #26]
   1b2cc:	b163      	cbz	r3, 1b2e8 <bt_gatt_write+0x2c>
	len = MIN(params->length, bt_att_get_mtu(conn) - sizeof(*req) - 1);
   1b2ce:	4630      	mov	r0, r6
   1b2d0:	8c25      	ldrh	r5, [r4, #32]
   1b2d2:	f00f ff96 	bl	2b202 <bt_att_get_mtu>
   1b2d6:	3805      	subs	r0, #5
   1b2d8:	4285      	cmp	r5, r0
   1b2da:	d328      	bcc.n	1b32e <bt_gatt_write+0x72>
   1b2dc:	4630      	mov	r0, r6
   1b2de:	f00f ff90 	bl	2b202 <bt_att_get_mtu>
   1b2e2:	3805      	subs	r0, #5
   1b2e4:	b285      	uxth	r5, r0
   1b2e6:	e023      	b.n	1b330 <bt_gatt_write+0x74>
   1b2e8:	8c0d      	ldrh	r5, [r1, #32]
	    params->length > (bt_att_get_mtu(conn) - sizeof(*req) - 1)) {
   1b2ea:	f00f ff8a 	bl	2b202 <bt_att_get_mtu>
   1b2ee:	3803      	subs	r0, #3
	if (params->offset ||
   1b2f0:	42a8      	cmp	r0, r5
   1b2f2:	d3ec      	bcc.n	1b2ce <bt_gatt_write+0x12>
				sizeof(*req) + params->length);
   1b2f4:	8c22      	ldrh	r2, [r4, #32]
	buf = bt_att_create_pdu(conn, BT_ATT_OP_WRITE_REQ,
   1b2f6:	2112      	movs	r1, #18
   1b2f8:	3202      	adds	r2, #2
   1b2fa:	4630      	mov	r0, r6
   1b2fc:	f7fd fed0 	bl	190a0 <bt_att_create_pdu>
	if (!buf) {
   1b300:	4605      	mov	r5, r0
   1b302:	b1e0      	cbz	r0, 1b33e <bt_gatt_write+0x82>
	req = net_buf_add(buf, sizeof(*req));
   1b304:	f100 0708 	add.w	r7, r0, #8
   1b308:	2102      	movs	r1, #2
   1b30a:	4638      	mov	r0, r7
   1b30c:	f011 fc38 	bl	2cb80 <net_buf_simple_add>
	req->handle = sys_cpu_to_le16(params->handle);
   1b310:	8b23      	ldrh	r3, [r4, #24]
   1b312:	f820 3b02 	strh.w	r3, [r0], #2
	memcpy(req->value, params->data, params->length);
   1b316:	8c22      	ldrh	r2, [r4, #32]
   1b318:	69e1      	ldr	r1, [r4, #28]
   1b31a:	f00f f898 	bl	2a44e <memcpy>
	net_buf_add(buf, params->length);
   1b31e:	8c21      	ldrh	r1, [r4, #32]
   1b320:	4638      	mov	r0, r7
   1b322:	f011 fc2d 	bl	2cb80 <net_buf_simple_add>
	return gatt_send(conn, buf, gatt_write_rsp, params, NULL);
   1b326:	4623      	mov	r3, r4
   1b328:	4a1a      	ldr	r2, [pc, #104]	; (1b394 <bt_gatt_write+0xd8>)
   1b32a:	4629      	mov	r1, r5
   1b32c:	e02a      	b.n	1b384 <bt_gatt_write+0xc8>
	len = MIN(params->length, bt_att_get_mtu(conn) - sizeof(*req) - 1);
   1b32e:	8c25      	ldrh	r5, [r4, #32]
	buf = bt_att_create_pdu(conn, BT_ATT_OP_PREPARE_WRITE_REQ,
   1b330:	1d2a      	adds	r2, r5, #4
   1b332:	2116      	movs	r1, #22
   1b334:	4630      	mov	r0, r6
   1b336:	f7fd feb3 	bl	190a0 <bt_att_create_pdu>
	if (!buf) {
   1b33a:	4607      	mov	r7, r0
   1b33c:	b918      	cbnz	r0, 1b346 <bt_gatt_write+0x8a>
		return -ENOMEM;
   1b33e:	f06f 000b 	mvn.w	r0, #11
}
   1b342:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	req = net_buf_add(buf, sizeof(*req));
   1b346:	f100 0808 	add.w	r8, r0, #8
   1b34a:	2104      	movs	r1, #4
   1b34c:	4640      	mov	r0, r8
   1b34e:	f011 fc17 	bl	2cb80 <net_buf_simple_add>
	req->handle = sys_cpu_to_le16(params->handle);
   1b352:	8b23      	ldrh	r3, [r4, #24]
   1b354:	8003      	strh	r3, [r0, #0]
	req->offset = sys_cpu_to_le16(params->offset);
   1b356:	8b63      	ldrh	r3, [r4, #26]
   1b358:	8043      	strh	r3, [r0, #2]
	memcpy(req->value, params->data, len);
   1b35a:	462a      	mov	r2, r5
   1b35c:	69e1      	ldr	r1, [r4, #28]
   1b35e:	3004      	adds	r0, #4
   1b360:	f00f f875 	bl	2a44e <memcpy>
	net_buf_add(buf, len);
   1b364:	4629      	mov	r1, r5
   1b366:	4640      	mov	r0, r8
   1b368:	f011 fc0a 	bl	2cb80 <net_buf_simple_add>
	params->offset += len;
   1b36c:	8b63      	ldrh	r3, [r4, #26]
	params->length -= len;
   1b36e:	8c20      	ldrh	r0, [r4, #32]
	return gatt_send(conn, buf, gatt_prepare_write_rsp, params, NULL);
   1b370:	4a09      	ldr	r2, [pc, #36]	; (1b398 <bt_gatt_write+0xdc>)
	params->offset += len;
   1b372:	442b      	add	r3, r5
   1b374:	8363      	strh	r3, [r4, #26]
	params->data = (const u8_t *)params->data + len;
   1b376:	69e3      	ldr	r3, [r4, #28]
   1b378:	442b      	add	r3, r5
	params->length -= len;
   1b37a:	1b45      	subs	r5, r0, r5
	params->data = (const u8_t *)params->data + len;
   1b37c:	61e3      	str	r3, [r4, #28]
	params->length -= len;
   1b37e:	8425      	strh	r5, [r4, #32]
	return gatt_send(conn, buf, gatt_prepare_write_rsp, params, NULL);
   1b380:	4623      	mov	r3, r4
   1b382:	4639      	mov	r1, r7
	return gatt_send(conn, buf, gatt_write_rsp, params, NULL);
   1b384:	4630      	mov	r0, r6
}
   1b386:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return gatt_send(conn, buf, gatt_write_rsp, params, NULL);
   1b38a:	f7fe bbc1 	b.w	19b10 <gatt_send.constprop.37>
		return -ENOTCONN;
   1b38e:	f06f 0038 	mvn.w	r0, #56	; 0x38
   1b392:	e7d6      	b.n	1b342 <bt_gatt_write+0x86>
   1b394:	0002b325 	.word	0x0002b325
   1b398:	0001b39d 	.word	0x0001b39d

0001b39c <gatt_prepare_write_rsp>:
{
   1b39c:	b570      	push	{r4, r5, r6, lr}
   1b39e:	9c04      	ldr	r4, [sp, #16]
   1b3a0:	4606      	mov	r6, r0
	if (err) {
   1b3a2:	b121      	cbz	r1, 1b3ae <gatt_prepare_write_rsp+0x12>
		params->func(conn, err, params);
   1b3a4:	6963      	ldr	r3, [r4, #20]
   1b3a6:	4622      	mov	r2, r4
}
   1b3a8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		params->func(conn, err, params);
   1b3ac:	4718      	bx	r3
	if (!params->length) {
   1b3ae:	8c23      	ldrh	r3, [r4, #32]
   1b3b0:	b99b      	cbnz	r3, 1b3da <gatt_prepare_write_rsp+0x3e>
	buf = bt_att_create_pdu(conn, BT_ATT_OP_EXEC_WRITE_REQ, sizeof(*req));
   1b3b2:	2201      	movs	r2, #1
   1b3b4:	2118      	movs	r1, #24
   1b3b6:	f7fd fe73 	bl	190a0 <bt_att_create_pdu>
	if (!buf) {
   1b3ba:	4605      	mov	r5, r0
   1b3bc:	b190      	cbz	r0, 1b3e4 <gatt_prepare_write_rsp+0x48>
	req = net_buf_add(buf, sizeof(*req));
   1b3be:	2101      	movs	r1, #1
   1b3c0:	3008      	adds	r0, #8
   1b3c2:	f011 fbdd 	bl	2cb80 <net_buf_simple_add>
	req->flags = BT_ATT_FLAG_EXEC;
   1b3c6:	2301      	movs	r3, #1
   1b3c8:	7003      	strb	r3, [r0, #0]
	return gatt_send(conn, buf, gatt_write_rsp, params, NULL);
   1b3ca:	4629      	mov	r1, r5
   1b3cc:	4623      	mov	r3, r4
   1b3ce:	4630      	mov	r0, r6
   1b3d0:	4a05      	ldr	r2, [pc, #20]	; (1b3e8 <gatt_prepare_write_rsp+0x4c>)
}
   1b3d2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return gatt_send(conn, buf, gatt_write_rsp, params, NULL);
   1b3d6:	f7fe bb9b 	b.w	19b10 <gatt_send.constprop.37>
	bt_gatt_write(conn, params);
   1b3da:	4621      	mov	r1, r4
}
   1b3dc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	bt_gatt_write(conn, params);
   1b3e0:	f7ff bf6c 	b.w	1b2bc <bt_gatt_write>
}
   1b3e4:	bd70      	pop	{r4, r5, r6, pc}
   1b3e6:	bf00      	nop
   1b3e8:	0002b325 	.word	0x0002b325

0001b3ec <bt_gatt_unsubscribe>:
	sys_snode_t *prev = NULL;

	__ASSERT(conn, "invalid parameters\n");
	__ASSERT(params, "invalid parameters\n");

	if (conn->state != BT_CONN_CONNECTED) {
   1b3ec:	7a83      	ldrb	r3, [r0, #10]
   1b3ee:	2b04      	cmp	r3, #4
{
   1b3f0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b3f4:	4680      	mov	r8, r0
   1b3f6:	460e      	mov	r6, r1
	if (conn->state != BT_CONN_CONNECTED) {
   1b3f8:	d15e      	bne.n	1b4b8 <bt_gatt_unsubscribe+0xcc>
		return -ENOTCONN;
	}

	/* Lookup existing subscriptions */
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&subscriptions, tmp, next, node) {
   1b3fa:	4b32      	ldr	r3, [pc, #200]	; (1b4c4 <bt_gatt_unsubscribe+0xd8>)
   1b3fc:	681d      	ldr	r5, [r3, #0]
   1b3fe:	b1dd      	cbz	r5, 1b438 <bt_gatt_unsubscribe+0x4c>
   1b400:	f1b5 042c 	subs.w	r4, r5, #44	; 0x2c
   1b404:	d01a      	beq.n	1b43c <bt_gatt_unsubscribe+0x50>
   1b406:	682d      	ldr	r5, [r5, #0]
   1b408:	b105      	cbz	r5, 1b40c <bt_gatt_unsubscribe+0x20>
   1b40a:	3d2c      	subs	r5, #44	; 0x2c
   1b40c:	2700      	movs	r7, #0
   1b40e:	46ba      	mov	sl, r7
   1b410:	46b9      	mov	r9, r7
		/* Remove subscription */
		if (params == tmp) {
			found = true;
			sys_slist_remove(&subscriptions, prev, &tmp->node);
			/* Attempt to cancel if write is pending */
			if (atomic_test_bit(params->flags,
   1b412:	f106 0b28 	add.w	fp, r6, #40	; 0x28
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&subscriptions, tmp, next, node) {
   1b416:	b99c      	cbnz	r4, 1b440 <bt_gatt_unsubscribe+0x54>
		    tmp->value_handle == params->value_handle) {
			has_subscription = true;
		}
	}

	if (!found) {
   1b418:	f1ba 0f00 	cmp.w	sl, #0
   1b41c:	d04f      	beq.n	1b4be <bt_gatt_unsubscribe+0xd2>
		return -EINVAL;
	}

	if (has_subscription) {
   1b41e:	f1b9 0f00 	cmp.w	r9, #0
   1b422:	d03e      	beq.n	1b4a2 <bt_gatt_unsubscribe+0xb6>
		/* Notify with NULL data to complete unsubscribe */
		params->notify(conn, params, NULL, 0);
   1b424:	69f5      	ldr	r5, [r6, #28]
   1b426:	4623      	mov	r3, r4
   1b428:	4622      	mov	r2, r4
   1b42a:	4631      	mov	r1, r6
   1b42c:	4640      	mov	r0, r8
   1b42e:	47a8      	blx	r5
		return 0;
   1b430:	4620      	mov	r0, r4

	params->value = 0x0000;

	return gatt_write_ccc(conn, params->ccc_handle, params->value,
			      gatt_write_ccc_rsp, params);
}
   1b432:	b003      	add	sp, #12
   1b434:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&subscriptions, tmp, next, node) {
   1b438:	462c      	mov	r4, r5
   1b43a:	e7e7      	b.n	1b40c <bt_gatt_unsubscribe+0x20>
   1b43c:	4625      	mov	r5, r4
   1b43e:	e7e5      	b.n	1b40c <bt_gatt_unsubscribe+0x20>
		if (params == tmp) {
   1b440:	42b4      	cmp	r4, r6
   1b442:	f104 022c 	add.w	r2, r4, #44	; 0x2c
   1b446:	d116      	bne.n	1b476 <bt_gatt_unsubscribe+0x8a>
			sys_slist_remove(&subscriptions, prev, &tmp->node);
   1b448:	4639      	mov	r1, r7
   1b44a:	481e      	ldr	r0, [pc, #120]	; (1b4c4 <bt_gatt_unsubscribe+0xd8>)
   1b44c:	f00f ff32 	bl	2b2b4 <sys_slist_remove>
			if (atomic_test_bit(params->flags,
   1b450:	2101      	movs	r1, #1
   1b452:	4658      	mov	r0, fp
   1b454:	f00f ffc2 	bl	2b3dc <atomic_test_bit>
   1b458:	4682      	mov	sl, r0
   1b45a:	b1e0      	cbz	r0, 1b496 <bt_gatt_unsubscribe+0xaa>

void bt_gatt_cancel(struct bt_conn *conn, void *params)
{
	bt_att_req_cancel(conn, params);
   1b45c:	4631      	mov	r1, r6
   1b45e:	4640      	mov	r0, r8
   1b460:	f7fe fa4e 	bl	19900 <bt_att_req_cancel>
   1b464:	463a      	mov	r2, r7
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&subscriptions, tmp, next, node) {
   1b466:	b1d5      	cbz	r5, 1b49e <bt_gatt_unsubscribe+0xb2>
   1b468:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
   1b46a:	b101      	cbz	r1, 1b46e <bt_gatt_unsubscribe+0x82>
   1b46c:	392c      	subs	r1, #44	; 0x2c
   1b46e:	462c      	mov	r4, r5
   1b470:	4617      	mov	r7, r2
   1b472:	460d      	mov	r5, r1
   1b474:	e7cf      	b.n	1b416 <bt_gatt_unsubscribe+0x2a>
		if (!bt_conn_addr_le_cmp(conn, &tmp->_peer) &&
   1b476:	f104 0114 	add.w	r1, r4, #20
   1b47a:	4640      	mov	r0, r8
   1b47c:	9201      	str	r2, [sp, #4]
   1b47e:	f00f faa4 	bl	2a9ca <bt_conn_addr_le_cmp>
   1b482:	9a01      	ldr	r2, [sp, #4]
   1b484:	2800      	cmp	r0, #0
   1b486:	d1ee      	bne.n	1b466 <bt_gatt_unsubscribe+0x7a>
   1b488:	8c20      	ldrh	r0, [r4, #32]
   1b48a:	8c31      	ldrh	r1, [r6, #32]
			has_subscription = true;
   1b48c:	4288      	cmp	r0, r1
   1b48e:	bf08      	it	eq
   1b490:	f04f 0901 	moveq.w	r9, #1
   1b494:	e7e7      	b.n	1b466 <bt_gatt_unsubscribe+0x7a>
   1b496:	463a      	mov	r2, r7
			found = true;
   1b498:	f04f 0a01 	mov.w	sl, #1
   1b49c:	e7e3      	b.n	1b466 <bt_gatt_unsubscribe+0x7a>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&subscriptions, tmp, next, node) {
   1b49e:	4629      	mov	r1, r5
   1b4a0:	e7e5      	b.n	1b46e <bt_gatt_unsubscribe+0x82>
	return gatt_write_ccc(conn, params->ccc_handle, params->value,
   1b4a2:	8c71      	ldrh	r1, [r6, #34]	; 0x22
	params->value = 0x0000;
   1b4a4:	f8a6 9024 	strh.w	r9, [r6, #36]	; 0x24
	return gatt_write_ccc(conn, params->ccc_handle, params->value,
   1b4a8:	4633      	mov	r3, r6
   1b4aa:	464a      	mov	r2, r9
   1b4ac:	4640      	mov	r0, r8
}
   1b4ae:	b003      	add	sp, #12
   1b4b0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return gatt_write_ccc(conn, params->ccc_handle, params->value,
   1b4b4:	f7fe bcca 	b.w	19e4c <gatt_write_ccc.constprop.27>
		return -ENOTCONN;
   1b4b8:	f06f 0038 	mvn.w	r0, #56	; 0x38
   1b4bc:	e7b9      	b.n	1b432 <bt_gatt_unsubscribe+0x46>
		return -EINVAL;
   1b4be:	f06f 0015 	mvn.w	r0, #21
   1b4c2:	e7b6      	b.n	1b432 <bt_gatt_unsubscribe+0x46>
   1b4c4:	200018c4 	.word	0x200018c4

0001b4c8 <bt_gatt_notification>:
{
   1b4c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1b4cc:	469a      	mov	sl, r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&subscriptions, params, tmp, node) {
   1b4ce:	4b14      	ldr	r3, [pc, #80]	; (1b520 <bt_gatt_notification+0x58>)
   1b4d0:	681b      	ldr	r3, [r3, #0]
{
   1b4d2:	4606      	mov	r6, r0
   1b4d4:	4688      	mov	r8, r1
   1b4d6:	4691      	mov	r9, r2
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&subscriptions, params, tmp, node) {
   1b4d8:	b303      	cbz	r3, 1b51c <bt_gatt_notification+0x54>
   1b4da:	f1b3 052c 	subs.w	r5, r3, #44	; 0x2c
   1b4de:	d01d      	beq.n	1b51c <bt_gatt_notification+0x54>
   1b4e0:	681c      	ldr	r4, [r3, #0]
   1b4e2:	b104      	cbz	r4, 1b4e6 <bt_gatt_notification+0x1e>
   1b4e4:	3c2c      	subs	r4, #44	; 0x2c
		if (bt_conn_addr_le_cmp(conn, &params->_peer) ||
   1b4e6:	f105 0114 	add.w	r1, r5, #20
   1b4ea:	4630      	mov	r0, r6
   1b4ec:	f00f fa6d 	bl	2a9ca <bt_conn_addr_le_cmp>
   1b4f0:	b968      	cbnz	r0, 1b50e <bt_gatt_notification+0x46>
   1b4f2:	8c2b      	ldrh	r3, [r5, #32]
   1b4f4:	4543      	cmp	r3, r8
   1b4f6:	d10a      	bne.n	1b50e <bt_gatt_notification+0x46>
		if (params->notify(conn, params, data, length) ==
   1b4f8:	69ef      	ldr	r7, [r5, #28]
   1b4fa:	4653      	mov	r3, sl
   1b4fc:	464a      	mov	r2, r9
   1b4fe:	4629      	mov	r1, r5
   1b500:	4630      	mov	r0, r6
   1b502:	47b8      	blx	r7
   1b504:	b918      	cbnz	r0, 1b50e <bt_gatt_notification+0x46>
			bt_gatt_unsubscribe(conn, params);
   1b506:	4629      	mov	r1, r5
   1b508:	4630      	mov	r0, r6
   1b50a:	f7ff ff6f 	bl	1b3ec <bt_gatt_unsubscribe>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&subscriptions, params, tmp, node) {
   1b50e:	b12c      	cbz	r4, 1b51c <bt_gatt_notification+0x54>
   1b510:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   1b512:	b103      	cbz	r3, 1b516 <bt_gatt_notification+0x4e>
   1b514:	3b2c      	subs	r3, #44	; 0x2c
{
   1b516:	4625      	mov	r5, r4
   1b518:	461c      	mov	r4, r3
   1b51a:	e7e4      	b.n	1b4e6 <bt_gatt_notification+0x1e>
}
   1b51c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1b520:	200018c4 	.word	0x200018c4

0001b524 <bt_gatt_connected>:
	}
	return 0;
}

void bt_gatt_connected(struct bt_conn *conn)
{
   1b524:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1b526:	4605      	mov	r5, r0
	struct conn_data data;

	BT_DBG("conn %p", conn);

	data.conn = conn;
   1b528:	9000      	str	r0, [sp, #0]
		}

		settings_load_subtree_direct(key, ccc_set_direct, (void *)key);
	}

	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
   1b52a:	466b      	mov	r3, sp
	data.sec = BT_SECURITY_L1;
   1b52c:	2001      	movs	r0, #1
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
   1b52e:	4a0e      	ldr	r2, [pc, #56]	; (1b568 <bt_gatt_connected+0x44>)
	data.sec = BT_SECURITY_L1;
   1b530:	f88d 0004 	strb.w	r0, [sp, #4]
	bt_gatt_foreach_attr(0x0001, 0xffff, update_ccc, &data);
   1b534:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1b538:	f010 f8e9 	bl	2b70e <bt_gatt_foreach_attr>
	SYS_SLIST_FOR_EACH_CONTAINER(&subscriptions, params, node) {
   1b53c:	4b0b      	ldr	r3, [pc, #44]	; (1b56c <bt_gatt_connected+0x48>)
   1b53e:	681c      	ldr	r4, [r3, #0]
   1b540:	b10c      	cbz	r4, 1b546 <bt_gatt_connected+0x22>
   1b542:	3c2c      	subs	r4, #44	; 0x2c
   1b544:	b90c      	cbnz	r4, 1b54a <bt_gatt_connected+0x26>
	}

#if defined(CONFIG_BT_GATT_CLIENT)
	add_subscriptions(conn);
#endif /* CONFIG_BT_GATT_CLIENT */
}
   1b546:	b003      	add	sp, #12
   1b548:	bd30      	pop	{r4, r5, pc}
		if (bt_conn_addr_le_cmp(conn, &params->_peer)) {
   1b54a:	f104 0114 	add.w	r1, r4, #20
   1b54e:	4628      	mov	r0, r5
   1b550:	f00f fa3b 	bl	2a9ca <bt_conn_addr_le_cmp>
   1b554:	b928      	cbnz	r0, 1b562 <bt_gatt_connected+0x3e>
		gatt_write_ccc(conn, params->ccc_handle, params->value,
   1b556:	4623      	mov	r3, r4
   1b558:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
   1b55a:	8c61      	ldrh	r1, [r4, #34]	; 0x22
   1b55c:	4628      	mov	r0, r5
   1b55e:	f7fe fc75 	bl	19e4c <gatt_write_ccc.constprop.27>
   1b562:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
   1b564:	e7ec      	b.n	1b540 <bt_gatt_connected+0x1c>
   1b566:	bf00      	nop
   1b568:	0001a741 	.word	0x0001a741
   1b56c:	200018c4 	.word	0x200018c4

0001b570 <db_hash_read>:
{
   1b570:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1b572:	4604      	mov	r4, r0
	return k_ticks_to_ms_floor64(z_timeout_remaining(&work->timeout));
   1b574:	4814      	ldr	r0, [pc, #80]	; (1b5c8 <db_hash_read+0x58>)
   1b576:	f8bd 5018 	ldrh.w	r5, [sp, #24]
   1b57a:	461f      	mov	r7, r3
   1b57c:	4616      	mov	r6, r2
   1b57e:	f00c f81d 	bl	275bc <z_timeout_remaining>
		}
	} else {
		if (result32) {
			return (u32_t)((t * to_hz + off) / from_hz);
		} else {
			return (t * to_hz + off) / from_hz;
   1b582:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   1b586:	fb80 0103 	smull	r0, r1, r0, r3
   1b58a:	0bc3      	lsrs	r3, r0, #15
	if (k_delayed_work_remaining_get(&db_hash_work)) {
   1b58c:	ea53 4341 	orrs.w	r3, r3, r1, lsl #17
   1b590:	d004      	beq.n	1b59c <db_hash_read+0x2c>
		k_delayed_work_cancel(&db_hash_work);
   1b592:	480e      	ldr	r0, [pc, #56]	; (1b5cc <db_hash_read+0x5c>)
   1b594:	f011 ffe5 	bl	2d562 <k_delayed_work_cancel>
		db_hash_gen(true);
   1b598:	f7fe ff14 	bl	1a3c4 <db_hash_gen.isra.19>
	bt_gatt_change_aware(conn, true);
   1b59c:	2101      	movs	r1, #1
   1b59e:	4620      	mov	r0, r4
   1b5a0:	f010 f954 	bl	2b84c <bt_gatt_change_aware>
	if (offset > value_len) {
   1b5a4:	2d10      	cmp	r5, #16
   1b5a6:	d80c      	bhi.n	1b5c2 <db_hash_read+0x52>
	len = MIN(buf_len, value_len - offset);
   1b5a8:	f1c5 0410 	rsb	r4, r5, #16
   1b5ac:	42bc      	cmp	r4, r7
	memcpy(buf, (u8_t *)value + offset, len);
   1b5ae:	4908      	ldr	r1, [pc, #32]	; (1b5d0 <db_hash_read+0x60>)
	len = MIN(buf_len, value_len - offset);
   1b5b0:	bfa8      	it	ge
   1b5b2:	463c      	movge	r4, r7
	memcpy(buf, (u8_t *)value + offset, len);
   1b5b4:	4622      	mov	r2, r4
   1b5b6:	4429      	add	r1, r5
   1b5b8:	4630      	mov	r0, r6
   1b5ba:	f00e ff48 	bl	2a44e <memcpy>
}
   1b5be:	4620      	mov	r0, r4
   1b5c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   1b5c2:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, db_hash,
   1b5c6:	e7fa      	b.n	1b5be <db_hash_read+0x4e>
   1b5c8:	20001794 	.word	0x20001794
   1b5cc:	20001788 	.word	0x20001788
   1b5d0:	20003e03 	.word	0x20003e03

0001b5d4 <bt_gatt_disconnected>:
	return 0;

}

void bt_gatt_disconnected(struct bt_conn *conn)
{
   1b5d4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	BT_DBG("conn %p", conn);
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
   1b5d8:	4603      	mov	r3, r0
{
   1b5da:	4604      	mov	r4, r0
	bt_gatt_foreach_attr(0x0001, 0xffff, disconnected_cb, conn);
   1b5dc:	4a38      	ldr	r2, [pc, #224]	; (1b6c0 <bt_gatt_disconnected+0xec>)
   1b5de:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1b5e2:	2001      	movs	r0, #1
   1b5e4:	f010 f893 	bl	2b70e <bt_gatt_foreach_attr>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&subscriptions, params, tmp, node) {
   1b5e8:	4b36      	ldr	r3, [pc, #216]	; (1b6c4 <bt_gatt_disconnected+0xf0>)
   1b5ea:	681b      	ldr	r3, [r3, #0]
   1b5ec:	b943      	cbnz	r3, 1b600 <bt_gatt_disconnected+0x2c>
	cfg = find_cf_cfg(conn);
   1b5ee:	4620      	mov	r0, r4
   1b5f0:	f7fe fbe4 	bl	19dbc <find_cf_cfg>
	if (!cfg) {
   1b5f4:	4605      	mov	r5, r0
   1b5f6:	2800      	cmp	r0, #0
   1b5f8:	d13a      	bne.n	1b670 <bt_gatt_disconnected+0x9c>
#endif /* CONFIG_BT_GATT_CLIENT */

#if defined(CONFIG_BT_GATT_CACHING)
	remove_cf_cfg(conn);
#endif
}
   1b5fa:	b003      	add	sp, #12
   1b5fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&subscriptions, params, tmp, node) {
   1b600:	f1b3 052c 	subs.w	r5, r3, #44	; 0x2c
   1b604:	d0f3      	beq.n	1b5ee <bt_gatt_disconnected+0x1a>
   1b606:	681e      	ldr	r6, [r3, #0]
   1b608:	b106      	cbz	r6, 1b60c <bt_gatt_disconnected+0x38>
   1b60a:	3e2c      	subs	r6, #44	; 0x2c
{
   1b60c:	2700      	movs	r7, #0
		if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst) ||
   1b60e:	f104 0870 	add.w	r8, r4, #112	; 0x70
		    (atomic_test_bit(params->flags,
   1b612:	46ba      	mov	sl, r7
		if (bt_conn_addr_le_cmp(conn, &params->_peer)) {
   1b614:	f105 0914 	add.w	r9, r5, #20
   1b618:	4649      	mov	r1, r9
   1b61a:	4620      	mov	r0, r4
   1b61c:	f00f f9d5 	bl	2a9ca <bt_conn_addr_le_cmp>
   1b620:	4683      	mov	fp, r0
   1b622:	b110      	cbz	r0, 1b62a <bt_gatt_disconnected+0x56>
			prev = &params->node;
   1b624:	f105 072c 	add.w	r7, r5, #44	; 0x2c
   1b628:	e00b      	b.n	1b642 <bt_gatt_disconnected+0x6e>
		if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst) ||
   1b62a:	4641      	mov	r1, r8
   1b62c:	7a20      	ldrb	r0, [r4, #8]
   1b62e:	f00f f961 	bl	2a8f4 <bt_addr_le_is_bonded>
   1b632:	b970      	cbnz	r0, 1b652 <bt_gatt_disconnected+0x7e>
			params->value = 0U;
   1b634:	f8a5 a024 	strh.w	sl, [r5, #36]	; 0x24
			gatt_subscription_remove(conn, prev, params);
   1b638:	462a      	mov	r2, r5
   1b63a:	4639      	mov	r1, r7
   1b63c:	4620      	mov	r0, r4
   1b63e:	f7fe f9b9 	bl	199b4 <gatt_subscription_remove>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&subscriptions, params, tmp, node) {
   1b642:	2e00      	cmp	r6, #0
   1b644:	d0d3      	beq.n	1b5ee <bt_gatt_disconnected+0x1a>
   1b646:	6af3      	ldr	r3, [r6, #44]	; 0x2c
   1b648:	b103      	cbz	r3, 1b64c <bt_gatt_disconnected+0x78>
   1b64a:	3b2c      	subs	r3, #44	; 0x2c
{
   1b64c:	4635      	mov	r5, r6
   1b64e:	461e      	mov	r6, r3
   1b650:	e7e0      	b.n	1b614 <bt_gatt_disconnected+0x40>
		    (atomic_test_bit(params->flags,
   1b652:	4659      	mov	r1, fp
   1b654:	f105 0028 	add.w	r0, r5, #40	; 0x28
   1b658:	f00f fec0 	bl	2b3dc <atomic_test_bit>
		if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst) ||
   1b65c:	2800      	cmp	r0, #0
   1b65e:	d1e9      	bne.n	1b634 <bt_gatt_disconnected+0x60>
	if (params->_peer.type == BT_ADDR_LE_PUBLIC) {
   1b660:	7d2b      	ldrb	r3, [r5, #20]
   1b662:	2b00      	cmp	r3, #0
   1b664:	d0de      	beq.n	1b624 <bt_gatt_disconnected+0x50>
	bt_addr_le_copy(&params->_peer, &conn->le.dst);
   1b666:	4641      	mov	r1, r8
   1b668:	4648      	mov	r0, r9
   1b66a:	f00f feb4 	bl	2b3d6 <bt_addr_le_copy>
   1b66e:	e7d9      	b.n	1b624 <bt_gatt_disconnected+0x50>
	if (!bt_addr_le_is_bonded(conn->id, &conn->le.dst)) {
   1b670:	f104 0670 	add.w	r6, r4, #112	; 0x70
   1b674:	7a20      	ldrb	r0, [r4, #8]
   1b676:	4631      	mov	r1, r6
   1b678:	f00f f93c 	bl	2a8f4 <bt_addr_le_is_bonded>
   1b67c:	1c6b      	adds	r3, r5, #1
   1b67e:	4604      	mov	r4, r0
   1b680:	b9c0      	cbnz	r0, 1b6b4 <bt_gatt_disconnected+0xe0>
	bt_addr_le_copy(&cfg->peer, BT_ADDR_LE_ANY);
   1b682:	9000      	str	r0, [sp, #0]
   1b684:	4669      	mov	r1, sp
   1b686:	f8cd 0003 	str.w	r0, [sp, #3]
   1b68a:	4618      	mov	r0, r3
   1b68c:	f00f fea3 	bl	2b3d6 <bt_addr_le_copy>
	memset(cfg->data, 0, sizeof(cfg->data));
   1b690:	f105 0008 	add.w	r0, r5, #8
   1b694:	2201      	movs	r2, #1
   1b696:	4621      	mov	r1, r4
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   1b698:	350c      	adds	r5, #12
   1b69a:	f00e ff02 	bl	2a4a2 <memset>
   1b69e:	f3bf 8f5b 	dmb	ish
   1b6a2:	e855 3f00 	ldrex	r3, [r5]
   1b6a6:	e845 4200 	strex	r2, r4, [r5]
   1b6aa:	2a00      	cmp	r2, #0
   1b6ac:	d1f9      	bne.n	1b6a2 <bt_gatt_disconnected+0xce>
   1b6ae:	f3bf 8f5b 	dmb	ish
   1b6b2:	e7a2      	b.n	1b5fa <bt_gatt_disconnected+0x26>
		bt_addr_le_copy(&cfg->peer, &conn->le.dst);
   1b6b4:	4631      	mov	r1, r6
   1b6b6:	4618      	mov	r0, r3
   1b6b8:	f00f fe8d 	bl	2b3d6 <bt_addr_le_copy>
}
   1b6bc:	e79d      	b.n	1b5fa <bt_gatt_disconnected+0x26>
   1b6be:	bf00      	nop
   1b6c0:	00019a65 	.word	0x00019a65
   1b6c4:	200018c4 	.word	0x200018c4

0001b6c8 <bt_smp_accept>:
	BT_DBG("conn %p handle %u", conn, conn->handle);

	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
		struct bt_l2cap_le_chan *smp = &bt_smp_pool[i];

		if (smp->chan.conn) {
   1b6c8:	4a13      	ldr	r2, [pc, #76]	; (1b718 <bt_smp_accept+0x50>)
{
   1b6ca:	b570      	push	{r4, r5, r6, lr}
	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
   1b6cc:	2400      	movs	r4, #0
   1b6ce:	26ac      	movs	r6, #172	; 0xac
		if (smp->chan.conn) {
   1b6d0:	fb06 f504 	mul.w	r5, r6, r4
   1b6d4:	58ab      	ldr	r3, [r5, r2]
   1b6d6:	b1c3      	cbz	r3, 1b70a <bt_smp_accept+0x42>
	for (i = 0; i < ARRAY_SIZE(bt_smp_pool); i++) {
   1b6d8:	3401      	adds	r4, #1
   1b6da:	2c05      	cmp	r4, #5
   1b6dc:	d1f8      	bne.n	1b6d0 <bt_smp_accept+0x8>
		*chan = &smp->chan;

		return 0;
	}

	BT_ERR("No available SMP context for conn %p", conn);
   1b6de:	4b0f      	ldr	r3, [pc, #60]	; (1b71c <bt_smp_accept+0x54>)
   1b6e0:	681b      	ldr	r3, [r3, #0]
   1b6e2:	075b      	lsls	r3, r3, #29
   1b6e4:	d00e      	beq.n	1b704 <bt_smp_accept+0x3c>
   1b6e6:	2301      	movs	r3, #1
   1b6e8:	f04f 0200 	mov.w	r2, #0
   1b6ec:	f363 0207 	bfi	r2, r3, #0, #8
   1b6f0:	490b      	ldr	r1, [pc, #44]	; (1b720 <bt_smp_accept+0x58>)
   1b6f2:	4b0c      	ldr	r3, [pc, #48]	; (1b724 <bt_smp_accept+0x5c>)
   1b6f4:	1a5b      	subs	r3, r3, r1
   1b6f6:	08db      	lsrs	r3, r3, #3
   1b6f8:	4601      	mov	r1, r0
   1b6fa:	f363 128f 	bfi	r2, r3, #6, #10
   1b6fe:	480a      	ldr	r0, [pc, #40]	; (1b728 <bt_smp_accept+0x60>)
   1b700:	f00d f928 	bl	28954 <log_1>

	return -ENOMEM;
   1b704:	f06f 000b 	mvn.w	r0, #11
   1b708:	e004      	b.n	1b714 <bt_smp_accept+0x4c>
		smp->chan.ops = &ops;
   1b70a:	442a      	add	r2, r5
   1b70c:	4807      	ldr	r0, [pc, #28]	; (1b72c <bt_smp_accept+0x64>)
   1b70e:	6050      	str	r0, [r2, #4]
		*chan = &smp->chan;
   1b710:	600a      	str	r2, [r1, #0]
		return 0;
   1b712:	4618      	mov	r0, r3
}
   1b714:	bd70      	pop	{r4, r5, r6, pc}
   1b716:	bf00      	nop
   1b718:	200018cc 	.word	0x200018cc
   1b71c:	20010010 	.word	0x20010010
   1b720:	0002db28 	.word	0x0002db28
   1b724:	0002dc18 	.word	0x0002dc18
   1b728:	00031454 	.word	0x00031454
   1b72c:	2000fa94 	.word	0x2000fa94

0001b730 <mayfly_init>:
#if defined(MAYFLY_UT)
static u8_t _state;
#endif /* MAYFLY_UT */

void mayfly_init(void)
{
   1b730:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	while (callee_id--) {
		u8_t caller_id;

		caller_id = MAYFLY_CALLER_COUNT;
		while (caller_id--) {
			memq_init(&mfl[callee_id][caller_id],
   1b734:	4f11      	ldr	r7, [pc, #68]	; (1b77c <mayfly_init+0x4c>)
   1b736:	f8df 9048 	ldr.w	r9, [pc, #72]	; 1b780 <mayfly_init+0x50>
	callee_id = MAYFLY_CALLEE_COUNT;
   1b73a:	2604      	movs	r6, #4
	while (callee_id--) {
   1b73c:	3e01      	subs	r6, #1
   1b73e:	b2f6      	uxtb	r6, r6
   1b740:	2eff      	cmp	r6, #255	; 0xff
   1b742:	d019      	beq.n	1b778 <mayfly_init+0x48>
   1b744:	b233      	sxth	r3, r6
   1b746:	ea4f 0883 	mov.w	r8, r3, lsl #2
   1b74a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1b74e:	011d      	lsls	r5, r3, #4
		caller_id = MAYFLY_CALLER_COUNT;
   1b750:	2404      	movs	r4, #4
   1b752:	f04f 0a0c 	mov.w	sl, #12
   1b756:	e00a      	b.n	1b76e <mayfly_init+0x3e>
			memq_init(&mfl[callee_id][caller_id],
   1b758:	fb1a 5104 	smlabb	r1, sl, r4, r5
   1b75c:	1d0a      	adds	r2, r1, #4
   1b75e:	eb04 0008 	add.w	r0, r4, r8
   1b762:	443a      	add	r2, r7
   1b764:	4439      	add	r1, r7
   1b766:	eb09 00c0 	add.w	r0, r9, r0, lsl #3
   1b76a:	f010 f931 	bl	2b9d0 <memq_init>
		while (caller_id--) {
   1b76e:	3c01      	subs	r4, #1
   1b770:	b2e4      	uxtb	r4, r4
   1b772:	2cff      	cmp	r4, #255	; 0xff
   1b774:	d1f0      	bne.n	1b758 <mayfly_init+0x28>
   1b776:	e7e1      	b.n	1b73c <mayfly_init+0xc>
				  &mft[callee_id][caller_id].head,
				  &mft[callee_id][caller_id].tail);
		}
	}
}
   1b778:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1b77c:	20001ca8 	.word	0x20001ca8
   1b780:	20001c28 	.word	0x20001c28

0001b784 <mayfly_enable>:

void mayfly_enable(u8_t caller_id, u8_t callee_id, u8_t enable)
{
   1b784:	b4f0      	push	{r4, r5, r6, r7}
   1b786:	2430      	movs	r4, #48	; 0x30
   1b788:	4b10      	ldr	r3, [pc, #64]	; (1b7cc <mayfly_enable+0x48>)
   1b78a:	270c      	movs	r7, #12
	if (enable) {
		if (mft[callee_id][caller_id].enable_req ==
   1b78c:	434c      	muls	r4, r1
   1b78e:	fb07 4400 	mla	r4, r7, r0, r4
{
   1b792:	4605      	mov	r5, r0
   1b794:	460e      	mov	r6, r1
		if (mft[callee_id][caller_id].enable_req ==
   1b796:	4423      	add	r3, r4
	if (enable) {
   1b798:	b152      	cbz	r2, 1b7b0 <mayfly_enable+0x2c>
		if (mft[callee_id][caller_id].enable_req ==
   1b79a:	7a59      	ldrb	r1, [r3, #9]
   1b79c:	7a18      	ldrb	r0, [r3, #8]
   1b79e:	4281      	cmp	r1, r0
		    mft[callee_id][caller_id].enable_ack) {
			mft[callee_id][caller_id].enable_req++;
   1b7a0:	bf04      	itt	eq
   1b7a2:	3101      	addeq	r1, #1
   1b7a4:	7219      	strbeq	r1, [r3, #8]
		}

		mayfly_enable_cb(caller_id, callee_id, enable);
   1b7a6:	4628      	mov	r0, r5
   1b7a8:	4631      	mov	r1, r6

			/* pend the callee for execution */
			mayfly_pend(caller_id, callee_id);
		}
	}
}
   1b7aa:	bcf0      	pop	{r4, r5, r6, r7}
		mayfly_enable_cb(caller_id, callee_id, enable);
   1b7ac:	f009 bc30 	b.w	25010 <mayfly_enable_cb>
		if (mft[callee_id][caller_id].disable_req ==
   1b7b0:	7a9c      	ldrb	r4, [r3, #10]
   1b7b2:	7ada      	ldrb	r2, [r3, #11]
   1b7b4:	42a2      	cmp	r2, r4
   1b7b6:	d107      	bne.n	1b7c8 <mayfly_enable+0x44>
			mft[callee_id][caller_id].disable_req++;
   1b7b8:	3201      	adds	r2, #1
   1b7ba:	729a      	strb	r2, [r3, #10]
			mfp[callee_id] = 1U;
   1b7bc:	4b04      	ldr	r3, [pc, #16]	; (1b7d0 <mayfly_enable+0x4c>)
   1b7be:	2201      	movs	r2, #1
   1b7c0:	545a      	strb	r2, [r3, r1]
}
   1b7c2:	bcf0      	pop	{r4, r5, r6, r7}
			mayfly_pend(caller_id, callee_id);
   1b7c4:	f009 bc58 	b.w	25078 <mayfly_pend>
}
   1b7c8:	bcf0      	pop	{r4, r5, r6, r7}
   1b7ca:	4770      	bx	lr
   1b7cc:	20001ca8 	.word	0x20001ca8
   1b7d0:	20003e13 	.word	0x20003e13

0001b7d4 <mayfly_enqueue>:

u32_t mayfly_enqueue(u8_t caller_id, u8_t callee_id, u8_t chain,
			struct mayfly *m)
{
   1b7d4:	b570      	push	{r4, r5, r6, lr}
   1b7d6:	4606      	mov	r6, r0
   1b7d8:	460d      	mov	r5, r1
   1b7da:	461c      	mov	r4, r3
	u8_t state;
	u8_t ack;

	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
		!mayfly_is_enabled(caller_id, callee_id) ||
   1b7dc:	b1a2      	cbz	r2, 1b808 <mayfly_enqueue+0x34>
   1b7de:	2301      	movs	r3, #1
		(mft[callee_id][caller_id].disable_req !=
		 mft[callee_id][caller_id].disable_ack);

	/* shadow the ack */
	ack = m->_ack;
   1b7e0:	7862      	ldrb	r2, [r4, #1]

	/* already in queue */
	state = (m->_req - ack) & 0x03;
   1b7e2:	7820      	ldrb	r0, [r4, #0]
   1b7e4:	1a80      	subs	r0, r0, r2
	if (state != 0U) {
   1b7e6:	f010 0003 	ands.w	r0, r0, #3
   1b7ea:	d02c      	beq.n	1b846 <mayfly_enqueue+0x72>
		if (chain) {
   1b7ec:	b31b      	cbz	r3, 1b836 <mayfly_enqueue+0x62>
			if (state != 1U) {
   1b7ee:	2801      	cmp	r0, #1
   1b7f0:	d028      	beq.n	1b844 <mayfly_enqueue+0x70>
				/* mark as ready in queue */
				m->_req = ack + 1;
   1b7f2:	3201      	adds	r2, #1
   1b7f4:	b2d2      	uxtb	r2, r2
   1b7f6:	7022      	strb	r2, [r4, #0]
	m->_req = ack + 1;
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);

mayfly_enqueue_pend:
	/* set mayfly callee pending */
	mfp[callee_id] = 1U;
   1b7f8:	4b1c      	ldr	r3, [pc, #112]	; (1b86c <mayfly_enqueue+0x98>)
   1b7fa:	2201      	movs	r2, #1

	/* pend the callee for execution */
	mayfly_pend(caller_id, callee_id);
   1b7fc:	4629      	mov	r1, r5
   1b7fe:	4630      	mov	r0, r6
	mfp[callee_id] = 1U;
   1b800:	555a      	strb	r2, [r3, r5]
	mayfly_pend(caller_id, callee_id);
   1b802:	f009 fc39 	bl	25078 <mayfly_pend>
   1b806:	e01c      	b.n	1b842 <mayfly_enqueue+0x6e>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
   1b808:	f011 f964 	bl	2cad4 <mayfly_prio_is_equal>
   1b80c:	2800      	cmp	r0, #0
   1b80e:	d0e6      	beq.n	1b7de <mayfly_enqueue+0xa>
		!mayfly_is_enabled(caller_id, callee_id) ||
   1b810:	4629      	mov	r1, r5
   1b812:	4630      	mov	r0, r6
   1b814:	f009 fc16 	bl	25044 <mayfly_is_enabled>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
   1b818:	2800      	cmp	r0, #0
   1b81a:	d0e0      	beq.n	1b7de <mayfly_enqueue+0xa>
		(mft[callee_id][caller_id].disable_req !=
   1b81c:	2330      	movs	r3, #48	; 0x30
   1b81e:	220c      	movs	r2, #12
   1b820:	436b      	muls	r3, r5
   1b822:	fb02 3306 	mla	r3, r2, r6, r3
   1b826:	4a12      	ldr	r2, [pc, #72]	; (1b870 <mayfly_enqueue+0x9c>)
   1b828:	441a      	add	r2, r3
		!mayfly_is_enabled(caller_id, callee_id) ||
   1b82a:	7a93      	ldrb	r3, [r2, #10]
   1b82c:	7ad2      	ldrb	r2, [r2, #11]
   1b82e:	1a9b      	subs	r3, r3, r2
   1b830:	bf18      	it	ne
   1b832:	2301      	movne	r3, #1
   1b834:	e7d4      	b.n	1b7e0 <mayfly_enqueue+0xc>
		m->_req = ack + 2;
   1b836:	3202      	adds	r2, #2
   1b838:	b2d2      	uxtb	r2, r2
   1b83a:	7022      	strb	r2, [r4, #0]
		m->fp(m->param);
   1b83c:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
   1b840:	4798      	blx	r3

	return 0;
   1b842:	2000      	movs	r0, #0
}
   1b844:	bd70      	pop	{r4, r5, r6, pc}
	if (!chain) {
   1b846:	2b00      	cmp	r3, #0
   1b848:	d0f8      	beq.n	1b83c <mayfly_enqueue+0x68>
	m->_req = ack + 1;
   1b84a:	3201      	adds	r2, #1
   1b84c:	b2d2      	uxtb	r2, r2
   1b84e:	7022      	strb	r2, [r4, #0]
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
   1b850:	2304      	movs	r3, #4
   1b852:	2230      	movs	r2, #48	; 0x30
   1b854:	fb12 3205 	smlabb	r2, r2, r5, r3
   1b858:	230c      	movs	r3, #12
   1b85a:	fb13 2306 	smlabb	r3, r3, r6, r2
   1b85e:	4a04      	ldr	r2, [pc, #16]	; (1b870 <mayfly_enqueue+0x9c>)
   1b860:	6860      	ldr	r0, [r4, #4]
   1b862:	441a      	add	r2, r3
   1b864:	4621      	mov	r1, r4
   1b866:	f010 f8c1 	bl	2b9ec <memq_enqueue>
   1b86a:	e7c5      	b.n	1b7f8 <mayfly_enqueue+0x24>
   1b86c:	20003e13 	.word	0x20003e13
   1b870:	20001ca8 	.word	0x20001ca8

0001b874 <mayfly_run>:
		}
	}
}

void mayfly_run(u8_t callee_id)
{
   1b874:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u8_t disable = 0U;
	u8_t enable = 0U;
	u8_t caller_id;

	if (!mfp[callee_id]) {
   1b878:	4b57      	ldr	r3, [pc, #348]	; (1b9d8 <mayfly_run+0x164>)
   1b87a:	5c1a      	ldrb	r2, [r3, r0]
{
   1b87c:	b089      	sub	sp, #36	; 0x24
   1b87e:	4605      	mov	r5, r0
	if (!mfp[callee_id]) {
   1b880:	2a00      	cmp	r2, #0
   1b882:	f000 80a2 	beq.w	1b9ca <mayfly_run+0x156>
		return;
	}
	mfp[callee_id] = 0U;
   1b886:	2600      	movs	r6, #0
   1b888:	541e      	strb	r6, [r3, r0]

	/* iterate through each caller queue to this callee_id */
	caller_id = MAYFLY_CALLER_COUNT;
	while (caller_id--) {
   1b88a:	eb00 0340 	add.w	r3, r0, r0, lsl #1
   1b88e:	011b      	lsls	r3, r3, #4
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
   1b890:	f8df b148 	ldr.w	fp, [pc, #328]	; 1b9dc <mayfly_run+0x168>
   1b894:	9304      	str	r3, [sp, #16]
   1b896:	2404      	movs	r4, #4
   1b898:	233c      	movs	r3, #60	; 0x3c
   1b89a:	fb13 4300 	smlabb	r3, r3, r0, r4
   1b89e:	445b      	add	r3, fp
   1b8a0:	9303      	str	r3, [sp, #12]
	u8_t disable = 0U;
   1b8a2:	9600      	str	r6, [sp, #0]
   1b8a4:	46d9      	mov	r9, fp
	while (caller_id--) {
   1b8a6:	3c01      	subs	r4, #1
   1b8a8:	b2e4      	uxtb	r4, r4
   1b8aa:	2cff      	cmp	r4, #255	; 0xff
   1b8ac:	d10c      	bne.n	1b8c8 <mayfly_run+0x54>
			mft[callee_id][caller_id].enable_ack =
				mft[callee_id][caller_id].enable_req;
		}
	}

	if (disable && !enable) {
   1b8ae:	9b00      	ldr	r3, [sp, #0]
   1b8b0:	2b00      	cmp	r3, #0
   1b8b2:	f000 808a 	beq.w	1b9ca <mayfly_run+0x156>
   1b8b6:	2e00      	cmp	r6, #0
   1b8b8:	f040 8087 	bne.w	1b9ca <mayfly_run+0x156>
		mayfly_enable_cb(callee_id, callee_id, 0);
   1b8bc:	4632      	mov	r2, r6
   1b8be:	4629      	mov	r1, r5
   1b8c0:	4628      	mov	r0, r5
   1b8c2:	f009 fba5 	bl	25010 <mayfly_enable_cb>
   1b8c6:	e080      	b.n	1b9ca <mayfly_run+0x156>
		struct mayfly *m = 0;
   1b8c8:	2300      	movs	r3, #0
		link = memq_peek(mft[callee_id][caller_id].head,
   1b8ca:	270c      	movs	r7, #12
		struct mayfly *m = 0;
   1b8cc:	9307      	str	r3, [sp, #28]
		link = memq_peek(mft[callee_id][caller_id].head,
   1b8ce:	4367      	muls	r7, r4
   1b8d0:	2330      	movs	r3, #48	; 0x30
   1b8d2:	fb03 7305 	mla	r3, r3, r5, r7
   1b8d6:	eb09 0103 	add.w	r1, r9, r3
   1b8da:	aa07      	add	r2, sp, #28
   1b8dc:	f859 0003 	ldr.w	r0, [r9, r3]
   1b8e0:	6849      	ldr	r1, [r1, #4]
   1b8e2:	f010 f88a 	bl	2b9fa <memq_peek>
		memq_dequeue(mft[callee_id][caller_id].tail,
   1b8e6:	9a04      	ldr	r2, [sp, #16]
   1b8e8:	eb04 0344 	add.w	r3, r4, r4, lsl #1
   1b8ec:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   1b8f0:	444b      	add	r3, r9
   1b8f2:	e9cd 7301 	strd	r7, r3, [sp, #4]
		link = memq_peek(mft[callee_id][caller_id].head,
   1b8f6:	4682      	mov	sl, r0
		while (link) {
   1b8f8:	f1ba 0f00 	cmp.w	sl, #0
   1b8fc:	d047      	beq.n	1b98e <mayfly_run+0x11a>
			state = (m->_req - m->_ack) & 0x03;
   1b8fe:	9b07      	ldr	r3, [sp, #28]
   1b900:	f893 8000 	ldrb.w	r8, [r3]
   1b904:	785a      	ldrb	r2, [r3, #1]
   1b906:	eba8 0802 	sub.w	r8, r8, r2
   1b90a:	f008 0803 	and.w	r8, r8, #3
			if (state == 1U) {
   1b90e:	f1b8 0f01 	cmp.w	r8, #1
   1b912:	d104      	bne.n	1b91e <mayfly_run+0xaa>
				m->_ack--;
   1b914:	3a01      	subs	r2, #1
   1b916:	705a      	strb	r2, [r3, #1]
				m->fp(m->param);
   1b918:	e9d3 0202 	ldrd	r0, r2, [r3, #8]
   1b91c:	4790      	blx	r2
			dequeue(callee_id, caller_id, link, m);
   1b91e:	9f07      	ldr	r7, [sp, #28]
	req = m->_req;
   1b920:	783b      	ldrb	r3, [r7, #0]
	if (((req - m->_ack) & 0x03) != 1U) {
   1b922:	787a      	ldrb	r2, [r7, #1]
	req = m->_req;
   1b924:	b2db      	uxtb	r3, r3
	if (((req - m->_ack) & 0x03) != 1U) {
   1b926:	1a9a      	subs	r2, r3, r2
   1b928:	f002 0203 	and.w	r2, r2, #3
   1b92c:	2a01      	cmp	r2, #1
   1b92e:	9305      	str	r3, [sp, #20]
   1b930:	d01b      	beq.n	1b96a <mayfly_run+0xf6>
		memq_dequeue(mft[callee_id][caller_id].tail,
   1b932:	9b01      	ldr	r3, [sp, #4]
   1b934:	9902      	ldr	r1, [sp, #8]
   1b936:	2030      	movs	r0, #48	; 0x30
   1b938:	fb00 3005 	mla	r0, r0, r5, r3
   1b93c:	4b27      	ldr	r3, [pc, #156]	; (1b9dc <mayfly_run+0x168>)
   1b93e:	4418      	add	r0, r3
   1b940:	2200      	movs	r2, #0
   1b942:	6840      	ldr	r0, [r0, #4]
   1b944:	f010 f861 	bl	2ba0a <memq_dequeue>
		m->_ack = req;
   1b948:	9b05      	ldr	r3, [sp, #20]
		ack = m->_ack;
   1b94a:	787a      	ldrb	r2, [r7, #1]
		m->_ack = req;
   1b94c:	707b      	strb	r3, [r7, #1]
		if (((m->_req - ack) & 0x03) == 1U) {
   1b94e:	783b      	ldrb	r3, [r7, #0]
		m->_link = link;
   1b950:	f8c7 a004 	str.w	sl, [r7, #4]
		if (((m->_req - ack) & 0x03) == 1U) {
   1b954:	1a9b      	subs	r3, r3, r2
   1b956:	f003 0303 	and.w	r3, r3, #3
   1b95a:	2b01      	cmp	r3, #1
   1b95c:	d105      	bne.n	1b96a <mayfly_run+0xf6>
			m->_ack = ack;
   1b95e:	707a      	strb	r2, [r7, #1]
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
   1b960:	4639      	mov	r1, r7
   1b962:	9a03      	ldr	r2, [sp, #12]
   1b964:	4650      	mov	r0, sl
   1b966:	f010 f841 	bl	2b9ec <memq_enqueue>
			link = memq_peek(mft[callee_id][caller_id].head,
   1b96a:	9a01      	ldr	r2, [sp, #4]
   1b96c:	2330      	movs	r3, #48	; 0x30
   1b96e:	fb03 2305 	mla	r3, r3, r5, r2
   1b972:	eb09 0103 	add.w	r1, r9, r3
   1b976:	aa07      	add	r2, sp, #28
   1b978:	6849      	ldr	r1, [r1, #4]
   1b97a:	f859 0003 	ldr.w	r0, [r9, r3]
   1b97e:	f010 f83c 	bl	2b9fa <memq_peek>
			if (state == 1U) {
   1b982:	f1b8 0f01 	cmp.w	r8, #1
			link = memq_peek(mft[callee_id][caller_id].head,
   1b986:	4682      	mov	sl, r0
			if (state == 1U) {
   1b988:	d1b6      	bne.n	1b8f8 <mayfly_run+0x84>
				if (caller_id || link) {
   1b98a:	b9bc      	cbnz	r4, 1b9bc <mayfly_run+0x148>
   1b98c:	b9b0      	cbnz	r0, 1b9bc <mayfly_run+0x148>
		if (mft[callee_id][caller_id].disable_req !=
   1b98e:	2230      	movs	r2, #48	; 0x30
   1b990:	4912      	ldr	r1, [pc, #72]	; (1b9dc <mayfly_run+0x168>)
   1b992:	230c      	movs	r3, #12
   1b994:	436a      	muls	r2, r5
   1b996:	fb03 2204 	mla	r2, r3, r4, r2
   1b99a:	440a      	add	r2, r1
   1b99c:	7a91      	ldrb	r1, [r2, #10]
   1b99e:	7ad0      	ldrb	r0, [r2, #11]
   1b9a0:	4288      	cmp	r0, r1
   1b9a2:	d115      	bne.n	1b9d0 <mayfly_run+0x15c>
		if (mft[callee_id][caller_id].enable_req !=
   1b9a4:	2230      	movs	r2, #48	; 0x30
   1b9a6:	436a      	muls	r2, r5
   1b9a8:	fb03 2304 	mla	r3, r3, r4, r2
   1b9ac:	445b      	add	r3, fp
   1b9ae:	7a1a      	ldrb	r2, [r3, #8]
   1b9b0:	7a59      	ldrb	r1, [r3, #9]
   1b9b2:	4291      	cmp	r1, r2
			mft[callee_id][caller_id].enable_ack =
   1b9b4:	bf1c      	itt	ne
   1b9b6:	725a      	strbne	r2, [r3, #9]
			enable = 1U;
   1b9b8:	2601      	movne	r6, #1
   1b9ba:	e774      	b.n	1b8a6 <mayfly_run+0x32>
					mfp[callee_id] = 1U;
   1b9bc:	4b06      	ldr	r3, [pc, #24]	; (1b9d8 <mayfly_run+0x164>)
   1b9be:	2201      	movs	r2, #1
					mayfly_pend(callee_id, callee_id);
   1b9c0:	4629      	mov	r1, r5
   1b9c2:	4628      	mov	r0, r5
					mfp[callee_id] = 1U;
   1b9c4:	555a      	strb	r2, [r3, r5]
					mayfly_pend(callee_id, callee_id);
   1b9c6:	f009 fb57 	bl	25078 <mayfly_pend>
	}
}
   1b9ca:	b009      	add	sp, #36	; 0x24
   1b9cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mft[callee_id][caller_id].disable_ack =
   1b9d0:	72d1      	strb	r1, [r2, #11]
			disable = 1U;
   1b9d2:	2201      	movs	r2, #1
   1b9d4:	9200      	str	r2, [sp, #0]
   1b9d6:	e7e5      	b.n	1b9a4 <mayfly_run+0x130>
   1b9d8:	20003e13 	.word	0x20003e13
   1b9dc:	20001ca8 	.word	0x20001ca8

0001b9e0 <ticker_job>:
 * @param param Pointer to ticker instance
 *
 * @internal
 */
void ticker_job(void *param)
{
   1b9e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u8_t flag_compare_update;

	DEBUG_TICKER_JOB(1);

	/* Defer worker, as job is now running */
	if (instance->worker_trigger) {
   1b9e4:	7fc2      	ldrb	r2, [r0, #31]
{
   1b9e6:	b08f      	sub	sp, #60	; 0x3c
   1b9e8:	4604      	mov	r4, r0
	if (instance->worker_trigger) {
   1b9ea:	2a00      	cmp	r2, #0
   1b9ec:	f040 8305 	bne.w	1bffa <ticker_job+0x61a>
		return;
	}
	instance->job_guard = 1U;

	/* Back up the previous known tick */
	ticks_previous = instance->ticks_current;
   1b9f0:	6943      	ldr	r3, [r0, #20]
   1b9f2:	9304      	str	r3, [sp, #16]
	instance->job_guard = 1U;
   1b9f4:	2101      	movs	r1, #1

	/* Update current tick with the elapsed value from queue, and dequeue */
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
   1b9f6:	7a83      	ldrb	r3, [r0, #10]
	instance->job_guard = 1U;
   1b9f8:	7781      	strb	r1, [r0, #30]
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
   1b9fa:	7ac0      	ldrb	r0, [r0, #11]
   1b9fc:	4298      	cmp	r0, r3
   1b9fe:	d077      	beq.n	1baf0 <ticker_job+0x110>
	u8_t idx = *ticks_elapsed_index + 1;
   1ba00:	440b      	add	r3, r1
   1ba02:	b2db      	uxtb	r3, r3
		idx = 0U;
   1ba04:	2b02      	cmp	r3, #2
   1ba06:	bf08      	it	eq
   1ba08:	2300      	moveq	r3, #0
	*ticks_elapsed_index = idx;
   1ba0a:	72a3      	strb	r3, [r4, #10]
		ticker_next_elapsed(&instance->ticks_elapsed_first);

		ticks_elapsed =
   1ba0c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
		    instance->ticks_elapsed[instance->ticks_elapsed_first];

		instance->ticks_current += ticks_elapsed;
		instance->ticks_current &= HAL_TICKER_CNTR_MASK;

		flag_elapsed = 1U;
   1ba10:	9101      	str	r1, [sp, #4]
		ticks_elapsed =
   1ba12:	f8d3 a00c 	ldr.w	sl, [r3, #12]
		instance->ticks_current += ticks_elapsed;
   1ba16:	9b04      	ldr	r3, [sp, #16]
   1ba18:	4453      	add	r3, sl
		instance->ticks_current &= HAL_TICKER_CNTR_MASK;
   1ba1a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   1ba1e:	6163      	str	r3, [r4, #20]
	flag_compare_update = 0U;

	/* Remember the old head, so as to decide if new compare needs to be
	 * set.
	 */
	ticker_id_old_head = instance->ticker_id_head;
   1ba20:	7f63      	ldrb	r3, [r4, #29]
   1ba22:	9303      	str	r3, [sp, #12]
	node = &instance->nodes[0];
   1ba24:	6823      	ldr	r3, [r4, #0]
   1ba26:	9305      	str	r3, [sp, #20]
	users = &instance->users[0];
   1ba28:	6863      	ldr	r3, [r4, #4]
   1ba2a:	930c      	str	r3, [sp, #48]	; 0x30
	count_user = instance->count_user;
   1ba2c:	7a63      	ldrb	r3, [r4, #9]
   1ba2e:	9302      	str	r3, [sp, #8]
	pending = 0U;
   1ba30:	2300      	movs	r3, #0
   1ba32:	9308      	str	r3, [sp, #32]
	insert_head = TICKER_NULL;
   1ba34:	f04f 0bff 	mov.w	fp, #255	; 0xff
	while (count_user--) {
   1ba38:	9b02      	ldr	r3, [sp, #8]
   1ba3a:	3b01      	subs	r3, #1
   1ba3c:	b2db      	uxtb	r3, r3
   1ba3e:	2bff      	cmp	r3, #255	; 0xff
   1ba40:	9302      	str	r3, [sp, #8]
   1ba42:	d158      	bne.n	1baf6 <ticker_job+0x116>

	/* Manage user operations (updates and deletions) in ticker list */
	pending = ticker_job_list_manage(instance, ticks_elapsed, &insert_head);

	/* Detect change in head of the list */
	if (instance->ticker_id_head != ticker_id_old_head) {
   1ba44:	7f63      	ldrb	r3, [r4, #29]
		flag_compare_update = 1U;
   1ba46:	9a03      	ldr	r2, [sp, #12]
   1ba48:	1a9b      	subs	r3, r3, r2
   1ba4a:	bf18      	it	ne
   1ba4c:	2301      	movne	r3, #1
   1ba4e:	9302      	str	r3, [sp, #8]
	}

	/* Handle expired tickers */
	if (flag_elapsed) {
   1ba50:	9b01      	ldr	r3, [sp, #4]
   1ba52:	b1cb      	cbz	r3, 1ba88 <ticker_job+0xa8>
   1ba54:	f8d4 9000 	ldr.w	r9, [r4]
	ticks_expired = 0U;
   1ba58:	f04f 0800 	mov.w	r8, #0
	while (instance->ticker_id_head != TICKER_NULL) {
   1ba5c:	7f66      	ldrb	r6, [r4, #29]
   1ba5e:	2eff      	cmp	r6, #255	; 0xff
   1ba60:	d00b      	beq.n	1ba7a <ticker_job+0x9a>
		ticker = &node[id_expired];
   1ba62:	272c      	movs	r7, #44	; 0x2c
   1ba64:	fb16 f707 	smulbb	r7, r6, r7
   1ba68:	eb09 0507 	add.w	r5, r9, r7
		ticks_to_expire = ticker->ticks_to_expire;
   1ba6c:	68aa      	ldr	r2, [r5, #8]
		if (ticks_elapsed < ticks_to_expire) {
   1ba6e:	4552      	cmp	r2, sl
   1ba70:	f240 8105 	bls.w	1bc7e <ticker_job+0x29e>
			ticker->ticks_to_expire -= ticks_elapsed;
   1ba74:	eba2 020a 	sub.w	r2, r2, sl
   1ba78:	60aa      	str	r2, [r5, #8]
		ticker_job_worker_bh(instance, ticks_previous, ticks_elapsed,
				     &insert_head);

		/* detect change in head of the list */
		if (instance->ticker_id_head != ticker_id_old_head) {
			flag_compare_update = 1U;
   1ba7a:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
   1ba7e:	9903      	ldr	r1, [sp, #12]
   1ba80:	42b1      	cmp	r1, r6
   1ba82:	bf18      	it	ne
   1ba84:	4613      	movne	r3, r2
   1ba86:	9302      	str	r3, [sp, #8]
	node = &instance->nodes[0];
   1ba88:	6823      	ldr	r3, [r4, #0]
   1ba8a:	9305      	str	r3, [sp, #20]
	users = &instance->users[0];
   1ba8c:	6863      	ldr	r3, [r4, #4]
   1ba8e:	930b      	str	r3, [sp, #44]	; 0x2c
	count_user = instance->count_user;
   1ba90:	7a63      	ldrb	r3, [r4, #9]
   1ba92:	9301      	str	r3, [sp, #4]
				ticker = &node[id_insert];
   1ba94:	f04f 092c 	mov.w	r9, #44	; 0x2c
	while (count_user--) {
   1ba98:	9b01      	ldr	r3, [sp, #4]
   1ba9a:	3b01      	subs	r3, #1
   1ba9c:	b2db      	uxtb	r3, r3
   1ba9e:	2bff      	cmp	r3, #255	; 0xff
   1baa0:	9301      	str	r3, [sp, #4]
   1baa2:	f040 8137 	bne.w	1bd14 <ticker_job+0x334>
	/* Handle insertions */
	ticker_job_list_insert(instance, insert_head);

	/* detect change in head of the list */
	if (instance->ticker_id_head != ticker_id_old_head) {
		flag_compare_update = 1U;
   1baa6:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
	if (instance->ticker_id_head != ticker_id_old_head) {
   1baaa:	7f63      	ldrb	r3, [r4, #29]
		flag_compare_update = 1U;
   1baac:	428b      	cmp	r3, r1
   1baae:	bf18      	it	ne
   1bab0:	2201      	movne	r2, #1
	}

	/* Process any list inquiries */
	if (!pending) {
   1bab2:	9b08      	ldr	r3, [sp, #32]
		flag_compare_update = 1U;
   1bab4:	9202      	str	r2, [sp, #8]
	if (!pending) {
   1bab6:	2b00      	cmp	r3, #0
   1bab8:	f000 81d7 	beq.w	1be6a <ticker_job+0x48a>
		/* Handle inquiries */
		ticker_job_list_inquire(instance);
	}

	/* Permit worker job to run */
	instance->job_guard = 0U;
   1babc:	2300      	movs	r3, #0
   1babe:	77a3      	strb	r3, [r4, #30]

	/* update compare if head changed */
	if (flag_compare_update) {
   1bac0:	9b02      	ldr	r3, [sp, #8]
   1bac2:	b13b      	cbz	r3, 1bad4 <ticker_job+0xf4>
	if (instance->ticker_id_head == TICKER_NULL) {
   1bac4:	7f63      	ldrb	r3, [r4, #29]
   1bac6:	2bff      	cmp	r3, #255	; 0xff
   1bac8:	f040 823c 	bne.w	1bf44 <ticker_job+0x564>
		if (cntr_stop() == 0) {
   1bacc:	f008 fd56 	bl	2457c <cntr_stop>
   1bad0:	b900      	cbnz	r0, 1bad4 <ticker_job+0xf4>
			instance->ticks_slot_previous = 0U;
   1bad2:	61a0      	str	r0, [r4, #24]
		ticker_job_compare_update(instance, ticker_id_old_head);
	}

	/* trigger worker if deferred */
	if (instance->worker_trigger) {
   1bad4:	7fe3      	ldrb	r3, [r4, #31]
   1bad6:	2b00      	cmp	r3, #0
   1bad8:	f000 828f 	beq.w	1bffa <ticker_job+0x61a>
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
   1badc:	6a65      	ldr	r5, [r4, #36]	; 0x24
   1bade:	4623      	mov	r3, r4
   1bae0:	2201      	movs	r2, #1
   1bae2:	2103      	movs	r1, #3
   1bae4:	2004      	movs	r0, #4
   1bae6:	46ac      	mov	ip, r5
				   instance);
	}

	DEBUG_TICKER_JOB(0);
}
   1bae8:	b00f      	add	sp, #60	; 0x3c
   1baea:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
   1baee:	4760      	bx	ip
		flag_elapsed = 0U;
   1baf0:	9201      	str	r2, [sp, #4]
		ticks_elapsed = 0U;
   1baf2:	4692      	mov	sl, r2
   1baf4:	e794      	b.n	1ba20 <ticker_job+0x40>
		user = &users[count_user];
   1baf6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1baf8:	9a02      	ldr	r2, [sp, #8]
   1bafa:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
		user_ops = &user->user_op[0];
   1bafe:	687b      	ldr	r3, [r7, #4]
   1bb00:	9306      	str	r3, [sp, #24]
		while (user->middle != user->last) {
   1bb02:	78f9      	ldrb	r1, [r7, #3]
   1bb04:	f897 8002 	ldrb.w	r8, [r7, #2]
   1bb08:	4588      	cmp	r8, r1
   1bb0a:	d095      	beq.n	1ba38 <ticker_job+0x58>
			user_op = &user_ops[user->middle];
   1bb0c:	9b06      	ldr	r3, [sp, #24]
			if (middle == user->count_user_op) {
   1bb0e:	7838      	ldrb	r0, [r7, #0]
			user_op = &user_ops[user->middle];
   1bb10:	eb08 0248 	add.w	r2, r8, r8, lsl #1
   1bb14:	0112      	lsls	r2, r2, #4
   1bb16:	189e      	adds	r6, r3, r2
			middle = user->middle + 1;
   1bb18:	f108 0301 	add.w	r3, r8, #1
   1bb1c:	b2db      	uxtb	r3, r3
				middle = 0U;
   1bb1e:	4298      	cmp	r0, r3
   1bb20:	bf08      	it	eq
   1bb22:	2300      	moveq	r3, #0
			user->middle = middle;
   1bb24:	70bb      	strb	r3, [r7, #2]
			if (user_op->op < TICKER_USER_OP_TYPE_UPDATE) {
   1bb26:	9b06      	ldr	r3, [sp, #24]
   1bb28:	5c9a      	ldrb	r2, [r3, r2]
   1bb2a:	2a04      	cmp	r2, #4
   1bb2c:	d9ea      	bls.n	1bb04 <ticker_job+0x124>
			ticker = &node[user_op->id];
   1bb2e:	7873      	ldrb	r3, [r6, #1]
   1bb30:	212c      	movs	r1, #44	; 0x2c
   1bb32:	fb13 f101 	smulbb	r1, r3, r1
   1bb36:	910b      	str	r1, [sp, #44]	; 0x2c
   1bb38:	980b      	ldr	r0, [sp, #44]	; 0x2c
   1bb3a:	9905      	ldr	r1, [sp, #20]
   1bb3c:	180d      	adds	r5, r1, r0
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP) ||
   1bb3e:	2a06      	cmp	r2, #6
			state = (ticker->req - ticker->ack) & 0xff;
   1bb40:	78a9      	ldrb	r1, [r5, #2]
   1bb42:	f895 c001 	ldrb.w	ip, [r5, #1]
   1bb46:	9107      	str	r1, [sp, #28]
   1bb48:	ebac 0c01 	sub.w	ip, ip, r1
   1bb4c:	fa5f f18c 	uxtb.w	r1, ip
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP) ||
   1bb50:	d80e      	bhi.n	1bb70 <ticker_job+0x190>
   1bb52:	b169      	cbz	r1, 1bb70 <ticker_job+0x190>
			    (state == 0U) ||
   1bb54:	2a05      	cmp	r2, #5
   1bb56:	d110      	bne.n	1bb7a <ticker_job+0x19a>
			    ((user_op->op == TICKER_USER_OP_TYPE_UPDATE) &&
   1bb58:	6870      	ldr	r0, [r6, #4]
   1bb5a:	b970      	cbnz	r0, 1bb7a <ticker_job+0x19a>
			     (user_op->params.update.ticks_drift_plus == 0U) &&
   1bb5c:	68b0      	ldr	r0, [r6, #8]
   1bb5e:	b960      	cbnz	r0, 1bb7a <ticker_job+0x19a>
			     (user_op->params.update.ticks_drift_minus == 0U) &&
   1bb60:	68f0      	ldr	r0, [r6, #12]
   1bb62:	b950      	cbnz	r0, 1bb7a <ticker_job+0x19a>
			     (user_op->params.update.ticks_slot_plus == 0U) &&
   1bb64:	6930      	ldr	r0, [r6, #16]
   1bb66:	b940      	cbnz	r0, 1bb7a <ticker_job+0x19a>
			     (user_op->params.update.lazy == 0U) &&
   1bb68:	6970      	ldr	r0, [r6, #20]
   1bb6a:	f030 407f 	bics.w	r0, r0, #4278190080	; 0xff000000
   1bb6e:	d104      	bne.n	1bb7a <ticker_job+0x19a>
				ticker_job_op_cb(user_op,
   1bb70:	2101      	movs	r1, #1
	ticker_job_op_cb(user_op, TICKER_STATUS_SUCCESS);
   1bb72:	4630      	mov	r0, r6
   1bb74:	f00f ff89 	bl	2ba8a <ticker_job_op_cb>
   1bb78:	e7c3      	b.n	1bb02 <ticker_job+0x122>
			if (state == 1U) {
   1bb7a:	2901      	cmp	r1, #1
   1bb7c:	d174      	bne.n	1bc68 <ticker_job+0x288>
	previous = instance->ticker_id_head;
   1bb7e:	f894 c01d 	ldrb.w	ip, [r4, #29]
	node = &instance->nodes[0];
   1bb82:	6821      	ldr	r1, [r4, #0]
	previous = instance->ticker_id_head;
   1bb84:	46e6      	mov	lr, ip
	total = 0U;
   1bb86:	f04f 0800 	mov.w	r8, #0
	while (current != TICKER_NULL) {
   1bb8a:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
   1bb8e:	d146      	bne.n	1bc1e <ticker_job+0x23e>
		return 0;
   1bb90:	f04f 0800 	mov.w	r8, #0
	if (user_op->op == TICKER_USER_OP_TYPE_UPDATE) {
   1bb94:	2a05      	cmp	r2, #5
	ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
   1bb96:	f8c5 8008 	str.w	r8, [r5, #8]
	if (user_op->op == TICKER_USER_OP_TYPE_UPDATE) {
   1bb9a:	d151      	bne.n	1bc40 <ticker_job+0x260>
		ticker_job_node_update(ticker, user_op, instance->ticks_current,
   1bb9c:	f8d4 9014 	ldr.w	r9, [r4, #20]
	ticks_now = cntr_cnt_get();
   1bba0:	f008 fd0a 	bl	245b8 <cntr_cnt_get>
 * @param ticks_now Highest tick count (now)
 * @param ticks_old Tick count to subtract from ticks_now
 */
u32_t ticker_ticks_diff_get(u32_t ticks_now, u32_t ticks_old)
{
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   1bba4:	eba0 0109 	sub.w	r1, r0, r9
   1bba8:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
   1bbac:	4451      	add	r1, sl
	if (ticks_to_expire > ticks_elapsed) {
   1bbae:	4588      	cmp	r8, r1
		ticker->ticks_to_expire_minus += ticks_elapsed -
   1bbb0:	bf98      	it	ls
   1bbb2:	696b      	ldrls	r3, [r5, #20]
	ticks_now = cntr_cnt_get();
   1bbb4:	4602      	mov	r2, r0
		ticker->ticks_to_expire_minus += ticks_elapsed -
   1bbb6:	bf98      	it	ls
   1bbb8:	eba3 0808 	subls.w	r8, r3, r8
	if ((ticker->ticks_periodic != 0U) &&
   1bbbc:	6868      	ldr	r0, [r5, #4]
		ticker->ticks_to_expire_minus += ticks_elapsed -
   1bbbe:	bf97      	itett	ls
   1bbc0:	4441      	addls	r1, r8
		ticks_to_expire -= ticks_elapsed;
   1bbc2:	eba8 0801 	subhi.w	r8, r8, r1
		ticker->ticks_to_expire_minus += ticks_elapsed -
   1bbc6:	6169      	strls	r1, [r5, #20]
		ticks_to_expire = 0U;
   1bbc8:	f04f 0800 	movls.w	r8, #0
	if ((ticker->ticks_periodic != 0U) &&
   1bbcc:	b128      	cbz	r0, 1bbda <ticker_job+0x1fa>
	    (user_op->params.update.lazy != 0U)) {
   1bbce:	8ab3      	ldrh	r3, [r6, #20]
	if ((ticker->ticks_periodic != 0U) &&
   1bbd0:	b11b      	cbz	r3, 1bbda <ticker_job+0x1fa>
		user_op->params.update.lazy--;
   1bbd2:	3b01      	subs	r3, #1
   1bbd4:	b29b      	uxth	r3, r3
   1bbd6:	82b3      	strh	r3, [r6, #20]
		ticker->lazy_periodic = user_op->params.update.lazy;
   1bbd8:	83ab      	strh	r3, [r5, #28]
	ticker->ticks_to_expire = ticks_to_expire +
   1bbda:	6871      	ldr	r1, [r6, #4]
	ticker->ticks_to_expire_minus +=
   1bbdc:	696b      	ldr	r3, [r5, #20]
	ticker->ticks_to_expire = ticks_to_expire +
   1bbde:	4441      	add	r1, r8
   1bbe0:	60a9      	str	r1, [r5, #8]
	ticker->ticks_to_expire_minus +=
   1bbe2:	68b1      	ldr	r1, [r6, #8]
   1bbe4:	440b      	add	r3, r1
   1bbe6:	616b      	str	r3, [r5, #20]
	ticks_to_expire_prep(ticker, ticks_current, ticks_now);
   1bbe8:	4649      	mov	r1, r9
   1bbea:	4628      	mov	r0, r5
   1bbec:	f00f ff2f 	bl	2ba4e <ticks_to_expire_prep>
	ticker->ticks_slot += user_op->params.update.ticks_slot_plus;
   1bbf0:	68f2      	ldr	r2, [r6, #12]
   1bbf2:	69ab      	ldr	r3, [r5, #24]
   1bbf4:	4413      	add	r3, r2
	if (ticker->ticks_slot > user_op->params.update.ticks_slot_minus) {
   1bbf6:	6932      	ldr	r2, [r6, #16]
   1bbf8:	4293      	cmp	r3, r2
		ticker->ticks_slot -= user_op->params.update.ticks_slot_minus;
   1bbfa:	bf8c      	ite	hi
   1bbfc:	1a9b      	subhi	r3, r3, r2
		ticker->ticks_slot = 0U;
   1bbfe:	2300      	movls	r3, #0
   1bc00:	61ab      	str	r3, [r5, #24]
	if (user_op->params.update.force != 0U) {
   1bc02:	7db3      	ldrb	r3, [r6, #22]
   1bc04:	b103      	cbz	r3, 1bc08 <ticker_job+0x228>
		ticker->force = user_op->params.update.force;
   1bc06:	70eb      	strb	r3, [r5, #3]
	ticker->next = *insert_head;
   1bc08:	9b05      	ldr	r3, [sp, #20]
   1bc0a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1bc0c:	f803 b002 	strb.w	fp, [r3, r2]
		ticker->req++;
   1bc10:	786b      	ldrb	r3, [r5, #1]
	*insert_head = user_op->id;
   1bc12:	f896 b001 	ldrb.w	fp, [r6, #1]
		ticker->req++;
   1bc16:	3301      	adds	r3, #1
   1bc18:	706b      	strb	r3, [r5, #1]
	ticker_job_op_cb(user_op, TICKER_STATUS_SUCCESS);
   1bc1a:	2100      	movs	r1, #0
   1bc1c:	e7a9      	b.n	1bb72 <ticker_job+0x192>
		ticker_current = &node[current];
   1bc1e:	202c      	movs	r0, #44	; 0x2c
   1bc20:	fb1c f900 	smulbb	r9, ip, r0
   1bc24:	eb01 0009 	add.w	r0, r1, r9
   1bc28:	9009      	str	r0, [sp, #36]	; 0x24
		if (current == id) {
   1bc2a:	6880      	ldr	r0, [r0, #8]
   1bc2c:	900a      	str	r0, [sp, #40]	; 0x28
   1bc2e:	4563      	cmp	r3, ip
   1bc30:	4480      	add	r8, r0
   1bc32:	f811 9009 	ldrb.w	r9, [r1, r9]
   1bc36:	f000 81c6 	beq.w	1bfc6 <ticker_job+0x5e6>
   1bc3a:	46e6      	mov	lr, ip
   1bc3c:	46cc      	mov	ip, r9
   1bc3e:	e7a4      	b.n	1bb8a <ticker_job+0x1aa>
		ticker->req = ticker->ack;
   1bc40:	9a07      	ldr	r2, [sp, #28]
   1bc42:	706a      	strb	r2, [r5, #1]
		if (instance->ticker_id_slot_previous == user_op->id) {
   1bc44:	7f22      	ldrb	r2, [r4, #28]
   1bc46:	429a      	cmp	r2, r3
   1bc48:	d1e7      	bne.n	1bc1a <ticker_job+0x23a>
			u32_t ticks_now = cntr_cnt_get();
   1bc4a:	f008 fcb5 	bl	245b8 <cntr_cnt_get>
			instance->ticker_id_slot_previous = TICKER_NULL;
   1bc4e:	23ff      	movs	r3, #255	; 0xff
   1bc50:	7723      	strb	r3, [r4, #28]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   1bc52:	6963      	ldr	r3, [r4, #20]
   1bc54:	1ac0      	subs	r0, r0, r3
   1bc56:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			ticks_used = ticks_elapsed +
   1bc5a:	4450      	add	r0, sl
			instance->ticks_slot_previous =	MIN(ticker->ticks_slot,
   1bc5c:	69ab      	ldr	r3, [r5, #24]
   1bc5e:	4298      	cmp	r0, r3
   1bc60:	bf94      	ite	ls
   1bc62:	61a0      	strls	r0, [r4, #24]
   1bc64:	61a3      	strhi	r3, [r4, #24]
   1bc66:	e7d8      	b.n	1bc1a <ticker_job+0x23a>
				instance->sched_cb(TICKER_CALL_ID_JOB,
   1bc68:	2104      	movs	r1, #4
   1bc6a:	4623      	mov	r3, r4
   1bc6c:	6a65      	ldr	r5, [r4, #36]	; 0x24
   1bc6e:	2201      	movs	r2, #1
   1bc70:	4608      	mov	r0, r1
   1bc72:	47a8      	blx	r5
				pending = 1U;
   1bc74:	2301      	movs	r3, #1
				user->middle = prev;
   1bc76:	f887 8002 	strb.w	r8, [r7, #2]
				pending = 1U;
   1bc7a:	9308      	str	r3, [sp, #32]
   1bc7c:	e6dc      	b.n	1ba38 <ticker_job+0x58>
		if (ticker->lazy_current != 0U) {
   1bc7e:	8be8      	ldrh	r0, [r5, #30]
		ticks_elapsed -= ticks_to_expire;
   1bc80:	ebaa 0a02 	sub.w	sl, sl, r2
		ticks_expired += ticks_to_expire;
   1bc84:	4490      	add	r8, r2
		if (ticker->lazy_current != 0U) {
   1bc86:	2800      	cmp	r0, #0
   1bc88:	d032      	beq.n	1bcf0 <ticker_job+0x310>
			instance->ticker_id_slot_previous = TICKER_NULL;
   1bc8a:	22ff      	movs	r2, #255	; 0xff
   1bc8c:	7722      	strb	r2, [r4, #28]
			instance->ticks_slot_previous = 0U;
   1bc8e:	2200      	movs	r2, #0
				instance->ticks_slot_previous =
   1bc90:	61a2      	str	r2, [r4, #24]
		ticker->ticks_to_expire = 0U;
   1bc92:	f04f 0c00 	mov.w	ip, #0
   1bc96:	f8c5 c008 	str.w	ip, [r5, #8]
		instance->ticker_id_head = ticker->next;
   1bc9a:	f819 1007 	ldrb.w	r1, [r9, r7]
   1bc9e:	7761      	strb	r1, [r4, #29]
		if (ticker->ticks_periodic != 0U) {
   1bca0:	686b      	ldr	r3, [r5, #4]
   1bca2:	2b00      	cmp	r3, #0
   1bca4:	d032      	beq.n	1bd0c <ticker_job+0x32c>
	ticker->remainder_current += ticker->remainder_periodic;
   1bca6:	e9d5 0108 	ldrd	r0, r1, [r5, #32]
   1bcaa:	4401      	add	r1, r0
	if ((ticker->remainder_current < BIT(31)) &&
   1bcac:	48a3      	ldr	r0, [pc, #652]	; (1bf3c <ticker_job+0x55c>)
   1bcae:	4aa4      	ldr	r2, [pc, #656]	; (1bf40 <ticker_job+0x560>)
			ticker->ticks_to_expire  = ticker->ticks_periodic;
   1bcb0:	60ab      	str	r3, [r5, #8]
	if ((ticker->remainder_current < BIT(31)) &&
   1bcb2:	1808      	adds	r0, r1, r0
   1bcb4:	4290      	cmp	r0, r2
		return 1;
   1bcb6:	bf95      	itete	ls
   1bcb8:	9a01      	ldrls	r2, [sp, #4]
	ticker->remainder_current += ticker->remainder_periodic;
   1bcba:	6269      	strhi	r1, [r5, #36]	; 0x24
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   1bcbc:	f1a1 71e8 	subls.w	r1, r1, #30408704	; 0x1d00000
	return 0;
   1bcc0:	4662      	movhi	r2, ip
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   1bcc2:	bf98      	it	ls
   1bcc4:	f5a1 31d4 	subls.w	r1, r1, #108544	; 0x1a800
			ticker->ticks_to_expire += ticker_remainder_inc(ticker);
   1bcc8:	441a      	add	r2, r3
			ticks_to_expire_prep(ticker, instance->ticks_current,
   1bcca:	9b04      	ldr	r3, [sp, #16]
			ticker->ticks_to_expire += ticker_remainder_inc(ticker);
   1bccc:	60aa      	str	r2, [r5, #8]
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
   1bcce:	bf9c      	itt	ls
   1bcd0:	f5a1 71a5 	subls.w	r1, r1, #330	; 0x14a
   1bcd4:	6269      	strls	r1, [r5, #36]	; 0x24
			ticks_to_expire_prep(ticker, instance->ticks_current,
   1bcd6:	eb03 0208 	add.w	r2, r3, r8
   1bcda:	6961      	ldr	r1, [r4, #20]
   1bcdc:	4628      	mov	r0, r5
   1bcde:	f00f feb6 	bl	2ba4e <ticks_to_expire_prep>
			ticker->next = *insert_head;
   1bce2:	f809 b007 	strb.w	fp, [r9, r7]
			ticker->req++;
   1bce6:	786a      	ldrb	r2, [r5, #1]
   1bce8:	3201      	adds	r2, #1
   1bcea:	706a      	strb	r2, [r5, #1]
			ticker->req = ticker->ack;
   1bcec:	46b3      	mov	fp, r6
   1bcee:	e6b5      	b.n	1ba5c <ticker_job+0x7c>
			if (instance->ticks_slot_previous > ticks_to_expire) {
   1bcf0:	69a1      	ldr	r1, [r4, #24]
   1bcf2:	428a      	cmp	r2, r1
				instance->ticker_id_slot_previous = TICKER_NULL;
   1bcf4:	bf2b      	itete	cs
   1bcf6:	22ff      	movcs	r2, #255	; 0xff
				instance->ticks_slot_previous -=
   1bcf8:	1a8a      	subcc	r2, r1, r2
				instance->ticker_id_slot_previous = TICKER_NULL;
   1bcfa:	7722      	strbcs	r2, [r4, #28]
				instance->ticks_slot_previous -=
   1bcfc:	61a2      	strcc	r2, [r4, #24]
			if (ticker->ticks_slot != 0U) {
   1bcfe:	69aa      	ldr	r2, [r5, #24]
				instance->ticks_slot_previous = 0U;
   1bd00:	bf28      	it	cs
   1bd02:	61a0      	strcs	r0, [r4, #24]
			if (ticker->ticks_slot != 0U) {
   1bd04:	2a00      	cmp	r2, #0
   1bd06:	d0c4      	beq.n	1bc92 <ticker_job+0x2b2>
				instance->ticker_id_slot_previous = id_expired;
   1bd08:	7726      	strb	r6, [r4, #28]
   1bd0a:	e7c1      	b.n	1bc90 <ticker_job+0x2b0>
			ticker->req = ticker->ack;
   1bd0c:	78aa      	ldrb	r2, [r5, #2]
   1bd0e:	706a      	strb	r2, [r5, #1]
   1bd10:	465e      	mov	r6, fp
   1bd12:	e7eb      	b.n	1bcec <ticker_job+0x30c>
		user = &users[count_user];
   1bd14:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1bd16:	9a01      	ldr	r2, [sp, #4]
   1bd18:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   1bd1c:	9304      	str	r3, [sp, #16]
		user_ops = (void *)&user->user_op[0];
   1bd1e:	685b      	ldr	r3, [r3, #4]
   1bd20:	9307      	str	r3, [sp, #28]
		user_ops_first = user->first;
   1bd22:	9b04      	ldr	r3, [sp, #16]
   1bd24:	785f      	ldrb	r7, [r3, #1]
		while ((insert_head != TICKER_NULL) ||
   1bd26:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
   1bd2a:	d05e      	beq.n	1bdea <ticker_job+0x40a>
				ticker = &node[id_insert];
   1bd2c:	fb1b f309 	smulbb	r3, fp, r9
   1bd30:	9a05      	ldr	r2, [sp, #20]
				insert_head = ticker->next;
   1bd32:	46da      	mov	sl, fp
   1bd34:	f812 b003 	ldrb.w	fp, [r2, r3]
				ticker = &node[id_insert];
   1bd38:	18d5      	adds	r5, r2, r3
				user_op = NULL;
   1bd3a:	2600      	movs	r6, #0
	ticker->next = TICKER_NULL;
   1bd3c:	22ff      	movs	r2, #255	; 0xff
   1bd3e:	702a      	strb	r2, [r5, #0]
	node = &instance->nodes[0];
   1bd40:	6820      	ldr	r0, [r4, #0]
	previous = TICKER_NULL;
   1bd42:	9206      	str	r2, [sp, #24]
	ticker_new = &node[id];
   1bd44:	fb1a f309 	smulbb	r3, sl, r9
   1bd48:	eb00 0e03 	add.w	lr, r0, r3
   1bd4c:	9309      	str	r3, [sp, #36]	; 0x24
	ticks_to_expire = ticker_new->ticks_to_expire;
   1bd4e:	f8de 1008 	ldr.w	r1, [lr, #8]
	current = instance->ticker_id_head;
   1bd52:	7f63      	ldrb	r3, [r4, #29]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
   1bd54:	2bff      	cmp	r3, #255	; 0xff
   1bd56:	d008      	beq.n	1bd6a <ticker_job+0x38a>
		(ticker_current = &node[current])->ticks_to_expire))) {
   1bd58:	fb13 f209 	smulbb	r2, r3, r9
   1bd5c:	920a      	str	r2, [sp, #40]	; 0x28
   1bd5e:	1882      	adds	r2, r0, r2
   1bd60:	4690      	mov	r8, r2
		(ticks_to_expire_current =
   1bd62:	f8d2 c008 	ldr.w	ip, [r2, #8]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
   1bd66:	4561      	cmp	r1, ip
   1bd68:	d26b      	bcs.n	1be42 <ticker_job+0x462>
	ticker_new->next = current;
   1bd6a:	9a09      	ldr	r2, [sp, #36]	; 0x24
	ticker_new->ticks_to_expire = ticks_to_expire;
   1bd6c:	f8ce 1008 	str.w	r1, [lr, #8]
	ticker_new->next = current;
   1bd70:	5483      	strb	r3, [r0, r2]
	if (previous == TICKER_NULL) {
   1bd72:	9a06      	ldr	r2, [sp, #24]
   1bd74:	2aff      	cmp	r2, #255	; 0xff
		node[previous].next = id;
   1bd76:	bf17      	itett	ne
   1bd78:	9a06      	ldrne	r2, [sp, #24]
		instance->ticker_id_head = id;
   1bd7a:	f884 a01d 	strbeq.w	sl, [r4, #29]
		node[previous].next = id;
   1bd7e:	fb12 f209 	smulbbne	r2, r2, r9
   1bd82:	f800 a002 	strbne.w	sl, [r0, r2]
	if (current != TICKER_NULL) {
   1bd86:	2bff      	cmp	r3, #255	; 0xff
		node[current].ticks_to_expire -= ticks_to_expire;
   1bd88:	bf1f      	itttt	ne
   1bd8a:	fb03 0309 	mlane	r3, r3, r9, r0
   1bd8e:	689a      	ldrne	r2, [r3, #8]
   1bd90:	1a51      	subne	r1, r2, r1
   1bd92:	6099      	strne	r1, [r3, #8]
	ticker->req = ticker->ack + 1;
   1bd94:	78ab      	ldrb	r3, [r5, #2]
   1bd96:	3301      	adds	r3, #1
   1bd98:	706b      	strb	r3, [r5, #1]
			if (user_op) {
   1bd9a:	2e00      	cmp	r6, #0
   1bd9c:	d0c3      	beq.n	1bd26 <ticker_job+0x346>
				ticker_job_op_cb(user_op, status);
   1bd9e:	2100      	movs	r1, #0
   1bda0:	4630      	mov	r0, r6
   1bda2:	f00f fe72 	bl	2ba8a <ticker_job_op_cb>
   1bda6:	e7be      	b.n	1bd26 <ticker_job+0x346>
				user_op = &user_ops[user_ops_first];
   1bda8:	eb07 0347 	add.w	r3, r7, r7, lsl #1
   1bdac:	9a07      	ldr	r2, [sp, #28]
   1bdae:	011b      	lsls	r3, r3, #4
   1bdb0:	18d6      	adds	r6, r2, r3
				if (first == user->count_user_op) {
   1bdb2:	9a04      	ldr	r2, [sp, #16]
				first = user_ops_first + 1;
   1bdb4:	3701      	adds	r7, #1
				if (first == user->count_user_op) {
   1bdb6:	7812      	ldrb	r2, [r2, #0]
				first = user_ops_first + 1;
   1bdb8:	b2ff      	uxtb	r7, r7
					first = 0U;
   1bdba:	42ba      	cmp	r2, r7
   1bdbc:	bf08      	it	eq
   1bdbe:	2700      	moveq	r7, #0
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
   1bdc0:	9a07      	ldr	r2, [sp, #28]
   1bdc2:	5cd3      	ldrb	r3, [r2, r3]
   1bdc4:	2b04      	cmp	r3, #4
   1bdc6:	d110      	bne.n	1bdea <ticker_job+0x40a>
				ticker = &node[id_insert];
   1bdc8:	9b05      	ldr	r3, [sp, #20]
				id_insert = user_op->id;
   1bdca:	f896 a001 	ldrb.w	sl, [r6, #1]
				ticker = &node[id_insert];
   1bdce:	fb0a 3509 	mla	r5, sl, r9, r3
				if (((ticker->req -
   1bdd2:	f895 8001 	ldrb.w	r8, [r5, #1]
				      ticker->ack) & 0xff) != 0U) {
   1bdd6:	78ab      	ldrb	r3, [r5, #2]
				if (((ticker->req -
   1bdd8:	eba8 0803 	sub.w	r8, r8, r3
   1bddc:	f018 08ff 	ands.w	r8, r8, #255	; 0xff
   1bde0:	d008      	beq.n	1bdf4 <ticker_job+0x414>
					ticker_job_op_cb(user_op,
   1bde2:	2101      	movs	r1, #1
   1bde4:	4630      	mov	r0, r6
   1bde6:	f00f fe50 	bl	2ba8a <ticker_job_op_cb>
		while ((insert_head != TICKER_NULL) ||
   1bdea:	9b04      	ldr	r3, [sp, #16]
   1bdec:	789b      	ldrb	r3, [r3, #2]
   1bdee:	42bb      	cmp	r3, r7
   1bdf0:	d1da      	bne.n	1bda8 <ticker_job+0x3c8>
   1bdf2:	e651      	b.n	1ba98 <ticker_job+0xb8>
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
   1bdf4:	8ab3      	ldrh	r3, [r6, #20]
				ticker_job_op_start(ticker, user_op,
   1bdf6:	6961      	ldr	r1, [r4, #20]
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
   1bdf8:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1bdfc:	4293      	cmp	r3, r2
   1bdfe:	bf0c      	ite	eq
   1be00:	2201      	moveq	r2, #1
   1be02:	2200      	movne	r2, #0
   1be04:	f885 2028 	strb.w	r2, [r5, #40]	; 0x28
	ticker->ticks_periodic = start->ticks_periodic;
   1be08:	68f2      	ldr	r2, [r6, #12]
   1be0a:	606a      	str	r2, [r5, #4]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
   1be0c:	bf08      	it	eq
   1be0e:	2300      	moveq	r3, #0
	ticker->remainder_periodic = start->remainder_periodic;
   1be10:	6932      	ldr	r2, [r6, #16]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
   1be12:	83ab      	strh	r3, [r5, #28]
	ticker->ticks_slot = start->ticks_slot;
   1be14:	69b3      	ldr	r3, [r6, #24]
   1be16:	61ab      	str	r3, [r5, #24]
	ticker->timeout_func = start->fp_timeout_func;
   1be18:	69f3      	ldr	r3, [r6, #28]
   1be1a:	60eb      	str	r3, [r5, #12]
	ticker->context = start->context;
   1be1c:	6a33      	ldr	r3, [r6, #32]
   1be1e:	612b      	str	r3, [r5, #16]
	ticker->ticks_to_expire = start->ticks_first;
   1be20:	68b3      	ldr	r3, [r6, #8]
	ticker->remainder_periodic = start->remainder_periodic;
   1be22:	622a      	str	r2, [r5, #32]
	ticker->ticks_to_expire = start->ticks_first;
   1be24:	60ab      	str	r3, [r5, #8]
	ticker->ticks_to_expire_minus = 0U;
   1be26:	f8c5 8014 	str.w	r8, [r5, #20]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
   1be2a:	6872      	ldr	r2, [r6, #4]
   1be2c:	4628      	mov	r0, r5
   1be2e:	f00f fe0e 	bl	2ba4e <ticks_to_expire_prep>
	ticker->force = 1U;
   1be32:	f04f 0301 	mov.w	r3, #1
	ticker->remainder_current = 0U;
   1be36:	f8c5 8024 	str.w	r8, [r5, #36]	; 0x24
	ticker->lazy_current = 0U;
   1be3a:	f8a5 801e 	strh.w	r8, [r5, #30]
	ticker->force = 1U;
   1be3e:	70eb      	strb	r3, [r5, #3]
   1be40:	e77c      	b.n	1bd3c <ticker_job+0x35c>
		if (ticks_to_expire == 0 && (ticker_new->lazy_current >
   1be42:	ebb1 010c 	subs.w	r1, r1, ip
   1be46:	d10a      	bne.n	1be5e <ticker_job+0x47e>
   1be48:	f8be 201e 	ldrh.w	r2, [lr, #30]
   1be4c:	920c      	str	r2, [sp, #48]	; 0x30
   1be4e:	f8b8 201e 	ldrh.w	r2, [r8, #30]
   1be52:	920d      	str	r2, [sp, #52]	; 0x34
   1be54:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   1be56:	4690      	mov	r8, r2
   1be58:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1be5a:	4590      	cmp	r8, r2
   1be5c:	d803      	bhi.n	1be66 <ticker_job+0x486>
		current = ticker_current->next;
   1be5e:	9306      	str	r3, [sp, #24]
   1be60:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1be62:	5cc3      	ldrb	r3, [r0, r3]
   1be64:	e776      	b.n	1bd54 <ticker_job+0x374>
		(ticks_to_expire_current =
   1be66:	4661      	mov	r1, ip
   1be68:	e77f      	b.n	1bd6a <ticker_job+0x38a>
	users = &instance->users[0];
   1be6a:	6863      	ldr	r3, [r4, #4]
	count_user = instance->count_user;
   1be6c:	7a65      	ldrb	r5, [r4, #9]
	users = &instance->users[0];
   1be6e:	9301      	str	r3, [sp, #4]
	       ((ticker = &node[_ticker_id_head])->ticks_slot == 0U)) {
   1be70:	272c      	movs	r7, #44	; 0x2c
	while (count_user--) {
   1be72:	3d01      	subs	r5, #1
   1be74:	b2ed      	uxtb	r5, r5
   1be76:	2dff      	cmp	r5, #255	; 0xff
   1be78:	f43f ae20 	beq.w	1babc <ticker_job+0xdc>
		user = &users[count_user];
   1be7c:	9b01      	ldr	r3, [sp, #4]
   1be7e:	eb03 06c5 	add.w	r6, r3, r5, lsl #3
		user_op = &user->user_op[0];
   1be82:	f8d6 8004 	ldr.w	r8, [r6, #4]
		while (user->first != user->last) {
   1be86:	7873      	ldrb	r3, [r6, #1]
   1be88:	78f2      	ldrb	r2, [r6, #3]
   1be8a:	429a      	cmp	r2, r3
   1be8c:	d0f1      	beq.n	1be72 <ticker_job+0x492>
			ticker_job_op_inquire(instance, &user_op[user->first]);
   1be8e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1be92:	011a      	lsls	r2, r3, #4
   1be94:	eb08 0302 	add.w	r3, r8, r2
	switch (uop->op) {
   1be98:	f818 2002 	ldrb.w	r2, [r8, r2]
   1be9c:	2a02      	cmp	r2, #2
   1be9e:	d013      	beq.n	1bec8 <ticker_job+0x4e8>
   1bea0:	2a03      	cmp	r2, #3
   1bea2:	d03e      	beq.n	1bf22 <ticker_job+0x542>
   1bea4:	2a01      	cmp	r2, #1
   1bea6:	d106      	bne.n	1beb6 <ticker_job+0x4d6>
			uop->status = TICKER_STATUS_SUCCESS;
   1bea8:	2200      	movs	r2, #0
			uop->status = TICKER_STATUS_FAILURE;
   1beaa:	625a      	str	r2, [r3, #36]	; 0x24
		fp_op_func = uop->fp_op_func;
   1beac:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if (fp_op_func) {
   1beae:	b112      	cbz	r2, 1beb6 <ticker_job+0x4d6>
		fp_op_func(uop->status, uop->op_context);
   1beb0:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
   1beb2:	6a58      	ldr	r0, [r3, #36]	; 0x24
   1beb4:	4790      	blx	r2
			first = user->first + 1;
   1beb6:	7873      	ldrb	r3, [r6, #1]
			if (first == user->count_user_op) {
   1beb8:	7832      	ldrb	r2, [r6, #0]
			first = user->first + 1;
   1beba:	3301      	adds	r3, #1
   1bebc:	b2db      	uxtb	r3, r3
				first = 0U;
   1bebe:	429a      	cmp	r2, r3
   1bec0:	bf08      	it	eq
   1bec2:	2300      	moveq	r3, #0
			user->first = first;
   1bec4:	7073      	strb	r3, [r6, #1]
   1bec6:	e7de      	b.n	1be86 <ticker_job+0x4a6>
		ticker_by_next_slot_get(instance,
   1bec8:	e9d3 9001 	ldrd	r9, r0, [r3, #4]
	_ticker_id_head = *ticker_id_head;
   1becc:	f899 a000 	ldrb.w	sl, [r9]
		ticker_by_next_slot_get(instance,
   1bed0:	f8d3 e00c 	ldr.w	lr, [r3, #12]
	node = instance->nodes;
   1bed4:	f8d4 c000 	ldr.w	ip, [r4]
	if ((_ticker_id_head == TICKER_NULL) ||
   1bed8:	6961      	ldr	r1, [r4, #20]
   1beda:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
   1bede:	d002      	beq.n	1bee6 <ticker_job+0x506>
   1bee0:	6802      	ldr	r2, [r0, #0]
   1bee2:	428a      	cmp	r2, r1
   1bee4:	d013      	beq.n	1bf0e <ticker_job+0x52e>
		_ticker_id_head = instance->ticker_id_head;
   1bee6:	7f62      	ldrb	r2, [r4, #29]
		*ticks_current = instance->ticks_current;
   1bee8:	6001      	str	r1, [r0, #0]
		_ticks_to_expire = 0U;
   1beea:	2100      	movs	r1, #0
	while ((_ticker_id_head != TICKER_NULL) &&
   1beec:	2aff      	cmp	r2, #255	; 0xff
   1beee:	d009      	beq.n	1bf04 <ticker_job+0x524>
	       ((ticker = &node[_ticker_id_head])->ticks_slot == 0U)) {
   1bef0:	fb12 fb07 	smulbb	fp, r2, r7
   1bef4:	eb0c 0a0b 	add.w	sl, ip, fp
   1bef8:	f8da 0008 	ldr.w	r0, [sl, #8]
   1befc:	4401      	add	r1, r0
	while ((_ticker_id_head != TICKER_NULL) &&
   1befe:	f8da 0018 	ldr.w	r0, [sl, #24]
   1bf02:	b158      	cbz	r0, 1bf1c <ticker_job+0x53c>
	*ticker_id_head = _ticker_id_head;
   1bf04:	f889 2000 	strb.w	r2, [r9]
	*ticks_to_expire = _ticks_to_expire;
   1bf08:	f8ce 1000 	str.w	r1, [lr]
		uop->status = TICKER_STATUS_SUCCESS;
   1bf0c:	e7cc      	b.n	1bea8 <ticker_job+0x4c8>
		ticker = &node[_ticker_id_head];
   1bf0e:	fb1a f207 	smulbb	r2, sl, r7
	_ticks_to_expire = *ticks_to_expire;
   1bf12:	f8de 1000 	ldr.w	r1, [lr]
		_ticker_id_head = ticker->next;
   1bf16:	f81c 2002 	ldrb.w	r2, [ip, r2]
   1bf1a:	e7e7      	b.n	1beec <ticker_job+0x50c>
		_ticker_id_head = ticker->next;
   1bf1c:	f81c 200b 	ldrb.w	r2, [ip, fp]
   1bf20:	e7e4      	b.n	1beec <ticker_job+0x50c>
		if (uop->id < instance->count_node) {
   1bf22:	7859      	ldrb	r1, [r3, #1]
   1bf24:	7a22      	ldrb	r2, [r4, #8]
   1bf26:	428a      	cmp	r2, r1
   1bf28:	d906      	bls.n	1bf38 <ticker_job+0x558>
			node[uop->id].priority =
   1bf2a:	6822      	ldr	r2, [r4, #0]
   1bf2c:	fb01 2207 	mla	r2, r1, r7, r2
   1bf30:	7919      	ldrb	r1, [r3, #4]
   1bf32:	f882 1029 	strb.w	r1, [r2, #41]	; 0x29
   1bf36:	e7b7      	b.n	1bea8 <ticker_job+0x4c8>
			uop->status = TICKER_STATUS_FAILURE;
   1bf38:	2201      	movs	r2, #1
   1bf3a:	e7b6      	b.n	1beaa <ticker_job+0x4ca>
   1bf3c:	ff172b5a 	.word	0xff172b5a
   1bf40:	7f172b59 	.word	0x7f172b59
	if (ticker_id_old_head == TICKER_NULL) {
   1bf44:	9b03      	ldr	r3, [sp, #12]
   1bf46:	2bff      	cmp	r3, #255	; 0xff
   1bf48:	d106      	bne.n	1bf58 <ticker_job+0x578>
		ticks_current = cntr_cnt_get();
   1bf4a:	f008 fb35 	bl	245b8 <cntr_cnt_get>
   1bf4e:	4605      	mov	r5, r0
		if (cntr_start() == 0) {
   1bf50:	f008 fb06 	bl	24560 <cntr_start>
   1bf54:	b900      	cbnz	r0, 1bf58 <ticker_job+0x578>
			instance->ticks_current = ticks_current;
   1bf56:	6165      	str	r5, [r4, #20]
	ticker = &instance->nodes[instance->ticker_id_head];
   1bf58:	7f61      	ldrb	r1, [r4, #29]
	ticks_to_expire = ticker->ticks_to_expire;
   1bf5a:	6822      	ldr	r2, [r4, #0]
		LL_ASSERT(i);
   1bf5c:	4f28      	ldr	r7, [pc, #160]	; (1c000 <ticker_job+0x620>)
	ticks_to_expire = ticker->ticks_to_expire;
   1bf5e:	232c      	movs	r3, #44	; 0x2c
   1bf60:	fb01 2303 	mla	r3, r1, r3, r2
	i = 10U;
   1bf64:	f04f 080a 	mov.w	r8, #10
	ticks_to_expire = ticker->ticks_to_expire;
   1bf68:	689e      	ldr	r6, [r3, #8]
		ctr = cntr_cnt_get();
   1bf6a:	f008 fb25 	bl	245b8 <cntr_cnt_get>
		cc = instance->ticks_current;
   1bf6e:	6965      	ldr	r5, [r4, #20]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   1bf70:	1b43      	subs	r3, r0, r5
   1bf72:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
		ticks_elapsed = ticker_ticks_diff_get(ctr, cc) +
   1bf76:	3303      	adds	r3, #3
		cc += MAX(ticks_elapsed, ticks_to_expire);
   1bf78:	42b3      	cmp	r3, r6
   1bf7a:	bf2c      	ite	cs
   1bf7c:	18ed      	addcs	r5, r5, r3
   1bf7e:	19ad      	addcc	r5, r5, r6
		cc &= HAL_TICKER_CNTR_MASK;
   1bf80:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		ctr = cntr_cnt_get();
   1bf84:	4681      	mov	r9, r0
		instance->trigger_set_cb(cc);
   1bf86:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1bf88:	4628      	mov	r0, r5
   1bf8a:	4798      	blx	r3
		ctr_post = cntr_cnt_get();
   1bf8c:	f008 fb14 	bl	245b8 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   1bf90:	eba0 0009 	sub.w	r0, r0, r9
   1bf94:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   1bf98:	eba5 0509 	sub.w	r5, r5, r9
	} while ((ticker_ticks_diff_get(ctr_post, ctr) +
   1bf9c:	3003      	adds	r0, #3
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   1bf9e:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		  ticker_ticks_diff_get(cc, ctr));
   1bfa2:	42a8      	cmp	r0, r5
		i--;
   1bfa4:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
		  ticker_ticks_diff_get(cc, ctr));
   1bfa8:	f67f ad94 	bls.w	1bad4 <ticker_job+0xf4>
		LL_ASSERT(i);
   1bfac:	f1b8 0f00 	cmp.w	r8, #0
   1bfb0:	d1db      	bne.n	1bf6a <ticker_job+0x58a>
   1bfb2:	4638      	mov	r0, r7
   1bfb4:	f00c f8c6 	bl	28144 <printk>
   1bfb8:	4040      	eors	r0, r0
   1bfba:	f380 8811 	msr	BASEPRI, r0
   1bfbe:	f04f 0003 	mov.w	r0, #3
   1bfc2:	df02      	svc	2
   1bfc4:	e7d1      	b.n	1bf6a <ticker_job+0x58a>
	if (previous == current) {
   1bfc6:	4573      	cmp	r3, lr
   1bfc8:	d101      	bne.n	1bfce <ticker_job+0x5ee>
		instance->ticker_id_head = ticker_current->next;
   1bfca:	f884 901d 	strb.w	r9, [r4, #29]
	node[previous].next = ticker_current->next;
   1bfce:	202c      	movs	r0, #44	; 0x2c
   1bfd0:	fb1e fe00 	smulbb	lr, lr, r0
	if (ticker_current->next != TICKER_NULL) {
   1bfd4:	9809      	ldr	r0, [sp, #36]	; 0x24
	node[previous].next = ticker_current->next;
   1bfd6:	f801 900e 	strb.w	r9, [r1, lr]
	if (ticker_current->next != TICKER_NULL) {
   1bfda:	f890 c000 	ldrb.w	ip, [r0]
   1bfde:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
   1bfe2:	f43f add7 	beq.w	1bb94 <ticker_job+0x1b4>
		node[ticker_current->next].ticks_to_expire += timeout;
   1bfe6:	202c      	movs	r0, #44	; 0x2c
   1bfe8:	fb0c 1c00 	mla	ip, ip, r0, r1
   1bfec:	980a      	ldr	r0, [sp, #40]	; 0x28
   1bfee:	f8dc 1008 	ldr.w	r1, [ip, #8]
   1bff2:	4401      	add	r1, r0
   1bff4:	f8cc 1008 	str.w	r1, [ip, #8]
	return (total + timeout);
   1bff8:	e5cc      	b.n	1bb94 <ticker_job+0x1b4>
}
   1bffa:	b00f      	add	sp, #60	; 0x3c
   1bffc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1c000:	0003148f 	.word	0x0003148f

0001c004 <ticker_init>:
{
   1c004:	b5f0      	push	{r4, r5, r6, r7, lr}
   1c006:	9e05      	ldr	r6, [sp, #20]
   1c008:	f89d 5018 	ldrb.w	r5, [sp, #24]
   1c00c:	9f07      	ldr	r7, [sp, #28]
	if (instance_index >= TICKER_INSTANCE_MAX) {
   1c00e:	b108      	cbz	r0, 1c014 <ticker_init+0x10>
		return TICKER_STATUS_FAILURE;
   1c010:	2001      	movs	r0, #1
}
   1c012:	bdf0      	pop	{r4, r5, r6, r7, pc}
	instance->count_node = count_node;
   1c014:	4c18      	ldr	r4, [pc, #96]	; (1c078 <ticker_init+0x74>)
		instance->nodes[count_node].priority = 0;
   1c016:	f04f 0c2c 	mov.w	ip, #44	; 0x2c
	instance->count_node = count_node;
   1c01a:	7221      	strb	r1, [r4, #8]
	instance->nodes = node;
   1c01c:	6022      	str	r2, [r4, #0]
	while (count_node--) {
   1c01e:	3901      	subs	r1, #1
   1c020:	b2c9      	uxtb	r1, r1
   1c022:	29ff      	cmp	r1, #255	; 0xff
   1c024:	d115      	bne.n	1c052 <ticker_init+0x4e>
	instance->count_user = count_user;
   1c026:	7263      	strb	r3, [r4, #9]
	instance->users = user;
   1c028:	6066      	str	r6, [r4, #4]
	while (count_user--) {
   1c02a:	3b01      	subs	r3, #1
   1c02c:	b2db      	uxtb	r3, r3
   1c02e:	2bff      	cmp	r3, #255	; 0xff
   1c030:	d114      	bne.n	1c05c <ticker_init+0x58>
	if (count_op) {
   1c032:	2d00      	cmp	r5, #0
   1c034:	d1ec      	bne.n	1c010 <ticker_init+0xc>
	instance->caller_id_get_cb = caller_id_get_cb;
   1c036:	9b08      	ldr	r3, [sp, #32]
   1c038:	6223      	str	r3, [r4, #32]
	instance->sched_cb = sched_cb;
   1c03a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1c03c:	6263      	str	r3, [r4, #36]	; 0x24
	instance->trigger_set_cb = trigger_set_cb;
   1c03e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1c040:	62a3      	str	r3, [r4, #40]	; 0x28
	instance->ticker_id_slot_previous = TICKER_NULL;
   1c042:	f64f 73ff 	movw	r3, #65535	; 0xffff
	instance->ticks_slot_previous = 0U;
   1c046:	e9c4 5505 	strd	r5, r5, [r4, #20]
	instance->ticker_id_slot_previous = TICKER_NULL;
   1c04a:	83a3      	strh	r3, [r4, #28]
	instance->ticks_elapsed_first = 0U;
   1c04c:	8165      	strh	r5, [r4, #10]
	return TICKER_STATUS_SUCCESS;
   1c04e:	4628      	mov	r0, r5
   1c050:	e7df      	b.n	1c012 <ticker_init+0xe>
		instance->nodes[count_node].priority = 0;
   1c052:	fb01 2e0c 	mla	lr, r1, ip, r2
   1c056:	f88e 0029 	strb.w	r0, [lr, #41]	; 0x29
   1c05a:	e7e0      	b.n	1c01e <ticker_init+0x1a>
		users[count_user].user_op = user_op_;
   1c05c:	b21a      	sxth	r2, r3
   1c05e:	eb06 01c2 	add.w	r1, r6, r2, lsl #3
   1c062:	604f      	str	r7, [r1, #4]
		user_op_ += users[count_user].count_user_op;
   1c064:	f816 0032 	ldrb.w	r0, [r6, r2, lsl #3]
   1c068:	eb00 0240 	add.w	r2, r0, r0, lsl #1
		count_op -= users[count_user].count_user_op;
   1c06c:	1a28      	subs	r0, r5, r0
		user_op_ += users[count_user].count_user_op;
   1c06e:	eb07 1702 	add.w	r7, r7, r2, lsl #4
		count_op -= users[count_user].count_user_op;
   1c072:	b2c5      	uxtb	r5, r0
   1c074:	e7d9      	b.n	1c02a <ticker_init+0x26>
   1c076:	bf00      	nop
   1c078:	20001d68 	.word	0x20001d68

0001c07c <ticker_is_initialized>:
	return !!(_instance[instance_index].count_node);
   1c07c:	4a04      	ldr	r2, [pc, #16]	; (1c090 <ticker_is_initialized+0x14>)
   1c07e:	232c      	movs	r3, #44	; 0x2c
   1c080:	fb03 2000 	mla	r0, r3, r0, r2
   1c084:	7a00      	ldrb	r0, [r0, #8]
}
   1c086:	3000      	adds	r0, #0
   1c088:	bf18      	it	ne
   1c08a:	2001      	movne	r0, #1
   1c08c:	4770      	bx	lr
   1c08e:	bf00      	nop
   1c090:	20001d68 	.word	0x20001d68

0001c094 <ticker_trigger>:
	if (instance->sched_cb) {
   1c094:	4a07      	ldr	r2, [pc, #28]	; (1c0b4 <ticker_trigger+0x20>)
   1c096:	232c      	movs	r3, #44	; 0x2c
   1c098:	fb03 2100 	mla	r1, r3, r0, r2
{
   1c09c:	b410      	push	{r4}
	if (instance->sched_cb) {
   1c09e:	6a4c      	ldr	r4, [r1, #36]	; 0x24
   1c0a0:	b134      	cbz	r4, 1c0b0 <ticker_trigger+0x1c>
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
   1c0a2:	460b      	mov	r3, r1
   1c0a4:	46a4      	mov	ip, r4
   1c0a6:	2201      	movs	r2, #1
   1c0a8:	2103      	movs	r1, #3
   1c0aa:	2002      	movs	r0, #2
}
   1c0ac:	bc10      	pop	{r4}
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
   1c0ae:	4760      	bx	ip
}
   1c0b0:	bc10      	pop	{r4}
   1c0b2:	4770      	bx	lr
   1c0b4:	20001d68 	.word	0x20001d68

0001c0b8 <ticker_start>:
{
   1c0b8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct ticker_instance *instance = &_instance[instance_index];
   1c0bc:	4c22      	ldr	r4, [pc, #136]	; (1c148 <ticker_start+0x90>)
   1c0be:	272c      	movs	r7, #44	; 0x2c
   1c0c0:	fb00 4907 	mla	r9, r0, r7, r4
	user = &instance->users[user_id];
   1c0c4:	b20d      	sxth	r5, r1
   1c0c6:	f8d9 0004 	ldr.w	r0, [r9, #4]
   1c0ca:	eb00 0cc5 	add.w	ip, r0, r5, lsl #3
	if (last >= user->count_user_op) {
   1c0ce:	f810 0035 	ldrb.w	r0, [r0, r5, lsl #3]
	last = user->last + 1;
   1c0d2:	f89c 4003 	ldrb.w	r4, [ip, #3]
   1c0d6:	1c66      	adds	r6, r4, #1
   1c0d8:	b2f6      	uxtb	r6, r6
		last = 0U;
   1c0da:	42b0      	cmp	r0, r6
   1c0dc:	bf98      	it	ls
   1c0de:	2600      	movls	r6, #0
	if (last == user->first) {
   1c0e0:	f89c 0001 	ldrb.w	r0, [ip, #1]
   1c0e4:	42b0      	cmp	r0, r6
   1c0e6:	d02d      	beq.n	1c144 <ticker_start+0x8c>
	user_op = &user->user_op[user->last];
   1c0e8:	f8dc 0004 	ldr.w	r0, [ip, #4]
   1c0ec:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   1c0f0:	0125      	lsls	r5, r4, #4
   1c0f2:	1944      	adds	r4, r0, r5
	user_op->op = TICKER_USER_OP_TYPE_START;
   1c0f4:	f04f 0804 	mov.w	r8, #4
   1c0f8:	f800 8005 	strb.w	r8, [r0, r5]
	user_op->params.start.ticks_at_start = ticks_anchor;
   1c0fc:	6063      	str	r3, [r4, #4]
	user_op->params.start.ticks_first = ticks_first;
   1c0fe:	9b08      	ldr	r3, [sp, #32]
   1c100:	60a3      	str	r3, [r4, #8]
	user_op->params.start.ticks_periodic = ticks_periodic;
   1c102:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1c104:	60e3      	str	r3, [r4, #12]
	user_op->params.start.remainder_periodic = remainder_periodic;
   1c106:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1c108:	6123      	str	r3, [r4, #16]
	user_op->params.start.ticks_slot = ticks_slot;
   1c10a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1c10c:	61a3      	str	r3, [r4, #24]
	user_op->params.start.lazy = lazy;
   1c10e:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
   1c112:	82a3      	strh	r3, [r4, #20]
	user_op->params.start.fp_timeout_func = fp_timeout_func;
   1c114:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1c116:	61e3      	str	r3, [r4, #28]
	user_op->params.start.context = context;
   1c118:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   1c11a:	6223      	str	r3, [r4, #32]
	user_op->status = TICKER_STATUS_BUSY;
   1c11c:	2302      	movs	r3, #2
   1c11e:	6263      	str	r3, [r4, #36]	; 0x24
	user_op->fp_op_func = fp_op_func;
   1c120:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1c122:	62a3      	str	r3, [r4, #40]	; 0x28
	user_op->op_context = op_context;
   1c124:	9b10      	ldr	r3, [sp, #64]	; 0x40
	user_op->id = ticker_id;
   1c126:	7062      	strb	r2, [r4, #1]
	user_op->op_context = op_context;
   1c128:	62e3      	str	r3, [r4, #44]	; 0x2c
	user->last = last;
   1c12a:	f88c 6003 	strb.w	r6, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   1c12e:	e9d9 3508 	ldrd	r3, r5, [r9, #32]
   1c132:	4608      	mov	r0, r1
   1c134:	4798      	blx	r3
   1c136:	464b      	mov	r3, r9
   1c138:	2200      	movs	r2, #0
   1c13a:	4641      	mov	r1, r8
   1c13c:	47a8      	blx	r5
	return user_op->status;
   1c13e:	6a60      	ldr	r0, [r4, #36]	; 0x24
}
   1c140:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return TICKER_STATUS_FAILURE;
   1c144:	2001      	movs	r0, #1
   1c146:	e7fb      	b.n	1c140 <ticker_start+0x88>
   1c148:	20001d68 	.word	0x20001d68

0001c14c <ticker_update>:
{
   1c14c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct ticker_instance *instance = &_instance[instance_index];
   1c150:	4c21      	ldr	r4, [pc, #132]	; (1c1d8 <ticker_update+0x8c>)
   1c152:	272c      	movs	r7, #44	; 0x2c
   1c154:	fb00 4807 	mla	r8, r0, r7, r4
	user = &instance->users[user_id];
   1c158:	b20d      	sxth	r5, r1
   1c15a:	f8d8 0004 	ldr.w	r0, [r8, #4]
   1c15e:	eb00 0cc5 	add.w	ip, r0, r5, lsl #3
	if (last >= user->count_user_op) {
   1c162:	f810 0035 	ldrb.w	r0, [r0, r5, lsl #3]
	last = user->last + 1;
   1c166:	f89c 4003 	ldrb.w	r4, [ip, #3]
   1c16a:	1c66      	adds	r6, r4, #1
   1c16c:	b2f6      	uxtb	r6, r6
		last = 0U;
   1c16e:	42b0      	cmp	r0, r6
   1c170:	bf98      	it	ls
   1c172:	2600      	movls	r6, #0
	if (last == user->first) {
   1c174:	f89c 0001 	ldrb.w	r0, [ip, #1]
   1c178:	42b0      	cmp	r0, r6
   1c17a:	d02a      	beq.n	1c1d2 <ticker_update+0x86>
	user_op = &user->user_op[user->last];
   1c17c:	f8dc 0004 	ldr.w	r0, [ip, #4]
   1c180:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   1c184:	0125      	lsls	r5, r4, #4
   1c186:	1944      	adds	r4, r0, r5
	user_op->op = TICKER_USER_OP_TYPE_UPDATE;
   1c188:	f04f 0e05 	mov.w	lr, #5
   1c18c:	f800 e005 	strb.w	lr, [r0, r5]
	user_op->params.update.ticks_drift_plus = ticks_drift_plus;
   1c190:	6063      	str	r3, [r4, #4]
	user_op->params.update.ticks_drift_minus = ticks_drift_minus;
   1c192:	9b06      	ldr	r3, [sp, #24]
   1c194:	60a3      	str	r3, [r4, #8]
	user_op->params.update.ticks_slot_plus = ticks_slot_plus;
   1c196:	9b07      	ldr	r3, [sp, #28]
   1c198:	60e3      	str	r3, [r4, #12]
	user_op->params.update.ticks_slot_minus = ticks_slot_minus;
   1c19a:	9b08      	ldr	r3, [sp, #32]
   1c19c:	6123      	str	r3, [r4, #16]
	user_op->params.update.lazy = lazy;
   1c19e:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
   1c1a2:	82a3      	strh	r3, [r4, #20]
	user_op->params.update.force = force;
   1c1a4:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
   1c1a8:	75a3      	strb	r3, [r4, #22]
	user_op->status = TICKER_STATUS_BUSY;
   1c1aa:	2302      	movs	r3, #2
   1c1ac:	6263      	str	r3, [r4, #36]	; 0x24
	user_op->fp_op_func = fp_op_func;
   1c1ae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1c1b0:	62a3      	str	r3, [r4, #40]	; 0x28
	user_op->op_context = op_context;
   1c1b2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	user_op->id = ticker_id;
   1c1b4:	7062      	strb	r2, [r4, #1]
	user_op->op_context = op_context;
   1c1b6:	62e3      	str	r3, [r4, #44]	; 0x2c
	user->last = last;
   1c1b8:	f88c 6003 	strb.w	r6, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   1c1bc:	e9d8 3508 	ldrd	r3, r5, [r8, #32]
   1c1c0:	4608      	mov	r0, r1
   1c1c2:	4798      	blx	r3
   1c1c4:	4643      	mov	r3, r8
   1c1c6:	2200      	movs	r2, #0
   1c1c8:	2104      	movs	r1, #4
   1c1ca:	47a8      	blx	r5
	return user_op->status;
   1c1cc:	6a60      	ldr	r0, [r4, #36]	; 0x24
}
   1c1ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
   1c1d2:	2001      	movs	r0, #1
   1c1d4:	e7fb      	b.n	1c1ce <ticker_update+0x82>
   1c1d6:	bf00      	nop
   1c1d8:	20001d68 	.word	0x20001d68

0001c1dc <ticker_stop>:
{
   1c1dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct ticker_instance *instance = &_instance[instance_index];
   1c1e0:	4c1a      	ldr	r4, [pc, #104]	; (1c24c <ticker_stop+0x70>)
   1c1e2:	262c      	movs	r6, #44	; 0x2c
   1c1e4:	fb00 4806 	mla	r8, r0, r6, r4
	user = &instance->users[user_id];
   1c1e8:	b20f      	sxth	r7, r1
   1c1ea:	f8d8 0004 	ldr.w	r0, [r8, #4]
   1c1ee:	eb00 0cc7 	add.w	ip, r0, r7, lsl #3
	if (last >= user->count_user_op) {
   1c1f2:	f810 0037 	ldrb.w	r0, [r0, r7, lsl #3]
	last = user->last + 1;
   1c1f6:	f89c 4003 	ldrb.w	r4, [ip, #3]
   1c1fa:	1c65      	adds	r5, r4, #1
   1c1fc:	b2ed      	uxtb	r5, r5
		last = 0U;
   1c1fe:	42a8      	cmp	r0, r5
   1c200:	bf98      	it	ls
   1c202:	2500      	movls	r5, #0
	if (last == user->first) {
   1c204:	f89c 0001 	ldrb.w	r0, [ip, #1]
   1c208:	42a8      	cmp	r0, r5
   1c20a:	d01c      	beq.n	1c246 <ticker_stop+0x6a>
	user_op = &user->user_op[user->last];
   1c20c:	f8dc 0004 	ldr.w	r0, [ip, #4]
   1c210:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   1c214:	0124      	lsls	r4, r4, #4
   1c216:	1907      	adds	r7, r0, r4
	user_op->op = TICKER_USER_OP_TYPE_STOP;
   1c218:	f04f 0e06 	mov.w	lr, #6
   1c21c:	f800 e004 	strb.w	lr, [r0, r4]
	user_op->id = ticker_id;
   1c220:	707a      	strb	r2, [r7, #1]
	user_op->status = TICKER_STATUS_BUSY;
   1c222:	2202      	movs	r2, #2
	user_op->fp_op_func = fp_op_func;
   1c224:	e9c7 2309 	strd	r2, r3, [r7, #36]	; 0x24
	user_op->op_context = op_context;
   1c228:	9b06      	ldr	r3, [sp, #24]
   1c22a:	62fb      	str	r3, [r7, #44]	; 0x2c
	user->last = last;
   1c22c:	f88c 5003 	strb.w	r5, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
   1c230:	e9d8 3408 	ldrd	r3, r4, [r8, #32]
   1c234:	4608      	mov	r0, r1
   1c236:	4798      	blx	r3
   1c238:	4643      	mov	r3, r8
   1c23a:	2200      	movs	r2, #0
   1c23c:	2104      	movs	r1, #4
   1c23e:	47a0      	blx	r4
	return user_op->status;
   1c240:	6a78      	ldr	r0, [r7, #36]	; 0x24
}
   1c242:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
   1c246:	2001      	movs	r0, #1
   1c248:	e7fb      	b.n	1c242 <ticker_stop+0x66>
   1c24a:	bf00      	nop
   1c24c:	20001d68 	.word	0x20001d68

0001c250 <ll_addr_get>:

static u8_t pub_addr[BDADDR_SIZE];
static u8_t rnd_addr[BDADDR_SIZE];

u8_t *ll_addr_get(u8_t addr_type, u8_t *bdaddr)
{
   1c250:	b508      	push	{r3, lr}
   1c252:	4603      	mov	r3, r0
	if (addr_type > 1) {
   1c254:	2b01      	cmp	r3, #1
{
   1c256:	4608      	mov	r0, r1
	if (addr_type > 1) {
   1c258:	d80e      	bhi.n	1c278 <ll_addr_get+0x28>
		return NULL;
	}

	if (addr_type) {
   1c25a:	b133      	cbz	r3, 1c26a <ll_addr_get+0x1a>
		if (bdaddr) {
   1c25c:	b119      	cbz	r1, 1c266 <ll_addr_get+0x16>
			memcpy(bdaddr, rnd_addr, BDADDR_SIZE);
   1c25e:	2206      	movs	r2, #6
   1c260:	4906      	ldr	r1, [pc, #24]	; (1c27c <ll_addr_get+0x2c>)
   1c262:	f00e f8f4 	bl	2a44e <memcpy>
		}

		return rnd_addr;
   1c266:	4805      	ldr	r0, [pc, #20]	; (1c27c <ll_addr_get+0x2c>)
   1c268:	e007      	b.n	1c27a <ll_addr_get+0x2a>
	}

	if (bdaddr) {
   1c26a:	b119      	cbz	r1, 1c274 <ll_addr_get+0x24>
		memcpy(bdaddr, pub_addr, BDADDR_SIZE);
   1c26c:	2206      	movs	r2, #6
   1c26e:	4904      	ldr	r1, [pc, #16]	; (1c280 <ll_addr_get+0x30>)
   1c270:	f00e f8ed 	bl	2a44e <memcpy>
	}

	return pub_addr;
   1c274:	4802      	ldr	r0, [pc, #8]	; (1c280 <ll_addr_get+0x30>)
   1c276:	e000      	b.n	1c27a <ll_addr_get+0x2a>
		return NULL;
   1c278:	2000      	movs	r0, #0
}
   1c27a:	bd08      	pop	{r3, pc}
   1c27c:	20003e1d 	.word	0x20003e1d
   1c280:	20003e17 	.word	0x20003e17

0001c284 <ll_addr_set>:

u32_t ll_addr_set(u8_t addr_type, u8_t const *const bdaddr)
{
   1c284:	b570      	push	{r4, r5, r6, lr}
   1c286:	4606      	mov	r6, r0
	if (IS_ENABLED(CONFIG_BT_BROADCASTER) &&
	    ull_adv_is_enabled(0)) {
   1c288:	2000      	movs	r0, #0
{
   1c28a:	460d      	mov	r5, r1
	    ull_adv_is_enabled(0)) {
   1c28c:	f00f fe25 	bl	2beda <ull_adv_is_enabled>
	if (IS_ENABLED(CONFIG_BT_BROADCASTER) &&
   1c290:	b110      	cbz	r0, 1c298 <ll_addr_set+0x14>
		return BT_HCI_ERR_CMD_DISALLOWED;
   1c292:	240c      	movs	r4, #12
	} else {
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
	}

	return 0;
}
   1c294:	4620      	mov	r0, r4
   1c296:	bd70      	pop	{r4, r5, r6, pc}
	    (ull_scan_is_enabled(0) & (BIT(1) | BIT(2)))) {
   1c298:	f00f ff0f 	bl	2c0ba <ull_scan_is_enabled>
	if (IS_ENABLED(CONFIG_BT_OBSERVER) &&
   1c29c:	f010 0406 	ands.w	r4, r0, #6
   1c2a0:	d1f7      	bne.n	1c292 <ll_addr_set+0xe>
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
   1c2a2:	2206      	movs	r2, #6
   1c2a4:	4629      	mov	r1, r5
	if (addr_type) {
   1c2a6:	b11e      	cbz	r6, 1c2b0 <ll_addr_set+0x2c>
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
   1c2a8:	4802      	ldr	r0, [pc, #8]	; (1c2b4 <ll_addr_set+0x30>)
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
   1c2aa:	f00e f8d0 	bl	2a44e <memcpy>
   1c2ae:	e7f1      	b.n	1c294 <ll_addr_set+0x10>
   1c2b0:	4801      	ldr	r0, [pc, #4]	; (1c2b8 <ll_addr_set+0x34>)
   1c2b2:	e7fa      	b.n	1c2aa <ll_addr_set+0x26>
   1c2b4:	20003e1d 	.word	0x20003e1d
   1c2b8:	20003e17 	.word	0x20003e17

0001c2bc <hci_driver_init>:
	.open	= hci_driver_open,
	.send	= hci_driver_send,
};

static int hci_driver_init(struct device *unused)
{
   1c2bc:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	bt_hci_driver_register(&drv);
   1c2be:	4802      	ldr	r0, [pc, #8]	; (1c2c8 <hci_driver_init+0xc>)
   1c2c0:	f7fa fb72 	bl	169a8 <bt_hci_driver_register>

	return 0;
}
   1c2c4:	2000      	movs	r0, #0
   1c2c6:	bd08      	pop	{r3, pc}
   1c2c8:	0002e764 	.word	0x0002e764

0001c2cc <hci_driver_send>:
	if (!buf->len) {
   1c2cc:	8983      	ldrh	r3, [r0, #12]
{
   1c2ce:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1c2d0:	4605      	mov	r5, r0
	if (!buf->len) {
   1c2d2:	b9a3      	cbnz	r3, 1c2fe <hci_driver_send+0x32>
		BT_ERR("Empty HCI packet");
   1c2d4:	4b27      	ldr	r3, [pc, #156]	; (1c374 <hci_driver_send+0xa8>)
   1c2d6:	681b      	ldr	r3, [r3, #0]
   1c2d8:	075a      	lsls	r2, r3, #29
   1c2da:	d00d      	beq.n	1c2f8 <hci_driver_send+0x2c>
   1c2dc:	2301      	movs	r3, #1
   1c2de:	f04f 0100 	mov.w	r1, #0
   1c2e2:	f363 0107 	bfi	r1, r3, #0, #8
   1c2e6:	4a24      	ldr	r2, [pc, #144]	; (1c378 <hci_driver_send+0xac>)
   1c2e8:	4b24      	ldr	r3, [pc, #144]	; (1c37c <hci_driver_send+0xb0>)
   1c2ea:	4825      	ldr	r0, [pc, #148]	; (1c380 <hci_driver_send+0xb4>)
   1c2ec:	1a9b      	subs	r3, r3, r2
   1c2ee:	08db      	lsrs	r3, r3, #3
   1c2f0:	f363 118f 	bfi	r1, r3, #6, #10
   1c2f4:	f00c fb21 	bl	2893a <log_0>
   1c2f8:	f06f 0415 	mvn.w	r4, #21
   1c2fc:	e010      	b.n	1c320 <hci_driver_send+0x54>
	return (enum bt_buf_type)(*(u8_t *)net_buf_user_data(buf));
   1c2fe:	7d01      	ldrb	r1, [r0, #20]
	switch (type) {
   1c300:	b189      	cbz	r1, 1c326 <hci_driver_send+0x5a>
   1c302:	2902      	cmp	r1, #2
   1c304:	d123      	bne.n	1c34e <hci_driver_send+0x82>
	err = hci_acl_handle(buf, &evt);
   1c306:	a901      	add	r1, sp, #4
   1c308:	f000 ff80 	bl	1d20c <hci_acl_handle>
   1c30c:	4604      	mov	r4, r0
	if (evt) {
   1c30e:	9801      	ldr	r0, [sp, #4]
   1c310:	b108      	cbz	r0, 1c316 <hci_driver_send+0x4a>
		bt_recv_prio(evt);
   1c312:	f7fa fb03 	bl	1691c <bt_recv_prio>
	if (!err) {
   1c316:	b91c      	cbnz	r4, 1c320 <hci_driver_send+0x54>
		net_buf_unref(buf);
   1c318:	4628      	mov	r0, r5
   1c31a:	f008 ffd7 	bl	252cc <net_buf_unref>
   1c31e:	2400      	movs	r4, #0
}
   1c320:	4620      	mov	r0, r4
   1c322:	b003      	add	sp, #12
   1c324:	bd30      	pop	{r4, r5, pc}
	struct node_rx_pdu *node_rx = NULL;
   1c326:	9101      	str	r1, [sp, #4]
	evt = hci_cmd_handle(buf, (void **) &node_rx);
   1c328:	a901      	add	r1, sp, #4
   1c32a:	f000 fb19 	bl	1c960 <hci_cmd_handle>
	if (evt) {
   1c32e:	2800      	cmp	r0, #0
   1c330:	d0f2      	beq.n	1c318 <hci_driver_send+0x4c>
		bt_recv_prio(evt);
   1c332:	f7fa faf3 	bl	1691c <bt_recv_prio>
		if (node_rx) {
   1c336:	9c01      	ldr	r4, [sp, #4]
   1c338:	2c00      	cmp	r4, #0
   1c33a:	d0ed      	beq.n	1c318 <hci_driver_send+0x4c>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
   1c33c:	4620      	mov	r0, r4
   1c33e:	f00f fcf5 	bl	2bd2c <hci_get_class>
   1c342:	7160      	strb	r0, [r4, #5]
			k_fifo_put(&recv_fifo, node_rx);
   1c344:	9901      	ldr	r1, [sp, #4]
   1c346:	480f      	ldr	r0, [pc, #60]	; (1c384 <hci_driver_send+0xb8>)
   1c348:	f010 fedb 	bl	2d102 <k_queue_append>
	if (!err) {
   1c34c:	e7e4      	b.n	1c318 <hci_driver_send+0x4c>
		BT_ERR("Unknown HCI type %u", type);
   1c34e:	4b09      	ldr	r3, [pc, #36]	; (1c374 <hci_driver_send+0xa8>)
   1c350:	681b      	ldr	r3, [r3, #0]
   1c352:	075b      	lsls	r3, r3, #29
   1c354:	d0d0      	beq.n	1c2f8 <hci_driver_send+0x2c>
   1c356:	2301      	movs	r3, #1
   1c358:	f04f 0200 	mov.w	r2, #0
   1c35c:	f363 0207 	bfi	r2, r3, #0, #8
   1c360:	4805      	ldr	r0, [pc, #20]	; (1c378 <hci_driver_send+0xac>)
   1c362:	4b06      	ldr	r3, [pc, #24]	; (1c37c <hci_driver_send+0xb0>)
   1c364:	1a1b      	subs	r3, r3, r0
   1c366:	08db      	lsrs	r3, r3, #3
   1c368:	f363 128f 	bfi	r2, r3, #6, #10
   1c36c:	4806      	ldr	r0, [pc, #24]	; (1c388 <hci_driver_send+0xbc>)
   1c36e:	f00c faf1 	bl	28954 <log_1>
   1c372:	e7c1      	b.n	1c2f8 <hci_driver_send+0x2c>
   1c374:	2000ffbc 	.word	0x2000ffbc
   1c378:	0002db28 	.word	0x0002db28
   1c37c:	0002db70 	.word	0x0002db70
   1c380:	000314d0 	.word	0x000314d0
   1c384:	200100f8 	.word	0x200100f8
   1c388:	000314e1 	.word	0x000314e1

0001c38c <recv_thread>:
{
   1c38c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return z_impl_k_queue_get(queue, timeout);
   1c38e:	4d25      	ldr	r5, [pc, #148]	; (1c424 <recv_thread+0x98>)
		LL_ASSERT(0);
   1c390:	4e25      	ldr	r6, [pc, #148]	; (1c428 <recv_thread+0x9c>)
   1c392:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1c396:	4628      	mov	r0, r5
   1c398:	f010 fedc 	bl	2d154 <z_impl_k_queue_get>
		if (node_rx && !buf) {
   1c39c:	b350      	cbz	r0, 1c3f4 <recv_thread+0x68>
	u8_t class = node_rx->hdr.user_meta;
   1c39e:	7943      	ldrb	r3, [r0, #5]
	buf = encode_node(node_rx, class);
   1c3a0:	9001      	str	r0, [sp, #4]
	switch (class) {
   1c3a2:	b11b      	cbz	r3, 1c3ac <recv_thread+0x20>
   1c3a4:	2b04      	cmp	r3, #4
   1c3a6:	d90c      	bls.n	1c3c2 <recv_thread+0x36>
   1c3a8:	2b05      	cmp	r3, #5
   1c3aa:	d02c      	beq.n	1c406 <recv_thread+0x7a>
		LL_ASSERT(0);
   1c3ac:	4630      	mov	r0, r6
   1c3ae:	f00b fec9 	bl	28144 <printk>
   1c3b2:	4040      	eors	r0, r0
   1c3b4:	f380 8811 	msr	BASEPRI, r0
   1c3b8:	f04f 0003 	mov.w	r0, #3
   1c3bc:	df02      	svc	2
	struct net_buf *buf = NULL;
   1c3be:	2400      	movs	r4, #0
   1c3c0:	e00c      	b.n	1c3dc <recv_thread+0x50>
		if (class == HCI_CLASS_EVT_DISCARDABLE) {
   1c3c2:	2b02      	cmp	r3, #2
   1c3c4:	d119      	bne.n	1c3fa <recv_thread+0x6e>
			buf = bt_buf_get_evt(BT_HCI_EVT_UNKNOWN, true,
   1c3c6:	2200      	movs	r2, #0
   1c3c8:	2101      	movs	r1, #1
   1c3ca:	4610      	mov	r0, r2
   1c3cc:	f7fb fa0a 	bl	177e4 <bt_buf_get_evt>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   1c3d0:	4604      	mov	r4, r0
		if (buf) {
   1c3d2:	b118      	cbz	r0, 1c3dc <recv_thread+0x50>
			hci_evt_encode(node_rx, buf);
   1c3d4:	4601      	mov	r1, r0
   1c3d6:	9801      	ldr	r0, [sp, #4]
   1c3d8:	f001 f800 	bl	1d3dc <hci_evt_encode>
	node_rx->hdr.next = NULL;
   1c3dc:	9b01      	ldr	r3, [sp, #4]
   1c3de:	2200      	movs	r2, #0
   1c3e0:	601a      	str	r2, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
   1c3e2:	a801      	add	r0, sp, #4
   1c3e4:	f001 fe42 	bl	1e06c <ll_rx_mem_release>
		if (buf) {
   1c3e8:	b124      	cbz	r4, 1c3f4 <recv_thread+0x68>
			if (buf->len) {
   1c3ea:	89a3      	ldrh	r3, [r4, #12]
				bt_recv(buf);
   1c3ec:	4620      	mov	r0, r4
			if (buf->len) {
   1c3ee:	b1ab      	cbz	r3, 1c41c <recv_thread+0x90>
				bt_recv(buf);
   1c3f0:	f7fa f9e0 	bl	167b4 <bt_recv>
	z_impl_k_yield();
   1c3f4:	f00a fe0e 	bl	27014 <z_impl_k_yield>
   1c3f8:	e7cb      	b.n	1c392 <recv_thread+0x6>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   1c3fa:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1c3fe:	2001      	movs	r0, #1
   1c400:	f7fb f9ba 	bl	17778 <bt_buf_get_rx>
   1c404:	e7e4      	b.n	1c3d0 <recv_thread+0x44>
		buf = bt_buf_get_rx(BT_BUF_ACL_IN, K_FOREVER);
   1c406:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1c40a:	2003      	movs	r0, #3
   1c40c:	f7fb f9b4 	bl	17778 <bt_buf_get_rx>
   1c410:	4604      	mov	r4, r0
		hci_acl_encode(node_rx, buf);
   1c412:	4601      	mov	r1, r0
   1c414:	9801      	ldr	r0, [sp, #4]
   1c416:	f000 ffab 	bl	1d370 <hci_acl_encode>
		break;
   1c41a:	e7df      	b.n	1c3dc <recv_thread+0x50>
				net_buf_unref(buf);
   1c41c:	f008 ff56 	bl	252cc <net_buf_unref>
   1c420:	e7e8      	b.n	1c3f4 <recv_thread+0x68>
   1c422:	bf00      	nop
   1c424:	200100f8 	.word	0x200100f8
   1c428:	000314f5 	.word	0x000314f5

0001c42c <prio_recv_thread>:
{
   1c42c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	return z_impl_k_sem_take(sem, timeout);
   1c42e:	4d17      	ldr	r5, [pc, #92]	; (1c48c <prio_recv_thread+0x60>)
				k_fifo_put(&recv_fifo, node_rx);
   1c430:	4e17      	ldr	r6, [pc, #92]	; (1c490 <prio_recv_thread+0x64>)
		while ((num_cmplt = ll_rx_get((void *)&node_rx, &handle))) {
   1c432:	f10d 0102 	add.w	r1, sp, #2
   1c436:	a801      	add	r0, sp, #4
   1c438:	f001 fdc0 	bl	1dfbc <ll_rx_get>
   1c43c:	4604      	mov	r4, r0
   1c43e:	b968      	cbnz	r0, 1c45c <prio_recv_thread+0x30>
		if (node_rx) {
   1c440:	9b01      	ldr	r3, [sp, #4]
   1c442:	b1eb      	cbz	r3, 1c480 <prio_recv_thread+0x54>
			ll_rx_dequeue();
   1c444:	f001 feec 	bl	1e220 <ll_rx_dequeue>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
   1c448:	9c01      	ldr	r4, [sp, #4]
   1c44a:	4620      	mov	r0, r4
   1c44c:	f00f fc6e 	bl	2bd2c <hci_get_class>
				k_fifo_put(&recv_fifo, node_rx);
   1c450:	9901      	ldr	r1, [sp, #4]
			node_rx->hdr.user_meta = hci_get_class(node_rx);
   1c452:	7160      	strb	r0, [r4, #5]
				k_fifo_put(&recv_fifo, node_rx);
   1c454:	4630      	mov	r0, r6
   1c456:	f010 fe54 	bl	2d102 <k_queue_append>
			continue;
   1c45a:	e7ea      	b.n	1c432 <prio_recv_thread+0x6>
			buf = bt_buf_get_evt(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
   1c45c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1c460:	2100      	movs	r1, #0
   1c462:	2013      	movs	r0, #19
   1c464:	f7fb f9be 	bl	177e4 <bt_buf_get_evt>
			hci_num_cmplt_encode(buf, handle, num_cmplt);
   1c468:	4622      	mov	r2, r4
			buf = bt_buf_get_evt(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
   1c46a:	4607      	mov	r7, r0
			hci_num_cmplt_encode(buf, handle, num_cmplt);
   1c46c:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   1c470:	f00f fc48 	bl	2bd04 <hci_num_cmplt_encode>
			bt_recv_prio(buf);
   1c474:	4638      	mov	r0, r7
   1c476:	f7fa fa51 	bl	1691c <bt_recv_prio>
	z_impl_k_yield();
   1c47a:	f00a fdcb 	bl	27014 <z_impl_k_yield>
   1c47e:	e7d8      	b.n	1c432 <prio_recv_thread+0x6>
	return z_impl_k_sem_take(sem, timeout);
   1c480:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1c484:	4628      	mov	r0, r5
   1c486:	f00a fe6b 	bl	27160 <z_impl_k_sem_take>
		BT_DBG("sem taken");
   1c48a:	e7d2      	b.n	1c432 <prio_recv_thread+0x6>
   1c48c:	200100bc 	.word	0x200100bc
   1c490:	200100f8 	.word	0x200100f8

0001c494 <hci_driver_open>:
{
   1c494:	b510      	push	{r4, lr}
	err = ll_init(&sem_prio_recv);
   1c496:	4822      	ldr	r0, [pc, #136]	; (1c520 <hci_driver_open+0x8c>)
{
   1c498:	b086      	sub	sp, #24
	err = ll_init(&sem_prio_recv);
   1c49a:	f001 fc9d 	bl	1ddd8 <ll_init>
	if (err) {
   1c49e:	4604      	mov	r4, r0
   1c4a0:	b1a8      	cbz	r0, 1c4ce <hci_driver_open+0x3a>
		BT_ERR("LL initialization failed: %u", err);
   1c4a2:	4b20      	ldr	r3, [pc, #128]	; (1c524 <hci_driver_open+0x90>)
   1c4a4:	681b      	ldr	r3, [r3, #0]
   1c4a6:	075b      	lsls	r3, r3, #29
   1c4a8:	d00e      	beq.n	1c4c8 <hci_driver_open+0x34>
   1c4aa:	2301      	movs	r3, #1
   1c4ac:	f04f 0200 	mov.w	r2, #0
   1c4b0:	f363 0207 	bfi	r2, r3, #0, #8
   1c4b4:	491c      	ldr	r1, [pc, #112]	; (1c528 <hci_driver_open+0x94>)
   1c4b6:	4b1d      	ldr	r3, [pc, #116]	; (1c52c <hci_driver_open+0x98>)
   1c4b8:	1a5b      	subs	r3, r3, r1
   1c4ba:	08db      	lsrs	r3, r3, #3
   1c4bc:	4601      	mov	r1, r0
   1c4be:	f363 128f 	bfi	r2, r3, #6, #10
   1c4c2:	481b      	ldr	r0, [pc, #108]	; (1c530 <hci_driver_open+0x9c>)
   1c4c4:	f00c fa46 	bl	28954 <log_1>
}
   1c4c8:	4620      	mov	r0, r4
   1c4ca:	b006      	add	sp, #24
   1c4cc:	bd10      	pop	{r4, pc}
	hci_init(NULL);
   1c4ce:	f001 fab3 	bl	1da38 <hci_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   1c4d2:	f06f 0309 	mvn.w	r3, #9
   1c4d6:	e9cd 4302 	strd	r4, r3, [sp, #8]
   1c4da:	e9cd 4404 	strd	r4, r4, [sp, #16]
   1c4de:	e9cd 4400 	strd	r4, r4, [sp]
   1c4e2:	4b14      	ldr	r3, [pc, #80]	; (1c534 <hci_driver_open+0xa0>)
   1c4e4:	4914      	ldr	r1, [pc, #80]	; (1c538 <hci_driver_open+0xa4>)
   1c4e6:	4815      	ldr	r0, [pc, #84]	; (1c53c <hci_driver_open+0xa8>)
   1c4e8:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
   1c4ec:	f00a feb0 	bl	27250 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
   1c4f0:	4913      	ldr	r1, [pc, #76]	; (1c540 <hci_driver_open+0xac>)
   1c4f2:	4812      	ldr	r0, [pc, #72]	; (1c53c <hci_driver_open+0xa8>)
   1c4f4:	f010 ff9b 	bl	2d42e <z_impl_k_thread_name_set>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   1c4f8:	f06f 0307 	mvn.w	r3, #7
   1c4fc:	e9cd 4302 	strd	r4, r3, [sp, #8]
   1c500:	e9cd 4404 	strd	r4, r4, [sp, #16]
   1c504:	e9cd 4400 	strd	r4, r4, [sp]
   1c508:	4b0e      	ldr	r3, [pc, #56]	; (1c544 <hci_driver_open+0xb0>)
   1c50a:	490f      	ldr	r1, [pc, #60]	; (1c548 <hci_driver_open+0xb4>)
   1c50c:	480f      	ldr	r0, [pc, #60]	; (1c54c <hci_driver_open+0xb8>)
   1c50e:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1c512:	f00a fe9d 	bl	27250 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
   1c516:	490e      	ldr	r1, [pc, #56]	; (1c550 <hci_driver_open+0xbc>)
   1c518:	480c      	ldr	r0, [pc, #48]	; (1c54c <hci_driver_open+0xb8>)
   1c51a:	f010 ff88 	bl	2d42e <z_impl_k_thread_name_set>
	return 0;
   1c51e:	e7d3      	b.n	1c4c8 <hci_driver_open+0x34>
   1c520:	200100bc 	.word	0x200100bc
   1c524:	2000ffbc 	.word	0x2000ffbc
   1c528:	0002db28 	.word	0x0002db28
   1c52c:	0002db70 	.word	0x0002db70
   1c530:	000314a3 	.word	0x000314a3
   1c534:	0001c42d 	.word	0x0001c42d
   1c538:	20006f10 	.word	0x20006f10
   1c53c:	20001d94 	.word	0x20001d94
   1c540:	000314c0 	.word	0x000314c0
   1c544:	0001c38d 	.word	0x0001c38d
   1c548:	200070d0 	.word	0x200070d0
   1c54c:	20001e00 	.word	0x20001e00
   1c550:	000314ca 	.word	0x000314ca

0001c554 <dup_found>:
}
#endif /* CONFIG_BT_CONN */

#if CONFIG_BT_CTLR_DUP_FILTER_LEN > 0
static inline bool dup_found(struct pdu_adv *adv)
{
   1c554:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	/* check for duplicate filtering */
	if (dup_count >= 0) {
   1c558:	4d2c      	ldr	r5, [pc, #176]	; (1c60c <dup_found+0xb8>)
   1c55a:	682b      	ldr	r3, [r5, #0]
   1c55c:	2b00      	cmp	r3, #0
{
   1c55e:	4680      	mov	r8, r0
	if (dup_count >= 0) {
   1c560:	db4e      	blt.n	1c600 <dup_found+0xac>
   1c562:	4f2b      	ldr	r7, [pc, #172]	; (1c610 <dup_found+0xbc>)
		int i;

		for (i = 0; i < dup_count; i++) {
   1c564:	2400      	movs	r4, #0
   1c566:	463e      	mov	r6, r7
   1c568:	f100 0902 	add.w	r9, r0, #2
   1c56c:	682b      	ldr	r3, [r5, #0]
   1c56e:	42a3      	cmp	r3, r4
   1c570:	dc27      	bgt.n	1c5c2 <dup_found+0x6e>
				return false;
			}
		}

		/* insert into the duplicate filter */
		memcpy(&dup_filter[dup_curr].addr.a.val[0],
   1c572:	4c28      	ldr	r4, [pc, #160]	; (1c614 <dup_found+0xc0>)
   1c574:	6820      	ldr	r0, [r4, #0]
   1c576:	eb06 00c0 	add.w	r0, r6, r0, lsl #3
   1c57a:	2206      	movs	r2, #6
   1c57c:	4649      	mov	r1, r9
   1c57e:	3002      	adds	r0, #2
   1c580:	f00d ff65 	bl	2a44e <memcpy>
		       &adv->adv_ind.addr[0], sizeof(bt_addr_t));
		dup_filter[dup_curr].addr.type = adv->tx_addr;
   1c584:	6822      	ldr	r2, [r4, #0]
   1c586:	f898 3000 	ldrb.w	r3, [r8]
   1c58a:	eb06 01c2 	add.w	r1, r6, r2, lsl #3
   1c58e:	f3c3 1380 	ubfx	r3, r3, #6, #1
   1c592:	704b      	strb	r3, [r1, #1]
		dup_filter[dup_curr].mask = BIT(adv->type);
   1c594:	f898 3000 	ldrb.w	r3, [r8]
   1c598:	f003 010f 	and.w	r1, r3, #15
   1c59c:	2301      	movs	r3, #1
   1c59e:	408b      	lsls	r3, r1

		if (dup_count < CONFIG_BT_CTLR_DUP_FILTER_LEN) {
   1c5a0:	6829      	ldr	r1, [r5, #0]
		dup_filter[dup_curr].mask = BIT(adv->type);
   1c5a2:	f806 3032 	strb.w	r3, [r6, r2, lsl #3]
		if (dup_count < CONFIG_BT_CTLR_DUP_FILTER_LEN) {
   1c5a6:	290f      	cmp	r1, #15
			dup_count++;
   1c5a8:	bfd5      	itete	le
   1c5aa:	3101      	addle	r1, #1
			dup_curr = dup_count;
		} else {
			dup_curr++;
   1c5ac:	3201      	addgt	r2, #1
			dup_curr = dup_count;
   1c5ae:	6021      	strle	r1, [r4, #0]
			dup_curr++;
   1c5b0:	6022      	strgt	r2, [r4, #0]
		}

		if (dup_curr == CONFIG_BT_CTLR_DUP_FILTER_LEN) {
   1c5b2:	6822      	ldr	r2, [r4, #0]
			dup_count++;
   1c5b4:	bfd8      	it	le
   1c5b6:	6029      	strle	r1, [r5, #0]
		if (dup_curr == CONFIG_BT_CTLR_DUP_FILTER_LEN) {
   1c5b8:	2a10      	cmp	r2, #16
   1c5ba:	d121      	bne.n	1c600 <dup_found+0xac>
			dup_curr = 0U;
   1c5bc:	2000      	movs	r0, #0
   1c5be:	6020      	str	r0, [r4, #0]
   1c5c0:	e01f      	b.n	1c602 <dup_found+0xae>
			if (!memcmp(&adv->adv_ind.addr[0],
   1c5c2:	2206      	movs	r2, #6
   1c5c4:	1cb9      	adds	r1, r7, #2
   1c5c6:	4648      	mov	r0, r9
   1c5c8:	f00d ff1a 	bl	2a400 <memcmp>
   1c5cc:	b9d8      	cbnz	r0, 1c606 <dup_found+0xb2>
			    adv->tx_addr == dup_filter[i].addr.type) {
   1c5ce:	f898 2000 	ldrb.w	r2, [r8]
   1c5d2:	7879      	ldrb	r1, [r7, #1]
   1c5d4:	4613      	mov	r3, r2
   1c5d6:	f3c2 1280 	ubfx	r2, r2, #6, #1
				    sizeof(bt_addr_t)) &&
   1c5da:	428a      	cmp	r2, r1
   1c5dc:	d113      	bne.n	1c606 <dup_found+0xb2>
				if (dup_filter[i].mask & BIT(adv->type)) {
   1c5de:	f816 1034 	ldrb.w	r1, [r6, r4, lsl #3]
   1c5e2:	f003 030f 	and.w	r3, r3, #15
   1c5e6:	fa21 f203 	lsr.w	r2, r1, r3
   1c5ea:	f012 0201 	ands.w	r2, r2, #1
   1c5ee:	f04f 0001 	mov.w	r0, #1
   1c5f2:	d106      	bne.n	1c602 <dup_found+0xae>
				dup_filter[i].mask |= BIT(adv->type);
   1c5f4:	fa00 f303 	lsl.w	r3, r0, r3
   1c5f8:	ea41 0003 	orr.w	r0, r1, r3
   1c5fc:	f806 0034 	strb.w	r0, [r6, r4, lsl #3]
		}
	}

	return false;
   1c600:	2000      	movs	r0, #0
}
   1c602:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		for (i = 0; i < dup_count; i++) {
   1c606:	3401      	adds	r4, #1
   1c608:	3708      	adds	r7, #8
   1c60a:	e7af      	b.n	1c56c <dup_found+0x18>
   1c60c:	20001e70 	.word	0x20001e70
   1c610:	20003e23 	.word	0x20003e23
   1c614:	20001e74 	.word	0x20001e74

0001c618 <cmd_status>:
{
   1c618:	b538      	push	{r3, r4, r5, lr}
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   1c61a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
   1c61e:	4605      	mov	r5, r0
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   1c620:	2100      	movs	r1, #0
   1c622:	200f      	movs	r0, #15
   1c624:	f7fb f8de 	bl	177e4 <bt_buf_get_evt>
	hci_evt_create(buf, BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
   1c628:	2204      	movs	r2, #4
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
   1c62a:	4604      	mov	r4, r0
	hci_evt_create(buf, BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
   1c62c:	210f      	movs	r1, #15
   1c62e:	f00f fb4a 	bl	2bcc6 <hci_evt_create>
	cs = net_buf_add(buf, sizeof(*cs));
   1c632:	2104      	movs	r1, #4
   1c634:	f104 0008 	add.w	r0, r4, #8
   1c638:	f010 faa2 	bl	2cb80 <net_buf_simple_add>
	cs->ncmd = 1U;
   1c63c:	2301      	movs	r3, #1
   1c63e:	7043      	strb	r3, [r0, #1]
	cs->opcode = sys_cpu_to_le16(_opcode);
   1c640:	4b02      	ldr	r3, [pc, #8]	; (1c64c <cmd_status+0x34>)
	cs->status = status;
   1c642:	7005      	strb	r5, [r0, #0]
	cs->opcode = sys_cpu_to_le16(_opcode);
   1c644:	881b      	ldrh	r3, [r3, #0]
   1c646:	8043      	strh	r3, [r0, #2]
}
   1c648:	4620      	mov	r0, r4
   1c64a:	bd38      	pop	{r3, r4, r5, pc}
   1c64c:	20003cf2 	.word	0x20003cf2

0001c650 <le_remote_feat_complete>:
}
#endif /* CONFIG_BT_CTLR_LE_ENC */

static void le_remote_feat_complete(u8_t status, struct pdu_data *pdu_data,
				    u16_t handle, struct net_buf *buf)
{
   1c650:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1c652:	4605      	mov	r5, r0
   1c654:	4618      	mov	r0, r3
	struct bt_hci_evt_le_remote_feat_complete *sep;

	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1c656:	4b13      	ldr	r3, [pc, #76]	; (1c6a4 <le_remote_feat_complete+0x54>)
{
   1c658:	460e      	mov	r6, r1
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1c65a:	6859      	ldr	r1, [r3, #4]
   1c65c:	2400      	movs	r4, #0
{
   1c65e:	4617      	mov	r7, r2
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1c660:	f001 5300 	and.w	r3, r1, #536870912	; 0x20000000
   1c664:	4622      	mov	r2, r4
   1c666:	4313      	orrs	r3, r2
   1c668:	d01a      	beq.n	1c6a0 <le_remote_feat_complete+0x50>
	    !(le_event_mask & BT_EVT_MASK_LE_REMOTE_FEAT_COMPLETE)) {
   1c66a:	4b0f      	ldr	r3, [pc, #60]	; (1c6a8 <le_remote_feat_complete+0x58>)
   1c66c:	6819      	ldr	r1, [r3, #0]
   1c66e:	4623      	mov	r3, r4
   1c670:	f001 0208 	and.w	r2, r1, #8
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1c674:	4313      	orrs	r3, r2
   1c676:	d013      	beq.n	1c6a0 <le_remote_feat_complete+0x50>
		return;
	}

	sep = meta_evt(buf, BT_HCI_EV_LE_REMOTE_FEAT_COMPLETE, sizeof(*sep));
   1c678:	220b      	movs	r2, #11
   1c67a:	2104      	movs	r1, #4
   1c67c:	f00f fb2d 	bl	2bcda <meta_evt>

	sep->status = status;
	sep->handle = sys_cpu_to_le16(handle);
	if (!status) {
		memcpy(&sep->features[0],
   1c680:	2208      	movs	r2, #8
	sep->status = status;
   1c682:	7005      	strb	r5, [r0, #0]
	sep->handle = sys_cpu_to_le16(handle);
   1c684:	f8a0 7001 	strh.w	r7, [r0, #1]
	if (!status) {
   1c688:	3003      	adds	r0, #3
   1c68a:	b925      	cbnz	r5, 1c696 <le_remote_feat_complete+0x46>
		memcpy(&sep->features[0],
   1c68c:	1d31      	adds	r1, r6, #4
		       &pdu_data->llctrl.feature_rsp.features[0],
		       sizeof(sep->features));
	} else {
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
	}
}
   1c68e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		memcpy(&sep->features[0],
   1c692:	f00d bedc 	b.w	2a44e <memcpy>
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
   1c696:	4621      	mov	r1, r4
}
   1c698:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
   1c69c:	f00d bf01 	b.w	2a4a2 <memset>
}
   1c6a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1c6a2:	bf00      	nop
   1c6a4:	2000f7f8 	.word	0x2000f7f8
   1c6a8:	2000f800 	.word	0x2000f800

0001c6ac <encrypt_change>:
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
   1c6ac:	4b0e      	ldr	r3, [pc, #56]	; (1c6e8 <encrypt_change+0x3c>)
{
   1c6ae:	b570      	push	{r4, r5, r6, lr}
   1c6b0:	460e      	mov	r6, r1
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
   1c6b2:	6819      	ldr	r1, [r3, #0]
{
   1c6b4:	4615      	mov	r5, r2
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
   1c6b6:	2300      	movs	r3, #0
   1c6b8:	f001 0280 	and.w	r2, r1, #128	; 0x80
   1c6bc:	4313      	orrs	r3, r2
{
   1c6be:	4604      	mov	r4, r0
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
   1c6c0:	d010      	beq.n	1c6e4 <encrypt_change+0x38>
	hci_evt_create(buf, BT_HCI_EVT_ENCRYPT_CHANGE, sizeof(*ep));
   1c6c2:	2204      	movs	r2, #4
   1c6c4:	2108      	movs	r1, #8
   1c6c6:	4628      	mov	r0, r5
   1c6c8:	f00f fafd 	bl	2bcc6 <hci_evt_create>
	ep = net_buf_add(buf, sizeof(*ep));
   1c6cc:	2104      	movs	r1, #4
   1c6ce:	f105 0008 	add.w	r0, r5, #8
   1c6d2:	f010 fa55 	bl	2cb80 <net_buf_simple_add>
	ep->encrypt = !err ? 1 : 0;
   1c6d6:	fab4 f384 	clz	r3, r4
   1c6da:	095b      	lsrs	r3, r3, #5
	ep->status = err;
   1c6dc:	7004      	strb	r4, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
   1c6de:	f8a0 6001 	strh.w	r6, [r0, #1]
	ep->encrypt = !err ? 1 : 0;
   1c6e2:	70c3      	strb	r3, [r0, #3]
}
   1c6e4:	bd70      	pop	{r4, r5, r6, pc}
   1c6e6:	bf00      	nop
   1c6e8:	2000f7f8 	.word	0x2000f7f8

0001c6ec <hci_cmd_complete>:
{
   1c6ec:	b538      	push	{r3, r4, r5, lr}
	*buf = bt_buf_get_evt(BT_HCI_EVT_CMD_COMPLETE, false, K_FOREVER);
   1c6ee:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
{
   1c6f2:	4604      	mov	r4, r0
   1c6f4:	460d      	mov	r5, r1
	*buf = bt_buf_get_evt(BT_HCI_EVT_CMD_COMPLETE, false, K_FOREVER);
   1c6f6:	200e      	movs	r0, #14
   1c6f8:	2100      	movs	r1, #0
   1c6fa:	f7fb f873 	bl	177e4 <bt_buf_get_evt>
	hci_evt_create(*buf, BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
   1c6fe:	1cea      	adds	r2, r5, #3
	*buf = bt_buf_get_evt(BT_HCI_EVT_CMD_COMPLETE, false, K_FOREVER);
   1c700:	6020      	str	r0, [r4, #0]
	hci_evt_create(*buf, BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
   1c702:	b2d2      	uxtb	r2, r2
   1c704:	210e      	movs	r1, #14
   1c706:	f00f fade 	bl	2bcc6 <hci_evt_create>
	cc = net_buf_add(*buf, sizeof(*cc));
   1c70a:	6820      	ldr	r0, [r4, #0]
   1c70c:	2103      	movs	r1, #3
   1c70e:	3008      	adds	r0, #8
   1c710:	f010 fa36 	bl	2cb80 <net_buf_simple_add>
	cc->ncmd = 1U;
   1c714:	2301      	movs	r3, #1
   1c716:	7003      	strb	r3, [r0, #0]
	cc->opcode = sys_cpu_to_le16(_opcode);
   1c718:	4b05      	ldr	r3, [pc, #20]	; (1c730 <hci_cmd_complete+0x44>)
   1c71a:	881b      	ldrh	r3, [r3, #0]
   1c71c:	f8a0 3001 	strh.w	r3, [r0, #1]
	return net_buf_add(*buf, plen);
   1c720:	6820      	ldr	r0, [r4, #0]
   1c722:	4629      	mov	r1, r5
   1c724:	3008      	adds	r0, #8
}
   1c726:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return net_buf_add(*buf, plen);
   1c72a:	f010 ba29 	b.w	2cb80 <net_buf_simple_add>
   1c72e:	bf00      	nop
   1c730:	20003cf2 	.word	0x20003cf2

0001c734 <hci_vendor_cmd_handle_common>:
{
   1c734:	b5f0      	push	{r4, r5, r6, r7, lr}
	switch (ocf) {
   1c736:	3801      	subs	r0, #1
{
   1c738:	b087      	sub	sp, #28
   1c73a:	4614      	mov	r4, r2
	switch (ocf) {
   1c73c:	2809      	cmp	r0, #9
   1c73e:	f200 810a 	bhi.w	1c956 <hci_vendor_cmd_handle_common+0x222>
   1c742:	e8df f010 	tbh	[pc, r0, lsl #1]
   1c746:	000a      	.short	0x000a
   1c748:	00370020 	.word	0x00370020
   1c74c:	01080108 	.word	0x01080108
   1c750:	0108005e 	.word	0x0108005e
   1c754:	00690043 	.word	0x00690043
   1c758:	009f      	.short	0x009f
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1c75a:	210d      	movs	r1, #13
   1c75c:	4610      	mov	r0, r2
   1c75e:	f7ff ffc5 	bl	1c6ec <hci_cmd_complete>
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
   1c762:	2302      	movs	r3, #2
	rp->status = 0x00;
   1c764:	2100      	movs	r1, #0
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
   1c766:	7043      	strb	r3, [r0, #1]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
   1c768:	70c3      	strb	r3, [r0, #3]
	rp->fw_version = (KERNEL_VERSION_MAJOR & 0xff);
   1c76a:	7183      	strb	r3, [r0, #6]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
   1c76c:	2301      	movs	r3, #1
	rp->status = 0x00;
   1c76e:	7001      	strb	r1, [r0, #0]
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
   1c770:	7081      	strb	r1, [r0, #2]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
   1c772:	7101      	strb	r1, [r0, #4]
	rp->fw_variant = 0U;
   1c774:	7141      	strb	r1, [r0, #5]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
   1c776:	71c3      	strb	r3, [r0, #7]
   1c778:	7201      	strb	r1, [r0, #8]
	rp->fw_build = sys_cpu_to_le32(KERNEL_PATCHLEVEL & 0xffff);
   1c77a:	7241      	strb	r1, [r0, #9]
   1c77c:	7281      	strb	r1, [r0, #10]
   1c77e:	72c1      	strb	r1, [r0, #11]
   1c780:	7301      	strb	r1, [r0, #12]
	return 0;
   1c782:	2400      	movs	r4, #0
   1c784:	e013      	b.n	1c7ae <hci_vendor_cmd_handle_common+0x7a>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1c786:	2141      	movs	r1, #65	; 0x41
   1c788:	4610      	mov	r0, r2
   1c78a:	f7ff ffaf 	bl	1c6ec <hci_cmd_complete>
	rp->status = 0x00;
   1c78e:	2400      	movs	r4, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1c790:	4605      	mov	r5, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
   1c792:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
   1c794:	f800 4b01 	strb.w	r4, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
   1c798:	4621      	mov	r1, r4
   1c79a:	f00d fe82 	bl	2a4a2 <memset>
	rp->commands[0] |= BIT(5) | BIT(7);
   1c79e:	786b      	ldrb	r3, [r5, #1]
   1c7a0:	f063 0358 	orn	r3, r3, #88	; 0x58
   1c7a4:	706b      	strb	r3, [r5, #1]
	rp->commands[1] |= BIT(0) | BIT(1);
   1c7a6:	78ab      	ldrb	r3, [r5, #2]
   1c7a8:	f043 0303 	orr.w	r3, r3, #3
   1c7ac:	70ab      	strb	r3, [r5, #2]
}
   1c7ae:	4620      	mov	r0, r4
   1c7b0:	b007      	add	sp, #28
   1c7b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1c7b4:	2109      	movs	r1, #9
   1c7b6:	4610      	mov	r0, r2
   1c7b8:	f7ff ff98 	bl	1c6ec <hci_cmd_complete>
	rp->status = 0x00;
   1c7bc:	2400      	movs	r4, #0
   1c7be:	f800 4b01 	strb.w	r4, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   1c7c2:	2208      	movs	r2, #8
   1c7c4:	4621      	mov	r1, r4
		(void)memset(addr->ir, 0x00, sizeof(addr->ir));
   1c7c6:	f00d fe6c 	bl	2a4a2 <memset>
		return;
   1c7ca:	e7f0      	b.n	1c7ae <hci_vendor_cmd_handle_common+0x7a>
	const char build_info[] = HCI_VS_BUILD_INFO;
   1c7cc:	4b63      	ldr	r3, [pc, #396]	; (1c95c <hci_vendor_cmd_handle_common+0x228>)
   1c7ce:	aa01      	add	r2, sp, #4
   1c7d0:	f103 0710 	add.w	r7, r3, #16
   1c7d4:	4616      	mov	r6, r2
   1c7d6:	6818      	ldr	r0, [r3, #0]
   1c7d8:	6859      	ldr	r1, [r3, #4]
   1c7da:	4615      	mov	r5, r2
   1c7dc:	c503      	stmia	r5!, {r0, r1}
   1c7de:	3308      	adds	r3, #8
   1c7e0:	42bb      	cmp	r3, r7
   1c7e2:	462a      	mov	r2, r5
   1c7e4:	d1f7      	bne.n	1c7d6 <hci_vendor_cmd_handle_common+0xa2>
   1c7e6:	781b      	ldrb	r3, [r3, #0]
   1c7e8:	702b      	strb	r3, [r5, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp) + sizeof(build_info));
   1c7ea:	2112      	movs	r1, #18
   1c7ec:	4620      	mov	r0, r4
   1c7ee:	f7ff ff7d 	bl	1c6ec <hci_cmd_complete>
	rp->status = 0x00;
   1c7f2:	2400      	movs	r4, #0
   1c7f4:	f800 4b01 	strb.w	r4, [r0], #1
	memcpy(rp->info, build_info, sizeof(build_info));
   1c7f8:	2211      	movs	r2, #17
   1c7fa:	4631      	mov	r1, r6
   1c7fc:	f00d fe27 	bl	2a44e <memcpy>
   1c800:	e7d5      	b.n	1c7ae <hci_vendor_cmd_handle_common+0x7a>
	ll_addr_set(0, &cmd->bdaddr.val[0]);
   1c802:	6889      	ldr	r1, [r1, #8]
   1c804:	2000      	movs	r0, #0
   1c806:	f7ff fd3d 	bl	1c284 <ll_addr_set>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   1c80a:	2101      	movs	r1, #1
   1c80c:	4620      	mov	r0, r4
   1c80e:	f7ff ff6d 	bl	1c6ec <hci_cmd_complete>
	ccst->status = 0x00;
   1c812:	2100      	movs	r1, #0
   1c814:	7001      	strb	r1, [r0, #0]
   1c816:	e7b4      	b.n	1c782 <hci_vendor_cmd_handle_common+0x4e>
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   1c818:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   1c81c:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
   1c820:	3201      	adds	r2, #1
   1c822:	d106      	bne.n	1c832 <hci_vendor_cmd_handle_common+0xfe>
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   1c824:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   1c828:	f64f 72ff 	movw	r2, #65535	; 0xffff
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   1c82c:	b29b      	uxth	r3, r3
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
   1c82e:	4293      	cmp	r3, r2
   1c830:	d020      	beq.n	1c874 <hci_vendor_cmd_handle_common+0x140>
	      (NRF_FICR->DEVICEADDRTYPE & 0x01)) {
   1c832:	f04f 5680 	mov.w	r6, #268435456	; 0x10000000
   1c836:	f8d6 30a0 	ldr.w	r3, [r6, #160]	; 0xa0
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
   1c83a:	07db      	lsls	r3, r3, #31
   1c83c:	d51a      	bpl.n	1c874 <hci_vendor_cmd_handle_common+0x140>
		rp = hci_cmd_complete(evt, sizeof(*rp) + sizeof(*addr));
   1c83e:	2118      	movs	r1, #24
   1c840:	4620      	mov	r0, r4
   1c842:	f7ff ff53 	bl	1c6ec <hci_cmd_complete>
		rp->status = 0x00;
   1c846:	2400      	movs	r4, #0
		rp->num_addrs = 1U;
   1c848:	2301      	movs	r3, #1
		rp = hci_cmd_complete(evt, sizeof(*rp) + sizeof(*addr));
   1c84a:	4605      	mov	r5, r0
		rp->num_addrs = 1U;
   1c84c:	7043      	strb	r3, [r0, #1]
		rp->status = 0x00;
   1c84e:	7004      	strb	r4, [r0, #0]
		sys_put_le32(NRF_FICR->DEVICEADDR[0], &addr->bdaddr.val[0]);
   1c850:	f8d6 00a4 	ldr.w	r0, [r6, #164]	; 0xa4
   1c854:	1ca9      	adds	r1, r5, #2
   1c856:	f00f fa29 	bl	2bcac <sys_put_le32>
		sys_put_le16(NRF_FICR->DEVICEADDR[1], &addr->bdaddr.val[4]);
   1c85a:	f8d6 30a8 	ldr.w	r3, [r6, #168]	; 0xa8
	dst[0] = val;
   1c85e:	71ab      	strb	r3, [r5, #6]
	dst[1] = val >> 8;
   1c860:	f3c3 2307 	ubfx	r3, r3, #8, #8
		BT_ADDR_SET_STATIC(&addr->bdaddr);
   1c864:	f063 033f 	orn	r3, r3, #63	; 0x3f
   1c868:	71eb      	strb	r3, [r5, #7]
		(void)memset(addr->ir, 0x00, sizeof(addr->ir));
   1c86a:	2210      	movs	r2, #16
   1c86c:	4621      	mov	r1, r4
   1c86e:	f105 0008 	add.w	r0, r5, #8
   1c872:	e7a8      	b.n	1c7c6 <hci_vendor_cmd_handle_common+0x92>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1c874:	2102      	movs	r1, #2
   1c876:	4620      	mov	r0, r4
   1c878:	f7ff ff38 	bl	1c6ec <hci_cmd_complete>
	rp->status = 0x00;
   1c87c:	2100      	movs	r1, #0
   1c87e:	7001      	strb	r1, [r0, #0]
	rp->num_addrs = 0U;
   1c880:	7041      	strb	r1, [r0, #1]
   1c882:	e77e      	b.n	1c782 <hci_vendor_cmd_handle_common+0x4e>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1c884:	2121      	movs	r1, #33	; 0x21
   1c886:	4610      	mov	r0, r2
   1c888:	f7ff ff30 	bl	1c6ec <hci_cmd_complete>
	rp->status = 0x00;
   1c88c:	4603      	mov	r3, r0
   1c88e:	2200      	movs	r2, #0
   1c890:	f803 2b01 	strb.w	r2, [r3], #1
	if ((NRF_FICR->IR[0] != UINT32_MAX) &&
   1c894:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1c898:	4604      	mov	r4, r0
	if ((NRF_FICR->IR[0] != UINT32_MAX) &&
   1c89a:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
   1c89e:	3101      	adds	r1, #1
   1c8a0:	d04d      	beq.n	1c93e <hci_vendor_cmd_handle_common+0x20a>
	    (NRF_FICR->IR[1] != UINT32_MAX) &&
   1c8a2:	f8d2 1094 	ldr.w	r1, [r2, #148]	; 0x94
	if ((NRF_FICR->IR[0] != UINT32_MAX) &&
   1c8a6:	3101      	adds	r1, #1
   1c8a8:	d049      	beq.n	1c93e <hci_vendor_cmd_handle_common+0x20a>
	    (NRF_FICR->IR[2] != UINT32_MAX) &&
   1c8aa:	f8d2 1098 	ldr.w	r1, [r2, #152]	; 0x98
	    (NRF_FICR->IR[1] != UINT32_MAX) &&
   1c8ae:	3101      	adds	r1, #1
   1c8b0:	d045      	beq.n	1c93e <hci_vendor_cmd_handle_common+0x20a>
	    (NRF_FICR->IR[3] != UINT32_MAX)) {
   1c8b2:	f8d2 109c 	ldr.w	r1, [r2, #156]	; 0x9c
	    (NRF_FICR->IR[2] != UINT32_MAX) &&
   1c8b6:	3101      	adds	r1, #1
   1c8b8:	d041      	beq.n	1c93e <hci_vendor_cmd_handle_common+0x20a>
		sys_put_le32(NRF_FICR->IR[0], &rp->ir[0]);
   1c8ba:	f8d2 0090 	ldr.w	r0, [r2, #144]	; 0x90
   1c8be:	4619      	mov	r1, r3
   1c8c0:	f00f f9f4 	bl	2bcac <sys_put_le32>
		sys_put_le32(NRF_FICR->IR[1], &rp->ir[4]);
   1c8c4:	1d61      	adds	r1, r4, #5
   1c8c6:	f8d2 0094 	ldr.w	r0, [r2, #148]	; 0x94
   1c8ca:	f00f f9ef 	bl	2bcac <sys_put_le32>
		sys_put_le32(NRF_FICR->IR[2], &rp->ir[8]);
   1c8ce:	f104 0109 	add.w	r1, r4, #9
   1c8d2:	f8d2 0098 	ldr.w	r0, [r2, #152]	; 0x98
   1c8d6:	f00f f9e9 	bl	2bcac <sys_put_le32>
		sys_put_le32(NRF_FICR->IR[3], &rp->ir[12]);
   1c8da:	f104 010d 	add.w	r1, r4, #13
   1c8de:	f8d2 009c 	ldr.w	r0, [r2, #156]	; 0x9c
   1c8e2:	f00f f9e3 	bl	2bcac <sys_put_le32>
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
   1c8e6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1c8ea:	f104 0311 	add.w	r3, r4, #17
   1c8ee:	f8d2 1080 	ldr.w	r1, [r2, #128]	; 0x80
   1c8f2:	3101      	adds	r1, #1
   1c8f4:	d029      	beq.n	1c94a <hci_vendor_cmd_handle_common+0x216>
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
   1c8f6:	f8d2 1084 	ldr.w	r1, [r2, #132]	; 0x84
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
   1c8fa:	3101      	adds	r1, #1
   1c8fc:	d025      	beq.n	1c94a <hci_vendor_cmd_handle_common+0x216>
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
   1c8fe:	f8d2 1088 	ldr.w	r1, [r2, #136]	; 0x88
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
   1c902:	3101      	adds	r1, #1
   1c904:	d021      	beq.n	1c94a <hci_vendor_cmd_handle_common+0x216>
	    (NRF_FICR->ER[3] != UINT32_MAX)) {
   1c906:	f8d2 108c 	ldr.w	r1, [r2, #140]	; 0x8c
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
   1c90a:	3101      	adds	r1, #1
   1c90c:	d01d      	beq.n	1c94a <hci_vendor_cmd_handle_common+0x216>
		sys_put_le32(NRF_FICR->ER[0], &rp->er[0]);
   1c90e:	f8d2 0080 	ldr.w	r0, [r2, #128]	; 0x80
   1c912:	4619      	mov	r1, r3
   1c914:	f00f f9ca 	bl	2bcac <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[1], &rp->er[4]);
   1c918:	f104 0115 	add.w	r1, r4, #21
   1c91c:	f8d2 0084 	ldr.w	r0, [r2, #132]	; 0x84
   1c920:	f00f f9c4 	bl	2bcac <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[2], &rp->er[8]);
   1c924:	f104 0119 	add.w	r1, r4, #25
   1c928:	f8d2 0088 	ldr.w	r0, [r2, #136]	; 0x88
   1c92c:	f00f f9be 	bl	2bcac <sys_put_le32>
		sys_put_le32(NRF_FICR->ER[3], &rp->er[12]);
   1c930:	f104 011d 	add.w	r1, r4, #29
   1c934:	f8d2 008c 	ldr.w	r0, [r2, #140]	; 0x8c
   1c938:	f00f f9b8 	bl	2bcac <sys_put_le32>
   1c93c:	e721      	b.n	1c782 <hci_vendor_cmd_handle_common+0x4e>
		(void)memset(rp->ir, 0x00, sizeof(rp->ir));
   1c93e:	2210      	movs	r2, #16
   1c940:	2100      	movs	r1, #0
   1c942:	4618      	mov	r0, r3
   1c944:	f00d fdad 	bl	2a4a2 <memset>
   1c948:	e7cd      	b.n	1c8e6 <hci_vendor_cmd_handle_common+0x1b2>
		(void)memset(rp->er, 0x00, sizeof(rp->er));
   1c94a:	2210      	movs	r2, #16
   1c94c:	2100      	movs	r1, #0
   1c94e:	4618      	mov	r0, r3
   1c950:	f00d fda7 	bl	2a4a2 <memset>
   1c954:	e715      	b.n	1c782 <hci_vendor_cmd_handle_common+0x4e>
		return -EINVAL;
   1c956:	f06f 0415 	mvn.w	r4, #21
   1c95a:	e728      	b.n	1c7ae <hci_vendor_cmd_handle_common+0x7a>
   1c95c:	00031621 	.word	0x00031621

0001c960 <hci_cmd_handle>:
{
   1c960:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (cmd->len < sizeof(*chdr)) {
   1c962:	8983      	ldrh	r3, [r0, #12]
{
   1c964:	b08f      	sub	sp, #60	; 0x3c
	struct net_buf *evt = NULL;
   1c966:	2600      	movs	r6, #0
	if (cmd->len < sizeof(*chdr)) {
   1c968:	2b02      	cmp	r3, #2
{
   1c96a:	4604      	mov	r4, r0
   1c96c:	460f      	mov	r7, r1
	struct net_buf *evt = NULL;
   1c96e:	9609      	str	r6, [sp, #36]	; 0x24
	if (cmd->len < sizeof(*chdr)) {
   1c970:	d815      	bhi.n	1c99e <hci_cmd_handle+0x3e>
		BT_ERR("No HCI Command header");
   1c972:	4bb8      	ldr	r3, [pc, #736]	; (1cc54 <hci_cmd_handle+0x2f4>)
   1c974:	681b      	ldr	r3, [r3, #0]
   1c976:	075c      	lsls	r4, r3, #29
   1c978:	d102      	bne.n	1c980 <hci_cmd_handle+0x20>
		return NULL;
   1c97a:	2000      	movs	r0, #0
}
   1c97c:	b00f      	add	sp, #60	; 0x3c
   1c97e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		BT_ERR("No HCI Command header");
   1c980:	2301      	movs	r3, #1
   1c982:	f04f 0100 	mov.w	r1, #0
   1c986:	f363 0107 	bfi	r1, r3, #0, #8
   1c98a:	4ab3      	ldr	r2, [pc, #716]	; (1cc58 <hci_cmd_handle+0x2f8>)
   1c98c:	4bb3      	ldr	r3, [pc, #716]	; (1cc5c <hci_cmd_handle+0x2fc>)
   1c98e:	48b4      	ldr	r0, [pc, #720]	; (1cc60 <hci_cmd_handle+0x300>)
   1c990:	1a9b      	subs	r3, r3, r2
   1c992:	08db      	lsrs	r3, r3, #3
   1c994:	f363 118f 	bfi	r1, r3, #6, #10
		BT_ERR("Invalid HCI CMD packet length");
   1c998:	f00b ffcf 	bl	2893a <log_0>
   1c99c:	e7ed      	b.n	1c97a <hci_cmd_handle+0x1a>
	chdr = net_buf_pull_mem(cmd, sizeof(*chdr));
   1c99e:	2103      	movs	r1, #3
   1c9a0:	3008      	adds	r0, #8
   1c9a2:	f010 f91e 	bl	2cbe2 <net_buf_simple_pull_mem>
	if (cmd->len < chdr->param_len) {
   1c9a6:	89a2      	ldrh	r2, [r4, #12]
   1c9a8:	7883      	ldrb	r3, [r0, #2]
   1c9aa:	429a      	cmp	r2, r3
   1c9ac:	d210      	bcs.n	1c9d0 <hci_cmd_handle+0x70>
		BT_ERR("Invalid HCI CMD packet length");
   1c9ae:	4ba9      	ldr	r3, [pc, #676]	; (1cc54 <hci_cmd_handle+0x2f4>)
   1c9b0:	681b      	ldr	r3, [r3, #0]
   1c9b2:	0758      	lsls	r0, r3, #29
   1c9b4:	d0e1      	beq.n	1c97a <hci_cmd_handle+0x1a>
   1c9b6:	2301      	movs	r3, #1
   1c9b8:	f04f 0100 	mov.w	r1, #0
   1c9bc:	f363 0107 	bfi	r1, r3, #0, #8
   1c9c0:	4aa5      	ldr	r2, [pc, #660]	; (1cc58 <hci_cmd_handle+0x2f8>)
   1c9c2:	4ba6      	ldr	r3, [pc, #664]	; (1cc5c <hci_cmd_handle+0x2fc>)
   1c9c4:	48a7      	ldr	r0, [pc, #668]	; (1cc64 <hci_cmd_handle+0x304>)
   1c9c6:	1a9b      	subs	r3, r3, r2
   1c9c8:	08db      	lsrs	r3, r3, #3
   1c9ca:	f363 118f 	bfi	r1, r3, #6, #10
   1c9ce:	e7e3      	b.n	1c998 <hci_cmd_handle+0x38>
	_opcode = sys_le16_to_cpu(chdr->opcode);
   1c9d0:	8802      	ldrh	r2, [r0, #0]
   1c9d2:	49a5      	ldr	r1, [pc, #660]	; (1cc68 <hci_cmd_handle+0x308>)
   1c9d4:	b293      	uxth	r3, r2
	ocf = BT_OCF(_opcode);
   1c9d6:	f3c3 0509 	ubfx	r5, r3, #0, #10
	switch (BT_OGF(_opcode)) {
   1c9da:	0a9b      	lsrs	r3, r3, #10
   1c9dc:	2b04      	cmp	r3, #4
	_opcode = sys_le16_to_cpu(chdr->opcode);
   1c9de:	800a      	strh	r2, [r1, #0]
	switch (BT_OGF(_opcode)) {
   1c9e0:	f000 809d 	beq.w	1cb1e <hci_cmd_handle+0x1be>
   1c9e4:	d809      	bhi.n	1c9fa <hci_cmd_handle+0x9a>
   1c9e6:	2b01      	cmp	r3, #1
   1c9e8:	d014      	beq.n	1ca14 <hci_cmd_handle+0xb4>
   1c9ea:	2b03      	cmp	r3, #3
   1c9ec:	d024      	beq.n	1ca38 <hci_cmd_handle+0xd8>
		ccst = hci_cmd_complete(&evt, sizeof(*ccst));
   1c9ee:	2101      	movs	r1, #1
   1c9f0:	a809      	add	r0, sp, #36	; 0x24
   1c9f2:	f7ff fe7b 	bl	1c6ec <hci_cmd_complete>
		ccst->status = BT_HCI_ERR_UNKNOWN_CMD;
   1c9f6:	2301      	movs	r3, #1
   1c9f8:	e041      	b.n	1ca7e <hci_cmd_handle+0x11e>
	switch (BT_OGF(_opcode)) {
   1c9fa:	2b08      	cmp	r3, #8
   1c9fc:	f000 813e 	beq.w	1cc7c <hci_cmd_handle+0x31c>
   1ca00:	2b3f      	cmp	r3, #63	; 0x3f
   1ca02:	d1f4      	bne.n	1c9ee <hci_cmd_handle+0x8e>

/* Map vendor command handler directly to common implementation */
inline int hci_vendor_cmd_handle(u16_t ocf, struct net_buf *cmd,
				 struct net_buf **evt)
{
	return hci_vendor_cmd_handle_common(ocf, cmd, evt);
   1ca04:	aa09      	add	r2, sp, #36	; 0x24
   1ca06:	4621      	mov	r1, r4
   1ca08:	4628      	mov	r0, r5
   1ca0a:	f7ff fe93 	bl	1c734 <hci_vendor_cmd_handle_common>
	if (err == -EINVAL) {
   1ca0e:	3016      	adds	r0, #22
   1ca10:	d0ed      	beq.n	1c9ee <hci_cmd_handle+0x8e>
   1ca12:	e04e      	b.n	1cab2 <hci_cmd_handle+0x152>
	switch (ocf) {
   1ca14:	2d06      	cmp	r5, #6
   1ca16:	d006      	beq.n	1ca26 <hci_cmd_handle+0xc6>
   1ca18:	2d1d      	cmp	r5, #29
   1ca1a:	d1e8      	bne.n	1c9ee <hci_cmd_handle+0x8e>
	handle = sys_le16_to_cpu(cmd->handle);
   1ca1c:	68a3      	ldr	r3, [r4, #8]
	status = ll_version_ind_send(handle);
   1ca1e:	8818      	ldrh	r0, [r3, #0]
   1ca20:	f00f fd6e 	bl	2c500 <ll_version_ind_send>
	*evt = cmd_status(status);
   1ca24:	e004      	b.n	1ca30 <hci_cmd_handle+0xd0>
		disconnect(cmd, evt);
   1ca26:	68a3      	ldr	r3, [r4, #8]
	status = ll_terminate_ind_send(handle, cmd->reason);
   1ca28:	7899      	ldrb	r1, [r3, #2]
   1ca2a:	8818      	ldrh	r0, [r3, #0]
   1ca2c:	f00f fd47 	bl	2c4be <ll_terminate_ind_send>
	*evt = cmd_status(status);
   1ca30:	f7ff fdf2 	bl	1c618 <cmd_status>
   1ca34:	9009      	str	r0, [sp, #36]	; 0x24
	if (err == -EINVAL) {
   1ca36:	e03c      	b.n	1cab2 <hci_cmd_handle+0x152>
	switch (ocf) {
   1ca38:	2d2d      	cmp	r5, #45	; 0x2d
   1ca3a:	d03c      	beq.n	1cab6 <hci_cmd_handle+0x156>
   1ca3c:	d821      	bhi.n	1ca82 <hci_cmd_handle+0x122>
   1ca3e:	2d01      	cmp	r5, #1
   1ca40:	d02c      	beq.n	1ca9c <hci_cmd_handle+0x13c>
   1ca42:	2d03      	cmp	r5, #3
   1ca44:	d1d3      	bne.n	1c9ee <hci_cmd_handle+0x8e>
	dup_count = -1;
   1ca46:	4b89      	ldr	r3, [pc, #548]	; (1cc6c <hci_cmd_handle+0x30c>)
   1ca48:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1ca4c:	601a      	str	r2, [r3, #0]
	event_mask = DEFAULT_EVENT_MASK;
   1ca4e:	4b88      	ldr	r3, [pc, #544]	; (1cc70 <hci_cmd_handle+0x310>)
   1ca50:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1ca54:	f641 71ff 	movw	r1, #8191	; 0x1fff
   1ca58:	e9c3 0100 	strd	r0, r1, [r3]
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
   1ca5c:	4b85      	ldr	r3, [pc, #532]	; (1cc74 <hci_cmd_handle+0x314>)
   1ca5e:	2000      	movs	r0, #0
   1ca60:	2100      	movs	r1, #0
   1ca62:	e9c3 0100 	strd	r0, r1, [r3]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
   1ca66:	4b84      	ldr	r3, [pc, #528]	; (1cc78 <hci_cmd_handle+0x318>)
   1ca68:	201f      	movs	r0, #31
   1ca6a:	2100      	movs	r1, #0
   1ca6c:	e9c3 0100 	strd	r0, r1, [r3]
		ll_reset();
   1ca70:	f001 fa1a 	bl	1dea8 <ll_reset>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   1ca74:	2101      	movs	r1, #1
   1ca76:	a809      	add	r0, sp, #36	; 0x24
   1ca78:	f7ff fe38 	bl	1c6ec <hci_cmd_complete>
	ccst->status = 0x00;
   1ca7c:	2300      	movs	r3, #0
		ccst->status = BT_HCI_ERR_UNKNOWN_CMD;
   1ca7e:	7003      	strb	r3, [r0, #0]
   1ca80:	e017      	b.n	1cab2 <hci_cmd_handle+0x152>
	switch (ocf) {
   1ca82:	2d7b      	cmp	r5, #123	; 0x7b
   1ca84:	d029      	beq.n	1cada <hci_cmd_handle+0x17a>
   1ca86:	2d7c      	cmp	r5, #124	; 0x7c
   1ca88:	d03a      	beq.n	1cb00 <hci_cmd_handle+0x1a0>
   1ca8a:	2d63      	cmp	r5, #99	; 0x63
   1ca8c:	d1af      	bne.n	1c9ee <hci_cmd_handle+0x8e>
	event_mask_page_2 = sys_get_le64(cmd->events_page_2);
   1ca8e:	68a0      	ldr	r0, [r4, #8]
   1ca90:	f00f f915 	bl	2bcbe <sys_get_le64>
   1ca94:	4b77      	ldr	r3, [pc, #476]	; (1cc74 <hci_cmd_handle+0x314>)
	le_event_mask = sys_get_le64(cmd->events);
   1ca96:	e9c3 0100 	strd	r0, r1, [r3]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   1ca9a:	e7eb      	b.n	1ca74 <hci_cmd_handle+0x114>
	event_mask = sys_get_le64(cmd->events);
   1ca9c:	68a0      	ldr	r0, [r4, #8]
   1ca9e:	f00f f90e 	bl	2bcbe <sys_get_le64>
   1caa2:	4b73      	ldr	r3, [pc, #460]	; (1cc70 <hci_cmd_handle+0x310>)
   1caa4:	e9c3 0100 	strd	r0, r1, [r3]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   1caa8:	4629      	mov	r1, r5
   1caaa:	a809      	add	r0, sp, #36	; 0x24
   1caac:	f7ff fe1e 	bl	1c6ec <hci_cmd_complete>
	ccst->status = 0x00;
   1cab0:	7006      	strb	r6, [r0, #0]
	return evt;
   1cab2:	9809      	ldr	r0, [sp, #36]	; 0x24
   1cab4:	e762      	b.n	1c97c <hci_cmd_handle+0x1c>
		read_tx_power_level(cmd, evt);
   1cab6:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1cab8:	2104      	movs	r1, #4
   1caba:	a809      	add	r0, sp, #36	; 0x24
	handle = sys_le16_to_cpu(cmd->handle);
   1cabc:	881d      	ldrh	r5, [r3, #0]
	type = cmd->type;
   1cabe:	789f      	ldrb	r7, [r3, #2]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1cac0:	f7ff fe14 	bl	1c6ec <hci_cmd_complete>
	handle = sys_le16_to_cpu(cmd->handle);
   1cac4:	b2ae      	uxth	r6, r5
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1cac6:	4604      	mov	r4, r0
	status = ll_tx_pwr_lvl_get(handle, type, &rp->tx_power_level);
   1cac8:	1cc2      	adds	r2, r0, #3
   1caca:	4639      	mov	r1, r7
   1cacc:	4630      	mov	r0, r6
   1cace:	f00f f8de 	bl	2bc8e <ll_tx_pwr_lvl_get>
	rp->status = status;
   1cad2:	7020      	strb	r0, [r4, #0]
	rp->handle = sys_le16_to_cpu(handle);
   1cad4:	f8a4 5001 	strh.w	r5, [r4, #1]
	if (err == -EINVAL) {
   1cad8:	e7eb      	b.n	1cab2 <hci_cmd_handle+0x152>
	handle = sys_le16_to_cpu(cmd->handle);
   1cada:	68a3      	ldr	r3, [r4, #8]
   1cadc:	881c      	ldrh	r4, [r3, #0]
	status = ll_apto_get(handle, &auth_payload_timeout);
   1cade:	a90a      	add	r1, sp, #40	; 0x28
   1cae0:	4620      	mov	r0, r4
   1cae2:	f00f fda1 	bl	2c628 <ll_apto_get>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1cae6:	2105      	movs	r1, #5
	status = ll_apto_get(handle, &auth_payload_timeout);
   1cae8:	4605      	mov	r5, r0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1caea:	a809      	add	r0, sp, #36	; 0x24
   1caec:	f7ff fdfe 	bl	1c6ec <hci_cmd_complete>
	rp->status = status;
   1caf0:	7005      	strb	r5, [r0, #0]
	rp->handle = sys_cpu_to_le16(handle);
   1caf2:	f8a0 4001 	strh.w	r4, [r0, #1]
	rp->auth_payload_timeout = sys_cpu_to_le16(auth_payload_timeout);
   1caf6:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   1cafa:	f8a0 3003 	strh.w	r3, [r0, #3]
   1cafe:	e7d8      	b.n	1cab2 <hci_cmd_handle+0x152>
		write_auth_payload_timeout(cmd, evt);
   1cb00:	68a3      	ldr	r3, [r4, #8]
	handle = sys_le16_to_cpu(cmd->handle);
   1cb02:	881c      	ldrh	r4, [r3, #0]
	status = ll_apto_set(handle, auth_payload_timeout);
   1cb04:	8859      	ldrh	r1, [r3, #2]
   1cb06:	4620      	mov	r0, r4
   1cb08:	f00f fda2 	bl	2c650 <ll_apto_set>
	status = ll_start_enc_req_send(handle, 0x00, &cmd->ltk[0]);
   1cb0c:	4605      	mov	r5, r0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1cb0e:	2103      	movs	r1, #3
   1cb10:	a809      	add	r0, sp, #36	; 0x24
   1cb12:	f7ff fdeb 	bl	1c6ec <hci_cmd_complete>
	rp->status = status;
   1cb16:	7005      	strb	r5, [r0, #0]
	rp->handle = sys_cpu_to_le16(handle);
   1cb18:	f8a0 4001 	strh.w	r4, [r0, #1]
	if (err == -EINVAL) {
   1cb1c:	e7c9      	b.n	1cab2 <hci_cmd_handle+0x152>
	switch (ocf) {
   1cb1e:	3d01      	subs	r5, #1
   1cb20:	2d08      	cmp	r5, #8
   1cb22:	f63f af64 	bhi.w	1c9ee <hci_cmd_handle+0x8e>
   1cb26:	a301      	add	r3, pc, #4	; (adr r3, 1cb2c <hci_cmd_handle+0x1cc>)
   1cb28:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
   1cb2c:	0001cb51 	.word	0x0001cb51
   1cb30:	0001cb7b 	.word	0x0001cb7b
   1cb34:	0001cc21 	.word	0x0001cc21
   1cb38:	0001c9ef 	.word	0x0001c9ef
   1cb3c:	0001c9ef 	.word	0x0001c9ef
   1cb40:	0001c9ef 	.word	0x0001c9ef
   1cb44:	0001c9ef 	.word	0x0001c9ef
   1cb48:	0001c9ef 	.word	0x0001c9ef
   1cb4c:	0001cc3d 	.word	0x0001cc3d
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1cb50:	2109      	movs	r1, #9
   1cb52:	a809      	add	r0, sp, #36	; 0x24
   1cb54:	f7ff fdca 	bl	1c6ec <hci_cmd_complete>
	rp->status = 0x00;
   1cb58:	2300      	movs	r3, #0
   1cb5a:	7003      	strb	r3, [r0, #0]
	rp->hci_revision = sys_cpu_to_le16(0);
   1cb5c:	7083      	strb	r3, [r0, #2]
   1cb5e:	70c3      	strb	r3, [r0, #3]
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
   1cb60:	f06f 030e 	mvn.w	r3, #14
   1cb64:	7143      	strb	r3, [r0, #5]
   1cb66:	2305      	movs	r3, #5
	rp->hci_version = LL_VERSION_NUMBER;
   1cb68:	220a      	movs	r2, #10
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
   1cb6a:	7183      	strb	r3, [r0, #6]
	rp->lmp_subversion = sys_cpu_to_le16(ll_settings_subversion_number());
   1cb6c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	rp->hci_version = LL_VERSION_NUMBER;
   1cb70:	7042      	strb	r2, [r0, #1]
	rp->lmp_version = LL_VERSION_NUMBER;
   1cb72:	7102      	strb	r2, [r0, #4]
	rp->lmp_subversion = sys_cpu_to_le16(ll_settings_subversion_number());
   1cb74:	71c3      	strb	r3, [r0, #7]
   1cb76:	7203      	strb	r3, [r0, #8]
	if (err == -EINVAL) {
   1cb78:	e79b      	b.n	1cab2 <hci_cmd_handle+0x152>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1cb7a:	2141      	movs	r1, #65	; 0x41
   1cb7c:	a809      	add	r0, sp, #36	; 0x24
   1cb7e:	f7ff fdb5 	bl	1c6ec <hci_cmd_complete>
	rp->status = 0x00;
   1cb82:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1cb84:	4604      	mov	r4, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
   1cb86:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
   1cb88:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
   1cb8c:	f00d fc89 	bl	2a4a2 <memset>
	rp->commands[5] |= BIT(6) | BIT(7);
   1cb90:	79a3      	ldrb	r3, [r4, #6]
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
   1cb92:	7ea2      	ldrb	r2, [r4, #26]
	rp->commands[5] |= BIT(6) | BIT(7);
   1cb94:	f063 033f 	orn	r3, r3, #63	; 0x3f
   1cb98:	71a3      	strb	r3, [r4, #6]
	rp->commands[10] |= BIT(2);
   1cb9a:	7ae3      	ldrb	r3, [r4, #11]
   1cb9c:	f043 0304 	orr.w	r3, r3, #4
   1cba0:	72e3      	strb	r3, [r4, #11]
	rp->commands[14] |= BIT(3) | BIT(5);
   1cba2:	7be3      	ldrb	r3, [r4, #15]
   1cba4:	f043 0328 	orr.w	r3, r3, #40	; 0x28
   1cba8:	73e3      	strb	r3, [r4, #15]
	rp->commands[15] |= BIT(1);
   1cbaa:	7c23      	ldrb	r3, [r4, #16]
   1cbac:	f043 0302 	orr.w	r3, r3, #2
   1cbb0:	7423      	strb	r3, [r4, #16]
	rp->commands[22] |= BIT(2);
   1cbb2:	7de3      	ldrb	r3, [r4, #23]
   1cbb4:	f043 0304 	orr.w	r3, r3, #4
   1cbb8:	75e3      	strb	r3, [r4, #23]
	rp->commands[28] |= BIT(3);
   1cbba:	7f63      	ldrb	r3, [r4, #29]
	rp->commands[28] |= BIT(1) | BIT(2);
   1cbbc:	f043 030f 	orr.w	r3, r3, #15
   1cbc0:	7763      	strb	r3, [r4, #29]
	rp->commands[0] |= BIT(5);
   1cbc2:	7863      	ldrb	r3, [r4, #1]
   1cbc4:	f043 0320 	orr.w	r3, r3, #32
   1cbc8:	7063      	strb	r3, [r4, #1]
	rp->commands[33] |= BIT(4) | BIT(5);
   1cbca:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
	rp->commands[33] |= BIT(6) | BIT(7);
   1cbce:	f063 030f 	orn	r3, r3, #15
   1cbd2:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
	rp->commands[35] |= BIT(3);
   1cbd6:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
   1cbda:	f062 0208 	orn	r2, r2, #8
	rp->commands[35] |= BIT(0) | BIT(1) | BIT(2);
   1cbde:	f043 037f 	orr.w	r3, r3, #127	; 0x7f
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
   1cbe2:	76a2      	strb	r2, [r4, #26]
	rp->commands[26] |= BIT(4) | BIT(5);
   1cbe4:	22ff      	movs	r2, #255	; 0xff
   1cbe6:	76e2      	strb	r2, [r4, #27]
	rp->commands[27] |= BIT(2) | BIT(4) | BIT(5);
   1cbe8:	7722      	strb	r2, [r4, #28]
	rp->commands[35] |= BIT(0) | BIT(1) | BIT(2);
   1cbea:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
	rp->commands[32] |= BIT(4) | BIT(5);
   1cbee:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
	rp->commands[39] |= BIT(2);
   1cbf2:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
	rp->commands[32] |= BIT(4) | BIT(5);
   1cbf6:	f042 0230 	orr.w	r2, r2, #48	; 0x30
	rp->commands[39] |= BIT(2);
   1cbfa:	f043 0304 	orr.w	r3, r3, #4
	rp->commands[32] |= BIT(4) | BIT(5);
   1cbfe:	f884 2021 	strb.w	r2, [r4, #33]	; 0x21
	rp->commands[39] |= BIT(2);
   1cc02:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	rp->commands[34] |= BIT(3) | BIT(4) | BIT(5) | BIT(6) | BIT(7);
   1cc06:	f894 2023 	ldrb.w	r2, [r4, #35]	; 0x23
	rp->commands[38] |= BIT(7);
   1cc0a:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
	rp->commands[34] |= BIT(3) | BIT(4) | BIT(5) | BIT(6) | BIT(7);
   1cc0e:	f062 0206 	orn	r2, r2, #6
	rp->commands[38] |= BIT(7);
   1cc12:	f063 037f 	orn	r3, r3, #127	; 0x7f
	rp->commands[34] |= BIT(3) | BIT(4) | BIT(5) | BIT(6) | BIT(7);
   1cc16:	f884 2023 	strb.w	r2, [r4, #35]	; 0x23
	rp->commands[38] |= BIT(7);
   1cc1a:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
   1cc1e:	e748      	b.n	1cab2 <hci_cmd_handle+0x152>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1cc20:	2109      	movs	r1, #9
   1cc22:	a809      	add	r0, sp, #36	; 0x24
   1cc24:	f7ff fd62 	bl	1c6ec <hci_cmd_complete>
	rp->status = 0x00;
   1cc28:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1cc2a:	4604      	mov	r4, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   1cc2c:	2208      	movs	r2, #8
	rp->status = 0x00;
   1cc2e:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   1cc32:	f00d fc36 	bl	2a4a2 <memset>
	rp->features[4] = (1 << 5) | (1 << 6);
   1cc36:	2360      	movs	r3, #96	; 0x60
   1cc38:	7163      	strb	r3, [r4, #5]
   1cc3a:	e73a      	b.n	1cab2 <hci_cmd_handle+0x152>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1cc3c:	2107      	movs	r1, #7
   1cc3e:	a809      	add	r0, sp, #36	; 0x24
   1cc40:	f7ff fd54 	bl	1c6ec <hci_cmd_complete>
	rp->status = 0x00;
   1cc44:	4601      	mov	r1, r0
   1cc46:	2300      	movs	r3, #0
   1cc48:	f801 3b01 	strb.w	r3, [r1], #1
	ll_addr_get(0, &rp->bdaddr.val[0]);
   1cc4c:	4618      	mov	r0, r3
   1cc4e:	f7ff faff 	bl	1c250 <ll_addr_get>
   1cc52:	e72e      	b.n	1cab2 <hci_cmd_handle+0x152>
   1cc54:	2000ffb8 	.word	0x2000ffb8
   1cc58:	0002db28 	.word	0x0002db28
   1cc5c:	0002db68 	.word	0x0002db68
   1cc60:	0003157d 	.word	0x0003157d
   1cc64:	00031593 	.word	0x00031593
   1cc68:	20003cf2 	.word	0x20003cf2
   1cc6c:	20001e70 	.word	0x20001e70
   1cc70:	2000f7f8 	.word	0x2000f7f8
   1cc74:	20000000 	.word	0x20000000
   1cc78:	2000f800 	.word	0x2000f800
	switch (ocf) {
   1cc7c:	3d01      	subs	r5, #1
   1cc7e:	2d4d      	cmp	r5, #77	; 0x4d
   1cc80:	f63f aeb5 	bhi.w	1c9ee <hci_cmd_handle+0x8e>
   1cc84:	a301      	add	r3, pc, #4	; (adr r3, 1cc8c <hci_cmd_handle+0x32c>)
   1cc86:	f853 f025 	ldr.w	pc, [r3, r5, lsl #2]
   1cc8a:	bf00      	nop
   1cc8c:	0001cdc5 	.word	0x0001cdc5
   1cc90:	0001cdcf 	.word	0x0001cdcf
   1cc94:	0001cde9 	.word	0x0001cde9
   1cc98:	0001c9ef 	.word	0x0001c9ef
   1cc9c:	0001ce0d 	.word	0x0001ce0d
   1cca0:	0001cebd 	.word	0x0001cebd
   1cca4:	0001ced9 	.word	0x0001ced9
   1cca8:	0001cee9 	.word	0x0001cee9
   1ccac:	0001cef5 	.word	0x0001cef5
   1ccb0:	0001cf01 	.word	0x0001cf01
   1ccb4:	0001cf0b 	.word	0x0001cf0b
   1ccb8:	0001cf23 	.word	0x0001cf23
   1ccbc:	0001cf43 	.word	0x0001cf43
   1ccc0:	0001cf6d 	.word	0x0001cf6d
   1ccc4:	0001ce23 	.word	0x0001ce23
   1ccc8:	0001ce39 	.word	0x0001ce39
   1cccc:	0001ce4b 	.word	0x0001ce4b
   1ccd0:	0001ce53 	.word	0x0001ce53
   1ccd4:	0001cfcf 	.word	0x0001cfcf
   1ccd8:	0001cf75 	.word	0x0001cf75
   1ccdc:	0001cfab 	.word	0x0001cfab
   1cce0:	0001cfc5 	.word	0x0001cfc5
   1cce4:	0001ce5b 	.word	0x0001ce5b
   1cce8:	0001ce81 	.word	0x0001ce81
   1ccec:	0001cf7d 	.word	0x0001cf7d
   1ccf0:	0001cf91 	.word	0x0001cf91
   1ccf4:	0001cfa1 	.word	0x0001cfa1
   1ccf8:	0001ce97 	.word	0x0001ce97
   1ccfc:	0001c9ef 	.word	0x0001c9ef
   1cd00:	0001c9ef 	.word	0x0001c9ef
   1cd04:	0001c9ef 	.word	0x0001c9ef
   1cd08:	0001cfeb 	.word	0x0001cfeb
   1cd0c:	0001d009 	.word	0x0001d009
   1cd10:	0001d019 	.word	0x0001d019
   1cd14:	0001d029 	.word	0x0001d029
   1cd18:	0001d053 	.word	0x0001d053
   1cd1c:	0001c9ef 	.word	0x0001c9ef
   1cd20:	0001c9ef 	.word	0x0001c9ef
   1cd24:	0001d157 	.word	0x0001d157
   1cd28:	0001d165 	.word	0x0001d165
   1cd2c:	0001d16d 	.word	0x0001d16d
   1cd30:	0001d17d 	.word	0x0001d17d
   1cd34:	0001d18f 	.word	0x0001d18f
   1cd38:	0001d1ad 	.word	0x0001d1ad
   1cd3c:	0001d1cb 	.word	0x0001d1cb
   1cd40:	0001d1e1 	.word	0x0001d1e1
   1cd44:	0001d05f 	.word	0x0001d05f
   1cd48:	0001d095 	.word	0x0001d095
   1cd4c:	0001d0e3 	.word	0x0001d0e3
   1cd50:	0001d101 	.word	0x0001d101
   1cd54:	0001c9ef 	.word	0x0001c9ef
   1cd58:	0001c9ef 	.word	0x0001c9ef
   1cd5c:	0001c9ef 	.word	0x0001c9ef
   1cd60:	0001c9ef 	.word	0x0001c9ef
   1cd64:	0001c9ef 	.word	0x0001c9ef
   1cd68:	0001c9ef 	.word	0x0001c9ef
   1cd6c:	0001c9ef 	.word	0x0001c9ef
   1cd70:	0001c9ef 	.word	0x0001c9ef
   1cd74:	0001c9ef 	.word	0x0001c9ef
   1cd78:	0001c9ef 	.word	0x0001c9ef
   1cd7c:	0001c9ef 	.word	0x0001c9ef
   1cd80:	0001c9ef 	.word	0x0001c9ef
   1cd84:	0001c9ef 	.word	0x0001c9ef
   1cd88:	0001c9ef 	.word	0x0001c9ef
   1cd8c:	0001c9ef 	.word	0x0001c9ef
   1cd90:	0001c9ef 	.word	0x0001c9ef
   1cd94:	0001c9ef 	.word	0x0001c9ef
   1cd98:	0001c9ef 	.word	0x0001c9ef
   1cd9c:	0001c9ef 	.word	0x0001c9ef
   1cda0:	0001c9ef 	.word	0x0001c9ef
   1cda4:	0001c9ef 	.word	0x0001c9ef
   1cda8:	0001c9ef 	.word	0x0001c9ef
   1cdac:	0001c9ef 	.word	0x0001c9ef
   1cdb0:	0001c9ef 	.word	0x0001c9ef
   1cdb4:	0001d1f5 	.word	0x0001d1f5
   1cdb8:	0001c9ef 	.word	0x0001c9ef
   1cdbc:	0001c9ef 	.word	0x0001c9ef
   1cdc0:	0001d1eb 	.word	0x0001d1eb
	le_event_mask = sys_get_le64(cmd->events);
   1cdc4:	68a0      	ldr	r0, [r4, #8]
   1cdc6:	f00e ff7a 	bl	2bcbe <sys_get_le64>
   1cdca:	4baf      	ldr	r3, [pc, #700]	; (1d088 <hci_cmd_handle+0x728>)
   1cdcc:	e663      	b.n	1ca96 <hci_cmd_handle+0x136>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1cdce:	2104      	movs	r1, #4
   1cdd0:	a809      	add	r0, sp, #36	; 0x24
   1cdd2:	f7ff fc8b 	bl	1c6ec <hci_cmd_complete>
	rp->status = 0x00;
   1cdd6:	2300      	movs	r3, #0
   1cdd8:	7003      	strb	r3, [r0, #0]
	rp->le_max_len = sys_cpu_to_le16(CONFIG_BT_CTLR_TX_BUFFER_SIZE);
   1cdda:	2304      	movs	r3, #4
   1cddc:	7043      	strb	r3, [r0, #1]
   1cdde:	2301      	movs	r3, #1
   1cde0:	7083      	strb	r3, [r0, #2]
	rp->le_max_num = CONFIG_BT_CTLR_TX_BUFFERS;
   1cde2:	2303      	movs	r3, #3
   1cde4:	70c3      	strb	r3, [r0, #3]
   1cde6:	e664      	b.n	1cab2 <hci_cmd_handle+0x152>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1cde8:	2109      	movs	r1, #9
   1cdea:	a809      	add	r0, sp, #36	; 0x24
   1cdec:	f7ff fc7e 	bl	1c6ec <hci_cmd_complete>
	rp->status = 0x00;
   1cdf0:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1cdf2:	4604      	mov	r4, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   1cdf4:	2208      	movs	r2, #8
	rp->status = 0x00;
   1cdf6:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
   1cdfa:	f00d fb52 	bl	2a4a2 <memset>
	rp->features[0] = LL_FEAT & 0xFF;
   1cdfe:	23ff      	movs	r3, #255	; 0xff
   1ce00:	7063      	strb	r3, [r4, #1]
	rp->features[1] = (LL_FEAT >> 8)  & 0xFF;
   1ce02:	2349      	movs	r3, #73	; 0x49
   1ce04:	70a3      	strb	r3, [r4, #2]
	rp->features[2] = (LL_FEAT >> 16)  & 0xFF;
   1ce06:	2301      	movs	r3, #1
   1ce08:	70e3      	strb	r3, [r4, #3]
   1ce0a:	e652      	b.n	1cab2 <hci_cmd_handle+0x152>
	status = ll_addr_set(1, &cmd->bdaddr.val[0]);
   1ce0c:	68a1      	ldr	r1, [r4, #8]
   1ce0e:	2001      	movs	r0, #1
   1ce10:	f7ff fa38 	bl	1c284 <ll_addr_set>
	status = ll_wl_add(&cmd->addr);
   1ce14:	4604      	mov	r4, r0
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   1ce16:	2101      	movs	r1, #1
   1ce18:	a809      	add	r0, sp, #36	; 0x24
   1ce1a:	f7ff fc67 	bl	1c6ec <hci_cmd_complete>
	ccst->status = status;
   1ce1e:	7004      	strb	r4, [r0, #0]
	if (err == -EINVAL) {
   1ce20:	e647      	b.n	1cab2 <hci_cmd_handle+0x152>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1ce22:	2102      	movs	r1, #2
   1ce24:	a809      	add	r0, sp, #36	; 0x24
   1ce26:	f7ff fc61 	bl	1c6ec <hci_cmd_complete>
	rp->status = 0x00;
   1ce2a:	2300      	movs	r3, #0
   1ce2c:	7003      	strb	r3, [r0, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1ce2e:	4604      	mov	r4, r0
	rp->wl_size = ll_wl_size_get();
   1ce30:	f00f fe10 	bl	2ca54 <ll_wl_size_get>
   1ce34:	7060      	strb	r0, [r4, #1]
	if (err == -EINVAL) {
   1ce36:	e63c      	b.n	1cab2 <hci_cmd_handle+0x152>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   1ce38:	2101      	movs	r1, #1
   1ce3a:	a809      	add	r0, sp, #36	; 0x24
   1ce3c:	f7ff fc56 	bl	1c6ec <hci_cmd_complete>
   1ce40:	4604      	mov	r4, r0
	ccst->status = ll_wl_clear();
   1ce42:	f006 fcc3 	bl	237cc <ll_wl_clear>
	ccst->status = ll_rl_clear();
   1ce46:	7020      	strb	r0, [r4, #0]
	if (err == -EINVAL) {
   1ce48:	e633      	b.n	1cab2 <hci_cmd_handle+0x152>
	status = ll_wl_add(&cmd->addr);
   1ce4a:	68a0      	ldr	r0, [r4, #8]
   1ce4c:	f006 feae 	bl	23bac <ll_wl_add>
   1ce50:	e7e0      	b.n	1ce14 <hci_cmd_handle+0x4b4>
	status = ll_wl_remove(&cmd->addr);
   1ce52:	68a0      	ldr	r0, [r4, #8]
   1ce54:	f006 fcf6 	bl	23844 <ll_wl_remove>
   1ce58:	e7dc      	b.n	1ce14 <hci_cmd_handle+0x4b4>
		le_encrypt(cmd, evt);
   1ce5a:	68a0      	ldr	r0, [r4, #8]
	ecb_encrypt(cmd->key, cmd->plaintext, enc_data, NULL);
   1ce5c:	aa0a      	add	r2, sp, #40	; 0x28
   1ce5e:	2300      	movs	r3, #0
   1ce60:	f100 0110 	add.w	r1, r0, #16
   1ce64:	f00f fdfa 	bl	2ca5c <ecb_encrypt>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1ce68:	2111      	movs	r1, #17
   1ce6a:	a809      	add	r0, sp, #36	; 0x24
   1ce6c:	f7ff fc3e 	bl	1c6ec <hci_cmd_complete>
	rp->status = 0x00;
   1ce70:	2300      	movs	r3, #0
   1ce72:	f800 3b01 	strb.w	r3, [r0], #1
	memcpy(rp->enc_data, enc_data, 16);
   1ce76:	2210      	movs	r2, #16
   1ce78:	a90a      	add	r1, sp, #40	; 0x28
   1ce7a:	f00d fae8 	bl	2a44e <memcpy>
	if (err == -EINVAL) {
   1ce7e:	e618      	b.n	1cab2 <hci_cmd_handle+0x152>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1ce80:	2109      	movs	r1, #9
   1ce82:	a809      	add	r0, sp, #36	; 0x24
   1ce84:	f7ff fc32 	bl	1c6ec <hci_cmd_complete>
	rp->status = 0x00;
   1ce88:	2300      	movs	r3, #0
   1ce8a:	f800 3b01 	strb.w	r3, [r0], #1
	bt_rand(rp->rand, count);
   1ce8e:	2108      	movs	r1, #8
   1ce90:	f000 fdf0 	bl	1da74 <bt_rand>
	if (err == -EINVAL) {
   1ce94:	e60d      	b.n	1cab2 <hci_cmd_handle+0x152>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1ce96:	2109      	movs	r1, #9
   1ce98:	a809      	add	r0, sp, #36	; 0x24
   1ce9a:	f7ff fc27 	bl	1c6ec <hci_cmd_complete>
	rp->status = 0x00;
   1ce9e:	4601      	mov	r1, r0
   1cea0:	2300      	movs	r3, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1cea2:	4602      	mov	r2, r0
	rp->status = 0x00;
   1cea4:	f801 3b01 	strb.w	r3, [r1], #1
	sys_put_le32(val, dst);
   1cea8:	f46f 0040 	mvn.w	r0, #12582912	; 0xc00000
   1ceac:	f00e fefe 	bl	2bcac <sys_put_le32>
	sys_put_le32(val >> 32, &dst[4]);
   1ceb0:	f240 30ff 	movw	r0, #1023	; 0x3ff
   1ceb4:	1d51      	adds	r1, r2, #5
   1ceb6:	f00e fef9 	bl	2bcac <sys_put_le32>
	if (err == -EINVAL) {
   1ceba:	e5fa      	b.n	1cab2 <hci_cmd_handle+0x152>
		le_set_adv_param(cmd, evt);
   1cebc:	68a4      	ldr	r4, [r4, #8]
	status = ll_adv_params_set(min_interval, cmd->type,
   1cebe:	7ba5      	ldrb	r5, [r4, #14]
   1cec0:	79a3      	ldrb	r3, [r4, #6]
   1cec2:	7962      	ldrb	r2, [r4, #5]
   1cec4:	7921      	ldrb	r1, [r4, #4]
   1cec6:	8820      	ldrh	r0, [r4, #0]
   1cec8:	9502      	str	r5, [sp, #8]
   1ceca:	7b65      	ldrb	r5, [r4, #13]
   1cecc:	9501      	str	r5, [sp, #4]
				   &cmd->direct_addr.a.val[0], cmd->channel_map,
   1cece:	3407      	adds	r4, #7
	status = ll_adv_params_set(min_interval, cmd->type,
   1ced0:	9400      	str	r4, [sp, #0]
   1ced2:	f002 f92d 	bl	1f130 <ll_adv_params_set>
   1ced6:	e79d      	b.n	1ce14 <hci_cmd_handle+0x4b4>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1ced8:	2102      	movs	r1, #2
   1ceda:	a809      	add	r0, sp, #36	; 0x24
   1cedc:	f7ff fc06 	bl	1c6ec <hci_cmd_complete>
	rp->status = 0x00;
   1cee0:	2300      	movs	r3, #0
   1cee2:	7003      	strb	r3, [r0, #0]
	rp->tx_power_level = 0;
   1cee4:	7043      	strb	r3, [r0, #1]
	if (err == -EINVAL) {
   1cee6:	e5e4      	b.n	1cab2 <hci_cmd_handle+0x152>
	status = ll_adv_data_set(cmd->len, &cmd->data[0]);
   1cee8:	68a1      	ldr	r1, [r4, #8]
   1ceea:	f811 0b01 	ldrb.w	r0, [r1], #1
   1ceee:	f002 f9af 	bl	1f250 <ll_adv_data_set>
   1cef2:	e78f      	b.n	1ce14 <hci_cmd_handle+0x4b4>
	status = ll_adv_scan_rsp_set(cmd->len, &cmd->data[0]);
   1cef4:	68a1      	ldr	r1, [r4, #8]
   1cef6:	f811 0b01 	ldrb.w	r0, [r1], #1
   1cefa:	f002 fa01 	bl	1f300 <ll_adv_scan_rsp_set>
   1cefe:	e789      	b.n	1ce14 <hci_cmd_handle+0x4b4>
	status = ll_adv_enable(cmd->enable);
   1cf00:	68a3      	ldr	r3, [r4, #8]
   1cf02:	7818      	ldrb	r0, [r3, #0]
   1cf04:	f7ef fb70 	bl	c5e8 <ll_adv_enable>
   1cf08:	e784      	b.n	1ce14 <hci_cmd_handle+0x4b4>
		le_set_scan_param(cmd, evt);
   1cf0a:	68a4      	ldr	r4, [r4, #8]
	status = ll_scan_params_set(cmd->scan_type, interval, window,
   1cf0c:	7963      	ldrb	r3, [r4, #5]
   1cf0e:	f8b4 2003 	ldrh.w	r2, [r4, #3]
   1cf12:	f8b4 1001 	ldrh.w	r1, [r4, #1]
   1cf16:	7820      	ldrb	r0, [r4, #0]
   1cf18:	79a4      	ldrb	r4, [r4, #6]
   1cf1a:	9400      	str	r4, [sp, #0]
   1cf1c:	f7ef fe60 	bl	cbe0 <ll_scan_params_set>
   1cf20:	e778      	b.n	1ce14 <hci_cmd_handle+0x4b4>
		le_set_scan_enable(cmd, evt);
   1cf22:	68a2      	ldr	r2, [r4, #8]
	if (cmd->enable && cmd->filter_dup) {
   1cf24:	4b59      	ldr	r3, [pc, #356]	; (1d08c <hci_cmd_handle+0x72c>)
   1cf26:	7810      	ldrb	r0, [r2, #0]
   1cf28:	b140      	cbz	r0, 1cf3c <hci_cmd_handle+0x5dc>
   1cf2a:	7852      	ldrb	r2, [r2, #1]
   1cf2c:	b132      	cbz	r2, 1cf3c <hci_cmd_handle+0x5dc>
		dup_count = 0;
   1cf2e:	2200      	movs	r2, #0
   1cf30:	601a      	str	r2, [r3, #0]
		dup_curr = 0U;
   1cf32:	4b57      	ldr	r3, [pc, #348]	; (1d090 <hci_cmd_handle+0x730>)
		dup_count = -1;
   1cf34:	601a      	str	r2, [r3, #0]
	status = ll_scan_enable(cmd->enable);
   1cf36:	f00f f87e 	bl	2c036 <ll_scan_enable>
   1cf3a:	e76b      	b.n	1ce14 <hci_cmd_handle+0x4b4>
		dup_count = -1;
   1cf3c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1cf40:	e7f8      	b.n	1cf34 <hci_cmd_handle+0x5d4>
		le_create_connection(cmd, evt);
   1cf42:	68a4      	ldr	r4, [r4, #8]
	status = ll_create_connection(scan_interval, scan_window,
   1cf44:	f8b4 5013 	ldrh.w	r5, [r4, #19]
   1cf48:	7963      	ldrb	r3, [r4, #5]
   1cf4a:	7922      	ldrb	r2, [r4, #4]
   1cf4c:	8861      	ldrh	r1, [r4, #2]
   1cf4e:	8820      	ldrh	r0, [r4, #0]
   1cf50:	9504      	str	r5, [sp, #16]
   1cf52:	f8b4 5011 	ldrh.w	r5, [r4, #17]
   1cf56:	9503      	str	r5, [sp, #12]
   1cf58:	f8b4 500f 	ldrh.w	r5, [r4, #15]
   1cf5c:	9502      	str	r5, [sp, #8]
   1cf5e:	7b25      	ldrb	r5, [r4, #12]
   1cf60:	9501      	str	r5, [sp, #4]
   1cf62:	3406      	adds	r4, #6
   1cf64:	9400      	str	r4, [sp, #0]
   1cf66:	f006 f835 	bl	22fd4 <ll_create_connection>
   1cf6a:	e561      	b.n	1ca30 <hci_cmd_handle+0xd0>
	status = ll_connect_disable(node_rx);
   1cf6c:	4638      	mov	r0, r7
   1cf6e:	f006 fa91 	bl	23494 <ll_connect_disable>
   1cf72:	e74f      	b.n	1ce14 <hci_cmd_handle+0x4b4>
	status = ll_chm_update(&cmd->ch_map[0]);
   1cf74:	68a0      	ldr	r0, [r4, #8]
   1cf76:	f00f fcb5 	bl	2c8e4 <ll_chm_update>
   1cf7a:	e74b      	b.n	1ce14 <hci_cmd_handle+0x4b4>
		le_start_encryption(cmd, evt);
   1cf7c:	68a2      	ldr	r2, [r4, #8]
				 (u8_t *)&cmd->rand,
   1cf7e:	4611      	mov	r1, r2
	status = ll_enc_req_send(handle,
   1cf80:	f102 030c 	add.w	r3, r2, #12
   1cf84:	f831 0b02 	ldrh.w	r0, [r1], #2
   1cf88:	320a      	adds	r2, #10
   1cf8a:	f00f fcde 	bl	2c94a <ll_enc_req_send>
	*evt = cmd_status(status);
   1cf8e:	e54f      	b.n	1ca30 <hci_cmd_handle+0xd0>
	handle = sys_le16_to_cpu(cmd->handle);
   1cf90:	68a2      	ldr	r2, [r4, #8]
   1cf92:	f832 4b02 	ldrh.w	r4, [r2], #2
	status = ll_start_enc_req_send(handle, 0x00, &cmd->ltk[0]);
   1cf96:	2100      	movs	r1, #0
   1cf98:	4620      	mov	r0, r4
   1cf9a:	f00f fc5a 	bl	2c852 <ll_start_enc_req_send>
   1cf9e:	e5b5      	b.n	1cb0c <hci_cmd_handle+0x1ac>
	handle = sys_le16_to_cpu(cmd->handle);
   1cfa0:	68a3      	ldr	r3, [r4, #8]
	status = ll_start_enc_req_send(handle, BT_HCI_ERR_PIN_OR_KEY_MISSING,
   1cfa2:	2200      	movs	r2, #0
	handle = sys_le16_to_cpu(cmd->handle);
   1cfa4:	881c      	ldrh	r4, [r3, #0]
	status = ll_start_enc_req_send(handle, BT_HCI_ERR_PIN_OR_KEY_MISSING,
   1cfa6:	2106      	movs	r1, #6
   1cfa8:	e7f6      	b.n	1cf98 <hci_cmd_handle+0x638>
	handle = sys_le16_to_cpu(cmd->handle);
   1cfaa:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1cfac:	2108      	movs	r1, #8
   1cfae:	a809      	add	r0, sp, #36	; 0x24
	handle = sys_le16_to_cpu(cmd->handle);
   1cfb0:	881d      	ldrh	r5, [r3, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1cfb2:	f7ff fb9b 	bl	1c6ec <hci_cmd_complete>
	handle = sys_le16_to_cpu(cmd->handle);
   1cfb6:	b2ae      	uxth	r6, r5
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1cfb8:	4604      	mov	r4, r0
	status = ll_chm_get(handle, rp->ch_map);
   1cfba:	1cc1      	adds	r1, r0, #3
   1cfbc:	4630      	mov	r0, r6
   1cfbe:	f00f fa67 	bl	2c490 <ll_chm_get>
   1cfc2:	e586      	b.n	1cad2 <hci_cmd_handle+0x172>
	handle = sys_le16_to_cpu(cmd->handle);
   1cfc4:	68a3      	ldr	r3, [r4, #8]
	status = ll_feature_req_send(handle);
   1cfc6:	8818      	ldrh	r0, [r3, #0]
   1cfc8:	f00f fa89 	bl	2c4de <ll_feature_req_send>
	*evt = cmd_status(status);
   1cfcc:	e530      	b.n	1ca30 <hci_cmd_handle+0xd0>
		le_conn_update(cmd, evt);
   1cfce:	68a2      	ldr	r2, [r4, #8]
	status = ll_conn_update(handle, 0, 0, conn_interval_min,
   1cfd0:	8911      	ldrh	r1, [r2, #8]
   1cfd2:	8853      	ldrh	r3, [r2, #2]
   1cfd4:	8810      	ldrh	r0, [r2, #0]
   1cfd6:	9102      	str	r1, [sp, #8]
   1cfd8:	88d1      	ldrh	r1, [r2, #6]
   1cfda:	9101      	str	r1, [sp, #4]
   1cfdc:	8892      	ldrh	r2, [r2, #4]
   1cfde:	9200      	str	r2, [sp, #0]
   1cfe0:	2200      	movs	r2, #0
   1cfe2:	4611      	mov	r1, r2
   1cfe4:	f00f f9dc 	bl	2c3a0 <ll_conn_update>
	*evt = cmd_status(status);
   1cfe8:	e522      	b.n	1ca30 <hci_cmd_handle+0xd0>
		le_conn_param_req_reply(cmd, evt);
   1cfea:	68a2      	ldr	r2, [r4, #8]
	status = ll_conn_update(handle, 2, 0, interval_min, interval_max,
   1cfec:	8911      	ldrh	r1, [r2, #8]
	handle = sys_le16_to_cpu(cmd->handle);
   1cfee:	8814      	ldrh	r4, [r2, #0]
	status = ll_conn_update(handle, 2, 0, interval_min, interval_max,
   1cff0:	8853      	ldrh	r3, [r2, #2]
   1cff2:	9102      	str	r1, [sp, #8]
   1cff4:	88d1      	ldrh	r1, [r2, #6]
   1cff6:	9101      	str	r1, [sp, #4]
   1cff8:	8892      	ldrh	r2, [r2, #4]
   1cffa:	9200      	str	r2, [sp, #0]
   1cffc:	2200      	movs	r2, #0
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0);
   1cffe:	2102      	movs	r1, #2
   1d000:	4620      	mov	r0, r4
   1d002:	f00f f9cd 	bl	2c3a0 <ll_conn_update>
   1d006:	e581      	b.n	1cb0c <hci_cmd_handle+0x1ac>
		le_conn_param_req_neg_reply(cmd, evt);
   1d008:	68a3      	ldr	r3, [r4, #8]
	handle = sys_le16_to_cpu(cmd->handle);
   1d00a:	881c      	ldrh	r4, [r3, #0]
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0);
   1d00c:	789a      	ldrb	r2, [r3, #2]
   1d00e:	2300      	movs	r3, #0
   1d010:	e9cd 3301 	strd	r3, r3, [sp, #4]
   1d014:	9300      	str	r3, [sp, #0]
   1d016:	e7f2      	b.n	1cffe <hci_cmd_handle+0x69e>
		le_set_data_len(cmd, evt);
   1d018:	68a3      	ldr	r3, [r4, #8]
	handle = sys_le16_to_cpu(cmd->handle);
   1d01a:	881c      	ldrh	r4, [r3, #0]
	status = ll_length_req_send(handle, tx_octets, tx_time);
   1d01c:	889a      	ldrh	r2, [r3, #4]
   1d01e:	8859      	ldrh	r1, [r3, #2]
   1d020:	4620      	mov	r0, r4
   1d022:	f00f fa7e 	bl	2c522 <ll_length_req_send>
   1d026:	e571      	b.n	1cb0c <hci_cmd_handle+0x1ac>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1d028:	2105      	movs	r1, #5
   1d02a:	a809      	add	r0, sp, #36	; 0x24
   1d02c:	f7ff fb5e 	bl	1c6ec <hci_cmd_complete>
	ll_length_default_get(&max_tx_octets, &max_tx_time);
   1d030:	a90a      	add	r1, sp, #40	; 0x28
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1d032:	4604      	mov	r4, r0
	ll_length_default_get(&max_tx_octets, &max_tx_time);
   1d034:	f10d 0022 	add.w	r0, sp, #34	; 0x22
   1d038:	f003 fb1a 	bl	20670 <ll_length_default_get>
	rp->max_tx_octets = sys_cpu_to_le16(max_tx_octets);
   1d03c:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
   1d040:	f8a4 3001 	strh.w	r3, [r4, #1]
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
   1d044:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
   1d048:	f8a4 3003 	strh.w	r3, [r4, #3]
	rp->status = 0x00;
   1d04c:	2300      	movs	r3, #0
   1d04e:	7023      	strb	r3, [r4, #0]
	if (err == -EINVAL) {
   1d050:	e52f      	b.n	1cab2 <hci_cmd_handle+0x152>
		le_write_default_data_len(cmd, evt);
   1d052:	68a3      	ldr	r3, [r4, #8]
	status = ll_length_default_set(max_tx_octets, max_tx_time);
   1d054:	8859      	ldrh	r1, [r3, #2]
   1d056:	8818      	ldrh	r0, [r3, #0]
   1d058:	f003 fb16 	bl	20688 <ll_length_default_set>
   1d05c:	e6da      	b.n	1ce14 <hci_cmd_handle+0x4b4>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1d05e:	2109      	movs	r1, #9
   1d060:	a809      	add	r0, sp, #36	; 0x24
   1d062:	f7ff fb43 	bl	1c6ec <hci_cmd_complete>
	ll_length_max_get(&max_tx_octets, &max_tx_time,
   1d066:	ab0a      	add	r3, sp, #40	; 0x28
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1d068:	4604      	mov	r4, r0
	ll_length_max_get(&max_tx_octets, &max_tx_time,
   1d06a:	f10d 0222 	add.w	r2, sp, #34	; 0x22
   1d06e:	a908      	add	r1, sp, #32
   1d070:	f10d 001e 	add.w	r0, sp, #30
   1d074:	f00f fa88 	bl	2c588 <ll_length_max_get>
	rp->max_tx_octets = sys_cpu_to_le16(max_tx_octets);
   1d078:	f8bd 301e 	ldrh.w	r3, [sp, #30]
   1d07c:	f8a4 3001 	strh.w	r3, [r4, #1]
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
   1d080:	f8bd 3020 	ldrh.w	r3, [sp, #32]
   1d084:	e7e0      	b.n	1d048 <hci_cmd_handle+0x6e8>
   1d086:	bf00      	nop
   1d088:	2000f800 	.word	0x2000f800
   1d08c:	20001e70 	.word	0x20001e70
   1d090:	20001e74 	.word	0x20001e74
	handle = sys_le16_to_cpu(cmd->handle);
   1d094:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1d096:	2105      	movs	r1, #5
   1d098:	a809      	add	r0, sp, #36	; 0x24
	handle = sys_le16_to_cpu(cmd->handle);
   1d09a:	881d      	ldrh	r5, [r3, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1d09c:	f7ff fb26 	bl	1c6ec <hci_cmd_complete>
	handle = sys_le16_to_cpu(cmd->handle);
   1d0a0:	b2ae      	uxth	r6, r5
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1d0a2:	4604      	mov	r4, r0
	status = ll_phy_get(handle, &rp->tx_phy, &rp->rx_phy);
   1d0a4:	1d02      	adds	r2, r0, #4
   1d0a6:	1cc1      	adds	r1, r0, #3
   1d0a8:	4630      	mov	r0, r6
   1d0aa:	f00f fa76 	bl	2c59a <ll_phy_get>
 * @return least significant bit set, 0 if @a op is 0
 */

static ALWAYS_INLINE unsigned int find_lsb_set(u32_t op)
{
	return __builtin_ffs(op);
   1d0ae:	78e2      	ldrb	r2, [r4, #3]
	rp->status = status;
   1d0b0:	7020      	strb	r0, [r4, #0]
   1d0b2:	2a00      	cmp	r2, #0
   1d0b4:	fa92 f3a2 	rbit	r3, r2
   1d0b8:	fab3 f383 	clz	r3, r3
   1d0bc:	7922      	ldrb	r2, [r4, #4]
	rp->handle = sys_cpu_to_le16(handle);
   1d0be:	f8a4 5001 	strh.w	r5, [r4, #1]
   1d0c2:	bf08      	it	eq
   1d0c4:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   1d0c8:	3301      	adds	r3, #1
	rp->tx_phy = find_lsb_set(rp->tx_phy);
   1d0ca:	70e3      	strb	r3, [r4, #3]
   1d0cc:	2a00      	cmp	r2, #0
   1d0ce:	fa92 f3a2 	rbit	r3, r2
   1d0d2:	fab3 f383 	clz	r3, r3
   1d0d6:	bf08      	it	eq
   1d0d8:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   1d0dc:	3301      	adds	r3, #1
	rp->rx_phy = find_lsb_set(rp->rx_phy);
   1d0de:	7123      	strb	r3, [r4, #4]
	if (err == -EINVAL) {
   1d0e0:	e4e7      	b.n	1cab2 <hci_cmd_handle+0x152>
		le_set_default_phy(cmd, evt);
   1d0e2:	68a3      	ldr	r3, [r4, #8]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
   1d0e4:	781a      	ldrb	r2, [r3, #0]
   1d0e6:	07d1      	lsls	r1, r2, #31
		cmd->tx_phys = 0x07;
   1d0e8:	bf44      	itt	mi
   1d0ea:	2107      	movmi	r1, #7
   1d0ec:	7059      	strbmi	r1, [r3, #1]
	if (cmd->all_phys & BT_HCI_LE_PHY_RX_ANY) {
   1d0ee:	0792      	lsls	r2, r2, #30
		cmd->rx_phys = 0x07;
   1d0f0:	bf44      	itt	mi
   1d0f2:	2207      	movmi	r2, #7
   1d0f4:	709a      	strbmi	r2, [r3, #2]
	status = ll_phy_default_set(cmd->tx_phys, cmd->rx_phys);
   1d0f6:	7899      	ldrb	r1, [r3, #2]
   1d0f8:	7858      	ldrb	r0, [r3, #1]
   1d0fa:	f003 facf 	bl	2069c <ll_phy_default_set>
   1d0fe:	e689      	b.n	1ce14 <hci_cmd_handle+0x4b4>
		le_set_phy(cmd, evt);
   1d100:	68a3      	ldr	r3, [r4, #8]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
   1d102:	7899      	ldrb	r1, [r3, #2]
	handle = sys_le16_to_cpu(cmd->handle);
   1d104:	8818      	ldrh	r0, [r3, #0]
	phy_opts = sys_le16_to_cpu(cmd->phy_opts);
   1d106:	f8b3 4005 	ldrh.w	r4, [r3, #5]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
   1d10a:	07cf      	lsls	r7, r1, #31
		cmd->tx_phys |= mask_phys;
   1d10c:	bf42      	ittt	mi
   1d10e:	78da      	ldrbmi	r2, [r3, #3]
   1d110:	f042 0207 	orrmi.w	r2, r2, #7
   1d114:	70da      	strbmi	r2, [r3, #3]
	if (cmd->all_phys & BT_HCI_LE_PHY_RX_ANY) {
   1d116:	078e      	lsls	r6, r1, #30
		cmd->rx_phys |= mask_phys;
   1d118:	bf48      	it	mi
   1d11a:	791a      	ldrbmi	r2, [r3, #4]
	if ((cmd->tx_phys | cmd->rx_phys) & ~mask_phys) {
   1d11c:	78d9      	ldrb	r1, [r3, #3]
		cmd->rx_phys |= mask_phys;
   1d11e:	bf44      	itt	mi
   1d120:	f042 0207 	orrmi.w	r2, r2, #7
   1d124:	711a      	strbmi	r2, [r3, #4]
	if ((cmd->tx_phys | cmd->rx_phys) & ~mask_phys) {
   1d126:	791b      	ldrb	r3, [r3, #4]
   1d128:	ea41 0203 	orr.w	r2, r1, r3
   1d12c:	f012 0ff8 	tst.w	r2, #248	; 0xf8
   1d130:	d001      	beq.n	1d136 <hci_cmd_handle+0x7d6>
		*evt = cmd_status(BT_HCI_ERR_UNSUPP_FEATURE_PARAM_VAL);
   1d132:	2011      	movs	r0, #17
   1d134:	e47c      	b.n	1ca30 <hci_cmd_handle+0xd0>
	if (!(cmd->tx_phys & 0x07) ||
   1d136:	074d      	lsls	r5, r1, #29
   1d138:	d001      	beq.n	1d13e <hci_cmd_handle+0x7de>
   1d13a:	075a      	lsls	r2, r3, #29
   1d13c:	d101      	bne.n	1d142 <hci_cmd_handle+0x7e2>
		*evt = cmd_status(BT_HCI_ERR_INVALID_PARAM);
   1d13e:	2012      	movs	r0, #18
   1d140:	e476      	b.n	1ca30 <hci_cmd_handle+0xd0>
	if (phy_opts & 0x03) {
   1d142:	f014 0203 	ands.w	r2, r4, #3
		phy_opts -= 1U;
   1d146:	bf1c      	itt	ne
   1d148:	f104 34ff 	addne.w	r4, r4, #4294967295	; 0xffffffff
		phy_opts &= 1;
   1d14c:	f004 0201 	andne.w	r2, r4, #1
	status = ll_phy_req_send(handle, cmd->tx_phys, phy_opts,
   1d150:	f00f fa37 	bl	2c5c2 <ll_phy_req_send>
	*evt = cmd_status(status);
   1d154:	e46c      	b.n	1ca30 <hci_cmd_handle+0xd0>
		le_add_dev_to_rl(cmd, evt);
   1d156:	68a0      	ldr	r0, [r4, #8]
	status = ll_rl_add(&cmd->peer_id_addr, cmd->peer_irk, cmd->local_irk);
   1d158:	f100 0217 	add.w	r2, r0, #23
   1d15c:	1dc1      	adds	r1, r0, #7
   1d15e:	f006 fd7f 	bl	23c60 <ll_rl_add>
   1d162:	e657      	b.n	1ce14 <hci_cmd_handle+0x4b4>
	status = ll_rl_remove(&cmd->peer_id_addr);
   1d164:	68a0      	ldr	r0, [r4, #8]
   1d166:	f006 fe1d 	bl	23da4 <ll_rl_remove>
   1d16a:	e653      	b.n	1ce14 <hci_cmd_handle+0x4b4>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   1d16c:	2101      	movs	r1, #1
   1d16e:	a809      	add	r0, sp, #36	; 0x24
   1d170:	f7ff fabc 	bl	1c6ec <hci_cmd_complete>
   1d174:	4604      	mov	r4, r0
	ccst->status = ll_rl_clear();
   1d176:	f006 fbd1 	bl	2391c <ll_rl_clear>
   1d17a:	e664      	b.n	1ce46 <hci_cmd_handle+0x4e6>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1d17c:	2102      	movs	r1, #2
   1d17e:	a809      	add	r0, sp, #36	; 0x24
   1d180:	f7ff fab4 	bl	1c6ec <hci_cmd_complete>
   1d184:	4604      	mov	r4, r0
	rp->rl_size = ll_rl_size_get();
   1d186:	f00f fc67 	bl	2ca58 <ll_rl_size_get>
   1d18a:	7060      	strb	r0, [r4, #1]
   1d18c:	e75e      	b.n	1d04c <hci_cmd_handle+0x6ec>
	memcpy(dst, src, sizeof(*dst));
   1d18e:	2207      	movs	r2, #7
   1d190:	68a1      	ldr	r1, [r4, #8]
   1d192:	a80a      	add	r0, sp, #40	; 0x28
   1d194:	f00d f95b 	bl	2a44e <memcpy>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1d198:	2107      	movs	r1, #7
   1d19a:	a809      	add	r0, sp, #36	; 0x24
   1d19c:	f7ff faa6 	bl	1c6ec <hci_cmd_complete>
   1d1a0:	4604      	mov	r4, r0
	rp->status = ll_rl_crpa_get(&peer_id_addr, &rp->peer_rpa);
   1d1a2:	1c41      	adds	r1, r0, #1
   1d1a4:	a80a      	add	r0, sp, #40	; 0x28
   1d1a6:	f006 fe8d 	bl	23ec4 <ll_rl_crpa_get>
   1d1aa:	e64c      	b.n	1ce46 <hci_cmd_handle+0x4e6>
   1d1ac:	2207      	movs	r2, #7
   1d1ae:	68a1      	ldr	r1, [r4, #8]
   1d1b0:	a80a      	add	r0, sp, #40	; 0x28
   1d1b2:	f00d f94c 	bl	2a44e <memcpy>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1d1b6:	2107      	movs	r1, #7
   1d1b8:	a809      	add	r0, sp, #36	; 0x24
   1d1ba:	f7ff fa97 	bl	1c6ec <hci_cmd_complete>
   1d1be:	4604      	mov	r4, r0
	rp->status = ll_rl_lrpa_get(&peer_id_addr, &rp->local_rpa);
   1d1c0:	1c41      	adds	r1, r0, #1
   1d1c2:	a80a      	add	r0, sp, #40	; 0x28
   1d1c4:	f006 fea0 	bl	23f08 <ll_rl_lrpa_get>
   1d1c8:	e63d      	b.n	1ce46 <hci_cmd_handle+0x4e6>
	u8_t enable = cmd->enable;
   1d1ca:	68a3      	ldr	r3, [r4, #8]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   1d1cc:	2101      	movs	r1, #1
   1d1ce:	a809      	add	r0, sp, #36	; 0x24
	u8_t enable = cmd->enable;
   1d1d0:	781d      	ldrb	r5, [r3, #0]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
   1d1d2:	f7ff fa8b 	bl	1c6ec <hci_cmd_complete>
   1d1d6:	4604      	mov	r4, r0
	ccst->status = ll_rl_enable(enable);
   1d1d8:	4628      	mov	r0, r5
   1d1da:	f006 fbdd 	bl	23998 <ll_rl_enable>
   1d1de:	e632      	b.n	1ce46 <hci_cmd_handle+0x4e6>
	u16_t timeout = sys_le16_to_cpu(cmd->rpa_timeout);
   1d1e0:	68a3      	ldr	r3, [r4, #8]
	ll_rl_timeout_set(timeout);
   1d1e2:	8818      	ldrh	r0, [r3, #0]
   1d1e4:	f006 fbee 	bl	239c4 <ll_rl_timeout_set>
   1d1e8:	e444      	b.n	1ca74 <hci_cmd_handle+0x114>
		le_set_privacy_mode(cmd, evt);
   1d1ea:	68a0      	ldr	r0, [r4, #8]
	status = ll_priv_mode_set(&cmd->id_addr, cmd->mode);
   1d1ec:	79c1      	ldrb	r1, [r0, #7]
   1d1ee:	f006 fea5 	bl	23f3c <ll_priv_mode_set>
   1d1f2:	e60f      	b.n	1ce14 <hci_cmd_handle+0x4b4>
	rp = hci_cmd_complete(evt, sizeof(*rp));
   1d1f4:	2103      	movs	r1, #3
   1d1f6:	a809      	add	r0, sp, #36	; 0x24
   1d1f8:	f7ff fa78 	bl	1c6ec <hci_cmd_complete>
	rp->status = 0x00;
   1d1fc:	4601      	mov	r1, r0
   1d1fe:	2300      	movs	r3, #0
   1d200:	f801 3b02 	strb.w	r3, [r1], #2
	ll_tx_pwr_get(&rp->min_tx_power, &rp->max_tx_power);
   1d204:	3001      	adds	r0, #1
   1d206:	f00e fd4d 	bl	2bca4 <ll_tx_pwr_get>
	if (err == -EINVAL) {
   1d20a:	e452      	b.n	1cab2 <hci_cmd_handle+0x152>

0001d20c <hci_acl_handle>:
{
   1d20c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	*evt = NULL;
   1d210:	2300      	movs	r3, #0
   1d212:	600b      	str	r3, [r1, #0]
	if (buf->len < sizeof(*acl)) {
   1d214:	8983      	ldrh	r3, [r0, #12]
   1d216:	2b03      	cmp	r3, #3
{
   1d218:	4606      	mov	r6, r0
   1d21a:	460f      	mov	r7, r1
	if (buf->len < sizeof(*acl)) {
   1d21c:	d816      	bhi.n	1d24c <hci_acl_handle+0x40>
		BT_ERR("No HCI ACL header");
   1d21e:	4b4c      	ldr	r3, [pc, #304]	; (1d350 <hci_acl_handle+0x144>)
   1d220:	681b      	ldr	r3, [r3, #0]
   1d222:	0758      	lsls	r0, r3, #29
   1d224:	d103      	bne.n	1d22e <hci_acl_handle+0x22>
		return -EINVAL;
   1d226:	f06f 0015 	mvn.w	r0, #21
}
   1d22a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		BT_ERR("No HCI ACL header");
   1d22e:	2301      	movs	r3, #1
   1d230:	f04f 0100 	mov.w	r1, #0
   1d234:	f363 0107 	bfi	r1, r3, #0, #8
   1d238:	4a46      	ldr	r2, [pc, #280]	; (1d354 <hci_acl_handle+0x148>)
   1d23a:	4b47      	ldr	r3, [pc, #284]	; (1d358 <hci_acl_handle+0x14c>)
   1d23c:	4847      	ldr	r0, [pc, #284]	; (1d35c <hci_acl_handle+0x150>)
   1d23e:	1a9b      	subs	r3, r3, r2
   1d240:	08db      	lsrs	r3, r3, #3
   1d242:	f363 118f 	bfi	r1, r3, #6, #10
		BT_ERR("Invalid HCI ACL packet length");
   1d246:	f00b fb78 	bl	2893a <log_0>
   1d24a:	e7ec      	b.n	1d226 <hci_acl_handle+0x1a>
	acl = net_buf_pull_mem(buf, sizeof(*acl));
   1d24c:	2104      	movs	r1, #4
   1d24e:	3008      	adds	r0, #8
   1d250:	f00f fcc7 	bl	2cbe2 <net_buf_simple_pull_mem>
	if (buf->len < len) {
   1d254:	89b3      	ldrh	r3, [r6, #12]
	len = sys_le16_to_cpu(acl->len);
   1d256:	f8b0 8002 	ldrh.w	r8, [r0, #2]
	handle = sys_le16_to_cpu(acl->handle);
   1d25a:	8800      	ldrh	r0, [r0, #0]
	if (buf->len < len) {
   1d25c:	4543      	cmp	r3, r8
   1d25e:	d210      	bcs.n	1d282 <hci_acl_handle+0x76>
		BT_ERR("Invalid HCI ACL packet length");
   1d260:	4b3b      	ldr	r3, [pc, #236]	; (1d350 <hci_acl_handle+0x144>)
   1d262:	681b      	ldr	r3, [r3, #0]
   1d264:	0759      	lsls	r1, r3, #29
   1d266:	d0de      	beq.n	1d226 <hci_acl_handle+0x1a>
   1d268:	2301      	movs	r3, #1
   1d26a:	f04f 0100 	mov.w	r1, #0
   1d26e:	f363 0107 	bfi	r1, r3, #0, #8
   1d272:	4a38      	ldr	r2, [pc, #224]	; (1d354 <hci_acl_handle+0x148>)
   1d274:	4b38      	ldr	r3, [pc, #224]	; (1d358 <hci_acl_handle+0x14c>)
   1d276:	483a      	ldr	r0, [pc, #232]	; (1d360 <hci_acl_handle+0x154>)
   1d278:	1a9b      	subs	r3, r3, r2
   1d27a:	08db      	lsrs	r3, r3, #3
   1d27c:	f363 118f 	bfi	r1, r3, #6, #10
   1d280:	e7e1      	b.n	1d246 <hci_acl_handle+0x3a>
	flags = bt_acl_flags(handle);
   1d282:	ea4f 3910 	mov.w	r9, r0, lsr #12
	handle = bt_acl_handle(handle);
   1d286:	f3c0 050b 	ubfx	r5, r0, #0, #12
	node_tx = ll_tx_mem_acquire();
   1d28a:	f003 f989 	bl	205a0 <ll_tx_mem_acquire>
	if (!node_tx) {
   1d28e:	4604      	mov	r4, r0
   1d290:	bb60      	cbnz	r0, 1d2ec <hci_acl_handle+0xe0>
		BT_ERR("Tx Buffer Overflow");
   1d292:	4b2f      	ldr	r3, [pc, #188]	; (1d350 <hci_acl_handle+0x144>)
   1d294:	681b      	ldr	r3, [r3, #0]
   1d296:	075a      	lsls	r2, r3, #29
   1d298:	d00d      	beq.n	1d2b6 <hci_acl_handle+0xaa>
   1d29a:	2301      	movs	r3, #1
   1d29c:	f04f 0100 	mov.w	r1, #0
   1d2a0:	f363 0107 	bfi	r1, r3, #0, #8
   1d2a4:	4a2b      	ldr	r2, [pc, #172]	; (1d354 <hci_acl_handle+0x148>)
   1d2a6:	4b2c      	ldr	r3, [pc, #176]	; (1d358 <hci_acl_handle+0x14c>)
   1d2a8:	482e      	ldr	r0, [pc, #184]	; (1d364 <hci_acl_handle+0x158>)
   1d2aa:	1a9b      	subs	r3, r3, r2
   1d2ac:	08db      	lsrs	r3, r3, #3
   1d2ae:	f363 118f 	bfi	r1, r3, #6, #10
   1d2b2:	f00b fb42 	bl	2893a <log_0>
	if (!(event_mask & BT_EVT_MASK_DATA_BUFFER_OVERFLOW)) {
   1d2b6:	4b2c      	ldr	r3, [pc, #176]	; (1d368 <hci_acl_handle+0x15c>)
   1d2b8:	6819      	ldr	r1, [r3, #0]
   1d2ba:	2300      	movs	r3, #0
   1d2bc:	f001 7200 	and.w	r2, r1, #33554432	; 0x2000000
   1d2c0:	4313      	orrs	r3, r2
   1d2c2:	d010      	beq.n	1d2e6 <hci_acl_handle+0xda>
	*buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   1d2c4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1d2c8:	2001      	movs	r0, #1
   1d2ca:	f7fa fa55 	bl	17778 <bt_buf_get_rx>
	hci_evt_create(*buf, BT_HCI_EVT_DATA_BUF_OVERFLOW, sizeof(*ep));
   1d2ce:	2201      	movs	r2, #1
	*buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
   1d2d0:	6038      	str	r0, [r7, #0]
	hci_evt_create(*buf, BT_HCI_EVT_DATA_BUF_OVERFLOW, sizeof(*ep));
   1d2d2:	211a      	movs	r1, #26
   1d2d4:	f00e fcf7 	bl	2bcc6 <hci_evt_create>
	ep = net_buf_add(*buf, sizeof(*ep));
   1d2d8:	6838      	ldr	r0, [r7, #0]
   1d2da:	2101      	movs	r1, #1
   1d2dc:	3008      	adds	r0, #8
   1d2de:	f00f fc4f 	bl	2cb80 <net_buf_simple_add>
	ep->link_type = BT_OVERFLOW_LINK_ACL;
   1d2e2:	2301      	movs	r3, #1
   1d2e4:	7003      	strb	r3, [r0, #0]
		return -ENOBUFS;
   1d2e6:	f06f 0036 	mvn.w	r0, #54	; 0x36
   1d2ea:	e79e      	b.n	1d22a <hci_acl_handle+0x1e>
	if (flags == BT_ACL_START_NO_FLUSH || flags == BT_ACL_START) {
   1d2ec:	f1b9 0f00 	cmp.w	r9, #0
   1d2f0:	d02b      	beq.n	1d34a <hci_acl_handle+0x13e>
		pdu_data->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   1d2f2:	f1b9 0f02 	cmp.w	r9, #2
   1d2f6:	bf0c      	ite	eq
   1d2f8:	2202      	moveq	r2, #2
   1d2fa:	2201      	movne	r2, #1
   1d2fc:	7923      	ldrb	r3, [r4, #4]
	pdu_data->len = len;
   1d2fe:	f884 8005 	strb.w	r8, [r4, #5]
   1d302:	f362 0301 	bfi	r3, r2, #0, #2
	memcpy(&pdu_data->lldata[0], buf->data, len);
   1d306:	68b1      	ldr	r1, [r6, #8]
   1d308:	7123      	strb	r3, [r4, #4]
   1d30a:	4642      	mov	r2, r8
   1d30c:	1de0      	adds	r0, r4, #7
   1d30e:	f00d f89e 	bl	2a44e <memcpy>
	if (ll_tx_mem_enqueue(handle, node_tx)) {
   1d312:	4621      	mov	r1, r4
   1d314:	4628      	mov	r0, r5
   1d316:	f003 f94f 	bl	205b8 <ll_tx_mem_enqueue>
   1d31a:	2800      	cmp	r0, #0
   1d31c:	d085      	beq.n	1d22a <hci_acl_handle+0x1e>
		BT_ERR("Invalid Tx Enqueue");
   1d31e:	4b0c      	ldr	r3, [pc, #48]	; (1d350 <hci_acl_handle+0x144>)
   1d320:	681b      	ldr	r3, [r3, #0]
   1d322:	075b      	lsls	r3, r3, #29
   1d324:	d00d      	beq.n	1d342 <hci_acl_handle+0x136>
   1d326:	2301      	movs	r3, #1
   1d328:	f04f 0100 	mov.w	r1, #0
   1d32c:	f363 0107 	bfi	r1, r3, #0, #8
   1d330:	4a08      	ldr	r2, [pc, #32]	; (1d354 <hci_acl_handle+0x148>)
   1d332:	4b09      	ldr	r3, [pc, #36]	; (1d358 <hci_acl_handle+0x14c>)
   1d334:	480d      	ldr	r0, [pc, #52]	; (1d36c <hci_acl_handle+0x160>)
   1d336:	1a9b      	subs	r3, r3, r2
   1d338:	08db      	lsrs	r3, r3, #3
   1d33a:	f363 118f 	bfi	r1, r3, #6, #10
   1d33e:	f00b fafc 	bl	2893a <log_0>
		ll_tx_mem_release(node_tx);
   1d342:	4620      	mov	r0, r4
   1d344:	f003 f932 	bl	205ac <ll_tx_mem_release>
   1d348:	e76d      	b.n	1d226 <hci_acl_handle+0x1a>
		pdu_data->ll_id = PDU_DATA_LLID_DATA_START;
   1d34a:	2202      	movs	r2, #2
   1d34c:	e7d6      	b.n	1d2fc <hci_acl_handle+0xf0>
   1d34e:	bf00      	nop
   1d350:	2000ffb8 	.word	0x2000ffb8
   1d354:	0002db28 	.word	0x0002db28
   1d358:	0002db68 	.word	0x0002db68
   1d35c:	00031527 	.word	0x00031527
   1d360:	00031539 	.word	0x00031539
   1d364:	00031557 	.word	0x00031557
   1d368:	2000f7f8 	.word	0x2000f7f8
   1d36c:	0003156a 	.word	0x0003156a

0001d370 <hci_acl_encode>:
	u16_t handle;
	u8_t *data;

	handle = node_rx->hdr.handle;

	switch (pdu_data->ll_id) {
   1d370:	f890 3020 	ldrb.w	r3, [r0, #32]
   1d374:	f003 0303 	and.w	r3, r3, #3
   1d378:	3b01      	subs	r3, #1
   1d37a:	2b01      	cmp	r3, #1
{
   1d37c:	b570      	push	{r4, r5, r6, lr}
   1d37e:	4604      	mov	r4, r0
	switch (pdu_data->ll_id) {
   1d380:	d81f      	bhi.n	1d3c2 <hci_acl_encode+0x52>
	case PDU_DATA_LLID_DATA_CONTINUE:
	case PDU_DATA_LLID_DATA_START:
		acl = (void *)net_buf_add(buf, sizeof(*acl));
   1d382:	f101 0608 	add.w	r6, r1, #8
	handle = node_rx->hdr.handle;
   1d386:	88c5      	ldrh	r5, [r0, #6]
		acl = (void *)net_buf_add(buf, sizeof(*acl));
   1d388:	2104      	movs	r1, #4
   1d38a:	4630      	mov	r0, r6
   1d38c:	f00f fbf8 	bl	2cb80 <net_buf_simple_add>
		if (pdu_data->ll_id == PDU_DATA_LLID_DATA_START) {
   1d390:	f894 3020 	ldrb.w	r3, [r4, #32]
   1d394:	f003 0303 	and.w	r3, r3, #3
   1d398:	2b02      	cmp	r3, #2
			handle_flags = bt_acl_handle_pack(handle, BT_ACL_START);
   1d39a:	bf0c      	ite	eq
   1d39c:	f445 5500 	orreq.w	r5, r5, #8192	; 0x2000
		} else {
			handle_flags = bt_acl_handle_pack(handle, BT_ACL_CONT);
   1d3a0:	f445 5580 	orrne.w	r5, r5, #4096	; 0x1000
		}
		acl->handle = sys_cpu_to_le16(handle_flags);
   1d3a4:	8005      	strh	r5, [r0, #0]
		acl->len = sys_cpu_to_le16(pdu_data->len);
   1d3a6:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
   1d3aa:	8041      	strh	r1, [r0, #2]
		data = (void *)net_buf_add(buf, pdu_data->len);
   1d3ac:	4630      	mov	r0, r6
   1d3ae:	f00f fbe7 	bl	2cb80 <net_buf_simple_add>
		memcpy(data, pdu_data->lldata, pdu_data->len);
   1d3b2:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
   1d3b6:	f104 0123 	add.w	r1, r4, #35	; 0x23

	default:
		LL_ASSERT(0);
		break;
	}
}
   1d3ba:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		memcpy(data, pdu_data->lldata, pdu_data->len);
   1d3be:	f00d b846 	b.w	2a44e <memcpy>
		LL_ASSERT(0);
   1d3c2:	4805      	ldr	r0, [pc, #20]	; (1d3d8 <hci_acl_encode+0x68>)
   1d3c4:	f00a febe 	bl	28144 <printk>
   1d3c8:	4040      	eors	r0, r0
   1d3ca:	f380 8811 	msr	BASEPRI, r0
   1d3ce:	f04f 0003 	mov.w	r0, #3
   1d3d2:	df02      	svc	2
}
   1d3d4:	bd70      	pop	{r4, r5, r6, pc}
   1d3d6:	bf00      	nop
   1d3d8:	000314f5 	.word	0x000314f5

0001d3dc <hci_evt_encode>:
#endif /* CONFIG_BT_CONN */

void hci_evt_encode(struct node_rx_pdu *node_rx, struct net_buf *buf)
{
   1d3dc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct pdu_data *pdu_data = PDU_DATA(node_rx);

	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   1d3e0:	7903      	ldrb	r3, [r0, #4]
   1d3e2:	88c6      	ldrh	r6, [r0, #6]
   1d3e4:	2b02      	cmp	r3, #2
{
   1d3e6:	b089      	sub	sp, #36	; 0x24
   1d3e8:	4604      	mov	r4, r0
   1d3ea:	460d      	mov	r5, r1
	struct pdu_data *pdu_data = PDU_DATA(node_rx);
   1d3ec:	f100 0920 	add.w	r9, r0, #32
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   1d3f0:	f000 8257 	beq.w	1d8a2 <hci_evt_encode+0x4c6>
	switch (node_rx->hdr.type) {
   1d3f4:	3b04      	subs	r3, #4
   1d3f6:	2b0a      	cmp	r3, #10
   1d3f8:	f200 8302 	bhi.w	1da00 <hci_evt_encode+0x624>
   1d3fc:	e8df f013 	tbh	[pc, r3, lsl #1]
   1d400:	0300000b 	.word	0x0300000b
   1d404:	03000300 	.word	0x03000300
   1d408:	015800c6 	.word	0x015800c6
   1d40c:	01a60176 	.word	0x01a60176
   1d410:	01d101bd 	.word	0x01d101bd
   1d414:	01ec      	.short	0x01ec
	const u8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
   1d416:	4bc8      	ldr	r3, [pc, #800]	; (1d738 <hci_evt_encode+0x35c>)
   1d418:	9304      	str	r3, [sp, #16]
   1d41a:	f64f 7304 	movw	r3, #65284	; 0xff04
   1d41e:	f8ad 3014 	strh.w	r3, [sp, #20]
   1d422:	2302      	movs	r3, #2
   1d424:	f88d 3016 	strb.w	r3, [sp, #22]
	rssi = -(node_rx->hdr.rx_ftr.rssi);
   1d428:	7f07      	ldrb	r7, [r0, #28]
	if (adv->tx_addr) {
   1d42a:	f890 3020 	ldrb.w	r3, [r0, #32]
	rl_idx = node_rx->hdr.rx_ftr.rl_idx;
   1d42e:	f890 801d 	ldrb.w	r8, [r0, #29]
	direct = node_rx->hdr.rx_ftr.direct;
   1d432:	7f86      	ldrb	r6, [r0, #30]
	rssi = -(node_rx->hdr.rx_ftr.rssi);
   1d434:	427f      	negs	r7, r7
	if (adv->tx_addr) {
   1d436:	065b      	lsls	r3, r3, #25
	rssi = -(node_rx->hdr.rx_ftr.rssi);
   1d438:	b27f      	sxtb	r7, r7
	if (adv->tx_addr) {
   1d43a:	d506      	bpl.n	1d44a <hci_evt_encode+0x6e>
		ll_rl_crpa_set(0x00, NULL, rl_idx, &adv->adv_ind.addr[0]);
   1d43c:	2100      	movs	r1, #0
   1d43e:	f100 0322 	add.w	r3, r0, #34	; 0x22
   1d442:	4642      	mov	r2, r8
   1d444:	4608      	mov	r0, r1
   1d446:	f006 fd1b 	bl	23e80 <ll_rl_crpa_set>
	if (direct) {
   1d44a:	4bbc      	ldr	r3, [pc, #752]	; (1d73c <hci_evt_encode+0x360>)
   1d44c:	6858      	ldr	r0, [r3, #4]
   1d44e:	2100      	movs	r1, #0
   1d450:	460a      	mov	r2, r1
   1d452:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
   1d456:	2e00      	cmp	r6, #0
   1d458:	d04a      	beq.n	1d4f0 <hci_evt_encode+0x114>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1d45a:	4313      	orrs	r3, r2
   1d45c:	d03a      	beq.n	1d4d4 <hci_evt_encode+0xf8>
	    !(le_event_mask & BT_EVT_MASK_LE_DIRECT_ADV_REPORT)) {
   1d45e:	4bb8      	ldr	r3, [pc, #736]	; (1d740 <hci_evt_encode+0x364>)
   1d460:	6818      	ldr	r0, [r3, #0]
   1d462:	460b      	mov	r3, r1
   1d464:	f400 6280 	and.w	r2, r0, #1024	; 0x400
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1d468:	4313      	orrs	r3, r2
   1d46a:	d033      	beq.n	1d4d4 <hci_evt_encode+0xf8>
	LL_ASSERT(adv->type == PDU_ADV_TYPE_DIRECT_IND);
   1d46c:	f894 3020 	ldrb.w	r3, [r4, #32]
   1d470:	f003 030f 	and.w	r3, r3, #15
   1d474:	2b01      	cmp	r3, #1
   1d476:	d008      	beq.n	1d48a <hci_evt_encode+0xae>
   1d478:	48b2      	ldr	r0, [pc, #712]	; (1d744 <hci_evt_encode+0x368>)
   1d47a:	f00a fe63 	bl	28144 <printk>
   1d47e:	4040      	eors	r0, r0
   1d480:	f380 8811 	msr	BASEPRI, r0
   1d484:	f04f 0003 	mov.w	r0, #3
   1d488:	df02      	svc	2
	if (dup_found(adv)) {
   1d48a:	4648      	mov	r0, r9
   1d48c:	f7ff f862 	bl	1c554 <dup_found>
   1d490:	bb00      	cbnz	r0, 1d4d4 <hci_evt_encode+0xf8>
	drp = meta_evt(buf, BT_HCI_EVT_LE_DIRECT_ADV_REPORT,
   1d492:	2211      	movs	r2, #17
   1d494:	210b      	movs	r1, #11
   1d496:	4628      	mov	r0, r5
   1d498:	f00e fc1f 	bl	2bcda <meta_evt>
	drp->num_reports = 1U;
   1d49c:	2301      	movs	r3, #1
   1d49e:	7003      	strb	r3, [r0, #0]
	dir_info->evt_type = BT_LE_ADV_DIRECT_IND;
   1d4a0:	7043      	strb	r3, [r0, #1]
	drp = meta_evt(buf, BT_HCI_EVT_LE_DIRECT_ADV_REPORT,
   1d4a2:	4605      	mov	r5, r0
	if (rl_idx < ll_rl_size_get()) {
   1d4a4:	f00f fad8 	bl	2ca58 <ll_rl_size_get>
   1d4a8:	4580      	cmp	r8, r0
   1d4aa:	f105 0003 	add.w	r0, r5, #3
   1d4ae:	d214      	bcs.n	1d4da <hci_evt_encode+0xfe>
		ll_rl_id_addr_get(rl_idx, &dir_info->addr.type,
   1d4b0:	4602      	mov	r2, r0
   1d4b2:	1ca9      	adds	r1, r5, #2
   1d4b4:	4640      	mov	r0, r8
   1d4b6:	f006 f9fd 	bl	238b4 <ll_rl_id_addr_get>
		dir_info->addr.type += 2U;
   1d4ba:	78ab      	ldrb	r3, [r5, #2]
   1d4bc:	3302      	adds	r3, #2
   1d4be:	70ab      	strb	r3, [r5, #2]
	dir_info->dir_addr.type = 0x1;
   1d4c0:	2301      	movs	r3, #1
   1d4c2:	726b      	strb	r3, [r5, #9]
	memcpy(&dir_info->dir_addr.a.val[0],
   1d4c4:	2206      	movs	r2, #6
   1d4c6:	f104 0128 	add.w	r1, r4, #40	; 0x28
   1d4ca:	f105 000a 	add.w	r0, r5, #10
   1d4ce:	f00c ffbe 	bl	2a44e <memcpy>
	dir_info->rssi = rssi;
   1d4d2:	742f      	strb	r7, [r5, #16]
		encode_control(node_rx, pdu_data, buf);
	} else if (IS_ENABLED(CONFIG_BT_CONN)) {
		encode_data_ctrl(node_rx, pdu_data, buf);
	}
}
   1d4d4:	b009      	add	sp, #36	; 0x24
   1d4d6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		dir_info->addr.type = adv->tx_addr;
   1d4da:	f894 3020 	ldrb.w	r3, [r4, #32]
   1d4de:	f3c3 1380 	ubfx	r3, r3, #6, #1
   1d4e2:	70ab      	strb	r3, [r5, #2]
		memcpy(&dir_info->addr.a.val[0], &adv->direct_ind.adv_addr[0],
   1d4e4:	2206      	movs	r2, #6
   1d4e6:	f104 0122 	add.w	r1, r4, #34	; 0x22
   1d4ea:	f00c ffb0 	bl	2a44e <memcpy>
   1d4ee:	e7e7      	b.n	1d4c0 <hci_evt_encode+0xe4>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1d4f0:	4313      	orrs	r3, r2
   1d4f2:	d0ef      	beq.n	1d4d4 <hci_evt_encode+0xf8>
	    !(le_event_mask & BT_EVT_MASK_LE_ADVERTISING_REPORT)) {
   1d4f4:	4b92      	ldr	r3, [pc, #584]	; (1d740 <hci_evt_encode+0x364>)
   1d4f6:	6819      	ldr	r1, [r3, #0]
   1d4f8:	4633      	mov	r3, r6
   1d4fa:	f001 0202 	and.w	r2, r1, #2
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1d4fe:	4313      	orrs	r3, r2
   1d500:	d0e8      	beq.n	1d4d4 <hci_evt_encode+0xf8>
	if (dup_found(adv)) {
   1d502:	4648      	mov	r0, r9
   1d504:	f7ff f826 	bl	1c554 <dup_found>
   1d508:	2800      	cmp	r0, #0
   1d50a:	d1e3      	bne.n	1d4d4 <hci_evt_encode+0xf8>
	if (adv->type != PDU_ADV_TYPE_DIRECT_IND) {
   1d50c:	f894 3020 	ldrb.w	r3, [r4, #32]
   1d510:	f003 030f 	and.w	r3, r3, #15
   1d514:	2b01      	cmp	r3, #1
		data_len = (adv->len - BDADDR_SIZE);
   1d516:	bf1e      	ittt	ne
   1d518:	f894 6021 	ldrbne.w	r6, [r4, #33]	; 0x21
   1d51c:	3e06      	subne	r6, #6
   1d51e:	b2f6      	uxtbne	r6, r6
	sep = meta_evt(buf, BT_HCI_EVT_LE_ADVERTISING_REPORT,
   1d520:	f106 020b 	add.w	r2, r6, #11
   1d524:	b2d2      	uxtb	r2, r2
   1d526:	2102      	movs	r1, #2
   1d528:	4628      	mov	r0, r5
   1d52a:	f00e fbd6 	bl	2bcda <meta_evt>
	sep->num_reports = 1U;
   1d52e:	2301      	movs	r3, #1
   1d530:	7003      	strb	r3, [r0, #0]
	adv_info->evt_type = c_adv_type[adv->type];
   1d532:	f894 3020 	ldrb.w	r3, [r4, #32]
   1d536:	aa08      	add	r2, sp, #32
   1d538:	f003 030f 	and.w	r3, r3, #15
   1d53c:	4413      	add	r3, r2
	sep = meta_evt(buf, BT_HCI_EVT_LE_ADVERTISING_REPORT,
   1d53e:	4605      	mov	r5, r0
	adv_info->evt_type = c_adv_type[adv->type];
   1d540:	f813 3c10 	ldrb.w	r3, [r3, #-16]
   1d544:	7043      	strb	r3, [r0, #1]
	if (rl_idx < ll_rl_size_get()) {
   1d546:	f00f fa87 	bl	2ca58 <ll_rl_size_get>
   1d54a:	4580      	cmp	r8, r0
   1d54c:	f105 0003 	add.w	r0, r5, #3
   1d550:	d211      	bcs.n	1d576 <hci_evt_encode+0x19a>
		ll_rl_id_addr_get(rl_idx, &adv_info->addr.type,
   1d552:	4602      	mov	r2, r0
   1d554:	1ca9      	adds	r1, r5, #2
   1d556:	4640      	mov	r0, r8
   1d558:	f006 f9ac 	bl	238b4 <ll_rl_id_addr_get>
		adv_info->addr.type += 2U;
   1d55c:	78ab      	ldrb	r3, [r5, #2]
   1d55e:	3302      	adds	r3, #2
   1d560:	70ab      	strb	r3, [r5, #2]
	adv_info->length = data_len;
   1d562:	726e      	strb	r6, [r5, #9]
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
   1d564:	350a      	adds	r5, #10
   1d566:	4632      	mov	r2, r6
   1d568:	f104 0128 	add.w	r1, r4, #40	; 0x28
   1d56c:	4628      	mov	r0, r5
   1d56e:	f00c ff6e 	bl	2a44e <memcpy>
	*prssi = rssi;
   1d572:	55af      	strb	r7, [r5, r6]
   1d574:	e7ae      	b.n	1d4d4 <hci_evt_encode+0xf8>
		adv_info->addr.type = adv->tx_addr;
   1d576:	f894 3020 	ldrb.w	r3, [r4, #32]
   1d57a:	f3c3 1380 	ubfx	r3, r3, #6, #1
   1d57e:	70ab      	strb	r3, [r5, #2]
		memcpy(&adv_info->addr.a.val[0], &adv->adv_ind.addr[0],
   1d580:	2206      	movs	r2, #6
   1d582:	f104 0122 	add.w	r1, r4, #34	; 0x22
   1d586:	f00c ff62 	bl	2a44e <memcpy>
   1d58a:	e7ea      	b.n	1d562 <hci_evt_encode+0x186>
	u8_t status = node_rx->status;
   1d58c:	f890 7020 	ldrb.w	r7, [r0, #32]
	if (!status) {
   1d590:	b947      	cbnz	r7, 1d5a4 <hci_evt_encode+0x1c8>
		ll_rl_crpa_set(node_rx->peer_addr_type,
   1d592:	f100 0329 	add.w	r3, r0, #41	; 0x29
   1d596:	f100 0123 	add.w	r1, r0, #35	; 0x23
   1d59a:	22ff      	movs	r2, #255	; 0xff
   1d59c:	f890 0022 	ldrb.w	r0, [r0, #34]	; 0x22
   1d5a0:	f006 fc6e 	bl	23e80 <ll_rl_crpa_set>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1d5a4:	4b65      	ldr	r3, [pc, #404]	; (1d73c <hci_evt_encode+0x360>)
   1d5a6:	6859      	ldr	r1, [r3, #4]
   1d5a8:	f04f 0c00 	mov.w	ip, #0
   1d5ac:	4662      	mov	r2, ip
   1d5ae:	f001 5300 	and.w	r3, r1, #536870912	; 0x20000000
   1d5b2:	4313      	orrs	r3, r2
   1d5b4:	d08e      	beq.n	1d4d4 <hci_evt_encode+0xf8>
	    (!(le_event_mask & BT_EVT_MASK_LE_CONN_COMPLETE) &&
   1d5b6:	4b62      	ldr	r3, [pc, #392]	; (1d740 <hci_evt_encode+0x364>)
   1d5b8:	f8d3 e000 	ldr.w	lr, [r3]
   1d5bc:	f240 2001 	movw	r0, #513	; 0x201
   1d5c0:	ea0e 0000 	and.w	r0, lr, r0
   1d5c4:	4661      	mov	r1, ip
   1d5c6:	4301      	orrs	r1, r0
	     !(le_event_mask & BT_EVT_MASK_LE_ENH_CONN_COMPLETE))) {
   1d5c8:	f40e 7200 	and.w	r2, lr, #512	; 0x200
   1d5cc:	4663      	mov	r3, ip
	    (!(le_event_mask & BT_EVT_MASK_LE_CONN_COMPLETE) &&
   1d5ce:	d081      	beq.n	1d4d4 <hci_evt_encode+0xf8>
	if (!status) {
   1d5d0:	b91f      	cbnz	r7, 1d5da <hci_evt_encode+0x1fe>
		conn_count++;
   1d5d2:	485d      	ldr	r0, [pc, #372]	; (1d748 <hci_evt_encode+0x36c>)
   1d5d4:	6801      	ldr	r1, [r0, #0]
   1d5d6:	3101      	adds	r1, #1
   1d5d8:	6001      	str	r1, [r0, #0]
	if (le_event_mask & BT_EVT_MASK_LE_ENH_CONN_COMPLETE) {
   1d5da:	4313      	orrs	r3, r2
   1d5dc:	d043      	beq.n	1d666 <hci_evt_encode+0x28a>
		leecc = meta_evt(buf, BT_HCI_EVT_LE_ENH_CONN_COMPLETE,
   1d5de:	4628      	mov	r0, r5
   1d5e0:	221e      	movs	r2, #30
   1d5e2:	210a      	movs	r1, #10
   1d5e4:	f00e fb79 	bl	2bcda <meta_evt>
   1d5e8:	4605      	mov	r5, r0
		if (status) {
   1d5ea:	b12f      	cbz	r7, 1d5f8 <hci_evt_encode+0x21c>
			(void)memset(leecc, 0x00, sizeof(*leecc));
   1d5ec:	221e      	movs	r2, #30
		(void)memset(lecc, 0x00, sizeof(*lecc));
   1d5ee:	2100      	movs	r1, #0
   1d5f0:	f00c ff57 	bl	2a4a2 <memset>
		lecc->status = status;
   1d5f4:	702f      	strb	r7, [r5, #0]
		return;
   1d5f6:	e76d      	b.n	1d4d4 <hci_evt_encode+0xf8>
		leecc->status = 0x00;
   1d5f8:	7007      	strb	r7, [r0, #0]
		leecc->handle = sys_cpu_to_le16(handle);
   1d5fa:	f8a0 6001 	strh.w	r6, [r0, #1]
		leecc->role = node_rx->role;
   1d5fe:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
   1d602:	70c3      	strb	r3, [r0, #3]
		leecc->peer_addr.type = node_rx->peer_addr_type;
   1d604:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
   1d608:	7103      	strb	r3, [r0, #4]
		memcpy(&leecc->peer_addr.a.val[0], &node_rx->peer_addr[0],
   1d60a:	2206      	movs	r2, #6
   1d60c:	f104 0123 	add.w	r1, r4, #35	; 0x23
   1d610:	3005      	adds	r0, #5
   1d612:	f00c ff1c 	bl	2a44e <memcpy>
		if ((node_rx->own_addr_type) &&
   1d616:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
   1d61a:	f105 000b 	add.w	r0, r5, #11
			memcpy(&leecc->local_rpa.val[0], &node_rx->own_addr[0],
   1d61e:	2206      	movs	r2, #6
		if ((node_rx->own_addr_type) &&
   1d620:	b1eb      	cbz	r3, 1d65e <hci_evt_encode+0x282>
   1d622:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
   1d626:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   1d62a:	2b40      	cmp	r3, #64	; 0x40
   1d62c:	d117      	bne.n	1d65e <hci_evt_encode+0x282>
			memcpy(&leecc->local_rpa.val[0], &node_rx->own_addr[0],
   1d62e:	f104 0130 	add.w	r1, r4, #48	; 0x30
   1d632:	f00c ff0c 	bl	2a44e <memcpy>
		memcpy(&leecc->peer_rpa.val[0], &node_rx->peer_rpa[0],
   1d636:	2206      	movs	r2, #6
   1d638:	f104 0129 	add.w	r1, r4, #41	; 0x29
   1d63c:	f105 0011 	add.w	r0, r5, #17
   1d640:	f00c ff05 	bl	2a44e <memcpy>
		leecc->interval = sys_cpu_to_le16(node_rx->interval);
   1d644:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   1d646:	f8a5 3017 	strh.w	r3, [r5, #23]
		leecc->latency = sys_cpu_to_le16(node_rx->latency);
   1d64a:	8f23      	ldrh	r3, [r4, #56]	; 0x38
   1d64c:	f8a5 3019 	strh.w	r3, [r5, #25]
		leecc->supv_timeout = sys_cpu_to_le16(node_rx->timeout);
   1d650:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   1d652:	f8a5 301b 	strh.w	r3, [r5, #27]
		leecc->clock_accuracy = node_rx->sca;
   1d656:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   1d65a:	776b      	strb	r3, [r5, #29]
		return;
   1d65c:	e73a      	b.n	1d4d4 <hci_evt_encode+0xf8>
			(void)memset(&leecc->local_rpa.val[0], 0x0,
   1d65e:	2100      	movs	r1, #0
   1d660:	f00c ff1f 	bl	2a4a2 <memset>
   1d664:	e7e7      	b.n	1d636 <hci_evt_encode+0x25a>
	lecc = meta_evt(buf, BT_HCI_EVT_LE_CONN_COMPLETE, sizeof(*lecc));
   1d666:	4628      	mov	r0, r5
   1d668:	2212      	movs	r2, #18
   1d66a:	2101      	movs	r1, #1
   1d66c:	f00e fb35 	bl	2bcda <meta_evt>
   1d670:	4605      	mov	r5, r0
	if (status) {
   1d672:	b10f      	cbz	r7, 1d678 <hci_evt_encode+0x29c>
		(void)memset(lecc, 0x00, sizeof(*lecc));
   1d674:	2212      	movs	r2, #18
   1d676:	e7ba      	b.n	1d5ee <hci_evt_encode+0x212>
	lecc->status = 0x00;
   1d678:	7007      	strb	r7, [r0, #0]
	lecc->handle = sys_cpu_to_le16(handle);
   1d67a:	f8a0 6001 	strh.w	r6, [r0, #1]
	lecc->role = node_rx->role;
   1d67e:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
   1d682:	70c3      	strb	r3, [r0, #3]
	lecc->peer_addr.type = node_rx->peer_addr_type;
   1d684:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
   1d688:	7103      	strb	r3, [r0, #4]
	memcpy(&lecc->peer_addr.a.val[0], &node_rx->peer_addr[0], BDADDR_SIZE);
   1d68a:	2206      	movs	r2, #6
   1d68c:	f104 0123 	add.w	r1, r4, #35	; 0x23
   1d690:	3005      	adds	r0, #5
   1d692:	f00c fedc 	bl	2a44e <memcpy>
	lecc->interval = sys_cpu_to_le16(node_rx->interval);
   1d696:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   1d698:	f8a5 300b 	strh.w	r3, [r5, #11]
	lecc->latency = sys_cpu_to_le16(node_rx->latency);
   1d69c:	8f23      	ldrh	r3, [r4, #56]	; 0x38
   1d69e:	f8a5 300d 	strh.w	r3, [r5, #13]
	lecc->supv_timeout = sys_cpu_to_le16(node_rx->timeout);
   1d6a2:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
   1d6a4:	f8a5 300f 	strh.w	r3, [r5, #15]
	lecc->clock_accuracy = node_rx->sca;
   1d6a8:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
   1d6ac:	746b      	strb	r3, [r5, #17]
   1d6ae:	e711      	b.n	1d4d4 <hci_evt_encode+0xf8>
	if (!(event_mask & BT_EVT_MASK_DISCONN_COMPLETE)) {
   1d6b0:	4b22      	ldr	r3, [pc, #136]	; (1d73c <hci_evt_encode+0x360>)
   1d6b2:	6819      	ldr	r1, [r3, #0]
   1d6b4:	2700      	movs	r7, #0
   1d6b6:	f001 0210 	and.w	r2, r1, #16
   1d6ba:	463b      	mov	r3, r7
   1d6bc:	4313      	orrs	r3, r2
   1d6be:	f43f af09 	beq.w	1d4d4 <hci_evt_encode+0xf8>
	hci_evt_create(buf, BT_HCI_EVT_DISCONN_COMPLETE, sizeof(*ep));
   1d6c2:	2204      	movs	r2, #4
   1d6c4:	2105      	movs	r1, #5
   1d6c6:	4628      	mov	r0, r5
   1d6c8:	f00e fafd 	bl	2bcc6 <hci_evt_create>
	ep = net_buf_add(buf, sizeof(*ep));
   1d6cc:	2104      	movs	r1, #4
   1d6ce:	f105 0008 	add.w	r0, r5, #8
   1d6d2:	f00f fa55 	bl	2cb80 <net_buf_simple_add>
	conn_count--;
   1d6d6:	4a1c      	ldr	r2, [pc, #112]	; (1d748 <hci_evt_encode+0x36c>)
	ep->status = 0x00;
   1d6d8:	7007      	strb	r7, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
   1d6da:	f8a0 6001 	strh.w	r6, [r0, #1]
	ep->reason = *((u8_t *)pdu_data);
   1d6de:	f894 3020 	ldrb.w	r3, [r4, #32]
   1d6e2:	70c3      	strb	r3, [r0, #3]
	conn_count--;
   1d6e4:	6813      	ldr	r3, [r2, #0]
   1d6e6:	3b01      	subs	r3, #1
   1d6e8:	6013      	str	r3, [r2, #0]
   1d6ea:	e6f3      	b.n	1d4d4 <hci_evt_encode+0xf8>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1d6ec:	4b13      	ldr	r3, [pc, #76]	; (1d73c <hci_evt_encode+0x360>)
   1d6ee:	6858      	ldr	r0, [r3, #4]
   1d6f0:	2100      	movs	r1, #0
   1d6f2:	460a      	mov	r2, r1
   1d6f4:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
   1d6f8:	4313      	orrs	r3, r2
   1d6fa:	f43f aeeb 	beq.w	1d4d4 <hci_evt_encode+0xf8>
	    !(le_event_mask & BT_EVT_MASK_LE_CONN_UPDATE_COMPLETE)) {
   1d6fe:	4b10      	ldr	r3, [pc, #64]	; (1d740 <hci_evt_encode+0x364>)
   1d700:	6818      	ldr	r0, [r3, #0]
   1d702:	460b      	mov	r3, r1
   1d704:	f000 0204 	and.w	r2, r0, #4
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1d708:	4313      	orrs	r3, r2
   1d70a:	f43f aee3 	beq.w	1d4d4 <hci_evt_encode+0xf8>
	sep = meta_evt(buf, BT_HCI_EVT_LE_CONN_UPDATE_COMPLETE, sizeof(*sep));
   1d70e:	2209      	movs	r2, #9
   1d710:	2103      	movs	r1, #3
   1d712:	4628      	mov	r0, r5
   1d714:	f00e fae1 	bl	2bcda <meta_evt>
	sep->status = cu->status;
   1d718:	f894 3020 	ldrb.w	r3, [r4, #32]
   1d71c:	7003      	strb	r3, [r0, #0]
	sep->interval = sys_cpu_to_le16(cu->interval);
   1d71e:	8c63      	ldrh	r3, [r4, #34]	; 0x22
   1d720:	f8a0 3003 	strh.w	r3, [r0, #3]
	sep->latency = sys_cpu_to_le16(cu->latency);
   1d724:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
   1d726:	f8a0 3005 	strh.w	r3, [r0, #5]
	sep->supv_timeout = sys_cpu_to_le16(cu->timeout);
   1d72a:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
	sep->handle = sys_cpu_to_le16(handle);
   1d72c:	f8a0 6001 	strh.w	r6, [r0, #1]
	sep->supv_timeout = sys_cpu_to_le16(cu->timeout);
   1d730:	f8a0 3007 	strh.w	r3, [r0, #7]
   1d734:	e6ce      	b.n	1d4d4 <hci_evt_encode+0xf8>
   1d736:	bf00      	nop
   1d738:	ff030100 	.word	0xff030100
   1d73c:	2000f7f8 	.word	0x2000f7f8
   1d740:	2000f800 	.word	0x2000f800
   1d744:	000315b1 	.word	0x000315b1
   1d748:	20001e6c 	.word	0x20001e6c
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_KEY_REFRESH_COMPLETE)) {
   1d74c:	4bb1      	ldr	r3, [pc, #708]	; (1da14 <hci_evt_encode+0x638>)
   1d74e:	6859      	ldr	r1, [r3, #4]
   1d750:	2400      	movs	r4, #0
   1d752:	4622      	mov	r2, r4
   1d754:	f401 4300 	and.w	r3, r1, #32768	; 0x8000
   1d758:	4313      	orrs	r3, r2
   1d75a:	f43f aebb 	beq.w	1d4d4 <hci_evt_encode+0xf8>
	hci_evt_create(buf, BT_HCI_EVT_ENCRYPT_KEY_REFRESH_COMPLETE,
   1d75e:	2203      	movs	r2, #3
   1d760:	2130      	movs	r1, #48	; 0x30
   1d762:	4628      	mov	r0, r5
   1d764:	f00e faaf 	bl	2bcc6 <hci_evt_create>
	ep = net_buf_add(buf, sizeof(*ep));
   1d768:	2103      	movs	r1, #3
   1d76a:	f105 0008 	add.w	r0, r5, #8
   1d76e:	f00f fa07 	bl	2cb80 <net_buf_simple_add>
	ep->status = 0x00;
   1d772:	7004      	strb	r4, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
   1d774:	f8a0 6001 	strh.w	r6, [r0, #1]
   1d778:	e6ac      	b.n	1d4d4 <hci_evt_encode+0xf8>
	if (!(event_mask_page_2 & BT_EVT_MASK_AUTH_PAYLOAD_TIMEOUT_EXP)) {
   1d77a:	4ba7      	ldr	r3, [pc, #668]	; (1da18 <hci_evt_encode+0x63c>)
   1d77c:	6819      	ldr	r1, [r3, #0]
   1d77e:	2300      	movs	r3, #0
   1d780:	f401 0200 	and.w	r2, r1, #8388608	; 0x800000
   1d784:	4313      	orrs	r3, r2
   1d786:	f43f aea5 	beq.w	1d4d4 <hci_evt_encode+0xf8>
	hci_evt_create(buf, BT_HCI_EVT_AUTH_PAYLOAD_TIMEOUT_EXP, sizeof(*ep));
   1d78a:	2202      	movs	r2, #2
   1d78c:	2157      	movs	r1, #87	; 0x57
   1d78e:	4628      	mov	r0, r5
   1d790:	f00e fa99 	bl	2bcc6 <hci_evt_create>
	ep = net_buf_add(buf, sizeof(*ep));
   1d794:	2102      	movs	r1, #2
   1d796:	f105 0008 	add.w	r0, r5, #8
   1d79a:	f00f f9f1 	bl	2cb80 <net_buf_simple_add>
	ep->handle = sys_cpu_to_le16(handle);
   1d79e:	8006      	strh	r6, [r0, #0]
   1d7a0:	e698      	b.n	1d4d4 <hci_evt_encode+0xf8>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1d7a2:	4b9c      	ldr	r3, [pc, #624]	; (1da14 <hci_evt_encode+0x638>)
   1d7a4:	6858      	ldr	r0, [r3, #4]
   1d7a6:	2100      	movs	r1, #0
   1d7a8:	460a      	mov	r2, r1
   1d7aa:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
   1d7ae:	4313      	orrs	r3, r2
   1d7b0:	f43f ae90 	beq.w	1d4d4 <hci_evt_encode+0xf8>
	    !(le_event_mask & BT_EVT_MASK_LE_CHAN_SEL_ALGO)) {
   1d7b4:	4b99      	ldr	r3, [pc, #612]	; (1da1c <hci_evt_encode+0x640>)
   1d7b6:	6818      	ldr	r0, [r3, #0]
   1d7b8:	460b      	mov	r3, r1
   1d7ba:	f400 2200 	and.w	r2, r0, #524288	; 0x80000
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1d7be:	4313      	orrs	r3, r2
   1d7c0:	f43f ae88 	beq.w	1d4d4 <hci_evt_encode+0xf8>
	sep = meta_evt(buf, BT_HCI_EVT_LE_CHAN_SEL_ALGO, sizeof(*sep));
   1d7c4:	2203      	movs	r2, #3
   1d7c6:	2114      	movs	r1, #20
   1d7c8:	4628      	mov	r0, r5
   1d7ca:	f00e fa86 	bl	2bcda <meta_evt>
	sep->handle = sys_cpu_to_le16(handle);
   1d7ce:	8006      	strh	r6, [r0, #0]
	sep->chan_sel_algo = cs->csa;
   1d7d0:	f894 3020 	ldrb.w	r3, [r4, #32]
   1d7d4:	7083      	strb	r3, [r0, #2]
   1d7d6:	e67d      	b.n	1d4d4 <hci_evt_encode+0xf8>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1d7d8:	4b8e      	ldr	r3, [pc, #568]	; (1da14 <hci_evt_encode+0x638>)
   1d7da:	6858      	ldr	r0, [r3, #4]
   1d7dc:	2100      	movs	r1, #0
   1d7de:	460a      	mov	r2, r1
   1d7e0:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
   1d7e4:	4313      	orrs	r3, r2
   1d7e6:	d006      	beq.n	1d7f6 <hci_evt_encode+0x41a>
	    !(le_event_mask & BT_EVT_MASK_LE_PHY_UPDATE_COMPLETE)) {
   1d7e8:	4b8c      	ldr	r3, [pc, #560]	; (1da1c <hci_evt_encode+0x640>)
   1d7ea:	6818      	ldr	r0, [r3, #0]
   1d7ec:	460b      	mov	r3, r1
   1d7ee:	f400 6200 	and.w	r2, r0, #2048	; 0x800
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1d7f2:	4313      	orrs	r3, r2
   1d7f4:	d132      	bne.n	1d85c <hci_evt_encode+0x480>
		BT_WARN("handle: 0x%04x, status: %x, tx: %x, rx: %x.", handle,
   1d7f6:	4b8a      	ldr	r3, [pc, #552]	; (1da20 <hci_evt_encode+0x644>)
   1d7f8:	681b      	ldr	r3, [r3, #0]
   1d7fa:	f013 0f06 	tst.w	r3, #6
   1d7fe:	f43f ae69 	beq.w	1d4d4 <hci_evt_encode+0xf8>
   1d802:	2202      	movs	r2, #2
   1d804:	f04f 0300 	mov.w	r3, #0
   1d808:	f362 0307 	bfi	r3, r2, #0, #8
   1d80c:	4985      	ldr	r1, [pc, #532]	; (1da24 <hci_evt_encode+0x648>)
   1d80e:	4a86      	ldr	r2, [pc, #536]	; (1da28 <hci_evt_encode+0x64c>)
   1d810:	4886      	ldr	r0, [pc, #536]	; (1da2c <hci_evt_encode+0x650>)
   1d812:	9604      	str	r6, [sp, #16]
   1d814:	1a52      	subs	r2, r2, r1
   1d816:	08d2      	lsrs	r2, r2, #3
   1d818:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
   1d81c:	f362 138f 	bfi	r3, r2, #6, #10
   1d820:	f894 2020 	ldrb.w	r2, [r4, #32]
   1d824:	9205      	str	r2, [sp, #20]
   1d826:	2900      	cmp	r1, #0
   1d828:	fa91 f2a1 	rbit	r2, r1
   1d82c:	fab2 f282 	clz	r2, r2
   1d830:	f894 1022 	ldrb.w	r1, [r4, #34]	; 0x22
   1d834:	bf08      	it	eq
   1d836:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
   1d83a:	3201      	adds	r2, #1
   1d83c:	2900      	cmp	r1, #0
   1d83e:	9206      	str	r2, [sp, #24]
   1d840:	fa91 f2a1 	rbit	r2, r1
   1d844:	fab2 f282 	clz	r2, r2
   1d848:	bf08      	it	eq
   1d84a:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
   1d84e:	3201      	adds	r2, #1
   1d850:	9207      	str	r2, [sp, #28]
   1d852:	a904      	add	r1, sp, #16
   1d854:	2204      	movs	r2, #4
   1d856:	f00b f8c4 	bl	289e2 <log_n>
   1d85a:	e63b      	b.n	1d4d4 <hci_evt_encode+0xf8>
	sep = meta_evt(buf, BT_HCI_EVT_LE_PHY_UPDATE_COMPLETE, sizeof(*sep));
   1d85c:	2205      	movs	r2, #5
   1d85e:	210c      	movs	r1, #12
   1d860:	4628      	mov	r0, r5
   1d862:	f00e fa3a 	bl	2bcda <meta_evt>
	sep->status = pu->status;
   1d866:	f894 3020 	ldrb.w	r3, [r4, #32]
   1d86a:	7003      	strb	r3, [r0, #0]
	sep->handle = sys_cpu_to_le16(handle);
   1d86c:	f8a0 6001 	strh.w	r6, [r0, #1]
   1d870:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
   1d874:	2a00      	cmp	r2, #0
   1d876:	fa92 f3a2 	rbit	r3, r2
   1d87a:	fab3 f383 	clz	r3, r3
   1d87e:	bf08      	it	eq
   1d880:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   1d884:	3301      	adds	r3, #1
	sep->tx_phy = find_lsb_set(pu->tx);
   1d886:	70c3      	strb	r3, [r0, #3]
   1d888:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22
   1d88c:	fa92 f3a2 	rbit	r3, r2
   1d890:	2a00      	cmp	r2, #0
   1d892:	fab3 f383 	clz	r3, r3
   1d896:	bf08      	it	eq
   1d898:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   1d89c:	3301      	adds	r3, #1
	sep->rx_phy = find_lsb_set(pu->rx);
   1d89e:	7103      	strb	r3, [r0, #4]
   1d8a0:	e618      	b.n	1d4d4 <hci_evt_encode+0xf8>
	switch (pdu_data->llctrl.opcode) {
   1d8a2:	f890 3023 	ldrb.w	r3, [r0, #35]	; 0x23
   1d8a6:	3b03      	subs	r3, #3
   1d8a8:	2b12      	cmp	r3, #18
   1d8aa:	f200 80a9 	bhi.w	1da00 <hci_evt_encode+0x624>
   1d8ae:	e8df f003 	tbb	[pc, r3]
   1d8b2:	a70a      	.short	0xa70a
   1d8b4:	a78930a7 	.word	0xa78930a7
   1d8b8:	a7a7a736 	.word	0xa7a7a736
   1d8bc:	a742a73d 	.word	0xa742a73d
   1d8c0:	6aa7a7a7 	.word	0x6aa7a7a7
   1d8c4:	6a          	.byte	0x6a
   1d8c5:	00          	.byte	0x00
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1d8c6:	4b53      	ldr	r3, [pc, #332]	; (1da14 <hci_evt_encode+0x638>)
   1d8c8:	6858      	ldr	r0, [r3, #4]
   1d8ca:	2100      	movs	r1, #0
   1d8cc:	460a      	mov	r2, r1
   1d8ce:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
   1d8d2:	4313      	orrs	r3, r2
   1d8d4:	f43f adfe 	beq.w	1d4d4 <hci_evt_encode+0xf8>
	    !(le_event_mask & BT_EVT_MASK_LE_LTK_REQUEST)) {
   1d8d8:	4b50      	ldr	r3, [pc, #320]	; (1da1c <hci_evt_encode+0x640>)
   1d8da:	6818      	ldr	r0, [r3, #0]
   1d8dc:	460b      	mov	r3, r1
   1d8de:	f000 0210 	and.w	r2, r0, #16
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1d8e2:	4313      	orrs	r3, r2
   1d8e4:	f43f adf6 	beq.w	1d4d4 <hci_evt_encode+0xf8>
	sep = meta_evt(buf, BT_HCI_EVT_LE_LTK_REQUEST, sizeof(*sep));
   1d8e8:	220c      	movs	r2, #12
   1d8ea:	2105      	movs	r1, #5
   1d8ec:	4628      	mov	r0, r5
   1d8ee:	f00e f9f4 	bl	2bcda <meta_evt>
	memcpy(&sep->rand, pdu_data->llctrl.enc_req.rand, sizeof(u64_t));
   1d8f2:	f104 0124 	add.w	r1, r4, #36	; 0x24
	sep = meta_evt(buf, BT_HCI_EVT_LE_LTK_REQUEST, sizeof(*sep));
   1d8f6:	4605      	mov	r5, r0
	memcpy(&sep->rand, pdu_data->llctrl.enc_req.rand, sizeof(u64_t));
   1d8f8:	2208      	movs	r2, #8
	sep->handle = sys_cpu_to_le16(handle);
   1d8fa:	f820 6b02 	strh.w	r6, [r0], #2
	memcpy(&sep->rand, pdu_data->llctrl.enc_req.rand, sizeof(u64_t));
   1d8fe:	f00c fda6 	bl	2a44e <memcpy>
	memcpy(&sep->ediv, pdu_data->llctrl.enc_req.ediv, sizeof(u16_t));
   1d902:	2202      	movs	r2, #2
   1d904:	f104 012c 	add.w	r1, r4, #44	; 0x2c
   1d908:	f105 000a 	add.w	r0, r5, #10
   1d90c:	f00c fd9f 	bl	2a44e <memcpy>
   1d910:	e5e0      	b.n	1d4d4 <hci_evt_encode+0xf8>
		encrypt_change(0x00, handle, buf);
   1d912:	460a      	mov	r2, r1
   1d914:	2000      	movs	r0, #0
   1d916:	4631      	mov	r1, r6
		encrypt_change(pdu_data->llctrl.reject_ind.error_code, handle,
   1d918:	f7fe fec8 	bl	1c6ac <encrypt_change>
		break;
   1d91c:	e5da      	b.n	1d4d4 <hci_evt_encode+0xf8>
		le_remote_feat_complete(0x00, pdu_data, handle, buf);
   1d91e:	460b      	mov	r3, r1
   1d920:	4632      	mov	r2, r6
   1d922:	4649      	mov	r1, r9
   1d924:	2000      	movs	r0, #0
		le_remote_feat_complete(BT_HCI_ERR_UNSUPP_REMOTE_FEATURE,
   1d926:	f7fe fe93 	bl	1c650 <le_remote_feat_complete>
		break;
   1d92a:	e5d3      	b.n	1d4d4 <hci_evt_encode+0xf8>
		encrypt_change(pdu_data->llctrl.reject_ind.error_code, handle,
   1d92c:	460a      	mov	r2, r1
   1d92e:	f890 0024 	ldrb.w	r0, [r0, #36]	; 0x24
   1d932:	4631      	mov	r1, r6
   1d934:	e7f0      	b.n	1d918 <hci_evt_encode+0x53c>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1d936:	4b37      	ldr	r3, [pc, #220]	; (1da14 <hci_evt_encode+0x638>)
   1d938:	6858      	ldr	r0, [r3, #4]
   1d93a:	2100      	movs	r1, #0
   1d93c:	460a      	mov	r2, r1
   1d93e:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
   1d942:	4313      	orrs	r3, r2
   1d944:	d006      	beq.n	1d954 <hci_evt_encode+0x578>
	    !(le_event_mask & BT_EVT_MASK_LE_CONN_PARAM_REQ)) {
   1d946:	4b35      	ldr	r3, [pc, #212]	; (1da1c <hci_evt_encode+0x640>)
   1d948:	6818      	ldr	r0, [r3, #0]
   1d94a:	460b      	mov	r3, r1
   1d94c:	f000 0220 	and.w	r2, r0, #32
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1d950:	4313      	orrs	r3, r2
   1d952:	d109      	bne.n	1d968 <hci_evt_encode+0x58c>
		ll_conn_update(handle, 2, BT_HCI_ERR_UNSUPP_REMOTE_FEATURE, 0,
   1d954:	2300      	movs	r3, #0
   1d956:	e9cd 3301 	strd	r3, r3, [sp, #4]
   1d95a:	9300      	str	r3, [sp, #0]
   1d95c:	221a      	movs	r2, #26
   1d95e:	2102      	movs	r1, #2
   1d960:	4630      	mov	r0, r6
   1d962:	f00e fd1d 	bl	2c3a0 <ll_conn_update>
		return;
   1d966:	e5b5      	b.n	1d4d4 <hci_evt_encode+0xf8>
	sep = meta_evt(buf, BT_HCI_EVT_LE_CONN_PARAM_REQ, sizeof(*sep));
   1d968:	220a      	movs	r2, #10
   1d96a:	2106      	movs	r1, #6
   1d96c:	4628      	mov	r0, r5
   1d96e:	f00e f9b4 	bl	2bcda <meta_evt>
	sep->handle = sys_cpu_to_le16(handle);
   1d972:	8006      	strh	r6, [r0, #0]
	sep->interval_min = pdu_data->llctrl.conn_param_req.interval_min;
   1d974:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
   1d976:	8043      	strh	r3, [r0, #2]
	sep->interval_max = pdu_data->llctrl.conn_param_req.interval_max;
   1d978:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
   1d97a:	8083      	strh	r3, [r0, #4]
	sep->latency = pdu_data->llctrl.conn_param_req.latency;
   1d97c:	8d23      	ldrh	r3, [r4, #40]	; 0x28
   1d97e:	80c3      	strh	r3, [r0, #6]
	sep->timeout = pdu_data->llctrl.conn_param_req.timeout;
   1d980:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
	sep->max_rx_time = pdu_data->llctrl.length_rsp.max_rx_time;
   1d982:	8103      	strh	r3, [r0, #8]
   1d984:	e5a6      	b.n	1d4d4 <hci_evt_encode+0xf8>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1d986:	4b23      	ldr	r3, [pc, #140]	; (1da14 <hci_evt_encode+0x638>)
   1d988:	6858      	ldr	r0, [r3, #4]
   1d98a:	2100      	movs	r1, #0
   1d98c:	460a      	mov	r2, r1
   1d98e:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
   1d992:	4313      	orrs	r3, r2
   1d994:	f43f ad9e 	beq.w	1d4d4 <hci_evt_encode+0xf8>
	    !(le_event_mask & BT_EVT_MASK_LE_DATA_LEN_CHANGE)) {
   1d998:	4b20      	ldr	r3, [pc, #128]	; (1da1c <hci_evt_encode+0x640>)
   1d99a:	6818      	ldr	r0, [r3, #0]
   1d99c:	460b      	mov	r3, r1
   1d99e:	f000 0240 	and.w	r2, r0, #64	; 0x40
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
   1d9a2:	4313      	orrs	r3, r2
   1d9a4:	f43f ad96 	beq.w	1d4d4 <hci_evt_encode+0xf8>
	sep = meta_evt(buf, BT_HCI_EVT_LE_DATA_LEN_CHANGE, sizeof(*sep));
   1d9a8:	220a      	movs	r2, #10
   1d9aa:	2107      	movs	r1, #7
   1d9ac:	4628      	mov	r0, r5
   1d9ae:	f00e f994 	bl	2bcda <meta_evt>
	sep->handle = sys_cpu_to_le16(handle);
   1d9b2:	8006      	strh	r6, [r0, #0]
	sep->max_tx_octets = pdu_data->llctrl.length_rsp.max_tx_octets;
   1d9b4:	8d23      	ldrh	r3, [r4, #40]	; 0x28
   1d9b6:	8043      	strh	r3, [r0, #2]
	sep->max_tx_time = pdu_data->llctrl.length_rsp.max_tx_time;
   1d9b8:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
   1d9ba:	8083      	strh	r3, [r0, #4]
	sep->max_rx_octets = pdu_data->llctrl.length_rsp.max_rx_octets;
   1d9bc:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
   1d9be:	80c3      	strh	r3, [r0, #6]
	sep->max_rx_time = pdu_data->llctrl.length_rsp.max_rx_time;
   1d9c0:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
   1d9c2:	e7de      	b.n	1d982 <hci_evt_encode+0x5a6>
		le_unknown_rsp(pdu_data, handle, buf);
   1d9c4:	f890 1024 	ldrb.w	r1, [r0, #36]	; 0x24
	switch (pdu_data->llctrl.unknown_rsp.type) {
   1d9c8:	290e      	cmp	r1, #14
   1d9ca:	d104      	bne.n	1d9d6 <hci_evt_encode+0x5fa>
		le_remote_feat_complete(BT_HCI_ERR_UNSUPP_REMOTE_FEATURE,
   1d9cc:	462b      	mov	r3, r5
   1d9ce:	4632      	mov	r2, r6
   1d9d0:	2100      	movs	r1, #0
   1d9d2:	201a      	movs	r0, #26
   1d9d4:	e7a7      	b.n	1d926 <hci_evt_encode+0x54a>
		BT_WARN("type: 0x%02x",	pdu_data->llctrl.unknown_rsp.type);
   1d9d6:	4b12      	ldr	r3, [pc, #72]	; (1da20 <hci_evt_encode+0x644>)
   1d9d8:	681b      	ldr	r3, [r3, #0]
   1d9da:	f013 0f06 	tst.w	r3, #6
   1d9de:	f43f ad79 	beq.w	1d4d4 <hci_evt_encode+0xf8>
   1d9e2:	2302      	movs	r3, #2
   1d9e4:	f04f 0200 	mov.w	r2, #0
   1d9e8:	f363 0207 	bfi	r2, r3, #0, #8
   1d9ec:	480d      	ldr	r0, [pc, #52]	; (1da24 <hci_evt_encode+0x648>)
   1d9ee:	4b0e      	ldr	r3, [pc, #56]	; (1da28 <hci_evt_encode+0x64c>)
   1d9f0:	1a1b      	subs	r3, r3, r0
   1d9f2:	08db      	lsrs	r3, r3, #3
   1d9f4:	f363 128f 	bfi	r2, r3, #6, #10
   1d9f8:	480d      	ldr	r0, [pc, #52]	; (1da30 <hci_evt_encode+0x654>)
   1d9fa:	f00a ffab 	bl	28954 <log_1>
   1d9fe:	e569      	b.n	1d4d4 <hci_evt_encode+0xf8>
		LL_ASSERT(0);
   1da00:	480c      	ldr	r0, [pc, #48]	; (1da34 <hci_evt_encode+0x658>)
   1da02:	f00a fb9f 	bl	28144 <printk>
   1da06:	4040      	eors	r0, r0
   1da08:	f380 8811 	msr	BASEPRI, r0
   1da0c:	f04f 0003 	mov.w	r0, #3
   1da10:	df02      	svc	2
}
   1da12:	e55f      	b.n	1d4d4 <hci_evt_encode+0xf8>
   1da14:	2000f7f8 	.word	0x2000f7f8
   1da18:	20000000 	.word	0x20000000
   1da1c:	2000f800 	.word	0x2000f800
   1da20:	2000ffb8 	.word	0x2000ffb8
   1da24:	0002db28 	.word	0x0002db28
   1da28:	0002db68 	.word	0x0002db68
   1da2c:	000315e8 	.word	0x000315e8
   1da30:	00031614 	.word	0x00031614
   1da34:	000314f5 	.word	0x000314f5

0001da38 <hci_init>:
	dup_count = -1;
   1da38:	4b0a      	ldr	r3, [pc, #40]	; (1da64 <hci_init+0x2c>)
   1da3a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1da3e:	601a      	str	r2, [r3, #0]
	event_mask = DEFAULT_EVENT_MASK;
   1da40:	4b09      	ldr	r3, [pc, #36]	; (1da68 <hci_init+0x30>)
   1da42:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1da46:	f641 71ff 	movw	r1, #8191	; 0x1fff
   1da4a:	e9c3 0100 	strd	r0, r1, [r3]
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
   1da4e:	4b07      	ldr	r3, [pc, #28]	; (1da6c <hci_init+0x34>)
   1da50:	2000      	movs	r0, #0
   1da52:	2100      	movs	r1, #0
   1da54:	e9c3 0100 	strd	r0, r1, [r3]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
   1da58:	4b05      	ldr	r3, [pc, #20]	; (1da70 <hci_init+0x38>)
   1da5a:	201f      	movs	r0, #31
   1da5c:	2100      	movs	r1, #0
   1da5e:	e9c3 0100 	strd	r0, r1, [r3]
{
#if defined(CONFIG_BT_HCI_ACL_FLOW_CONTROL)
	hbuf_signal = signal_host_buf;
#endif
	reset(NULL, NULL);
}
   1da62:	4770      	bx	lr
   1da64:	20001e70 	.word	0x20001e70
   1da68:	2000f7f8 	.word	0x2000f7f8
   1da6c:	20000000 	.word	0x20000000
   1da70:	2000f800 	.word	0x2000f800

0001da74 <bt_rand>:
#include "hal/ecb.h"

static struct device *entropy_driver;

int bt_rand(void *buf, size_t len)
{
   1da74:	b570      	push	{r4, r5, r6, lr}
	struct device *dev = entropy_driver;
   1da76:	4c08      	ldr	r4, [pc, #32]	; (1da98 <bt_rand+0x24>)
{
   1da78:	4605      	mov	r5, r0
	struct device *dev = entropy_driver;
   1da7a:	6820      	ldr	r0, [r4, #0]
{
   1da7c:	460e      	mov	r6, r1

	if (unlikely(!dev)) {
   1da7e:	b918      	cbnz	r0, 1da88 <bt_rand+0x14>
   1da80:	4806      	ldr	r0, [pc, #24]	; (1da9c <bt_rand+0x28>)
   1da82:	f008 fc3f 	bl	26304 <z_impl_device_get_binding>
		dev = device_get_binding(CONFIG_ENTROPY_NAME);
		__ASSERT((dev != NULL),
			"Device driver for %s (CONFIG_ENTROPY_NAME) not found. "
			"Check your build configuration!",
			CONFIG_ENTROPY_NAME);
		entropy_driver = dev;
   1da86:	6020      	str	r0, [r4, #0]
	return api->get_entropy(dev, buffer, length);
   1da88:	6843      	ldr	r3, [r0, #4]
   1da8a:	b2b2      	uxth	r2, r6
   1da8c:	4629      	mov	r1, r5
   1da8e:	681b      	ldr	r3, [r3, #0]
	}

	return entropy_get_entropy(dev, (u8_t *)buf, len);
}
   1da90:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   1da94:	4718      	bx	r3
   1da96:	bf00      	nop
   1da98:	20001e78 	.word	0x20001e78
   1da9c:	0003163e 	.word	0x0003163e

0001daa0 <ll_rx_link_inc_quota>:
	rx_alloc(UINT8_MAX);
}

static inline void ll_rx_link_inc_quota(int8_t delta)
{
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
   1daa0:	2801      	cmp	r0, #1
{
   1daa2:	b538      	push	{r3, r4, r5, lr}
   1daa4:	4604      	mov	r4, r0
   1daa6:	4d09      	ldr	r5, [pc, #36]	; (1dacc <ll_rx_link_inc_quota+0x2c>)
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
   1daa8:	d10b      	bne.n	1dac2 <ll_rx_link_inc_quota+0x22>
   1daaa:	782b      	ldrb	r3, [r5, #0]
   1daac:	2b06      	cmp	r3, #6
   1daae:	d908      	bls.n	1dac2 <ll_rx_link_inc_quota+0x22>
   1dab0:	4807      	ldr	r0, [pc, #28]	; (1dad0 <ll_rx_link_inc_quota+0x30>)
   1dab2:	f00a fb47 	bl	28144 <printk>
   1dab6:	4040      	eors	r0, r0
   1dab8:	f380 8811 	msr	BASEPRI, r0
   1dabc:	f04f 0003 	mov.w	r0, #3
   1dac0:	df02      	svc	2
	mem_link_rx.quota_pdu += delta;
   1dac2:	782b      	ldrb	r3, [r5, #0]
   1dac4:	441c      	add	r4, r3
   1dac6:	702c      	strb	r4, [r5, #0]
}
   1dac8:	bd38      	pop	{r3, r4, r5, pc}
   1daca:	bf00      	nop
   1dacc:	20001f74 	.word	0x20001f74
   1dad0:	000316e6 	.word	0x000316e6

0001dad4 <rx_alloc>:

	return done;
}

static inline void rx_alloc(u8_t max)
{
   1dad4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	u8_t idx;

#if defined(CONFIG_BT_CONN)
	while (mem_link_rx.quota_pdu &&
   1dad8:	4e31      	ldr	r6, [pc, #196]	; (1dba0 <rx_alloc+0xcc>)
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
   1dada:	4f32      	ldr	r7, [pc, #200]	; (1dba4 <rx_alloc+0xd0>)
{
   1dadc:	4680      	mov	r8, r0
   1dade:	46b1      	mov	r9, r6
	while (mem_link_rx.quota_pdu &&
   1dae0:	7833      	ldrb	r3, [r6, #0]
   1dae2:	b1b3      	cbz	r3, 1db12 <rx_alloc+0x3e>
 */
static inline bool mfifo_enqueue_idx_get(u8_t count, u8_t first, u8_t last,
					 u8_t *idx)
{
	/* Non-destructive: Advance write-index modulo 'count' */
	last = last + 1;
   1dae4:	78fc      	ldrb	r4, [r7, #3]
	if (last == count) {
   1dae6:	787a      	ldrb	r2, [r7, #1]
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
   1dae8:	78bb      	ldrb	r3, [r7, #2]
	last = last + 1;
   1daea:	3401      	adds	r4, #1
   1daec:	b2e4      	uxtb	r4, r4
		last = 0U;
   1daee:	42a2      	cmp	r2, r4
   1daf0:	bf08      	it	eq
   1daf2:	2400      	moveq	r4, #0
	 * We want to maintain the invariant of emptiness defined by
	 * first == last, but we just advanced a copy of the write-index before
	 * and may have wrapped. So if first == last the queue is full and we
	 * can not continue
	 */
	if (last == first) {
   1daf4:	42a3      	cmp	r3, r4
   1daf6:	d00c      	beq.n	1db12 <rx_alloc+0x3e>
		memq_link_t *link;
		struct node_rx_hdr *rx;

		link = mem_acquire(&mem_link_rx.free);
   1daf8:	482b      	ldr	r0, [pc, #172]	; (1dba8 <rx_alloc+0xd4>)
   1dafa:	f00d ff19 	bl	2b930 <mem_acquire>
		if (!link) {
   1dafe:	4605      	mov	r5, r0
   1db00:	b138      	cbz	r0, 1db12 <rx_alloc+0x3e>
			break;
		}

		rx = mem_acquire(&mem_pdu_rx.free);
   1db02:	482a      	ldr	r0, [pc, #168]	; (1dbac <rx_alloc+0xd8>)
   1db04:	f00d ff14 	bl	2b930 <mem_acquire>
		if (!rx) {
   1db08:	bb00      	cbnz	r0, 1db4c <rx_alloc+0x78>
			mem_release(link, &mem_link_rx.free);
   1db0a:	4927      	ldr	r1, [pc, #156]	; (1dba8 <rx_alloc+0xd4>)
   1db0c:	4628      	mov	r0, r5
   1db0e:	f00d ff28 	bl	2b962 <mem_release>

		ll_rx_link_inc_quota(-1);
	}
#endif /* CONFIG_BT_CONN */

	if (max > mem_link_rx.quota_pdu) {
   1db12:	f899 6000 	ldrb.w	r6, [r9]

	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
		memq_link_t *link;
		struct node_rx_hdr *rx;

		link = mem_acquire(&mem_link_rx.free);
   1db16:	4f24      	ldr	r7, [pc, #144]	; (1dba8 <rx_alloc+0xd4>)
   1db18:	4546      	cmp	r6, r8
   1db1a:	bf28      	it	cs
   1db1c:	4646      	movcs	r6, r8
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
   1db1e:	f8df 8090 	ldr.w	r8, [pc, #144]	; 1dbb0 <rx_alloc+0xdc>
   1db22:	b18e      	cbz	r6, 1db48 <rx_alloc+0x74>
	last = last + 1;
   1db24:	f898 4003 	ldrb.w	r4, [r8, #3]
	if (last == count) {
   1db28:	f898 2001 	ldrb.w	r2, [r8, #1]
   1db2c:	f898 3002 	ldrb.w	r3, [r8, #2]
	last = last + 1;
   1db30:	3401      	adds	r4, #1
   1db32:	b2e4      	uxtb	r4, r4
		last = 0U;
   1db34:	42a2      	cmp	r2, r4
   1db36:	bf08      	it	eq
   1db38:	2400      	moveq	r4, #0
	if (last == first) {
   1db3a:	42a3      	cmp	r3, r4
   1db3c:	d004      	beq.n	1db48 <rx_alloc+0x74>
		link = mem_acquire(&mem_link_rx.free);
   1db3e:	4638      	mov	r0, r7
   1db40:	f00d fef6 	bl	2b930 <mem_acquire>
		if (!link) {
   1db44:	4605      	mov	r5, r0
   1db46:	b978      	cbnz	r0, 1db68 <rx_alloc+0x94>

		MFIFO_BY_IDX_ENQUEUE(pdu_rx_free, idx, rx);

		ll_rx_link_inc_quota(-1);
	}
}
   1db48:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		link->mem = NULL;
   1db4c:	2300      	movs	r3, #0
   1db4e:	606b      	str	r3, [r5, #4]
		rx->link = link;
   1db50:	6005      	str	r5, [r0, #0]
 */
static inline void mfifo_by_idx_enqueue(u8_t *fifo, u8_t size, u8_t idx,
					void *mem, u8_t *last)
{
	/* API 2: fifo is array of void-ptrs */
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   1db52:	78fa      	ldrb	r2, [r7, #3]
   1db54:	783b      	ldrb	r3, [r7, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   1db56:	fb02 7303 	mla	r3, r2, r3, r7
   1db5a:	6058      	str	r0, [r3, #4]

	*last = idx; /* Commit: Update write index */
   1db5c:	70fc      	strb	r4, [r7, #3]
		ll_rx_link_inc_quota(-1);
   1db5e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1db62:	f7ff ff9d 	bl	1daa0 <ll_rx_link_inc_quota>
   1db66:	e7bb      	b.n	1dae0 <rx_alloc+0xc>
		rx = mem_acquire(&mem_pdu_rx.free);
   1db68:	4810      	ldr	r0, [pc, #64]	; (1dbac <rx_alloc+0xd8>)
   1db6a:	f00d fee1 	bl	2b930 <mem_acquire>
		if (!rx) {
   1db6e:	b928      	cbnz	r0, 1db7c <rx_alloc+0xa8>
			mem_release(link, &mem_link_rx.free);
   1db70:	4628      	mov	r0, r5
   1db72:	490d      	ldr	r1, [pc, #52]	; (1dba8 <rx_alloc+0xd4>)
}
   1db74:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			mem_release(link, &mem_link_rx.free);
   1db78:	f00d bef3 	b.w	2b962 <mem_release>
		rx->link = link;
   1db7c:	6005      	str	r5, [r0, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   1db7e:	f898 2003 	ldrb.w	r2, [r8, #3]
   1db82:	f898 3000 	ldrb.w	r3, [r8]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   1db86:	fb02 8303 	mla	r3, r2, r3, r8
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
   1db8a:	3e01      	subs	r6, #1
   1db8c:	6058      	str	r0, [r3, #4]
	*last = idx; /* Commit: Update write index */
   1db8e:	f888 4003 	strb.w	r4, [r8, #3]
		ll_rx_link_inc_quota(-1);
   1db92:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
   1db96:	b2f6      	uxtb	r6, r6
		ll_rx_link_inc_quota(-1);
   1db98:	f7ff ff82 	bl	1daa0 <ll_rx_link_inc_quota>
   1db9c:	e7c1      	b.n	1db22 <rx_alloc+0x4e>
   1db9e:	bf00      	nop
   1dba0:	20001f74 	.word	0x20001f74
   1dba4:	2000fac4 	.word	0x2000fac4
   1dba8:	20001f78 	.word	0x20001f78
   1dbac:	20001fec 	.word	0x20001fec
   1dbb0:	2000fad8 	.word	0x2000fad8

0001dbb4 <init_reset>:
	mem_init(mem_done.pool, sizeof(struct node_rx_event_done),
   1dbb4:	4b36      	ldr	r3, [pc, #216]	; (1dc90 <init_reset+0xdc>)
{
   1dbb6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	mem_init(mem_done.pool, sizeof(struct node_rx_event_done),
   1dbba:	1d18      	adds	r0, r3, #4
   1dbbc:	2203      	movs	r2, #3
   1dbbe:	2138      	movs	r1, #56	; 0x38
   1dbc0:	f00d fe92 	bl	2b8e8 <mem_init>
	mem_init(mem_link_done.pool, sizeof(memq_link_t), EVENT_DONE_MAX,
   1dbc4:	4b33      	ldr	r3, [pc, #204]	; (1dc94 <init_reset+0xe0>)
	while (MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
   1dbc6:	4d34      	ldr	r5, [pc, #208]	; (1dc98 <init_reset+0xe4>)
		link = mem_acquire(&mem_link_done.free);
   1dbc8:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 1dc94 <init_reset+0xe0>
	mem_init(mem_link_done.pool, sizeof(memq_link_t), EVENT_DONE_MAX,
   1dbcc:	2203      	movs	r2, #3
   1dbce:	2108      	movs	r1, #8
   1dbd0:	1d18      	adds	r0, r3, #4
   1dbd2:	f00d fe89 	bl	2b8e8 <mem_init>
	while (MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
   1dbd6:	462e      	mov	r6, r5
	last = last + 1;
   1dbd8:	78ec      	ldrb	r4, [r5, #3]
	if (last == count) {
   1dbda:	786a      	ldrb	r2, [r5, #1]
   1dbdc:	78ab      	ldrb	r3, [r5, #2]
	last = last + 1;
   1dbde:	3401      	adds	r4, #1
   1dbe0:	b2e4      	uxtb	r4, r4
		last = 0U;
   1dbe2:	42a2      	cmp	r2, r4
   1dbe4:	bf08      	it	eq
   1dbe6:	2400      	moveq	r4, #0
	if (last == first) {
   1dbe8:	429c      	cmp	r4, r3
   1dbea:	d00d      	beq.n	1dc08 <init_reset+0x54>
		link = mem_acquire(&mem_link_done.free);
   1dbec:	4640      	mov	r0, r8
   1dbee:	f00d fe9f 	bl	2b930 <mem_acquire>
		if (!link) {
   1dbf2:	4607      	mov	r7, r0
   1dbf4:	b140      	cbz	r0, 1dc08 <init_reset+0x54>
		rx = mem_acquire(&mem_done.free);
   1dbf6:	4826      	ldr	r0, [pc, #152]	; (1dc90 <init_reset+0xdc>)
   1dbf8:	f00d fe9a 	bl	2b930 <mem_acquire>
		if (!rx) {
   1dbfc:	2800      	cmp	r0, #0
   1dbfe:	d13e      	bne.n	1dc7e <init_reset+0xca>
			mem_release(link, &mem_link_done.free);
   1dc00:	4924      	ldr	r1, [pc, #144]	; (1dc94 <init_reset+0xe0>)
   1dc02:	4638      	mov	r0, r7
   1dc04:	f00d fead 	bl	2b962 <mem_release>
	mem_init(mem_pdu_rx.pool, (PDU_RX_NODE_POOL_ELEMENT_SIZE),
   1dc08:	4b24      	ldr	r3, [pc, #144]	; (1dc9c <init_reset+0xe8>)
   1dc0a:	2209      	movs	r2, #9
   1dc0c:	1d18      	adds	r0, r3, #4
   1dc0e:	214c      	movs	r1, #76	; 0x4c
   1dc10:	f00d fe6a 	bl	2b8e8 <mem_init>
	mem_init(mem_link_rx.pool, sizeof(memq_link_t),
   1dc14:	4b22      	ldr	r3, [pc, #136]	; (1dca0 <init_reset+0xec>)
   1dc16:	220e      	movs	r2, #14
   1dc18:	1d18      	adds	r0, r3, #4
   1dc1a:	2108      	movs	r1, #8
   1dc1c:	f00d fe64 	bl	2b8e8 <mem_init>
	link = mem_acquire(&mem_link_rx.free);
   1dc20:	481f      	ldr	r0, [pc, #124]	; (1dca0 <init_reset+0xec>)
   1dc22:	f00d fe85 	bl	2b930 <mem_acquire>
	LL_ASSERT(link);
   1dc26:	4604      	mov	r4, r0
   1dc28:	b940      	cbnz	r0, 1dc3c <init_reset+0x88>
   1dc2a:	481e      	ldr	r0, [pc, #120]	; (1dca4 <init_reset+0xf0>)
   1dc2c:	f00a fa8a 	bl	28144 <printk>
   1dc30:	4040      	eors	r0, r0
   1dc32:	f380 8811 	msr	BASEPRI, r0
   1dc36:	f04f 0003 	mov.w	r0, #3
   1dc3a:	df02      	svc	2
	MEMQ_INIT(ull_rx, link);
   1dc3c:	4a1a      	ldr	r2, [pc, #104]	; (1dca8 <init_reset+0xf4>)
   1dc3e:	4620      	mov	r0, r4
   1dc40:	1f11      	subs	r1, r2, #4
   1dc42:	f00d fec5 	bl	2b9d0 <memq_init>
	link = mem_acquire(&mem_link_rx.free);
   1dc46:	4816      	ldr	r0, [pc, #88]	; (1dca0 <init_reset+0xec>)
   1dc48:	f00d fe72 	bl	2b930 <mem_acquire>
	LL_ASSERT(link);
   1dc4c:	4604      	mov	r4, r0
   1dc4e:	b940      	cbnz	r0, 1dc62 <init_reset+0xae>
   1dc50:	4814      	ldr	r0, [pc, #80]	; (1dca4 <init_reset+0xf0>)
   1dc52:	f00a fa77 	bl	28144 <printk>
   1dc56:	4040      	eors	r0, r0
   1dc58:	f380 8811 	msr	BASEPRI, r0
   1dc5c:	f04f 0003 	mov.w	r0, #3
   1dc60:	df02      	svc	2
	MEMQ_INIT(ll_rx, link);
   1dc62:	4a12      	ldr	r2, [pc, #72]	; (1dcac <init_reset+0xf8>)
   1dc64:	4620      	mov	r0, r4
   1dc66:	1f11      	subs	r1, r2, #4
   1dc68:	f00d feb2 	bl	2b9d0 <memq_init>
	mem_link_rx.quota_pdu = RX_CNT;
   1dc6c:	4b10      	ldr	r3, [pc, #64]	; (1dcb0 <init_reset+0xfc>)
   1dc6e:	2207      	movs	r2, #7
	rx_alloc(UINT8_MAX);
   1dc70:	20ff      	movs	r0, #255	; 0xff
	mem_link_rx.quota_pdu = RX_CNT;
   1dc72:	701a      	strb	r2, [r3, #0]
	rx_alloc(UINT8_MAX);
   1dc74:	f7ff ff2e 	bl	1dad4 <rx_alloc>
}
   1dc78:	2000      	movs	r0, #0
   1dc7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		rx->link = link;
   1dc7e:	6007      	str	r7, [r0, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   1dc80:	78f2      	ldrb	r2, [r6, #3]
   1dc82:	7833      	ldrb	r3, [r6, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   1dc84:	fb02 6303 	mla	r3, r2, r3, r6
   1dc88:	6058      	str	r0, [r3, #4]
	*last = idx; /* Commit: Update write index */
   1dc8a:	70f4      	strb	r4, [r6, #3]
   1dc8c:	e7a4      	b.n	1dbd8 <init_reset+0x24>
   1dc8e:	bf00      	nop
   1dc90:	20001eac 	.word	0x20001eac
   1dc94:	20001f58 	.word	0x20001f58
   1dc98:	2000fab0 	.word	0x2000fab0
   1dc9c:	20001fec 	.word	0x20001fec
   1dca0:	20001f78 	.word	0x20001f78
   1dca4:	00031657 	.word	0x00031657
   1dca8:	200022a8 	.word	0x200022a8
   1dcac:	200022a0 	.word	0x200022a0
   1dcb0:	20001f74 	.word	0x20001f74

0001dcb4 <perform_lll_reset>:
{
   1dcb4:	b510      	push	{r4, lr}
   1dcb6:	4604      	mov	r4, r0
	err = lll_reset();
   1dcb8:	f00e f8dc 	bl	2be74 <lll_reset>
	LL_ASSERT(!err);
   1dcbc:	b140      	cbz	r0, 1dcd0 <perform_lll_reset+0x1c>
   1dcbe:	4819      	ldr	r0, [pc, #100]	; (1dd24 <perform_lll_reset+0x70>)
   1dcc0:	f00a fa40 	bl	28144 <printk>
   1dcc4:	4040      	eors	r0, r0
   1dcc6:	f380 8811 	msr	BASEPRI, r0
   1dcca:	f04f 0003 	mov.w	r0, #3
   1dcce:	df02      	svc	2
	err = lll_adv_reset();
   1dcd0:	f00e f98c 	bl	2bfec <lll_adv_reset>
	LL_ASSERT(!err);
   1dcd4:	b140      	cbz	r0, 1dce8 <perform_lll_reset+0x34>
   1dcd6:	4813      	ldr	r0, [pc, #76]	; (1dd24 <perform_lll_reset+0x70>)
   1dcd8:	f00a fa34 	bl	28144 <printk>
   1dcdc:	4040      	eors	r0, r0
   1dcde:	f380 8811 	msr	BASEPRI, r0
   1dce2:	f04f 0003 	mov.w	r0, #3
   1dce6:	df02      	svc	2
	err = lll_scan_reset();
   1dce8:	f00e fab7 	bl	2c25a <lll_scan_reset>
	LL_ASSERT(!err);
   1dcec:	b140      	cbz	r0, 1dd00 <perform_lll_reset+0x4c>
   1dcee:	480d      	ldr	r0, [pc, #52]	; (1dd24 <perform_lll_reset+0x70>)
   1dcf0:	f00a fa28 	bl	28144 <printk>
   1dcf4:	4040      	eors	r0, r0
   1dcf6:	f380 8811 	msr	BASEPRI, r0
   1dcfa:	f04f 0003 	mov.w	r0, #3
   1dcfe:	df02      	svc	2
	err = lll_conn_reset();
   1dd00:	f00e fd11 	bl	2c726 <lll_conn_reset>
	LL_ASSERT(!err);
   1dd04:	b140      	cbz	r0, 1dd18 <perform_lll_reset+0x64>
   1dd06:	4807      	ldr	r0, [pc, #28]	; (1dd24 <perform_lll_reset+0x70>)
   1dd08:	f00a fa1c 	bl	28144 <printk>
   1dd0c:	4040      	eors	r0, r0
   1dd0e:	f380 8811 	msr	BASEPRI, r0
   1dd12:	f04f 0003 	mov.w	r0, #3
   1dd16:	df02      	svc	2
	z_impl_k_sem_give(sem);
   1dd18:	4620      	mov	r0, r4
}
   1dd1a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1dd1e:	f009 b9f3 	b.w	27108 <z_impl_k_sem_give>
   1dd22:	bf00      	nop
   1dd24:	000317e5 	.word	0x000317e5

0001dd28 <tx_cmplt_get>:

#if defined(CONFIG_BT_CONN)
static u8_t tx_cmplt_get(u16_t *handle, u8_t *first, u8_t last)
{
   1dd28:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1dd2c:	460d      	mov	r5, r1
	struct lll_tx *tx;
	u8_t cmplt;

	tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
   1dd2e:	4e28      	ldr	r6, [pc, #160]	; (1ddd0 <tx_cmplt_get+0xa8>)
					   u8_t first, u8_t last, u8_t *idx)
{
	void *p;
	u8_t i;

	if (*idx >= count) {
   1dd30:	782b      	ldrb	r3, [r5, #0]
   1dd32:	7871      	ldrb	r1, [r6, #1]
   1dd34:	428b      	cmp	r3, r1
   1dd36:	bf28      	it	cs
   1dd38:	78b3      	ldrbcs	r3, [r6, #2]
{
   1dd3a:	4680      	mov	r8, r0
	tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
   1dd3c:	7830      	ldrb	r0, [r6, #0]
		*idx = first;
   1dd3e:	bf28      	it	cs
   1dd40:	702b      	strbcs	r3, [r5, #0]
	}

	if (*idx == last) {
   1dd42:	782b      	ldrb	r3, [r5, #0]
   1dd44:	429a      	cmp	r2, r3
{
   1dd46:	4691      	mov	r9, r2
   1dd48:	d103      	bne.n	1dd52 <tx_cmplt_get+0x2a>
				    mfifo_tx_ack.n, mfifo_tx_ack.f, last,
				    first);
	if (!tx) {
		return 0;
   1dd4a:	2700      	movs	r7, #0
					    mfifo_tx_ack.n, mfifo_tx_ack.f,
					    last, first);
	} while (tx && tx->handle == *handle);

	return cmplt;
}
   1dd4c:	4638      	mov	r0, r7
   1dd4e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return NULL;
	}

	i = *idx + 1;
   1dd52:	1c5a      	adds	r2, r3, #1
   1dd54:	b2d2      	uxtb	r2, r2
	if (i == count) {
		i = 0U;
	}

	p = (void *)(fifo + (*idx) * size);
   1dd56:	4c1f      	ldr	r4, [pc, #124]	; (1ddd4 <tx_cmplt_get+0xac>)
		i = 0U;
   1dd58:	4291      	cmp	r1, r2
   1dd5a:	bf08      	it	eq
   1dd5c:	2200      	moveq	r2, #0
	p = (void *)(fifo + (*idx) * size);
   1dd5e:	fb13 f300 	smulbb	r3, r3, r0

	*idx = i;
   1dd62:	702a      	strb	r2, [r5, #0]
	if (!tx) {
   1dd64:	18e2      	adds	r2, r4, r3
   1dd66:	d0f0      	beq.n	1dd4a <tx_cmplt_get+0x22>
	*handle = tx->handle;
   1dd68:	5ae3      	ldrh	r3, [r4, r3]
   1dd6a:	f8a8 3000 	strh.w	r3, [r8]
	cmplt = 0U;
   1dd6e:	2700      	movs	r7, #0
		node_tx = tx->node;
   1dd70:	6850      	ldr	r0, [r2, #4]
		if (!node_tx || (node_tx == (void *)1) ||
   1dd72:	2801      	cmp	r0, #1
   1dd74:	f020 0103 	bic.w	r1, r0, #3
   1dd78:	d906      	bls.n	1dd88 <tx_cmplt_get+0x60>
   1dd7a:	b331      	cbz	r1, 1ddca <tx_cmplt_get+0xa2>
		     (p->ll_id == PDU_DATA_LLID_DATA_START ||
   1dd7c:	7903      	ldrb	r3, [r0, #4]
   1dd7e:	f003 0303 	and.w	r3, r3, #3
		    (((u32_t)node_tx & ~3) &&
   1dd82:	3b01      	subs	r3, #1
   1dd84:	2b01      	cmp	r3, #1
   1dd86:	d820      	bhi.n	1ddca <tx_cmplt_get+0xa2>
			cmplt++;
   1dd88:	3701      	adds	r7, #1
   1dd8a:	b2ff      	uxtb	r7, r7
			tx->node = (void *)1;
   1dd8c:	2301      	movs	r3, #1
   1dd8e:	6053      	str	r3, [r2, #4]
		if (((u32_t)node_tx & ~3)) {
   1dd90:	b109      	cbz	r1, 1dd96 <tx_cmplt_get+0x6e>
			ll_tx_mem_release(node_tx);
   1dd92:	f002 fc0b 	bl	205ac <ll_tx_mem_release>
	if (*idx >= count) {
   1dd96:	782b      	ldrb	r3, [r5, #0]
		tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
   1dd98:	7872      	ldrb	r2, [r6, #1]
   1dd9a:	7830      	ldrb	r0, [r6, #0]
   1dd9c:	4293      	cmp	r3, r2
   1dd9e:	bf24      	itt	cs
   1dda0:	78b3      	ldrbcs	r3, [r6, #2]
		*idx = first;
   1dda2:	702b      	strbcs	r3, [r5, #0]
	if (*idx == last) {
   1dda4:	782b      	ldrb	r3, [r5, #0]
   1dda6:	4599      	cmp	r9, r3
   1dda8:	d0d0      	beq.n	1dd4c <tx_cmplt_get+0x24>
	i = *idx + 1;
   1ddaa:	1c59      	adds	r1, r3, #1
   1ddac:	b2c9      	uxtb	r1, r1
	p = (void *)(fifo + (*idx) * size);
   1ddae:	fb13 f300 	smulbb	r3, r3, r0
		i = 0U;
   1ddb2:	428a      	cmp	r2, r1
   1ddb4:	bf08      	it	eq
   1ddb6:	2100      	moveq	r1, #0
	} while (tx && tx->handle == *handle);
   1ddb8:	18e2      	adds	r2, r4, r3
	*idx = i;
   1ddba:	7029      	strb	r1, [r5, #0]
   1ddbc:	d0c6      	beq.n	1dd4c <tx_cmplt_get+0x24>
   1ddbe:	5ae3      	ldrh	r3, [r4, r3]
   1ddc0:	f8b8 1000 	ldrh.w	r1, [r8]
   1ddc4:	4299      	cmp	r1, r3
   1ddc6:	d0d3      	beq.n	1dd70 <tx_cmplt_get+0x48>
   1ddc8:	e7c0      	b.n	1dd4c <tx_cmplt_get+0x24>
			tx->node = (void *)2;
   1ddca:	2302      	movs	r3, #2
   1ddcc:	e7df      	b.n	1dd8e <tx_cmplt_get+0x66>
   1ddce:	bf00      	nop
   1ddd0:	2000fc14 	.word	0x2000fc14
   1ddd4:	2000fc18 	.word	0x2000fc18

0001ddd8 <ll_init>:
{
   1ddd8:	b510      	push	{r4, lr}
	sem_recv = sem_rx;
   1ddda:	4b2a      	ldr	r3, [pc, #168]	; (1de84 <ll_init+0xac>)
{
   1dddc:	b086      	sub	sp, #24
	sem_recv = sem_rx;
   1ddde:	6018      	str	r0, [r3, #0]
	cntr_init();
   1dde0:	f006 fbb0 	bl	24544 <cntr_init>
	mayfly_init();
   1dde4:	f7fd fca4 	bl	1b730 <mayfly_init>
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
   1dde8:	4a27      	ldr	r2, [pc, #156]	; (1de88 <ll_init+0xb0>)
   1ddea:	2103      	movs	r1, #3
   1ddec:	7011      	strb	r1, [r2, #0]
	ticker_users[MAYFLY_CALL_ID_PROGRAM][0] = TICKER_USER_APP_OPS;
   1ddee:	7611      	strb	r1, [r2, #24]
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
   1ddf0:	2002      	movs	r0, #2
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
   1ddf2:	4926      	ldr	r1, [pc, #152]	; (1de8c <ll_init+0xb4>)
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
   1ddf4:	7410      	strb	r0, [r2, #16]
	ticker_users[MAYFLY_CALL_ID_1][0] = TICKER_USER_ULL_HIGH_OPS;
   1ddf6:	2304      	movs	r3, #4
   1ddf8:	7213      	strb	r3, [r2, #8]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
   1ddfa:	9105      	str	r1, [sp, #20]
   1ddfc:	4924      	ldr	r1, [pc, #144]	; (1de90 <ll_init+0xb8>)
   1ddfe:	9104      	str	r1, [sp, #16]
   1de00:	4924      	ldr	r1, [pc, #144]	; (1de94 <ll_init+0xbc>)
   1de02:	9103      	str	r1, [sp, #12]
   1de04:	4924      	ldr	r1, [pc, #144]	; (1de98 <ll_init+0xc0>)
   1de06:	9102      	str	r1, [sp, #8]
   1de08:	210c      	movs	r1, #12
   1de0a:	e9cd 2100 	strd	r2, r1, [sp]
   1de0e:	2000      	movs	r0, #0
   1de10:	4a22      	ldr	r2, [pc, #136]	; (1de9c <ll_init+0xc4>)
   1de12:	210b      	movs	r1, #11
   1de14:	f7fe f8f6 	bl	1c004 <ticker_init>
	LL_ASSERT(!err);
   1de18:	b140      	cbz	r0, 1de2c <ll_init+0x54>
   1de1a:	4821      	ldr	r0, [pc, #132]	; (1dea0 <ll_init+0xc8>)
   1de1c:	f00a f992 	bl	28144 <printk>
   1de20:	4040      	eors	r0, r0
   1de22:	f380 8811 	msr	BASEPRI, r0
   1de26:	f04f 0003 	mov.w	r0, #3
   1de2a:	df02      	svc	2
	z_impl_k_sem_init(sem, initial_count, limit);
   1de2c:	2201      	movs	r2, #1
   1de2e:	2100      	movs	r1, #0
   1de30:	481c      	ldr	r0, [pc, #112]	; (1dea4 <ll_init+0xcc>)
   1de32:	f00f fae8 	bl	2d406 <z_impl_k_sem_init>
	err = lll_init();
   1de36:	f000 fef1 	bl	1ec1c <lll_init>
	if (err) {
   1de3a:	4604      	mov	r4, r0
   1de3c:	b9f0      	cbnz	r0, 1de7c <ll_init+0xa4>
	err = init_reset();
   1de3e:	f7ff feb9 	bl	1dbb4 <init_reset>
	if (err) {
   1de42:	4604      	mov	r4, r0
   1de44:	b9d0      	cbnz	r0, 1de7c <ll_init+0xa4>
	err = lll_adv_init();
   1de46:	f00e f8cf 	bl	2bfe8 <lll_adv_init>
	if (err) {
   1de4a:	4604      	mov	r4, r0
   1de4c:	b9b0      	cbnz	r0, 1de7c <ll_init+0xa4>
	err = ull_adv_init();
   1de4e:	f00e f83d 	bl	2becc <ull_adv_init>
	if (err) {
   1de52:	4604      	mov	r4, r0
   1de54:	b990      	cbnz	r0, 1de7c <ll_init+0xa4>
	err = lll_scan_init();
   1de56:	f00e f9fe 	bl	2c256 <lll_scan_init>
	if (err) {
   1de5a:	4604      	mov	r4, r0
   1de5c:	b970      	cbnz	r0, 1de7c <ll_init+0xa4>
	err = ull_scan_init();
   1de5e:	f00e f8c7 	bl	2bff0 <ull_scan_init>
	if (err) {
   1de62:	4604      	mov	r4, r0
   1de64:	b950      	cbnz	r0, 1de7c <ll_init+0xa4>
	err = lll_conn_init();
   1de66:	f00e fc5c 	bl	2c722 <lll_conn_init>
	if (err) {
   1de6a:	4604      	mov	r4, r0
   1de6c:	b930      	cbnz	r0, 1de7c <ll_init+0xa4>
	err = ull_conn_init();
   1de6e:	f002 fc1f 	bl	206b0 <ull_conn_init>
	if (err) {
   1de72:	4604      	mov	r4, r0
   1de74:	b910      	cbnz	r0, 1de7c <ll_init+0xa4>
		ull_filter_reset(true);
   1de76:	2001      	movs	r0, #1
   1de78:	f006 f984 	bl	24184 <ull_filter_reset>
}
   1de7c:	4620      	mov	r0, r4
   1de7e:	b006      	add	sp, #24
   1de80:	bd10      	pop	{r4, pc}
   1de82:	bf00      	nop
   1de84:	200022ac 	.word	0x200022ac
   1de88:	200026ec 	.word	0x200026ec
   1de8c:	0002cb07 	.word	0x0002cb07
   1de90:	000250f9 	.word	0x000250f9
   1de94:	000250b5 	.word	0x000250b5
   1de98:	200024ac 	.word	0x200024ac
   1de9c:	200022c8 	.word	0x200022c8
   1dea0:	000317e5 	.word	0x000317e5
   1dea4:	200022b0 	.word	0x200022b0

0001dea8 <ll_reset>:
{
   1dea8:	b510      	push	{r4, lr}
   1deaa:	b086      	sub	sp, #24
	err = ull_adv_reset();
   1deac:	f00e f810 	bl	2bed0 <ull_adv_reset>
	LL_ASSERT(!err);
   1deb0:	b140      	cbz	r0, 1dec4 <ll_reset+0x1c>
   1deb2:	4839      	ldr	r0, [pc, #228]	; (1df98 <ll_reset+0xf0>)
   1deb4:	f00a f946 	bl	28144 <printk>
   1deb8:	4040      	eors	r0, r0
   1deba:	f380 8811 	msr	BASEPRI, r0
   1debe:	f04f 0003 	mov.w	r0, #3
   1dec2:	df02      	svc	2
	err = ull_scan_reset();
   1dec4:	f00e f8b2 	bl	2c02c <ull_scan_reset>
	LL_ASSERT(!err);
   1dec8:	b140      	cbz	r0, 1dedc <ll_reset+0x34>
   1deca:	4833      	ldr	r0, [pc, #204]	; (1df98 <ll_reset+0xf0>)
   1decc:	f00a f93a 	bl	28144 <printk>
   1ded0:	4040      	eors	r0, r0
   1ded2:	f380 8811 	msr	BASEPRI, r0
   1ded6:	f04f 0003 	mov.w	r0, #3
   1deda:	df02      	svc	2
		err = ll_connect_disable(&rx);
   1dedc:	4668      	mov	r0, sp
   1dede:	f005 fad9 	bl	23494 <ll_connect_disable>
		if (!err) {
   1dee2:	b9a0      	cbnz	r0, 1df0e <ll_reset+0x66>
			scan = ull_scan_is_enabled_get(0);
   1dee4:	f001 fee4 	bl	1fcb0 <ull_scan_is_enabled_get>
			LL_ASSERT(scan);
   1dee8:	4604      	mov	r4, r0
   1deea:	b940      	cbnz	r0, 1defe <ll_reset+0x56>
   1deec:	482b      	ldr	r0, [pc, #172]	; (1df9c <ll_reset+0xf4>)
   1deee:	f00a f929 	bl	28144 <printk>
   1def2:	4040      	eors	r0, r0
   1def4:	f380 8811 	msr	BASEPRI, r0
   1def8:	f04f 0003 	mov.w	r0, #3
   1defc:	df02      	svc	2
			scan->is_enabled = 0U;
   1defe:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
   1df02:	f36f 0300 	bfc	r3, #0, #1
   1df06:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
			scan->lll.conn = NULL;
   1df0a:	2300      	movs	r3, #0
   1df0c:	6263      	str	r3, [r4, #36]	; 0x24
	err = ull_conn_reset();
   1df0e:	f002 fbe1 	bl	206d4 <ull_conn_reset>
	LL_ASSERT(!err);
   1df12:	b140      	cbz	r0, 1df26 <ll_reset+0x7e>
   1df14:	4820      	ldr	r0, [pc, #128]	; (1df98 <ll_reset+0xf0>)
   1df16:	f00a f915 	bl	28144 <printk>
   1df1a:	4040      	eors	r0, r0
   1df1c:	f380 8811 	msr	BASEPRI, r0
   1df20:	f04f 0003 	mov.w	r0, #3
   1df24:	df02      	svc	2
	MFIFO_INIT(tx_ack);
   1df26:	4b1e      	ldr	r3, [pc, #120]	; (1dfa0 <ll_reset+0xf8>)
   1df28:	2400      	movs	r4, #0
   1df2a:	805c      	strh	r4, [r3, #2]
		ull_filter_reset(false);
   1df2c:	4620      	mov	r0, r4
   1df2e:	f006 f929 	bl	24184 <ull_filter_reset>
	MFIFO_INIT(prep);
   1df32:	4b1c      	ldr	r3, [pc, #112]	; (1dfa4 <ll_reset+0xfc>)
   1df34:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(done);
   1df36:	4b1c      	ldr	r3, [pc, #112]	; (1dfa8 <ll_reset+0x100>)
   1df38:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(pdu_rx_free);
   1df3a:	4b1c      	ldr	r3, [pc, #112]	; (1dfac <ll_reset+0x104>)
   1df3c:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(ll_pdu_rx_free);
   1df3e:	4b1c      	ldr	r3, [pc, #112]	; (1dfb0 <ll_reset+0x108>)
   1df40:	805c      	strh	r4, [r3, #2]
   1df42:	2201      	movs	r2, #1
   1df44:	4621      	mov	r1, r4
   1df46:	4668      	mov	r0, sp
   1df48:	f00f fa5d 	bl	2d406 <z_impl_k_sem_init>
		mfy.param = &sem;
   1df4c:	4b19      	ldr	r3, [pc, #100]	; (1dfb4 <ll_reset+0x10c>)
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
   1df4e:	4622      	mov	r2, r4
   1df50:	4621      	mov	r1, r4
   1df52:	2003      	movs	r0, #3
		mfy.param = &sem;
   1df54:	f8c3 d008 	str.w	sp, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
   1df58:	f7fd fc3c 	bl	1b7d4 <mayfly_enqueue>
		LL_ASSERT(!retval);
   1df5c:	b140      	cbz	r0, 1df70 <ll_reset+0xc8>
   1df5e:	4816      	ldr	r0, [pc, #88]	; (1dfb8 <ll_reset+0x110>)
   1df60:	f00a f8f0 	bl	28144 <printk>
   1df64:	4040      	eors	r0, r0
   1df66:	f380 8811 	msr	BASEPRI, r0
   1df6a:	f04f 0003 	mov.w	r0, #3
   1df6e:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
   1df70:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1df74:	4668      	mov	r0, sp
   1df76:	f009 f8f3 	bl	27160 <z_impl_k_sem_take>
	err = init_reset();
   1df7a:	f7ff fe1b 	bl	1dbb4 <init_reset>
	LL_ASSERT(!err);
   1df7e:	b140      	cbz	r0, 1df92 <ll_reset+0xea>
   1df80:	4805      	ldr	r0, [pc, #20]	; (1df98 <ll_reset+0xf0>)
   1df82:	f00a f8df 	bl	28144 <printk>
   1df86:	4040      	eors	r0, r0
   1df88:	f380 8811 	msr	BASEPRI, r0
   1df8c:	f04f 0003 	mov.w	r0, #3
   1df90:	df02      	svc	2
}
   1df92:	b006      	add	sp, #24
   1df94:	bd10      	pop	{r4, pc}
   1df96:	bf00      	nop
   1df98:	000317e5 	.word	0x000317e5
   1df9c:	00031685 	.word	0x00031685
   1dfa0:	2000fc14 	.word	0x2000fc14
   1dfa4:	2000faf0 	.word	0x2000faf0
   1dfa8:	2000fab0 	.word	0x2000fab0
   1dfac:	2000fad8 	.word	0x2000fad8
   1dfb0:	2000fac4 	.word	0x2000fac4
   1dfb4:	2000fc38 	.word	0x2000fc38
   1dfb8:	0003169c 	.word	0x0003169c

0001dfbc <ll_rx_get>:
{
   1dfbc:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
   1dfc0:	4d25      	ldr	r5, [pc, #148]	; (1e058 <ll_rx_get+0x9c>)
   1dfc2:	4e26      	ldr	r6, [pc, #152]	; (1e05c <ll_rx_get+0xa0>)
{
   1dfc4:	4680      	mov	r8, r0
   1dfc6:	460f      	mov	r7, r1
   1dfc8:	46aa      	mov	sl, r5
	*node_rx = NULL;
   1dfca:	2300      	movs	r3, #0
   1dfcc:	f8c8 3000 	str.w	r3, [r8]
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
   1dfd0:	aa01      	add	r2, sp, #4
   1dfd2:	e9d5 0100 	ldrd	r0, r1, [r5]
   1dfd6:	f00d fd10 	bl	2b9fa <memq_peek>
	if (link) {
   1dfda:	4681      	mov	r9, r0
   1dfdc:	b3a0      	cbz	r0, 1e048 <ll_rx_get+0x8c>
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, rx->ack_last);
   1dfde:	9b01      	ldr	r3, [sp, #4]
   1dfe0:	491f      	ldr	r1, [pc, #124]	; (1e060 <ll_rx_get+0xa4>)
   1dfe2:	781a      	ldrb	r2, [r3, #0]
   1dfe4:	4638      	mov	r0, r7
   1dfe6:	f7ff fe9f 	bl	1dd28 <tx_cmplt_get>
		if (!cmplt) {
   1dfea:	4604      	mov	r4, r0
   1dfec:	bb40      	cbnz	r0, 1e040 <ll_rx_get+0x84>
			f = mfifo_tx_ack.f;
   1dfee:	78b3      	ldrb	r3, [r6, #2]
   1dff0:	f88d 3001 	strb.w	r3, [sp, #1]
				cmplt_curr = tx_cmplt_get(&h, &f,
   1dff4:	78f2      	ldrb	r2, [r6, #3]
   1dff6:	f10d 0101 	add.w	r1, sp, #1
   1dffa:	f10d 0002 	add.w	r0, sp, #2
   1dffe:	f7ff fe93 	bl	1dd28 <tx_cmplt_get>
				 (cmplt_prev != cmplt_curr));
   1e002:	b9cc      	cbnz	r4, 1e038 <ll_rx_get+0x7c>
			} while ((cmplt_prev != 0U) ||
   1e004:	b9c0      	cbnz	r0, 1e038 <ll_rx_get+0x7c>
			if (rx->type == NODE_RX_TYPE_DC_PDU_RELEASE) {
   1e006:	9b01      	ldr	r3, [sp, #4]
   1e008:	791a      	ldrb	r2, [r3, #4]
   1e00a:	2a03      	cmp	r2, #3
   1e00c:	d116      	bne.n	1e03c <ll_rx_get+0x80>
				(void)memq_dequeue(memq_ll_rx.tail,
   1e00e:	4622      	mov	r2, r4
   1e010:	4629      	mov	r1, r5
   1e012:	f8da 0004 	ldr.w	r0, [sl, #4]
   1e016:	f00d fcf8 	bl	2ba0a <memq_dequeue>
				mem_release(link, &mem_link_rx.free);
   1e01a:	4912      	ldr	r1, [pc, #72]	; (1e064 <ll_rx_get+0xa8>)
   1e01c:	4648      	mov	r0, r9
   1e01e:	f00d fca0 	bl	2b962 <mem_release>
				ll_rx_link_inc_quota(1);
   1e022:	2001      	movs	r0, #1
   1e024:	f7ff fd3c 	bl	1daa0 <ll_rx_link_inc_quota>
				mem_release(rx, &mem_pdu_rx.free);
   1e028:	9801      	ldr	r0, [sp, #4]
   1e02a:	490f      	ldr	r1, [pc, #60]	; (1e068 <ll_rx_get+0xac>)
   1e02c:	f00d fc99 	bl	2b962 <mem_release>
				rx_alloc(1);
   1e030:	2001      	movs	r0, #1
   1e032:	f7ff fd4f 	bl	1dad4 <rx_alloc>
				goto ll_rx_get_again;
   1e036:	e7c8      	b.n	1dfca <ll_rx_get+0xe>
{
   1e038:	4604      	mov	r4, r0
   1e03a:	e7db      	b.n	1dff4 <ll_rx_get+0x38>
			*node_rx = rx;
   1e03c:	f8c8 3000 	str.w	r3, [r8]
}
   1e040:	4620      	mov	r0, r4
   1e042:	b002      	add	sp, #8
   1e044:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, mfifo_tx_ack.l);
   1e048:	78f2      	ldrb	r2, [r6, #3]
   1e04a:	4905      	ldr	r1, [pc, #20]	; (1e060 <ll_rx_get+0xa4>)
   1e04c:	4638      	mov	r0, r7
   1e04e:	f7ff fe6b 	bl	1dd28 <tx_cmplt_get>
   1e052:	4604      	mov	r4, r0
   1e054:	e7f4      	b.n	1e040 <ll_rx_get+0x84>
   1e056:	bf00      	nop
   1e058:	2000229c 	.word	0x2000229c
   1e05c:	2000fc14 	.word	0x2000fc14
   1e060:	2000fc16 	.word	0x2000fc16
   1e064:	20001f78 	.word	0x20001f78
   1e068:	20001fec 	.word	0x20001fec

0001e06c <ll_rx_mem_release>:
{
   1e06c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	rx = *node_rx;
   1e070:	6804      	ldr	r4, [r0, #0]
			LL_ASSERT(0);
   1e072:	4e57      	ldr	r6, [pc, #348]	; (1e1d0 <ll_rx_mem_release+0x164>)
			mem_release(rx_free, &mem_pdu_rx.free);
   1e074:	4f57      	ldr	r7, [pc, #348]	; (1e1d4 <ll_rx_mem_release+0x168>)
			LL_ASSERT(rx_free->type != NODE_RX_TYPE_NONE);
   1e076:	f8df 8174 	ldr.w	r8, [pc, #372]	; 1e1ec <ll_rx_mem_release+0x180>
{
   1e07a:	4605      	mov	r5, r0
	while (rx) {
   1e07c:	b92c      	cbnz	r4, 1e08a <ll_rx_mem_release+0x1e>
	*node_rx = rx;
   1e07e:	602c      	str	r4, [r5, #0]
	rx_alloc(UINT8_MAX);
   1e080:	20ff      	movs	r0, #255	; 0xff
}
   1e082:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	rx_alloc(UINT8_MAX);
   1e086:	f7ff bd25 	b.w	1dad4 <rx_alloc>
		switch (rx_free->type) {
   1e08a:	7922      	ldrb	r2, [r4, #4]
		rx = rx->next;
   1e08c:	f8d4 9000 	ldr.w	r9, [r4]
		switch (rx_free->type) {
   1e090:	2a0e      	cmp	r2, #14
   1e092:	f200 8092 	bhi.w	1e1ba <ll_rx_mem_release+0x14e>
   1e096:	2301      	movs	r3, #1
   1e098:	4093      	lsls	r3, r2
   1e09a:	f647 4115 	movw	r1, #31765	; 0x7c15
   1e09e:	420b      	tst	r3, r1
   1e0a0:	d153      	bne.n	1e14a <ll_rx_mem_release+0xde>
   1e0a2:	f413 7000 	ands.w	r0, r3, #512	; 0x200
   1e0a6:	d162      	bne.n	1e16e <ll_rx_mem_release+0x102>
   1e0a8:	05db      	lsls	r3, r3, #23
   1e0aa:	f140 8086 	bpl.w	1e1ba <ll_rx_mem_release+0x14e>
			if (*((u8_t *)rx->pdu) ==
   1e0ae:	f894 3020 	ldrb.w	r3, [r4, #32]
   1e0b2:	2b02      	cmp	r3, #2
   1e0b4:	d149      	bne.n	1e14a <ll_rx_mem_release+0xde>
				scan = ull_scan_is_enabled_get(0);
   1e0b6:	f001 fdfb 	bl	1fcb0 <ull_scan_is_enabled_get>
				LL_ASSERT(scan);
   1e0ba:	4682      	mov	sl, r0
   1e0bc:	b940      	cbnz	r0, 1e0d0 <ll_rx_mem_release+0x64>
   1e0be:	4846      	ldr	r0, [pc, #280]	; (1e1d8 <ll_rx_mem_release+0x16c>)
   1e0c0:	f00a f840 	bl	28144 <printk>
   1e0c4:	4040      	eors	r0, r0
   1e0c6:	f380 8811 	msr	BASEPRI, r0
   1e0ca:	f04f 0003 	mov.w	r0, #3
   1e0ce:	df02      	svc	2
				conn_lll = scan->lll.conn;
   1e0d0:	f8da 4024 	ldr.w	r4, [sl, #36]	; 0x24
				LL_ASSERT(conn_lll);
   1e0d4:	b944      	cbnz	r4, 1e0e8 <ll_rx_mem_release+0x7c>
   1e0d6:	4841      	ldr	r0, [pc, #260]	; (1e1dc <ll_rx_mem_release+0x170>)
   1e0d8:	f00a f834 	bl	28144 <printk>
   1e0dc:	4040      	eors	r0, r0
   1e0de:	f380 8811 	msr	BASEPRI, r0
   1e0e2:	f04f 0003 	mov.w	r0, #3
   1e0e6:	df02      	svc	2
				LL_ASSERT(!conn_lll->link_tx_free);
   1e0e8:	6de3      	ldr	r3, [r4, #92]	; 0x5c
   1e0ea:	b143      	cbz	r3, 1e0fe <ll_rx_mem_release+0x92>
   1e0ec:	483c      	ldr	r0, [pc, #240]	; (1e1e0 <ll_rx_mem_release+0x174>)
   1e0ee:	f00a f829 	bl	28144 <printk>
   1e0f2:	4040      	eors	r0, r0
   1e0f4:	f380 8811 	msr	BASEPRI, r0
   1e0f8:	f04f 0003 	mov.w	r0, #3
   1e0fc:	df02      	svc	2
				link = memq_deinit(&conn_lll->memq_tx.head,
   1e0fe:	f104 0150 	add.w	r1, r4, #80	; 0x50
   1e102:	f104 004c 	add.w	r0, r4, #76	; 0x4c
   1e106:	f00d fc66 	bl	2b9d6 <memq_deinit>
				LL_ASSERT(link);
   1e10a:	4683      	mov	fp, r0
   1e10c:	b940      	cbnz	r0, 1e120 <ll_rx_mem_release+0xb4>
   1e10e:	4835      	ldr	r0, [pc, #212]	; (1e1e4 <ll_rx_mem_release+0x178>)
   1e110:	f00a f818 	bl	28144 <printk>
   1e114:	4040      	eors	r0, r0
   1e116:	f380 8811 	msr	BASEPRI, r0
   1e11a:	f04f 0003 	mov.w	r0, #3
   1e11e:	df02      	svc	2
				ll_conn_release(conn);
   1e120:	6820      	ldr	r0, [r4, #0]
				conn_lll->link_tx_free = link;
   1e122:	f8c4 b05c 	str.w	fp, [r4, #92]	; 0x5c
				ll_conn_release(conn);
   1e126:	f002 fa25 	bl	20574 <ll_conn_release>
				scan->is_enabled = 0U;
   1e12a:	f89a 3048 	ldrb.w	r3, [sl, #72]	; 0x48
				scan->lll.conn = NULL;
   1e12e:	2000      	movs	r0, #0
				scan->is_enabled = 0U;
   1e130:	f36f 0300 	bfc	r3, #0, #1
   1e134:	f88a 3048 	strb.w	r3, [sl, #72]	; 0x48
				scan->lll.conn = NULL;
   1e138:	f8ca 0024 	str.w	r0, [sl, #36]	; 0x24
				if (!ull_adv_is_enabled_get(0))
   1e13c:	f001 f936 	bl	1f3ac <ull_adv_is_enabled_get>
   1e140:	b908      	cbnz	r0, 1e146 <ll_rx_mem_release+0xda>
					ull_filter_adv_scan_state_cb(0);
   1e142:	f005 fc47 	bl	239d4 <ull_filter_adv_scan_state_cb>
{
   1e146:	464c      	mov	r4, r9
   1e148:	e798      	b.n	1e07c <ll_rx_mem_release+0x10>
			LL_ASSERT(rx_free->type != NODE_RX_TYPE_NONE);
   1e14a:	b942      	cbnz	r2, 1e15e <ll_rx_mem_release+0xf2>
   1e14c:	4640      	mov	r0, r8
   1e14e:	f009 fff9 	bl	28144 <printk>
   1e152:	4040      	eors	r0, r0
   1e154:	f380 8811 	msr	BASEPRI, r0
   1e158:	f04f 0003 	mov.w	r0, #3
   1e15c:	df02      	svc	2
			ll_rx_link_inc_quota(1);
   1e15e:	2001      	movs	r0, #1
   1e160:	f7ff fc9e 	bl	1daa0 <ll_rx_link_inc_quota>
			mem_release(rx_free, &mem_pdu_rx.free);
   1e164:	4639      	mov	r1, r7
   1e166:	4620      	mov	r0, r4
   1e168:	f00d fbfb 	bl	2b962 <mem_release>
			break;
   1e16c:	e7eb      	b.n	1e146 <ll_rx_mem_release+0xda>
			conn = ll_conn_get(rx_free->handle);
   1e16e:	88e0      	ldrh	r0, [r4, #6]
   1e170:	f002 fa0e 	bl	20590 <ll_conn_get>
			LL_ASSERT(!conn->lll.link_tx_free);
   1e174:	6f83      	ldr	r3, [r0, #120]	; 0x78
			conn = ll_conn_get(rx_free->handle);
   1e176:	4604      	mov	r4, r0
			LL_ASSERT(!conn->lll.link_tx_free);
   1e178:	b143      	cbz	r3, 1e18c <ll_rx_mem_release+0x120>
   1e17a:	481b      	ldr	r0, [pc, #108]	; (1e1e8 <ll_rx_mem_release+0x17c>)
   1e17c:	f009 ffe2 	bl	28144 <printk>
   1e180:	4040      	eors	r0, r0
   1e182:	f380 8811 	msr	BASEPRI, r0
   1e186:	f04f 0003 	mov.w	r0, #3
   1e18a:	df02      	svc	2
			link = memq_deinit(&conn->lll.memq_tx.head,
   1e18c:	f104 016c 	add.w	r1, r4, #108	; 0x6c
   1e190:	f104 0068 	add.w	r0, r4, #104	; 0x68
   1e194:	f00d fc1f 	bl	2b9d6 <memq_deinit>
			LL_ASSERT(link);
   1e198:	4682      	mov	sl, r0
   1e19a:	b940      	cbnz	r0, 1e1ae <ll_rx_mem_release+0x142>
   1e19c:	4811      	ldr	r0, [pc, #68]	; (1e1e4 <ll_rx_mem_release+0x178>)
   1e19e:	f009 ffd1 	bl	28144 <printk>
   1e1a2:	4040      	eors	r0, r0
   1e1a4:	f380 8811 	msr	BASEPRI, r0
   1e1a8:	f04f 0003 	mov.w	r0, #3
   1e1ac:	df02      	svc	2
			conn->lll.link_tx_free = link;
   1e1ae:	f8c4 a078 	str.w	sl, [r4, #120]	; 0x78
			ll_conn_release(conn);
   1e1b2:	4620      	mov	r0, r4
   1e1b4:	f002 f9de 	bl	20574 <ll_conn_release>
		break;
   1e1b8:	e7c5      	b.n	1e146 <ll_rx_mem_release+0xda>
			LL_ASSERT(0);
   1e1ba:	4630      	mov	r0, r6
   1e1bc:	f009 ffc2 	bl	28144 <printk>
   1e1c0:	4040      	eors	r0, r0
   1e1c2:	f380 8811 	msr	BASEPRI, r0
   1e1c6:	f04f 0003 	mov.w	r0, #3
   1e1ca:	df02      	svc	2
			break;
   1e1cc:	e7bb      	b.n	1e146 <ll_rx_mem_release+0xda>
   1e1ce:	bf00      	nop
   1e1d0:	000314f5 	.word	0x000314f5
   1e1d4:	20001fec 	.word	0x20001fec
   1e1d8:	00031685 	.word	0x00031685
   1e1dc:	0003172c 	.word	0x0003172c
   1e1e0:	00031747 	.word	0x00031747
   1e1e4:	00031657 	.word	0x00031657
   1e1e8:	000317a6 	.word	0x000317a6
   1e1ec:	00031771 	.word	0x00031771

0001e1f0 <ll_rx_link_alloc>:
	return mem_acquire(&mem_link_rx.free);
   1e1f0:	4801      	ldr	r0, [pc, #4]	; (1e1f8 <ll_rx_link_alloc+0x8>)
   1e1f2:	f00d bb9d 	b.w	2b930 <mem_acquire>
   1e1f6:	bf00      	nop
   1e1f8:	20001f78 	.word	0x20001f78

0001e1fc <ll_rx_link_release>:
	mem_release(link, &mem_link_rx.free);
   1e1fc:	4901      	ldr	r1, [pc, #4]	; (1e204 <ll_rx_link_release+0x8>)
   1e1fe:	f00d bbb0 	b.w	2b962 <mem_release>
   1e202:	bf00      	nop
   1e204:	20001f78 	.word	0x20001f78

0001e208 <ll_rx_alloc>:
	return mem_acquire(&mem_pdu_rx.free);
   1e208:	4801      	ldr	r0, [pc, #4]	; (1e210 <ll_rx_alloc+0x8>)
   1e20a:	f00d bb91 	b.w	2b930 <mem_acquire>
   1e20e:	bf00      	nop
   1e210:	20001fec 	.word	0x20001fec

0001e214 <ll_rx_release>:
	mem_release(node_rx, &mem_pdu_rx.free);
   1e214:	4901      	ldr	r1, [pc, #4]	; (1e21c <ll_rx_release+0x8>)
   1e216:	f00d bba4 	b.w	2b962 <mem_release>
   1e21a:	bf00      	nop
   1e21c:	20001fec 	.word	0x20001fec

0001e220 <ll_rx_dequeue>:
{
   1e220:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
   1e222:	4945      	ldr	r1, [pc, #276]	; (1e338 <ll_rx_dequeue+0x118>)
	struct node_rx_hdr *rx = NULL;
   1e224:	2300      	movs	r3, #0
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
   1e226:	aa01      	add	r2, sp, #4
   1e228:	6848      	ldr	r0, [r1, #4]
	struct node_rx_hdr *rx = NULL;
   1e22a:	9301      	str	r3, [sp, #4]
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
   1e22c:	f00d fbed 	bl	2ba0a <memq_dequeue>
	LL_ASSERT(link);
   1e230:	4604      	mov	r4, r0
   1e232:	b940      	cbnz	r0, 1e246 <ll_rx_dequeue+0x26>
   1e234:	4841      	ldr	r0, [pc, #260]	; (1e33c <ll_rx_dequeue+0x11c>)
   1e236:	f009 ff85 	bl	28144 <printk>
   1e23a:	4040      	eors	r0, r0
   1e23c:	f380 8811 	msr	BASEPRI, r0
   1e240:	f04f 0003 	mov.w	r0, #3
   1e244:	df02      	svc	2
	mem_release(link, &mem_link_rx.free);
   1e246:	493e      	ldr	r1, [pc, #248]	; (1e340 <ll_rx_dequeue+0x120>)
   1e248:	4620      	mov	r0, r4
   1e24a:	f00d fb8a 	bl	2b962 <mem_release>
	switch (rx->type) {
   1e24e:	9901      	ldr	r1, [sp, #4]
   1e250:	7908      	ldrb	r0, [r1, #4]
   1e252:	280e      	cmp	r0, #14
   1e254:	d86e      	bhi.n	1e334 <ll_rx_dequeue+0x114>
   1e256:	2301      	movs	r3, #1
   1e258:	4083      	lsls	r3, r0
   1e25a:	f647 6215 	movw	r2, #32277	; 0x7e15
   1e25e:	401a      	ands	r2, r3
   1e260:	d15c      	bne.n	1e31c <ll_rx_dequeue+0xfc>
   1e262:	05db      	lsls	r3, r3, #23
   1e264:	d566      	bpl.n	1e334 <ll_rx_dequeue+0x114>
		} else if ((cc->status == BT_HCI_ERR_ADV_TIMEOUT) || cc->role) {
   1e266:	f891 3020 	ldrb.w	r3, [r1, #32]
   1e26a:	688e      	ldr	r6, [r1, #8]
   1e26c:	2b3c      	cmp	r3, #60	; 0x3c
   1e26e:	6834      	ldr	r4, [r6, #0]
   1e270:	d00a      	beq.n	1e288 <ll_rx_dequeue+0x68>
   1e272:	f891 1021 	ldrb.w	r1, [r1, #33]	; 0x21
   1e276:	2900      	cmp	r1, #0
   1e278:	d147      	bne.n	1e30a <ll_rx_dequeue+0xea>
			scan->is_enabled = 0U;
   1e27a:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
   1e27e:	f361 0300 	bfi	r3, r1, #0, #1
   1e282:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
   1e286:	e032      	b.n	1e2ee <ll_rx_dequeue+0xce>
				conn_lll = lll->conn;
   1e288:	68b5      	ldr	r5, [r6, #8]
				LL_ASSERT(conn_lll);
   1e28a:	b945      	cbnz	r5, 1e29e <ll_rx_dequeue+0x7e>
   1e28c:	482d      	ldr	r0, [pc, #180]	; (1e344 <ll_rx_dequeue+0x124>)
   1e28e:	f009 ff59 	bl	28144 <printk>
   1e292:	4040      	eors	r0, r0
   1e294:	f380 8811 	msr	BASEPRI, r0
   1e298:	f04f 0003 	mov.w	r0, #3
   1e29c:	df02      	svc	2
				LL_ASSERT(!conn_lll->link_tx_free);
   1e29e:	6deb      	ldr	r3, [r5, #92]	; 0x5c
   1e2a0:	b143      	cbz	r3, 1e2b4 <ll_rx_dequeue+0x94>
   1e2a2:	4829      	ldr	r0, [pc, #164]	; (1e348 <ll_rx_dequeue+0x128>)
   1e2a4:	f009 ff4e 	bl	28144 <printk>
   1e2a8:	4040      	eors	r0, r0
   1e2aa:	f380 8811 	msr	BASEPRI, r0
   1e2ae:	f04f 0003 	mov.w	r0, #3
   1e2b2:	df02      	svc	2
				link = memq_deinit(&conn_lll->memq_tx.head,
   1e2b4:	f105 0150 	add.w	r1, r5, #80	; 0x50
   1e2b8:	f105 004c 	add.w	r0, r5, #76	; 0x4c
   1e2bc:	f00d fb8b 	bl	2b9d6 <memq_deinit>
				LL_ASSERT(link);
   1e2c0:	4607      	mov	r7, r0
   1e2c2:	b940      	cbnz	r0, 1e2d6 <ll_rx_dequeue+0xb6>
   1e2c4:	481d      	ldr	r0, [pc, #116]	; (1e33c <ll_rx_dequeue+0x11c>)
   1e2c6:	f009 ff3d 	bl	28144 <printk>
   1e2ca:	4040      	eors	r0, r0
   1e2cc:	f380 8811 	msr	BASEPRI, r0
   1e2d0:	f04f 0003 	mov.w	r0, #3
   1e2d4:	df02      	svc	2
				conn_lll->link_tx_free = link;
   1e2d6:	65ef      	str	r7, [r5, #92]	; 0x5c
				ll_conn_release(conn);
   1e2d8:	6828      	ldr	r0, [r5, #0]
   1e2da:	f002 f94b 	bl	20574 <ll_conn_release>
				lll->conn = NULL;
   1e2de:	2300      	movs	r3, #0
   1e2e0:	60b3      	str	r3, [r6, #8]
			adv->is_enabled = 0U;
   1e2e2:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
   1e2e6:	f36f 0300 	bfc	r3, #0, #1
   1e2ea:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
			      ull_scan_is_enabled(0) << 1) |
   1e2ee:	2000      	movs	r0, #0
   1e2f0:	f00d fee3 	bl	2c0ba <ull_scan_is_enabled>
   1e2f4:	4604      	mov	r4, r0
			      ull_adv_is_enabled(0));
   1e2f6:	2000      	movs	r0, #0
   1e2f8:	f00d fdef 	bl	2beda <ull_adv_is_enabled>
			if (!bm) {
   1e2fc:	ea50 0044 	orrs.w	r0, r0, r4, lsl #1
   1e300:	d101      	bne.n	1e306 <ll_rx_dequeue+0xe6>
				ull_filter_adv_scan_state_cb(0);
   1e302:	f005 fb67 	bl	239d4 <ull_filter_adv_scan_state_cb>
}
   1e306:	b003      	add	sp, #12
   1e308:	bdf0      	pop	{r4, r5, r6, r7, pc}
				if (adv->node_rx_cc_free) {
   1e30a:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
   1e30e:	2800      	cmp	r0, #0
   1e310:	d0e7      	beq.n	1e2e2 <ll_rx_dequeue+0xc2>
					adv->node_rx_cc_free = NULL;
   1e312:	f8c4 20d4 	str.w	r2, [r4, #212]	; 0xd4
					ll_rx_release(rx_free);
   1e316:	f7ff ff7d 	bl	1e214 <ll_rx_release>
   1e31a:	e7e2      	b.n	1e2e2 <ll_rx_dequeue+0xc2>
		LL_ASSERT(rx->type != NODE_RX_TYPE_NONE);
   1e31c:	2800      	cmp	r0, #0
   1e31e:	d1f2      	bne.n	1e306 <ll_rx_dequeue+0xe6>
   1e320:	480a      	ldr	r0, [pc, #40]	; (1e34c <ll_rx_dequeue+0x12c>)
		LL_ASSERT(0);
   1e322:	f009 ff0f 	bl	28144 <printk>
   1e326:	4040      	eors	r0, r0
   1e328:	f380 8811 	msr	BASEPRI, r0
   1e32c:	f04f 0003 	mov.w	r0, #3
   1e330:	df02      	svc	2
}
   1e332:	e7e8      	b.n	1e306 <ll_rx_dequeue+0xe6>
		LL_ASSERT(0);
   1e334:	4806      	ldr	r0, [pc, #24]	; (1e350 <ll_rx_dequeue+0x130>)
   1e336:	e7f4      	b.n	1e322 <ll_rx_dequeue+0x102>
   1e338:	2000229c 	.word	0x2000229c
   1e33c:	00031657 	.word	0x00031657
   1e340:	20001f78 	.word	0x20001f78
   1e344:	0003172c 	.word	0x0003172c
   1e348:	00031747 	.word	0x00031747
   1e34c:	000316b6 	.word	0x000316b6
   1e350:	000314f5 	.word	0x000314f5

0001e354 <ll_rx_put>:
	rx_hdr->ack_last = mfifo_tx_ack.l;
   1e354:	4b02      	ldr	r3, [pc, #8]	; (1e360 <ll_rx_put+0xc>)
	memq_enqueue(link, rx, &memq_ll_rx.tail);
   1e356:	4a03      	ldr	r2, [pc, #12]	; (1e364 <ll_rx_put+0x10>)
	rx_hdr->ack_last = mfifo_tx_ack.l;
   1e358:	78db      	ldrb	r3, [r3, #3]
   1e35a:	700b      	strb	r3, [r1, #0]
	memq_enqueue(link, rx, &memq_ll_rx.tail);
   1e35c:	f00d bb46 	b.w	2b9ec <memq_enqueue>
   1e360:	2000fc14 	.word	0x2000fc14
   1e364:	200022a0 	.word	0x200022a0

0001e368 <ll_rx_sched>:
	k_sem_give(sem_recv);
   1e368:	4b01      	ldr	r3, [pc, #4]	; (1e370 <ll_rx_sched+0x8>)
   1e36a:	6818      	ldr	r0, [r3, #0]
	z_impl_k_sem_give(sem);
   1e36c:	f008 becc 	b.w	27108 <z_impl_k_sem_give>
   1e370:	200022ac 	.word	0x200022ac

0001e374 <ll_pdu_rx_alloc_peek>:
{
   1e374:	b510      	push	{r4, lr}
	if (count > MFIFO_AVAIL_COUNT_GET(ll_pdu_rx_free)) {
   1e376:	4a0a      	ldr	r2, [pc, #40]	; (1e3a0 <ll_pdu_rx_alloc_peek+0x2c>)
   1e378:	7891      	ldrb	r1, [r2, #2]
   1e37a:	78d4      	ldrb	r4, [r2, #3]
   1e37c:	7853      	ldrb	r3, [r2, #1]
	if (last >= first) {
   1e37e:	42a1      	cmp	r1, r4
		return count - first + last;
   1e380:	bf8a      	itet	hi
   1e382:	1a5b      	subhi	r3, r3, r1
		return last - first;
   1e384:	1a63      	subls	r3, r4, r1
		return count - first + last;
   1e386:	191b      	addhi	r3, r3, r4
   1e388:	b2db      	uxtb	r3, r3
   1e38a:	4298      	cmp	r0, r3
   1e38c:	d806      	bhi.n	1e39c <ll_pdu_rx_alloc_peek+0x28>
	if (first == last) {
   1e38e:	42a1      	cmp	r1, r4
	return MFIFO_DEQUEUE_PEEK(ll_pdu_rx_free);
   1e390:	7813      	ldrb	r3, [r2, #0]
   1e392:	d003      	beq.n	1e39c <ll_pdu_rx_alloc_peek+0x28>
	return *((void **)(fifo + first * size));
   1e394:	fb01 2203 	mla	r2, r1, r3, r2
   1e398:	6850      	ldr	r0, [r2, #4]
}
   1e39a:	bd10      	pop	{r4, pc}
		return NULL;
   1e39c:	2000      	movs	r0, #0
   1e39e:	e7fc      	b.n	1e39a <ll_pdu_rx_alloc_peek+0x26>
   1e3a0:	2000fac4 	.word	0x2000fac4

0001e3a4 <ll_pdu_rx_alloc>:
{
   1e3a4:	b510      	push	{r4, lr}
	return MFIFO_DEQUEUE(ll_pdu_rx_free);
   1e3a6:	4a09      	ldr	r2, [pc, #36]	; (1e3cc <ll_pdu_rx_alloc+0x28>)
 * @return              Head buffer; or NULL if queue was empty
 */
static inline void *mfifo_dequeue(u8_t *fifo, u8_t size, u8_t count,
				  u8_t last, u8_t *first)
{
	u8_t _first = *first; /* Copy read-index */
   1e3a8:	7893      	ldrb	r3, [r2, #2]
	void *mem;

	/* Queue is empty if first == last */
	if (_first == last) {
   1e3aa:	78d0      	ldrb	r0, [r2, #3]
   1e3ac:	7811      	ldrb	r1, [r2, #0]
   1e3ae:	7854      	ldrb	r4, [r2, #1]
   1e3b0:	4298      	cmp	r0, r3
   1e3b2:	d009      	beq.n	1e3c8 <ll_pdu_rx_alloc+0x24>
	}

	/* Obtain address of head buffer.
	 * API 2: fifo is array of void-ptrs
	 */
	mem = *((void **)(fifo + _first * size));
   1e3b4:	fb03 2101 	mla	r1, r3, r1, r2

	/* Circular buffer increment read-index modulo 'count' */
	_first += 1U;
   1e3b8:	3301      	adds	r3, #1
   1e3ba:	b2db      	uxtb	r3, r3
	if (_first == count) {
		_first = 0U;
   1e3bc:	429c      	cmp	r4, r3
   1e3be:	bf08      	it	eq
   1e3c0:	2300      	moveq	r3, #0
	mem = *((void **)(fifo + _first * size));
   1e3c2:	6848      	ldr	r0, [r1, #4]
	}

	*first = _first; /* Write back read-index */
   1e3c4:	7093      	strb	r3, [r2, #2]
}
   1e3c6:	bd10      	pop	{r4, pc}
		return NULL;
   1e3c8:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(ll_pdu_rx_free);
   1e3ca:	e7fc      	b.n	1e3c6 <ll_pdu_rx_alloc+0x22>
   1e3cc:	2000fac4 	.word	0x2000fac4

0001e3d0 <ll_tx_ack_put>:
{
   1e3d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	idx = MFIFO_ENQUEUE_GET(tx_ack, (void **)&tx);
   1e3d2:	4a10      	ldr	r2, [pc, #64]	; (1e414 <ll_tx_ack_put+0x44>)
   1e3d4:	78d4      	ldrb	r4, [r2, #3]
	if (last == count) {
   1e3d6:	7857      	ldrb	r7, [r2, #1]
   1e3d8:	7895      	ldrb	r5, [r2, #2]
   1e3da:	7816      	ldrb	r6, [r2, #0]
	last = last + 1;
   1e3dc:	1c63      	adds	r3, r4, #1
   1e3de:	b2db      	uxtb	r3, r3
		last = 0U;
   1e3e0:	429f      	cmp	r7, r3
   1e3e2:	bf08      	it	eq
   1e3e4:	2300      	moveq	r3, #0
	if (last == first) {
   1e3e6:	429d      	cmp	r5, r3
   1e3e8:	d004      	beq.n	1e3f4 <ll_tx_ack_put+0x24>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   1e3ea:	1d15      	adds	r5, r2, #4
   1e3ec:	fb14 f406 	smulbb	r4, r4, r6
	LL_ASSERT(tx);
   1e3f0:	192e      	adds	r6, r5, r4
   1e3f2:	d10b      	bne.n	1e40c <ll_tx_ack_put+0x3c>
   1e3f4:	4808      	ldr	r0, [pc, #32]	; (1e418 <ll_tx_ack_put+0x48>)
   1e3f6:	f009 fea5 	bl	28144 <printk>
   1e3fa:	4040      	eors	r0, r0
   1e3fc:	f380 8811 	msr	BASEPRI, r0
   1e400:	f04f 0003 	mov.w	r0, #3
   1e404:	df02      	svc	2
	tx->handle = handle;
   1e406:	2300      	movs	r3, #0
   1e408:	801b      	strh	r3, [r3, #0]
   1e40a:	deff      	udf	#255	; 0xff
   1e40c:	5328      	strh	r0, [r5, r4]
	*last = idx; /* Commit: Update write index */
   1e40e:	70d3      	strb	r3, [r2, #3]
	tx->node = node_tx;
   1e410:	6071      	str	r1, [r6, #4]
}
   1e412:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1e414:	2000fc14 	.word	0x2000fc14
   1e418:	000317d0 	.word	0x000317d0

0001e41c <ll_radio_state_abort>:
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL, 0,
   1e41c:	2200      	movs	r2, #0
{
   1e41e:	b508      	push	{r3, lr}
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL, 0,
   1e420:	4611      	mov	r1, r2
   1e422:	4b07      	ldr	r3, [pc, #28]	; (1e440 <ll_radio_state_abort+0x24>)
   1e424:	2001      	movs	r0, #1
   1e426:	f7fd f9d5 	bl	1b7d4 <mayfly_enqueue>
	LL_ASSERT(!ret);
   1e42a:	b140      	cbz	r0, 1e43e <ll_radio_state_abort+0x22>
   1e42c:	4805      	ldr	r0, [pc, #20]	; (1e444 <ll_radio_state_abort+0x28>)
   1e42e:	f009 fe89 	bl	28144 <printk>
   1e432:	4040      	eors	r0, r0
   1e434:	f380 8811 	msr	BASEPRI, r0
   1e438:	f04f 0003 	mov.w	r0, #3
   1e43c:	df02      	svc	2
}
   1e43e:	bd08      	pop	{r3, pc}
   1e440:	2000fc48 	.word	0x2000fc48
   1e444:	0003166e 	.word	0x0003166e

0001e448 <ull_ticker_status_give>:
	*((u32_t volatile *)param) = status;
   1e448:	6008      	str	r0, [r1, #0]
   1e44a:	4801      	ldr	r0, [pc, #4]	; (1e450 <ull_ticker_status_give+0x8>)
   1e44c:	f008 be5c 	b.w	27108 <z_impl_k_sem_give>
   1e450:	200022b0 	.word	0x200022b0

0001e454 <ull_ticker_status_take>:
{
   1e454:	b510      	push	{r4, lr}
   1e456:	460c      	mov	r4, r1
	return z_impl_k_sem_take(sem, timeout);
   1e458:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1e45c:	4802      	ldr	r0, [pc, #8]	; (1e468 <ull_ticker_status_take+0x14>)
   1e45e:	f008 fe7f 	bl	27160 <z_impl_k_sem_take>
	return *ret_cb;
   1e462:	6820      	ldr	r0, [r4, #0]
}
   1e464:	bd10      	pop	{r4, pc}
   1e466:	bf00      	nop
   1e468:	200022b0 	.word	0x200022b0

0001e46c <ull_disable_mark>:
	if (!*m) {
   1e46c:	4b02      	ldr	r3, [pc, #8]	; (1e478 <ull_disable_mark+0xc>)
   1e46e:	681a      	ldr	r2, [r3, #0]
   1e470:	b902      	cbnz	r2, 1e474 <ull_disable_mark+0x8>
		*m = param;
   1e472:	6018      	str	r0, [r3, #0]
}
   1e474:	6818      	ldr	r0, [r3, #0]
   1e476:	4770      	bx	lr
   1e478:	20001ea4 	.word	0x20001ea4

0001e47c <ull_disable_unmark>:
	if (*m && *m == param) {
   1e47c:	4905      	ldr	r1, [pc, #20]	; (1e494 <ull_disable_unmark+0x18>)
   1e47e:	680b      	ldr	r3, [r1, #0]
   1e480:	b12b      	cbz	r3, 1e48e <ull_disable_unmark+0x12>
   1e482:	4298      	cmp	r0, r3
   1e484:	f04f 0200 	mov.w	r2, #0
		*m = NULL;
   1e488:	bf0c      	ite	eq
   1e48a:	600a      	streq	r2, [r1, #0]
	return NULL;
   1e48c:	4613      	movne	r3, r2
}
   1e48e:	4618      	mov	r0, r3
   1e490:	4770      	bx	lr
   1e492:	bf00      	nop
   1e494:	20001ea4 	.word	0x20001ea4

0001e498 <ull_disable_mark_get>:
}
   1e498:	4b01      	ldr	r3, [pc, #4]	; (1e4a0 <ull_disable_mark_get+0x8>)
   1e49a:	6818      	ldr	r0, [r3, #0]
   1e49c:	4770      	bx	lr
   1e49e:	bf00      	nop
   1e4a0:	20001ea4 	.word	0x20001ea4

0001e4a4 <ull_update_mark>:
	if (!*m) {
   1e4a4:	4b02      	ldr	r3, [pc, #8]	; (1e4b0 <ull_update_mark+0xc>)
   1e4a6:	681a      	ldr	r2, [r3, #0]
   1e4a8:	b902      	cbnz	r2, 1e4ac <ull_update_mark+0x8>
		*m = param;
   1e4aa:	6018      	str	r0, [r3, #0]
}
   1e4ac:	6818      	ldr	r0, [r3, #0]
   1e4ae:	4770      	bx	lr
   1e4b0:	20001ea8 	.word	0x20001ea8

0001e4b4 <ull_update_unmark>:
	if (*m && *m == param) {
   1e4b4:	4905      	ldr	r1, [pc, #20]	; (1e4cc <ull_update_unmark+0x18>)
   1e4b6:	680b      	ldr	r3, [r1, #0]
   1e4b8:	b12b      	cbz	r3, 1e4c6 <ull_update_unmark+0x12>
   1e4ba:	4298      	cmp	r0, r3
   1e4bc:	f04f 0200 	mov.w	r2, #0
		*m = NULL;
   1e4c0:	bf0c      	ite	eq
   1e4c2:	600a      	streq	r2, [r1, #0]
	return NULL;
   1e4c4:	4613      	movne	r3, r2
}
   1e4c6:	4618      	mov	r0, r3
   1e4c8:	4770      	bx	lr
   1e4ca:	bf00      	nop
   1e4cc:	20001ea8 	.word	0x20001ea8

0001e4d0 <ull_update_mark_get>:
}
   1e4d0:	4b01      	ldr	r3, [pc, #4]	; (1e4d8 <ull_update_mark_get+0x8>)
   1e4d2:	6818      	ldr	r0, [r3, #0]
   1e4d4:	4770      	bx	lr
   1e4d6:	bf00      	nop
   1e4d8:	20001ea8 	.word	0x20001ea8

0001e4dc <ull_disable>:
{
   1e4dc:	b530      	push	{r4, r5, lr}
	hdr = HDR_ULL(((struct lll_hdr *)lll)->parent);
   1e4de:	6804      	ldr	r4, [r0, #0]
{
   1e4e0:	4605      	mov	r5, r0
	if (!hdr || !hdr->ref) {
   1e4e2:	f114 0010 	adds.w	r0, r4, #16
{
   1e4e6:	b087      	sub	sp, #28
	if (!hdr || !hdr->ref) {
   1e4e8:	d020      	beq.n	1e52c <ull_disable+0x50>
   1e4ea:	7c20      	ldrb	r0, [r4, #16]
   1e4ec:	b1f0      	cbz	r0, 1e52c <ull_disable+0x50>
	z_impl_k_sem_init(sem, initial_count, limit);
   1e4ee:	2201      	movs	r2, #1
   1e4f0:	2100      	movs	r1, #0
   1e4f2:	4668      	mov	r0, sp
   1e4f4:	f00e ff87 	bl	2d406 <z_impl_k_sem_init>
	hdr->disabled_cb = disabled_cb;
   1e4f8:	4b0d      	ldr	r3, [pc, #52]	; (1e530 <ull_disable+0x54>)
   1e4fa:	6163      	str	r3, [r4, #20]
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
   1e4fc:	2200      	movs	r2, #0
	mfy.param = lll;
   1e4fe:	4b0d      	ldr	r3, [pc, #52]	; (1e534 <ull_disable+0x58>)
	hdr->disabled_param = &sem;
   1e500:	f8c4 d018 	str.w	sp, [r4, #24]
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
   1e504:	4611      	mov	r1, r2
   1e506:	2003      	movs	r0, #3
	mfy.param = lll;
   1e508:	609d      	str	r5, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
   1e50a:	f7fd f963 	bl	1b7d4 <mayfly_enqueue>
	LL_ASSERT(!ret);
   1e50e:	b140      	cbz	r0, 1e522 <ull_disable+0x46>
   1e510:	4809      	ldr	r0, [pc, #36]	; (1e538 <ull_disable+0x5c>)
   1e512:	f009 fe17 	bl	28144 <printk>
   1e516:	4040      	eors	r0, r0
   1e518:	f380 8811 	msr	BASEPRI, r0
   1e51c:	f04f 0003 	mov.w	r0, #3
   1e520:	df02      	svc	2
	return z_impl_k_sem_take(sem, timeout);
   1e522:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1e526:	4668      	mov	r0, sp
   1e528:	f008 fe1a 	bl	27160 <z_impl_k_sem_take>
}
   1e52c:	b007      	add	sp, #28
   1e52e:	bd30      	pop	{r4, r5, pc}
   1e530:	0002bd77 	.word	0x0002bd77
   1e534:	2000fc58 	.word	0x2000fc58
   1e538:	0003166e 	.word	0x0003166e

0001e53c <ull_pdu_rx_alloc_peek>:
{
   1e53c:	b510      	push	{r4, lr}
	if (count > MFIFO_AVAIL_COUNT_GET(pdu_rx_free)) {
   1e53e:	4a0a      	ldr	r2, [pc, #40]	; (1e568 <ull_pdu_rx_alloc_peek+0x2c>)
   1e540:	7891      	ldrb	r1, [r2, #2]
   1e542:	78d4      	ldrb	r4, [r2, #3]
   1e544:	7853      	ldrb	r3, [r2, #1]
	if (last >= first) {
   1e546:	42a1      	cmp	r1, r4
		return count - first + last;
   1e548:	bf8a      	itet	hi
   1e54a:	1a5b      	subhi	r3, r3, r1
		return last - first;
   1e54c:	1a63      	subls	r3, r4, r1
		return count - first + last;
   1e54e:	191b      	addhi	r3, r3, r4
   1e550:	b2db      	uxtb	r3, r3
   1e552:	4298      	cmp	r0, r3
   1e554:	d806      	bhi.n	1e564 <ull_pdu_rx_alloc_peek+0x28>
	if (first == last) {
   1e556:	42a1      	cmp	r1, r4
	return MFIFO_DEQUEUE_PEEK(pdu_rx_free);
   1e558:	7813      	ldrb	r3, [r2, #0]
   1e55a:	d003      	beq.n	1e564 <ull_pdu_rx_alloc_peek+0x28>
	return *((void **)(fifo + first * size));
   1e55c:	fb01 2203 	mla	r2, r1, r3, r2
   1e560:	6850      	ldr	r0, [r2, #4]
}
   1e562:	bd10      	pop	{r4, pc}
		return NULL;
   1e564:	2000      	movs	r0, #0
   1e566:	e7fc      	b.n	1e562 <ull_pdu_rx_alloc_peek+0x26>
   1e568:	2000fad8 	.word	0x2000fad8

0001e56c <ull_pdu_rx_alloc>:
{
   1e56c:	b510      	push	{r4, lr}
	return MFIFO_DEQUEUE(pdu_rx_free);
   1e56e:	4a09      	ldr	r2, [pc, #36]	; (1e594 <ull_pdu_rx_alloc+0x28>)
	u8_t _first = *first; /* Copy read-index */
   1e570:	7893      	ldrb	r3, [r2, #2]
	if (_first == last) {
   1e572:	78d0      	ldrb	r0, [r2, #3]
   1e574:	7811      	ldrb	r1, [r2, #0]
   1e576:	7854      	ldrb	r4, [r2, #1]
   1e578:	4298      	cmp	r0, r3
   1e57a:	d009      	beq.n	1e590 <ull_pdu_rx_alloc+0x24>
	mem = *((void **)(fifo + _first * size));
   1e57c:	fb03 2101 	mla	r1, r3, r1, r2
	_first += 1U;
   1e580:	3301      	adds	r3, #1
   1e582:	b2db      	uxtb	r3, r3
		_first = 0U;
   1e584:	429c      	cmp	r4, r3
   1e586:	bf08      	it	eq
   1e588:	2300      	moveq	r3, #0
	mem = *((void **)(fifo + _first * size));
   1e58a:	6848      	ldr	r0, [r1, #4]
	*first = _first; /* Write back read-index */
   1e58c:	7093      	strb	r3, [r2, #2]
}
   1e58e:	bd10      	pop	{r4, pc}
		return NULL;
   1e590:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(pdu_rx_free);
   1e592:	e7fc      	b.n	1e58e <ull_pdu_rx_alloc+0x22>
   1e594:	2000fad8 	.word	0x2000fad8

0001e598 <ull_rx_put>:
{
   1e598:	b538      	push	{r3, r4, r5, lr}
   1e59a:	460c      	mov	r4, r1
   1e59c:	4605      	mov	r5, r0
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
   1e59e:	f003 fe79 	bl	22294 <ull_conn_ack_last_idx_get>
	memq_enqueue(link, rx, &memq_ull_rx.tail);
   1e5a2:	4621      	mov	r1, r4
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
   1e5a4:	7020      	strb	r0, [r4, #0]
	memq_enqueue(link, rx, &memq_ull_rx.tail);
   1e5a6:	4a03      	ldr	r2, [pc, #12]	; (1e5b4 <ull_rx_put+0x1c>)
   1e5a8:	4628      	mov	r0, r5
}
   1e5aa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	memq_enqueue(link, rx, &memq_ull_rx.tail);
   1e5ae:	f00d ba1d 	b.w	2b9ec <memq_enqueue>
   1e5b2:	bf00      	nop
   1e5b4:	200022a8 	.word	0x200022a8

0001e5b8 <ull_rx_sched>:
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
   1e5b8:	2201      	movs	r2, #1
   1e5ba:	4b02      	ldr	r3, [pc, #8]	; (1e5c4 <ull_rx_sched+0xc>)
   1e5bc:	4611      	mov	r1, r2
   1e5be:	2000      	movs	r0, #0
   1e5c0:	f7fd b908 	b.w	1b7d4 <mayfly_enqueue>
   1e5c4:	2000fc68 	.word	0x2000fc68

0001e5c8 <ull_prepare_enqueue>:
{
   1e5c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
   1e5cc:	4e16      	ldr	r6, [pc, #88]	; (1e628 <ull_prepare_enqueue+0x60>)
{
   1e5ce:	460f      	mov	r7, r1
   1e5d0:	4611      	mov	r1, r2
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
   1e5d2:	78f2      	ldrb	r2, [r6, #3]
   1e5d4:	7834      	ldrb	r4, [r6, #0]
{
   1e5d6:	4680      	mov	r8, r0
	last = last + 1;
   1e5d8:	1c55      	adds	r5, r2, #1
	if (last == count) {
   1e5da:	7870      	ldrb	r0, [r6, #1]
   1e5dc:	4699      	mov	r9, r3
	last = last + 1;
   1e5de:	b2ed      	uxtb	r5, r5
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
   1e5e0:	78b3      	ldrb	r3, [r6, #2]
		last = 0U;
   1e5e2:	42a8      	cmp	r0, r5
   1e5e4:	bf08      	it	eq
   1e5e6:	2500      	moveq	r5, #0
	if (last == first) {
   1e5e8:	42ab      	cmp	r3, r5
   1e5ea:	d01a      	beq.n	1e622 <ull_prepare_enqueue+0x5a>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   1e5ec:	1d33      	adds	r3, r6, #4
   1e5ee:	fb02 3404 	mla	r4, r2, r4, r3
	if (!e) {
   1e5f2:	b1b4      	cbz	r4, 1e622 <ull_prepare_enqueue+0x5a>
	memcpy(&e->prepare_param, prepare_param, sizeof(e->prepare_param));
   1e5f4:	2210      	movs	r2, #16
   1e5f6:	4620      	mov	r0, r4
   1e5f8:	f00b ff29 	bl	2a44e <memcpy>
	e->prio = prio;
   1e5fc:	9b08      	ldr	r3, [sp, #32]
   1e5fe:	61e3      	str	r3, [r4, #28]
	e->is_resume = is_resume;
   1e600:	f89d 2024 	ldrb.w	r2, [sp, #36]	; 0x24
   1e604:	f894 3020 	ldrb.w	r3, [r4, #32]
	e->abort_cb = abort_cb;
   1e608:	61a7      	str	r7, [r4, #24]
	e->is_resume = is_resume;
   1e60a:	f362 0300 	bfi	r3, r2, #0, #1
	e->is_abort_cb = is_abort_cb;
   1e60e:	e9c4 9804 	strd	r9, r8, [r4, #16]
	e->is_aborted = 0U;
   1e612:	f36f 0341 	bfc	r3, #1, #1
   1e616:	f884 3020 	strb.w	r3, [r4, #32]
	*last = idx; /* Commit: Update write index */
   1e61a:	70f5      	strb	r5, [r6, #3]
	return 0;
   1e61c:	2000      	movs	r0, #0
}
   1e61e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return -ENOBUFS;
   1e622:	f06f 0036 	mvn.w	r0, #54	; 0x36
   1e626:	e7fa      	b.n	1e61e <ull_prepare_enqueue+0x56>
   1e628:	2000faf0 	.word	0x2000faf0

0001e62c <ull_prepare_dequeue_get>:
	return MFIFO_DEQUEUE_GET(prep);
   1e62c:	4b05      	ldr	r3, [pc, #20]	; (1e644 <ull_prepare_dequeue_get+0x18>)
   1e62e:	789a      	ldrb	r2, [r3, #2]
	if (first == last) {
   1e630:	78d9      	ldrb	r1, [r3, #3]
   1e632:	7818      	ldrb	r0, [r3, #0]
   1e634:	4291      	cmp	r1, r2
	return (void *)(fifo + first * size);
   1e636:	bf1a      	itte	ne
   1e638:	3304      	addne	r3, #4
   1e63a:	fb02 3000 	mlane	r0, r2, r0, r3
		return NULL;
   1e63e:	2000      	moveq	r0, #0
}
   1e640:	4770      	bx	lr
   1e642:	bf00      	nop
   1e644:	2000faf0 	.word	0x2000faf0

0001e648 <rx_demux>:
		}
}
#endif /* CONFIG_BT_CONN */

static void rx_demux(void *param)
{
   1e648:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
			ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
					     TICKER_USER_ID_LLL, 0, &mfy);
			LL_ASSERT(!ret);
		}

		MFIFO_DEQUEUE(prep);
   1e64c:	4e7f      	ldr	r6, [pc, #508]	; (1e84c <rx_demux+0x204>)
		link = memq_peek(memq_ull_rx.head, memq_ull_rx.tail,
   1e64e:	4c80      	ldr	r4, [pc, #512]	; (1e850 <rx_demux+0x208>)
   1e650:	aa01      	add	r2, sp, #4
   1e652:	e9d4 0100 	ldrd	r0, r1, [r4]
   1e656:	f00d f9d0 	bl	2b9fa <memq_peek>
		if (link) {
   1e65a:	4605      	mov	r5, r0
   1e65c:	2800      	cmp	r0, #0
   1e65e:	f000 80d9 	beq.w	1e814 <rx_demux+0x1cc>
			LL_ASSERT(rx);
   1e662:	9b01      	ldr	r3, [sp, #4]
   1e664:	b943      	cbnz	r3, 1e678 <rx_demux+0x30>
   1e666:	487b      	ldr	r0, [pc, #492]	; (1e854 <rx_demux+0x20c>)
   1e668:	f009 fd6c 	bl	28144 <printk>
   1e66c:	4040      	eors	r0, r0
   1e66e:	f380 8811 	msr	BASEPRI, r0
   1e672:	f04f 0003 	mov.w	r0, #3
   1e676:	df02      	svc	2
			link_tx = ull_conn_ack_by_last_peek(rx->ack_last,
   1e678:	9b01      	ldr	r3, [sp, #4]
   1e67a:	aa02      	add	r2, sp, #8
   1e67c:	f10d 0102 	add.w	r1, sp, #2
   1e680:	7818      	ldrb	r0, [r3, #0]
   1e682:	f003 fe25 	bl	222d0 <ull_conn_ack_by_last_peek>
			if (link_tx) {
   1e686:	9f01      	ldr	r7, [sp, #4]
   1e688:	4602      	mov	r2, r0
   1e68a:	b130      	cbz	r0, 1e69a <rx_demux+0x52>
				rx_demux_conn_tx_ack(rx->ack_last, handle,
   1e68c:	9b02      	ldr	r3, [sp, #8]
   1e68e:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   1e692:	7838      	ldrb	r0, [r7, #0]
				rx_demux_conn_tx_ack(ack_last, handle,
   1e694:	f00d fb71 	bl	2bd7a <rx_demux_conn_tx_ack>
   1e698:	e7d9      	b.n	1e64e <rx_demux+0x6>
	switch (rx->type) {
   1e69a:	793b      	ldrb	r3, [r7, #4]
   1e69c:	9703      	str	r7, [sp, #12]
   1e69e:	3b01      	subs	r3, #1
   1e6a0:	2b08      	cmp	r3, #8
   1e6a2:	f200 80ad 	bhi.w	1e800 <rx_demux+0x1b8>
   1e6a6:	e8df f003 	tbb	[pc, r3]
   1e6aa:	8f05      	.short	0x8f05
   1e6ac:	ababa4ab 	.word	0xababa4ab
   1e6b0:	85ab      	.short	0x85ab
   1e6b2:	a4          	.byte	0xa4
   1e6b3:	00          	.byte	0x00
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   1e6b4:	6860      	ldr	r0, [r4, #4]
   1e6b6:	4966      	ldr	r1, [pc, #408]	; (1e850 <rx_demux+0x208>)
   1e6b8:	2200      	movs	r2, #0
   1e6ba:	f00d f9a6 	bl	2ba0a <memq_dequeue>
		rx_demux_event_done(link, rx);
   1e6be:	9f03      	ldr	r7, [sp, #12]
	switch (done->extra.type) {
   1e6c0:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
	ull_hdr = done->param;
   1e6c4:	6a3c      	ldr	r4, [r7, #32]
	switch (done->extra.type) {
   1e6c6:	b123      	cbz	r3, 1e6d2 <rx_demux+0x8a>
   1e6c8:	2b01      	cmp	r3, #1
   1e6ca:	d160      	bne.n	1e78e <rx_demux+0x146>
		ull_conn_done(done);
   1e6cc:	4638      	mov	r0, r7
   1e6ce:	f003 fbe5 	bl	21e9c <ull_conn_done>
	if (!MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
   1e6d2:	4a61      	ldr	r2, [pc, #388]	; (1e858 <rx_demux+0x210>)
   1e6d4:	78d1      	ldrb	r1, [r2, #3]
	if (last == count) {
   1e6d6:	f892 c001 	ldrb.w	ip, [r2, #1]
   1e6da:	7890      	ldrb	r0, [r2, #2]
	done->extra.type = 0U;
   1e6dc:	2300      	movs	r3, #0
   1e6de:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
	last = last + 1;
   1e6e2:	1c4b      	adds	r3, r1, #1
   1e6e4:	b2db      	uxtb	r3, r3
		last = 0U;
   1e6e6:	459c      	cmp	ip, r3
   1e6e8:	bf08      	it	eq
   1e6ea:	2300      	moveq	r3, #0
	if (last == first) {
   1e6ec:	4298      	cmp	r0, r3
   1e6ee:	f000 809f 	beq.w	1e830 <rx_demux+0x1e8>
	done->hdr.link = link;
   1e6f2:	603d      	str	r5, [r7, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
   1e6f4:	7810      	ldrb	r0, [r2, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
   1e6f6:	fb00 2101 	mla	r1, r0, r1, r2
   1e6fa:	604f      	str	r7, [r1, #4]
	*last = idx; /* Commit: Update write index */
   1e6fc:	70d3      	strb	r3, [r2, #3]
	next = ull_prepare_dequeue_get();
   1e6fe:	f7ff ff95 	bl	1e62c <ull_prepare_dequeue_get>
			mfy.param = next;
   1e702:	f8df 8158 	ldr.w	r8, [pc, #344]	; 1e85c <rx_demux+0x214>
	while (next) {
   1e706:	b330      	cbz	r0, 1e756 <rx_demux+0x10e>
		u8_t is_aborted = next->is_aborted;
   1e708:	f890 5020 	ldrb.w	r5, [r0, #32]
   1e70c:	f3c5 0740 	ubfx	r7, r5, #1, #1
		u8_t is_resume = next->is_resume;
   1e710:	f005 0501 	and.w	r5, r5, #1
		if (!is_aborted) {
   1e714:	b98f      	cbnz	r7, 1e73a <rx_demux+0xf2>
			mfy.param = next;
   1e716:	f8c8 0008 	str.w	r0, [r8, #8]
			ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   1e71a:	4b50      	ldr	r3, [pc, #320]	; (1e85c <rx_demux+0x214>)
   1e71c:	463a      	mov	r2, r7
   1e71e:	4639      	mov	r1, r7
   1e720:	2001      	movs	r0, #1
   1e722:	f7fd f857 	bl	1b7d4 <mayfly_enqueue>
			LL_ASSERT(!ret);
   1e726:	b140      	cbz	r0, 1e73a <rx_demux+0xf2>
   1e728:	484d      	ldr	r0, [pc, #308]	; (1e860 <rx_demux+0x218>)
   1e72a:	f009 fd0b 	bl	28144 <printk>
   1e72e:	4040      	eors	r0, r0
   1e730:	f380 8811 	msr	BASEPRI, r0
   1e734:	f04f 0003 	mov.w	r0, #3
   1e738:	df02      	svc	2
	u8_t _first = *first; /* Copy read-index */
   1e73a:	78b3      	ldrb	r3, [r6, #2]
	if (_first == last) {
   1e73c:	78f1      	ldrb	r1, [r6, #3]
		MFIFO_DEQUEUE(prep);
   1e73e:	7872      	ldrb	r2, [r6, #1]
   1e740:	4299      	cmp	r1, r3
   1e742:	d005      	beq.n	1e750 <rx_demux+0x108>
	_first += 1U;
   1e744:	3301      	adds	r3, #1
   1e746:	b2db      	uxtb	r3, r3
		_first = 0U;
   1e748:	429a      	cmp	r2, r3
   1e74a:	bf08      	it	eq
   1e74c:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   1e74e:	70b3      	strb	r3, [r6, #2]

		next = ull_prepare_dequeue_get();
   1e750:	f7ff ff6c 	bl	1e62c <ull_prepare_dequeue_get>

		if (!next || (!is_aborted && (!is_resume || next->is_resume))) {
   1e754:	bb28      	cbnz	r0, 1e7a2 <rx_demux+0x15a>
			break;
		}
	}

	/* ull instance will resume, dont decrement ref */
	if (!ull_hdr) {
   1e756:	2c00      	cmp	r4, #0
   1e758:	f43f af79 	beq.w	1e64e <rx_demux+0x6>
		return;
	}

	/* Decrement prepare reference */
	LL_ASSERT(ull_hdr->ref);
   1e75c:	7823      	ldrb	r3, [r4, #0]
   1e75e:	b943      	cbnz	r3, 1e772 <rx_demux+0x12a>
   1e760:	4840      	ldr	r0, [pc, #256]	; (1e864 <rx_demux+0x21c>)
   1e762:	f009 fcef 	bl	28144 <printk>
   1e766:	4040      	eors	r0, r0
   1e768:	f380 8811 	msr	BASEPRI, r0
   1e76c:	f04f 0003 	mov.w	r0, #3
   1e770:	df02      	svc	2
	return hdr->ref--;
   1e772:	7823      	ldrb	r3, [r4, #0]
   1e774:	3b01      	subs	r3, #1
   1e776:	b2db      	uxtb	r3, r3
   1e778:	7023      	strb	r3, [r4, #0]
	ull_ref_dec(ull_hdr);

	/* If disable initiated, signal the semaphore */
	if (!ull_hdr->ref && ull_hdr->disabled_cb) {
   1e77a:	2b00      	cmp	r3, #0
   1e77c:	f47f af67 	bne.w	1e64e <rx_demux+0x6>
   1e780:	6863      	ldr	r3, [r4, #4]
   1e782:	2b00      	cmp	r3, #0
   1e784:	f43f af63 	beq.w	1e64e <rx_demux+0x6>
		ull_hdr->disabled_cb(ull_hdr->disabled_param);
   1e788:	68a0      	ldr	r0, [r4, #8]
   1e78a:	4798      	blx	r3
			if (nack) {
   1e78c:	e75f      	b.n	1e64e <rx_demux+0x6>
		LL_ASSERT(0);
   1e78e:	4836      	ldr	r0, [pc, #216]	; (1e868 <rx_demux+0x220>)
   1e790:	f009 fcd8 	bl	28144 <printk>
   1e794:	4040      	eors	r0, r0
   1e796:	f380 8811 	msr	BASEPRI, r0
   1e79a:	f04f 0003 	mov.w	r0, #3
   1e79e:	df02      	svc	2
		break;
   1e7a0:	e797      	b.n	1e6d2 <rx_demux+0x8a>
		if (!next || (!is_aborted && (!is_resume || next->is_resume))) {
   1e7a2:	2f00      	cmp	r7, #0
   1e7a4:	d1af      	bne.n	1e706 <rx_demux+0xbe>
   1e7a6:	2d00      	cmp	r5, #0
   1e7a8:	d0d5      	beq.n	1e756 <rx_demux+0x10e>
   1e7aa:	f890 3020 	ldrb.w	r3, [r0, #32]
   1e7ae:	07db      	lsls	r3, r3, #31
   1e7b0:	d4d1      	bmi.n	1e756 <rx_demux+0x10e>
   1e7b2:	e7a8      	b.n	1e706 <rx_demux+0xbe>
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   1e7b4:	2200      	movs	r2, #0
   1e7b6:	4926      	ldr	r1, [pc, #152]	; (1e850 <rx_demux+0x208>)
   1e7b8:	6860      	ldr	r0, [r4, #4]
   1e7ba:	f00d f926 	bl	2ba0a <memq_dequeue>
		ull_conn_setup(link, rx);
   1e7be:	9903      	ldr	r1, [sp, #12]
   1e7c0:	4628      	mov	r0, r5
   1e7c2:	f002 f82d 	bl	20820 <ull_conn_setup>
			if (nack) {
   1e7c6:	e742      	b.n	1e64e <rx_demux+0x6>
		nack = ull_conn_rx(link, (void *)&rx);
   1e7c8:	a903      	add	r1, sp, #12
   1e7ca:	4628      	mov	r0, r5
   1e7cc:	f002 f846 	bl	2085c <ull_conn_rx>
		if (nack) {
   1e7d0:	4602      	mov	r2, r0
   1e7d2:	2800      	cmp	r0, #0
   1e7d4:	d136      	bne.n	1e844 <rx_demux+0x1fc>
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   1e7d6:	491e      	ldr	r1, [pc, #120]	; (1e850 <rx_demux+0x208>)
   1e7d8:	6860      	ldr	r0, [r4, #4]
   1e7da:	f00d f916 	bl	2ba0a <memq_dequeue>
		if (rx) {
   1e7de:	9903      	ldr	r1, [sp, #12]
   1e7e0:	2900      	cmp	r1, #0
   1e7e2:	f43f af34 	beq.w	1e64e <rx_demux+0x6>
		ll_rx_put(link, rx);
   1e7e6:	4628      	mov	r0, r5
   1e7e8:	f7ff fdb4 	bl	1e354 <ll_rx_put>
		ll_rx_sched();
   1e7ec:	f7ff fdbc 	bl	1e368 <ll_rx_sched>
			if (nack) {
   1e7f0:	e72d      	b.n	1e64e <rx_demux+0x6>
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
   1e7f2:	4917      	ldr	r1, [pc, #92]	; (1e850 <rx_demux+0x208>)
   1e7f4:	6860      	ldr	r0, [r4, #4]
   1e7f6:	2200      	movs	r2, #0
   1e7f8:	f00d f907 	bl	2ba0a <memq_dequeue>
		ll_rx_put(link, rx);
   1e7fc:	9903      	ldr	r1, [sp, #12]
   1e7fe:	e7f2      	b.n	1e7e6 <rx_demux+0x19e>
		LL_ASSERT(0);
   1e800:	4819      	ldr	r0, [pc, #100]	; (1e868 <rx_demux+0x220>)
   1e802:	f009 fc9f 	bl	28144 <printk>
   1e806:	4040      	eors	r0, r0
   1e808:	f380 8811 	msr	BASEPRI, r0
   1e80c:	f04f 0003 	mov.w	r0, #3
   1e810:	df02      	svc	2
			if (nack) {
   1e812:	e71c      	b.n	1e64e <rx_demux+0x6>
			link = ull_conn_ack_peek(&ack_last, &handle, &node_tx);
   1e814:	aa03      	add	r2, sp, #12
   1e816:	a902      	add	r1, sp, #8
   1e818:	f10d 0002 	add.w	r0, sp, #2
   1e81c:	f003 fd40 	bl	222a0 <ull_conn_ack_peek>
			if (link) {
   1e820:	4602      	mov	r2, r0
   1e822:	b178      	cbz	r0, 1e844 <rx_demux+0x1fc>
				rx_demux_conn_tx_ack(ack_last, handle,
   1e824:	9b03      	ldr	r3, [sp, #12]
   1e826:	f8bd 1008 	ldrh.w	r1, [sp, #8]
   1e82a:	f89d 0002 	ldrb.w	r0, [sp, #2]
   1e82e:	e731      	b.n	1e694 <rx_demux+0x4c>
	LL_ASSERT(release == done);
   1e830:	480e      	ldr	r0, [pc, #56]	; (1e86c <rx_demux+0x224>)
   1e832:	f009 fc87 	bl	28144 <printk>
   1e836:	4040      	eors	r0, r0
   1e838:	f380 8811 	msr	BASEPRI, r0
   1e83c:	f04f 0003 	mov.w	r0, #3
   1e840:	df02      	svc	2
   1e842:	e75c      	b.n	1e6fe <rx_demux+0xb6>
}
   1e844:	b004      	add	sp, #16
   1e846:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1e84a:	bf00      	nop
   1e84c:	2000faf0 	.word	0x2000faf0
   1e850:	200022a4 	.word	0x200022a4
   1e854:	000317fc 	.word	0x000317fc
   1e858:	2000fab0 	.word	0x2000fab0
   1e85c:	2000fc78 	.word	0x2000fc78
   1e860:	0003166e 	.word	0x0003166e
   1e864:	00031811 	.word	0x00031811
   1e868:	000314f5 	.word	0x000314f5
   1e86c:	00031830 	.word	0x00031830

0001e870 <ull_prepare_dequeue_iter>:
{
   1e870:	b530      	push	{r4, r5, lr}
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
   1e872:	4b0c      	ldr	r3, [pc, #48]	; (1e8a4 <ull_prepare_dequeue_iter+0x34>)
	if (*idx >= count) {
   1e874:	7801      	ldrb	r1, [r0, #0]
   1e876:	785c      	ldrb	r4, [r3, #1]
   1e878:	78dd      	ldrb	r5, [r3, #3]
   1e87a:	781a      	ldrb	r2, [r3, #0]
   1e87c:	42a1      	cmp	r1, r4
   1e87e:	bf24      	itt	cs
   1e880:	789b      	ldrbcs	r3, [r3, #2]
		*idx = first;
   1e882:	7003      	strbcs	r3, [r0, #0]
	if (*idx == last) {
   1e884:	7801      	ldrb	r1, [r0, #0]
   1e886:	428d      	cmp	r5, r1
   1e888:	d00a      	beq.n	1e8a0 <ull_prepare_dequeue_iter+0x30>
	i = *idx + 1;
   1e88a:	1c4b      	adds	r3, r1, #1
   1e88c:	b2db      	uxtb	r3, r3
		i = 0U;
   1e88e:	429c      	cmp	r4, r3
   1e890:	bf08      	it	eq
   1e892:	2300      	moveq	r3, #0
	p = (void *)(fifo + (*idx) * size);
   1e894:	4c04      	ldr	r4, [pc, #16]	; (1e8a8 <ull_prepare_dequeue_iter+0x38>)
	*idx = i;
   1e896:	7003      	strb	r3, [r0, #0]
	p = (void *)(fifo + (*idx) * size);
   1e898:	fb01 4202 	mla	r2, r1, r2, r4
}
   1e89c:	4610      	mov	r0, r2
   1e89e:	bd30      	pop	{r4, r5, pc}
		return NULL;
   1e8a0:	2200      	movs	r2, #0
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
   1e8a2:	e7fb      	b.n	1e89c <ull_prepare_dequeue_iter+0x2c>
   1e8a4:	2000faf0 	.word	0x2000faf0
   1e8a8:	2000faf4 	.word	0x2000faf4

0001e8ac <ull_event_done_extra_get>:
	evdone = MFIFO_DEQUEUE_PEEK(done);
   1e8ac:	4b06      	ldr	r3, [pc, #24]	; (1e8c8 <ull_event_done_extra_get+0x1c>)
   1e8ae:	7899      	ldrb	r1, [r3, #2]
	if (first == last) {
   1e8b0:	78d8      	ldrb	r0, [r3, #3]
   1e8b2:	781a      	ldrb	r2, [r3, #0]
   1e8b4:	4288      	cmp	r0, r1
   1e8b6:	d005      	beq.n	1e8c4 <ull_event_done_extra_get+0x18>
	return *((void **)(fifo + first * size));
   1e8b8:	fb01 3302 	mla	r3, r1, r2, r3
   1e8bc:	6858      	ldr	r0, [r3, #4]
	if (!evdone) {
   1e8be:	b110      	cbz	r0, 1e8c6 <ull_event_done_extra_get+0x1a>
	return &evdone->extra;
   1e8c0:	3024      	adds	r0, #36	; 0x24
   1e8c2:	4770      	bx	lr
		return NULL;
   1e8c4:	2000      	movs	r0, #0
}
   1e8c6:	4770      	bx	lr
   1e8c8:	2000fab0 	.word	0x2000fab0

0001e8cc <ull_event_done>:
{
   1e8cc:	b538      	push	{r3, r4, r5, lr}
	evdone = MFIFO_DEQUEUE(done);
   1e8ce:	4a10      	ldr	r2, [pc, #64]	; (1e910 <ull_event_done+0x44>)
	u8_t _first = *first; /* Copy read-index */
   1e8d0:	7893      	ldrb	r3, [r2, #2]
	if (_first == last) {
   1e8d2:	78d4      	ldrb	r4, [r2, #3]
   1e8d4:	7811      	ldrb	r1, [r2, #0]
   1e8d6:	7855      	ldrb	r5, [r2, #1]
   1e8d8:	429c      	cmp	r4, r3
   1e8da:	d017      	beq.n	1e90c <ull_event_done+0x40>
	mem = *((void **)(fifo + _first * size));
   1e8dc:	fb03 2101 	mla	r1, r3, r1, r2
	_first += 1U;
   1e8e0:	3301      	adds	r3, #1
	mem = *((void **)(fifo + _first * size));
   1e8e2:	684c      	ldr	r4, [r1, #4]
	_first += 1U;
   1e8e4:	b2db      	uxtb	r3, r3
		_first = 0U;
   1e8e6:	429d      	cmp	r5, r3
   1e8e8:	bf08      	it	eq
   1e8ea:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   1e8ec:	7093      	strb	r3, [r2, #2]
	if (!evdone) {
   1e8ee:	b15c      	cbz	r4, 1e908 <ull_event_done+0x3c>
	link = evdone->hdr.link;
   1e8f0:	6823      	ldr	r3, [r4, #0]
	evdone->param = param;
   1e8f2:	6220      	str	r0, [r4, #32]
	evdone->hdr.link = NULL;
   1e8f4:	2200      	movs	r2, #0
   1e8f6:	6022      	str	r2, [r4, #0]
	evdone->hdr.type = NODE_RX_TYPE_EVENT_DONE;
   1e8f8:	2201      	movs	r2, #1
   1e8fa:	7122      	strb	r2, [r4, #4]
	ull_rx_put(link, evdone);
   1e8fc:	4621      	mov	r1, r4
   1e8fe:	4618      	mov	r0, r3
   1e900:	f7ff fe4a 	bl	1e598 <ull_rx_put>
	ull_rx_sched();
   1e904:	f7ff fe58 	bl	1e5b8 <ull_rx_sched>
}
   1e908:	4620      	mov	r0, r4
   1e90a:	bd38      	pop	{r3, r4, r5, pc}
		return NULL;
   1e90c:	2400      	movs	r4, #0
   1e90e:	e7fb      	b.n	1e908 <ull_event_done+0x3c>
   1e910:	2000fab0 	.word	0x2000fab0

0001e914 <lll_chan_sel_2>:
}

#if defined(CONFIG_BT_CTLR_CHAN_SEL_2)
u8_t lll_chan_sel_2(u16_t counter, u16_t chan_id, u8_t *chan_map,
		    u8_t chan_count)
{
   1e914:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
/* Attribution:
 * http://graphics.stanford.edu/%7Eseander/bithacks.html#ReverseByteWith32Bits
 */
static u8_t chan_rev_8(u8_t b)
{
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   1e918:	4f25      	ldr	r7, [pc, #148]	; (1e9b0 <lll_chan_sel_2+0x9c>)
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   1e91a:	4d26      	ldr	r5, [pc, #152]	; (1e9b4 <lll_chan_sel_2+0xa0>)
static u16_t chan_prn(u16_t counter, u16_t chan_id)
{
	u8_t iterate;
	u16_t prn_e;

	prn_e = counter ^ chan_id;
   1e91c:	4048      	eors	r0, r1
   1e91e:	2403      	movs	r4, #3
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   1e920:	f640 0c02 	movw	ip, #2050	; 0x802
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   1e924:	f248 0620 	movw	r6, #32800	; 0x8020
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   1e928:	ea4f 2e10 	mov.w	lr, r0, lsr #8
   1e92c:	fb0c f80e 	mul.w	r8, ip, lr
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   1e930:	fb06 fe0e 	mul.w	lr, r6, lr
   1e934:	ea0e 0e05 	and.w	lr, lr, r5
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   1e938:	ea08 0807 	and.w	r8, r8, r7
   1e93c:	ea48 080e 	orr.w	r8, r8, lr
   1e940:	b2c0      	uxtb	r0, r0
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   1e942:	eb08 2e08 	add.w	lr, r8, r8, lsl #8
   1e946:	eb08 280e 	add.w	r8, r8, lr, lsl #8
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   1e94a:	fb0c fe00 	mul.w	lr, ip, r0
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   1e94e:	4370      	muls	r0, r6
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   1e950:	ea0e 0e07 	and.w	lr, lr, r7
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   1e954:	4028      	ands	r0, r5
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
   1e956:	ea4e 0000 	orr.w	r0, lr, r0
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
   1e95a:	eb00 2e00 	add.w	lr, r0, r0, lsl #8
   1e95e:	eb00 200e 	add.w	r0, r0, lr, lsl #8
   1e962:	ea4f 4818 	mov.w	r8, r8, lsr #16
	return (chan_rev_8((i >> 8) & 0xFF) << 8) | chan_rev_8(i & 0xFF);
   1e966:	f3c0 4007 	ubfx	r0, r0, #16, #8
   1e96a:	ea40 2008 	orr.w	r0, r0, r8, lsl #8
	return ((u32_t)a * 17U + b) & 0xFFFF;
   1e96e:	eb00 1000 	add.w	r0, r0, r0, lsl #4
   1e972:	3c01      	subs	r4, #1
   1e974:	4408      	add	r0, r1

	for (iterate = 0U; iterate < 3; iterate++) {
   1e976:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
	return ((u32_t)a * 17U + b) & 0xFFFF;
   1e97a:	b280      	uxth	r0, r0
	for (iterate = 0U; iterate < 3; iterate++) {
   1e97c:	d1d4      	bne.n	1e928 <lll_chan_sel_2+0x14>
	chan_next = prn_e % 37;
   1e97e:	2425      	movs	r4, #37	; 0x25
		prn_e = chan_perm(prn_e);
		prn_e = chan_mam(prn_e, chan_id);
	}

	prn_e ^= chan_id;
   1e980:	4041      	eors	r1, r0
	chan_next = prn_e % 37;
   1e982:	fbb1 f0f4 	udiv	r0, r1, r4
   1e986:	fb04 1010 	mls	r0, r4, r0, r1
   1e98a:	b2c0      	uxtb	r0, r0
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
   1e98c:	08c4      	lsrs	r4, r0, #3
   1e98e:	f000 0507 	and.w	r5, r0, #7
   1e992:	5d14      	ldrb	r4, [r2, r4]
   1e994:	412c      	asrs	r4, r5
   1e996:	07e4      	lsls	r4, r4, #31
   1e998:	d407      	bmi.n	1e9aa <lll_chan_sel_2+0x96>
		chan_index = ((u32_t)chan_count * prn_e) >> 16;
   1e99a:	4359      	muls	r1, r3
		chan_next = chan_sel_remap(chan_map, chan_index);
   1e99c:	f3c1 4107 	ubfx	r1, r1, #16, #8
   1e9a0:	4610      	mov	r0, r2
}
   1e9a2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		chan_next = chan_sel_remap(chan_map, chan_index);
   1e9a6:	f00d ba14 	b.w	2bdd2 <chan_sel_remap>
}
   1e9aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1e9ae:	bf00      	nop
   1e9b0:	00022110 	.word	0x00022110
   1e9b4:	00088440 	.word	0x00088440

0001e9b8 <rtc0_nrf5_isr>:
	DEBUG_RADIO_ISR(0);
	return 1;
}

static void rtc0_nrf5_isr(void *arg)
{
   1e9b8:	b508      	push	{r3, lr}
	DEBUG_TICKER_ISR(1);

	/* On compare0 run ticker worker instance0 */
	if (NRF_RTC0->EVENTS_COMPARE[0]) {
   1e9ba:	4b08      	ldr	r3, [pc, #32]	; (1e9dc <rtc0_nrf5_isr+0x24>)
   1e9bc:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
   1e9c0:	b122      	cbz	r2, 1e9cc <rtc0_nrf5_isr+0x14>
		NRF_RTC0->EVENTS_COMPARE[0] = 0;
   1e9c2:	2000      	movs	r0, #0
   1e9c4:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140

		ticker_trigger(0);
   1e9c8:	f7fd fb64 	bl	1c094 <ticker_trigger>
	}

	mayfly_run(TICKER_USER_ID_ULL_HIGH);
   1e9cc:	2001      	movs	r0, #1
   1e9ce:	f7fc ff51 	bl	1b874 <mayfly_run>

#if !defined(CONFIG_BT_CTLR_LOW_LAT) && \
	(CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	mayfly_run(TICKER_USER_ID_ULL_LOW);
   1e9d2:	2002      	movs	r0, #2
#endif

	DEBUG_TICKER_ISR(0);
}
   1e9d4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	mayfly_run(TICKER_USER_ID_ULL_LOW);
   1e9d8:	f7fc bf4c 	b.w	1b874 <mayfly_run>
   1e9dc:	4000b000 	.word	0x4000b000

0001e9e0 <prepare>:
}

static int prepare(lll_is_abort_cb_t is_abort_cb, lll_abort_cb_t abort_cb,
		   lll_prepare_cb_t prepare_cb, int prio,
		   struct lll_prepare_param *prepare_param, u8_t is_resume)
{
   1e9e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1e9e4:	b08d      	sub	sp, #52	; 0x34
   1e9e6:	4699      	mov	r9, r3
   1e9e8:	9d14      	ldr	r5, [sp, #80]	; 0x50
   1e9ea:	f89d 4054 	ldrb.w	r4, [sp, #84]	; 0x54
	u8_t idx = UINT8_MAX;
   1e9ee:	23ff      	movs	r3, #255	; 0xff
{
   1e9f0:	4680      	mov	r8, r0
   1e9f2:	460f      	mov	r7, r1
   1e9f4:	4616      	mov	r6, r2
	u8_t idx = UINT8_MAX;
   1e9f6:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
	int ret, err;

	/* Find the ready prepare in the pipeline */
	p = ull_prepare_dequeue_iter(&idx);
	while (p && (p->is_aborted || p->is_resume)) {
		p = ull_prepare_dequeue_iter(&idx);
   1e9fa:	f10d 002f 	add.w	r0, sp, #47	; 0x2f
   1e9fe:	f7ff ff37 	bl	1e870 <ull_prepare_dequeue_iter>
	while (p && (p->is_aborted || p->is_resume)) {
   1ea02:	b118      	cbz	r0, 1ea0c <prepare+0x2c>
   1ea04:	f890 3020 	ldrb.w	r3, [r0, #32]
   1ea08:	079b      	lsls	r3, r3, #30
   1ea0a:	d1f6      	bne.n	1e9fa <prepare+0x1a>
	}

	/* Current event active or another prepare is ready in the pipeline */
	if (event.curr.abort_cb || (p && is_resume)) {
   1ea0c:	4b30      	ldr	r3, [pc, #192]	; (1ead0 <prepare+0xf0>)
   1ea0e:	689a      	ldr	r2, [r3, #8]
   1ea10:	b91a      	cbnz	r2, 1ea1a <prepare+0x3a>
   1ea12:	2800      	cmp	r0, #0
   1ea14:	d042      	beq.n	1ea9c <prepare+0xbc>
   1ea16:	2c00      	cmp	r4, #0
   1ea18:	d040      	beq.n	1ea9c <prepare+0xbc>
			/* early abort */
			event.curr.abort_cb(NULL, event.curr.param);
		}

		/* Store the next prepare for deferred call */
		ret = ull_prepare_enqueue(is_abort_cb, abort_cb, prepare_param,
   1ea1a:	e9cd 9400 	strd	r9, r4, [sp]
   1ea1e:	4633      	mov	r3, r6
   1ea20:	462a      	mov	r2, r5
   1ea22:	4639      	mov	r1, r7
   1ea24:	4640      	mov	r0, r8
   1ea26:	f7ff fdcf 	bl	1e5c8 <ull_prepare_enqueue>
					  prepare_cb, prio, is_resume);
		LL_ASSERT(!ret);
   1ea2a:	b140      	cbz	r0, 1ea3e <prepare+0x5e>
   1ea2c:	4829      	ldr	r0, [pc, #164]	; (1ead4 <prepare+0xf4>)
   1ea2e:	f009 fb89 	bl	28144 <printk>
   1ea32:	4040      	eors	r0, r0
   1ea34:	f380 8811 	msr	BASEPRI, r0
   1ea38:	f04f 0003 	mov.w	r0, #3
   1ea3c:	df02      	svc	2

#if !defined(CONFIG_BT_CTLR_LOW_LAT)
		if (is_resume) {
   1ea3e:	b12c      	cbz	r4, 1ea4c <prepare+0x6c>
				LL_ASSERT(ret == -ECANCELED);
			}
		}
#endif /* CONFIG_BT_CTLR_LOW_LAT */

		return -EINPROGRESS;
   1ea40:	f06f 0443 	mvn.w	r4, #67	; 0x43
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
		  (ret == TICKER_STATUS_FAILURE) ||
		  (ret == TICKER_STATUS_BUSY));

	return err;
}
   1ea44:	4620      	mov	r0, r4
   1ea46:	b00d      	add	sp, #52	; 0x34
   1ea48:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		evt = HDR_LLL2EVT(prepare_param->param);
   1ea4c:	68eb      	ldr	r3, [r5, #12]
   1ea4e:	681a      	ldr	r2, [r3, #0]
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   1ea50:	4b21      	ldr	r3, [pc, #132]	; (1ead8 <prepare+0xf8>)
   1ea52:	9408      	str	r4, [sp, #32]
   1ea54:	e9cd 4306 	strd	r4, r3, [sp, #24]
   1ea58:	4b20      	ldr	r3, [pc, #128]	; (1eadc <prepare+0xfc>)
   1ea5a:	9401      	str	r4, [sp, #4]
   1ea5c:	e9cd 4304 	strd	r4, r3, [sp, #16]
   1ea60:	e9cd 4402 	strd	r4, r4, [sp, #8]
		preempt_to = MAX(evt->ticks_active_to_start,
   1ea64:	e9d2 0100 	ldrd	r0, r1, [r2]
   1ea68:	6893      	ldr	r3, [r2, #8]
   1ea6a:	4288      	cmp	r0, r1
   1ea6c:	bf2c      	ite	cs
   1ea6e:	ebc3 0300 	rsbcs	r3, r3, r0
   1ea72:	ebc3 0301 	rsbcc	r3, r3, r1
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   1ea76:	9300      	str	r3, [sp, #0]
   1ea78:	682b      	ldr	r3, [r5, #0]
   1ea7a:	4622      	mov	r2, r4
   1ea7c:	4621      	mov	r1, r4
   1ea7e:	4620      	mov	r0, r4
   1ea80:	f7fd fb1a 	bl	1c0b8 <ticker_start>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1ea84:	2802      	cmp	r0, #2
   1ea86:	d9db      	bls.n	1ea40 <prepare+0x60>
   1ea88:	4815      	ldr	r0, [pc, #84]	; (1eae0 <prepare+0x100>)
   1ea8a:	f009 fb5b 	bl	28144 <printk>
   1ea8e:	4040      	eors	r0, r0
   1ea90:	f380 8811 	msr	BASEPRI, r0
   1ea94:	f04f 0003 	mov.w	r0, #3
   1ea98:	df02      	svc	2
   1ea9a:	e7d1      	b.n	1ea40 <prepare+0x60>
	event.curr.param = prepare_param->param;
   1ea9c:	68ea      	ldr	r2, [r5, #12]
	event.curr.abort_cb = abort_cb;
   1ea9e:	609f      	str	r7, [r3, #8]
	event.curr.is_abort_cb = is_abort_cb;
   1eaa0:	e9c3 2800 	strd	r2, r8, [r3]
	err = prepare_cb(prepare_param);
   1eaa4:	4628      	mov	r0, r5
   1eaa6:	47b0      	blx	r6
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_LLL,
   1eaa8:	2300      	movs	r3, #0
	err = prepare_cb(prepare_param);
   1eaaa:	4604      	mov	r4, r0
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_LLL,
   1eaac:	9300      	str	r3, [sp, #0]
   1eaae:	461a      	mov	r2, r3
   1eab0:	4619      	mov	r1, r3
   1eab2:	4618      	mov	r0, r3
   1eab4:	f7fd fb92 	bl	1c1dc <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1eab8:	2802      	cmp	r0, #2
   1eaba:	d9c3      	bls.n	1ea44 <prepare+0x64>
   1eabc:	4808      	ldr	r0, [pc, #32]	; (1eae0 <prepare+0x100>)
   1eabe:	f009 fb41 	bl	28144 <printk>
   1eac2:	4040      	eors	r0, r0
   1eac4:	f380 8811 	msr	BASEPRI, r0
   1eac8:	f04f 0003 	mov.w	r0, #3
   1eacc:	df02      	svc	2
   1eace:	e7b9      	b.n	1ea44 <prepare+0x64>
   1ead0:	20002710 	.word	0x20002710
   1ead4:	0003166e 	.word	0x0003166e
   1ead8:	0001ebd1 	.word	0x0001ebd1
   1eadc:	0001ebf1 	.word	0x0001ebf1
   1eae0:	0003192a 	.word	0x0003192a

0001eae4 <preempt>:
			     0, &mfy);
	LL_ASSERT(!ret);
}

static void preempt(void *param)
{
   1eae4:	b5f0      	push	{r4, r5, r6, r7, lr}
   1eae6:	b08b      	sub	sp, #44	; 0x2c
	struct lll_event *next = ull_prepare_dequeue_get();
   1eae8:	f7ff fda0 	bl	1e62c <ull_prepare_dequeue_get>
	lll_prepare_cb_t resume_cb;
	u8_t idx = UINT8_MAX;
   1eaec:	23ff      	movs	r3, #255	; 0xff
	int resume_prio;
	int ret;

	next = ull_prepare_dequeue_iter(&idx);
   1eaee:	f10d 000e 	add.w	r0, sp, #14
	u8_t idx = UINT8_MAX;
   1eaf2:	f88d 300e 	strb.w	r3, [sp, #14]
	next = ull_prepare_dequeue_iter(&idx);
   1eaf6:	f7ff febb 	bl	1e870 <ull_prepare_dequeue_iter>
	if (!next || !event.curr.abort_cb || !event.curr.param) {
   1eafa:	4605      	mov	r5, r0
   1eafc:	b120      	cbz	r0, 1eb08 <preempt+0x24>
   1eafe:	4c31      	ldr	r4, [pc, #196]	; (1ebc4 <preempt+0xe0>)
   1eb00:	68a3      	ldr	r3, [r4, #8]
   1eb02:	b10b      	cbz	r3, 1eb08 <preempt+0x24>
   1eb04:	6823      	ldr	r3, [r4, #0]
   1eb06:	b943      	cbnz	r3, 1eb1a <preempt+0x36>
		ret = resume_enqueue(resume_cb, resume_prio);
		LL_ASSERT(!ret);
	} else {
		LL_ASSERT(ret == -ECANCELED);
	}
}
   1eb08:	b00b      	add	sp, #44	; 0x2c
   1eb0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		next = ull_prepare_dequeue_iter(&idx);
   1eb0c:	f10d 000e 	add.w	r0, sp, #14
   1eb10:	f7ff feae 	bl	1e870 <ull_prepare_dequeue_iter>
	while (next && (next->is_aborted || next->is_resume)) {
   1eb14:	4605      	mov	r5, r0
   1eb16:	2800      	cmp	r0, #0
   1eb18:	d0f6      	beq.n	1eb08 <preempt+0x24>
   1eb1a:	f895 0020 	ldrb.w	r0, [r5, #32]
   1eb1e:	f010 0603 	ands.w	r6, r0, #3
   1eb22:	d1f3      	bne.n	1eb0c <preempt+0x28>
	ret = event.curr.is_abort_cb(next->prepare_param.param, next->prio,
   1eb24:	ab05      	add	r3, sp, #20
   1eb26:	9300      	str	r3, [sp, #0]
   1eb28:	6867      	ldr	r7, [r4, #4]
   1eb2a:	6822      	ldr	r2, [r4, #0]
   1eb2c:	69e9      	ldr	r1, [r5, #28]
   1eb2e:	68e8      	ldr	r0, [r5, #12]
   1eb30:	ab04      	add	r3, sp, #16
   1eb32:	47b8      	blx	r7
	if (!ret) {
   1eb34:	4607      	mov	r7, r0
   1eb36:	b950      	cbnz	r0, 1eb4e <preempt+0x6a>
		next->is_aborted = 1;
   1eb38:	f895 3020 	ldrb.w	r3, [r5, #32]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
   1eb3c:	68e9      	ldr	r1, [r5, #12]
		next->is_aborted = 1;
   1eb3e:	f043 0302 	orr.w	r3, r3, #2
   1eb42:	f885 3020 	strb.w	r3, [r5, #32]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
   1eb46:	4628      	mov	r0, r5
   1eb48:	69ab      	ldr	r3, [r5, #24]
   1eb4a:	4798      	blx	r3
		return;
   1eb4c:	e7dc      	b.n	1eb08 <preempt+0x24>
	event.curr.abort_cb(NULL, event.curr.param);
   1eb4e:	68a3      	ldr	r3, [r4, #8]
   1eb50:	6821      	ldr	r1, [r4, #0]
   1eb52:	4630      	mov	r0, r6
   1eb54:	4798      	blx	r3
	if (ret == -EAGAIN) {
   1eb56:	f117 0f0b 	cmn.w	r7, #11
   1eb5a:	d12f      	bne.n	1ebbc <preempt+0xd8>
		u8_t idx = UINT8_MAX;
   1eb5c:	23ff      	movs	r3, #255	; 0xff
   1eb5e:	f88d 300f 	strb.w	r3, [sp, #15]
			iter = ull_prepare_dequeue_iter(&idx);
   1eb62:	f10d 000f 	add.w	r0, sp, #15
   1eb66:	f7ff fe83 	bl	1e870 <ull_prepare_dequeue_iter>
		while (iter) {
   1eb6a:	b9c0      	cbnz	r0, 1eb9e <preempt+0xba>
	prepare_param.param = event.curr.param;
   1eb6c:	6823      	ldr	r3, [r4, #0]
   1eb6e:	9309      	str	r3, [sp, #36]	; 0x24
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
   1eb70:	2301      	movs	r3, #1
   1eb72:	9301      	str	r3, [sp, #4]
   1eb74:	9b05      	ldr	r3, [sp, #20]
	event.curr.param = NULL;
   1eb76:	6020      	str	r0, [r4, #0]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
   1eb78:	9300      	str	r3, [sp, #0]
   1eb7a:	aa06      	add	r2, sp, #24
   1eb7c:	9b04      	ldr	r3, [sp, #16]
   1eb7e:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
   1eb82:	f7ff fd21 	bl	1e5c8 <ull_prepare_enqueue>
		LL_ASSERT(!ret);
   1eb86:	2800      	cmp	r0, #0
   1eb88:	d0be      	beq.n	1eb08 <preempt+0x24>
   1eb8a:	480f      	ldr	r0, [pc, #60]	; (1ebc8 <preempt+0xe4>)
		LL_ASSERT(ret == -ECANCELED);
   1eb8c:	f009 fada 	bl	28144 <printk>
   1eb90:	4040      	eors	r0, r0
   1eb92:	f380 8811 	msr	BASEPRI, r0
   1eb96:	f04f 0003 	mov.w	r0, #3
   1eb9a:	df02      	svc	2
   1eb9c:	e7b4      	b.n	1eb08 <preempt+0x24>
			if (!iter->is_aborted &&
   1eb9e:	f890 3020 	ldrb.w	r3, [r0, #32]
   1eba2:	079a      	lsls	r2, r3, #30
   1eba4:	d4dd      	bmi.n	1eb62 <preempt+0x7e>
			    event.curr.param == iter->prepare_param.param) {
   1eba6:	68c2      	ldr	r2, [r0, #12]
			if (!iter->is_aborted &&
   1eba8:	6821      	ldr	r1, [r4, #0]
   1ebaa:	4291      	cmp	r1, r2
   1ebac:	d1d9      	bne.n	1eb62 <preempt+0x7e>
				iter->is_aborted = 1;
   1ebae:	f043 0302 	orr.w	r3, r3, #2
   1ebb2:	f880 3020 	strb.w	r3, [r0, #32]
				iter->abort_cb(&iter->prepare_param,
   1ebb6:	6983      	ldr	r3, [r0, #24]
   1ebb8:	4798      	blx	r3
   1ebba:	e7d2      	b.n	1eb62 <preempt+0x7e>
		LL_ASSERT(ret == -ECANCELED);
   1ebbc:	3748      	adds	r7, #72	; 0x48
   1ebbe:	d0a3      	beq.n	1eb08 <preempt+0x24>
   1ebc0:	4802      	ldr	r0, [pc, #8]	; (1ebcc <preempt+0xe8>)
   1ebc2:	e7e3      	b.n	1eb8c <preempt+0xa8>
   1ebc4:	20002710 	.word	0x20002710
   1ebc8:	0003166e 	.word	0x0003166e
   1ebcc:	0003190d 	.word	0x0003190d

0001ebd0 <ticker_start_op_cb>:
	LL_ASSERT((status == TICKER_STATUS_SUCCESS) ||
   1ebd0:	2801      	cmp	r0, #1
{
   1ebd2:	b508      	push	{r3, lr}
	LL_ASSERT((status == TICKER_STATUS_SUCCESS) ||
   1ebd4:	d908      	bls.n	1ebe8 <ticker_start_op_cb+0x18>
   1ebd6:	4805      	ldr	r0, [pc, #20]	; (1ebec <ticker_start_op_cb+0x1c>)
   1ebd8:	f009 fab4 	bl	28144 <printk>
   1ebdc:	4040      	eors	r0, r0
   1ebde:	f380 8811 	msr	BASEPRI, r0
   1ebe2:	f04f 0003 	mov.w	r0, #3
   1ebe6:	df02      	svc	2
}
   1ebe8:	bd08      	pop	{r3, pc}
   1ebea:	bf00      	nop
   1ebec:	0003196f 	.word	0x0003196f

0001ebf0 <preempt_ticker_cb>:
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   1ebf0:	2200      	movs	r2, #0
{
   1ebf2:	b508      	push	{r3, lr}
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   1ebf4:	4611      	mov	r1, r2
   1ebf6:	4b07      	ldr	r3, [pc, #28]	; (1ec14 <preempt_ticker_cb+0x24>)
   1ebf8:	2001      	movs	r0, #1
   1ebfa:	f7fc fdeb 	bl	1b7d4 <mayfly_enqueue>
	LL_ASSERT(!ret);
   1ebfe:	b140      	cbz	r0, 1ec12 <preempt_ticker_cb+0x22>
   1ec00:	4805      	ldr	r0, [pc, #20]	; (1ec18 <preempt_ticker_cb+0x28>)
   1ec02:	f009 fa9f 	bl	28144 <printk>
   1ec06:	4040      	eors	r0, r0
   1ec08:	f380 8811 	msr	BASEPRI, r0
   1ec0c:	f04f 0003 	mov.w	r0, #3
   1ec10:	df02      	svc	2
}
   1ec12:	bd08      	pop	{r3, pc}
   1ec14:	2000fc88 	.word	0x2000fc88
   1ec18:	0003166e 	.word	0x0003166e

0001ec1c <lll_init>:
{
   1ec1c:	b510      	push	{r4, lr}
   1ec1e:	481a      	ldr	r0, [pc, #104]	; (1ec88 <lll_init+0x6c>)
   1ec20:	f007 fb70 	bl	26304 <z_impl_device_get_binding>
	dev_entropy = device_get_binding(CONFIG_ENTROPY_NAME);
   1ec24:	4b19      	ldr	r3, [pc, #100]	; (1ec8c <lll_init+0x70>)
   1ec26:	6018      	str	r0, [r3, #0]
	if (!dev_entropy) {
   1ec28:	b910      	cbnz	r0, 1ec30 <lll_init+0x14>
		return -ENODEV;
   1ec2a:	f06f 0012 	mvn.w	r0, #18
}
   1ec2e:	bd10      	pop	{r4, pc}
	event.curr.abort_cb = NULL;
   1ec30:	4b17      	ldr	r3, [pc, #92]	; (1ec90 <lll_init+0x74>)
   1ec32:	2400      	movs	r4, #0
   1ec34:	609c      	str	r4, [r3, #8]
   1ec36:	4817      	ldr	r0, [pc, #92]	; (1ec94 <lll_init+0x78>)
   1ec38:	f007 fb64 	bl	26304 <z_impl_device_get_binding>
	if (!clk_k32) {
   1ec3c:	2800      	cmp	r0, #0
   1ec3e:	d0f4      	beq.n	1ec2a <lll_init+0xe>
	clock_control_on(clk_k32, NULL);
   1ec40:	f00d f905 	bl	2be4e <clock_control_on.constprop.4>
   1ec44:	4814      	ldr	r0, [pc, #80]	; (1ec98 <lll_init+0x7c>)
   1ec46:	f007 fb5d 	bl	26304 <z_impl_device_get_binding>
	lll.clk_hf =
   1ec4a:	4b14      	ldr	r3, [pc, #80]	; (1ec9c <lll_init+0x80>)
   1ec4c:	6018      	str	r0, [r3, #0]
	if (!lll.clk_hf) {
   1ec4e:	2800      	cmp	r0, #0
   1ec50:	d0eb      	beq.n	1ec2a <lll_init+0xe>
	IRQ_DIRECT_CONNECT(RADIO_IRQn, CONFIG_BT_CTLR_LLL_PRIO,
   1ec52:	4622      	mov	r2, r4
   1ec54:	4621      	mov	r1, r4
   1ec56:	2001      	movs	r0, #1
   1ec58:	f7f4 ff64 	bl	13b24 <z_arm_irq_priority_set>
	IRQ_CONNECT(RTC0_IRQn, CONFIG_BT_CTLR_ULL_HIGH_PRIO,
   1ec5c:	4622      	mov	r2, r4
   1ec5e:	4621      	mov	r1, r4
   1ec60:	200b      	movs	r0, #11
   1ec62:	f7f4 ff5f 	bl	13b24 <z_arm_irq_priority_set>
	IRQ_CONNECT(HAL_SWI_RADIO_IRQ, CONFIG_BT_CTLR_LLL_PRIO,
   1ec66:	4622      	mov	r2, r4
   1ec68:	4621      	mov	r1, r4
   1ec6a:	2018      	movs	r0, #24
   1ec6c:	f7f4 ff5a 	bl	13b24 <z_arm_irq_priority_set>
	irq_enable(RADIO_IRQn);
   1ec70:	2001      	movs	r0, #1
   1ec72:	f7f4 ff25 	bl	13ac0 <arch_irq_enable>
	irq_enable(RTC0_IRQn);
   1ec76:	200b      	movs	r0, #11
   1ec78:	f7f4 ff22 	bl	13ac0 <arch_irq_enable>
	irq_enable(HAL_SWI_RADIO_IRQ);
   1ec7c:	2018      	movs	r0, #24
   1ec7e:	f7f4 ff1f 	bl	13ac0 <arch_irq_enable>
	return 0;
   1ec82:	4620      	mov	r0, r4
   1ec84:	e7d3      	b.n	1ec2e <lll_init+0x12>
   1ec86:	bf00      	nop
   1ec88:	0003163e 	.word	0x0003163e
   1ec8c:	2000270c 	.word	0x2000270c
   1ec90:	20002710 	.word	0x20002710
   1ec94:	000301ee 	.word	0x000301ee
   1ec98:	000301f8 	.word	0x000301f8
   1ec9c:	20002724 	.word	0x20002724

0001eca0 <lll_entropy_get>:
{
   1eca0:	b538      	push	{r3, r4, r5, lr}
	return entropy_get_entropy_isr(dev_entropy, rand, len, 0);
   1eca2:	4b07      	ldr	r3, [pc, #28]	; (1ecc0 <lll_entropy_get+0x20>)
   1eca4:	681d      	ldr	r5, [r3, #0]
	if (unlikely(!api->get_entropy_isr)) {
   1eca6:	686b      	ldr	r3, [r5, #4]
   1eca8:	685c      	ldr	r4, [r3, #4]
   1ecaa:	4602      	mov	r2, r0
   1ecac:	b124      	cbz	r4, 1ecb8 <lll_entropy_get+0x18>
	return api->get_entropy_isr(dev, buffer, length, flags);
   1ecae:	2300      	movs	r3, #0
   1ecb0:	4628      	mov	r0, r5
   1ecb2:	47a0      	blx	r4
}
   1ecb4:	b2c0      	uxtb	r0, r0
   1ecb6:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOTSUP;
   1ecb8:	f06f 0022 	mvn.w	r0, #34	; 0x22
   1ecbc:	e7fa      	b.n	1ecb4 <lll_entropy_get+0x14>
   1ecbe:	bf00      	nop
   1ecc0:	2000270c 	.word	0x2000270c

0001ecc4 <lll_resume>:
{
   1ecc4:	b507      	push	{r0, r1, r2, lr}
		      next->prio, &next->prepare_param, next->is_resume);
   1ecc6:	f890 3020 	ldrb.w	r3, [r0, #32]
	ret = prepare(next->is_abort_cb, next->abort_cb, next->prepare_cb,
   1ecca:	f003 0301 	and.w	r3, r3, #1
   1ecce:	e9cd 0300 	strd	r0, r3, [sp]
   1ecd2:	69c3      	ldr	r3, [r0, #28]
   1ecd4:	6902      	ldr	r2, [r0, #16]
   1ecd6:	e9d0 0105 	ldrd	r0, r1, [r0, #20]
   1ecda:	f7ff fe81 	bl	1e9e0 <prepare>
	LL_ASSERT(!ret || ret == -EINPROGRESS);
   1ecde:	b150      	cbz	r0, 1ecf6 <lll_resume+0x32>
   1ece0:	3044      	adds	r0, #68	; 0x44
   1ece2:	d008      	beq.n	1ecf6 <lll_resume+0x32>
   1ece4:	4805      	ldr	r0, [pc, #20]	; (1ecfc <lll_resume+0x38>)
   1ece6:	f009 fa2d 	bl	28144 <printk>
   1ecea:	4040      	eors	r0, r0
   1ecec:	f380 8811 	msr	BASEPRI, r0
   1ecf0:	f04f 0003 	mov.w	r0, #3
   1ecf4:	df02      	svc	2
}
   1ecf6:	b003      	add	sp, #12
   1ecf8:	f85d fb04 	ldr.w	pc, [sp], #4
   1ecfc:	000318e8 	.word	0x000318e8

0001ed00 <lll_disable>:
{
   1ed00:	b513      	push	{r0, r1, r4, lr}
   1ed02:	4b19      	ldr	r3, [pc, #100]	; (1ed68 <lll_disable+0x68>)
	if (!param || (param == event.curr.param)) {
   1ed04:	4604      	mov	r4, r0
   1ed06:	b110      	cbz	r0, 1ed0e <lll_disable+0xe>
   1ed08:	681a      	ldr	r2, [r3, #0]
   1ed0a:	4282      	cmp	r2, r0
   1ed0c:	d105      	bne.n	1ed1a <lll_disable+0x1a>
		if (event.curr.abort_cb && event.curr.param) {
   1ed0e:	689a      	ldr	r2, [r3, #8]
   1ed10:	b16a      	cbz	r2, 1ed2e <lll_disable+0x2e>
   1ed12:	6819      	ldr	r1, [r3, #0]
   1ed14:	b159      	cbz	r1, 1ed2e <lll_disable+0x2e>
			event.curr.abort_cb(NULL, event.curr.param);
   1ed16:	2000      	movs	r0, #0
   1ed18:	4790      	blx	r2
		u8_t idx = UINT8_MAX;
   1ed1a:	23ff      	movs	r3, #255	; 0xff
   1ed1c:	f88d 3007 	strb.w	r3, [sp, #7]
			next = ull_prepare_dequeue_iter(&idx);
   1ed20:	f10d 0007 	add.w	r0, sp, #7
   1ed24:	f7ff fda4 	bl	1e870 <ull_prepare_dequeue_iter>
		while (next) {
   1ed28:	b968      	cbnz	r0, 1ed46 <lll_disable+0x46>
}
   1ed2a:	b002      	add	sp, #8
   1ed2c:	bd10      	pop	{r4, pc}
			LL_ASSERT(!param);
   1ed2e:	2c00      	cmp	r4, #0
   1ed30:	d0f3      	beq.n	1ed1a <lll_disable+0x1a>
   1ed32:	480e      	ldr	r0, [pc, #56]	; (1ed6c <lll_disable+0x6c>)
   1ed34:	f009 fa06 	bl	28144 <printk>
   1ed38:	4040      	eors	r0, r0
   1ed3a:	f380 8811 	msr	BASEPRI, r0
   1ed3e:	f04f 0003 	mov.w	r0, #3
   1ed42:	df02      	svc	2
   1ed44:	e7e9      	b.n	1ed1a <lll_disable+0x1a>
			if (!next->is_aborted &&
   1ed46:	f890 3020 	ldrb.w	r3, [r0, #32]
   1ed4a:	079b      	lsls	r3, r3, #30
   1ed4c:	d4e8      	bmi.n	1ed20 <lll_disable+0x20>
   1ed4e:	68c1      	ldr	r1, [r0, #12]
   1ed50:	b10c      	cbz	r4, 1ed56 <lll_disable+0x56>
			    (!param || (param == next->prepare_param.param))) {
   1ed52:	428c      	cmp	r4, r1
   1ed54:	d1e4      	bne.n	1ed20 <lll_disable+0x20>
				next->is_aborted = 1;
   1ed56:	f890 3020 	ldrb.w	r3, [r0, #32]
   1ed5a:	f043 0302 	orr.w	r3, r3, #2
   1ed5e:	f880 3020 	strb.w	r3, [r0, #32]
				next->abort_cb(&next->prepare_param,
   1ed62:	6983      	ldr	r3, [r0, #24]
   1ed64:	4798      	blx	r3
   1ed66:	e7db      	b.n	1ed20 <lll_disable+0x20>
   1ed68:	20002710 	.word	0x20002710
   1ed6c:	0003186f 	.word	0x0003186f

0001ed70 <lll_done>:
{
   1ed70:	b510      	push	{r4, lr}
   1ed72:	4604      	mov	r4, r0
	struct lll_event *next = ull_prepare_dequeue_get();
   1ed74:	f7ff fc5a 	bl	1e62c <ull_prepare_dequeue_get>
	LL_ASSERT(!param || next);
   1ed78:	b15c      	cbz	r4, 1ed92 <lll_done+0x22>
   1ed7a:	b940      	cbnz	r0, 1ed8e <lll_done+0x1e>
   1ed7c:	4815      	ldr	r0, [pc, #84]	; (1edd4 <lll_done+0x64>)
   1ed7e:	f009 f9e1 	bl	28144 <printk>
   1ed82:	4040      	eors	r0, r0
   1ed84:	f380 8811 	msr	BASEPRI, r0
   1ed88:	f04f 0003 	mov.w	r0, #3
   1ed8c:	df02      	svc	2
		ull = HDR_ULL(((struct lll_hdr *)param)->parent);
   1ed8e:	6820      	ldr	r0, [r4, #0]
   1ed90:	e011      	b.n	1edb6 <lll_done+0x46>
		LL_ASSERT(event.curr.abort_cb);
   1ed92:	4c11      	ldr	r4, [pc, #68]	; (1edd8 <lll_done+0x68>)
   1ed94:	68a3      	ldr	r3, [r4, #8]
   1ed96:	b943      	cbnz	r3, 1edaa <lll_done+0x3a>
   1ed98:	4810      	ldr	r0, [pc, #64]	; (1eddc <lll_done+0x6c>)
   1ed9a:	f009 f9d3 	bl	28144 <printk>
   1ed9e:	4040      	eors	r0, r0
   1eda0:	f380 8811 	msr	BASEPRI, r0
   1eda4:	f04f 0003 	mov.w	r0, #3
   1eda8:	df02      	svc	2
		param = event.curr.param;
   1edaa:	6820      	ldr	r0, [r4, #0]
		event.curr.abort_cb = NULL;
   1edac:	2300      	movs	r3, #0
   1edae:	60a3      	str	r3, [r4, #8]
		event.curr.param = NULL;
   1edb0:	6023      	str	r3, [r4, #0]
		if (param) {
   1edb2:	b108      	cbz	r0, 1edb8 <lll_done+0x48>
			ull = HDR_ULL(((struct lll_hdr *)param)->parent);
   1edb4:	6800      	ldr	r0, [r0, #0]
   1edb6:	3010      	adds	r0, #16
	evdone = ull_event_done(ull);
   1edb8:	f7ff fd88 	bl	1e8cc <ull_event_done>
	LL_ASSERT(evdone);
   1edbc:	b940      	cbnz	r0, 1edd0 <lll_done+0x60>
   1edbe:	4808      	ldr	r0, [pc, #32]	; (1ede0 <lll_done+0x70>)
   1edc0:	f009 f9c0 	bl	28144 <printk>
   1edc4:	4040      	eors	r0, r0
   1edc6:	f380 8811 	msr	BASEPRI, r0
   1edca:	f04f 0003 	mov.w	r0, #3
   1edce:	df02      	svc	2
}
   1edd0:	2000      	movs	r0, #0
   1edd2:	bd10      	pop	{r4, pc}
   1edd4:	00031888 	.word	0x00031888
   1edd8:	20002710 	.word	0x20002710
   1eddc:	000318a9 	.word	0x000318a9
   1ede0:	000318cf 	.word	0x000318cf

0001ede4 <lll_is_done>:
	return !event.curr.abort_cb;
   1ede4:	4b02      	ldr	r3, [pc, #8]	; (1edf0 <lll_is_done+0xc>)
   1ede6:	6898      	ldr	r0, [r3, #8]
}
   1ede8:	fab0 f080 	clz	r0, r0
   1edec:	0940      	lsrs	r0, r0, #5
   1edee:	4770      	bx	lr
   1edf0:	20002710 	.word	0x20002710

0001edf4 <lll_clk_on>:
	err = clock_control_on(lll.clk_hf, NULL);
   1edf4:	4b01      	ldr	r3, [pc, #4]	; (1edfc <lll_clk_on+0x8>)
   1edf6:	6818      	ldr	r0, [r3, #0]
   1edf8:	f00d b829 	b.w	2be4e <clock_control_on.constprop.4>
   1edfc:	20002724 	.word	0x20002724

0001ee00 <lll_clk_off>:
	err = clock_control_off(lll.clk_hf, NULL);
   1ee00:	4b02      	ldr	r3, [pc, #8]	; (1ee0c <lll_clk_off+0xc>)
   1ee02:	6818      	ldr	r0, [r3, #0]
				    clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->off(dev, sys);
   1ee04:	6843      	ldr	r3, [r0, #4]
   1ee06:	2100      	movs	r1, #0
   1ee08:	685b      	ldr	r3, [r3, #4]
   1ee0a:	4718      	bx	r3
   1ee0c:	20002724 	.word	0x20002724

0001ee10 <lll_chan_set>:
	switch (chan) {
   1ee10:	2826      	cmp	r0, #38	; 0x26
{
   1ee12:	b510      	push	{r4, lr}
   1ee14:	4604      	mov	r4, r0
	switch (chan) {
   1ee16:	d00b      	beq.n	1ee30 <lll_chan_set+0x20>
   1ee18:	2827      	cmp	r0, #39	; 0x27
   1ee1a:	d00b      	beq.n	1ee34 <lll_chan_set+0x24>
   1ee1c:	2825      	cmp	r0, #37	; 0x25
   1ee1e:	d10b      	bne.n	1ee38 <lll_chan_set+0x28>
		radio_freq_chan_set(2);
   1ee20:	2002      	movs	r0, #2
		radio_freq_chan_set(26);
   1ee22:	f005 fdaf 	bl	24984 <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
   1ee26:	4620      	mov	r0, r4
}
   1ee28:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
   1ee2c:	f005 bdb0 	b.w	24990 <radio_whiten_iv_set>
		radio_freq_chan_set(26);
   1ee30:	201a      	movs	r0, #26
   1ee32:	e7f6      	b.n	1ee22 <lll_chan_set+0x12>
		radio_freq_chan_set(80);
   1ee34:	2050      	movs	r0, #80	; 0x50
   1ee36:	e7f4      	b.n	1ee22 <lll_chan_set+0x12>
		if (chan < 11) {
   1ee38:	280a      	cmp	r0, #10
   1ee3a:	d802      	bhi.n	1ee42 <lll_chan_set+0x32>
			radio_freq_chan_set(4 + (chan * 2U));
   1ee3c:	3002      	adds	r0, #2
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
   1ee3e:	0040      	lsls	r0, r0, #1
   1ee40:	e7ef      	b.n	1ee22 <lll_chan_set+0x12>
		} else if (chan < 40) {
   1ee42:	2827      	cmp	r0, #39	; 0x27
   1ee44:	d801      	bhi.n	1ee4a <lll_chan_set+0x3a>
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
   1ee46:	3003      	adds	r0, #3
   1ee48:	e7f9      	b.n	1ee3e <lll_chan_set+0x2e>
			LL_ASSERT(0);
   1ee4a:	4805      	ldr	r0, [pc, #20]	; (1ee60 <lll_chan_set+0x50>)
   1ee4c:	f009 f97a 	bl	28144 <printk>
   1ee50:	4040      	eors	r0, r0
   1ee52:	f380 8811 	msr	BASEPRI, r0
   1ee56:	f04f 0003 	mov.w	r0, #3
   1ee5a:	df02      	svc	2
   1ee5c:	e7e3      	b.n	1ee26 <lll_chan_set+0x16>
   1ee5e:	bf00      	nop
   1ee60:	000314f5 	.word	0x000314f5

0001ee64 <disabled_cb>:
		LL_ASSERT(!ret);
	}
}

static void disabled_cb(void *param)
{
   1ee64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct ll_adv_set *adv;
	struct node_rx_pdu *rx;
	struct node_rx_cc *cc;
	memq_link_t *link;

	adv = ((struct lll_hdr *)param)->parent;
   1ee66:	6805      	ldr	r5, [r0, #0]

	LL_ASSERT(adv->link_cc_free);
   1ee68:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
{
   1ee6c:	4606      	mov	r6, r0
	LL_ASSERT(adv->link_cc_free);
   1ee6e:	b943      	cbnz	r3, 1ee82 <disabled_cb+0x1e>
   1ee70:	481a      	ldr	r0, [pc, #104]	; (1eedc <disabled_cb+0x78>)
   1ee72:	f009 f967 	bl	28144 <printk>
   1ee76:	4040      	eors	r0, r0
   1ee78:	f380 8811 	msr	BASEPRI, r0
   1ee7c:	f04f 0003 	mov.w	r0, #3
   1ee80:	df02      	svc	2
	link = adv->link_cc_free;
	adv->link_cc_free = NULL;
   1ee82:	2300      	movs	r3, #0
	link = adv->link_cc_free;
   1ee84:	f8d5 70d0 	ldr.w	r7, [r5, #208]	; 0xd0
	adv->link_cc_free = NULL;
   1ee88:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0

	LL_ASSERT(adv->node_rx_cc_free);
   1ee8c:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
   1ee90:	b943      	cbnz	r3, 1eea4 <disabled_cb+0x40>
   1ee92:	4813      	ldr	r0, [pc, #76]	; (1eee0 <disabled_cb+0x7c>)
   1ee94:	f009 f956 	bl	28144 <printk>
   1ee98:	4040      	eors	r0, r0
   1ee9a:	f380 8811 	msr	BASEPRI, r0
   1ee9e:	f04f 0003 	mov.w	r0, #3
   1eea2:	df02      	svc	2
	rx = adv->node_rx_cc_free;
   1eea4:	f8d5 40d4 	ldr.w	r4, [r5, #212]	; 0xd4
	adv->node_rx_cc_free = NULL;
   1eea8:	2100      	movs	r1, #0

	rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   1eeaa:	2308      	movs	r3, #8
	adv->node_rx_cc_free = NULL;
   1eeac:	f8c5 10d4 	str.w	r1, [r5, #212]	; 0xd4
	rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   1eeb0:	7123      	strb	r3, [r4, #4]
	rx->hdr.handle = 0xffff;
   1eeb2:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1eeb6:	80e3      	strh	r3, [r4, #6]

	cc = (void *)rx->pdu;
	memset(cc, 0x00, sizeof(struct node_rx_cc));
   1eeb8:	221e      	movs	r2, #30
   1eeba:	f104 0020 	add.w	r0, r4, #32
   1eebe:	f00b faf0 	bl	2a4a2 <memset>
	cc->status = 0x3c;
   1eec2:	233c      	movs	r3, #60	; 0x3c
   1eec4:	f884 3020 	strb.w	r3, [r4, #32]

	ftr = &(rx->hdr.rx_ftr);
	ftr->param = param;
   1eec8:	60a6      	str	r6, [r4, #8]

	ll_rx_put(link, rx);
   1eeca:	4621      	mov	r1, r4
   1eecc:	4638      	mov	r0, r7
   1eece:	f7ff fa41 	bl	1e354 <ll_rx_put>
	ll_rx_sched();
}
   1eed2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	ll_rx_sched();
   1eed6:	f7ff ba47 	b.w	1e368 <ll_rx_sched>
   1eeda:	bf00      	nop
   1eedc:	000319e3 	.word	0x000319e3
   1eee0:	00031a07 	.word	0x00031a07

0001eee4 <ticker_cb>:
{
   1eee4:	b5f0      	push	{r4, r5, r6, r7, lr}
   1eee6:	461d      	mov	r5, r3
	if (IS_ENABLED(CONFIG_BT_TICKER_COMPATIBILITY_MODE) ||
   1eee8:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1eeec:	429a      	cmp	r2, r3
{
   1eeee:	b08b      	sub	sp, #44	; 0x2c
   1eef0:	4607      	mov	r7, r0
   1eef2:	460e      	mov	r6, r1
   1eef4:	4614      	mov	r4, r2
	if (IS_ENABLED(CONFIG_BT_TICKER_COMPATIBILITY_MODE) ||
   1eef6:	d025      	beq.n	1ef44 <ticker_cb+0x60>
	return ++hdr->ref;
   1eef8:	7c2b      	ldrb	r3, [r5, #16]
   1eefa:	3301      	adds	r3, #1
   1eefc:	b2db      	uxtb	r3, r3
   1eefe:	742b      	strb	r3, [r5, #16]
		LL_ASSERT(ref);
   1ef00:	b943      	cbnz	r3, 1ef14 <ticker_cb+0x30>
   1ef02:	482a      	ldr	r0, [pc, #168]	; (1efac <ticker_cb+0xc8>)
   1ef04:	f009 f91e 	bl	28144 <printk>
   1ef08:	4040      	eors	r0, r0
   1ef0a:	f380 8811 	msr	BASEPRI, r0
   1ef0e:	f04f 0003 	mov.w	r0, #3
   1ef12:	df02      	svc	2
		p.ticks_at_expire = ticks_at_expire;
   1ef14:	4826      	ldr	r0, [pc, #152]	; (1efb0 <ticker_cb+0xcc>)
	lll = &adv->lll;
   1ef16:	f105 031c 	add.w	r3, r5, #28
		p.param = lll;
   1ef1a:	60c3      	str	r3, [r0, #12]
		mfy.param = &p;
   1ef1c:	4b25      	ldr	r3, [pc, #148]	; (1efb4 <ticker_cb+0xd0>)
		p.lazy = lazy;
   1ef1e:	8104      	strh	r4, [r0, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   1ef20:	2200      	movs	r2, #0
		p.remainder = remainder;
   1ef22:	e9c0 7600 	strd	r7, r6, [r0]
		mfy.param = &p;
   1ef26:	6098      	str	r0, [r3, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   1ef28:	4611      	mov	r1, r2
   1ef2a:	2001      	movs	r0, #1
   1ef2c:	f7fc fc52 	bl	1b7d4 <mayfly_enqueue>
		LL_ASSERT(!ret);
   1ef30:	b140      	cbz	r0, 1ef44 <ticker_cb+0x60>
   1ef32:	4821      	ldr	r0, [pc, #132]	; (1efb8 <ticker_cb+0xd4>)
   1ef34:	f009 f906 	bl	28144 <printk>
   1ef38:	4040      	eors	r0, r0
   1ef3a:	f380 8811 	msr	BASEPRI, r0
   1ef3e:	f04f 0003 	mov.w	r0, #3
   1ef42:	df02      	svc	2
	if (!lll->is_hdcd)
   1ef44:	f895 4028 	ldrb.w	r4, [r5, #40]	; 0x28
   1ef48:	f014 0401 	ands.w	r4, r4, #1
   1ef4c:	d12b      	bne.n	1efa6 <ticker_cb+0xc2>
		lll_entropy_get(sizeof(random_delay), &random_delay);
   1ef4e:	a909      	add	r1, sp, #36	; 0x24
   1ef50:	2004      	movs	r0, #4
   1ef52:	f7ff fea5 	bl	1eca0 <lll_entropy_get>
		random_delay %= HAL_TICKER_US_TO_TICKS(10000);
   1ef56:	9909      	ldr	r1, [sp, #36]	; 0x24
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   1ef58:	9506      	str	r5, [sp, #24]
		random_delay %= HAL_TICKER_US_TO_TICKS(10000);
   1ef5a:	f240 1247 	movw	r2, #327	; 0x147
   1ef5e:	fbb1 f3f2 	udiv	r3, r1, r2
   1ef62:	fb02 1313 	mls	r3, r2, r3, r1
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   1ef66:	4a15      	ldr	r2, [pc, #84]	; (1efbc <ticker_cb+0xd8>)
   1ef68:	21e4      	movs	r1, #228	; 0xe4
   1ef6a:	1aaa      	subs	r2, r5, r2
   1ef6c:	fbb2 f2f1 	udiv	r2, r2, r1
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   1ef70:	4913      	ldr	r1, [pc, #76]	; (1efc0 <ticker_cb+0xdc>)
				    (TICKER_ID_ADV_BASE +
   1ef72:	3202      	adds	r2, #2
		random_delay += 1;
   1ef74:	3301      	adds	r3, #1
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   1ef76:	e9cd 4104 	strd	r4, r1, [sp, #16]
   1ef7a:	e9cd 4402 	strd	r4, r4, [sp, #8]
   1ef7e:	e9cd 4400 	strd	r4, r4, [sp]
   1ef82:	b2d2      	uxtb	r2, r2
   1ef84:	2101      	movs	r1, #1
   1ef86:	4620      	mov	r0, r4
		random_delay += 1;
   1ef88:	9309      	str	r3, [sp, #36]	; 0x24
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
   1ef8a:	f7fd f8df 	bl	1c14c <ticker_update>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1ef8e:	f030 0302 	bics.w	r3, r0, #2
   1ef92:	d008      	beq.n	1efa6 <ticker_cb+0xc2>
   1ef94:	480b      	ldr	r0, [pc, #44]	; (1efc4 <ticker_cb+0xe0>)
   1ef96:	f009 f8d5 	bl	28144 <printk>
   1ef9a:	4040      	eors	r0, r0
   1ef9c:	f380 8811 	msr	BASEPRI, r0
   1efa0:	f04f 0003 	mov.w	r0, #3
   1efa4:	df02      	svc	2
}
   1efa6:	b00b      	add	sp, #44	; 0x2c
   1efa8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1efaa:	bf00      	nop
   1efac:	00031a3e 	.word	0x00031a3e
   1efb0:	2000281c 	.word	0x2000281c
   1efb4:	2000fc98 	.word	0x2000fc98
   1efb8:	0003166e 	.word	0x0003166e
   1efbc:	20002738 	.word	0x20002738
   1efc0:	0001f0a9 	.word	0x0001f0a9
   1efc4:	00031a54 	.word	0x00031a54

0001efc8 <conn_release>:

static inline void conn_release(struct ll_adv_set *adv)
{
   1efc8:	b570      	push	{r4, r5, r6, lr}
	struct lll_conn *lll = adv->lll.conn;
   1efca:	6a45      	ldr	r5, [r0, #36]	; 0x24
	memq_link_t *link;

	LL_ASSERT(!lll->link_tx_free);
   1efcc:	6deb      	ldr	r3, [r5, #92]	; 0x5c
{
   1efce:	4604      	mov	r4, r0
	LL_ASSERT(!lll->link_tx_free);
   1efd0:	b143      	cbz	r3, 1efe4 <conn_release+0x1c>
   1efd2:	4816      	ldr	r0, [pc, #88]	; (1f02c <conn_release+0x64>)
   1efd4:	f009 f8b6 	bl	28144 <printk>
   1efd8:	4040      	eors	r0, r0
   1efda:	f380 8811 	msr	BASEPRI, r0
   1efde:	f04f 0003 	mov.w	r0, #3
   1efe2:	df02      	svc	2
	link = memq_deinit(&lll->memq_tx.head, &lll->memq_tx.tail);
   1efe4:	f105 0150 	add.w	r1, r5, #80	; 0x50
   1efe8:	f105 004c 	add.w	r0, r5, #76	; 0x4c
   1efec:	f00c fcf3 	bl	2b9d6 <memq_deinit>
	LL_ASSERT(link);
   1eff0:	4606      	mov	r6, r0
   1eff2:	b940      	cbnz	r0, 1f006 <conn_release+0x3e>
   1eff4:	480e      	ldr	r0, [pc, #56]	; (1f030 <conn_release+0x68>)
   1eff6:	f009 f8a5 	bl	28144 <printk>
   1effa:	4040      	eors	r0, r0
   1effc:	f380 8811 	msr	BASEPRI, r0
   1f000:	f04f 0003 	mov.w	r0, #3
   1f004:	df02      	svc	2
	lll->link_tx_free = link;

	ll_conn_release(lll->hdr.parent);
   1f006:	6828      	ldr	r0, [r5, #0]
	lll->link_tx_free = link;
   1f008:	65ee      	str	r6, [r5, #92]	; 0x5c
	adv->lll.conn = NULL;
   1f00a:	2500      	movs	r5, #0
	ll_conn_release(lll->hdr.parent);
   1f00c:	f001 fab2 	bl	20574 <ll_conn_release>

	ll_rx_release(adv->node_rx_cc_free);
   1f010:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
	adv->lll.conn = NULL;
   1f014:	6265      	str	r5, [r4, #36]	; 0x24
	ll_rx_release(adv->node_rx_cc_free);
   1f016:	f7ff f8fd 	bl	1e214 <ll_rx_release>
	adv->node_rx_cc_free = NULL;
   1f01a:	f8c4 50d4 	str.w	r5, [r4, #212]	; 0xd4
	ll_rx_link_release(adv->link_cc_free);
   1f01e:	f8d4 00d0 	ldr.w	r0, [r4, #208]	; 0xd0
   1f022:	f7ff f8eb 	bl	1e1fc <ll_rx_link_release>
	adv->link_cc_free = NULL;
   1f026:	f8c4 50d0 	str.w	r5, [r4, #208]	; 0xd0
}
   1f02a:	bd70      	pop	{r4, r5, r6, pc}
   1f02c:	000319a0 	.word	0x000319a0
   1f030:	00031657 	.word	0x00031657

0001f034 <ticker_op_stop_cb>:
{
   1f034:	b570      	push	{r4, r5, r6, lr}
   1f036:	460c      	mov	r4, r1
	if (status != TICKER_STATUS_SUCCESS) {
   1f038:	bb38      	cbnz	r0, 1f08a <ticker_op_stop_cb+0x56>
	mfy.param = &adv->lll;
   1f03a:	4b16      	ldr	r3, [pc, #88]	; (1f094 <ticker_op_stop_cb+0x60>)
   1f03c:	4d16      	ldr	r5, [pc, #88]	; (1f098 <ticker_op_stop_cb+0x64>)
   1f03e:	f101 021c 	add.w	r2, r1, #28
   1f042:	609a      	str	r2, [r3, #8]
	if (hdr->ref) {
   1f044:	7c0a      	ldrb	r2, [r1, #16]
   1f046:	461e      	mov	r6, r3
   1f048:	b302      	cbz	r2, 1f08c <ticker_op_stop_cb+0x58>
		LL_ASSERT(!hdr->disabled_cb);
   1f04a:	694b      	ldr	r3, [r1, #20]
   1f04c:	b143      	cbz	r3, 1f060 <ticker_op_stop_cb+0x2c>
   1f04e:	4813      	ldr	r0, [pc, #76]	; (1f09c <ticker_op_stop_cb+0x68>)
   1f050:	f009 f878 	bl	28144 <printk>
   1f054:	4040      	eors	r0, r0
   1f056:	f380 8811 	msr	BASEPRI, r0
   1f05a:	f04f 0003 	mov.w	r0, #3
   1f05e:	df02      	svc	2
		hdr->disabled_param = mfy.param;
   1f060:	68b3      	ldr	r3, [r6, #8]
		hdr->disabled_cb = disabled_cb;
   1f062:	e9c4 5305 	strd	r5, r3, [r4, #20]
		mfy.fp = lll_disable;
   1f066:	4b0e      	ldr	r3, [pc, #56]	; (1f0a0 <ticker_op_stop_cb+0x6c>)
   1f068:	60f3      	str	r3, [r6, #12]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   1f06a:	2200      	movs	r2, #0
   1f06c:	4b09      	ldr	r3, [pc, #36]	; (1f094 <ticker_op_stop_cb+0x60>)
   1f06e:	4611      	mov	r1, r2
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   1f070:	2002      	movs	r0, #2
   1f072:	f7fc fbaf 	bl	1b7d4 <mayfly_enqueue>
		LL_ASSERT(!ret);
   1f076:	b140      	cbz	r0, 1f08a <ticker_op_stop_cb+0x56>
   1f078:	480a      	ldr	r0, [pc, #40]	; (1f0a4 <ticker_op_stop_cb+0x70>)
   1f07a:	f009 f863 	bl	28144 <printk>
   1f07e:	4040      	eors	r0, r0
   1f080:	f380 8811 	msr	BASEPRI, r0
   1f084:	f04f 0003 	mov.w	r0, #3
   1f088:	df02      	svc	2
}
   1f08a:	bd70      	pop	{r4, r5, r6, pc}
		mfy.fp = disabled_cb;
   1f08c:	60dd      	str	r5, [r3, #12]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
   1f08e:	2101      	movs	r1, #1
   1f090:	e7ee      	b.n	1f070 <ticker_op_stop_cb+0x3c>
   1f092:	bf00      	nop
   1f094:	2000fca8 	.word	0x2000fca8
   1f098:	0001ee65 	.word	0x0001ee65
   1f09c:	00031a7f 	.word	0x00031a7f
   1f0a0:	0001ed01 	.word	0x0001ed01
   1f0a4:	0003166e 	.word	0x0003166e

0001f0a8 <ticker_op_update_cb>:
{
   1f0a8:	b510      	push	{r4, lr}
   1f0aa:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
   1f0ac:	b160      	cbz	r0, 1f0c8 <ticker_op_update_cb+0x20>
   1f0ae:	f7ff f9f3 	bl	1e498 <ull_disable_mark_get>
   1f0b2:	4284      	cmp	r4, r0
   1f0b4:	d008      	beq.n	1f0c8 <ticker_op_update_cb+0x20>
   1f0b6:	4805      	ldr	r0, [pc, #20]	; (1f0cc <ticker_op_update_cb+0x24>)
   1f0b8:	f009 f844 	bl	28144 <printk>
   1f0bc:	4040      	eors	r0, r0
   1f0be:	f380 8811 	msr	BASEPRI, r0
   1f0c2:	f04f 0003 	mov.w	r0, #3
   1f0c6:	df02      	svc	2
}
   1f0c8:	bd10      	pop	{r4, pc}
   1f0ca:	bf00      	nop
   1f0cc:	00031aa3 	.word	0x00031aa3

0001f0d0 <ticker_stop_cb>:
{
   1f0d0:	b537      	push	{r0, r1, r2, r4, r5, lr}
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   1f0d2:	4c13      	ldr	r4, [pc, #76]	; (1f120 <ticker_stop_cb+0x50>)
{
   1f0d4:	461d      	mov	r5, r3
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   1f0d6:	1b1c      	subs	r4, r3, r4
   1f0d8:	22e4      	movs	r2, #228	; 0xe4
   1f0da:	fbb4 f4f2 	udiv	r4, r4, r2
	LL_ASSERT(handle < BT_CTLR_ADV_MAX);
   1f0de:	b2a3      	uxth	r3, r4
   1f0e0:	b143      	cbz	r3, 1f0f4 <ticker_stop_cb+0x24>
   1f0e2:	4810      	ldr	r0, [pc, #64]	; (1f124 <ticker_stop_cb+0x54>)
   1f0e4:	f009 f82e 	bl	28144 <printk>
   1f0e8:	4040      	eors	r0, r0
   1f0ea:	f380 8811 	msr	BASEPRI, r0
   1f0ee:	f04f 0003 	mov.w	r0, #3
   1f0f2:	df02      	svc	2
			  TICKER_ID_ADV_BASE + handle,
   1f0f4:	1ca2      	adds	r2, r4, #2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
   1f0f6:	4b0c      	ldr	r3, [pc, #48]	; (1f128 <ticker_stop_cb+0x58>)
   1f0f8:	9500      	str	r5, [sp, #0]
   1f0fa:	b2d2      	uxtb	r2, r2
   1f0fc:	2101      	movs	r1, #1
   1f0fe:	2000      	movs	r0, #0
   1f100:	f7fd f86c 	bl	1c1dc <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1f104:	f030 0302 	bics.w	r3, r0, #2
   1f108:	d008      	beq.n	1f11c <ticker_stop_cb+0x4c>
   1f10a:	4808      	ldr	r0, [pc, #32]	; (1f12c <ticker_stop_cb+0x5c>)
   1f10c:	f009 f81a 	bl	28144 <printk>
   1f110:	4040      	eors	r0, r0
   1f112:	f380 8811 	msr	BASEPRI, r0
   1f116:	f04f 0003 	mov.w	r0, #3
   1f11a:	df02      	svc	2
}
   1f11c:	b003      	add	sp, #12
   1f11e:	bd30      	pop	{r4, r5, pc}
   1f120:	20002738 	.word	0x20002738
   1f124:	00031ae4 	.word	0x00031ae4
   1f128:	0001f035 	.word	0x0001f035
   1f12c:	00031a54 	.word	0x00031a54

0001f130 <ll_adv_params_set>:
{
   1f130:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	if (!adv || adv->is_enabled) {
   1f134:	4c44      	ldr	r4, [pc, #272]	; (1f248 <ll_adv_params_set+0x118>)
{
   1f136:	4699      	mov	r9, r3
	if (!adv || adv->is_enabled) {
   1f138:	f894 60cc 	ldrb.w	r6, [r4, #204]	; 0xcc
	u8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
   1f13c:	4b43      	ldr	r3, [pc, #268]	; (1f24c <ll_adv_params_set+0x11c>)
   1f13e:	9300      	str	r3, [sp, #0]
   1f140:	2301      	movs	r3, #1
	if (!adv || adv->is_enabled) {
   1f142:	401e      	ands	r6, r3
{
   1f144:	4617      	mov	r7, r2
	u8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
   1f146:	f88d 3004 	strb.w	r3, [sp, #4]
	if (!adv || adv->is_enabled) {
   1f14a:	d17a      	bne.n	1f242 <ll_adv_params_set+0x112>
		adv->interval = 0;
   1f14c:	4299      	cmp	r1, r3
	adv->lll.chan_map = chan_map;
   1f14e:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
   1f152:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
   1f156:	f362 0343 	bfi	r3, r2, #1, #3
   1f15a:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	adv->lll.filter_policy = filter_policy;
   1f15e:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   1f162:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
   1f166:	f362 0301 	bfi	r3, r2, #0, #2
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   1f16a:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
   1f16e:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
   1f172:	f04f 0527 	mov.w	r5, #39	; 0x27
   1f176:	f04f 032d 	mov.w	r3, #45	; 0x2d
   1f17a:	fb15 3502 	smlabb	r5, r5, r2, r3
	pdu->type = pdu_adv_type[adv_type];
   1f17e:	ab02      	add	r3, sp, #8
		adv->interval = 0;
   1f180:	bf08      	it	eq
   1f182:	2000      	moveq	r0, #0
	pdu->type = pdu_adv_type[adv_type];
   1f184:	4419      	add	r1, r3
   1f186:	f8a4 00d8 	strh.w	r0, [r4, #216]	; 0xd8
   1f18a:	f811 2c08 	ldrb.w	r2, [r1, #-8]
   1f18e:	5d63      	ldrb	r3, [r4, r5]
   1f190:	f362 0303 	bfi	r3, r2, #0, #4
	pdu->rfu = 0;
   1f194:	f366 1304 	bfi	r3, r6, #4, #1
	    ((pdu->type == PDU_ADV_TYPE_ADV_IND) ||
   1f198:	b2db      	uxtb	r3, r3
	if (IS_ENABLED(CONFIG_BT_CTLR_CHAN_SEL_2) &&
   1f19a:	f013 0f0e 	tst.w	r3, #14
   1f19e:	bf0c      	ite	eq
   1f1a0:	2201      	moveq	r2, #1
   1f1a2:	2200      	movne	r2, #0
   1f1a4:	f362 1345 	bfi	r3, r2, #5, #1
   1f1a8:	5563      	strb	r3, [r4, r5]
	adv->own_addr_type = own_addr_type;
   1f1aa:	f894 30da 	ldrb.w	r3, [r4, #218]	; 0xda
   1f1ae:	f367 0301 	bfi	r3, r7, #0, #2
   1f1b2:	f884 30da 	strb.w	r3, [r4, #218]	; 0xda
	if (adv->own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
   1f1b6:	b2db      	uxtb	r3, r3
   1f1b8:	079a      	lsls	r2, r3, #30
   1f1ba:	eb04 0805 	add.w	r8, r4, r5
   1f1be:	d509      	bpl.n	1f1d4 <ll_adv_params_set+0xa4>
		adv->id_addr_type = direct_addr_type;
   1f1c0:	f369 0382 	bfi	r3, r9, #2, #1
		memcpy(&adv->id_addr, direct_addr, BDADDR_SIZE);
   1f1c4:	2206      	movs	r2, #6
   1f1c6:	990a      	ldr	r1, [sp, #40]	; 0x28
		adv->id_addr_type = direct_addr_type;
   1f1c8:	f884 30da 	strb.w	r3, [r4, #218]	; 0xda
		memcpy(&adv->id_addr, direct_addr, BDADDR_SIZE);
   1f1cc:	f104 00dc 	add.w	r0, r4, #220	; 0xdc
   1f1d0:	f00b f93d 	bl	2a44e <memcpy>
	pdu->tx_addr = own_addr_type & 0x1;
   1f1d4:	5d61      	ldrb	r1, [r4, r5]
   1f1d6:	f007 0701 	and.w	r7, r7, #1
   1f1da:	f367 1186 	bfi	r1, r7, #6, #1
	pdu->rx_addr = 0;
   1f1de:	f36f 11c7 	bfc	r1, #7, #1
   1f1e2:	5561      	strb	r1, [r4, r5]
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   1f1e4:	b2c9      	uxtb	r1, r1
   1f1e6:	f001 030f 	and.w	r3, r1, #15
   1f1ea:	2b01      	cmp	r3, #1
   1f1ec:	d123      	bne.n	1f236 <ll_adv_params_set+0x106>
		pdu->rx_addr = direct_addr_type;
   1f1ee:	f369 11c7 	bfi	r1, r9, #7, #1
   1f1f2:	5561      	strb	r1, [r4, r5]
		memcpy(&pdu->direct_ind.tgt_addr[0], direct_addr, BDADDR_SIZE);
   1f1f4:	2206      	movs	r2, #6
   1f1f6:	990a      	ldr	r1, [sp, #40]	; 0x28
   1f1f8:	f108 0008 	add.w	r0, r8, #8
   1f1fc:	f00b f927 	bl	2a44e <memcpy>
		pdu->len = sizeof(struct pdu_adv_direct_ind);
   1f200:	230c      	movs	r3, #12
		pdu->len = BDADDR_SIZE;
   1f202:	f888 3001 	strb.w	r3, [r8, #1]
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   1f206:	f894 107c 	ldrb.w	r1, [r4, #124]	; 0x7c
   1f20a:	237d      	movs	r3, #125	; 0x7d
   1f20c:	2227      	movs	r2, #39	; 0x27
   1f20e:	fb12 3201 	smlabb	r2, r2, r1, r3
   1f212:	18a1      	adds	r1, r4, r2
	pdu->tx_addr = own_addr_type & 0x1;
   1f214:	5ca3      	ldrb	r3, [r4, r2]
   1f216:	f367 1386 	bfi	r3, r7, #6, #1
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
   1f21a:	f003 0340 	and.w	r3, r3, #64	; 0x40
   1f21e:	f043 0304 	orr.w	r3, r3, #4
   1f222:	54a3      	strb	r3, [r4, r2]
	if (pdu->len == 0) {
   1f224:	784b      	ldrb	r3, [r1, #1]
   1f226:	b913      	cbnz	r3, 1f22e <ll_adv_params_set+0xfe>
		pdu->len = BDADDR_SIZE;
   1f228:	2206      	movs	r2, #6
   1f22a:	704a      	strb	r2, [r1, #1]
	return 0;
   1f22c:	461e      	mov	r6, r3
}
   1f22e:	4630      	mov	r0, r6
   1f230:	b003      	add	sp, #12
   1f232:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	} else if (pdu->len == 0) {
   1f236:	f898 3001 	ldrb.w	r3, [r8, #1]
   1f23a:	2b00      	cmp	r3, #0
   1f23c:	d1e3      	bne.n	1f206 <ll_adv_params_set+0xd6>
		pdu->len = BDADDR_SIZE;
   1f23e:	2306      	movs	r3, #6
   1f240:	e7df      	b.n	1f202 <ll_adv_params_set+0xd2>
		return BT_HCI_ERR_CMD_DISALLOWED;
   1f242:	260c      	movs	r6, #12
   1f244:	e7f3      	b.n	1f22e <ll_adv_params_set+0xfe>
   1f246:	bf00      	nop
   1f248:	20002738 	.word	0x20002738
   1f24c:	02060100 	.word	0x02060100

0001f250 <ll_adv_data_set>:
{
   1f250:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   1f254:	4a29      	ldr	r2, [pc, #164]	; (1f2fc <ll_adv_data_set+0xac>)
   1f256:	f892 402c 	ldrb.w	r4, [r2, #44]	; 0x2c
   1f25a:	232d      	movs	r3, #45	; 0x2d
   1f25c:	4607      	mov	r7, r0
   1f25e:	2027      	movs	r0, #39	; 0x27
   1f260:	fb10 3004 	smlabb	r0, r0, r4, r3
   1f264:	4689      	mov	r9, r1
	if ((prev->type == PDU_ADV_TYPE_DIRECT_IND) ||
   1f266:	f812 c000 	ldrb.w	ip, [r2, r0]
   1f26a:	f00c 030f 	and.w	r3, ip, #15
   1f26e:	2b01      	cmp	r3, #1
   1f270:	eb02 0100 	add.w	r1, r2, r0
   1f274:	4615      	mov	r5, r2
   1f276:	d03e      	beq.n	1f2f6 <ll_adv_data_set+0xa6>
	if (pdu->first == pdu->last) {
   1f278:	f892 302b 	ldrb.w	r3, [r2, #43]	; 0x2b
   1f27c:	42a3      	cmp	r3, r4
   1f27e:	d104      	bne.n	1f28a <ll_adv_data_set+0x3a>
		last = pdu->last + 1;
   1f280:	3401      	adds	r4, #1
   1f282:	b2e4      	uxtb	r4, r4
			last = 0U;
   1f284:	2c02      	cmp	r4, #2
   1f286:	bf08      	it	eq
   1f288:	2400      	moveq	r4, #0
	return (void *)pdu->pdu[last];
   1f28a:	2627      	movs	r6, #39	; 0x27
   1f28c:	232d      	movs	r3, #45	; 0x2d
   1f28e:	fb16 3304 	smlabb	r3, r6, r4, r3
   1f292:	eb05 0803 	add.w	r8, r5, r3
	pdu->type = prev->type;
   1f296:	5cee      	ldrb	r6, [r5, r3]
   1f298:	f36c 0603 	bfi	r6, ip, #0, #4
	pdu->rfu = 0U;
   1f29c:	f36f 1604 	bfc	r6, #4, #1
   1f2a0:	54ee      	strb	r6, [r5, r3]
		pdu->chan_sel = prev->chan_sel;
   1f2a2:	5c16      	ldrb	r6, [r2, r0]
   1f2a4:	f815 c003 	ldrb.w	ip, [r5, r3]
   1f2a8:	f3c6 1640 	ubfx	r6, r6, #5, #1
   1f2ac:	f366 1c45 	bfi	ip, r6, #5, #1
   1f2b0:	f805 c003 	strb.w	ip, [r5, r3]
	pdu->tx_addr = prev->tx_addr;
   1f2b4:	5c16      	ldrb	r6, [r2, r0]
   1f2b6:	fa5f fc8c 	uxtb.w	ip, ip
   1f2ba:	f3c6 1680 	ubfx	r6, r6, #6, #1
   1f2be:	f366 1c86 	bfi	ip, r6, #6, #1
   1f2c2:	f805 c003 	strb.w	ip, [r5, r3]
	pdu->rx_addr = prev->rx_addr;
   1f2c6:	5c12      	ldrb	r2, [r2, r0]
   1f2c8:	fa5f f08c 	uxtb.w	r0, ip
   1f2cc:	09d2      	lsrs	r2, r2, #7
   1f2ce:	f362 10c7 	bfi	r0, r2, #7, #1
   1f2d2:	54e8      	strb	r0, [r5, r3]
	memcpy(&pdu->adv_ind.addr[0], &prev->adv_ind.addr[0], BDADDR_SIZE);
   1f2d4:	2206      	movs	r2, #6
   1f2d6:	3102      	adds	r1, #2
   1f2d8:	f108 0002 	add.w	r0, r8, #2
   1f2dc:	f00b f8b7 	bl	2a44e <memcpy>
	memcpy(&pdu->adv_ind.data[0], data, len);
   1f2e0:	463a      	mov	r2, r7
   1f2e2:	4649      	mov	r1, r9
   1f2e4:	f108 0008 	add.w	r0, r8, #8
	pdu->len = BDADDR_SIZE + len;
   1f2e8:	3706      	adds	r7, #6
	memcpy(&pdu->adv_ind.data[0], data, len);
   1f2ea:	f00b f8b0 	bl	2a44e <memcpy>
	pdu->len = BDADDR_SIZE + len;
   1f2ee:	f888 7001 	strb.w	r7, [r8, #1]
	pdu->last = idx;
   1f2f2:	f885 402c 	strb.w	r4, [r5, #44]	; 0x2c
}
   1f2f6:	2000      	movs	r0, #0
   1f2f8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1f2fc:	20002738 	.word	0x20002738

0001f300 <ll_adv_scan_rsp_set>:
{
   1f300:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   1f304:	4a1e      	ldr	r2, [pc, #120]	; (1f380 <ll_adv_scan_rsp_set+0x80>)
   1f306:	f892 407c 	ldrb.w	r4, [r2, #124]	; 0x7c
   1f30a:	237d      	movs	r3, #125	; 0x7d
   1f30c:	f04f 0c27 	mov.w	ip, #39	; 0x27
   1f310:	fb1c 3c04 	smlabb	ip, ip, r4, r3
	if (pdu->first == pdu->last) {
   1f314:	f892 307b 	ldrb.w	r3, [r2, #123]	; 0x7b
   1f318:	42a3      	cmp	r3, r4
   1f31a:	4688      	mov	r8, r1
   1f31c:	4607      	mov	r7, r0
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
   1f31e:	eb02 010c 	add.w	r1, r2, ip
	if (pdu->first == pdu->last) {
   1f322:	4615      	mov	r5, r2
   1f324:	d104      	bne.n	1f330 <ll_adv_scan_rsp_set+0x30>
		last = pdu->last + 1;
   1f326:	3401      	adds	r4, #1
   1f328:	b2e4      	uxtb	r4, r4
			last = 0U;
   1f32a:	2c02      	cmp	r4, #2
   1f32c:	bf08      	it	eq
   1f32e:	2400      	moveq	r4, #0
	return (void *)pdu->pdu[last];
   1f330:	2027      	movs	r0, #39	; 0x27
   1f332:	237d      	movs	r3, #125	; 0x7d
   1f334:	fb10 3304 	smlabb	r3, r0, r4, r3
   1f338:	18ee      	adds	r6, r5, r3
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
   1f33a:	5ce8      	ldrb	r0, [r5, r3]
   1f33c:	f020 003f 	bic.w	r0, r0, #63	; 0x3f
   1f340:	f040 0004 	orr.w	r0, r0, #4
   1f344:	54e8      	strb	r0, [r5, r3]
	pdu->tx_addr = prev->tx_addr;
   1f346:	f812 000c 	ldrb.w	r0, [r2, ip]
   1f34a:	5cea      	ldrb	r2, [r5, r3]
   1f34c:	f3c0 1080 	ubfx	r0, r0, #6, #1
   1f350:	f360 1286 	bfi	r2, r0, #6, #1
	pdu->rx_addr = 0;
   1f354:	f36f 12c7 	bfc	r2, #7, #1
   1f358:	54ea      	strb	r2, [r5, r3]
	pdu->len = BDADDR_SIZE + len;
   1f35a:	1dbb      	adds	r3, r7, #6
   1f35c:	7073      	strb	r3, [r6, #1]
	memcpy(&pdu->scan_rsp.addr[0], &prev->scan_rsp.addr[0], BDADDR_SIZE);
   1f35e:	2206      	movs	r2, #6
   1f360:	3102      	adds	r1, #2
   1f362:	1cb0      	adds	r0, r6, #2
   1f364:	f00b f873 	bl	2a44e <memcpy>
	memcpy(&pdu->scan_rsp.data[0], data, len);
   1f368:	463a      	mov	r2, r7
   1f36a:	4641      	mov	r1, r8
   1f36c:	f106 0008 	add.w	r0, r6, #8
   1f370:	f00b f86d 	bl	2a44e <memcpy>
	pdu->last = idx;
   1f374:	f885 407c 	strb.w	r4, [r5, #124]	; 0x7c
}
   1f378:	2000      	movs	r0, #0
   1f37a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1f37e:	bf00      	nop
   1f380:	20002738 	.word	0x20002738

0001f384 <ull_adv_handle_get>:
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   1f384:	4b03      	ldr	r3, [pc, #12]	; (1f394 <ull_adv_handle_get+0x10>)
   1f386:	1ac0      	subs	r0, r0, r3
   1f388:	23e4      	movs	r3, #228	; 0xe4
   1f38a:	fbb0 f0f3 	udiv	r0, r0, r3
}
   1f38e:	b280      	uxth	r0, r0
   1f390:	4770      	bx	lr
   1f392:	bf00      	nop
   1f394:	20002738 	.word	0x20002738

0001f398 <ull_adv_lll_handle_get>:
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
   1f398:	6800      	ldr	r0, [r0, #0]
   1f39a:	4b03      	ldr	r3, [pc, #12]	; (1f3a8 <ull_adv_lll_handle_get+0x10>)
   1f39c:	1ac0      	subs	r0, r0, r3
   1f39e:	23e4      	movs	r3, #228	; 0xe4
   1f3a0:	fbb0 f0f3 	udiv	r0, r0, r3
}
   1f3a4:	b280      	uxth	r0, r0
   1f3a6:	4770      	bx	lr
   1f3a8:	20002738 	.word	0x20002738

0001f3ac <ull_adv_is_enabled_get>:
	if (handle >= BT_CTLR_ADV_MAX) {
   1f3ac:	b938      	cbnz	r0, 1f3be <ull_adv_is_enabled_get+0x12>
	if (!adv || !adv->is_enabled) {
   1f3ae:	4805      	ldr	r0, [pc, #20]	; (1f3c4 <ull_adv_is_enabled_get+0x18>)
   1f3b0:	f890 30cc 	ldrb.w	r3, [r0, #204]	; 0xcc
	return &ll_adv[handle];
   1f3b4:	f013 0f01 	tst.w	r3, #1
   1f3b8:	bf08      	it	eq
   1f3ba:	2000      	moveq	r0, #0
   1f3bc:	4770      	bx	lr
		return NULL;
   1f3be:	2000      	movs	r0, #0
}
   1f3c0:	4770      	bx	lr
   1f3c2:	bf00      	nop
   1f3c4:	20002738 	.word	0x20002738

0001f3c8 <disable.constprop.5>:
#endif /* CONFIG_BT_PERIPHERAL */

static inline u8_t disable(u16_t handle)
   1f3c8:	b530      	push	{r4, r5, lr}
   1f3ca:	b085      	sub	sp, #20
{
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   1f3cc:	2302      	movs	r3, #2
	struct ll_adv_set *adv;
	void *mark;
	u32_t ret;

	adv = ull_adv_is_enabled_get(handle);
   1f3ce:	2000      	movs	r0, #0
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   1f3d0:	9303      	str	r3, [sp, #12]
	adv = ull_adv_is_enabled_get(handle);
   1f3d2:	f7ff ffeb 	bl	1f3ac <ull_adv_is_enabled_get>
	if (!adv) {
   1f3d6:	4604      	mov	r4, r0
   1f3d8:	b910      	cbnz	r0, 1f3e0 <disable.constprop.5+0x18>
	ret = ull_ticker_status_take(ret, &ret_cb);
	if (ret) {
		mark = ull_disable_mark(adv);
		LL_ASSERT(mark == adv);

		return BT_HCI_ERR_CMD_DISALLOWED;
   1f3da:	200c      	movs	r0, #12
		ull_filter_adv_scan_state_cb(0);
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */

	return 0;
}
   1f3dc:	b005      	add	sp, #20
   1f3de:	bd30      	pop	{r4, r5, pc}
	mark = ull_disable_mark(adv);
   1f3e0:	f7ff f844 	bl	1e46c <ull_disable_mark>
	LL_ASSERT(mark == adv);
   1f3e4:	4284      	cmp	r4, r0
   1f3e6:	d008      	beq.n	1f3fa <disable.constprop.5+0x32>
   1f3e8:	4832      	ldr	r0, [pc, #200]	; (1f4b4 <disable.constprop.5+0xec>)
   1f3ea:	f008 feab 	bl	28144 <printk>
   1f3ee:	4040      	eors	r0, r0
   1f3f0:	f380 8811 	msr	BASEPRI, r0
   1f3f4:	f04f 0003 	mov.w	r0, #3
   1f3f8:	df02      	svc	2
	if (adv->lll.is_hdcd) {
   1f3fa:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
   1f3fe:	f013 0f01 	tst.w	r3, #1
   1f402:	ad03      	add	r5, sp, #12
   1f404:	d01b      	beq.n	1f43e <disable.constprop.5+0x76>
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   1f406:	2103      	movs	r1, #3
   1f408:	9500      	str	r5, [sp, #0]
   1f40a:	4b2b      	ldr	r3, [pc, #172]	; (1f4b8 <disable.constprop.5+0xf0>)
   1f40c:	2201      	movs	r2, #1
   1f40e:	2000      	movs	r0, #0
   1f410:	f7fc fee4 	bl	1c1dc <ticker_stop>
		ret = ull_ticker_status_take(ret, &ret_cb);
   1f414:	4629      	mov	r1, r5
   1f416:	f7ff f81d 	bl	1e454 <ull_ticker_status_take>
		if (ret) {
   1f41a:	b170      	cbz	r0, 1f43a <disable.constprop.5+0x72>
		mark = ull_disable_mark(adv);
   1f41c:	4620      	mov	r0, r4
   1f41e:	f7ff f825 	bl	1e46c <ull_disable_mark>
		LL_ASSERT(mark == adv);
   1f422:	4284      	cmp	r4, r0
   1f424:	d0d9      	beq.n	1f3da <disable.constprop.5+0x12>
   1f426:	4823      	ldr	r0, [pc, #140]	; (1f4b4 <disable.constprop.5+0xec>)
   1f428:	f008 fe8c 	bl	28144 <printk>
   1f42c:	4040      	eors	r0, r0
   1f42e:	f380 8811 	msr	BASEPRI, r0
   1f432:	f04f 0003 	mov.w	r0, #3
   1f436:	df02      	svc	2
   1f438:	e7cf      	b.n	1f3da <disable.constprop.5+0x12>
		ret_cb = TICKER_STATUS_BUSY;
   1f43a:	2302      	movs	r3, #2
   1f43c:	9303      	str	r3, [sp, #12]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   1f43e:	2103      	movs	r1, #3
   1f440:	9500      	str	r5, [sp, #0]
   1f442:	4b1d      	ldr	r3, [pc, #116]	; (1f4b8 <disable.constprop.5+0xf0>)
   1f444:	2202      	movs	r2, #2
   1f446:	2000      	movs	r0, #0
   1f448:	f7fc fec8 	bl	1c1dc <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
   1f44c:	4629      	mov	r1, r5
   1f44e:	f7ff f801 	bl	1e454 <ull_ticker_status_take>
	if (ret) {
   1f452:	2800      	cmp	r0, #0
   1f454:	d1e2      	bne.n	1f41c <disable.constprop.5+0x54>
	ret = ull_disable(&adv->lll);
   1f456:	f104 001c 	add.w	r0, r4, #28
   1f45a:	f7ff f83f 	bl	1e4dc <ull_disable>
	LL_ASSERT(!ret);
   1f45e:	b140      	cbz	r0, 1f472 <disable.constprop.5+0xaa>
   1f460:	4816      	ldr	r0, [pc, #88]	; (1f4bc <disable.constprop.5+0xf4>)
   1f462:	f008 fe6f 	bl	28144 <printk>
   1f466:	4040      	eors	r0, r0
   1f468:	f380 8811 	msr	BASEPRI, r0
   1f46c:	f04f 0003 	mov.w	r0, #3
   1f470:	df02      	svc	2
	mark = ull_disable_unmark(adv);
   1f472:	4620      	mov	r0, r4
   1f474:	f7ff f802 	bl	1e47c <ull_disable_unmark>
	LL_ASSERT(mark == adv);
   1f478:	4284      	cmp	r4, r0
   1f47a:	d008      	beq.n	1f48e <disable.constprop.5+0xc6>
   1f47c:	480d      	ldr	r0, [pc, #52]	; (1f4b4 <disable.constprop.5+0xec>)
   1f47e:	f008 fe61 	bl	28144 <printk>
   1f482:	4040      	eors	r0, r0
   1f484:	f380 8811 	msr	BASEPRI, r0
   1f488:	f04f 0003 	mov.w	r0, #3
   1f48c:	df02      	svc	2
	if (adv->lll.conn) {
   1f48e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1f490:	b113      	cbz	r3, 1f498 <disable.constprop.5+0xd0>
		conn_release(adv);
   1f492:	4620      	mov	r0, r4
   1f494:	f7ff fd98 	bl	1efc8 <conn_release>
	adv->is_enabled = 0U;
   1f498:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
   1f49c:	f36f 0300 	bfc	r3, #0, #1
   1f4a0:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
	if (IS_ENABLED(CONFIG_BT_OBSERVER) && !ull_scan_is_enabled_get(0)) {
   1f4a4:	2000      	movs	r0, #0
   1f4a6:	f000 fc03 	bl	1fcb0 <ull_scan_is_enabled_get>
   1f4aa:	b908      	cbnz	r0, 1f4b0 <disable.constprop.5+0xe8>
		ull_filter_adv_scan_state_cb(0);
   1f4ac:	f004 fa92 	bl	239d4 <ull_filter_adv_scan_state_cb>
	return 0;
   1f4b0:	2000      	movs	r0, #0
   1f4b2:	e793      	b.n	1f3dc <disable.constprop.5+0x14>
   1f4b4:	000319c5 	.word	0x000319c5
   1f4b8:	0001e449 	.word	0x0001e449
   1f4bc:	0003166e 	.word	0x0003166e

0001f4c0 <isr_cleanup>:

	isr_cleanup(param);
}

static void isr_cleanup(void *param)
{
   1f4c0:	b508      	push	{r3, lr}
	int err;

	radio_isr_set(isr_race, param);
   1f4c2:	4601      	mov	r1, r0
   1f4c4:	480b      	ldr	r0, [pc, #44]	; (1f4f4 <isr_cleanup+0x34>)
   1f4c6:	f005 f9e3 	bl	24890 <radio_isr_set>
	radio_tmr_stop();
   1f4ca:	f005 fc5b 	bl	24d84 <radio_tmr_stop>

	err = lll_clk_off();
   1f4ce:	f7ff fc97 	bl	1ee00 <lll_clk_off>
	LL_ASSERT(!err || err == -EBUSY);
   1f4d2:	b150      	cbz	r0, 1f4ea <isr_cleanup+0x2a>
   1f4d4:	3010      	adds	r0, #16
   1f4d6:	d008      	beq.n	1f4ea <isr_cleanup+0x2a>
   1f4d8:	4807      	ldr	r0, [pc, #28]	; (1f4f8 <isr_cleanup+0x38>)
   1f4da:	f008 fe33 	bl	28144 <printk>
   1f4de:	4040      	eors	r0, r0
   1f4e0:	f380 8811 	msr	BASEPRI, r0
   1f4e4:	f04f 0003 	mov.w	r0, #3
   1f4e8:	df02      	svc	2

	lll_done(NULL);
   1f4ea:	2000      	movs	r0, #0
}
   1f4ec:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
   1f4f0:	f7ff bc3e 	b.w	1ed70 <lll_done>
   1f4f4:	0002befb 	.word	0x0002befb
   1f4f8:	00031b3d 	.word	0x00031b3d

0001f4fc <isr_tx>:
{
   1f4fc:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1f4fe:	4604      	mov	r4, r0
	radio_status_reset();
   1f500:	f005 facc 	bl	24a9c <radio_status_reset>
	radio_tmr_status_reset();
   1f504:	f005 fb9a 	bl	24c3c <radio_tmr_status_reset>
	radio_isr_set(isr_rx, param);
   1f508:	4621      	mov	r1, r4
   1f50a:	481e      	ldr	r0, [pc, #120]	; (1f584 <isr_tx+0x88>)
   1f50c:	f005 f9c0 	bl	24890 <radio_isr_set>
	radio_tmr_tifs_set(EVENT_IFS_US);
   1f510:	2096      	movs	r0, #150	; 0x96
   1f512:	f005 fba3 	bl	24c5c <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
   1f516:	2300      	movs	r3, #0
   1f518:	461a      	mov	r2, r3
   1f51a:	4619      	mov	r1, r3
   1f51c:	4618      	mov	r0, r3
   1f51e:	f005 fb07 	bl	24b30 <radio_switch_complete_and_tx>
	radio_pkt_rx_set(radio_pkt_scratch_get());
   1f522:	f005 faf5 	bl	24b10 <radio_pkt_scratch_get>
   1f526:	f005 fa8f 	bl	24a48 <radio_pkt_rx_set>
	LL_ASSERT(!radio_is_ready());
   1f52a:	f005 fac3 	bl	24ab4 <radio_is_ready>
   1f52e:	b140      	cbz	r0, 1f542 <isr_tx+0x46>
   1f530:	4815      	ldr	r0, [pc, #84]	; (1f588 <isr_tx+0x8c>)
   1f532:	f008 fe07 	bl	28144 <printk>
   1f536:	4040      	eors	r0, r0
   1f538:	f380 8811 	msr	BASEPRI, r0
   1f53c:	f04f 0003 	mov.w	r0, #3
   1f540:	df02      	svc	2
	if (ull_filter_lll_rl_enabled()) {
   1f542:	f004 fff7 	bl	24534 <ull_filter_lll_rl_enabled>
   1f546:	b140      	cbz	r0, 1f55a <isr_tx+0x5e>
		u8_t count, *irks = ull_filter_lll_irks_get(&count);
   1f548:	f10d 0007 	add.w	r0, sp, #7
   1f54c:	f004 feb6 	bl	242bc <ull_filter_lll_irks_get>
		radio_ar_configure(count, irks);
   1f550:	4601      	mov	r1, r0
   1f552:	f89d 0007 	ldrb.w	r0, [sp, #7]
   1f556:	f005 fd09 	bl	24f6c <radio_ar_configure>
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   1f55a:	f005 fc65 	bl	24e28 <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(0, 0);
   1f55e:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   1f560:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(0, 0);
   1f562:	4608      	mov	r0, r1
   1f564:	f00d faa8 	bl	2cab8 <radio_rx_chain_delay_get>
	hcto -= radio_tx_chain_delay_get(0, 0);
   1f568:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(0, 0);
   1f56a:	4605      	mov	r5, r0
	hcto -= radio_tx_chain_delay_get(0, 0);
   1f56c:	4608      	mov	r0, r1
   1f56e:	f00d fa9f 	bl	2cab0 <radio_tx_chain_delay_get>
   1f572:	442c      	add	r4, r5
   1f574:	34c3      	adds	r4, #195	; 0xc3
	radio_tmr_hcto_configure(hcto);
   1f576:	1a20      	subs	r0, r4, r0
   1f578:	f005 fc10 	bl	24d9c <radio_tmr_hcto_configure>
	radio_tmr_end_capture();
   1f57c:	f005 fc46 	bl	24e0c <radio_tmr_end_capture>
}
   1f580:	b003      	add	sp, #12
   1f582:	bd30      	pop	{r4, r5, pc}
   1f584:	0001f631 	.word	0x0001f631
   1f588:	00031b62 	.word	0x00031b62

0001f58c <is_abort_cb>:
	if (next != curr) {
   1f58c:	4282      	cmp	r2, r0
{
   1f58e:	b508      	push	{r3, lr}
	if (next != curr) {
   1f590:	d018      	beq.n	1f5c4 <is_abort_cb+0x38>
		} else if (lll->is_hdcd) {
   1f592:	7b12      	ldrb	r2, [r2, #12]
   1f594:	07d2      	lsls	r2, r2, #31
   1f596:	d522      	bpl.n	1f5de <is_abort_cb+0x52>
			*resume_cb = resume_prepare_cb;
   1f598:	4a12      	ldr	r2, [pc, #72]	; (1f5e4 <is_abort_cb+0x58>)
   1f59a:	601a      	str	r2, [r3, #0]
			*resume_prio = 0; /* TODO: */
   1f59c:	9b02      	ldr	r3, [sp, #8]
   1f59e:	2200      	movs	r2, #0
   1f5a0:	601a      	str	r2, [r3, #0]
			err = lll_clk_on();
   1f5a2:	f7ff fc27 	bl	1edf4 <lll_clk_on>
			LL_ASSERT(!err || err == -EINPROGRESS);
   1f5a6:	b150      	cbz	r0, 1f5be <is_abort_cb+0x32>
   1f5a8:	3044      	adds	r0, #68	; 0x44
   1f5aa:	d008      	beq.n	1f5be <is_abort_cb+0x32>
   1f5ac:	480e      	ldr	r0, [pc, #56]	; (1f5e8 <is_abort_cb+0x5c>)
   1f5ae:	f008 fdc9 	bl	28144 <printk>
   1f5b2:	4040      	eors	r0, r0
   1f5b4:	f380 8811 	msr	BASEPRI, r0
   1f5b8:	f04f 0003 	mov.w	r0, #3
   1f5bc:	df02      	svc	2
   1f5be:	f06f 000a 	mvn.w	r0, #10
   1f5c2:	e00b      	b.n	1f5dc <is_abort_cb+0x50>
	return lll_adv_pdu_latest_get(&lll->scan_rsp, is_modified);
}

static inline struct pdu_adv *lll_adv_data_curr_get(struct lll_adv *lll)
{
	return (void *)lll->adv_data.pdu[lll->adv_data.first];
   1f5c4:	7bd3      	ldrb	r3, [r2, #15]
   1f5c6:	2127      	movs	r1, #39	; 0x27
   1f5c8:	fb01 2203 	mla	r2, r1, r3, r2
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   1f5cc:	7c53      	ldrb	r3, [r2, #17]
   1f5ce:	f003 030f 	and.w	r3, r3, #15
   1f5d2:	2b01      	cmp	r3, #1
		return 0;
   1f5d4:	bf14      	ite	ne
   1f5d6:	f06f 0047 	mvnne.w	r0, #71	; 0x47
   1f5da:	2000      	moveq	r0, #0
}
   1f5dc:	bd08      	pop	{r3, pc}
			return -ECANCELED;
   1f5de:	f06f 0047 	mvn.w	r0, #71	; 0x47
   1f5e2:	e7fb      	b.n	1f5dc <is_abort_cb+0x50>
   1f5e4:	0002bf6d 	.word	0x0002bf6d
   1f5e8:	00031b18 	.word	0x00031b18

0001f5ec <abort_cb>:
{
   1f5ec:	b510      	push	{r4, lr}
   1f5ee:	460c      	mov	r4, r1
	if (!prepare_param) {
   1f5f0:	b930      	cbnz	r0, 1f600 <abort_cb+0x14>
		radio_isr_set(isr_abort, param);
   1f5f2:	480d      	ldr	r0, [pc, #52]	; (1f628 <abort_cb+0x3c>)
   1f5f4:	f005 f94c 	bl	24890 <radio_isr_set>
}
   1f5f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
   1f5fc:	f005 ba3c 	b.w	24a78 <radio_disable>
	err = lll_clk_off();
   1f600:	f7ff fbfe 	bl	1ee00 <lll_clk_off>
	LL_ASSERT(!err || err == -EBUSY);
   1f604:	b150      	cbz	r0, 1f61c <abort_cb+0x30>
   1f606:	3010      	adds	r0, #16
   1f608:	d008      	beq.n	1f61c <abort_cb+0x30>
   1f60a:	4808      	ldr	r0, [pc, #32]	; (1f62c <abort_cb+0x40>)
   1f60c:	f008 fd9a 	bl	28144 <printk>
   1f610:	4040      	eors	r0, r0
   1f612:	f380 8811 	msr	BASEPRI, r0
   1f616:	f04f 0003 	mov.w	r0, #3
   1f61a:	df02      	svc	2
	lll_done(param);
   1f61c:	4620      	mov	r0, r4
}
   1f61e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
   1f622:	f7ff bba5 	b.w	1ed70 <lll_done>
   1f626:	bf00      	nop
   1f628:	0002beff 	.word	0x0002beff
   1f62c:	00031b3d 	.word	0x00031b3d

0001f630 <isr_rx>:
{
   1f630:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   1f634:	4604      	mov	r4, r0
	trx_done = radio_is_done();
   1f636:	f005 fa47 	bl	24ac8 <radio_is_done>
   1f63a:	b2c5      	uxtb	r5, r0
	if (trx_done) {
   1f63c:	2d00      	cmp	r5, #0
   1f63e:	d04d      	beq.n	1f6dc <isr_rx+0xac>
		crc_ok = radio_crc_is_valid();
   1f640:	f005 fa58 	bl	24af4 <radio_crc_is_valid>
   1f644:	fa5f f880 	uxtb.w	r8, r0
		devmatch_ok = radio_filter_has_match();
   1f648:	f005 fadc 	bl	24c04 <radio_filter_has_match>
   1f64c:	fa5f f980 	uxtb.w	r9, r0
		devmatch_id = radio_filter_match_get();
   1f650:	f005 fae2 	bl	24c18 <radio_filter_match_get>
		irkmatch_ok = radio_ar_has_match();
   1f654:	f005 fcc8 	bl	24fe8 <radio_ar_has_match>
   1f658:	b2c6      	uxtb	r6, r0
		irkmatch_id = radio_ar_match_get();
   1f65a:	f005 fcb3 	bl	24fc4 <radio_ar_match_get>
   1f65e:	b2c7      	uxtb	r7, r0
		rssi_ready = radio_rssi_is_ready();
   1f660:	f005 fa98 	bl	24b94 <radio_rssi_is_ready>
	radio_status_reset();
   1f664:	f005 fa1a 	bl	24a9c <radio_status_reset>
	radio_tmr_status_reset();
   1f668:	f005 fae8 	bl	24c3c <radio_tmr_status_reset>
	radio_filter_status_reset();
   1f66c:	f005 fac2 	bl	24bf4 <radio_filter_status_reset>
	radio_ar_status_reset();
   1f670:	f005 fcae 	bl	24fd0 <radio_ar_status_reset>
	radio_rssi_status_reset();
   1f674:	f005 fa86 	bl	24b84 <radio_rssi_status_reset>
	if (!trx_done) {
   1f678:	2d00      	cmp	r5, #0
   1f67a:	f000 8124 	beq.w	1f8c6 <isr_rx+0x296>
	if (crc_ok) {
   1f67e:	f1b8 0f00 	cmp.w	r8, #0
   1f682:	f000 8120 	beq.w	1f8c6 <isr_rx+0x296>
{
	struct pdu_adv *pdu_rx, *pdu_adv;

#if defined(CONFIG_BT_CTLR_PRIVACY)
	/* An IRK match implies address resolution enabled */
	u8_t rl_idx = irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
   1f686:	b376      	cbz	r6, 1f6e6 <isr_rx+0xb6>
   1f688:	4638      	mov	r0, r7
   1f68a:	f004 fe69 	bl	24360 <ull_filter_lll_rl_irk_idx>
   1f68e:	f88d 0007 	strb.w	r0, [sp, #7]
				    FILTER_IDX_NONE;
#else
	u8_t rl_idx = FILTER_IDX_NONE;
#endif /* CONFIG_BT_CTLR_PRIVACY */

	pdu_rx = (void *)radio_pkt_scratch_get();
   1f692:	f005 fa3d 	bl	24b10 <radio_pkt_scratch_get>
   1f696:	7be2      	ldrb	r2, [r4, #15]
   1f698:	4605      	mov	r5, r0
	pdu_adv = lll_adv_data_curr_get(lll);

	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
   1f69a:	7800      	ldrb	r0, [r0, #0]
   1f69c:	2311      	movs	r3, #17
   1f69e:	2727      	movs	r7, #39	; 0x27
   1f6a0:	fb17 3702 	smlabb	r7, r7, r2, r3
   1f6a4:	f000 030f 	and.w	r3, r0, #15
   1f6a8:	2b03      	cmp	r3, #3
   1f6aa:	eb04 0807 	add.w	r8, r4, r7
   1f6ae:	d153      	bne.n	1f758 <isr_rx+0x128>
   1f6b0:	786b      	ldrb	r3, [r5, #1]
   1f6b2:	2b0c      	cmp	r3, #12
   1f6b4:	f040 8107 	bne.w	1f8c6 <isr_rx+0x296>
	    (pdu_rx->len == sizeof(struct pdu_adv_scan_req)) &&
	    (pdu_adv->type != PDU_ADV_TYPE_DIRECT_IND) &&
   1f6b8:	5de3      	ldrb	r3, [r4, r7]
	    (pdu_rx->len == sizeof(struct pdu_adv_scan_req)) &&
   1f6ba:	f003 030f 	and.w	r3, r3, #15
   1f6be:	2b01      	cmp	r3, #1
   1f6c0:	f000 8101 	beq.w	1f8c6 <isr_rx+0x296>
static inline bool isr_rx_sr_check(struct lll_adv *lll, struct pdu_adv *adv,
				   struct pdu_adv *sr, u8_t devmatch_ok,
				   u8_t *rl_idx)
{
#if defined(CONFIG_BT_CTLR_PRIVACY)
	return ((((lll->filter_policy & 0x01) == 0) &&
   1f6c4:	7b63      	ldrb	r3, [r4, #13]
		 ull_filter_lll_rl_addr_allowed(sr->tx_addr,
						sr->scan_req.scan_addr,
						rl_idx)) ||
		(((lll->filter_policy & 0x01) != 0) &&
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
   1f6c6:	07da      	lsls	r2, r3, #31
   1f6c8:	d50f      	bpl.n	1f6ea <isr_rx+0xba>
		(((lll->filter_policy & 0x01) != 0) &&
   1f6ca:	f1b9 0f00 	cmp.w	r9, #0
   1f6ce:	d114      	bne.n	1f6fa <isr_rx+0xca>
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
   1f6d0:	f89d 0007 	ldrb.w	r0, [sp, #7]
   1f6d4:	f004 fe7e 	bl	243d4 <ull_filter_lll_irk_whitelisted>
   1f6d8:	b978      	cbnz	r0, 1f6fa <isr_rx+0xca>
   1f6da:	e03d      	b.n	1f758 <isr_rx+0x128>
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready = 0U;
   1f6dc:	462e      	mov	r6, r5
   1f6de:	46a9      	mov	r9, r5
   1f6e0:	46a8      	mov	r8, r5
		devmatch_id = irkmatch_id = 0xFF;
   1f6e2:	27ff      	movs	r7, #255	; 0xff
   1f6e4:	e7be      	b.n	1f664 <isr_rx+0x34>
	u8_t rl_idx = irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
   1f6e6:	20ff      	movs	r0, #255	; 0xff
   1f6e8:	e7d1      	b.n	1f68e <isr_rx+0x5e>
		 ull_filter_lll_rl_addr_allowed(sr->tx_addr,
   1f6ea:	f10d 0207 	add.w	r2, sp, #7
   1f6ee:	1ca9      	adds	r1, r5, #2
   1f6f0:	f3c0 1080 	ubfx	r0, r0, #6, #1
   1f6f4:	f004 fec2 	bl	2447c <ull_filter_lll_rl_addr_allowed>
	return ((((lll->filter_policy & 0x01) == 0) &&
   1f6f8:	b358      	cbz	r0, 1f752 <isr_rx+0x122>
}

static inline bool isr_rx_sr_adva_check(struct pdu_adv *adv,
					struct pdu_adv *sr)
{
	return (adv->tx_addr == sr->rx_addr) &&
   1f6fa:	5de3      	ldrb	r3, [r4, r7]
   1f6fc:	782a      	ldrb	r2, [r5, #0]
   1f6fe:	f3c3 1380 	ubfx	r3, r3, #6, #1
   1f702:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
   1f706:	d127      	bne.n	1f758 <isr_rx+0x128>
		!memcmp(adv->adv_ind.addr, sr->scan_req.adv_addr, BDADDR_SIZE);
   1f708:	2206      	movs	r2, #6
   1f70a:	f105 0108 	add.w	r1, r5, #8
   1f70e:	f108 0002 	add.w	r0, r8, #2
   1f712:	f00a fe75 	bl	2a400 <memcmp>
	    (pdu_adv->type != PDU_ADV_TYPE_DIRECT_IND) &&
   1f716:	b9f8      	cbnz	r0, 1f758 <isr_rx+0x128>
		radio_isr_set(isr_done, lll);
   1f718:	4621      	mov	r1, r4
   1f71a:	486e      	ldr	r0, [pc, #440]	; (1f8d4 <isr_rx+0x2a4>)
   1f71c:	f005 f8b8 	bl	24890 <radio_isr_set>
		radio_switch_complete_and_disable();
   1f720:	f005 fa12 	bl	24b48 <radio_switch_complete_and_disable>
}

static inline struct pdu_adv *lll_adv_scan_rsp_curr_get(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.first];
   1f724:	f894 005f 	ldrb.w	r0, [r4, #95]	; 0x5f
   1f728:	2327      	movs	r3, #39	; 0x27
   1f72a:	fb03 4000 	mla	r0, r3, r0, r4
		radio_pkt_tx_set(lll_adv_scan_rsp_curr_get(lll));
   1f72e:	3061      	adds	r0, #97	; 0x61
   1f730:	f005 f990 	bl	24a54 <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
   1f734:	f005 f9be 	bl	24ab4 <radio_is_ready>
   1f738:	b140      	cbz	r0, 1f74c <isr_rx+0x11c>
   1f73a:	4867      	ldr	r0, [pc, #412]	; (1f8d8 <isr_rx+0x2a8>)
   1f73c:	f008 fd02 	bl	28144 <printk>
   1f740:	4040      	eors	r0, r0
   1f742:	f380 8811 	msr	BASEPRI, r0
   1f746:	f04f 0003 	mov.w	r0, #3
   1f74a:	df02      	svc	2
}
   1f74c:	b003      	add	sp, #12
   1f74e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		(((lll->filter_policy & 0x01) != 0) &&
   1f752:	7b63      	ldrb	r3, [r4, #13]
						rl_idx)) ||
   1f754:	07db      	lsls	r3, r3, #31
   1f756:	d4b8      	bmi.n	1f6ca <isr_rx+0x9a>
	} else if ((pdu_rx->type == PDU_ADV_TYPE_CONNECT_IND) &&
   1f758:	7828      	ldrb	r0, [r5, #0]
   1f75a:	f000 030f 	and.w	r3, r0, #15
   1f75e:	2b05      	cmp	r3, #5
   1f760:	f040 80b1 	bne.w	1f8c6 <isr_rx+0x296>
   1f764:	786b      	ldrb	r3, [r5, #1]
   1f766:	2b22      	cmp	r3, #34	; 0x22
   1f768:	f040 80ad 	bne.w	1f8c6 <isr_rx+0x296>
static inline bool isr_rx_ci_check(struct lll_adv *lll, struct pdu_adv *adv,
				   struct pdu_adv *ci, u8_t devmatch_ok,
				   u8_t *rl_idx)
{
	/* LL 4.3.2: filter policy shall be ignored for directed adv */
	if (adv->type == PDU_ADV_TYPE_DIRECT_IND) {
   1f76c:	5de3      	ldrb	r3, [r4, r7]
   1f76e:	f003 030f 	and.w	r3, r3, #15
   1f772:	2b01      	cmp	r3, #1
   1f774:	f040 8088 	bne.w	1f888 <isr_rx+0x258>
#if defined(CONFIG_BT_CTLR_PRIVACY)
		return ull_filter_lll_rl_addr_allowed(ci->tx_addr,
						      ci->connect_ind.init_addr,
   1f778:	f105 0902 	add.w	r9, r5, #2
		return ull_filter_lll_rl_addr_allowed(ci->tx_addr,
   1f77c:	f10d 0207 	add.w	r2, sp, #7
   1f780:	4649      	mov	r1, r9
   1f782:	f3c0 1080 	ubfx	r0, r0, #6, #1
   1f786:	f004 fe79 	bl	2447c <ull_filter_lll_rl_addr_allowed>
						      rl_idx) &&
#else
		return (1) &&
#endif
		       isr_rx_ci_adva_check(adv, ci) &&
   1f78a:	b908      	cbnz	r0, 1f790 <isr_rx+0x160>
	return ((((lll->filter_policy & 0x02) == 0) &&
		 ull_filter_lll_rl_addr_allowed(ci->tx_addr,
						ci->connect_ind.init_addr,
						rl_idx)) ||
		(((lll->filter_policy & 0x02) != 0) &&
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
   1f78c:	2000      	movs	r0, #0
   1f78e:	e00d      	b.n	1f7ac <isr_rx+0x17c>
		       isr_rx_ci_adva_check(adv, ci) &&
   1f790:	4629      	mov	r1, r5
   1f792:	4640      	mov	r0, r8
   1f794:	f00c fbc6 	bl	2bf24 <isr_rx_ci_adva_check>
						      rl_idx) &&
   1f798:	2800      	cmp	r0, #0
   1f79a:	d0f7      	beq.n	1f78c <isr_rx+0x15c>
		       isr_rx_ci_tgta_check(lll, adv, ci, *rl_idx);
   1f79c:	f89d 3007 	ldrb.w	r3, [sp, #7]
static inline bool isr_rx_ci_tgta_check(struct lll_adv *lll,
					struct pdu_adv *adv, struct pdu_adv *ci,
					u8_t rl_idx)
{
#if defined(CONFIG_BT_CTLR_PRIVACY)
	if (rl_idx != FILTER_IDX_NONE) {
   1f7a0:	2bff      	cmp	r3, #255	; 0xff
   1f7a2:	d060      	beq.n	1f866 <isr_rx+0x236>
		return rl_idx == lll->rl_idx;
   1f7a4:	7ba0      	ldrb	r0, [r4, #14]
   1f7a6:	1ac7      	subs	r7, r0, r3
   1f7a8:	4278      	negs	r0, r7
   1f7aa:	4178      	adcs	r0, r7
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
   1f7ac:	f000 0001 	and.w	r0, r0, #1
		   (pdu_rx->len == sizeof(struct pdu_adv_connect_ind)) &&
   1f7b0:	2800      	cmp	r0, #0
   1f7b2:	f000 8088 	beq.w	1f8c6 <isr_rx+0x296>
				   &rl_idx) &&
   1f7b6:	68a3      	ldr	r3, [r4, #8]
   1f7b8:	2b00      	cmp	r3, #0
   1f7ba:	f000 8084 	beq.w	1f8c6 <isr_rx+0x296>
			rx = ull_pdu_rx_alloc_peek(4);
   1f7be:	2004      	movs	r0, #4
   1f7c0:	f7fe febc 	bl	1e53c <ull_pdu_rx_alloc_peek>
		if (!rx) {
   1f7c4:	2800      	cmp	r0, #0
   1f7c6:	d07e      	beq.n	1f8c6 <isr_rx+0x296>
		radio_isr_set(isr_abort, lll);
   1f7c8:	4621      	mov	r1, r4
   1f7ca:	4844      	ldr	r0, [pc, #272]	; (1f8dc <isr_rx+0x2ac>)
   1f7cc:	f005 f860 	bl	24890 <radio_isr_set>
		radio_disable();
   1f7d0:	f005 f952 	bl	24a78 <radio_disable>
		LL_ASSERT(!radio_is_ready());
   1f7d4:	f005 f96e 	bl	24ab4 <radio_is_ready>
   1f7d8:	b140      	cbz	r0, 1f7ec <isr_rx+0x1bc>
   1f7da:	483f      	ldr	r0, [pc, #252]	; (1f8d8 <isr_rx+0x2a8>)
   1f7dc:	f008 fcb2 	bl	28144 <printk>
   1f7e0:	4040      	eors	r0, r0
   1f7e2:	f380 8811 	msr	BASEPRI, r0
   1f7e6:	f04f 0003 	mov.w	r0, #3
   1f7ea:	df02      	svc	2
	int ret = !!hdr->is_stop;
   1f7ec:	7923      	ldrb	r3, [r4, #4]
	hdr->is_stop = 1U;
   1f7ee:	f043 0201 	orr.w	r2, r3, #1
		LL_ASSERT(!ret);
   1f7f2:	07db      	lsls	r3, r3, #31
   1f7f4:	7122      	strb	r2, [r4, #4]
   1f7f6:	d508      	bpl.n	1f80a <isr_rx+0x1da>
   1f7f8:	4839      	ldr	r0, [pc, #228]	; (1f8e0 <isr_rx+0x2b0>)
   1f7fa:	f008 fca3 	bl	28144 <printk>
   1f7fe:	4040      	eors	r0, r0
   1f800:	f380 8811 	msr	BASEPRI, r0
   1f804:	f04f 0003 	mov.w	r0, #3
   1f808:	df02      	svc	2
		rx = ull_pdu_rx_alloc();
   1f80a:	f7fe feaf 	bl	1e56c <ull_pdu_rx_alloc>
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   1f80e:	2308      	movs	r3, #8
		rx = ull_pdu_rx_alloc();
   1f810:	4607      	mov	r7, r0
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
   1f812:	7103      	strb	r3, [r0, #4]
		rx->hdr.handle = 0xffff;
   1f814:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1f818:	80c3      	strh	r3, [r0, #6]
		memcpy(rx->pdu, pdu_rx, (offsetof(struct pdu_adv, connect_ind) +
   1f81a:	2224      	movs	r2, #36	; 0x24
   1f81c:	4629      	mov	r1, r5
   1f81e:	3020      	adds	r0, #32
   1f820:	f00a fe15 	bl	2a44e <memcpy>
		ftr->param = lll;
   1f824:	60bc      	str	r4, [r7, #8]
		ftr->ticks_anchor = radio_tmr_start_get();
   1f826:	f005 faa7 	bl	24d78 <radio_tmr_start_get>
   1f82a:	6138      	str	r0, [r7, #16]
		ftr->us_radio_end = radio_tmr_end_get() -
   1f82c:	f005 faf6 	bl	24e1c <radio_tmr_end_get>
				    radio_tx_chain_delay_get(0, 0);
   1f830:	2100      	movs	r1, #0
		ftr->us_radio_end = radio_tmr_end_get() -
   1f832:	4604      	mov	r4, r0
				    radio_tx_chain_delay_get(0, 0);
   1f834:	4608      	mov	r0, r1
   1f836:	f00d f93b 	bl	2cab0 <radio_tx_chain_delay_get>
		ftr->us_radio_rdy = radio_rx_ready_delay_get(0, 0);
   1f83a:	2100      	movs	r1, #0
		ftr->us_radio_end = radio_tmr_end_get() -
   1f83c:	1a20      	subs	r0, r4, r0
   1f83e:	6178      	str	r0, [r7, #20]
		ftr->us_radio_rdy = radio_rx_ready_delay_get(0, 0);
   1f840:	4608      	mov	r0, r1
   1f842:	f00d f937 	bl	2cab4 <radio_rx_ready_delay_get>
   1f846:	61b8      	str	r0, [r7, #24]
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
   1f848:	2e00      	cmp	r6, #0
   1f84a:	d03a      	beq.n	1f8c2 <isr_rx+0x292>
   1f84c:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1f850:	777b      	strb	r3, [r7, #29]
			ftr->extra = ull_pdu_rx_alloc();
   1f852:	f7fe fe8b 	bl	1e56c <ull_pdu_rx_alloc>
		ull_rx_put(rx->hdr.link, rx);
   1f856:	4639      	mov	r1, r7
			ftr->extra = ull_pdu_rx_alloc();
   1f858:	60f8      	str	r0, [r7, #12]
		ull_rx_put(rx->hdr.link, rx);
   1f85a:	6838      	ldr	r0, [r7, #0]
   1f85c:	f7fe fe9c 	bl	1e598 <ull_rx_put>
		ull_rx_sched();
   1f860:	f7fe feaa 	bl	1e5b8 <ull_rx_sched>
		if (!err) {
   1f864:	e772      	b.n	1f74c <isr_rx+0x11c>
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */
	return (adv->rx_addr == ci->tx_addr) &&
   1f866:	782b      	ldrb	r3, [r5, #0]
   1f868:	5de2      	ldrb	r2, [r4, r7]
   1f86a:	f3c3 1380 	ubfx	r3, r3, #6, #1
   1f86e:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
   1f872:	d18b      	bne.n	1f78c <isr_rx+0x15c>
	       !memcmp(adv->direct_ind.tgt_addr, ci->connect_ind.init_addr,
   1f874:	2206      	movs	r2, #6
   1f876:	4649      	mov	r1, r9
   1f878:	f108 0008 	add.w	r0, r8, #8
   1f87c:	f00a fdc0 	bl	2a400 <memcmp>
	return (adv->rx_addr == ci->tx_addr) &&
   1f880:	fab0 f080 	clz	r0, r0
   1f884:	0940      	lsrs	r0, r0, #5
   1f886:	e791      	b.n	1f7ac <isr_rx+0x17c>
	return ((((lll->filter_policy & 0x02) == 0) &&
   1f888:	7b63      	ldrb	r3, [r4, #13]
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
   1f88a:	0799      	lsls	r1, r3, #30
   1f88c:	d508      	bpl.n	1f8a0 <isr_rx+0x270>
		(((lll->filter_policy & 0x02) != 0) &&
   1f88e:	f1b9 0f00 	cmp.w	r9, #0
   1f892:	d10d      	bne.n	1f8b0 <isr_rx+0x280>
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
   1f894:	f89d 0007 	ldrb.w	r0, [sp, #7]
   1f898:	f004 fd9c 	bl	243d4 <ull_filter_lll_irk_whitelisted>
   1f89c:	b940      	cbnz	r0, 1f8b0 <isr_rx+0x280>
   1f89e:	e775      	b.n	1f78c <isr_rx+0x15c>
		 ull_filter_lll_rl_addr_allowed(ci->tx_addr,
   1f8a0:	f10d 0207 	add.w	r2, sp, #7
   1f8a4:	1ca9      	adds	r1, r5, #2
   1f8a6:	f3c0 1080 	ubfx	r0, r0, #6, #1
   1f8aa:	f004 fde7 	bl	2447c <ull_filter_lll_rl_addr_allowed>
	return ((((lll->filter_policy & 0x02) == 0) &&
   1f8ae:	b120      	cbz	r0, 1f8ba <isr_rx+0x28a>
	       isr_rx_ci_adva_check(adv, ci);
   1f8b0:	4629      	mov	r1, r5
   1f8b2:	4640      	mov	r0, r8
   1f8b4:	f00c fb36 	bl	2bf24 <isr_rx_ci_adva_check>
   1f8b8:	e778      	b.n	1f7ac <isr_rx+0x17c>
		(((lll->filter_policy & 0x02) != 0) &&
   1f8ba:	7b63      	ldrb	r3, [r4, #13]
						rl_idx)) ||
   1f8bc:	079a      	lsls	r2, r3, #30
   1f8be:	d4e6      	bmi.n	1f88e <isr_rx+0x25e>
   1f8c0:	e764      	b.n	1f78c <isr_rx+0x15c>
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
   1f8c2:	23ff      	movs	r3, #255	; 0xff
   1f8c4:	e7c4      	b.n	1f850 <isr_rx+0x220>
	radio_isr_set(isr_done, param);
   1f8c6:	4621      	mov	r1, r4
   1f8c8:	4802      	ldr	r0, [pc, #8]	; (1f8d4 <isr_rx+0x2a4>)
   1f8ca:	f004 ffe1 	bl	24890 <radio_isr_set>
	radio_disable();
   1f8ce:	f005 f8d3 	bl	24a78 <radio_disable>
   1f8d2:	e73b      	b.n	1f74c <isr_rx+0x11c>
   1f8d4:	0002bf95 	.word	0x0002bf95
   1f8d8:	00031b62 	.word	0x00031b62
   1f8dc:	0002beff 	.word	0x0002beff
   1f8e0:	0003166e 	.word	0x0003166e

0001f8e4 <chan_prepare>:
{
   1f8e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	first = pdu->first;
   1f8e6:	7bc3      	ldrb	r3, [r0, #15]
	if (first != pdu->last) {
   1f8e8:	7c05      	ldrb	r5, [r0, #16]
   1f8ea:	42ab      	cmp	r3, r5
   1f8ec:	4604      	mov	r4, r0
   1f8ee:	d05c      	beq.n	1f9aa <chan_prepare+0xc6>
		first += 1U;
   1f8f0:	1c5d      	adds	r5, r3, #1
   1f8f2:	b2ed      	uxtb	r5, r5
			first = 0U;
   1f8f4:	2d02      	cmp	r5, #2
   1f8f6:	bf08      	it	eq
   1f8f8:	2500      	moveq	r5, #0
		pdu->first = first;
   1f8fa:	73c5      	strb	r5, [r0, #15]
		*is_modified = 1U;
   1f8fc:	f04f 0e01 	mov.w	lr, #1
	first = pdu->first;
   1f900:	4620      	mov	r0, r4
	if (first != pdu->last) {
   1f902:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
	first = pdu->first;
   1f906:	f810 2f5f 	ldrb.w	r2, [r0, #95]!
	return (void *)pdu->pdu[first];
   1f90a:	2127      	movs	r1, #39	; 0x27
   1f90c:	f04f 0c02 	mov.w	ip, #2
   1f910:	f104 060f 	add.w	r6, r4, #15
   1f914:	fb11 c505 	smlabb	r5, r1, r5, ip
	if (first != pdu->last) {
   1f918:	4293      	cmp	r3, r2
	return (void *)pdu->pdu[first];
   1f91a:	eb06 0705 	add.w	r7, r6, r5
	if (first != pdu->last) {
   1f91e:	d047      	beq.n	1f9b0 <chan_prepare+0xcc>
		first += 1U;
   1f920:	3201      	adds	r2, #1
   1f922:	b2d3      	uxtb	r3, r2
			first = 0U;
   1f924:	4563      	cmp	r3, ip
   1f926:	bf08      	it	eq
   1f928:	2300      	moveq	r3, #0
		pdu->first = first;
   1f92a:	f884 305f 	strb.w	r3, [r4, #95]	; 0x5f
	return (void *)pdu->pdu[first];
   1f92e:	fb11 c303 	smlabb	r3, r1, r3, ip
   1f932:	4418      	add	r0, r3
		memcpy(&scan_pdu->scan_rsp.addr[0],
   1f934:	2206      	movs	r2, #6
   1f936:	1cb9      	adds	r1, r7, #2
   1f938:	3002      	adds	r0, #2
   1f93a:	f00a fd88 	bl	2a44e <memcpy>
	radio_pkt_tx_set(pdu);
   1f93e:	4638      	mov	r0, r7
   1f940:	f005 f888 	bl	24a54 <radio_pkt_tx_set>
	if ((pdu->type != PDU_ADV_TYPE_NONCONN_IND) &&
   1f944:	5d73      	ldrb	r3, [r6, r5]
   1f946:	f003 030f 	and.w	r3, r3, #15
   1f94a:	2b02      	cmp	r3, #2
		radio_isr_set(isr_tx, lll);
   1f94c:	4621      	mov	r1, r4
	if ((pdu->type != PDU_ADV_TYPE_NONCONN_IND) &&
   1f94e:	d036      	beq.n	1f9be <chan_prepare+0xda>
		radio_isr_set(isr_tx, lll);
   1f950:	481e      	ldr	r0, [pc, #120]	; (1f9cc <chan_prepare+0xe8>)
   1f952:	f004 ff9d 	bl	24890 <radio_isr_set>
		radio_tmr_tifs_set(EVENT_IFS_US);
   1f956:	2096      	movs	r0, #150	; 0x96
   1f958:	f005 f980 	bl	24c5c <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
   1f95c:	2000      	movs	r0, #0
   1f95e:	f005 f8db 	bl	24b18 <radio_switch_complete_and_rx>
	chan = find_lsb_set(lll->chan_map_curr);
   1f962:	7b23      	ldrb	r3, [r4, #12]
   1f964:	f3c3 1302 	ubfx	r3, r3, #4, #3
   1f968:	2b00      	cmp	r3, #0
   1f96a:	fa93 f0a3 	rbit	r0, r3
   1f96e:	fab0 f080 	clz	r0, r0
   1f972:	bf08      	it	eq
   1f974:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
	LL_ASSERT(chan);
   1f978:	1c45      	adds	r5, r0, #1
   1f97a:	d108      	bne.n	1f98e <chan_prepare+0xaa>
   1f97c:	4814      	ldr	r0, [pc, #80]	; (1f9d0 <chan_prepare+0xec>)
   1f97e:	f008 fbe1 	bl	28144 <printk>
   1f982:	4040      	eors	r0, r0
   1f984:	f380 8811 	msr	BASEPRI, r0
   1f988:	f04f 0003 	mov.w	r0, #3
   1f98c:	df02      	svc	2
	lll->chan_map_curr &= (lll->chan_map_curr - 1);
   1f98e:	7b23      	ldrb	r3, [r4, #12]
   1f990:	f3c3 1202 	ubfx	r2, r3, #4, #3
   1f994:	1e51      	subs	r1, r2, #1
   1f996:	400a      	ands	r2, r1
   1f998:	f362 1306 	bfi	r3, r2, #4, #3
   1f99c:	7323      	strb	r3, [r4, #12]
	lll_chan_set(36 + chan);
   1f99e:	f105 0024 	add.w	r0, r5, #36	; 0x24
}
   1f9a2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	lll_chan_set(36 + chan);
   1f9a6:	f7ff ba33 	b.w	1ee10 <lll_chan_set>
	u8_t upd = 0U;
   1f9aa:	f04f 0e00 	mov.w	lr, #0
   1f9ae:	e7a7      	b.n	1f900 <chan_prepare+0x1c>
	if (upd) {
   1f9b0:	f1be 0f00 	cmp.w	lr, #0
   1f9b4:	d0c3      	beq.n	1f93e <chan_prepare+0x5a>
   1f9b6:	fb11 c103 	smlabb	r1, r1, r3, ip
   1f9ba:	4408      	add	r0, r1
   1f9bc:	e7ba      	b.n	1f934 <chan_prepare+0x50>
		radio_isr_set(isr_done, lll);
   1f9be:	4805      	ldr	r0, [pc, #20]	; (1f9d4 <chan_prepare+0xf0>)
   1f9c0:	f004 ff66 	bl	24890 <radio_isr_set>
		radio_switch_complete_and_disable();
   1f9c4:	f005 f8c0 	bl	24b48 <radio_switch_complete_and_disable>
   1f9c8:	e7cb      	b.n	1f962 <chan_prepare+0x7e>
   1f9ca:	bf00      	nop
   1f9cc:	0001f4fd 	.word	0x0001f4fd
   1f9d0:	00031b01 	.word	0x00031b01
   1f9d4:	0002bf95 	.word	0x0002bf95

0001f9d8 <prepare_cb>:
{
   1f9d8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct lll_adv *lll = prepare_param->param;
   1f9da:	68c4      	ldr	r4, [r0, #12]
	u32_t aa = sys_cpu_to_le32(0x8e89bed6);
   1f9dc:	4b3d      	ldr	r3, [pc, #244]	; (1fad4 <prepare_cb+0xfc>)

static inline int lll_is_stop(void *lll)
{
	struct lll_hdr *hdr = lll;

	return !!hdr->is_stop;
   1f9de:	7925      	ldrb	r5, [r4, #4]
   1f9e0:	9301      	str	r3, [sp, #4]
	if (lll_is_stop(lll)) {
   1f9e2:	f015 0501 	ands.w	r5, r5, #1
{
   1f9e6:	4606      	mov	r6, r0
	if (lll_is_stop(lll)) {
   1f9e8:	d013      	beq.n	1fa12 <prepare_cb+0x3a>
		err = lll_clk_off();
   1f9ea:	f7ff fa09 	bl	1ee00 <lll_clk_off>
		LL_ASSERT(!err || err == -EBUSY);
   1f9ee:	b150      	cbz	r0, 1fa06 <prepare_cb+0x2e>
   1f9f0:	3010      	adds	r0, #16
   1f9f2:	d008      	beq.n	1fa06 <prepare_cb+0x2e>
   1f9f4:	4838      	ldr	r0, [pc, #224]	; (1fad8 <prepare_cb+0x100>)
   1f9f6:	f008 fba5 	bl	28144 <printk>
   1f9fa:	4040      	eors	r0, r0
   1f9fc:	f380 8811 	msr	BASEPRI, r0
   1fa00:	f04f 0003 	mov.w	r0, #3
   1fa04:	df02      	svc	2
		lll_done(NULL);
   1fa06:	2000      	movs	r0, #0
   1fa08:	f7ff f9b2 	bl	1ed70 <lll_done>
}
   1fa0c:	2000      	movs	r0, #0
   1fa0e:	b003      	add	sp, #12
   1fa10:	bdf0      	pop	{r4, r5, r6, r7, pc}
	radio_reset();
   1fa12:	f004 ff5d 	bl	248d0 <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
   1fa16:	2008      	movs	r0, #8
   1fa18:	f004 ffae 	bl	24978 <radio_tx_power_set>
	radio_phy_set(0, 0);
   1fa1c:	4629      	mov	r1, r5
   1fa1e:	4628      	mov	r0, r5
   1fa20:	f004 ff7c 	bl	2491c <radio_phy_set>
	radio_pkt_configure(8, PDU_AC_PAYLOAD_SIZE_MAX, 0);
   1fa24:	462a      	mov	r2, r5
   1fa26:	2125      	movs	r1, #37	; 0x25
   1fa28:	2008      	movs	r0, #8
   1fa2a:	f004 ffdb 	bl	249e4 <radio_pkt_configure>
	radio_aa_set((u8_t *)&aa);
   1fa2e:	a801      	add	r0, sp, #4
   1fa30:	f004 ffc0 	bl	249b4 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
   1fa34:	4929      	ldr	r1, [pc, #164]	; (1fadc <prepare_cb+0x104>)
   1fa36:	f240 605b 	movw	r0, #1627	; 0x65b
   1fa3a:	f005 f84f 	bl	24adc <radio_crc_configure>
	lll->chan_map_curr = lll->chan_map;
   1fa3e:	7b23      	ldrb	r3, [r4, #12]
   1fa40:	f3c3 0242 	ubfx	r2, r3, #1, #3
   1fa44:	f362 1306 	bfi	r3, r2, #4, #3
   1fa48:	7323      	strb	r3, [r4, #12]
	chan_prepare(lll);
   1fa4a:	4620      	mov	r0, r4
   1fa4c:	f7ff ff4a 	bl	1f8e4 <chan_prepare>
	if (ull_filter_lll_rl_enabled()) {
   1fa50:	f004 fd70 	bl	24534 <ull_filter_lll_rl_enabled>
   1fa54:	7b63      	ldrb	r3, [r4, #13]
   1fa56:	b348      	cbz	r0, 1faac <prepare_cb+0xd4>
			ull_filter_lll_get(!!(lll->filter_policy));
   1fa58:	f013 0003 	ands.w	r0, r3, #3
   1fa5c:	bf18      	it	ne
   1fa5e:	2001      	movne	r0, #1
		struct lll_filter *wl = ull_filter_lll_get(true);
   1fa60:	f004 fcd8 	bl	24414 <ull_filter_lll_get>
		radio_filter_configure(wl->enable_bitmask,
   1fa64:	1c82      	adds	r2, r0, #2
   1fa66:	7841      	ldrb	r1, [r0, #1]
   1fa68:	7800      	ldrb	r0, [r0, #0]
   1fa6a:	f005 f89d 	bl	24ba8 <radio_filter_configure>
	evt = HDR_LLL2EVT(lll);
   1fa6e:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
   1fa70:	6835      	ldr	r5, [r6, #0]
	ticks_at_event += lll_evt_offset_get(evt);
   1fa72:	4638      	mov	r0, r7
   1fa74:	f00c fa0b 	bl	2be8e <lll_evt_offset_get>
   1fa78:	4405      	add	r5, r0
	remainder_us = radio_tmr_start(1, ticks_at_start, remainder);
   1fa7a:	6872      	ldr	r2, [r6, #4]
   1fa7c:	f105 0109 	add.w	r1, r5, #9
   1fa80:	2001      	movs	r0, #1
   1fa82:	f005 f8f7 	bl	24c74 <radio_tmr_start>
	radio_tmr_end_capture();
   1fa86:	f005 f9c1 	bl	24e0c <radio_tmr_end_capture>
				   ull_adv_lll_handle_get(lll)),
   1fa8a:	4620      	mov	r0, r4
   1fa8c:	f7ff fc84 	bl	1f398 <ull_adv_lll_handle_get>
	if (lll_preempt_calc(evt, (TICKER_ID_ADV_BASE +
   1fa90:	1c81      	adds	r1, r0, #2
   1fa92:	462a      	mov	r2, r5
   1fa94:	b2c9      	uxtb	r1, r1
   1fa96:	4638      	mov	r0, r7
   1fa98:	f00c fa07 	bl	2beaa <lll_preempt_calc>
   1fa9c:	b150      	cbz	r0, 1fab4 <prepare_cb+0xdc>
		radio_isr_set(isr_abort, lll);
   1fa9e:	4621      	mov	r1, r4
   1faa0:	480f      	ldr	r0, [pc, #60]	; (1fae0 <prepare_cb+0x108>)
   1faa2:	f004 fef5 	bl	24890 <radio_isr_set>
		radio_disable();
   1faa6:	f004 ffe7 	bl	24a78 <radio_disable>
   1faaa:	e7af      	b.n	1fa0c <prepare_cb+0x34>
	if (IS_ENABLED(CONFIG_BT_CTLR_FILTER) && lll->filter_policy) {
   1faac:	079b      	lsls	r3, r3, #30
   1faae:	d0de      	beq.n	1fa6e <prepare_cb+0x96>
		struct lll_filter *wl = ull_filter_lll_get(true);
   1fab0:	2001      	movs	r0, #1
   1fab2:	e7d5      	b.n	1fa60 <prepare_cb+0x88>
		ret = lll_prepare_done(lll);
   1fab4:	4620      	mov	r0, r4
   1fab6:	f00c f9e8 	bl	2be8a <lll_prepare_done>
		LL_ASSERT(!ret);
   1faba:	2800      	cmp	r0, #0
   1fabc:	d0a6      	beq.n	1fa0c <prepare_cb+0x34>
   1fabe:	4809      	ldr	r0, [pc, #36]	; (1fae4 <prepare_cb+0x10c>)
   1fac0:	f008 fb40 	bl	28144 <printk>
   1fac4:	4040      	eors	r0, r0
   1fac6:	f380 8811 	msr	BASEPRI, r0
   1faca:	f04f 0003 	mov.w	r0, #3
   1face:	df02      	svc	2
   1fad0:	e79c      	b.n	1fa0c <prepare_cb+0x34>
   1fad2:	bf00      	nop
   1fad4:	8e89bed6 	.word	0x8e89bed6
   1fad8:	00031b3d 	.word	0x00031b3d
   1fadc:	00555555 	.word	0x00555555
   1fae0:	0002beff 	.word	0x0002beff
   1fae4:	0003166e 	.word	0x0003166e

0001fae8 <lll_adv_prepare>:
{
   1fae8:	b513      	push	{r0, r1, r4, lr}
   1faea:	4604      	mov	r4, r0
	err = lll_clk_on();
   1faec:	f7ff f982 	bl	1edf4 <lll_clk_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
   1faf0:	b150      	cbz	r0, 1fb08 <lll_adv_prepare+0x20>
   1faf2:	3044      	adds	r0, #68	; 0x44
   1faf4:	d008      	beq.n	1fb08 <lll_adv_prepare+0x20>
   1faf6:	480f      	ldr	r0, [pc, #60]	; (1fb34 <lll_adv_prepare+0x4c>)
   1faf8:	f008 fb24 	bl	28144 <printk>
   1fafc:	4040      	eors	r0, r0
   1fafe:	f380 8811 	msr	BASEPRI, r0
   1fb02:	f04f 0003 	mov.w	r0, #3
   1fb06:	df02      	svc	2
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, p);
   1fb08:	9400      	str	r4, [sp, #0]
   1fb0a:	2300      	movs	r3, #0
   1fb0c:	4a0a      	ldr	r2, [pc, #40]	; (1fb38 <lll_adv_prepare+0x50>)
   1fb0e:	490b      	ldr	r1, [pc, #44]	; (1fb3c <lll_adv_prepare+0x54>)
   1fb10:	480b      	ldr	r0, [pc, #44]	; (1fb40 <lll_adv_prepare+0x58>)
   1fb12:	f00c f9b1 	bl	2be78 <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
   1fb16:	b150      	cbz	r0, 1fb2e <lll_adv_prepare+0x46>
   1fb18:	3044      	adds	r0, #68	; 0x44
   1fb1a:	d008      	beq.n	1fb2e <lll_adv_prepare+0x46>
   1fb1c:	4805      	ldr	r0, [pc, #20]	; (1fb34 <lll_adv_prepare+0x4c>)
   1fb1e:	f008 fb11 	bl	28144 <printk>
   1fb22:	4040      	eors	r0, r0
   1fb24:	f380 8811 	msr	BASEPRI, r0
   1fb28:	f04f 0003 	mov.w	r0, #3
   1fb2c:	df02      	svc	2
}
   1fb2e:	b002      	add	sp, #8
   1fb30:	bd10      	pop	{r4, pc}
   1fb32:	bf00      	nop
   1fb34:	00031b18 	.word	0x00031b18
   1fb38:	0001f9d9 	.word	0x0001f9d9
   1fb3c:	0001f5ed 	.word	0x0001f5ed
   1fb40:	0001f58d 	.word	0x0001f58d

0001fb44 <ticker_cb>:
	return 0;
}

static void ticker_cb(u32_t ticks_at_expire, u32_t remainder, u16_t lazy,
		      void *param)
{
   1fb44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1fb46:	461c      	mov	r4, r3
   1fb48:	7c1b      	ldrb	r3, [r3, #16]
   1fb4a:	3301      	adds	r3, #1
   1fb4c:	b2db      	uxtb	r3, r3
   1fb4e:	4607      	mov	r7, r0
   1fb50:	460e      	mov	r6, r1
   1fb52:	4615      	mov	r5, r2
   1fb54:	7423      	strb	r3, [r4, #16]

	DEBUG_RADIO_PREPARE_O(1);

	/* Increment prepare reference count */
	ref = ull_ref_inc(&scan->ull);
	LL_ASSERT(ref);
   1fb56:	b943      	cbnz	r3, 1fb6a <ticker_cb+0x26>
   1fb58:	481a      	ldr	r0, [pc, #104]	; (1fbc4 <ticker_cb+0x80>)
   1fb5a:	f008 faf3 	bl	28144 <printk>
   1fb5e:	4040      	eors	r0, r0
   1fb60:	f380 8811 	msr	BASEPRI, r0
   1fb64:	f04f 0003 	mov.w	r0, #3
   1fb68:	df02      	svc	2

	/* Append timing parameters */
	p.ticks_at_expire = ticks_at_expire;
   1fb6a:	4817      	ldr	r0, [pc, #92]	; (1fbc8 <ticker_cb+0x84>)
	p.remainder = remainder;
	p.lazy = lazy;
	p.param = &scan->lll;
   1fb6c:	f104 031c 	add.w	r3, r4, #28
   1fb70:	60c3      	str	r3, [r0, #12]
	mfy.param = &p;
   1fb72:	4b16      	ldr	r3, [pc, #88]	; (1fbcc <ticker_cb+0x88>)
	p.lazy = lazy;
   1fb74:	8105      	strh	r5, [r0, #8]

	/* Kick LLL prepare */
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   1fb76:	2200      	movs	r2, #0
	p.remainder = remainder;
   1fb78:	e9c0 7600 	strd	r7, r6, [r0]
	mfy.param = &p;
   1fb7c:	6098      	str	r0, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   1fb7e:	4611      	mov	r1, r2
   1fb80:	2001      	movs	r0, #1
   1fb82:	f7fb fe27 	bl	1b7d4 <mayfly_enqueue>
			     0, &mfy);
	LL_ASSERT(!ret);
   1fb86:	b140      	cbz	r0, 1fb9a <ticker_cb+0x56>
   1fb88:	4811      	ldr	r0, [pc, #68]	; (1fbd0 <ticker_cb+0x8c>)
   1fb8a:	f008 fadb 	bl	28144 <printk>
   1fb8e:	4040      	eors	r0, r0
   1fb90:	f380 8811 	msr	BASEPRI, r0
   1fb94:	f04f 0003 	mov.w	r0, #3
   1fb98:	df02      	svc	2

#if defined(CONFIG_BT_CENTRAL) && defined(CONFIG_BT_CTLR_SCHED_ADVANCED)
	/* calc next group in us for the anchor where first connection event
	 * to be placed
	 */
	if (scan->lll.conn) {
   1fb9a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1fb9c:	b183      	cbz	r3, 1fbc0 <ticker_cb+0x7c>
		static struct mayfly s_mfy_sched_after_mstr_offset_get = {
			0, 0, &s_link, NULL,
			ull_sched_mfy_after_mstr_offset_get};
		u32_t retval;

		s_mfy_sched_after_mstr_offset_get.param = (void *)scan;
   1fb9e:	4b0d      	ldr	r3, [pc, #52]	; (1fbd4 <ticker_cb+0x90>)

		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   1fba0:	2201      	movs	r2, #1
   1fba2:	2102      	movs	r1, #2
   1fba4:	4610      	mov	r0, r2
		s_mfy_sched_after_mstr_offset_get.param = (void *)scan;
   1fba6:	609c      	str	r4, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
   1fba8:	f7fb fe14 	bl	1b7d4 <mayfly_enqueue>
				TICKER_USER_ID_ULL_LOW, 1,
				&s_mfy_sched_after_mstr_offset_get);
		LL_ASSERT(!retval);
   1fbac:	b140      	cbz	r0, 1fbc0 <ticker_cb+0x7c>
   1fbae:	480a      	ldr	r0, [pc, #40]	; (1fbd8 <ticker_cb+0x94>)
   1fbb0:	f008 fac8 	bl	28144 <printk>
   1fbb4:	4040      	eors	r0, r0
   1fbb6:	f380 8811 	msr	BASEPRI, r0
   1fbba:	f04f 0003 	mov.w	r0, #3
   1fbbe:	df02      	svc	2
	}
#endif /* CONFIG_BT_CENTRAL && CONFIG_BT_CTLR_SCHED_ADVANCED */

	DEBUG_RADIO_PREPARE_O(1);
}
   1fbc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1fbc2:	bf00      	nop
   1fbc4:	00031a3e 	.word	0x00031a3e
   1fbc8:	20002880 	.word	0x20002880
   1fbcc:	2000fcb8 	.word	0x2000fcb8
   1fbd0:	0003166e 	.word	0x0003166e
   1fbd4:	2000fcc8 	.word	0x2000fcc8
   1fbd8:	0003169c 	.word	0x0003169c

0001fbdc <ull_scan_disable>:
{
   1fbdc:	b530      	push	{r4, r5, lr}
   1fbde:	b085      	sub	sp, #20
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   1fbe0:	2302      	movs	r3, #2
{
   1fbe2:	4605      	mov	r5, r0
	mark = ull_disable_mark(scan);
   1fbe4:	4608      	mov	r0, r1
{
   1fbe6:	460c      	mov	r4, r1
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   1fbe8:	9303      	str	r3, [sp, #12]
	mark = ull_disable_mark(scan);
   1fbea:	f7fe fc3f 	bl	1e46c <ull_disable_mark>
	LL_ASSERT(mark == scan);
   1fbee:	4284      	cmp	r4, r0
   1fbf0:	d008      	beq.n	1fc04 <ull_scan_disable+0x28>
   1fbf2:	4822      	ldr	r0, [pc, #136]	; (1fc7c <ull_scan_disable+0xa0>)
   1fbf4:	f008 faa6 	bl	28144 <printk>
   1fbf8:	4040      	eors	r0, r0
   1fbfa:	f380 8811 	msr	BASEPRI, r0
   1fbfe:	f04f 0003 	mov.w	r0, #3
   1fc02:	df02      	svc	2
			  TICKER_ID_SCAN_BASE + handle,
   1fc04:	1d2a      	adds	r2, r5, #4
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   1fc06:	ad03      	add	r5, sp, #12
   1fc08:	2103      	movs	r1, #3
   1fc0a:	9500      	str	r5, [sp, #0]
   1fc0c:	4b1c      	ldr	r3, [pc, #112]	; (1fc80 <ull_scan_disable+0xa4>)
   1fc0e:	b2d2      	uxtb	r2, r2
   1fc10:	2000      	movs	r0, #0
   1fc12:	f7fc fae3 	bl	1c1dc <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
   1fc16:	4629      	mov	r1, r5
   1fc18:	f7fe fc1c 	bl	1e454 <ull_ticker_status_take>
	if (ret) {
   1fc1c:	b180      	cbz	r0, 1fc40 <ull_scan_disable+0x64>
		mark = ull_disable_unmark(scan);
   1fc1e:	4620      	mov	r0, r4
   1fc20:	f7fe fc2c 	bl	1e47c <ull_disable_unmark>
		LL_ASSERT(mark == scan);
   1fc24:	4284      	cmp	r4, r0
   1fc26:	d008      	beq.n	1fc3a <ull_scan_disable+0x5e>
   1fc28:	4814      	ldr	r0, [pc, #80]	; (1fc7c <ull_scan_disable+0xa0>)
   1fc2a:	f008 fa8b 	bl	28144 <printk>
   1fc2e:	4040      	eors	r0, r0
   1fc30:	f380 8811 	msr	BASEPRI, r0
   1fc34:	f04f 0003 	mov.w	r0, #3
   1fc38:	df02      	svc	2
		return BT_HCI_ERR_CMD_DISALLOWED;
   1fc3a:	200c      	movs	r0, #12
}
   1fc3c:	b005      	add	sp, #20
   1fc3e:	bd30      	pop	{r4, r5, pc}
	ret = ull_disable(&scan->lll);
   1fc40:	f104 001c 	add.w	r0, r4, #28
   1fc44:	f7fe fc4a 	bl	1e4dc <ull_disable>
	LL_ASSERT(!ret);
   1fc48:	b140      	cbz	r0, 1fc5c <ull_scan_disable+0x80>
   1fc4a:	480e      	ldr	r0, [pc, #56]	; (1fc84 <ull_scan_disable+0xa8>)
   1fc4c:	f008 fa7a 	bl	28144 <printk>
   1fc50:	4040      	eors	r0, r0
   1fc52:	f380 8811 	msr	BASEPRI, r0
   1fc56:	f04f 0003 	mov.w	r0, #3
   1fc5a:	df02      	svc	2
	mark = ull_disable_unmark(scan);
   1fc5c:	4620      	mov	r0, r4
   1fc5e:	f7fe fc0d 	bl	1e47c <ull_disable_unmark>
	LL_ASSERT(mark == scan);
   1fc62:	4284      	cmp	r4, r0
   1fc64:	d008      	beq.n	1fc78 <ull_scan_disable+0x9c>
   1fc66:	4805      	ldr	r0, [pc, #20]	; (1fc7c <ull_scan_disable+0xa0>)
   1fc68:	f008 fa6c 	bl	28144 <printk>
   1fc6c:	4040      	eors	r0, r0
   1fc6e:	f380 8811 	msr	BASEPRI, r0
   1fc72:	f04f 0003 	mov.w	r0, #3
   1fc76:	df02      	svc	2
	return 0;
   1fc78:	2000      	movs	r0, #0
   1fc7a:	e7df      	b.n	1fc3c <ull_scan_disable+0x60>
   1fc7c:	00031ba7 	.word	0x00031ba7
   1fc80:	0001e449 	.word	0x0001e449
   1fc84:	0003166e 	.word	0x0003166e

0001fc88 <ull_scan_handle_get>:
	return ((u8_t *)scan - (u8_t *)ll_scan) / sizeof(*scan);
   1fc88:	4b03      	ldr	r3, [pc, #12]	; (1fc98 <ull_scan_handle_get+0x10>)
   1fc8a:	1ac0      	subs	r0, r0, r3
   1fc8c:	234c      	movs	r3, #76	; 0x4c
   1fc8e:	fbb0 f0f3 	udiv	r0, r0, r3
}
   1fc92:	b280      	uxth	r0, r0
   1fc94:	4770      	bx	lr
   1fc96:	bf00      	nop
   1fc98:	20002834 	.word	0x20002834

0001fc9c <ull_scan_lll_handle_get>:
	return ((u8_t *)scan - (u8_t *)ll_scan) / sizeof(*scan);
   1fc9c:	6800      	ldr	r0, [r0, #0]
   1fc9e:	4b03      	ldr	r3, [pc, #12]	; (1fcac <ull_scan_lll_handle_get+0x10>)
   1fca0:	1ac0      	subs	r0, r0, r3
   1fca2:	234c      	movs	r3, #76	; 0x4c
   1fca4:	fbb0 f0f3 	udiv	r0, r0, r3
}
   1fca8:	b280      	uxth	r0, r0
   1fcaa:	4770      	bx	lr
   1fcac:	20002834 	.word	0x20002834

0001fcb0 <ull_scan_is_enabled_get>:
	if (handle >= BT_CTLR_SCAN_MAX) {
   1fcb0:	b938      	cbnz	r0, 1fcc2 <ull_scan_is_enabled_get+0x12>
	if (!scan || !scan->is_enabled) {
   1fcb2:	4805      	ldr	r0, [pc, #20]	; (1fcc8 <ull_scan_is_enabled_get+0x18>)
   1fcb4:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
	return &ll_scan[handle];
   1fcb8:	f013 0f01 	tst.w	r3, #1
   1fcbc:	bf08      	it	eq
   1fcbe:	2000      	moveq	r0, #0
   1fcc0:	4770      	bx	lr
		return NULL;
   1fcc2:	2000      	movs	r0, #0
}
   1fcc4:	4770      	bx	lr
   1fcc6:	bf00      	nop
   1fcc8:	20002834 	.word	0x20002834

0001fccc <ull_scan_is_disabled_get>:
	if (handle >= BT_CTLR_SCAN_MAX) {
   1fccc:	b938      	cbnz	r0, 1fcde <ull_scan_is_disabled_get+0x12>
	if (!scan || scan->is_enabled) {
   1fcce:	4805      	ldr	r0, [pc, #20]	; (1fce4 <ull_scan_is_disabled_get+0x18>)
   1fcd0:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
	return &ll_scan[handle];
   1fcd4:	f013 0f01 	tst.w	r3, #1
   1fcd8:	bf18      	it	ne
   1fcda:	2000      	movne	r0, #0
   1fcdc:	4770      	bx	lr
		return NULL;
   1fcde:	2000      	movs	r0, #0
}
   1fce0:	4770      	bx	lr
   1fce2:	bf00      	nop
   1fce4:	20002834 	.word	0x20002834

0001fce8 <ticker_stop_cb>:
{
   1fce8:	b508      	push	{r3, lr}
	radio_isr_set(isr_cleanup, param);
   1fcea:	4619      	mov	r1, r3
   1fcec:	4803      	ldr	r0, [pc, #12]	; (1fcfc <ticker_stop_cb+0x14>)
   1fcee:	f004 fdcf 	bl	24890 <radio_isr_set>
}
   1fcf2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_disable();
   1fcf6:	f004 bebf 	b.w	24a78 <radio_disable>
   1fcfa:	bf00      	nop
   1fcfc:	000200c9 	.word	0x000200c9

0001fd00 <prepare_cb>:
{
   1fd00:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct lll_scan *lll = prepare_param->param;
   1fd02:	68c4      	ldr	r4, [r0, #12]
	u32_t aa = sys_cpu_to_le32(0x8e89bed6);
   1fd04:	4b64      	ldr	r3, [pc, #400]	; (1fe98 <prepare_cb+0x198>)
{
   1fd06:	b08d      	sub	sp, #52	; 0x34
   1fd08:	4606      	mov	r6, r0
	u32_t aa = sys_cpu_to_le32(0x8e89bed6);
   1fd0a:	930b      	str	r3, [sp, #44]	; 0x2c
   1fd0c:	7923      	ldrb	r3, [r4, #4]
	if (lll_is_stop(lll)) {
   1fd0e:	07db      	lsls	r3, r3, #31
   1fd10:	d513      	bpl.n	1fd3a <prepare_cb+0x3a>
		err = lll_clk_off();
   1fd12:	f7ff f875 	bl	1ee00 <lll_clk_off>
		LL_ASSERT(!err || err == -EBUSY);
   1fd16:	b150      	cbz	r0, 1fd2e <prepare_cb+0x2e>
   1fd18:	3010      	adds	r0, #16
   1fd1a:	d008      	beq.n	1fd2e <prepare_cb+0x2e>
   1fd1c:	485f      	ldr	r0, [pc, #380]	; (1fe9c <prepare_cb+0x19c>)
   1fd1e:	f008 fa11 	bl	28144 <printk>
   1fd22:	4040      	eors	r0, r0
   1fd24:	f380 8811 	msr	BASEPRI, r0
   1fd28:	f04f 0003 	mov.w	r0, #3
   1fd2c:	df02      	svc	2
		lll_done(NULL);
   1fd2e:	2000      	movs	r0, #0
   1fd30:	f7ff f81e 	bl	1ed70 <lll_done>
}
   1fd34:	2000      	movs	r0, #0
   1fd36:	b00d      	add	sp, #52	; 0x34
   1fd38:	bdf0      	pop	{r4, r5, r6, r7, pc}
	node_rx = ull_pdu_rx_alloc_peek(1);
   1fd3a:	2001      	movs	r0, #1
   1fd3c:	f7fe fbfe 	bl	1e53c <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   1fd40:	4605      	mov	r5, r0
   1fd42:	b940      	cbnz	r0, 1fd56 <prepare_cb+0x56>
   1fd44:	4856      	ldr	r0, [pc, #344]	; (1fea0 <prepare_cb+0x1a0>)
   1fd46:	f008 f9fd 	bl	28144 <printk>
   1fd4a:	4040      	eors	r0, r0
   1fd4c:	f380 8811 	msr	BASEPRI, r0
   1fd50:	f04f 0003 	mov.w	r0, #3
   1fd54:	df02      	svc	2
	radio_reset();
   1fd56:	f004 fdbb 	bl	248d0 <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
   1fd5a:	2008      	movs	r0, #8
   1fd5c:	f004 fe0c 	bl	24978 <radio_tx_power_set>
	radio_phy_set(0, 0);
   1fd60:	2100      	movs	r1, #0
   1fd62:	4608      	mov	r0, r1
   1fd64:	f004 fdda 	bl	2491c <radio_phy_set>
	radio_pkt_configure(8, PDU_AC_PAYLOAD_SIZE_MAX, 0);
   1fd68:	2200      	movs	r2, #0
   1fd6a:	2125      	movs	r1, #37	; 0x25
   1fd6c:	2008      	movs	r0, #8
   1fd6e:	f004 fe39 	bl	249e4 <radio_pkt_configure>
	radio_pkt_rx_set(node_rx->pdu);
   1fd72:	f105 0020 	add.w	r0, r5, #32
   1fd76:	f004 fe67 	bl	24a48 <radio_pkt_rx_set>
	radio_aa_set((u8_t *)&aa);
   1fd7a:	a80b      	add	r0, sp, #44	; 0x2c
   1fd7c:	f004 fe1a 	bl	249b4 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
   1fd80:	4948      	ldr	r1, [pc, #288]	; (1fea4 <prepare_cb+0x1a4>)
   1fd82:	f240 605b 	movw	r0, #1627	; 0x65b
   1fd86:	f004 fea9 	bl	24adc <radio_crc_configure>
	lll_chan_set(37 + lll->chan);
   1fd8a:	7da0      	ldrb	r0, [r4, #22]
   1fd8c:	f3c0 0041 	ubfx	r0, r0, #1, #2
   1fd90:	3025      	adds	r0, #37	; 0x25
   1fd92:	f7ff f83d 	bl	1ee10 <lll_chan_set>
	radio_isr_set(isr_rx, lll);
   1fd96:	4621      	mov	r1, r4
   1fd98:	4843      	ldr	r0, [pc, #268]	; (1fea8 <prepare_cb+0x1a8>)
   1fd9a:	f004 fd79 	bl	24890 <radio_isr_set>
	radio_tmr_tifs_set(EVENT_IFS_US);
   1fd9e:	2096      	movs	r0, #150	; 0x96
   1fda0:	f004 ff5c 	bl	24c5c <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
   1fda4:	2300      	movs	r3, #0
   1fda6:	461a      	mov	r2, r3
   1fda8:	4619      	mov	r1, r3
   1fdaa:	4618      	mov	r0, r3
   1fdac:	f004 fec0 	bl	24b30 <radio_switch_complete_and_tx>
	if (ull_filter_lll_rl_enabled()) {
   1fdb0:	f004 fbc0 	bl	24534 <ull_filter_lll_rl_enabled>
   1fdb4:	7da3      	ldrb	r3, [r4, #22]
   1fdb6:	b3a8      	cbz	r0, 1fe24 <prepare_cb+0x124>
			ull_filter_lll_get(!!(lll->filter_policy & 0x1));
   1fdb8:	f3c3 00c0 	ubfx	r0, r3, #3, #1
   1fdbc:	f004 fb2a 	bl	24414 <ull_filter_lll_get>
   1fdc0:	4605      	mov	r5, r0
		u8_t count, *irks = ull_filter_lll_irks_get(&count);
   1fdc2:	f10d 002b 	add.w	r0, sp, #43	; 0x2b
   1fdc6:	f004 fa79 	bl	242bc <ull_filter_lll_irks_get>
		radio_filter_configure(filter->enable_bitmask,
   1fdca:	7869      	ldrb	r1, [r5, #1]
		u8_t count, *irks = ull_filter_lll_irks_get(&count);
   1fdcc:	4607      	mov	r7, r0
		radio_filter_configure(filter->enable_bitmask,
   1fdce:	1caa      	adds	r2, r5, #2
   1fdd0:	7828      	ldrb	r0, [r5, #0]
   1fdd2:	f004 fee9 	bl	24ba8 <radio_filter_configure>
		radio_ar_configure(count, irks);
   1fdd6:	4639      	mov	r1, r7
   1fdd8:	f89d 002b 	ldrb.w	r0, [sp, #43]	; 0x2b
   1fddc:	f005 f8c6 	bl	24f6c <radio_ar_configure>
	evt = HDR_LLL2EVT(lll);
   1fde0:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
   1fde2:	6835      	ldr	r5, [r6, #0]
	ticks_at_event += lll_evt_offset_get(evt);
   1fde4:	4638      	mov	r0, r7
   1fde6:	f00c f852 	bl	2be8e <lll_evt_offset_get>
   1fdea:	4405      	add	r5, r0
	remainder_us = radio_tmr_start(0, ticks_at_start, remainder);
   1fdec:	6872      	ldr	r2, [r6, #4]
   1fdee:	f105 0109 	add.w	r1, r5, #9
   1fdf2:	2000      	movs	r0, #0
   1fdf4:	f004 ff3e 	bl	24c74 <radio_tmr_start>
	radio_tmr_end_capture();
   1fdf8:	f005 f808 	bl	24e0c <radio_tmr_end_capture>
	radio_rssi_measure();
   1fdfc:	f004 feb2 	bl	24b64 <radio_rssi_measure>
				   ull_scan_lll_handle_get(lll)),
   1fe00:	4620      	mov	r0, r4
   1fe02:	f7ff ff4b 	bl	1fc9c <ull_scan_lll_handle_get>
	if (lll_preempt_calc(evt, (TICKER_ID_SCAN_BASE +
   1fe06:	1d01      	adds	r1, r0, #4
   1fe08:	b2c9      	uxtb	r1, r1
   1fe0a:	462a      	mov	r2, r5
   1fe0c:	4638      	mov	r0, r7
   1fe0e:	f00c f84c 	bl	2beaa <lll_preempt_calc>
   1fe12:	4601      	mov	r1, r0
   1fe14:	b190      	cbz	r0, 1fe3c <prepare_cb+0x13c>
		radio_isr_set(isr_abort, lll);
   1fe16:	4621      	mov	r1, r4
   1fe18:	4824      	ldr	r0, [pc, #144]	; (1feac <prepare_cb+0x1ac>)
   1fe1a:	f004 fd39 	bl	24890 <radio_isr_set>
		radio_disable();
   1fe1e:	f004 fe2b 	bl	24a78 <radio_disable>
   1fe22:	e787      	b.n	1fd34 <prepare_cb+0x34>
	if (IS_ENABLED(CONFIG_BT_CTLR_FILTER) && lll->filter_policy) {
   1fe24:	f013 0f18 	tst.w	r3, #24
   1fe28:	d0da      	beq.n	1fde0 <prepare_cb+0xe0>
		struct lll_filter *wl = ull_filter_lll_get(true);
   1fe2a:	2001      	movs	r0, #1
   1fe2c:	f004 faf2 	bl	24414 <ull_filter_lll_get>
		radio_filter_configure(wl->enable_bitmask,
   1fe30:	1c82      	adds	r2, r0, #2
   1fe32:	7841      	ldrb	r1, [r0, #1]
   1fe34:	7800      	ldrb	r0, [r0, #0]
   1fe36:	f004 feb7 	bl	24ba8 <radio_filter_configure>
   1fe3a:	e7d1      	b.n	1fde0 <prepare_cb+0xe0>
		if (lll->ticks_window) {
   1fe3c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1fe3e:	b1db      	cbz	r3, 1fe78 <prepare_cb+0x178>
			ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
   1fe40:	22fa      	movs	r2, #250	; 0xfa
   1fe42:	9208      	str	r2, [sp, #32]
   1fe44:	4a1a      	ldr	r2, [pc, #104]	; (1feb0 <prepare_cb+0x1b0>)
   1fe46:	e9cd 4206 	strd	r4, r2, [sp, #24]
   1fe4a:	4a1a      	ldr	r2, [pc, #104]	; (1feb4 <prepare_cb+0x1b4>)
   1fe4c:	e9cd 3000 	strd	r3, r0, [sp]
   1fe50:	e9cd 0204 	strd	r0, r2, [sp, #16]
   1fe54:	462b      	mov	r3, r5
   1fe56:	e9cd 0002 	strd	r0, r0, [sp, #8]
   1fe5a:	2203      	movs	r2, #3
   1fe5c:	f7fc f92c 	bl	1c0b8 <ticker_start>
			LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
   1fe60:	f030 0302 	bics.w	r3, r0, #2
   1fe64:	d008      	beq.n	1fe78 <prepare_cb+0x178>
   1fe66:	4814      	ldr	r0, [pc, #80]	; (1feb8 <prepare_cb+0x1b8>)
   1fe68:	f008 f96c 	bl	28144 <printk>
   1fe6c:	4040      	eors	r0, r0
   1fe6e:	f380 8811 	msr	BASEPRI, r0
   1fe72:	f04f 0003 	mov.w	r0, #3
   1fe76:	df02      	svc	2
		ret = lll_prepare_done(lll);
   1fe78:	4620      	mov	r0, r4
   1fe7a:	f00c f806 	bl	2be8a <lll_prepare_done>
		LL_ASSERT(!ret);
   1fe7e:	2800      	cmp	r0, #0
   1fe80:	f43f af58 	beq.w	1fd34 <prepare_cb+0x34>
   1fe84:	480d      	ldr	r0, [pc, #52]	; (1febc <prepare_cb+0x1bc>)
   1fe86:	f008 f95d 	bl	28144 <printk>
   1fe8a:	4040      	eors	r0, r0
   1fe8c:	f380 8811 	msr	BASEPRI, r0
   1fe90:	f04f 0003 	mov.w	r0, #3
   1fe94:	df02      	svc	2
   1fe96:	e74d      	b.n	1fd34 <prepare_cb+0x34>
   1fe98:	8e89bed6 	.word	0x8e89bed6
   1fe9c:	00031b3d 	.word	0x00031b3d
   1fea0:	00031bc6 	.word	0x00031bc6
   1fea4:	00555555 	.word	0x00555555
   1fea8:	0000cc49 	.word	0x0000cc49
   1feac:	0002c1d9 	.word	0x0002c1d9
   1feb0:	0001fff1 	.word	0x0001fff1
   1feb4:	0001fce9 	.word	0x0001fce9
   1feb8:	00031a54 	.word	0x00031a54
   1febc:	0003166e 	.word	0x0003166e

0001fec0 <isr_common_done>:
{
   1fec0:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1fec2:	4605      	mov	r5, r0
	radio_status_reset();
   1fec4:	f004 fdea 	bl	24a9c <radio_status_reset>
	radio_tmr_status_reset();
   1fec8:	f004 feb8 	bl	24c3c <radio_tmr_status_reset>
	radio_filter_status_reset();
   1fecc:	f004 fe92 	bl	24bf4 <radio_filter_status_reset>
	radio_ar_status_reset();
   1fed0:	f005 f87e 	bl	24fd0 <radio_ar_status_reset>
	radio_rssi_status_reset();
   1fed4:	f004 fe56 	bl	24b84 <radio_rssi_status_reset>
	node_rx = ull_pdu_rx_alloc_peek(1);
   1fed8:	2001      	movs	r0, #1
   1feda:	f7fe fb2f 	bl	1e53c <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   1fede:	4604      	mov	r4, r0
   1fee0:	b940      	cbnz	r0, 1fef4 <isr_common_done+0x34>
   1fee2:	4815      	ldr	r0, [pc, #84]	; (1ff38 <isr_common_done+0x78>)
   1fee4:	f008 f92e 	bl	28144 <printk>
   1fee8:	4040      	eors	r0, r0
   1feea:	f380 8811 	msr	BASEPRI, r0
   1feee:	f04f 0003 	mov.w	r0, #3
   1fef2:	df02      	svc	2
	radio_tmr_tifs_set(EVENT_IFS_US);
   1fef4:	2096      	movs	r0, #150	; 0x96
   1fef6:	f004 feb1 	bl	24c5c <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
   1fefa:	2300      	movs	r3, #0
   1fefc:	4618      	mov	r0, r3
   1fefe:	461a      	mov	r2, r3
   1ff00:	4619      	mov	r1, r3
   1ff02:	f004 fe15 	bl	24b30 <radio_switch_complete_and_tx>
	radio_pkt_rx_set(node_rx->pdu);
   1ff06:	f104 0020 	add.w	r0, r4, #32
   1ff0a:	f004 fd9d 	bl	24a48 <radio_pkt_rx_set>
	radio_rssi_measure();
   1ff0e:	f004 fe29 	bl	24b64 <radio_rssi_measure>
	if (ull_filter_lll_rl_enabled()) {
   1ff12:	f004 fb0f 	bl	24534 <ull_filter_lll_rl_enabled>
   1ff16:	b140      	cbz	r0, 1ff2a <isr_common_done+0x6a>
		u8_t count, *irks = ull_filter_lll_irks_get(&count);
   1ff18:	f10d 0007 	add.w	r0, sp, #7
   1ff1c:	f004 f9ce 	bl	242bc <ull_filter_lll_irks_get>
		radio_ar_configure(count, irks);
   1ff20:	4601      	mov	r1, r0
   1ff22:	f89d 0007 	ldrb.w	r0, [sp, #7]
   1ff26:	f005 f821 	bl	24f6c <radio_ar_configure>
	radio_isr_set(isr_rx, param);
   1ff2a:	4629      	mov	r1, r5
   1ff2c:	4803      	ldr	r0, [pc, #12]	; (1ff3c <isr_common_done+0x7c>)
   1ff2e:	f004 fcaf 	bl	24890 <radio_isr_set>
}
   1ff32:	b003      	add	sp, #12
   1ff34:	bd30      	pop	{r4, r5, pc}
   1ff36:	bf00      	nop
   1ff38:	00031bc6 	.word	0x00031bc6
   1ff3c:	0000cc49 	.word	0x0000cc49

0001ff40 <isr_tx>:
{
   1ff40:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1ff42:	4605      	mov	r5, r0
	radio_status_reset();
   1ff44:	f004 fdaa 	bl	24a9c <radio_status_reset>
	radio_tmr_status_reset();
   1ff48:	f004 fe78 	bl	24c3c <radio_tmr_status_reset>
	node_rx = ull_pdu_rx_alloc_peek(1);
   1ff4c:	2001      	movs	r0, #1
   1ff4e:	f7fe faf5 	bl	1e53c <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   1ff52:	4604      	mov	r4, r0
   1ff54:	b940      	cbnz	r0, 1ff68 <isr_tx+0x28>
   1ff56:	4823      	ldr	r0, [pc, #140]	; (1ffe4 <isr_tx+0xa4>)
   1ff58:	f008 f8f4 	bl	28144 <printk>
   1ff5c:	4040      	eors	r0, r0
   1ff5e:	f380 8811 	msr	BASEPRI, r0
   1ff62:	f04f 0003 	mov.w	r0, #3
   1ff66:	df02      	svc	2
	radio_isr_set(isr_rx, param);
   1ff68:	4629      	mov	r1, r5
   1ff6a:	481f      	ldr	r0, [pc, #124]	; (1ffe8 <isr_tx+0xa8>)
   1ff6c:	f004 fc90 	bl	24890 <radio_isr_set>
	radio_tmr_tifs_set(EVENT_IFS_US);
   1ff70:	2096      	movs	r0, #150	; 0x96
   1ff72:	f004 fe73 	bl	24c5c <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
   1ff76:	2300      	movs	r3, #0
   1ff78:	4618      	mov	r0, r3
   1ff7a:	461a      	mov	r2, r3
   1ff7c:	4619      	mov	r1, r3
   1ff7e:	f004 fdd7 	bl	24b30 <radio_switch_complete_and_tx>
	radio_pkt_rx_set(node_rx->pdu);
   1ff82:	f104 0020 	add.w	r0, r4, #32
   1ff86:	f004 fd5f 	bl	24a48 <radio_pkt_rx_set>
	LL_ASSERT(!radio_is_ready());
   1ff8a:	f004 fd93 	bl	24ab4 <radio_is_ready>
   1ff8e:	b140      	cbz	r0, 1ffa2 <isr_tx+0x62>
   1ff90:	4816      	ldr	r0, [pc, #88]	; (1ffec <isr_tx+0xac>)
   1ff92:	f008 f8d7 	bl	28144 <printk>
   1ff96:	4040      	eors	r0, r0
   1ff98:	f380 8811 	msr	BASEPRI, r0
   1ff9c:	f04f 0003 	mov.w	r0, #3
   1ffa0:	df02      	svc	2
	if (ull_filter_lll_rl_enabled()) {
   1ffa2:	f004 fac7 	bl	24534 <ull_filter_lll_rl_enabled>
   1ffa6:	b140      	cbz	r0, 1ffba <isr_tx+0x7a>
		u8_t count, *irks = ull_filter_lll_irks_get(&count);
   1ffa8:	f10d 0007 	add.w	r0, sp, #7
   1ffac:	f004 f986 	bl	242bc <ull_filter_lll_irks_get>
		radio_ar_configure(count, irks);
   1ffb0:	4601      	mov	r1, r0
   1ffb2:	f89d 0007 	ldrb.w	r0, [sp, #7]
   1ffb6:	f004 ffd9 	bl	24f6c <radio_ar_configure>
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   1ffba:	f004 ff35 	bl	24e28 <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(0, 0);
   1ffbe:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
   1ffc0:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(0, 0);
   1ffc2:	4608      	mov	r0, r1
   1ffc4:	f00c fd78 	bl	2cab8 <radio_rx_chain_delay_get>
	hcto -= radio_tx_chain_delay_get(0, 0);
   1ffc8:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(0, 0);
   1ffca:	4605      	mov	r5, r0
	hcto -= radio_tx_chain_delay_get(0, 0);
   1ffcc:	4608      	mov	r0, r1
   1ffce:	f00c fd6f 	bl	2cab0 <radio_tx_chain_delay_get>
   1ffd2:	442c      	add	r4, r5
   1ffd4:	34c3      	adds	r4, #195	; 0xc3
	radio_tmr_hcto_configure(hcto);
   1ffd6:	1a20      	subs	r0, r4, r0
   1ffd8:	f004 fee0 	bl	24d9c <radio_tmr_hcto_configure>
	radio_rssi_measure();
   1ffdc:	f004 fdc2 	bl	24b64 <radio_rssi_measure>
}
   1ffe0:	b003      	add	sp, #12
   1ffe2:	bd30      	pop	{r4, r5, pc}
   1ffe4:	00031bc6 	.word	0x00031bc6
   1ffe8:	0000cc49 	.word	0x0000cc49
   1ffec:	00031b62 	.word	0x00031b62

0001fff0 <ticker_op_start_cb>:
{
   1fff0:	b508      	push	{r3, lr}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   1fff2:	b140      	cbz	r0, 20006 <ticker_op_start_cb+0x16>
   1fff4:	4804      	ldr	r0, [pc, #16]	; (20008 <ticker_op_start_cb+0x18>)
   1fff6:	f008 f8a5 	bl	28144 <printk>
   1fffa:	4040      	eors	r0, r0
   1fffc:	f380 8811 	msr	BASEPRI, r0
   20000:	f04f 0003 	mov.w	r0, #3
   20004:	df02      	svc	2
}
   20006:	bd08      	pop	{r3, pc}
   20008:	00031bf1 	.word	0x00031bf1

0002000c <abort_cb>:
{
   2000c:	b510      	push	{r4, lr}
   2000e:	460c      	mov	r4, r1
	if (!prepare_param) {
   20010:	b930      	cbnz	r0, 20020 <abort_cb+0x14>
			radio_isr_set(isr_abort, param);
   20012:	480d      	ldr	r0, [pc, #52]	; (20048 <abort_cb+0x3c>)
   20014:	f004 fc3c 	bl	24890 <radio_isr_set>
}
   20018:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			radio_disable();
   2001c:	f004 bd2c 	b.w	24a78 <radio_disable>
	err = lll_clk_off();
   20020:	f7fe feee 	bl	1ee00 <lll_clk_off>
	LL_ASSERT(!err || err == -EBUSY);
   20024:	b150      	cbz	r0, 2003c <abort_cb+0x30>
   20026:	3010      	adds	r0, #16
   20028:	d008      	beq.n	2003c <abort_cb+0x30>
   2002a:	4808      	ldr	r0, [pc, #32]	; (2004c <abort_cb+0x40>)
   2002c:	f008 f88a 	bl	28144 <printk>
   20030:	4040      	eors	r0, r0
   20032:	f380 8811 	msr	BASEPRI, r0
   20036:	f04f 0003 	mov.w	r0, #3
   2003a:	df02      	svc	2
	lll_done(param);
   2003c:	4620      	mov	r0, r4
}
   2003e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
   20042:	f7fe be95 	b.w	1ed70 <lll_done>
   20046:	bf00      	nop
   20048:	0002c1d9 	.word	0x0002c1d9
   2004c:	00031b3d 	.word	0x00031b3d

00020050 <is_abort_cb>:
	if (next != curr) {
   20050:	4282      	cmp	r2, r0
{
   20052:	b510      	push	{r4, lr}
   20054:	4614      	mov	r4, r2
	if (next != curr) {
   20056:	d015      	beq.n	20084 <is_abort_cb+0x34>
		*resume_cb = resume_prepare_cb;
   20058:	4a18      	ldr	r2, [pc, #96]	; (200bc <is_abort_cb+0x6c>)
   2005a:	601a      	str	r2, [r3, #0]
		*resume_prio = 0; /* TODO: */
   2005c:	9b02      	ldr	r3, [sp, #8]
   2005e:	2200      	movs	r2, #0
   20060:	601a      	str	r2, [r3, #0]
		err = lll_clk_on();
   20062:	f7fe fec7 	bl	1edf4 <lll_clk_on>
		LL_ASSERT(!err || err == -EINPROGRESS);
   20066:	b150      	cbz	r0, 2007e <is_abort_cb+0x2e>
   20068:	3044      	adds	r0, #68	; 0x44
   2006a:	d008      	beq.n	2007e <is_abort_cb+0x2e>
   2006c:	4814      	ldr	r0, [pc, #80]	; (200c0 <is_abort_cb+0x70>)
   2006e:	f008 f869 	bl	28144 <printk>
   20072:	4040      	eors	r0, r0
   20074:	f380 8811 	msr	BASEPRI, r0
   20078:	f04f 0003 	mov.w	r0, #3
   2007c:	df02      	svc	2
   2007e:	f06f 000a 	mvn.w	r0, #10
   20082:	e019      	b.n	200b8 <is_abort_cb+0x68>
	radio_isr_set(isr_window, lll);
   20084:	4611      	mov	r1, r2
   20086:	480f      	ldr	r0, [pc, #60]	; (200c4 <is_abort_cb+0x74>)
   20088:	f004 fc02 	bl	24890 <radio_isr_set>
	radio_disable();
   2008c:	f004 fcf4 	bl	24a78 <radio_disable>
	if (++lll->chan == 3U) {
   20090:	7da3      	ldrb	r3, [r4, #22]
   20092:	f3c3 0241 	ubfx	r2, r3, #1, #2
   20096:	3201      	adds	r2, #1
   20098:	f002 0203 	and.w	r2, r2, #3
   2009c:	2a03      	cmp	r2, #3
   2009e:	bf14      	ite	ne
   200a0:	f362 0342 	bfine	r3, r2, #1, #2
		lll->chan = 0U;
   200a4:	f36f 0342 	bfceq	r3, #1, #2
   200a8:	75a3      	strb	r3, [r4, #22]
	lll_chan_set(37 + lll->chan);
   200aa:	7da0      	ldrb	r0, [r4, #22]
   200ac:	f3c0 0041 	ubfx	r0, r0, #1, #2
   200b0:	3025      	adds	r0, #37	; 0x25
   200b2:	f7fe fead 	bl	1ee10 <lll_chan_set>
	return 0;
   200b6:	2000      	movs	r0, #0
}
   200b8:	bd10      	pop	{r4, pc}
   200ba:	bf00      	nop
   200bc:	0002c197 	.word	0x0002c197
   200c0:	00031b18 	.word	0x00031b18
   200c4:	0002c1bf 	.word	0x0002c1bf

000200c8 <isr_cleanup>:
{
   200c8:	b538      	push	{r3, r4, r5, lr}
   200ca:	4604      	mov	r4, r0
	if (lll_is_done(param)) {
   200cc:	f7fe fe8a 	bl	1ede4 <lll_is_done>
   200d0:	4605      	mov	r5, r0
   200d2:	bb38      	cbnz	r0, 20124 <isr_cleanup+0x5c>
	radio_filter_disable();
   200d4:	f004 fd84 	bl	24be0 <radio_filter_disable>
	if (++lll->chan == 3U) {
   200d8:	7da3      	ldrb	r3, [r4, #22]
	radio_isr_set(isr_race, param);
   200da:	4813      	ldr	r0, [pc, #76]	; (20128 <isr_cleanup+0x60>)
	if (++lll->chan == 3U) {
   200dc:	f3c3 0241 	ubfx	r2, r3, #1, #2
   200e0:	3201      	adds	r2, #1
   200e2:	f002 0203 	and.w	r2, r2, #3
   200e6:	2a03      	cmp	r2, #3
   200e8:	bf14      	ite	ne
   200ea:	f362 0342 	bfine	r3, r2, #1, #2
		lll->chan = 0U;
   200ee:	f365 0342 	bfieq	r3, r5, #1, #2
   200f2:	75a3      	strb	r3, [r4, #22]
	radio_isr_set(isr_race, param);
   200f4:	4621      	mov	r1, r4
   200f6:	f004 fbcb 	bl	24890 <radio_isr_set>
	radio_tmr_stop();
   200fa:	f004 fe43 	bl	24d84 <radio_tmr_stop>
	err = lll_clk_off();
   200fe:	f7fe fe7f 	bl	1ee00 <lll_clk_off>
	LL_ASSERT(!err || err == -EBUSY);
   20102:	b150      	cbz	r0, 2011a <isr_cleanup+0x52>
   20104:	3010      	adds	r0, #16
   20106:	d008      	beq.n	2011a <isr_cleanup+0x52>
   20108:	4808      	ldr	r0, [pc, #32]	; (2012c <isr_cleanup+0x64>)
   2010a:	f008 f81b 	bl	28144 <printk>
   2010e:	4040      	eors	r0, r0
   20110:	f380 8811 	msr	BASEPRI, r0
   20114:	f04f 0003 	mov.w	r0, #3
   20118:	df02      	svc	2
	lll_done(NULL);
   2011a:	2000      	movs	r0, #0
}
   2011c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	lll_done(NULL);
   20120:	f7fe be26 	b.w	1ed70 <lll_done>
}
   20124:	bd38      	pop	{r3, r4, r5, pc}
   20126:	bf00      	nop
   20128:	0002c0f3 	.word	0x0002c0f3
   2012c:	00031b3d 	.word	0x00031b3d

00020130 <lll_scan_prepare>:
{
   20130:	b513      	push	{r0, r1, r4, lr}
   20132:	4604      	mov	r4, r0
	err = lll_clk_on();
   20134:	f7fe fe5e 	bl	1edf4 <lll_clk_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
   20138:	b150      	cbz	r0, 20150 <lll_scan_prepare+0x20>
   2013a:	3044      	adds	r0, #68	; 0x44
   2013c:	d008      	beq.n	20150 <lll_scan_prepare+0x20>
   2013e:	480f      	ldr	r0, [pc, #60]	; (2017c <lll_scan_prepare+0x4c>)
   20140:	f008 f800 	bl	28144 <printk>
   20144:	4040      	eors	r0, r0
   20146:	f380 8811 	msr	BASEPRI, r0
   2014a:	f04f 0003 	mov.w	r0, #3
   2014e:	df02      	svc	2
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, p);
   20150:	9400      	str	r4, [sp, #0]
   20152:	2300      	movs	r3, #0
   20154:	4a0a      	ldr	r2, [pc, #40]	; (20180 <lll_scan_prepare+0x50>)
   20156:	490b      	ldr	r1, [pc, #44]	; (20184 <lll_scan_prepare+0x54>)
   20158:	480b      	ldr	r0, [pc, #44]	; (20188 <lll_scan_prepare+0x58>)
   2015a:	f00b fe8d 	bl	2be78 <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
   2015e:	b150      	cbz	r0, 20176 <lll_scan_prepare+0x46>
   20160:	3044      	adds	r0, #68	; 0x44
   20162:	d008      	beq.n	20176 <lll_scan_prepare+0x46>
   20164:	4805      	ldr	r0, [pc, #20]	; (2017c <lll_scan_prepare+0x4c>)
   20166:	f007 ffed 	bl	28144 <printk>
   2016a:	4040      	eors	r0, r0
   2016c:	f380 8811 	msr	BASEPRI, r0
   20170:	f04f 0003 	mov.w	r0, #3
   20174:	df02      	svc	2
}
   20176:	b002      	add	sp, #8
   20178:	bd10      	pop	{r4, pc}
   2017a:	bf00      	nop
   2017c:	00031b18 	.word	0x00031b18
   20180:	0001fd01 	.word	0x0001fd01
   20184:	0002000d 	.word	0x0002000d
   20188:	00020051 	.word	0x00020051

0002018c <pdu_len_cmp>:
		break;
	}
}

static inline bool pdu_len_cmp(u8_t opcode, u8_t len)
{
   2018c:	b5f0      	push	{r4, r5, r6, r7, lr}
	const u8_t ctrl_len_lut[] = {
   2018e:	4b0d      	ldr	r3, [pc, #52]	; (201c4 <pdu_len_cmp+0x38>)
{
   20190:	b089      	sub	sp, #36	; 0x24
   20192:	4605      	mov	r5, r0
   20194:	460e      	mov	r6, r1
	const u8_t ctrl_len_lut[] = {
   20196:	aa01      	add	r2, sp, #4
   20198:	f103 0718 	add.w	r7, r3, #24
   2019c:	6818      	ldr	r0, [r3, #0]
   2019e:	6859      	ldr	r1, [r3, #4]
   201a0:	4614      	mov	r4, r2
   201a2:	c403      	stmia	r4!, {r0, r1}
   201a4:	3308      	adds	r3, #8
   201a6:	42bb      	cmp	r3, r7
   201a8:	4622      	mov	r2, r4
   201aa:	d1f7      	bne.n	2019c <pdu_len_cmp+0x10>
   201ac:	881b      	ldrh	r3, [r3, #0]
   201ae:	8023      	strh	r3, [r4, #0]
		 sizeof(struct pdu_data_llctrl_phy_upd_ind)),
		(offsetof(struct pdu_data_llctrl, min_used_chans_ind) +
		 sizeof(struct pdu_data_llctrl_min_used_chans_ind)),
	};

	return ctrl_len_lut[opcode] == len;
   201b0:	ab08      	add	r3, sp, #32
   201b2:	441d      	add	r5, r3
   201b4:	f815 0c1c 	ldrb.w	r0, [r5, #-28]
}
   201b8:	1b83      	subs	r3, r0, r6
   201ba:	4258      	negs	r0, r3
   201bc:	4158      	adcs	r0, r3
   201be:	b009      	add	sp, #36	; 0x24
   201c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   201c2:	bf00      	nop
   201c4:	0002dd54 	.word	0x0002dd54

000201c8 <ticker_update_latency_cancel_op_cb>:
{
   201c8:	b510      	push	{r4, lr}
   201ca:	460c      	mov	r4, r1
	LL_ASSERT(ticker_status == TICKER_STATUS_SUCCESS);
   201cc:	b140      	cbz	r0, 201e0 <ticker_update_latency_cancel_op_cb+0x18>
   201ce:	4808      	ldr	r0, [pc, #32]	; (201f0 <ticker_update_latency_cancel_op_cb+0x28>)
   201d0:	f007 ffb8 	bl	28144 <printk>
   201d4:	4040      	eors	r0, r0
   201d6:	f380 8811 	msr	BASEPRI, r0
   201da:	f04f 0003 	mov.w	r0, #3
   201de:	df02      	svc	2
	conn->slave.latency_cancel = 0U;
   201e0:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
   201e4:	f36f 0341 	bfc	r3, #1, #1
   201e8:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
}
   201ec:	bd10      	pop	{r4, pc}
   201ee:	bf00      	nop
   201f0:	00031cf8 	.word	0x00031cf8

000201f4 <init_reset>:
{
   201f4:	b508      	push	{r3, lr}
	mem_init(conn_pool, sizeof(struct ll_conn),
   201f6:	2205      	movs	r2, #5
   201f8:	4b13      	ldr	r3, [pc, #76]	; (20248 <init_reset+0x54>)
   201fa:	4814      	ldr	r0, [pc, #80]	; (2024c <init_reset+0x58>)
   201fc:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
   20200:	f00b fb72 	bl	2b8e8 <mem_init>
	mem_init(mem_conn_tx.pool, CONN_TX_BUF_SIZE, CONFIG_BT_CTLR_TX_BUFFERS,
   20204:	4b12      	ldr	r3, [pc, #72]	; (20250 <init_reset+0x5c>)
   20206:	2203      	movs	r2, #3
   20208:	1d18      	adds	r0, r3, #4
   2020a:	f44f 7186 	mov.w	r1, #268	; 0x10c
   2020e:	f00b fb6b 	bl	2b8e8 <mem_init>
	mem_init(mem_conn_tx_ctrl.pool, CONN_TX_CTRL_BUF_SIZE,
   20212:	4b10      	ldr	r3, [pc, #64]	; (20254 <init_reset+0x60>)
   20214:	2204      	movs	r2, #4
   20216:	1898      	adds	r0, r3, r2
   20218:	2120      	movs	r1, #32
   2021a:	f00b fb65 	bl	2b8e8 <mem_init>
	mem_init(mem_link_tx.pool, sizeof(memq_link_t),
   2021e:	4b0e      	ldr	r3, [pc, #56]	; (20258 <init_reset+0x64>)
   20220:	2207      	movs	r2, #7
   20222:	1d18      	adds	r0, r3, #4
   20224:	2108      	movs	r1, #8
   20226:	f00b fb5f 	bl	2b8e8 <mem_init>
	default_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
   2022a:	4b0c      	ldr	r3, [pc, #48]	; (2025c <init_reset+0x68>)
   2022c:	221b      	movs	r2, #27
   2022e:	801a      	strh	r2, [r3, #0]
	default_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0);
   20230:	4b0b      	ldr	r3, [pc, #44]	; (20260 <init_reset+0x6c>)
   20232:	f44f 72a4 	mov.w	r2, #328	; 0x148
   20236:	801a      	strh	r2, [r3, #0]
	default_phy_tx |= BIT(2);
   20238:	4a0a      	ldr	r2, [pc, #40]	; (20264 <init_reset+0x70>)
   2023a:	2307      	movs	r3, #7
   2023c:	7013      	strb	r3, [r2, #0]
	default_phy_rx |= BIT(2);
   2023e:	4a0a      	ldr	r2, [pc, #40]	; (20268 <init_reset+0x74>)
   20240:	7013      	strb	r3, [r2, #0]
}
   20242:	2000      	movs	r0, #0
   20244:	bd08      	pop	{r3, pc}
   20246:	bf00      	nop
   20248:	20002898 	.word	0x20002898
   2024c:	2000289c 	.word	0x2000289c
   20250:	20003194 	.word	0x20003194
   20254:	200034bc 	.word	0x200034bc
   20258:	20003540 	.word	0x20003540
   2025c:	20003cf4 	.word	0x20003cf4
   20260:	20003cf6 	.word	0x20003cf6
   20264:	20003ea4 	.word	0x20003ea4
   20268:	20003ea3 	.word	0x20003ea3

0002026c <ticker_op_stop_cb>:
{
   2026c:	b510      	push	{r4, lr}
   2026e:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   20270:	b140      	cbz	r0, 20284 <ticker_op_stop_cb+0x18>
   20272:	480d      	ldr	r0, [pc, #52]	; (202a8 <ticker_op_stop_cb+0x3c>)
   20274:	f007 ff66 	bl	28144 <printk>
   20278:	4040      	eors	r0, r0
   2027a:	f380 8811 	msr	BASEPRI, r0
   2027e:	f04f 0003 	mov.w	r0, #3
   20282:	df02      	svc	2
	mfy.param = param;
   20284:	4b09      	ldr	r3, [pc, #36]	; (202ac <ticker_op_stop_cb+0x40>)
	retval = mayfly_enqueue(TICKER_USER_ID_ULL_LOW, TICKER_USER_ID_LLL, 0,
   20286:	2200      	movs	r2, #0
   20288:	4611      	mov	r1, r2
   2028a:	2002      	movs	r0, #2
	mfy.param = param;
   2028c:	609c      	str	r4, [r3, #8]
	retval = mayfly_enqueue(TICKER_USER_ID_ULL_LOW, TICKER_USER_ID_LLL, 0,
   2028e:	f7fb faa1 	bl	1b7d4 <mayfly_enqueue>
	LL_ASSERT(!retval);
   20292:	b140      	cbz	r0, 202a6 <ticker_op_stop_cb+0x3a>
   20294:	4806      	ldr	r0, [pc, #24]	; (202b0 <ticker_op_stop_cb+0x44>)
   20296:	f007 ff55 	bl	28144 <printk>
   2029a:	4040      	eors	r0, r0
   2029c:	f380 8811 	msr	BASEPRI, r0
   202a0:	f04f 0003 	mov.w	r0, #3
   202a4:	df02      	svc	2
}
   202a6:	bd10      	pop	{r4, pc}
   202a8:	00031bf1 	.word	0x00031bf1
   202ac:	2000fd40 	.word	0x2000fd40
   202b0:	0003169c 	.word	0x0003169c

000202b4 <ticker_start_conn_op_cb.part.15>:
static void ticker_start_conn_op_cb(u32_t status, void *param)
   202b4:	b508      	push	{r3, lr}
	LL_ASSERT(p == param);
   202b6:	4805      	ldr	r0, [pc, #20]	; (202cc <ticker_start_conn_op_cb.part.15+0x18>)
   202b8:	f007 ff44 	bl	28144 <printk>
   202bc:	4040      	eors	r0, r0
   202be:	f380 8811 	msr	BASEPRI, r0
   202c2:	f04f 0003 	mov.w	r0, #3
   202c6:	df02      	svc	2
}
   202c8:	bd08      	pop	{r3, pc}
   202ca:	bf00      	nop
   202cc:	00031c78 	.word	0x00031c78

000202d0 <ticker_start_conn_op_cb>:
{
   202d0:	b510      	push	{r4, lr}
   202d2:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   202d4:	b140      	cbz	r0, 202e8 <ticker_start_conn_op_cb+0x18>
   202d6:	4809      	ldr	r0, [pc, #36]	; (202fc <ticker_start_conn_op_cb+0x2c>)
   202d8:	f007 ff34 	bl	28144 <printk>
   202dc:	4040      	eors	r0, r0
   202de:	f380 8811 	msr	BASEPRI, r0
   202e2:	f04f 0003 	mov.w	r0, #3
   202e6:	df02      	svc	2
	void *p = ull_update_unmark(param);
   202e8:	4620      	mov	r0, r4
   202ea:	f7fe f8e3 	bl	1e4b4 <ull_update_unmark>
	LL_ASSERT(p == param);
   202ee:	4284      	cmp	r4, r0
   202f0:	d003      	beq.n	202fa <ticker_start_conn_op_cb+0x2a>
}
   202f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   202f6:	f7ff bfdd 	b.w	202b4 <ticker_start_conn_op_cb.part.15>
   202fa:	bd10      	pop	{r4, pc}
   202fc:	00031bf1 	.word	0x00031bf1

00020300 <ticker_stop_conn_op_cb>:
{
   20300:	b510      	push	{r4, lr}
   20302:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   20304:	b140      	cbz	r0, 20318 <ticker_stop_conn_op_cb+0x18>
   20306:	4809      	ldr	r0, [pc, #36]	; (2032c <ticker_stop_conn_op_cb+0x2c>)
   20308:	f007 ff1c 	bl	28144 <printk>
   2030c:	4040      	eors	r0, r0
   2030e:	f380 8811 	msr	BASEPRI, r0
   20312:	f04f 0003 	mov.w	r0, #3
   20316:	df02      	svc	2
	void *p = ull_update_mark(param);
   20318:	4620      	mov	r0, r4
   2031a:	f7fe f8c3 	bl	1e4a4 <ull_update_mark>
	LL_ASSERT(p == param);
   2031e:	4284      	cmp	r4, r0
   20320:	d003      	beq.n	2032a <ticker_stop_conn_op_cb+0x2a>
}
   20322:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   20326:	f7ff bfc5 	b.w	202b4 <ticker_start_conn_op_cb.part.15>
   2032a:	bd10      	pop	{r4, pc}
   2032c:	00031bf1 	.word	0x00031bf1

00020330 <ticker_update_conn_op_cb>:
{
   20330:	b510      	push	{r4, lr}
   20332:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
   20334:	b180      	cbz	r0, 20358 <ticker_update_conn_op_cb+0x28>
   20336:	f7fe f8cb 	bl	1e4d0 <ull_update_mark_get>
   2033a:	4284      	cmp	r4, r0
   2033c:	d00c      	beq.n	20358 <ticker_update_conn_op_cb+0x28>
   2033e:	f7fe f8ab 	bl	1e498 <ull_disable_mark_get>
   20342:	4284      	cmp	r4, r0
   20344:	d008      	beq.n	20358 <ticker_update_conn_op_cb+0x28>
   20346:	4805      	ldr	r0, [pc, #20]	; (2035c <ticker_update_conn_op_cb+0x2c>)
   20348:	f007 fefc 	bl	28144 <printk>
   2034c:	4040      	eors	r0, r0
   2034e:	f380 8811 	msr	BASEPRI, r0
   20352:	f04f 0003 	mov.w	r0, #3
   20356:	df02      	svc	2
}
   20358:	bd10      	pop	{r4, pc}
   2035a:	bf00      	nop
   2035c:	00031c95 	.word	0x00031c95

00020360 <tx_lll_flush>:
{
   20360:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	struct ll_conn *conn = (void *)HDR_LLL2EVT(param);
   20364:	4606      	mov	r6, r0
{
   20366:	4607      	mov	r7, r0
	struct ll_conn *conn = (void *)HDR_LLL2EVT(param);
   20368:	f856 5b4c 	ldr.w	r5, [r6], #76
		idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
   2036c:	4c2a      	ldr	r4, [pc, #168]	; (20418 <tx_lll_flush+0xb8>)
	lll_conn_flush(lll);
   2036e:	f00c fa6f 	bl	2c850 <lll_conn_flush>
	link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
   20372:	aa01      	add	r2, sp, #4
   20374:	4631      	mov	r1, r6
   20376:	6d38      	ldr	r0, [r7, #80]	; 0x50
   20378:	f00b fb47 	bl	2ba0a <memq_dequeue>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   2037c:	f104 0804 	add.w	r8, r4, #4
	while (link) {
   20380:	b9d0      	cbnz	r0, 203b8 <tx_lll_flush+0x58>
	LL_ASSERT(rx->hdr.link);
   20382:	f8d5 312c 	ldr.w	r3, [r5, #300]	; 0x12c
	rx = (void *)&conn->llcp_terminate.node_rx;
   20386:	f505 7496 	add.w	r4, r5, #300	; 0x12c
	LL_ASSERT(rx->hdr.link);
   2038a:	b943      	cbnz	r3, 2039e <tx_lll_flush+0x3e>
   2038c:	4823      	ldr	r0, [pc, #140]	; (2041c <tx_lll_flush+0xbc>)
   2038e:	f007 fed9 	bl	28144 <printk>
   20392:	4040      	eors	r0, r0
   20394:	f380 8811 	msr	BASEPRI, r0
   20398:	f04f 0003 	mov.w	r0, #3
   2039c:	df02      	svc	2
	rx->hdr.link = NULL;
   2039e:	2300      	movs	r3, #0
	link = rx->hdr.link;
   203a0:	f8d5 012c 	ldr.w	r0, [r5, #300]	; 0x12c
	rx->hdr.link = NULL;
   203a4:	f8c5 312c 	str.w	r3, [r5, #300]	; 0x12c
	ull_rx_put(link, rx);
   203a8:	4621      	mov	r1, r4
   203aa:	f7fe f8f5 	bl	1e598 <ull_rx_put>
	ull_rx_sched();
   203ae:	f7fe f903 	bl	1e5b8 <ull_rx_sched>
}
   203b2:	b002      	add	sp, #8
   203b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
   203b8:	78e2      	ldrb	r2, [r4, #3]
	if (last == count) {
   203ba:	f894 e001 	ldrb.w	lr, [r4, #1]
   203be:	f894 c002 	ldrb.w	ip, [r4, #2]
   203c2:	7821      	ldrb	r1, [r4, #0]
	last = last + 1;
   203c4:	1c53      	adds	r3, r2, #1
   203c6:	b2db      	uxtb	r3, r3
		last = 0U;
   203c8:	459e      	cmp	lr, r3
   203ca:	bf08      	it	eq
   203cc:	2300      	moveq	r3, #0
	if (last == first) {
   203ce:	459c      	cmp	ip, r3
   203d0:	d004      	beq.n	203dc <tx_lll_flush+0x7c>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   203d2:	fb12 f201 	smulbb	r2, r2, r1
		LL_ASSERT(lll_tx);
   203d6:	eb18 0c02 	adds.w	ip, r8, r2
   203da:	d10b      	bne.n	203f4 <tx_lll_flush+0x94>
   203dc:	4810      	ldr	r0, [pc, #64]	; (20420 <tx_lll_flush+0xc0>)
   203de:	f007 feb1 	bl	28144 <printk>
   203e2:	4040      	eors	r0, r0
   203e4:	f380 8811 	msr	BASEPRI, r0
   203e8:	f04f 0003 	mov.w	r0, #3
   203ec:	df02      	svc	2
		lll_tx->handle = 0xFFFF;
   203ee:	2300      	movs	r3, #0
   203f0:	801b      	strh	r3, [r3, #0]
   203f2:	deff      	udf	#255	; 0xff
   203f4:	f64f 71ff 	movw	r1, #65535	; 0xffff
   203f8:	f828 1002 	strh.w	r1, [r8, r2]
		lll_tx->node = tx;
   203fc:	9901      	ldr	r1, [sp, #4]
   203fe:	f8cc 1004 	str.w	r1, [ip, #4]
		link->next = tx->next; /* Indicates ctrl pool or data pool */
   20402:	680a      	ldr	r2, [r1, #0]
   20404:	6002      	str	r2, [r0, #0]
		tx->next = link;
   20406:	6008      	str	r0, [r1, #0]
		link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
   20408:	aa01      	add	r2, sp, #4
	*last = idx; /* Commit: Update write index */
   2040a:	70e3      	strb	r3, [r4, #3]
   2040c:	4631      	mov	r1, r6
   2040e:	6d38      	ldr	r0, [r7, #80]	; 0x50
   20410:	f00b fafb 	bl	2ba0a <memq_dequeue>
   20414:	e7b4      	b.n	20380 <tx_lll_flush+0x20>
   20416:	bf00      	nop
   20418:	2000fcd8 	.word	0x2000fcd8
   2041c:	00031d36 	.word	0x00031d36
   20420:	00031d1d 	.word	0x00031d1d

00020424 <ctrl_tx_pause_enqueue>:
{
   20424:	b538      	push	{r3, r4, r5, lr}
   20426:	460d      	mov	r5, r1
   20428:	e9d0 316c 	ldrd	r3, r1, [r0, #432]	; 0x1b0
   2042c:	4604      	mov	r4, r0
	if (
   2042e:	b1e3      	cbz	r3, 2046a <ctrl_tx_pause_enqueue+0x46>
	    !conn->llcp_enc.pause_tx &&
   20430:	f890 0152 	ldrb.w	r0, [r0, #338]	; 0x152
	    conn->tx_head &&
   20434:	0780      	lsls	r0, r0, #30
   20436:	d418      	bmi.n	2046a <ctrl_tx_pause_enqueue+0x46>
	    !conn->llcp_phy.pause_tx &&
   20438:	f894 01ab 	ldrb.w	r0, [r4, #427]	; 0x1ab
   2043c:	07c0      	lsls	r0, r0, #31
   2043e:	d414      	bmi.n	2046a <ctrl_tx_pause_enqueue+0x46>
		if (conn->tx_head == conn->tx_data) {
   20440:	f8d4 01bc 	ldr.w	r0, [r4, #444]	; 0x1bc
   20444:	4283      	cmp	r3, r0
			conn->tx_data = conn->tx_data->next;
   20446:	bf04      	itt	eq
   20448:	6818      	ldreq	r0, [r3, #0]
   2044a:	f8c4 01bc 	streq.w	r0, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
   2044e:	b989      	cbnz	r1, 20474 <ctrl_tx_pause_enqueue+0x50>
			tx->next = conn->tx_head->next;
   20450:	6819      	ldr	r1, [r3, #0]
   20452:	6029      	str	r1, [r5, #0]
			conn->tx_head->next = tx;
   20454:	601d      	str	r5, [r3, #0]
			if (!pause) {
   20456:	b91a      	cbnz	r2, 20460 <ctrl_tx_pause_enqueue+0x3c>
				conn->tx_ctrl = tx;
   20458:	f8c4 51b4 	str.w	r5, [r4, #436]	; 0x1b4
	conn->tx_ctrl_last = tx;
   2045c:	f8c4 51b8 	str.w	r5, [r4, #440]	; 0x1b8
	if (!tx->next) {
   20460:	682b      	ldr	r3, [r5, #0]
   20462:	b90b      	cbnz	r3, 20468 <ctrl_tx_pause_enqueue+0x44>
		conn->tx_data_last = tx;
   20464:	f8c4 51c0 	str.w	r5, [r4, #448]	; 0x1c0
}
   20468:	bd38      	pop	{r3, r4, r5, pc}
		if (!conn->tx_ctrl) {
   2046a:	b919      	cbnz	r1, 20474 <ctrl_tx_pause_enqueue+0x50>
			tx->next = conn->tx_head;
   2046c:	602b      	str	r3, [r5, #0]
			conn->tx_head = tx;
   2046e:	f8c4 51b0 	str.w	r5, [r4, #432]	; 0x1b0
			if (!pause) {
   20472:	e7f0      	b.n	20456 <ctrl_tx_pause_enqueue+0x32>
			LL_ASSERT(!pause);
   20474:	b142      	cbz	r2, 20488 <ctrl_tx_pause_enqueue+0x64>
   20476:	4807      	ldr	r0, [pc, #28]	; (20494 <ctrl_tx_pause_enqueue+0x70>)
   20478:	f007 fe64 	bl	28144 <printk>
   2047c:	4040      	eors	r0, r0
   2047e:	f380 8811 	msr	BASEPRI, r0
   20482:	f04f 0003 	mov.w	r0, #3
   20486:	df02      	svc	2
	tx->next = conn->tx_ctrl_last->next;
   20488:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
   2048c:	681a      	ldr	r2, [r3, #0]
   2048e:	602a      	str	r2, [r5, #0]
	conn->tx_ctrl_last->next = tx;
   20490:	601d      	str	r5, [r3, #0]
   20492:	e7e3      	b.n	2045c <ctrl_tx_pause_enqueue+0x38>
   20494:	00031c0f 	.word	0x00031c0f

00020498 <feature_rsp_send.isra.13>:
static int feature_rsp_send(struct ll_conn *conn, struct node_rx_pdu *rx,
   20498:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2049a:	4606      	mov	r6, r0
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   2049c:	4820      	ldr	r0, [pc, #128]	; (20520 <feature_rsp_send.isra.13+0x88>)
static int feature_rsp_send(struct ll_conn *conn, struct node_rx_pdu *rx,
   2049e:	460d      	mov	r5, r1
   204a0:	4617      	mov	r7, r2
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   204a2:	f00b fa45 	bl	2b930 <mem_acquire>
	if (!tx) {
   204a6:	4604      	mov	r4, r0
   204a8:	b3b0      	cbz	r0, 20518 <feature_rsp_send.isra.13+0x80>
	       (features[1] << 8) | (features[2] << 16);
   204aa:	79bb      	ldrb	r3, [r7, #6]
   204ac:	797a      	ldrb	r2, [r7, #5]
   204ae:	041b      	lsls	r3, r3, #16
   204b0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	feat = ~LL_FEAT_BIT_MASK_VALID | features[0] |
   204b4:	793a      	ldrb	r2, [r7, #4]
	       (features[1] << 8) | (features[2] << 16);
   204b6:	4313      	orrs	r3, r2
   204b8:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
   204bc:	f443 037e 	orr.w	r3, r3, #16646144	; 0xfe0000
	conn->llcp_feature.features &= feat_get(&req->features[0]);
   204c0:	f8d6 211c 	ldr.w	r2, [r6, #284]	; 0x11c
	       (features[1] << 8) | (features[2] << 16);
   204c4:	f443 5343 	orr.w	r3, r3, #12480	; 0x30c0
   204c8:	f043 0310 	orr.w	r3, r3, #16
	conn->llcp_feature.features &= feat_get(&req->features[0]);
   204cc:	4013      	ands	r3, r2
   204ce:	f3c3 0310 	ubfx	r3, r3, #0, #17
   204d2:	f8c6 311c 	str.w	r3, [r6, #284]	; 0x11c
	conn->common.fex_valid = 1U;
   204d6:	f896 30dc 	ldrb.w	r3, [r6, #220]	; 0xdc
   204da:	f043 0301 	orr.w	r3, r3, #1
   204de:	f886 30dc 	strb.w	r3, [r6, #220]	; 0xdc
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   204e2:	7903      	ldrb	r3, [r0, #4]
   204e4:	f043 0303 	orr.w	r3, r3, #3
   204e8:	7103      	strb	r3, [r0, #4]
	(void)memset(&pdu_tx->llctrl.feature_rsp.features[0], 0x00,
   204ea:	2208      	movs	r2, #8
	pdu_tx->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
   204ec:	2309      	movs	r3, #9
   204ee:	7143      	strb	r3, [r0, #5]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
   204f0:	71c3      	strb	r3, [r0, #7]
	(void)memset(&pdu_tx->llctrl.feature_rsp.features[0], 0x00,
   204f2:	2100      	movs	r1, #0
   204f4:	4410      	add	r0, r2
   204f6:	f009 ffd4 	bl	2a4a2 <memset>
		conn->llcp_feature.features & 0xFF;
   204fa:	f8d6 311c 	ldr.w	r3, [r6, #284]	; 0x11c
	pdu_tx->llctrl.feature_req.features[0] =
   204fe:	7223      	strb	r3, [r4, #8]
		(conn->llcp_feature.features >> 8) & 0xFF;
   20500:	0a1a      	lsrs	r2, r3, #8
		(conn->llcp_feature.features >> 16) & 0xFF;
   20502:	0c1b      	lsrs	r3, r3, #16
	pdu_tx->llctrl.feature_req.features[2] =
   20504:	72a3      	strb	r3, [r4, #10]
	ctrl_tx_sec_enqueue(conn, tx);
   20506:	4630      	mov	r0, r6
	pdu_tx->llctrl.feature_req.features[1] =
   20508:	7262      	strb	r2, [r4, #9]
	ctrl_tx_sec_enqueue(conn, tx);
   2050a:	4621      	mov	r1, r4
   2050c:	f00b feff 	bl	2c30e <ctrl_tx_sec_enqueue>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   20510:	2303      	movs	r3, #3
   20512:	702b      	strb	r3, [r5, #0]
	return 0;
   20514:	2000      	movs	r0, #0
}
   20516:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -ENOBUFS;
   20518:	f06f 0036 	mvn.w	r0, #54	; 0x36
   2051c:	e7fb      	b.n	20516 <feature_rsp_send.isra.13+0x7e>
   2051e:	bf00      	nop
   20520:	200034bc 	.word	0x200034bc

00020524 <reject_ext_ind_send.isra.8>:
static int reject_ext_ind_send(struct ll_conn *conn, struct node_rx_pdu *rx,
   20524:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   20528:	4606      	mov	r6, r0
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   2052a:	480e      	ldr	r0, [pc, #56]	; (20564 <reject_ext_ind_send.isra.8+0x40>)
static int reject_ext_ind_send(struct ll_conn *conn, struct node_rx_pdu *rx,
   2052c:	460d      	mov	r5, r1
   2052e:	4690      	mov	r8, r2
   20530:	461f      	mov	r7, r3
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   20532:	f00b f9fd 	bl	2b930 <mem_acquire>
	if (!tx) {
   20536:	4601      	mov	r1, r0
   20538:	b188      	cbz	r0, 2055e <reject_ext_ind_send.isra.8+0x3a>
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   2053a:	7900      	ldrb	r0, [r0, #4]
	pdu_ctrl_tx->llctrl.reject_ext_ind.reject_opcode = reject_opcode;
   2053c:	f881 8008 	strb.w	r8, [r1, #8]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   20540:	f040 0003 	orr.w	r0, r0, #3
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
   20544:	2403      	movs	r4, #3
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
   20546:	2311      	movs	r3, #17
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   20548:	7108      	strb	r0, [r1, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
   2054a:	714c      	strb	r4, [r1, #5]
	ctrl_tx_enqueue(conn, tx);
   2054c:	4630      	mov	r0, r6
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
   2054e:	71cb      	strb	r3, [r1, #7]
	pdu_ctrl_tx->llctrl.reject_ext_ind.error_code = error_code;
   20550:	724f      	strb	r7, [r1, #9]
	ctrl_tx_enqueue(conn, tx);
   20552:	f00b ff07 	bl	2c364 <ctrl_tx_enqueue>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   20556:	702c      	strb	r4, [r5, #0]
	return 0;
   20558:	2000      	movs	r0, #0
}
   2055a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -ENOBUFS;
   2055e:	f06f 0036 	mvn.w	r0, #54	; 0x36
   20562:	e7fa      	b.n	2055a <reject_ext_ind_send.isra.8+0x36>
   20564:	200034bc 	.word	0x200034bc

00020568 <ll_conn_acquire>:
	return mem_acquire(&conn_free);
   20568:	4801      	ldr	r0, [pc, #4]	; (20570 <ll_conn_acquire+0x8>)
   2056a:	f00b b9e1 	b.w	2b930 <mem_acquire>
   2056e:	bf00      	nop
   20570:	20002898 	.word	0x20002898

00020574 <ll_conn_release>:
	mem_release(conn, &conn_free);
   20574:	4901      	ldr	r1, [pc, #4]	; (2057c <ll_conn_release+0x8>)
   20576:	f00b b9f4 	b.w	2b962 <mem_release>
   2057a:	bf00      	nop
   2057c:	20002898 	.word	0x20002898

00020580 <ll_conn_handle_get>:
	return mem_index_get(conn, conn_pool, sizeof(struct ll_conn));
   20580:	f44f 72e4 	mov.w	r2, #456	; 0x1c8
   20584:	4901      	ldr	r1, [pc, #4]	; (2058c <ll_conn_handle_get+0xc>)
   20586:	f00b ba04 	b.w	2b992 <mem_index_get>
   2058a:	bf00      	nop
   2058c:	2000289c 	.word	0x2000289c

00020590 <ll_conn_get>:
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
   20590:	4602      	mov	r2, r0
   20592:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
   20596:	4801      	ldr	r0, [pc, #4]	; (2059c <ll_conn_get+0xc>)
   20598:	f00b b9f8 	b.w	2b98c <mem_get>
   2059c:	2000289c 	.word	0x2000289c

000205a0 <ll_tx_mem_acquire>:
	return mem_acquire(&mem_conn_tx.free);
   205a0:	4801      	ldr	r0, [pc, #4]	; (205a8 <ll_tx_mem_acquire+0x8>)
   205a2:	f00b b9c5 	b.w	2b930 <mem_acquire>
   205a6:	bf00      	nop
   205a8:	20003194 	.word	0x20003194

000205ac <ll_tx_mem_release>:
	mem_release(tx, &mem_conn_tx.free);
   205ac:	4901      	ldr	r1, [pc, #4]	; (205b4 <ll_tx_mem_release+0x8>)
   205ae:	f00b b9d8 	b.w	2b962 <mem_release>
   205b2:	bf00      	nop
   205b4:	20003194 	.word	0x20003194

000205b8 <ll_tx_mem_enqueue>:
{
   205b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   205bc:	b088      	sub	sp, #32
   205be:	4606      	mov	r6, r0
   205c0:	4688      	mov	r8, r1
	conn = ll_connected_get(handle);
   205c2:	f00b fee2 	bl	2c38a <ll_connected_get>
	if (!conn) {
   205c6:	2800      	cmp	r0, #0
   205c8:	d045      	beq.n	20656 <ll_tx_mem_enqueue+0x9e>
	idx = MFIFO_ENQUEUE_GET(conn_tx, (void **) &lll_tx);
   205ca:	4c26      	ldr	r4, [pc, #152]	; (20664 <ll_tx_mem_enqueue+0xac>)
   205cc:	78e5      	ldrb	r5, [r4, #3]
	if (last == count) {
   205ce:	7867      	ldrb	r7, [r4, #1]
   205d0:	78a2      	ldrb	r2, [r4, #2]
   205d2:	7821      	ldrb	r1, [r4, #0]
	last = last + 1;
   205d4:	1c6b      	adds	r3, r5, #1
   205d6:	b2db      	uxtb	r3, r3
		last = 0U;
   205d8:	429f      	cmp	r7, r3
   205da:	bf08      	it	eq
   205dc:	2300      	moveq	r3, #0
	if (last == first) {
   205de:	429a      	cmp	r2, r3
   205e0:	d03c      	beq.n	2065c <ll_tx_mem_enqueue+0xa4>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   205e2:	1d22      	adds	r2, r4, #4
   205e4:	fb15 f501 	smulbb	r5, r5, r1
	if (!lll_tx) {
   205e8:	1957      	adds	r7, r2, r5
   205ea:	d037      	beq.n	2065c <ll_tx_mem_enqueue+0xa4>
	lll_tx->handle = handle;
   205ec:	5356      	strh	r6, [r2, r5]
	*last = idx; /* Commit: Update write index */
   205ee:	70e3      	strb	r3, [r4, #3]
	if (conn->lll.role && conn->lll.latency_event &&
   205f0:	f990 303d 	ldrsb.w	r3, [r0, #61]	; 0x3d
	lll_tx->node = tx;
   205f4:	f8c7 8004 	str.w	r8, [r7, #4]
	if (conn->lll.role && conn->lll.latency_event &&
   205f8:	2b00      	cmp	r3, #0
   205fa:	db03      	blt.n	20604 <ll_tx_mem_enqueue+0x4c>
	return 0;
   205fc:	2000      	movs	r0, #0
}
   205fe:	b008      	add	sp, #32
   20600:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (conn->lll.role && conn->lll.latency_event &&
   20604:	8e83      	ldrh	r3, [r0, #52]	; 0x34
   20606:	2b00      	cmp	r3, #0
   20608:	d0f8      	beq.n	205fc <ll_tx_mem_enqueue+0x44>
	    !conn->slave.latency_cancel) {
   2060a:	f890 30dc 	ldrb.w	r3, [r0, #220]	; 0xdc
	if (conn->lll.role && conn->lll.latency_event &&
   2060e:	f013 0402 	ands.w	r4, r3, #2
   20612:	d1f3      	bne.n	205fc <ll_tx_mem_enqueue+0x44>
		conn->slave.latency_cancel = 1U;
   20614:	f043 0302 	orr.w	r3, r3, #2
   20618:	f880 30dc 	strb.w	r3, [r0, #220]	; 0xdc
			ticker_update(TICKER_INSTANCE_ID_CTLR,
   2061c:	4b12      	ldr	r3, [pc, #72]	; (20668 <ll_tx_mem_enqueue+0xb0>)
   2061e:	9006      	str	r0, [sp, #24]
   20620:	e9cd 4304 	strd	r4, r3, [sp, #16]
				      (TICKER_ID_CONN_BASE + handle),
   20624:	1d72      	adds	r2, r6, #5
			ticker_update(TICKER_INSTANCE_ID_CTLR,
   20626:	2301      	movs	r3, #1
   20628:	e9cd 4302 	strd	r4, r3, [sp, #8]
   2062c:	e9cd 4400 	strd	r4, r4, [sp]
   20630:	4623      	mov	r3, r4
   20632:	b2d2      	uxtb	r2, r2
   20634:	2103      	movs	r1, #3
   20636:	4620      	mov	r0, r4
   20638:	f7fb fd88 	bl	1c14c <ticker_update>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   2063c:	f030 0302 	bics.w	r3, r0, #2
   20640:	d0dc      	beq.n	205fc <ll_tx_mem_enqueue+0x44>
   20642:	480a      	ldr	r0, [pc, #40]	; (2066c <ll_tx_mem_enqueue+0xb4>)
   20644:	f007 fd7e 	bl	28144 <printk>
   20648:	4040      	eors	r0, r0
   2064a:	f380 8811 	msr	BASEPRI, r0
   2064e:	f04f 0003 	mov.w	r0, #3
   20652:	df02      	svc	2
   20654:	e7d2      	b.n	205fc <ll_tx_mem_enqueue+0x44>
		return -EINVAL;
   20656:	f06f 0015 	mvn.w	r0, #21
   2065a:	e7d0      	b.n	205fe <ll_tx_mem_enqueue+0x46>
		return -ENOBUFS;
   2065c:	f06f 0036 	mvn.w	r0, #54	; 0x36
   20660:	e7cd      	b.n	205fe <ll_tx_mem_enqueue+0x46>
   20662:	bf00      	nop
   20664:	2000fd1c 	.word	0x2000fd1c
   20668:	000201c9 	.word	0x000201c9
   2066c:	00031c28 	.word	0x00031c28

00020670 <ll_length_default_get>:
	*max_tx_octets = default_tx_octets;
   20670:	4b03      	ldr	r3, [pc, #12]	; (20680 <ll_length_default_get+0x10>)
   20672:	881b      	ldrh	r3, [r3, #0]
   20674:	8003      	strh	r3, [r0, #0]
	*max_tx_time = default_tx_time;
   20676:	4b03      	ldr	r3, [pc, #12]	; (20684 <ll_length_default_get+0x14>)
   20678:	881b      	ldrh	r3, [r3, #0]
   2067a:	800b      	strh	r3, [r1, #0]
}
   2067c:	4770      	bx	lr
   2067e:	bf00      	nop
   20680:	20003cf4 	.word	0x20003cf4
   20684:	20003cf6 	.word	0x20003cf6

00020688 <ll_length_default_set>:
	default_tx_octets = max_tx_octets;
   20688:	4b02      	ldr	r3, [pc, #8]	; (20694 <ll_length_default_set+0xc>)
   2068a:	8018      	strh	r0, [r3, #0]
	default_tx_time = max_tx_time;
   2068c:	4b02      	ldr	r3, [pc, #8]	; (20698 <ll_length_default_set+0x10>)
}
   2068e:	2000      	movs	r0, #0
	default_tx_time = max_tx_time;
   20690:	8019      	strh	r1, [r3, #0]
}
   20692:	4770      	bx	lr
   20694:	20003cf4 	.word	0x20003cf4
   20698:	20003cf6 	.word	0x20003cf6

0002069c <ll_phy_default_set>:
	default_phy_tx = tx;
   2069c:	4b02      	ldr	r3, [pc, #8]	; (206a8 <ll_phy_default_set+0xc>)
   2069e:	7018      	strb	r0, [r3, #0]
	default_phy_rx = rx;
   206a0:	4b02      	ldr	r3, [pc, #8]	; (206ac <ll_phy_default_set+0x10>)
}
   206a2:	2000      	movs	r0, #0
	default_phy_rx = rx;
   206a4:	7019      	strb	r1, [r3, #0]
}
   206a6:	4770      	bx	lr
   206a8:	20003ea4 	.word	0x20003ea4
   206ac:	20003ea3 	.word	0x20003ea3

000206b0 <ull_conn_init>:
{
   206b0:	b508      	push	{r3, lr}
   206b2:	4806      	ldr	r0, [pc, #24]	; (206cc <ull_conn_init+0x1c>)
   206b4:	f005 fe26 	bl	26304 <z_impl_device_get_binding>
	entropy = device_get_binding(CONFIG_ENTROPY_NAME);
   206b8:	4b05      	ldr	r3, [pc, #20]	; (206d0 <ull_conn_init+0x20>)
   206ba:	6018      	str	r0, [r3, #0]
	if (!entropy) {
   206bc:	b118      	cbz	r0, 206c6 <ull_conn_init+0x16>
}
   206be:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	err = init_reset();
   206c2:	f7ff bd97 	b.w	201f4 <init_reset>
}
   206c6:	f06f 0012 	mvn.w	r0, #18
   206ca:	bd08      	pop	{r3, pc}
   206cc:	0003163e 	.word	0x0003163e
   206d0:	20003188 	.word	0x20003188

000206d4 <ull_conn_reset>:
{
   206d4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   206d8:	2400      	movs	r4, #0
	LL_ASSERT(mark == conn);
   206da:	4e2e      	ldr	r6, [pc, #184]	; (20794 <ull_conn_reset+0xc0>)
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   206dc:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 207b0 <ull_conn_reset+0xdc>
{
   206e0:	b085      	sub	sp, #20
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   206e2:	46a1      	mov	r9, r4
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   206e4:	2302      	movs	r3, #2
	conn = ll_conn_get(handle);
   206e6:	b2a0      	uxth	r0, r4
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
   206e8:	9303      	str	r3, [sp, #12]
	conn = ll_conn_get(handle);
   206ea:	f7ff ff51 	bl	20590 <ll_conn_get>
   206ee:	4605      	mov	r5, r0
	mark = ull_disable_mark(conn);
   206f0:	f7fd febc 	bl	1e46c <ull_disable_mark>
	LL_ASSERT(mark == conn);
   206f4:	4285      	cmp	r5, r0
   206f6:	d008      	beq.n	2070a <ull_conn_reset+0x36>
   206f8:	4630      	mov	r0, r6
   206fa:	f007 fd23 	bl	28144 <printk>
   206fe:	4040      	eors	r0, r0
   20700:	f380 8811 	msr	BASEPRI, r0
   20704:	f04f 0003 	mov.w	r0, #3
   20708:	df02      	svc	2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
   2070a:	af03      	add	r7, sp, #12
   2070c:	1d62      	adds	r2, r4, #5
   2070e:	2103      	movs	r1, #3
   20710:	9700      	str	r7, [sp, #0]
   20712:	4643      	mov	r3, r8
   20714:	b2d2      	uxtb	r2, r2
   20716:	2000      	movs	r0, #0
   20718:	f7fb fd60 	bl	1c1dc <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
   2071c:	4639      	mov	r1, r7
   2071e:	f7fd fe99 	bl	1e454 <ull_ticker_status_take>
	if (!ret) {
   20722:	b968      	cbnz	r0, 20740 <ull_conn_reset+0x6c>
		ret = ull_disable(&conn->lll);
   20724:	f105 001c 	add.w	r0, r5, #28
   20728:	f7fd fed8 	bl	1e4dc <ull_disable>
		LL_ASSERT(!ret);
   2072c:	b140      	cbz	r0, 20740 <ull_conn_reset+0x6c>
   2072e:	481a      	ldr	r0, [pc, #104]	; (20798 <ull_conn_reset+0xc4>)
   20730:	f007 fd08 	bl	28144 <printk>
   20734:	4040      	eors	r0, r0
   20736:	f380 8811 	msr	BASEPRI, r0
   2073a:	f04f 0003 	mov.w	r0, #3
   2073e:	df02      	svc	2
	conn->lll.link_tx_free = NULL;
   20740:	f8c5 9078 	str.w	r9, [r5, #120]	; 0x78
	mark = ull_disable_unmark(conn);
   20744:	4628      	mov	r0, r5
   20746:	f7fd fe99 	bl	1e47c <ull_disable_unmark>
	LL_ASSERT(mark == conn);
   2074a:	4285      	cmp	r5, r0
   2074c:	d008      	beq.n	20760 <ull_conn_reset+0x8c>
   2074e:	4630      	mov	r0, r6
   20750:	f007 fcf8 	bl	28144 <printk>
   20754:	4040      	eors	r0, r0
   20756:	f380 8811 	msr	BASEPRI, r0
   2075a:	f04f 0003 	mov.w	r0, #3
   2075e:	df02      	svc	2
   20760:	3401      	adds	r4, #1
	for (handle = 0U; handle < CONFIG_BT_MAX_CONN; handle++) {
   20762:	2c05      	cmp	r4, #5
   20764:	d1be      	bne.n	206e4 <ull_conn_reset+0x10>
	data_chan_map[0] = 0xFF;
   20766:	4b0d      	ldr	r3, [pc, #52]	; (2079c <ull_conn_reset+0xc8>)
   20768:	22ff      	movs	r2, #255	; 0xff
   2076a:	701a      	strb	r2, [r3, #0]
	data_chan_map[1] = 0xFF;
   2076c:	705a      	strb	r2, [r3, #1]
	data_chan_map[2] = 0xFF;
   2076e:	709a      	strb	r2, [r3, #2]
	data_chan_map[3] = 0xFF;
   20770:	70da      	strb	r2, [r3, #3]
	data_chan_map[4] = 0x1F;
   20772:	221f      	movs	r2, #31
   20774:	711a      	strb	r2, [r3, #4]
	data_chan_count = 37U;
   20776:	4b0a      	ldr	r3, [pc, #40]	; (207a0 <ull_conn_reset+0xcc>)
   20778:	2225      	movs	r2, #37	; 0x25
   2077a:	701a      	strb	r2, [r3, #0]
	MFIFO_INIT(conn_tx);
   2077c:	4a09      	ldr	r2, [pc, #36]	; (207a4 <ull_conn_reset+0xd0>)
   2077e:	2300      	movs	r3, #0
   20780:	8053      	strh	r3, [r2, #2]
	MFIFO_INIT(conn_ack);
   20782:	4a09      	ldr	r2, [pc, #36]	; (207a8 <ull_conn_reset+0xd4>)
   20784:	8053      	strh	r3, [r2, #2]
	conn_upd_curr = NULL;
   20786:	4a09      	ldr	r2, [pc, #36]	; (207ac <ull_conn_reset+0xd8>)
   20788:	6013      	str	r3, [r2, #0]
	err = init_reset();
   2078a:	f7ff fd33 	bl	201f4 <init_reset>
}
   2078e:	b005      	add	sp, #20
   20790:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   20794:	00031e12 	.word	0x00031e12
   20798:	0003166e 	.word	0x0003166e
   2079c:	2000fec6 	.word	0x2000fec6
   207a0:	2000fec5 	.word	0x2000fec5
   207a4:	2000fd1c 	.word	0x2000fd1c
   207a8:	2000fcd8 	.word	0x2000fcd8
   207ac:	20003184 	.word	0x20003184
   207b0:	0001e449 	.word	0x0001e449

000207b4 <ull_conn_chan_map_cpy>:
{
   207b4:	b508      	push	{r3, lr}
	memcpy(chan_map, data_chan_map, sizeof(data_chan_map));
   207b6:	2205      	movs	r2, #5
   207b8:	4902      	ldr	r1, [pc, #8]	; (207c4 <ull_conn_chan_map_cpy+0x10>)
   207ba:	f009 fe48 	bl	2a44e <memcpy>
}
   207be:	4b02      	ldr	r3, [pc, #8]	; (207c8 <ull_conn_chan_map_cpy+0x14>)
   207c0:	7818      	ldrb	r0, [r3, #0]
   207c2:	bd08      	pop	{r3, pc}
   207c4:	2000fec6 	.word	0x2000fec6
   207c8:	2000fec5 	.word	0x2000fec5

000207cc <ull_conn_chan_map_set>:
{
   207cc:	b510      	push	{r4, lr}
	memcpy(data_chan_map, chan_map, sizeof(data_chan_map));
   207ce:	4c06      	ldr	r4, [pc, #24]	; (207e8 <ull_conn_chan_map_set+0x1c>)
   207d0:	4601      	mov	r1, r0
   207d2:	2205      	movs	r2, #5
   207d4:	4620      	mov	r0, r4
   207d6:	f009 fe3a 	bl	2a44e <memcpy>
	data_chan_count = util_ones_count_get(data_chan_map,
   207da:	2105      	movs	r1, #5
   207dc:	4620      	mov	r0, r4
   207de:	f00b f923 	bl	2ba28 <util_ones_count_get>
   207e2:	4b02      	ldr	r3, [pc, #8]	; (207ec <ull_conn_chan_map_set+0x20>)
   207e4:	7018      	strb	r0, [r3, #0]
}
   207e6:	bd10      	pop	{r4, pc}
   207e8:	2000fec6 	.word	0x2000fec6
   207ec:	2000fec5 	.word	0x2000fec5

000207f0 <ull_conn_default_tx_octets_get>:
}
   207f0:	4b01      	ldr	r3, [pc, #4]	; (207f8 <ull_conn_default_tx_octets_get+0x8>)
   207f2:	8818      	ldrh	r0, [r3, #0]
   207f4:	4770      	bx	lr
   207f6:	bf00      	nop
   207f8:	20003cf4 	.word	0x20003cf4

000207fc <ull_conn_default_tx_time_get>:
}
   207fc:	4b01      	ldr	r3, [pc, #4]	; (20804 <ull_conn_default_tx_time_get+0x8>)
   207fe:	8818      	ldrh	r0, [r3, #0]
   20800:	4770      	bx	lr
   20802:	bf00      	nop
   20804:	20003cf6 	.word	0x20003cf6

00020808 <ull_conn_default_phy_tx_get>:
}
   20808:	4b01      	ldr	r3, [pc, #4]	; (20810 <ull_conn_default_phy_tx_get+0x8>)
   2080a:	7818      	ldrb	r0, [r3, #0]
   2080c:	4770      	bx	lr
   2080e:	bf00      	nop
   20810:	20003ea4 	.word	0x20003ea4

00020814 <ull_conn_default_phy_rx_get>:
}
   20814:	4b01      	ldr	r3, [pc, #4]	; (2081c <ull_conn_default_phy_rx_get+0x8>)
   20816:	7818      	ldrb	r0, [r3, #0]
   20818:	4770      	bx	lr
   2081a:	bf00      	nop
   2081c:	20003ea3 	.word	0x20003ea3

00020820 <ull_conn_setup>:
	lll = *((struct lll_conn **)((u8_t *)ftr->param +
   20820:	688b      	ldr	r3, [r1, #8]
   20822:	689b      	ldr	r3, [r3, #8]
{
   20824:	b510      	push	{r4, lr}
	switch (lll->role) {
   20826:	f893 4021 	ldrb.w	r4, [r3, #33]	; 0x21
   2082a:	09e4      	lsrs	r4, r4, #7
	ftr = &(rx->rx_ftr);
   2082c:	f101 0208 	add.w	r2, r1, #8
	switch (lll->role) {
   20830:	d00a      	beq.n	20848 <ull_conn_setup+0x28>
   20832:	b96c      	cbnz	r4, 20850 <ull_conn_setup+0x30>
		LL_ASSERT(0);
   20834:	4808      	ldr	r0, [pc, #32]	; (20858 <ull_conn_setup+0x38>)
   20836:	f007 fc85 	bl	28144 <printk>
   2083a:	4040      	eors	r0, r0
   2083c:	f380 8811 	msr	BASEPRI, r0
   20840:	f04f 0003 	mov.w	r0, #3
   20844:	df02      	svc	2
}
   20846:	bd10      	pop	{r4, pc}
   20848:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ull_master_setup(link, rx, ftr, lll);
   2084c:	f7ee b814 	b.w	e878 <ull_master_setup>
}
   20850:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ull_slave_setup(link, rx, ftr, lll);
   20854:	f7ed bdfc 	b.w	e450 <ull_slave_setup>
   20858:	000314f5 	.word	0x000314f5

0002085c <ull_conn_rx>:
{
   2085c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	conn = ll_connected_get((*rx)->hdr.handle);
   20860:	680b      	ldr	r3, [r1, #0]
{
   20862:	b085      	sub	sp, #20
   20864:	4680      	mov	r8, r0
	conn = ll_connected_get((*rx)->hdr.handle);
   20866:	88d8      	ldrh	r0, [r3, #6]
{
   20868:	460e      	mov	r6, r1
	conn = ll_connected_get((*rx)->hdr.handle);
   2086a:	f00b fd8e 	bl	2c38a <ll_connected_get>
	if (!conn) {
   2086e:	6835      	ldr	r5, [r6, #0]
   20870:	4604      	mov	r4, r0
   20872:	b910      	cbnz	r0, 2087a <ull_conn_rx+0x1e>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   20874:	2303      	movs	r3, #3
   20876:	712b      	strb	r3, [r5, #4]
	return 0;
   20878:	e1a5      	b.n	20bc6 <ull_conn_rx+0x36a>
	switch (pdu_rx->ll_id) {
   2087a:	f895 3020 	ldrb.w	r3, [r5, #32]
   2087e:	f890 7152 	ldrb.w	r7, [r0, #338]	; 0x152
   20882:	f3c3 0301 	ubfx	r3, r3, #0, #2
   20886:	b2d9      	uxtb	r1, r3
   20888:	b25b      	sxtb	r3, r3
   2088a:	f007 0201 	and.w	r2, r7, #1
   2088e:	2b00      	cmp	r3, #0
   20890:	f001 8212 	beq.w	21cb8 <ull_conn_rx+0x145c>
   20894:	2902      	cmp	r1, #2
   20896:	f241 820a 	bls.w	21cae <ull_conn_rx+0x1452>
			  struct pdu_data *pdu_rx, struct ll_conn *conn)
{
	int nack = 0;
	u8_t opcode;

	opcode = pdu_rx->llctrl.opcode;
   2089a:	f895 9023 	ldrb.w	r9, [r5, #35]	; 0x23

#if defined(CONFIG_BT_CTLR_LE_ENC)
	/* FIXME: do check in individual case to reduce CPU time */
	if (conn->llcp_enc.pause_rx && ctrl_is_unexpected(conn, opcode)) {
   2089e:	b14a      	cbz	r2, 208b4 <ull_conn_rx+0x58>
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)))) ||
   208a0:	f990 203d 	ldrsb.w	r2, [r0, #61]	; 0x3d
   208a4:	2a00      	cmp	r2, #0
   208a6:	f007 0304 	and.w	r3, r7, #4
   208aa:	db3d      	blt.n	20928 <ull_conn_rx+0xcc>
	return (!conn->lll.role &&
   208ac:	bb23      	cbnz	r3, 208f8 <ull_conn_rx+0x9c>
		((!conn->llcp_enc.refresh &&
   208ae:	f1b9 0f02 	cmp.w	r9, #2
   208b2:	d132      	bne.n	2091a <ull_conn_rx+0xbe>
	pdu_rx = (void *)(*rx)->pdu;
   208b4:	f105 0a20 	add.w	sl, r5, #32

		return 0;
	}
#endif /* CONFIG_BT_CTLR_LE_ENC */

	switch (opcode) {
   208b8:	f1b9 0f19 	cmp.w	r9, #25
   208bc:	f201 81e4 	bhi.w	21c88 <ull_conn_rx+0x142c>
   208c0:	e8df f019 	tbh	[pc, r9, lsl #1]
   208c4:	0108008e 	.word	0x0108008e
   208c8:	013c003a 	.word	0x013c003a
   208cc:	01a80183 	.word	0x01a80183
   208d0:	05f201ce 	.word	0x05f201ce
   208d4:	02250207 	.word	0x02250207
   208d8:	02820251 	.word	0x02820251
   208dc:	02f802a6 	.word	0x02f802a6
   208e0:	030b021c 	.word	0x030b021c
   208e4:	005d0498 	.word	0x005d0498
   208e8:	05e405cd 	.word	0x05e405cd
   208ec:	06ba06ba 	.word	0x06ba06ba
   208f0:	08a507c9 	.word	0x08a507c9
   208f4:	09ac08ee 	.word	0x09ac08ee
		 (conn->llcp_enc.refresh &&
   208f8:	f1a9 0302 	sub.w	r3, r9, #2
   208fc:	b2db      	uxtb	r3, r3
   208fe:	2b09      	cmp	r3, #9
   20900:	d80b      	bhi.n	2091a <ull_conn_rx+0xbe>
   20902:	f240 2205 	movw	r2, #517	; 0x205
   20906:	fa22 f303 	lsr.w	r3, r2, r3
   2090a:	07da      	lsls	r2, r3, #31
   2090c:	d4d2      	bmi.n	208b4 <ull_conn_rx+0x58>
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)) ||
   2090e:	4bd2      	ldr	r3, [pc, #840]	; (20c58 <ull_conn_rx+0x3fc>)
   20910:	fa23 f309 	lsr.w	r3, r3, r9
   20914:	07db      	lsls	r3, r3, #31
   20916:	d4cd      	bmi.n	208b4 <ull_conn_rx+0x58>
   20918:	e002      	b.n	20920 <ull_conn_rx+0xc4>
   2091a:	f1b9 0f11 	cmp.w	r9, #17
   2091e:	d9f6      	bls.n	2090e <ull_conn_rx+0xb2>
			conn->llcp_terminate.reason_peer =
   20920:	233d      	movs	r3, #61	; 0x3d
   20922:	f884 312b 	strb.w	r3, [r4, #299]	; 0x12b
   20926:	e171      	b.n	20c0c <ull_conn_rx+0x3b0>
	       (conn->lll.role &&
   20928:	b99b      	cbnz	r3, 20952 <ull_conn_rx+0xf6>
		((!conn->llcp_enc.refresh &&
   2092a:	f1b9 0f07 	cmp.w	r9, #7
   2092e:	f000 85bb 	beq.w	214a8 <ull_conn_rx+0xc4c>
		  (opcode != PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP) &&
   20932:	f1b9 0f02 	cmp.w	r9, #2
   20936:	d117      	bne.n	20968 <ull_conn_rx+0x10c>
		}
	}
	break;

	case PDU_DATA_LLCTRL_TYPE_TERMINATE_IND:
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_TERMINATE_IND,
   20938:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   2093c:	2002      	movs	r0, #2
   2093e:	f7ff fc25 	bl	2018c <pdu_len_cmp>
   20942:	2800      	cmp	r0, #0
   20944:	f001 81a0 	beq.w	21c88 <ull_conn_rx+0x142c>
				 pdu_rx->len)) {
			goto ull_conn_rx_unknown_rsp_send;
		}

		terminate_ind_recv(conn, *rx, pdu_rx);
   20948:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
	conn->llcp_terminate.reason_peer = pdu->llctrl.terminate_ind.error_code;
   2094c:	f884 312b 	strb.w	r3, [r4, #299]	; 0x12b
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   20950:	e790      	b.n	20874 <ull_conn_rx+0x18>
		 (conn->llcp_enc.refresh &&
   20952:	f1b9 0f02 	cmp.w	r9, #2
   20956:	d0ef      	beq.n	20938 <ull_conn_rx+0xdc>
		  (opcode != PDU_DATA_LLCTRL_TYPE_TERMINATE_IND) &&
   20958:	f1b9 0f0b 	cmp.w	r9, #11
   2095c:	f000 8234 	beq.w	20dc8 <ull_conn_rx+0x56c>
		  (opcode != PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP) &&
   20960:	f1b9 0f03 	cmp.w	r9, #3
   20964:	f000 80ea 	beq.w	20b3c <ull_conn_rx+0x2e0>
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)) ||
   20968:	f1b9 0f06 	cmp.w	r9, #6
   2096c:	f000 8178 	beq.w	20c60 <ull_conn_rx+0x404>
   20970:	f1b9 0f0d 	cmp.w	r9, #13
   20974:	f000 829e 	beq.w	20eb4 <ull_conn_rx+0x658>
	if (conn->llcp_enc.pause_rx && ctrl_is_unexpected(conn, opcode)) {
   20978:	f1b9 0f11 	cmp.w	r9, #17
   2097c:	d1d0      	bne.n	20920 <ull_conn_rx+0xc4>

		break;
#endif /* CONFIG_BT_CTLR_CONN_PARAM_REQ */

	case PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND:
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND,
   2097e:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   20982:	2011      	movs	r0, #17
   20984:	f7ff fc02 	bl	2018c <pdu_len_cmp>
   20988:	2800      	cmp	r0, #0
   2098a:	f001 817d 	beq.w	21c88 <ull_conn_rx+0x142c>
	switch (rej_ext_ind->reject_opcode) {
   2098e:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   20992:	2b0f      	cmp	r3, #15
   20994:	f000 84fa 	beq.w	2138c <ull_conn_rx+0xb30>
   20998:	f200 84be 	bhi.w	21318 <ull_conn_rx+0xabc>
   2099c:	2b03      	cmp	r3, #3
   2099e:	f47f af69 	bne.w	20874 <ull_conn_rx+0x18>
		if ((conn->llcp_ack != conn->llcp_req) &&
   209a2:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
   209a6:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
   209aa:	4293      	cmp	r3, r2
   209ac:	f43f af62 	beq.w	20874 <ull_conn_rx+0x18>
   209b0:	f894 30ea 	ldrb.w	r3, [r4, #234]	; 0xea
   209b4:	2b03      	cmp	r3, #3
   209b6:	f47f af5d 	bne.w	20874 <ull_conn_rx+0x18>
	conn->llcp_enc.pause_rx = 0U;
   209ba:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
	conn->llcp_ack = conn->llcp_req;
   209be:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
	conn->llcp_enc.pause_rx = 0U;
   209c2:	f023 0303 	bic.w	r3, r3, #3
	conn->procedure_expire = 0U;
   209c6:	2000      	movs	r0, #0
	conn->llcp_enc.pause_rx = 0U;
   209c8:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
	conn->procedure_expire = 0U;
   209cc:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
	pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
   209d0:	230d      	movs	r3, #13
   209d2:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
	pdu_rx->llctrl.reject_ind.error_code = rej_ext_ind->error_code;
   209d6:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
   209da:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
	if (err) {
   209de:	e1d6      	b.n	20d8e <ull_conn_rx+0x532>
		if (!conn->lll.role ||
   209e0:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   209e4:	2b00      	cmp	r3, #0
   209e6:	f281 814f 	bge.w	21c88 <ull_conn_rx+0x142c>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND,
   209ea:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   209ee:	2000      	movs	r0, #0
   209f0:	f7ff fbcc 	bl	2018c <pdu_len_cmp>
		if (!conn->lll.role ||
   209f4:	2800      	cmp	r0, #0
   209f6:	f001 8147 	beq.w	21c88 <ull_conn_rx+0x142c>
	instant = sys_le16_to_cpu(pdu->llctrl.conn_update_ind.instant);
   209fa:	f8b5 202d 	ldrh.w	r2, [r5, #45]	; 0x2d
	if (((instant - conn->lll.event_counter) & 0xFFFF) > 0x7FFF) {
   209fe:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   20a00:	1ad3      	subs	r3, r2, r3
   20a02:	041f      	lsls	r7, r3, #16
   20a04:	d505      	bpl.n	20a12 <ull_conn_rx+0x1b6>
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   20a06:	2303      	movs	r3, #3
   20a08:	712b      	strb	r3, [r5, #4]
		return BT_HCI_ERR_INSTANT_PASSED;
   20a0a:	2328      	movs	r3, #40	; 0x28
			goto ull_conn_rx_unknown_rsp_send;
		}

		err = phy_upd_ind_recv(conn, link, rx, pdu_rx);
		if (err) {
			conn->llcp_terminate.reason_peer = err;
   20a0c:	f884 312b 	strb.w	r3, [r4, #299]	; 0x12b
   20a10:	e0d9      	b.n	20bc6 <ull_conn_rx+0x36a>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   20a12:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   20a16:	f894 10e9 	ldrb.w	r1, [r4, #233]	; 0xe9
   20a1a:	1a5b      	subs	r3, r3, r1
   20a1c:	f003 0303 	and.w	r3, r3, #3
   20a20:	2b02      	cmp	r3, #2
   20a22:	d103      	bne.n	20a2c <ull_conn_rx+0x1d0>
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   20a24:	2303      	movs	r3, #3
   20a26:	712b      	strb	r3, [r5, #4]
		return BT_HCI_ERR_DIFF_TRANS_COLLISION;
   20a28:	232a      	movs	r3, #42	; 0x2a
   20a2a:	e7ef      	b.n	20a0c <ull_conn_rx+0x1b0>
	if (!conn_upd_curr) {
   20a2c:	4b8b      	ldr	r3, [pc, #556]	; (20c5c <ull_conn_rx+0x400>)
   20a2e:	6819      	ldr	r1, [r3, #0]
   20a30:	b901      	cbnz	r1, 20a34 <ull_conn_rx+0x1d8>
		conn_upd_curr = conn;
   20a32:	601c      	str	r4, [r3, #0]
	conn->llcp_cu.win_size = pdu->llctrl.conn_update_ind.win_size;
   20a34:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   20a38:	f884 3114 	strb.w	r3, [r4, #276]	; 0x114
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.win_offset) * 1250;
   20a3c:	f8b5 1025 	ldrh.w	r1, [r5, #37]	; 0x25
   20a40:	f240 43e2 	movw	r3, #1250	; 0x4e2
   20a44:	434b      	muls	r3, r1
	conn->llcp_cu.win_offset_us =
   20a46:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.interval);
   20a4a:	f895 1028 	ldrb.w	r1, [r5, #40]	; 0x28
   20a4e:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
   20a52:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	conn->llcp_cu.interval =
   20a56:	f8a4 3108 	strh.w	r3, [r4, #264]	; 0x108
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.latency);
   20a5a:	f895 102a 	ldrb.w	r1, [r5, #42]	; 0x2a
   20a5e:	f895 3029 	ldrb.w	r3, [r5, #41]	; 0x29
   20a62:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	conn->llcp_cu.latency =
   20a66:	f8a4 310a 	strh.w	r3, [r4, #266]	; 0x10a
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.timeout);
   20a6a:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
   20a6e:	f895 102c 	ldrb.w	r1, [r5, #44]	; 0x2c
	conn->llcp.conn_upd.instant = instant;
   20a72:	f8a4 20ec 	strh.w	r2, [r4, #236]	; 0xec
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.timeout);
   20a76:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
	conn->llcp_cu.timeout =
   20a7a:	f8a4 310c 	strh.w	r3, [r4, #268]	; 0x10c
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
   20a7e:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
   20a82:	f023 0307 	bic.w	r3, r3, #7
   20a86:	f043 0304 	orr.w	r3, r3, #4
   20a8a:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
	conn->llcp_cu.ack--;
   20a8e:	f894 3105 	ldrb.w	r3, [r4, #261]	; 0x105
   20a92:	3b01      	subs	r3, #1
   20a94:	f884 3105 	strb.w	r3, [r4, #261]	; 0x105
	link->mem = conn->llcp_rx;
   20a98:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
   20a9c:	f8c8 3004 	str.w	r3, [r8, #4]
	(*rx)->hdr.link = link;
   20aa0:	6833      	ldr	r3, [r6, #0]
   20aa2:	f8c3 8000 	str.w	r8, [r3]
	conn->llcp_rx = *rx;
   20aa6:	6833      	ldr	r3, [r6, #0]
   20aa8:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
	*rx = NULL;
   20aac:	2300      	movs	r3, #0
   20aae:	6033      	str	r3, [r6, #0]
	if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
   20ab0:	f894 2170 	ldrb.w	r2, [r4, #368]	; 0x170
   20ab4:	f894 3171 	ldrb.w	r3, [r4, #369]	; 0x171
   20ab8:	4293      	cmp	r3, r2
   20aba:	d007      	beq.n	20acc <ull_conn_rx+0x270>
	    (conn->llcp_conn_param.state == LLCP_CPR_STATE_RSP_WAIT)) {
   20abc:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
	if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
   20ac0:	f003 0307 	and.w	r3, r3, #7
   20ac4:	2b04      	cmp	r3, #4
   20ac6:	d101      	bne.n	20acc <ull_conn_rx+0x270>
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   20ac8:	f884 2171 	strb.w	r2, [r4, #369]	; 0x171
		conn->procedure_expire = 0U;
   20acc:	2000      	movs	r0, #0
   20ace:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
		break;
   20ad2:	e15c      	b.n	20d8e <ull_conn_rx+0x532>
		if (!conn->lll.role ||
   20ad4:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   20ad8:	2b00      	cmp	r3, #0
   20ada:	f281 80d5 	bge.w	21c88 <ull_conn_rx+0x142c>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_CHAN_MAP_IND,
   20ade:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   20ae2:	2001      	movs	r0, #1
   20ae4:	f7ff fb52 	bl	2018c <pdu_len_cmp>
		if (!conn->lll.role ||
   20ae8:	2800      	cmp	r0, #0
   20aea:	f001 80cd 	beq.w	21c88 <ull_conn_rx+0x142c>
	instant = sys_le16_to_cpu(pdu->llctrl.chan_map_ind.instant);
   20aee:	f8b5 6029 	ldrh.w	r6, [r5, #41]	; 0x29
	if (((instant - conn->lll.event_counter) & 0xffff) > 0x7fff) {
   20af2:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   20af4:	1af3      	subs	r3, r6, r3
   20af6:	0418      	lsls	r0, r3, #16
   20af8:	d485      	bmi.n	20a06 <ull_conn_rx+0x1aa>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   20afa:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   20afe:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
   20b02:	1a9b      	subs	r3, r3, r2
   20b04:	f003 0303 	and.w	r3, r3, #3
   20b08:	2b02      	cmp	r3, #2
   20b0a:	d08b      	beq.n	20a24 <ull_conn_rx+0x1c8>
	memcpy(&conn->llcp.chan_map.chm[0], &pdu->llctrl.chan_map_ind.chm[0],
   20b0c:	2205      	movs	r2, #5
   20b0e:	f105 0124 	add.w	r1, r5, #36	; 0x24
   20b12:	f104 00ed 	add.w	r0, r4, #237	; 0xed
   20b16:	f009 fc9a 	bl	2a44e <memcpy>
	conn->llcp.chan_map.initiate = 0U;
   20b1a:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
	conn->llcp.chan_map.instant = instant;
   20b1e:	f8a4 60f2 	strh.w	r6, [r4, #242]	; 0xf2
	conn->llcp.chan_map.initiate = 0U;
   20b22:	f36f 0300 	bfc	r3, #0, #1
   20b26:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
	conn->llcp_type = LLCP_CHAN_MAP;
   20b2a:	2302      	movs	r3, #2
   20b2c:	f884 30ea 	strb.w	r3, [r4, #234]	; 0xea
	conn->llcp_ack -= 2U;
   20b30:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
   20b34:	3b02      	subs	r3, #2
   20b36:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   20b3a:	e69b      	b.n	20874 <ull_conn_rx+0x18>
		if (!conn->lll.role ||
   20b3c:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   20b40:	2b00      	cmp	r3, #0
   20b42:	f281 80a1 	bge.w	21c88 <ull_conn_rx+0x142c>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_ENC_REQ, pdu_rx->len)) {
   20b46:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   20b4a:	2003      	movs	r0, #3
   20b4c:	f7ff fb1e 	bl	2018c <pdu_len_cmp>
		if (!conn->lll.role ||
   20b50:	2800      	cmp	r0, #0
   20b52:	f001 8099 	beq.w	21c88 <ull_conn_rx+0x142c>
		memcpy(&conn->llcp_enc.rand[0],
   20b56:	2208      	movs	r2, #8
   20b58:	f105 0124 	add.w	r1, r5, #36	; 0x24
   20b5c:	f204 1055 	addw	r0, r4, #341	; 0x155
   20b60:	f009 fc75 	bl	2a44e <memcpy>
		conn->llcp_enc.ediv[0] = pdu_rx->llctrl.enc_req.ediv[0];
   20b64:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
   20b68:	f884 3153 	strb.w	r3, [r4, #339]	; 0x153
		conn->llcp_enc.ediv[1] = pdu_rx->llctrl.enc_req.ediv[1];
   20b6c:	f895 302d 	ldrb.w	r3, [r5, #45]	; 0x2d
   20b70:	f884 3154 	strb.w	r3, [r4, #340]	; 0x154
		conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
   20b74:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
   20b78:	2201      	movs	r2, #1
   20b7a:	f362 0301 	bfi	r3, r2, #0, #2
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   20b7e:	6832      	ldr	r2, [r6, #0]
		conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
   20b80:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   20b84:	2303      	movs	r3, #3
   20b86:	7113      	strb	r3, [r2, #4]
		conn->llcp_type = LLCP_ENCRYPTION;
   20b88:	f884 30ea 	strb.w	r3, [r4, #234]	; 0xea
		conn->llcp_ack -= 2U;
   20b8c:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
   20b90:	3b02      	subs	r3, #2
   20b92:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
		memcpy(&conn->llcp.encryption.skd[0],
   20b96:	2208      	movs	r2, #8
   20b98:	f105 012e 	add.w	r1, r5, #46	; 0x2e
   20b9c:	f104 00ee 	add.w	r0, r4, #238	; 0xee
   20ba0:	f009 fc55 	bl	2a44e <memcpy>
		memcpy(&conn->lll.ccm_rx.iv[0],
   20ba4:	2204      	movs	r2, #4
   20ba6:	f105 0136 	add.w	r1, r5, #54	; 0x36
   20baa:	f104 0098 	add.w	r0, r4, #152	; 0x98
   20bae:	f009 fc4e 	bl	2a44e <memcpy>
		conn->llcp_enc.pause_rx = 1U;
   20bb2:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   20bb6:	f043 0301 	orr.w	r3, r3, #1
   20bba:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		conn->procedure_expire = conn->procedure_reload;
   20bbe:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
   20bc2:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	return 0;
   20bc6:	2000      	movs	r0, #0
		break;
   20bc8:	e0e1      	b.n	20d8e <ull_conn_rx+0x532>
		if (conn->lll.role ||
   20bca:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   20bce:	2b00      	cmp	r3, #0
   20bd0:	f2c1 805a 	blt.w	21c88 <ull_conn_rx+0x142c>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_ENC_RSP, pdu_rx->len)) {
   20bd4:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   20bd8:	2004      	movs	r0, #4
   20bda:	f7ff fad7 	bl	2018c <pdu_len_cmp>
		if (conn->lll.role ||
   20bde:	2800      	cmp	r0, #0
   20be0:	f001 8052 	beq.w	21c88 <ull_conn_rx+0x142c>
		memcpy(&conn->llcp.encryption.skd[8],
   20be4:	2208      	movs	r2, #8
   20be6:	f105 0124 	add.w	r1, r5, #36	; 0x24
   20bea:	f104 00f6 	add.w	r0, r4, #246	; 0xf6
   20bee:	f009 fc2e 	bl	2a44e <memcpy>
		memcpy(&conn->lll.ccm_rx.iv[4],
   20bf2:	2204      	movs	r2, #4
   20bf4:	f105 012c 	add.w	r1, r5, #44	; 0x2c
   20bf8:	f104 009c 	add.w	r0, r4, #156	; 0x9c
   20bfc:	f009 fc27 	bl	2a44e <memcpy>
		conn->llcp_enc.pause_rx = 1U;
   20c00:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   20c04:	f043 0301 	orr.w	r3, r3, #1
   20c08:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   20c0c:	6833      	ldr	r3, [r6, #0]
   20c0e:	2203      	movs	r2, #3
   20c10:	711a      	strb	r2, [r3, #4]
   20c12:	e7d8      	b.n	20bc6 <ull_conn_rx+0x36a>
		if (conn->lll.role || (conn->llcp_req == conn->llcp_ack) ||
   20c14:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   20c18:	2b00      	cmp	r3, #0
   20c1a:	f2c1 8035 	blt.w	21c88 <ull_conn_rx+0x142c>
   20c1e:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
   20c22:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
   20c26:	429a      	cmp	r2, r3
   20c28:	f001 802e 	beq.w	21c88 <ull_conn_rx+0x142c>
   20c2c:	f894 60ea 	ldrb.w	r6, [r4, #234]	; 0xea
   20c30:	2e03      	cmp	r6, #3
   20c32:	f041 8029 	bne.w	21c88 <ull_conn_rx+0x142c>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_START_ENC_REQ,
   20c36:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   20c3a:	2005      	movs	r0, #5
   20c3c:	f7ff faa6 	bl	2018c <pdu_len_cmp>
		    (conn->llcp_type != LLCP_ENCRYPTION) ||
   20c40:	2800      	cmp	r0, #0
   20c42:	f001 8021 	beq.w	21c88 <ull_conn_rx+0x142c>
		conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   20c46:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
   20c4a:	f36f 0301 	bfc	r3, #0, #2
   20c4e:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   20c52:	712e      	strb	r6, [r5, #4]
	return 0;
   20c54:	e7b7      	b.n	20bc6 <ull_conn_rx+0x36a>
   20c56:	bf00      	nop
   20c58:	00022060 	.word	0x00022060
   20c5c:	20003184 	.word	0x20003184
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_START_ENC_RSP,
   20c60:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   20c64:	2006      	movs	r0, #6
   20c66:	f7ff fa91 	bl	2018c <pdu_len_cmp>
   20c6a:	2800      	cmp	r0, #0
   20c6c:	f001 800c 	beq.w	21c88 <ull_conn_rx+0x142c>
		if (conn->lll.role) {
   20c70:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   20c74:	2b00      	cmp	r3, #0
   20c76:	da25      	bge.n	20cc4 <ull_conn_rx+0x468>
			if ((conn->llcp_req != conn->llcp_ack) &&
   20c78:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   20c7c:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
   20c80:	4293      	cmp	r3, r2
   20c82:	d004      	beq.n	20c8e <ull_conn_rx+0x432>
   20c84:	f894 10ea 	ldrb.w	r1, [r4, #234]	; 0xea
   20c88:	2903      	cmp	r1, #3
   20c8a:	f040 87fd 	bne.w	21c88 <ull_conn_rx+0x142c>
			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   20c8e:	f894 10ec 	ldrb.w	r1, [r4, #236]	; 0xec
			if (conn->llcp_req == conn->llcp_ack) {
   20c92:	4293      	cmp	r3, r2
			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   20c94:	f36f 0101 	bfc	r1, #0, #2
   20c98:	f884 10ec 	strb.w	r1, [r4, #236]	; 0xec
			if (conn->llcp_req == conn->llcp_ack) {
   20c9c:	d105      	bne.n	20caa <ull_conn_rx+0x44e>
				conn->llcp_type = LLCP_ENCRYPTION;
   20c9e:	2203      	movs	r2, #3
				conn->llcp_ack -= 2U;
   20ca0:	3b02      	subs	r3, #2
				conn->llcp_type = LLCP_ENCRYPTION;
   20ca2:	f884 20ea 	strb.w	r2, [r4, #234]	; 0xea
				conn->llcp_ack -= 2U;
   20ca6:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
		if (conn->llcp_enc.refresh) {
   20caa:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   20cae:	0759      	lsls	r1, r3, #29
   20cb0:	f57f af0c 	bpl.w	20acc <ull_conn_rx+0x270>
			conn->llcp_enc.refresh = 0U;
   20cb4:	f36f 0382 	bfc	r3, #2, #1
   20cb8:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
			(*rx)->hdr.type = NODE_RX_TYPE_ENC_REFRESH;
   20cbc:	6833      	ldr	r3, [r6, #0]
   20cbe:	220b      	movs	r2, #11
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   20cc0:	711a      	strb	r2, [r3, #4]
   20cc2:	e703      	b.n	20acc <ull_conn_rx+0x270>
			conn->llcp_enc.pause_rx = 0U;
   20cc4:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   20cc8:	f023 0303 	bic.w	r3, r3, #3
   20ccc:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
   20cd0:	e7eb      	b.n	20caa <ull_conn_rx+0x44e>
		if (!conn->lll.role ||
   20cd2:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   20cd6:	2b00      	cmp	r3, #0
   20cd8:	f280 87d6 	bge.w	21c88 <ull_conn_rx+0x142c>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_FEATURE_REQ,
   20cdc:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   20ce0:	2008      	movs	r0, #8
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_SLAVE_FEATURE_REQ,
   20ce2:	f7ff fa53 	bl	2018c <pdu_len_cmp>
		if (conn->lll.role ||
   20ce6:	2800      	cmp	r0, #0
   20ce8:	f000 87ce 	beq.w	21c88 <ull_conn_rx+0x142c>
		nack = feature_rsp_send(conn, *rx, pdu_rx);
   20cec:	4652      	mov	r2, sl
   20cee:	1d29      	adds	r1, r5, #4
   20cf0:	4620      	mov	r0, r4
}
   20cf2:	b005      	add	sp, #20
   20cf4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		nack = feature_rsp_send(conn, *rx, pdu_rx);
   20cf8:	f7ff bbce 	b.w	20498 <feature_rsp_send.isra.13>
		if (conn->lll.role ||
   20cfc:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   20d00:	2b00      	cmp	r3, #0
   20d02:	f2c0 87c1 	blt.w	21c88 <ull_conn_rx+0x142c>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_SLAVE_FEATURE_REQ,
   20d06:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   20d0a:	200e      	movs	r0, #14
   20d0c:	e7e9      	b.n	20ce2 <ull_conn_rx+0x486>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_FEATURE_RSP,
   20d0e:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   20d12:	2009      	movs	r0, #9
   20d14:	f7ff fa3a 	bl	2018c <pdu_len_cmp>
   20d18:	2800      	cmp	r0, #0
   20d1a:	f000 87b5 	beq.w	21c88 <ull_conn_rx+0x142c>
	       (features[1] << 8) | (features[2] << 16);
   20d1e:	f895 3026 	ldrb.w	r3, [r5, #38]	; 0x26
   20d22:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
   20d26:	041b      	lsls	r3, r3, #16
   20d28:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	feat = ~LL_FEAT_BIT_MASK_VALID | features[0] |
   20d2c:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
	       (features[1] << 8) | (features[2] << 16);
   20d30:	4313      	orrs	r3, r2
   20d32:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
   20d36:	f443 037e 	orr.w	r3, r3, #16646144	; 0xfe0000
	conn->llcp_feature.features &= feat_get(&rsp->features[0]);
   20d3a:	f8d4 211c 	ldr.w	r2, [r4, #284]	; 0x11c
	       (features[1] << 8) | (features[2] << 16);
   20d3e:	f443 5343 	orr.w	r3, r3, #12480	; 0x30c0
   20d42:	f043 0310 	orr.w	r3, r3, #16
	conn->llcp_feature.features &= feat_get(&rsp->features[0]);
   20d46:	4013      	ands	r3, r2
   20d48:	f3c3 0310 	ubfx	r3, r3, #0, #17
   20d4c:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
	conn->common.fex_valid = 1U;
   20d50:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
   20d54:	f043 0301 	orr.w	r3, r3, #1
   20d58:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
	conn->llcp_feature.ack = conn->llcp_feature.req;
   20d5c:	f894 3118 	ldrb.w	r3, [r4, #280]	; 0x118
   20d60:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119
	conn->procedure_expire = 0U;
   20d64:	e6b2      	b.n	20acc <ull_conn_rx+0x270>
		if (!conn->lll.role ||
   20d66:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   20d6a:	2b00      	cmp	r3, #0
   20d6c:	f280 878c 	bge.w	21c88 <ull_conn_rx+0x142c>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_REQ,
   20d70:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   20d74:	200a      	movs	r0, #10
   20d76:	f7ff fa09 	bl	2018c <pdu_len_cmp>
		if (!conn->lll.role ||
   20d7a:	2800      	cmp	r0, #0
   20d7c:	f000 8784 	beq.w	21c88 <ull_conn_rx+0x142c>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   20d80:	48c1      	ldr	r0, [pc, #772]	; (21088 <ull_conn_rx+0x82c>)
   20d82:	f00a fdd5 	bl	2b930 <mem_acquire>
		if (!tx) {
   20d86:	4601      	mov	r1, r0
   20d88:	b920      	cbnz	r0, 20d94 <ull_conn_rx+0x538>
			return -ENOBUFS;
   20d8a:	f06f 0036 	mvn.w	r0, #54	; 0x36
}
   20d8e:	b005      	add	sp, #20
   20d90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	conn->llcp_enc.pause_rx = 1U;
   20d94:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   20d98:	f023 0305 	bic.w	r3, r3, #5
   20d9c:	f043 0305 	orr.w	r3, r3, #5
   20da0:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
	conn->lll.enc_rx = 0;
   20da4:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
   20da8:	f36f 03c3 	bfc	r3, #3, #1
   20dac:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   20db0:	790b      	ldrb	r3, [r1, #4]
   20db2:	f043 0303 	orr.w	r3, r3, #3
   20db6:	710b      	strb	r3, [r1, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
   20db8:	2301      	movs	r3, #1
   20dba:	714b      	strb	r3, [r1, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP;
   20dbc:	230b      	movs	r3, #11
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_RSP;
   20dbe:	71cb      	strb	r3, [r1, #7]
	ctrl_tx_enqueue(conn, tx);
   20dc0:	4620      	mov	r0, r4
   20dc2:	f00b facf 	bl	2c364 <ctrl_tx_enqueue>
   20dc6:	e555      	b.n	20874 <ull_conn_rx+0x18>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP,
   20dc8:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   20dcc:	200b      	movs	r0, #11
   20dce:	f7ff f9dd 	bl	2018c <pdu_len_cmp>
   20dd2:	2800      	cmp	r0, #0
   20dd4:	f000 8758 	beq.w	21c88 <ull_conn_rx+0x142c>
	} else if (!conn->lll.role) {
   20dd8:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   20ddc:	2b00      	cmp	r3, #0
   20dde:	db10      	blt.n	20e02 <ull_conn_rx+0x5a6>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   20de0:	48a9      	ldr	r0, [pc, #676]	; (21088 <ull_conn_rx+0x82c>)
   20de2:	f00a fda5 	bl	2b930 <mem_acquire>
		if (!tx) {
   20de6:	4601      	mov	r1, r0
   20de8:	2800      	cmp	r0, #0
   20dea:	d0ce      	beq.n	20d8a <ull_conn_rx+0x52e>
	conn->llcp_enc.pause_rx = 1U;
   20dec:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   20df0:	f043 0301 	orr.w	r3, r3, #1
   20df4:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
	conn->lll.enc_rx = 0;
   20df8:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
   20dfc:	f023 0318 	bic.w	r3, r3, #24
   20e00:	e7d4      	b.n	20dac <ull_conn_rx+0x550>
		conn->lll.enc_tx = 0;
   20e02:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
   20e06:	f36f 1304 	bfc	r3, #4, #1
   20e0a:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   20e0e:	e531      	b.n	20874 <ull_conn_rx+0x18>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_VERSION_IND,
   20e10:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   20e14:	200c      	movs	r0, #12
   20e16:	f7ff f9b9 	bl	2018c <pdu_len_cmp>
   20e1a:	2800      	cmp	r0, #0
   20e1c:	f000 8734 	beq.w	21c88 <ull_conn_rx+0x142c>
	if (!conn->llcp_version.tx) {
   20e20:	f894 3122 	ldrb.w	r3, [r4, #290]	; 0x122
   20e24:	07da      	lsls	r2, r3, #31
   20e26:	d43e      	bmi.n	20ea6 <ull_conn_rx+0x64a>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   20e28:	4897      	ldr	r0, [pc, #604]	; (21088 <ull_conn_rx+0x82c>)
   20e2a:	f00a fd81 	bl	2b930 <mem_acquire>
		if (!tx) {
   20e2e:	4601      	mov	r1, r0
   20e30:	2800      	cmp	r0, #0
   20e32:	d0aa      	beq.n	20d8a <ull_conn_rx+0x52e>
		conn->llcp_version.tx = 1U;
   20e34:	f894 3122 	ldrb.w	r3, [r4, #290]	; 0x122
   20e38:	f043 0301 	orr.w	r3, r3, #1
   20e3c:	f884 3122 	strb.w	r3, [r4, #290]	; 0x122
		pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   20e40:	7903      	ldrb	r3, [r0, #4]
   20e42:	f043 0303 	orr.w	r3, r3, #3
   20e46:	7103      	strb	r3, [r0, #4]
		pdu_tx->len =
   20e48:	2306      	movs	r3, #6
   20e4a:	7143      	strb	r3, [r0, #5]
		pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
   20e4c:	230c      	movs	r3, #12
   20e4e:	71c3      	strb	r3, [r0, #7]
		v->version_number = LL_VERSION_NUMBER;
   20e50:	230a      	movs	r3, #10
   20e52:	7203      	strb	r3, [r0, #8]
		v->company_id =	sys_cpu_to_le16(ll_settings_company_id());
   20e54:	f06f 030e 	mvn.w	r3, #14
   20e58:	7243      	strb	r3, [r0, #9]
   20e5a:	2305      	movs	r3, #5
   20e5c:	7283      	strb	r3, [r0, #10]
		v->sub_version_number =
   20e5e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   20e62:	72c3      	strb	r3, [r0, #11]
   20e64:	7303      	strb	r3, [r0, #12]
		ctrl_tx_sec_enqueue(conn, tx);
   20e66:	4620      	mov	r0, r4
   20e68:	f00b fa51 	bl	2c30e <ctrl_tx_sec_enqueue>
		rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   20e6c:	2303      	movs	r3, #3
   20e6e:	712b      	strb	r3, [r5, #4]
	conn->llcp_version.version_number = v->version_number;
   20e70:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   20e74:	f884 3123 	strb.w	r3, [r4, #291]	; 0x123
	conn->llcp_version.company_id = sys_le16_to_cpu(v->company_id);
   20e78:	f895 2026 	ldrb.w	r2, [r5, #38]	; 0x26
   20e7c:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
   20e80:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   20e84:	f8a4 3124 	strh.w	r3, [r4, #292]	; 0x124
		sys_le16_to_cpu(v->sub_version_number);
   20e88:	f895 3027 	ldrb.w	r3, [r5, #39]	; 0x27
   20e8c:	f895 2028 	ldrb.w	r2, [r5, #40]	; 0x28
   20e90:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	conn->llcp_version.sub_version_number =
   20e94:	f8a4 3126 	strh.w	r3, [r4, #294]	; 0x126
	conn->llcp_version.rx = 1U;
   20e98:	f894 3122 	ldrb.w	r3, [r4, #290]	; 0x122
   20e9c:	f043 0302 	orr.w	r3, r3, #2
   20ea0:	f884 3122 	strb.w	r3, [r4, #290]	; 0x122
	return 0;
   20ea4:	e68f      	b.n	20bc6 <ull_conn_rx+0x36a>
	} else if (!conn->llcp_version.rx) {
   20ea6:	f013 0302 	ands.w	r3, r3, #2
   20eaa:	f47f ace3 	bne.w	20874 <ull_conn_rx+0x18>
		conn->procedure_expire = 0U;
   20eae:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
   20eb2:	e7dd      	b.n	20e70 <ull_conn_rx+0x614>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_REJECT_IND, pdu_rx->len)) {
   20eb4:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   20eb8:	200d      	movs	r0, #13
   20eba:	f7ff f967 	bl	2018c <pdu_len_cmp>
   20ebe:	2800      	cmp	r0, #0
   20ec0:	f000 86e2 	beq.w	21c88 <ull_conn_rx+0x142c>
		conn->llcp_enc.pause_rx = 0U;
   20ec4:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   20ec8:	f023 0303 	bic.w	r3, r3, #3
   20ecc:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		conn->llcp_ack = conn->llcp_req;
   20ed0:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   20ed4:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
		conn->procedure_expire = 0U;
   20ed8:	e5f8      	b.n	20acc <ull_conn_rx+0x270>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ,
   20eda:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   20ede:	200f      	movs	r0, #15
   20ee0:	f7ff f954 	bl	2018c <pdu_len_cmp>
   20ee4:	2800      	cmp	r0, #0
   20ee6:	f000 86cf 	beq.w	21c88 <ull_conn_rx+0x142c>
		if (conn_upd_curr && (conn_upd_curr != conn)) {
   20eea:	4b68      	ldr	r3, [pc, #416]	; (2108c <ull_conn_rx+0x830>)
   20eec:	6818      	ldr	r0, [r3, #0]
   20eee:	b150      	cbz	r0, 20f06 <ull_conn_rx+0x6aa>
   20ef0:	4284      	cmp	r4, r0
   20ef2:	d008      	beq.n	20f06 <ull_conn_rx+0x6aa>
			nack = reject_ext_ind_send(conn, *rx,
   20ef4:	2320      	movs	r3, #32
				nack = reject_ext_ind_send(conn, *rx,
   20ef6:	220f      	movs	r2, #15
				nack = reject_ext_ind_send(conn, *rx,
   20ef8:	1d29      	adds	r1, r5, #4
   20efa:	4620      	mov	r0, r4
}
   20efc:	b005      	add	sp, #20
   20efe:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
				nack = reject_ext_ind_send(conn, *rx,
   20f02:	f7ff bb0f 	b.w	20524 <reject_ext_ind_send.isra.8>
		if (!conn->lll.role) {
   20f06:	f994 103d 	ldrsb.w	r1, [r4, #61]	; 0x3d
   20f0a:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
   20f0e:	f894 2171 	ldrb.w	r2, [r4, #369]	; 0x171
   20f12:	2900      	cmp	r1, #0
   20f14:	f2c0 80bc 	blt.w	21090 <ull_conn_rx+0x834>
			if ((conn->llcp_conn_param.req !=
   20f18:	4293      	cmp	r3, r2
   20f1a:	d009      	beq.n	20f30 <ull_conn_rx+0x6d4>
			    ((conn->llcp_conn_param.state ==
   20f1c:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
					conn->llcp_conn_param.ack) &&
   20f20:	f013 0307 	ands.w	r3, r3, #7
   20f24:	d002      	beq.n	20f2c <ull_conn_rx+0x6d0>
			      LLCP_CPR_STATE_REQ) ||
   20f26:	3b04      	subs	r3, #4
   20f28:	2b01      	cmp	r3, #1
   20f2a:	d801      	bhi.n	20f30 <ull_conn_rx+0x6d4>
				nack = reject_ext_ind_send(conn, *rx,
   20f2c:	2323      	movs	r3, #35	; 0x23
   20f2e:	e7e2      	b.n	20ef6 <ull_conn_rx+0x69a>
			} else if (((((conn->llcp_req - conn->llcp_ack) &
   20f30:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   20f34:	f894 10e9 	ldrb.w	r1, [r4, #233]	; 0xe9
   20f38:	1a5b      	subs	r3, r3, r1
   20f3a:	f003 0303 	and.w	r3, r3, #3
   20f3e:	2b02      	cmp	r3, #2
   20f40:	d103      	bne.n	20f4a <ull_conn_rx+0x6ee>
				      0x03) == 0x02) &&
   20f42:	f894 30ea 	ldrb.w	r3, [r4, #234]	; 0xea
   20f46:	2b03      	cmp	r3, #3
   20f48:	d105      	bne.n	20f56 <ull_conn_rx+0x6fa>
				    (conn->llcp_type != LLCP_ENCRYPTION)) ||
   20f4a:	f894 11a8 	ldrb.w	r1, [r4, #424]	; 0x1a8
   20f4e:	f894 31a9 	ldrb.w	r3, [r4, #425]	; 0x1a9
   20f52:	4299      	cmp	r1, r3
   20f54:	d001      	beq.n	20f5a <ull_conn_rx+0x6fe>
				nack = reject_ext_ind_send(conn, *rx,
   20f56:	232a      	movs	r3, #42	; 0x2a
   20f58:	e7cd      	b.n	20ef6 <ull_conn_rx+0x69a>
				u16_t interval_min =
   20f5a:	f8b5 a024 	ldrh.w	sl, [r5, #36]	; 0x24
   20f5e:	fa1f f38a 	uxth.w	r3, sl
				if ((interval_min < 6) ||
   20f62:	2b05      	cmp	r3, #5
   20f64:	d925      	bls.n	20fb2 <ull_conn_rx+0x756>
				u16_t interval_max =
   20f66:	f8b5 9026 	ldrh.w	r9, [r5, #38]	; 0x26
   20f6a:	fa1f f189 	uxth.w	r1, r9
				if ((interval_min < 6) ||
   20f6e:	f5b1 6f48 	cmp.w	r1, #3200	; 0xc80
   20f72:	d81e      	bhi.n	20fb2 <ull_conn_rx+0x756>
				    (interval_max > 3200) ||
   20f74:	428b      	cmp	r3, r1
   20f76:	d81c      	bhi.n	20fb2 <ull_conn_rx+0x756>
				u16_t latency =
   20f78:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
   20f7a:	f8ad 3004 	strh.w	r3, [sp, #4]
   20f7e:	fa1f fc83 	uxth.w	ip, r3
				    (interval_min > interval_max) ||
   20f82:	f5bc 7ffa 	cmp.w	ip, #500	; 0x1f4
   20f86:	d214      	bcs.n	20fb2 <ull_conn_rx+0x756>
				u16_t timeout =
   20f88:	f8b5 b02a 	ldrh.w	fp, [r5, #42]	; 0x2a
   20f8c:	fa1f f38b 	uxth.w	r3, fp
				    (latency > 499) ||
   20f90:	f1a3 0e0a 	sub.w	lr, r3, #10
   20f94:	fa1f fe8e 	uxth.w	lr, lr
   20f98:	f640 4876 	movw	r8, #3190	; 0xc76
   20f9c:	45c6      	cmp	lr, r8
   20f9e:	d808      	bhi.n	20fb2 <ull_conn_rx+0x756>
				     ((latency + 1) * interval_max)) ||
   20fa0:	fb0c 1e01 	mla	lr, ip, r1, r1
				    (timeout > 3200) ||
   20fa4:	ebbe 0f83 	cmp.w	lr, r3, lsl #2
   20fa8:	d203      	bcs.n	20fb2 <ull_conn_rx+0x756>
					cpr->preferred_periodicity;
   20faa:	f895 e02c 	ldrb.w	lr, [r5, #44]	; 0x2c
				     ((latency + 1) * interval_max)) ||
   20fae:	4571      	cmp	r1, lr
   20fb0:	d201      	bcs.n	20fb6 <ull_conn_rx+0x75a>
				nack = reject_ext_ind_send(conn, *rx,
   20fb2:	231e      	movs	r3, #30
   20fb4:	e79f      	b.n	20ef6 <ull_conn_rx+0x69a>
				conn->llcp_conn_param.latency =	latency;
   20fb6:	f8bd 8004 	ldrh.w	r8, [sp, #4]
				conn->llcp_conn_param.interval_min =
   20fba:	f8a4 a174 	strh.w	sl, [r4, #372]	; 0x174
				conn->llcp_conn_param.interval_max =
   20fbe:	f8a4 9176 	strh.w	r9, [r4, #374]	; 0x176
				conn->llcp_conn_param.latency =	latency;
   20fc2:	f8a4 8178 	strh.w	r8, [r4, #376]	; 0x178
				conn->llcp_conn_param.timeout =	timeout;
   20fc6:	f8a4 b17a 	strh.w	fp, [r4, #378]	; 0x17a
				conn->llcp_conn_param.preferred_periodicity =
   20fca:	f884 e17c 	strb.w	lr, [r4, #380]	; 0x17c
					sys_le16_to_cpu(cpr->reference_conn_event_count);
   20fce:	f895 802e 	ldrb.w	r8, [r5, #46]	; 0x2e
   20fd2:	f895 e02d 	ldrb.w	lr, [r5, #45]	; 0x2d
   20fd6:	ea4e 2e08 	orr.w	lr, lr, r8, lsl #8
				conn->llcp_conn_param.reference_conn_event_count =
   20fda:	f8a4 e17e 	strh.w	lr, [r4, #382]	; 0x17e
					sys_le16_to_cpu(cpr->offset0);
   20fde:	f895 8030 	ldrb.w	r8, [r5, #48]	; 0x30
   20fe2:	f895 e02f 	ldrb.w	lr, [r5, #47]	; 0x2f
   20fe6:	ea4e 2e08 	orr.w	lr, lr, r8, lsl #8
				conn->llcp_conn_param.offset0 =
   20fea:	f8a4 e180 	strh.w	lr, [r4, #384]	; 0x180
					sys_le16_to_cpu(cpr->offset1);
   20fee:	f895 8032 	ldrb.w	r8, [r5, #50]	; 0x32
   20ff2:	f895 e031 	ldrb.w	lr, [r5, #49]	; 0x31
   20ff6:	ea4e 2e08 	orr.w	lr, lr, r8, lsl #8
				conn->llcp_conn_param.offset1 =
   20ffa:	f8a4 e182 	strh.w	lr, [r4, #386]	; 0x182
					sys_le16_to_cpu(cpr->offset2);
   20ffe:	f895 8034 	ldrb.w	r8, [r5, #52]	; 0x34
   21002:	f895 e033 	ldrb.w	lr, [r5, #51]	; 0x33
   21006:	ea4e 2e08 	orr.w	lr, lr, r8, lsl #8
				conn->llcp_conn_param.offset2 =
   2100a:	f8a4 e184 	strh.w	lr, [r4, #388]	; 0x184
					sys_le16_to_cpu(cpr->offset3);
   2100e:	f895 8036 	ldrb.w	r8, [r5, #54]	; 0x36
   21012:	f895 e035 	ldrb.w	lr, [r5, #53]	; 0x35
   21016:	ea4e 2e08 	orr.w	lr, lr, r8, lsl #8
				conn->llcp_conn_param.offset3 =
   2101a:	f8a4 e186 	strh.w	lr, [r4, #390]	; 0x186
					sys_le16_to_cpu(cpr->offset4);
   2101e:	f895 e037 	ldrb.w	lr, [r5, #55]	; 0x37
   21022:	f895 8038 	ldrb.w	r8, [r5, #56]	; 0x38
   21026:	ea4e 2e08 	orr.w	lr, lr, r8, lsl #8
				conn->llcp_conn_param.offset4 =
   2102a:	f8a4 e188 	strh.w	lr, [r4, #392]	; 0x188
					sys_le16_to_cpu(cpr->offset5);
   2102e:	f895 e039 	ldrb.w	lr, [r5, #57]	; 0x39
   21032:	f895 503a 	ldrb.w	r5, [r5, #58]	; 0x3a
   21036:	ea4e 2505 	orr.w	r5, lr, r5, lsl #8
				conn->llcp_conn_param.offset5 =
   2103a:	f8a4 518a 	strh.w	r5, [r4, #394]	; 0x18a
				     lll->interval) ||
   2103e:	8de5      	ldrh	r5, [r4, #46]	; 0x2e
				if ((conn->llcp_conn_param.interval_max !=
   21040:	42a9      	cmp	r1, r5
   21042:	d112      	bne.n	2106a <ull_conn_rx+0x80e>
				     lll->interval) ||
   21044:	8e21      	ldrh	r1, [r4, #48]	; 0x30
   21046:	4561      	cmp	r1, ip
   21048:	d10f      	bne.n	2106a <ull_conn_rx+0x80e>
				    (RADIO_CONN_EVENTS(conn->llcp_conn_param.timeout *
   2104a:	f240 41e2 	movw	r1, #1250	; 0x4e2
   2104e:	4369      	muls	r1, r5
   21050:	f242 7510 	movw	r5, #10000	; 0x2710
   21054:	fb05 1303 	mla	r3, r5, r3, r1
   21058:	3b01      	subs	r3, #1
   2105a:	fbb3 f3f1 	udiv	r3, r3, r1
				     lll->latency) ||
   2105e:	f8b4 10c6 	ldrh.w	r1, [r4, #198]	; 0xc6
   21062:	b29b      	uxth	r3, r3
   21064:	4299      	cmp	r1, r3
   21066:	f000 80b2 	beq.w	211ce <ull_conn_rx+0x972>
					if (conn->llcp_enc.pause_tx) {
   2106a:	f017 0f02 	tst.w	r7, #2
   2106e:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   21072:	f000 809e 	beq.w	211b2 <ull_conn_rx+0x956>
						conn->llcp_conn_param.state =
   21076:	2102      	movs	r1, #2
   21078:	f361 0302 	bfi	r3, r1, #0, #3
   2107c:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   21080:	6833      	ldr	r3, [r6, #0]
   21082:	2103      	movs	r1, #3
   21084:	7119      	strb	r1, [r3, #4]
   21086:	e099      	b.n	211bc <ull_conn_rx+0x960>
   21088:	200034bc 	.word	0x200034bc
   2108c:	20003184 	.word	0x20003184
		} else if ((conn->llcp_conn_param.req ==
   21090:	4293      	cmp	r3, r2
   21092:	d004      	beq.n	2109e <ull_conn_rx+0x842>
			    conn->llcp_conn_param.ack) ||
   21094:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   21098:	079b      	lsls	r3, r3, #30
   2109a:	f040 80a1 	bne.w	211e0 <ull_conn_rx+0x984>
			u16_t interval_min = sys_le16_to_cpu(cpr->interval_min);
   2109e:	f8b5 a024 	ldrh.w	sl, [r5, #36]	; 0x24
   210a2:	fa1f f38a 	uxth.w	r3, sl
			if ((interval_min < 6) ||
   210a6:	2b05      	cmp	r3, #5
   210a8:	d983      	bls.n	20fb2 <ull_conn_rx+0x756>
			u16_t interval_max = sys_le16_to_cpu(cpr->interval_max);
   210aa:	f8b5 9026 	ldrh.w	r9, [r5, #38]	; 0x26
   210ae:	fa1f f189 	uxth.w	r1, r9
			if ((interval_min < 6) ||
   210b2:	f5b1 6f48 	cmp.w	r1, #3200	; 0xc80
   210b6:	f63f af7c 	bhi.w	20fb2 <ull_conn_rx+0x756>
			    (interval_max > 3200) ||
   210ba:	428b      	cmp	r3, r1
   210bc:	f63f af79 	bhi.w	20fb2 <ull_conn_rx+0x756>
			u16_t latency = sys_le16_to_cpu(cpr->latency);
   210c0:	f8b5 8028 	ldrh.w	r8, [r5, #40]	; 0x28
   210c4:	fa1f f788 	uxth.w	r7, r8
			    (interval_min > interval_max) ||
   210c8:	f5b7 7ffa 	cmp.w	r7, #500	; 0x1f4
   210cc:	f4bf af71 	bcs.w	20fb2 <ull_conn_rx+0x756>
			u16_t timeout = sys_le16_to_cpu(cpr->timeout);
   210d0:	f8b5 e02a 	ldrh.w	lr, [r5, #42]	; 0x2a
   210d4:	fa1f f38e 	uxth.w	r3, lr
			    (latency > 499) ||
   210d8:	f1a3 0c0a 	sub.w	ip, r3, #10
   210dc:	fa1f fc8c 	uxth.w	ip, ip
   210e0:	f640 4b76 	movw	fp, #3190	; 0xc76
   210e4:	45dc      	cmp	ip, fp
   210e6:	f63f af64 	bhi.w	20fb2 <ull_conn_rx+0x756>
			     ((latency + 1) * interval_max)) ||
   210ea:	fb07 1c01 	mla	ip, r7, r1, r1
			    (timeout < 10) || (timeout > 3200) ||
   210ee:	ebbc 0f83 	cmp.w	ip, r3, lsl #2
   210f2:	f4bf af5e 	bcs.w	20fb2 <ull_conn_rx+0x756>
				cpr->preferred_periodicity;
   210f6:	f895 c02c 	ldrb.w	ip, [r5, #44]	; 0x2c
			     ((latency + 1) * interval_max)) ||
   210fa:	4561      	cmp	r1, ip
   210fc:	f4ff af59 	bcc.w	20fb2 <ull_conn_rx+0x756>
			conn->llcp_conn_param.interval_min = interval_min;
   21100:	f8a4 a174 	strh.w	sl, [r4, #372]	; 0x174
			conn->llcp_conn_param.interval_max = interval_max;
   21104:	f8a4 9176 	strh.w	r9, [r4, #374]	; 0x176
			conn->llcp_conn_param.latency =	latency;
   21108:	f8a4 8178 	strh.w	r8, [r4, #376]	; 0x178
			conn->llcp_conn_param.timeout =	timeout;
   2110c:	f8a4 e17a 	strh.w	lr, [r4, #378]	; 0x17a
			conn->llcp_conn_param.preferred_periodicity =
   21110:	f884 c17c 	strb.w	ip, [r4, #380]	; 0x17c
				sys_le16_to_cpu(cpr->reference_conn_event_count);
   21114:	f895 e02e 	ldrb.w	lr, [r5, #46]	; 0x2e
   21118:	f895 c02d 	ldrb.w	ip, [r5, #45]	; 0x2d
   2111c:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			conn->llcp_conn_param.reference_conn_event_count =
   21120:	f8a4 c17e 	strh.w	ip, [r4, #382]	; 0x17e
				sys_le16_to_cpu(cpr->offset0);
   21124:	f895 e030 	ldrb.w	lr, [r5, #48]	; 0x30
   21128:	f895 c02f 	ldrb.w	ip, [r5, #47]	; 0x2f
   2112c:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			conn->llcp_conn_param.offset0 =
   21130:	f8a4 c180 	strh.w	ip, [r4, #384]	; 0x180
				sys_le16_to_cpu(cpr->offset1);
   21134:	f895 e032 	ldrb.w	lr, [r5, #50]	; 0x32
   21138:	f895 c031 	ldrb.w	ip, [r5, #49]	; 0x31
   2113c:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			conn->llcp_conn_param.offset1 =
   21140:	f8a4 c182 	strh.w	ip, [r4, #386]	; 0x182
				sys_le16_to_cpu(cpr->offset2);
   21144:	f895 e034 	ldrb.w	lr, [r5, #52]	; 0x34
   21148:	f895 c033 	ldrb.w	ip, [r5, #51]	; 0x33
   2114c:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			conn->llcp_conn_param.offset2 =
   21150:	f8a4 c184 	strh.w	ip, [r4, #388]	; 0x184
				sys_le16_to_cpu(cpr->offset3);
   21154:	f895 e036 	ldrb.w	lr, [r5, #54]	; 0x36
   21158:	f895 c035 	ldrb.w	ip, [r5, #53]	; 0x35
   2115c:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			conn->llcp_conn_param.offset3 =
   21160:	f8a4 c186 	strh.w	ip, [r4, #390]	; 0x186
				sys_le16_to_cpu(cpr->offset4);
   21164:	f895 c037 	ldrb.w	ip, [r5, #55]	; 0x37
   21168:	f895 e038 	ldrb.w	lr, [r5, #56]	; 0x38
   2116c:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			conn->llcp_conn_param.offset4 =
   21170:	f8a4 c188 	strh.w	ip, [r4, #392]	; 0x188
				sys_le16_to_cpu(cpr->offset5);
   21174:	f895 c039 	ldrb.w	ip, [r5, #57]	; 0x39
   21178:	f895 503a 	ldrb.w	r5, [r5, #58]	; 0x3a
   2117c:	ea4c 2505 	orr.w	r5, ip, r5, lsl #8
			conn->llcp_conn_param.offset5 =
   21180:	f8a4 518a 	strh.w	r5, [r4, #394]	; 0x18a
			     lll->interval) ||
   21184:	8de5      	ldrh	r5, [r4, #46]	; 0x2e
			if ((conn->llcp_conn_param.interval_max !=
   21186:	42a9      	cmp	r1, r5
   21188:	d111      	bne.n	211ae <ull_conn_rx+0x952>
			     lll->interval) ||
   2118a:	8e25      	ldrh	r5, [r4, #48]	; 0x30
   2118c:	42bd      	cmp	r5, r7
   2118e:	d10e      	bne.n	211ae <ull_conn_rx+0x952>
			    (RADIO_CONN_EVENTS(conn->llcp_conn_param.timeout *
   21190:	f240 45e2 	movw	r5, #1250	; 0x4e2
   21194:	4369      	muls	r1, r5
   21196:	f242 7510 	movw	r5, #10000	; 0x2710
   2119a:	fb05 1303 	mla	r3, r5, r3, r1
   2119e:	3b01      	subs	r3, #1
   211a0:	fbb3 f3f1 	udiv	r3, r3, r1
			    (conn->llcp_conn_param.latency != lll->latency) ||
   211a4:	f8b4 10c6 	ldrh.w	r1, [r4, #198]	; 0xc6
   211a8:	b29b      	uxth	r3, r3
   211aa:	4299      	cmp	r1, r3
   211ac:	d00f      	beq.n	211ce <ull_conn_rx+0x972>
				conn->llcp_conn_param.state =
   211ae:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   211b2:	2103      	movs	r1, #3
   211b4:	f361 0302 	bfi	r3, r1, #0, #3
   211b8:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
			conn->llcp_conn_param.ack--;
   211bc:	3a01      	subs	r2, #1
   211be:	f884 2171 	strb.w	r2, [r4, #369]	; 0x171
			if (!conn_upd_curr) {
   211c2:	2800      	cmp	r0, #0
   211c4:	f47f acff 	bne.w	20bc6 <ull_conn_rx+0x36a>
				conn_upd_curr = conn;
   211c8:	4be1      	ldr	r3, [pc, #900]	; (21550 <ull_conn_rx+0xcf4>)
   211ca:	601c      	str	r4, [r3, #0]
   211cc:	e5df      	b.n	20d8e <ull_conn_rx+0x532>
				conn->llcp_conn_param.state =
   211ce:	f8b4 3172 	ldrh.w	r3, [r4, #370]	; 0x172
   211d2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   211d6:	f043 0301 	orr.w	r3, r3, #1
   211da:	f8a4 3172 	strh.w	r3, [r4, #370]	; 0x172
   211de:	e74f      	b.n	21080 <ull_conn_rx+0x824>
			LL_ASSERT(0);
   211e0:	48dc      	ldr	r0, [pc, #880]	; (21554 <ull_conn_rx+0xcf8>)
   211e2:	f006 ffaf 	bl	28144 <printk>
   211e6:	4040      	eors	r0, r0
   211e8:	f380 8811 	msr	BASEPRI, r0
   211ec:	f04f 0003 	mov.w	r0, #3
   211f0:	df02      	svc	2
   211f2:	e4e8      	b.n	20bc6 <ull_conn_rx+0x36a>
		if (conn->lll.role ||
   211f4:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   211f8:	2b00      	cmp	r3, #0
   211fa:	f2c0 8545 	blt.w	21c88 <ull_conn_rx+0x142c>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_CONN_PARAM_RSP,
   211fe:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   21202:	2010      	movs	r0, #16
   21204:	f7fe ffc2 	bl	2018c <pdu_len_cmp>
		if (conn->lll.role ||
   21208:	2800      	cmp	r0, #0
   2120a:	f000 853d 	beq.w	21c88 <ull_conn_rx+0x142c>
		if (!conn->lll.role &&
   2120e:	f894 2170 	ldrb.w	r2, [r4, #368]	; 0x170
   21212:	f894 3171 	ldrb.w	r3, [r4, #369]	; 0x171
   21216:	429a      	cmp	r2, r3
   21218:	f43f acf8 	beq.w	20c0c <ull_conn_rx+0x3b0>
		    (conn->llcp_conn_param.state ==
   2121c:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
		     conn->llcp_conn_param.ack) &&
   21220:	f003 0307 	and.w	r3, r3, #7
   21224:	2b04      	cmp	r3, #4
   21226:	f47f acf1 	bne.w	20c0c <ull_conn_rx+0x3b0>
			u16_t interval_min = sys_le16_to_cpu(cpr->interval_min);
   2122a:	f8b5 e024 	ldrh.w	lr, [r5, #36]	; 0x24
   2122e:	fa1f f28e 	uxth.w	r2, lr
			if ((interval_min < 6) ||
   21232:	2a05      	cmp	r2, #5
   21234:	d920      	bls.n	21278 <ull_conn_rx+0xa1c>
			u16_t interval_max = sys_le16_to_cpu(cpr->interval_max);
   21236:	f8b5 c026 	ldrh.w	ip, [r5, #38]	; 0x26
   2123a:	fa1f f38c 	uxth.w	r3, ip
			if ((interval_min < 6) ||
   2123e:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
   21242:	d819      	bhi.n	21278 <ull_conn_rx+0xa1c>
			    (interval_max > 3200) ||
   21244:	429a      	cmp	r2, r3
   21246:	d817      	bhi.n	21278 <ull_conn_rx+0xa1c>
			u16_t latency = sys_le16_to_cpu(cpr->latency);
   21248:	8d2f      	ldrh	r7, [r5, #40]	; 0x28
   2124a:	b2ba      	uxth	r2, r7
			    (interval_min > interval_max) ||
   2124c:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
   21250:	d212      	bcs.n	21278 <ull_conn_rx+0xa1c>
			u16_t timeout = sys_le16_to_cpu(cpr->timeout);
   21252:	8d68      	ldrh	r0, [r5, #42]	; 0x2a
   21254:	fa1f f880 	uxth.w	r8, r0
			    (latency > 499) ||
   21258:	f1a8 010a 	sub.w	r1, r8, #10
   2125c:	b289      	uxth	r1, r1
   2125e:	f640 4976 	movw	r9, #3190	; 0xc76
   21262:	4549      	cmp	r1, r9
   21264:	d808      	bhi.n	21278 <ull_conn_rx+0xa1c>
			     ((latency + 1) * interval_max)) ||
   21266:	fb02 3203 	mla	r2, r2, r3, r3
			    (timeout < 10) || (timeout > 3200) ||
   2126a:	ebb2 0f88 	cmp.w	r2, r8, lsl #2
   2126e:	d203      	bcs.n	21278 <ull_conn_rx+0xa1c>
				cpr->preferred_periodicity;
   21270:	f895 202c 	ldrb.w	r2, [r5, #44]	; 0x2c
			     ((latency + 1) * interval_max)) ||
   21274:	4293      	cmp	r3, r2
   21276:	d202      	bcs.n	2127e <ull_conn_rx+0xa22>
				nack = reject_ext_ind_send(conn, *rx,
   21278:	231e      	movs	r3, #30
   2127a:	2210      	movs	r2, #16
   2127c:	e63c      	b.n	20ef8 <ull_conn_rx+0x69c>
			conn->procedure_expire = 0U;
   2127e:	2300      	movs	r3, #0
   21280:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
			conn->llcp_conn_param.interval_min = interval_min;
   21284:	f8a4 e174 	strh.w	lr, [r4, #372]	; 0x174
			conn->llcp_conn_param.interval_max = interval_max;
   21288:	f8a4 c176 	strh.w	ip, [r4, #374]	; 0x176
			conn->llcp_conn_param.latency =	latency;
   2128c:	f8a4 7178 	strh.w	r7, [r4, #376]	; 0x178
			conn->llcp_conn_param.timeout =	timeout;
   21290:	f8a4 017a 	strh.w	r0, [r4, #378]	; 0x17a
			conn->llcp_conn_param.preferred_periodicity =
   21294:	f884 217c 	strb.w	r2, [r4, #380]	; 0x17c
				sys_le16_to_cpu(cpr->reference_conn_event_count);
   21298:	f895 202e 	ldrb.w	r2, [r5, #46]	; 0x2e
   2129c:	f895 302d 	ldrb.w	r3, [r5, #45]	; 0x2d
   212a0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.reference_conn_event_count =
   212a4:	f8a4 317e 	strh.w	r3, [r4, #382]	; 0x17e
				sys_le16_to_cpu(cpr->offset0);
   212a8:	f895 2030 	ldrb.w	r2, [r5, #48]	; 0x30
   212ac:	f895 302f 	ldrb.w	r3, [r5, #47]	; 0x2f
   212b0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset0 =
   212b4:	f8a4 3180 	strh.w	r3, [r4, #384]	; 0x180
				sys_le16_to_cpu(cpr->offset1);
   212b8:	f895 2032 	ldrb.w	r2, [r5, #50]	; 0x32
   212bc:	f895 3031 	ldrb.w	r3, [r5, #49]	; 0x31
   212c0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset1 =
   212c4:	f8a4 3182 	strh.w	r3, [r4, #386]	; 0x182
				sys_le16_to_cpu(cpr->offset2);
   212c8:	f895 2034 	ldrb.w	r2, [r5, #52]	; 0x34
   212cc:	f895 3033 	ldrb.w	r3, [r5, #51]	; 0x33
   212d0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset2 =
   212d4:	f8a4 3184 	strh.w	r3, [r4, #388]	; 0x184
				sys_le16_to_cpu(cpr->offset3);
   212d8:	f895 2036 	ldrb.w	r2, [r5, #54]	; 0x36
   212dc:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
   212e0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset3 =
   212e4:	f8a4 3186 	strh.w	r3, [r4, #390]	; 0x186
				sys_le16_to_cpu(cpr->offset4);
   212e8:	f895 2038 	ldrb.w	r2, [r5, #56]	; 0x38
   212ec:	f895 3037 	ldrb.w	r3, [r5, #55]	; 0x37
   212f0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset4 =
   212f4:	f8a4 3188 	strh.w	r3, [r4, #392]	; 0x188
				sys_le16_to_cpu(cpr->offset5);
   212f8:	f895 203a 	ldrb.w	r2, [r5, #58]	; 0x3a
   212fc:	f895 3039 	ldrb.w	r3, [r5, #57]	; 0x39
   21300:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			conn->llcp_conn_param.offset5 =
   21304:	f8a4 318a 	strh.w	r3, [r4, #394]	; 0x18a
			conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP;
   21308:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   2130c:	2201      	movs	r2, #1
   2130e:	f362 0302 	bfi	r3, r2, #0, #3
   21312:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   21316:	e479      	b.n	20c0c <ull_conn_rx+0x3b0>
	switch (rej_ext_ind->reject_opcode) {
   21318:	2b14      	cmp	r3, #20
   2131a:	f000 8081 	beq.w	21420 <ull_conn_rx+0xbc4>
   2131e:	2b16      	cmp	r3, #22
   21320:	f47f aaa8 	bne.w	20874 <ull_conn_rx+0x18>
		if (conn->llcp_phy.ack != conn->llcp_phy.req) {
   21324:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
   21328:	f894 21a9 	ldrb.w	r2, [r4, #425]	; 0x1a9
   2132c:	429a      	cmp	r2, r3
   2132e:	f43f aaa1 	beq.w	20874 <ull_conn_rx+0x18>
	if (rej_ext_ind->error_code != BT_HCI_ERR_LL_PROC_COLLISION) {
   21332:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
   21336:	2a23      	cmp	r2, #35	; 0x23
   21338:	d012      	beq.n	21360 <ull_conn_rx+0xb04>
		conn->llcp_phy.ack = conn->llcp_phy.req;
   2133a:	f884 31a9 	strb.w	r3, [r4, #425]	; 0x1a9
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   2133e:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
   21342:	f3c3 0102 	ubfx	r1, r3, #0, #3
   21346:	f361 1306 	bfi	r3, r1, #4, #3
   2134a:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
		conn->llcp_phy.pause_tx = 0U;
   2134e:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   21352:	f36f 0300 	bfc	r3, #0, #1
   21356:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
		conn->procedure_expire = 0U;
   2135a:	2300      	movs	r3, #0
   2135c:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	if (!conn->llcp_phy.cmd) {
   21360:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   21364:	075f      	lsls	r7, r3, #29
   21366:	f57f aa85 	bpl.w	20874 <ull_conn_rx+0x18>
	rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
   2136a:	230e      	movs	r3, #14
   2136c:	712b      	strb	r3, [r5, #4]
	p->status = rej_ext_ind->error_code;
   2136e:	f885 2020 	strb.w	r2, [r5, #32]
	p->tx = conn->lll.phy_tx;
   21372:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
   21376:	f3c3 0302 	ubfx	r3, r3, #0, #3
   2137a:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
	p->rx = conn->lll.phy_rx;
   2137e:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
   21382:	f3c3 0302 	ubfx	r3, r3, #0, #3
   21386:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
	if (err) {
   2138a:	e41c      	b.n	20bc6 <ull_conn_rx+0x36a>
		if (conn->llcp_conn_param.ack != conn->llcp_conn_param.req) {
   2138c:	f894 2171 	ldrb.w	r2, [r4, #369]	; 0x171
   21390:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
   21394:	429a      	cmp	r2, r3
   21396:	f43f aa6d 	beq.w	20874 <ull_conn_rx+0x18>
	if (!lll->role && (rej_ext_ind->error_code ==
   2139a:	f994 203d 	ldrsb.w	r2, [r4, #61]	; 0x3d
   2139e:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
   213a2:	2a00      	cmp	r2, #0
   213a4:	f2c0 8494 	blt.w	21cd0 <ull_conn_rx+0x1474>
   213a8:	2b1a      	cmp	r3, #26
   213aa:	f040 8497 	bne.w	21cdc <ull_conn_rx+0x1480>
		LL_ASSERT(conn->llcp_cu.req == conn->llcp_cu.ack);
   213ae:	f894 2104 	ldrb.w	r2, [r4, #260]	; 0x104
   213b2:	f894 3105 	ldrb.w	r3, [r4, #261]	; 0x105
   213b6:	429a      	cmp	r2, r3
   213b8:	d008      	beq.n	213cc <ull_conn_rx+0xb70>
   213ba:	4867      	ldr	r0, [pc, #412]	; (21558 <ull_conn_rx+0xcfc>)
   213bc:	f006 fec2 	bl	28144 <printk>
   213c0:	4040      	eors	r0, r0
   213c2:	f380 8811 	msr	BASEPRI, r0
   213c6:	f04f 0003 	mov.w	r0, #3
   213ca:	df02      	svc	2
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
   213cc:	f894 2172 	ldrb.w	r2, [r4, #370]	; 0x172
   213d0:	2305      	movs	r3, #5
   213d2:	f363 0202 	bfi	r2, r3, #0, #3
		conn->llcp_cu.win_offset_us = 0U;
   213d6:	2300      	movs	r3, #0
   213d8:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
		conn->llcp_cu.interval = conn->llcp_conn_param.interval_max;
   213dc:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
   213e0:	f8a4 3108 	strh.w	r3, [r4, #264]	; 0x108
		conn->llcp_cu.latency = conn->llcp_conn_param.latency;
   213e4:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
   213e8:	f8a4 310a 	strh.w	r3, [r4, #266]	; 0x10a
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
   213ec:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
   213f0:	f8a4 310c 	strh.w	r3, [r4, #268]	; 0x10c
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   213f4:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
   213f8:	f884 2172 	strb.w	r2, [r4, #370]	; 0x172
		conn->llcp_cu.win_size = 1U;
   213fc:	2101      	movs	r1, #1
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   213fe:	f361 0301 	bfi	r3, r1, #0, #2
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
   21402:	f3c2 02c0 	ubfx	r2, r2, #3, #1
   21406:	f362 0382 	bfi	r3, r2, #2, #1
   2140a:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
		conn->llcp_cu.ack--;
   2140e:	f894 3105 	ldrb.w	r3, [r4, #261]	; 0x105
		conn->llcp_cu.win_size = 1U;
   21412:	f884 1114 	strb.w	r1, [r4, #276]	; 0x114
		conn->llcp_cu.ack--;
   21416:	3b01      	subs	r3, #1
   21418:	f884 3105 	strb.w	r3, [r4, #261]	; 0x105
	if (err) {
   2141c:	f7ff ba2a 	b.w	20874 <ull_conn_rx+0x18>
		if (conn->llcp_length.ack != conn->llcp_length.req) {
   21420:	f894 3198 	ldrb.w	r3, [r4, #408]	; 0x198
   21424:	f894 2199 	ldrb.w	r2, [r4, #409]	; 0x199
   21428:	429a      	cmp	r2, r3
   2142a:	f43f aa23 	beq.w	20874 <ull_conn_rx+0x18>
	conn->llcp_length.ack = conn->llcp_length.req;
   2142e:	f884 3199 	strb.w	r3, [r4, #409]	; 0x199
	conn->procedure_expire = 0U;
   21432:	2000      	movs	r0, #0
	pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
   21434:	2309      	movs	r3, #9
	conn->procedure_expire = 0U;
   21436:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
	pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
   2143a:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
	pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
   2143e:	2315      	movs	r3, #21
   21440:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
	lr->max_rx_octets = sys_cpu_to_le16(conn->lll.max_rx_octets);
   21444:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
   21448:	84ab      	strh	r3, [r5, #36]	; 0x24
	lr->max_tx_octets = sys_cpu_to_le16(conn->lll.max_tx_octets);
   2144a:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
   2144e:	852b      	strh	r3, [r5, #40]	; 0x28
	lr->max_rx_time = sys_cpu_to_le16(conn->lll.max_rx_time);
   21450:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
   21454:	84eb      	strh	r3, [r5, #38]	; 0x26
	lr->max_tx_time = sys_cpu_to_le16(conn->lll.max_tx_time);
   21456:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
   2145a:	856b      	strh	r3, [r5, #42]	; 0x2a
	if (err) {
   2145c:	e497      	b.n	20d8e <ull_conn_rx+0x532>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PING_REQ, pdu_rx->len)) {
   2145e:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   21462:	2012      	movs	r0, #18
   21464:	f7fe fe92 	bl	2018c <pdu_len_cmp>
   21468:	2800      	cmp	r0, #0
   2146a:	f000 840d 	beq.w	21c88 <ull_conn_rx+0x142c>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   2146e:	483b      	ldr	r0, [pc, #236]	; (2155c <ull_conn_rx+0xd00>)
   21470:	f00a fa5e 	bl	2b930 <mem_acquire>
	if (!tx) {
   21474:	4601      	mov	r1, r0
   21476:	2800      	cmp	r0, #0
   21478:	f43f ac87 	beq.w	20d8a <ull_conn_rx+0x52e>
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   2147c:	7903      	ldrb	r3, [r0, #4]
   2147e:	f043 0303 	orr.w	r3, r3, #3
   21482:	7103      	strb	r3, [r0, #4]
	pdu_tx->len = offsetof(struct pdu_data_llctrl, ping_rsp) +
   21484:	2301      	movs	r3, #1
   21486:	7143      	strb	r3, [r0, #5]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_RSP;
   21488:	2313      	movs	r3, #19
   2148a:	e498      	b.n	20dbe <ull_conn_rx+0x562>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PING_RSP, pdu_rx->len)) {
   2148c:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   21490:	2013      	movs	r0, #19
   21492:	f7fe fe7b 	bl	2018c <pdu_len_cmp>
   21496:	2800      	cmp	r0, #0
   21498:	f000 83f6 	beq.w	21c88 <ull_conn_rx+0x142c>
		conn->procedure_expire = 0U;
   2149c:	2000      	movs	r0, #0
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   2149e:	2303      	movs	r3, #3
		conn->procedure_expire = 0U;
   214a0:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   214a4:	712b      	strb	r3, [r5, #4]
		break;
   214a6:	e472      	b.n	20d8e <ull_conn_rx+0x532>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP,
   214a8:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   214ac:	2007      	movs	r0, #7
   214ae:	f7fe fe6d 	bl	2018c <pdu_len_cmp>
   214b2:	2800      	cmp	r0, #0
   214b4:	f000 83e8 	beq.w	21c88 <ull_conn_rx+0x142c>
		} else if (conn->llcp_conn_param.ack !=
   214b8:	f894 2171 	ldrb.w	r2, [r4, #369]	; 0x171
   214bc:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
   214c0:	429a      	cmp	r2, r3
   214c2:	d07b      	beq.n	215bc <ull_conn_rx+0xd60>
			conn->llcp_conn_param.disabled = 1U;
   214c4:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   214c8:	f043 0310 	orr.w	r3, r3, #16
   214cc:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
			if (!conn->lll.role) {
   214d0:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   214d4:	2b00      	cmp	r3, #0
   214d6:	db43      	blt.n	21560 <ull_conn_rx+0xd04>
				LL_ASSERT(conn->llcp_cu.req ==
   214d8:	f894 2104 	ldrb.w	r2, [r4, #260]	; 0x104
   214dc:	f894 3105 	ldrb.w	r3, [r4, #261]	; 0x105
   214e0:	429a      	cmp	r2, r3
   214e2:	d008      	beq.n	214f6 <ull_conn_rx+0xc9a>
   214e4:	481c      	ldr	r0, [pc, #112]	; (21558 <ull_conn_rx+0xcfc>)
   214e6:	f006 fe2d 	bl	28144 <printk>
   214ea:	4040      	eors	r0, r0
   214ec:	f380 8811 	msr	BASEPRI, r0
   214f0:	f04f 0003 	mov.w	r0, #3
   214f4:	df02      	svc	2
				conn->llcp_conn_param.state =
   214f6:	f894 2172 	ldrb.w	r2, [r4, #370]	; 0x172
   214fa:	2305      	movs	r3, #5
   214fc:	f363 0202 	bfi	r2, r3, #0, #3
				conn->llcp_cu.interval =
   21500:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
   21504:	f8a4 3108 	strh.w	r3, [r4, #264]	; 0x108
				conn->llcp_cu.latency =
   21508:	f8b4 3178 	ldrh.w	r3, [r4, #376]	; 0x178
   2150c:	f8a4 310a 	strh.w	r3, [r4, #266]	; 0x10a
				conn->llcp_cu.timeout =
   21510:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
   21514:	f8a4 310c 	strh.w	r3, [r4, #268]	; 0x10c
				conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   21518:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
				conn->llcp_conn_param.state =
   2151c:	f884 2172 	strb.w	r2, [r4, #370]	; 0x172
				conn->llcp_cu.win_size = 1U;
   21520:	2101      	movs	r1, #1
				conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   21522:	f361 0301 	bfi	r3, r1, #0, #2
				conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
   21526:	f3c2 02c0 	ubfx	r2, r2, #3, #1
   2152a:	f362 0382 	bfi	r3, r2, #2, #1
   2152e:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
				conn->llcp_cu.ack--;
   21532:	f894 3105 	ldrb.w	r3, [r4, #261]	; 0x105
				conn->llcp_cu.win_size = 1U;
   21536:	f884 1114 	strb.w	r1, [r4, #276]	; 0x114
				conn->llcp_cu.ack--;
   2153a:	3b01      	subs	r3, #1
   2153c:	f884 3105 	strb.w	r3, [r4, #261]	; 0x105
				conn->llcp_cu.win_offset_us = 0U;
   21540:	2000      	movs	r0, #0
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   21542:	6833      	ldr	r3, [r6, #0]
				conn->llcp_cu.win_offset_us = 0U;
   21544:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   21548:	2203      	movs	r2, #3
   2154a:	711a      	strb	r2, [r3, #4]
				break;
   2154c:	e41f      	b.n	20d8e <ull_conn_rx+0x532>
   2154e:	bf00      	nop
   21550:	20003184 	.word	0x20003184
   21554:	000314f5 	.word	0x000314f5
   21558:	00031e31 	.word	0x00031e31
   2155c:	200034bc 	.word	0x200034bc
			LL_ASSERT(conn_upd_curr == conn);
   21560:	4fcb      	ldr	r7, [pc, #812]	; (21890 <ull_conn_rx+0x1034>)
   21562:	683a      	ldr	r2, [r7, #0]
   21564:	4294      	cmp	r4, r2
   21566:	d008      	beq.n	2157a <ull_conn_rx+0xd1e>
   21568:	48ca      	ldr	r0, [pc, #808]	; (21894 <ull_conn_rx+0x1038>)
   2156a:	f006 fdeb 	bl	28144 <printk>
   2156e:	4040      	eors	r0, r0
   21570:	f380 8811 	msr	BASEPRI, r0
   21574:	f04f 0003 	mov.w	r0, #3
   21578:	df02      	svc	2
			conn_upd_curr = NULL;
   2157a:	2300      	movs	r3, #0
			if (!conn->llcp_conn_param.cmd) {
   2157c:	f894 0172 	ldrb.w	r0, [r4, #370]	; 0x172
			conn_upd_curr = NULL;
   21580:	603b      	str	r3, [r7, #0]
			conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   21582:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
   21586:	f884 3171 	strb.w	r3, [r4, #369]	; 0x171
			if (!conn->llcp_conn_param.cmd) {
   2158a:	f010 0008 	ands.w	r0, r0, #8
   2158e:	6833      	ldr	r3, [r6, #0]
   21590:	d0da      	beq.n	21548 <ull_conn_rx+0xcec>
			(*rx)->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
   21592:	220a      	movs	r2, #10
   21594:	711a      	strb	r2, [r3, #4]
			cu->status = BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
   21596:	231a      	movs	r3, #26
   21598:	f885 3020 	strb.w	r3, [r5, #32]
			cu->latency = lll->latency;
   2159c:	8e22      	ldrh	r2, [r4, #48]	; 0x30
			cu->interval = lll->interval;
   2159e:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
			cu->latency = lll->latency;
   215a0:	84aa      	strh	r2, [r5, #36]	; 0x24
			cu->timeout = conn->supervision_reload *
   215a2:	f8b4 20c6 	ldrh.w	r2, [r4, #198]	; 0xc6
			cu->interval = lll->interval;
   215a6:	846b      	strh	r3, [r5, #34]	; 0x22
			cu->timeout = conn->supervision_reload *
   215a8:	435a      	muls	r2, r3
				      lll->interval * 125U / 1000;
   215aa:	237d      	movs	r3, #125	; 0x7d
   215ac:	4353      	muls	r3, r2
   215ae:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   215b2:	fbb3 f3f2 	udiv	r3, r3, r2
			cu->timeout = conn->supervision_reload *
   215b6:	84eb      	strh	r3, [r5, #38]	; 0x26
   215b8:	f7ff ba88 	b.w	20acc <ull_conn_rx+0x270>
		} else if (conn->llcp_length.req != conn->llcp_length.ack) {
   215bc:	f894 3198 	ldrb.w	r3, [r4, #408]	; 0x198
   215c0:	f894 2199 	ldrb.w	r2, [r4, #409]	; 0x199
   215c4:	429a      	cmp	r2, r3
   215c6:	d003      	beq.n	215d0 <ull_conn_rx+0xd74>
			conn->llcp_length.ack = conn->llcp_length.req;
   215c8:	f884 3199 	strb.w	r3, [r4, #409]	; 0x199
   215cc:	f7ff ba7e 	b.w	20acc <ull_conn_rx+0x270>
		} else if (conn->llcp_phy.req !=
   215d0:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
   215d4:	f894 21a9 	ldrb.w	r2, [r4, #425]	; 0x1a9
   215d8:	429a      	cmp	r2, r3
   215da:	d025      	beq.n	21628 <ull_conn_rx+0xdcc>
			conn->llcp_phy.ack = conn->llcp_phy.req;
   215dc:	f884 31a9 	strb.w	r3, [r4, #425]	; 0x1a9
			lll->phy_tx_time = lll->phy_tx;
   215e0:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
			conn->llcp_phy.pause_tx = 0U;
   215e4:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
			lll->phy_tx_time = lll->phy_tx;
   215e8:	f3c3 0102 	ubfx	r1, r3, #0, #3
			conn->llcp_phy.pause_tx = 0U;
   215ec:	f36f 0200 	bfc	r2, #0, #1
			lll->phy_tx_time = lll->phy_tx;
   215f0:	f361 1306 	bfi	r3, r1, #4, #3
			conn->llcp_phy.pause_tx = 0U;
   215f4:	f884 21ab 	strb.w	r2, [r4, #427]	; 0x1ab
			lll->phy_tx_time = lll->phy_tx;
   215f8:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
			if (conn->llcp_phy.cmd) {
   215fc:	f012 0f04 	tst.w	r2, #4
   21600:	6833      	ldr	r3, [r6, #0]
   21602:	d00e      	beq.n	21622 <ull_conn_rx+0xdc6>
				(*rx)->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
   21604:	220e      	movs	r2, #14
   21606:	711a      	strb	r2, [r3, #4]
				p->status = 0U;
   21608:	2300      	movs	r3, #0
   2160a:	f885 3020 	strb.w	r3, [r5, #32]
				p->tx = lll->phy_tx;
   2160e:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21
				p->rx = lll->phy_rx;
   21612:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
   21616:	f3c3 0302 	ubfx	r3, r3, #0, #3
   2161a:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   2161e:	f7ff ba55 	b.w	20acc <ull_conn_rx+0x270>
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   21622:	2203      	movs	r2, #3
   21624:	f7ff bb4c 	b.w	20cc0 <ull_conn_rx+0x464>
			switch (llctrl->unknown_rsp.type) {
   21628:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   2162c:	2b12      	cmp	r3, #18
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   2162e:	bf04      	itt	eq
   21630:	2303      	moveq	r3, #3
   21632:	712b      	strbeq	r3, [r5, #4]
				break;
   21634:	f7ff ba4a 	b.w	20acc <ull_conn_rx+0x270>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_LENGTH_REQ,
   21638:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   2163c:	2014      	movs	r0, #20
   2163e:	f7fe fda5 	bl	2018c <pdu_len_cmp>
   21642:	2800      	cmp	r0, #0
   21644:	f000 8320 	beq.w	21c88 <ull_conn_rx+0x142c>
	if (pdu_rx->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_LENGTH_REQ) {
   21648:	f1b9 0f14 	cmp.w	r9, #20
   2164c:	f040 80a1 	bne.w	21792 <ull_conn_rx+0xf36>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
   21650:	4891      	ldr	r0, [pc, #580]	; (21898 <ull_conn_rx+0x103c>)
   21652:	f00a f96d 	bl	2b930 <mem_acquire>
		if (!tx) {
   21656:	4607      	mov	r7, r0
   21658:	2800      	cmp	r0, #0
   2165a:	f43f ab96 	beq.w	20d8a <ull_conn_rx+0x52e>
	eff_rx_octets = conn->lll.max_rx_octets;
   2165e:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
   21662:	9301      	str	r3, [sp, #4]
	    ((conn->llcp_length.req == conn->llcp_length.ack) &&
   21664:	f894 3198 	ldrb.w	r3, [r4, #408]	; 0x198
   21668:	9302      	str	r3, [sp, #8]
	if (/* Local idle, and Peer request then complete the Peer procedure
   2166a:	f894 2199 	ldrb.w	r2, [r4, #409]	; 0x199
   2166e:	9902      	ldr	r1, [sp, #8]
	eff_tx_octets = conn->lll.max_tx_octets;
   21670:	f8b4 905c 	ldrh.w	r9, [r4, #92]	; 0x5c
	eff_rx_time = conn->lll.max_rx_time;
   21674:	f8b4 a062 	ldrh.w	sl, [r4, #98]	; 0x62
	eff_tx_time = conn->lll.max_tx_time;
   21678:	f8b4 b060 	ldrh.w	fp, [r4, #96]	; 0x60
	if (/* Local idle, and Peer request then complete the Peer procedure
   2167c:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
   21680:	428a      	cmp	r2, r1
   21682:	f040 8088 	bne.w	21796 <ull_conn_rx+0xf3a>
	    ((conn->llcp_length.req == conn->llcp_length.ack) &&
   21686:	2b14      	cmp	r3, #20
   21688:	f040 80dd 	bne.w	21846 <ull_conn_rx+0xfea>
		max_rx_octets = sys_le16_to_cpu(lr->max_rx_octets);
   2168c:	8cab      	ldrh	r3, [r5, #36]	; 0x24
		if (max_rx_octets >= PDU_DC_PAYLOAD_SIZE_MIN) {
   2168e:	2b1a      	cmp	r3, #26
   21690:	f240 809b 	bls.w	217ca <ull_conn_rx+0xf6e>
			eff_tx_octets = MIN(max_rx_octets,
   21694:	f8b4 10d6 	ldrh.w	r1, [r4, #214]	; 0xd6
   21698:	4299      	cmp	r1, r3
   2169a:	bf28      	it	cs
   2169c:	4619      	movcs	r1, r3
		if (max_tx_octets >= PDU_DC_PAYLOAD_SIZE_MIN) {
   2169e:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
			eff_rx_octets = MIN(max_tx_octets,
   216a0:	2b1b      	cmp	r3, #27
   216a2:	9b01      	ldr	r3, [sp, #4]
   216a4:	bf38      	it	cc
   216a6:	469c      	movcc	ip, r3
		max_rx_time = sys_le16_to_cpu(lr->max_rx_time);
   216a8:	8ceb      	ldrh	r3, [r5, #38]	; 0x26
			eff_rx_octets = MIN(max_tx_octets,
   216aa:	bf28      	it	cs
   216ac:	f04f 0c1b 	movcs.w	ip, #27
		if (max_rx_time >= PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0)) {
   216b0:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
   216b4:	f0c0 808b 	bcc.w	217ce <ull_conn_rx+0xf72>
			eff_tx_time = MIN(max_rx_time,
   216b8:	f8b4 20d8 	ldrh.w	r2, [r4, #216]	; 0xd8
   216bc:	4293      	cmp	r3, r2
   216be:	bf28      	it	cs
   216c0:	4613      	movcs	r3, r2
			eff_tx_time = MAX(eff_tx_time,
   216c2:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
   216c6:	f002 0207 	and.w	r2, r2, #7
   216ca:	0750      	lsls	r0, r2, #29
   216cc:	bf5d      	ittte	pl
   216ce:	1052      	asrpl	r2, r2, #1
   216d0:	f44f 7ea4 	movpl.w	lr, #328	; 0x148
   216d4:	fa2e f202 	lsrpl.w	r2, lr, r2
   216d8:	f44f 6229 	movmi.w	r2, #2704	; 0xa90
   216dc:	429a      	cmp	r2, r3
   216de:	bf38      	it	cc
   216e0:	461a      	movcc	r2, r3
   216e2:	b293      	uxth	r3, r2
		max_tx_time = sys_le16_to_cpu(lr->max_tx_time);
   216e4:	8d6a      	ldrh	r2, [r5, #42]	; 0x2a
		if (max_tx_time >= PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0)) {
   216e6:	f5b2 7fa4 	cmp.w	r2, #328	; 0x148
   216ea:	d372      	bcc.n	217d2 <ull_conn_rx+0xf76>
			eff_rx_time = MIN(max_tx_time,
   216ec:	f5b2 6f29 	cmp.w	r2, #2704	; 0xa90
   216f0:	bf28      	it	cs
   216f2:	f44f 6229 	movcs.w	r2, #2704	; 0xa90
   216f6:	9203      	str	r2, [sp, #12]
			eff_rx_time = MAX(eff_rx_time,
   216f8:	f894 2065 	ldrb.w	r2, [r4, #101]	; 0x65
   216fc:	f002 0207 	and.w	r2, r2, #7
   21700:	0750      	lsls	r0, r2, #29
   21702:	bf5e      	ittt	pl
   21704:	1052      	asrpl	r2, r2, #1
   21706:	f44f 7ea4 	movpl.w	lr, #328	; 0x148
   2170a:	fa2e f002 	lsrpl.w	r0, lr, r2
   2170e:	9a03      	ldr	r2, [sp, #12]
   21710:	bf48      	it	mi
   21712:	f44f 6029 	movmi.w	r0, #2704	; 0xa90
   21716:	4282      	cmp	r2, r0
   21718:	bf38      	it	cc
   2171a:	4602      	movcc	r2, r0
   2171c:	b292      	uxth	r2, r2
		if (eff_rx_octets != conn->lll.max_rx_octets) {
   2171e:	9801      	ldr	r0, [sp, #4]
   21720:	4560      	cmp	r0, ip
   21722:	d05e      	beq.n	217e2 <ull_conn_rx+0xf86>
			conn->llcp_length.ack = (conn->llcp_length.req -
   21724:	9802      	ldr	r0, [sp, #8]
			conn->llcp_length.rx_octets = eff_rx_octets;
   21726:	f8a4 c19c 	strh.w	ip, [r4, #412]	; 0x19c
			conn->llcp_length.ack = (conn->llcp_length.req -
   2172a:	3801      	subs	r0, #1
   2172c:	f884 0199 	strb.w	r0, [r4, #409]	; 0x199
			conn->llcp_length.tx_octets = eff_tx_octets;
   21730:	f8a4 119e 	strh.w	r1, [r4, #414]	; 0x19e
			conn->llcp_length.rx_time = eff_rx_time;
   21734:	f8a4 21a0 	strh.w	r2, [r4, #416]	; 0x1a0
			conn->llcp_length.tx_time = eff_tx_time;
   21738:	f8a4 31a2 	strh.w	r3, [r4, #418]	; 0x1a2
			if (tx) {
   2173c:	f894 019a 	ldrb.w	r0, [r4, #410]	; 0x19a
   21740:	2f00      	cmp	r7, #0
   21742:	d048      	beq.n	217d6 <ull_conn_rx+0xf7a>
				conn->llcp_length.state =
   21744:	2505      	movs	r5, #5
				conn->llcp_length.state =
   21746:	f365 0002 	bfi	r0, r5, #0, #3
   2174a:	f884 019a 	strb.w	r0, [r4, #410]	; 0x19a
			link->mem = conn->llcp_rx;
   2174e:	f8d4 0100 	ldr.w	r0, [r4, #256]	; 0x100
   21752:	f8c8 0004 	str.w	r0, [r8, #4]
			(*rx)->hdr.link = link;
   21756:	6830      	ldr	r0, [r6, #0]
   21758:	f8c0 8000 	str.w	r8, [r0]
			conn->llcp_rx = *rx;
   2175c:	6830      	ldr	r0, [r6, #0]
   2175e:	f8c4 0100 	str.w	r0, [r4, #256]	; 0x100
			*rx = NULL;
   21762:	2000      	movs	r0, #0
   21764:	6030      	str	r0, [r6, #0]
	if (tx) {
   21766:	2f00      	cmp	r7, #0
   21768:	f43f aa2d 	beq.w	20bc6 <ull_conn_rx+0x36a>
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   2176c:	7938      	ldrb	r0, [r7, #4]
	pdu_tx->llctrl.length_rsp.max_tx_octets =
   2176e:	81b9      	strh	r1, [r7, #12]
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
   21770:	f040 0003 	orr.w	r0, r0, #3
   21774:	7138      	strb	r0, [r7, #4]
	pdu_tx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
   21776:	2009      	movs	r0, #9
   21778:	7178      	strb	r0, [r7, #5]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
   2177a:	2015      	movs	r0, #21
   2177c:	71f8      	strb	r0, [r7, #7]
	pdu_tx->llctrl.length_rsp.max_rx_octets =
   2177e:	f8a7 c008 	strh.w	ip, [r7, #8]
	pdu_tx->llctrl.length_rsp.max_rx_time = sys_cpu_to_le16(eff_rx_time);
   21782:	817a      	strh	r2, [r7, #10]
	pdu_tx->llctrl.length_rsp.max_tx_time = sys_cpu_to_le16(eff_tx_time);
   21784:	81fb      	strh	r3, [r7, #14]
	ctrl_tx_enqueue(conn, tx);
   21786:	4639      	mov	r1, r7
   21788:	4620      	mov	r0, r4
   2178a:	f00a fdeb 	bl	2c364 <ctrl_tx_enqueue>
   2178e:	f7ff ba1a 	b.w	20bc6 <ull_conn_rx+0x36a>
	struct node_tx *tx = NULL;
   21792:	2700      	movs	r7, #0
   21794:	e763      	b.n	2165e <ull_conn_rx+0xe02>
	     ((((conn->llcp_length.state == LLCP_LENGTH_STATE_REQ) ||
   21796:	f894 219a 	ldrb.w	r2, [r4, #410]	; 0x19a
	    ((conn->llcp_length.req != conn->llcp_length.ack) &&
   2179a:	f012 0f06 	tst.w	r2, #6
   2179e:	d102      	bne.n	217a6 <ull_conn_rx+0xf4a>
		(conn->llcp_length.state == LLCP_LENGTH_STATE_REQ_ACK_WAIT)) &&
   217a0:	2b14      	cmp	r3, #20
   217a2:	f43f af73 	beq.w	2168c <ull_conn_rx+0xe30>
		PDU_DATA_LLCTRL_TYPE_LENGTH_REQ)) ||
   217a6:	f002 0207 	and.w	r2, r2, #7
   217aa:	2a02      	cmp	r2, #2
   217ac:	d14b      	bne.n	21846 <ull_conn_rx+0xfea>
	      ((conn->llcp_length.state == LLCP_LENGTH_STATE_RSP_WAIT) &&
   217ae:	3b14      	subs	r3, #20
   217b0:	2b01      	cmp	r3, #1
   217b2:	f67f af6b 	bls.w	2168c <ull_conn_rx+0xe30>
		LL_ASSERT(pdu_rx->llctrl.opcode ==
   217b6:	4839      	ldr	r0, [pc, #228]	; (2189c <ull_conn_rx+0x1040>)
   217b8:	f006 fcc4 	bl	28144 <printk>
   217bc:	4040      	eors	r0, r0
   217be:	f380 8811 	msr	BASEPRI, r0
   217c2:	f04f 0003 	mov.w	r0, #3
   217c6:	df02      	svc	2
   217c8:	e03f      	b.n	2184a <ull_conn_rx+0xfee>
	eff_tx_octets = conn->lll.max_tx_octets;
   217ca:	4649      	mov	r1, r9
   217cc:	e767      	b.n	2169e <ull_conn_rx+0xe42>
	eff_tx_time = conn->lll.max_tx_time;
   217ce:	465b      	mov	r3, fp
   217d0:	e788      	b.n	216e4 <ull_conn_rx+0xe88>
	eff_rx_time = conn->lll.max_rx_time;
   217d2:	4652      	mov	r2, sl
   217d4:	e7a3      	b.n	2171e <ull_conn_rx+0xec2>
				conn->lll.max_tx_octets = eff_tx_octets;
   217d6:	f8a4 105c 	strh.w	r1, [r4, #92]	; 0x5c
				conn->lll.max_tx_time = eff_tx_time;
   217da:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
				conn->llcp_length.state =
   217de:	2504      	movs	r5, #4
   217e0:	e7b1      	b.n	21746 <ull_conn_rx+0xeea>
			conn->llcp_length.ack = conn->llcp_length.req;
   217e2:	9802      	ldr	r0, [sp, #8]
   217e4:	f884 0199 	strb.w	r0, [r4, #409]	; 0x199
			conn->procedure_expire = 0U;
   217e8:	f04f 0e00 	mov.w	lr, #0
			if (eff_tx_octets == conn->lll.max_tx_octets &&
   217ec:	4589      	cmp	r9, r1
			conn->procedure_expire = 0U;
   217ee:	f8a4 e0cc 	strh.w	lr, [r4, #204]	; 0xcc
			if (eff_tx_octets == conn->lll.max_tx_octets &&
   217f2:	d107      	bne.n	21804 <ull_conn_rx+0xfa8>
   217f4:	459b      	cmp	fp, r3
   217f6:	d105      	bne.n	21804 <ull_conn_rx+0xfa8>
			    eff_rx_time == conn->lll.max_rx_time &&
   217f8:	4592      	cmp	sl, r2
   217fa:	d103      	bne.n	21804 <ull_conn_rx+0xfa8>
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   217fc:	6830      	ldr	r0, [r6, #0]
   217fe:	2503      	movs	r5, #3
   21800:	7105      	strb	r5, [r0, #4]
				goto send_length_resp;
   21802:	e7b0      	b.n	21766 <ull_conn_rx+0xf0a>
			conn->lll.max_rx_time = eff_rx_time;
   21804:	f8a4 2062 	strh.w	r2, [r4, #98]	; 0x62
			if (tx) {
   21808:	b1c7      	cbz	r7, 2183c <ull_conn_rx+0xfe0>
					(conn->llcp_length.req - 1);
   2180a:	9802      	ldr	r0, [sp, #8]
				conn->llcp_length.rx_octets = eff_rx_octets;
   2180c:	f8a4 c19c 	strh.w	ip, [r4, #412]	; 0x19c
					(conn->llcp_length.req - 1);
   21810:	3801      	subs	r0, #1
				conn->llcp_length.ack =
   21812:	f884 0199 	strb.w	r0, [r4, #409]	; 0x199
				conn->llcp_length.state =
   21816:	f894 019a 	ldrb.w	r0, [r4, #410]	; 0x19a
				conn->llcp_length.tx_octets = eff_tx_octets;
   2181a:	f8a4 119e 	strh.w	r1, [r4, #414]	; 0x19e
				conn->llcp_length.state =
   2181e:	2603      	movs	r6, #3
   21820:	f366 0002 	bfi	r0, r6, #0, #3
				conn->llcp_length.rx_time = eff_rx_time;
   21824:	f8a4 21a0 	strh.w	r2, [r4, #416]	; 0x1a0
				conn->llcp_length.tx_time = eff_tx_time;
   21828:	f8a4 31a2 	strh.w	r3, [r4, #418]	; 0x1a2
				conn->llcp_length.state =
   2182c:	f884 019a 	strb.w	r0, [r4, #410]	; 0x19a
			lr->max_rx_octets = sys_cpu_to_le16(eff_rx_octets);
   21830:	f8a5 c024 	strh.w	ip, [r5, #36]	; 0x24
			lr->max_tx_octets = sys_cpu_to_le16(eff_tx_octets);
   21834:	8529      	strh	r1, [r5, #40]	; 0x28
			lr->max_rx_time = sys_cpu_to_le16(eff_rx_time);
   21836:	84ea      	strh	r2, [r5, #38]	; 0x26
			lr->max_tx_time = sys_cpu_to_le16(eff_tx_time);
   21838:	856b      	strh	r3, [r5, #42]	; 0x2a
   2183a:	e794      	b.n	21766 <ull_conn_rx+0xf0a>
				conn->lll.max_tx_octets = eff_tx_octets;
   2183c:	f8a4 105c 	strh.w	r1, [r4, #92]	; 0x5c
				conn->lll.max_tx_time = eff_tx_time;
   21840:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
   21844:	e7f4      	b.n	21830 <ull_conn_rx+0xfd4>
		LL_ASSERT(pdu_rx->llctrl.opcode ==
   21846:	2b15      	cmp	r3, #21
   21848:	d1b5      	bne.n	217b6 <ull_conn_rx+0xf5a>
	eff_tx_time = conn->lll.max_tx_time;
   2184a:	465b      	mov	r3, fp
	eff_rx_time = conn->lll.max_rx_time;
   2184c:	4652      	mov	r2, sl
	eff_tx_octets = conn->lll.max_tx_octets;
   2184e:	4649      	mov	r1, r9
	eff_rx_octets = conn->lll.max_rx_octets;
   21850:	f8dd c004 	ldr.w	ip, [sp, #4]
   21854:	e787      	b.n	21766 <ull_conn_rx+0xf0a>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PHY_REQ, pdu_rx->len)) {
   21856:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   2185a:	2016      	movs	r0, #22
   2185c:	f7fe fc96 	bl	2018c <pdu_len_cmp>
   21860:	2800      	cmp	r0, #0
   21862:	f000 8211 	beq.w	21c88 <ull_conn_rx+0x142c>
		if (!conn->lll.role) {
   21866:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   2186a:	2b00      	cmp	r3, #0
   2186c:	db75      	blt.n	2195a <ull_conn_rx+0x10fe>
			if ((conn->llcp_phy.ack !=
   2186e:	f894 31a9 	ldrb.w	r3, [r4, #425]	; 0x1a9
			     conn->llcp_phy.req) &&
   21872:	f894 11a8 	ldrb.w	r1, [r4, #424]	; 0x1a8
			if ((conn->llcp_phy.ack !=
   21876:	428b      	cmp	r3, r1
   21878:	d012      	beq.n	218a0 <ull_conn_rx+0x1044>
			      LLCP_PHY_STATE_RSP_WAIT) ||
   2187a:	f894 21aa 	ldrb.w	r2, [r4, #426]	; 0x1aa
   2187e:	f002 0203 	and.w	r2, r2, #3
			     conn->llcp_phy.req) &&
   21882:	3a01      	subs	r2, #1
   21884:	2a02      	cmp	r2, #2
   21886:	d80b      	bhi.n	218a0 <ull_conn_rx+0x1044>
				nack = reject_ext_ind_send(conn, *rx,
   21888:	2323      	movs	r3, #35	; 0x23
				nack = reject_ext_ind_send(conn, *rx,
   2188a:	2216      	movs	r2, #22
   2188c:	f7ff bb34 	b.w	20ef8 <ull_conn_rx+0x69c>
   21890:	20003184 	.word	0x20003184
   21894:	00031e6a 	.word	0x00031e6a
   21898:	200034bc 	.word	0x200034bc
   2189c:	00031e92 	.word	0x00031e92
			} else if (((((conn->llcp_req - conn->llcp_ack) &
   218a0:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
   218a4:	f894 00e9 	ldrb.w	r0, [r4, #233]	; 0xe9
   218a8:	1a12      	subs	r2, r2, r0
   218aa:	f002 0203 	and.w	r2, r2, #3
   218ae:	2a02      	cmp	r2, #2
   218b0:	d103      	bne.n	218ba <ull_conn_rx+0x105e>
				      0x03) == 0x02) &&
   218b2:	f894 20ea 	ldrb.w	r2, [r4, #234]	; 0xea
   218b6:	2a03      	cmp	r2, #3
   218b8:	d105      	bne.n	218c6 <ull_conn_rx+0x106a>
				     LLCP_ENCRYPTION)) ||
   218ba:	f894 0170 	ldrb.w	r0, [r4, #368]	; 0x170
   218be:	f894 2171 	ldrb.w	r2, [r4, #369]	; 0x171
   218c2:	4290      	cmp	r0, r2
   218c4:	d001      	beq.n	218ca <ull_conn_rx+0x106e>
				nack = reject_ext_ind_send(conn, *rx,
   218c6:	232a      	movs	r3, #42	; 0x2a
   218c8:	e7df      	b.n	2188a <ull_conn_rx+0x102e>
				conn->llcp_phy.state =
   218ca:	f894 21aa 	ldrb.w	r2, [r4, #426]	; 0x1aa
				if (conn->llcp_phy.ack ==
   218ce:	428b      	cmp	r3, r1
				conn->llcp_phy.state =
   218d0:	f042 0203 	orr.w	r2, r2, #3
   218d4:	f884 21aa 	strb.w	r2, [r4, #426]	; 0x1aa
				if (conn->llcp_phy.ack ==
   218d8:	d116      	bne.n	21908 <ull_conn_rx+0x10ac>
					conn->llcp_phy.ack--;
   218da:	3b01      	subs	r3, #1
   218dc:	f884 31a9 	strb.w	r3, [r4, #425]	; 0x1a9
					conn->llcp_phy.cmd = 0U;
   218e0:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
						conn->phy_pref_tx;
   218e4:	f894 21ac 	ldrb.w	r2, [r4, #428]	; 0x1ac
					conn->llcp_phy.cmd = 0U;
   218e8:	f36f 0382 	bfc	r3, #2, #1
   218ec:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
					conn->llcp_phy.tx =
   218f0:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
						conn->phy_pref_tx;
   218f4:	f3c2 0102 	ubfx	r1, r2, #0, #3
					conn->llcp_phy.tx =
   218f8:	f361 0384 	bfi	r3, r1, #2, #3
						conn->phy_pref_rx;
   218fc:	f3c2 1202 	ubfx	r2, r2, #4, #3
					conn->llcp_phy.rx =
   21900:	f362 1347 	bfi	r3, r2, #5, #3
   21904:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
				conn->llcp_phy.tx &= p->rx_phys;
   21908:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
   2190c:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
   21910:	f3c3 0182 	ubfx	r1, r3, #2, #3
   21914:	400a      	ands	r2, r1
   21916:	f362 0384 	bfi	r3, r2, #2, #3
   2191a:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
				conn->llcp_phy.rx &= p->tx_phys;
   2191e:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
   21922:	b2db      	uxtb	r3, r3
   21924:	ea02 1253 	and.w	r2, r2, r3, lsr #5
   21928:	f362 1347 	bfi	r3, r2, #5, #3
   2192c:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
				if (!conn->llcp_phy.tx || !conn->llcp_phy.rx) {
   21930:	b2db      	uxtb	r3, r3
   21932:	f013 0f1c 	tst.w	r3, #28
   21936:	d002      	beq.n	2193e <ull_conn_rx+0x10e2>
   21938:	f013 0fe0 	tst.w	r3, #224	; 0xe0
   2193c:	d105      	bne.n	2194a <ull_conn_rx+0x10ee>
					conn->llcp_phy.tx = 0;
   2193e:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
   21942:	f003 0303 	and.w	r3, r3, #3
   21946:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
				conn->llcp_phy.pause_tx = 1U;
   2194a:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   2194e:	f043 0301 	orr.w	r3, r3, #1
   21952:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   21956:	f7ff b959 	b.w	20c0c <ull_conn_rx+0x3b0>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   2195a:	48da      	ldr	r0, [pc, #872]	; (21cc4 <ull_conn_rx+0x1468>)
   2195c:	f009 ffe8 	bl	2b930 <mem_acquire>
	if (!tx) {
   21960:	4601      	mov	r1, r0
   21962:	2800      	cmp	r0, #0
   21964:	f43f aa11 	beq.w	20d8a <ull_conn_rx+0x52e>
	conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
   21968:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
	if (conn->llcp_phy.ack ==
   2196c:	f894 c1a9 	ldrb.w	ip, [r4, #425]	; 0x1a9
	conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
   21970:	2202      	movs	r2, #2
   21972:	f362 0301 	bfi	r3, r2, #0, #2
   21976:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
	if (conn->llcp_phy.ack ==
   2197a:	f894 21ac 	ldrb.w	r2, [r4, #428]	; 0x1ac
   2197e:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
   21982:	f3c2 0002 	ubfx	r0, r2, #0, #3
   21986:	4563      	cmp	r3, ip
   21988:	f3c2 1202 	ubfx	r2, r2, #4, #3
   2198c:	b2c7      	uxtb	r7, r0
   2198e:	b2d6      	uxtb	r6, r2
   21990:	d114      	bne.n	219bc <ull_conn_rx+0x1160>
		conn->llcp_phy.ack--;
   21992:	3b01      	subs	r3, #1
   21994:	f884 31a9 	strb.w	r3, [r4, #425]	; 0x1a9
		conn->llcp_phy.cmd = 0U;
   21998:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   2199c:	f36f 0382 	bfc	r3, #2, #1
   219a0:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
		conn->llcp_phy.tx =
   219a4:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
   219a8:	f367 0384 	bfi	r3, r7, #2, #3
		conn->llcp_phy.rx =
   219ac:	f366 1347 	bfi	r3, r6, #5, #3
   219b0:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
		conn->procedure_expire =
   219b4:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
   219b8:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	conn->llcp_phy.tx &= p->rx_phys;
   219bc:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
   219c0:	f895 6025 	ldrb.w	r6, [r5, #37]	; 0x25
   219c4:	f3c3 0782 	ubfx	r7, r3, #2, #3
   219c8:	403e      	ands	r6, r7
   219ca:	f366 0384 	bfi	r3, r6, #2, #3
   219ce:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
	conn->llcp_phy.rx &= p->tx_phys;
   219d2:	f895 6024 	ldrb.w	r6, [r5, #36]	; 0x24
   219d6:	b2db      	uxtb	r3, r3
   219d8:	ea06 1653 	and.w	r6, r6, r3, lsr #5
   219dc:	f366 1347 	bfi	r3, r6, #5, #3
   219e0:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
	conn->llcp_phy.pause_tx = 1U;
   219e4:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   219e8:	f043 0301 	orr.w	r3, r3, #1
   219ec:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   219f0:	790b      	ldrb	r3, [r1, #4]
	pdu_ctrl_tx->llctrl.phy_rsp.tx_phys = conn->phy_pref_tx;
   219f2:	7208      	strb	r0, [r1, #8]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   219f4:	f043 0303 	orr.w	r3, r3, #3
   219f8:	710b      	strb	r3, [r1, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, phy_rsp) +
   219fa:	2603      	movs	r6, #3
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_RSP;
   219fc:	2317      	movs	r3, #23
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, phy_rsp) +
   219fe:	714e      	strb	r6, [r1, #5]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_RSP;
   21a00:	71cb      	strb	r3, [r1, #7]
	pdu_ctrl_tx->llctrl.phy_rsp.rx_phys = conn->phy_pref_rx;
   21a02:	724a      	strb	r2, [r1, #9]
	ctrl_tx_enqueue(conn, tx);
   21a04:	4620      	mov	r0, r4
   21a06:	f00a fcad 	bl	2c364 <ctrl_tx_enqueue>
   21a0a:	f7ff b922 	b.w	20c52 <ull_conn_rx+0x3f6>
		if (conn->lll.role ||
   21a0e:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   21a12:	2b00      	cmp	r3, #0
   21a14:	f2c0 8138 	blt.w	21c88 <ull_conn_rx+0x142c>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PHY_RSP, pdu_rx->len)) {
   21a18:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   21a1c:	2017      	movs	r0, #23
   21a1e:	f7fe fbb5 	bl	2018c <pdu_len_cmp>
		if (conn->lll.role ||
   21a22:	2800      	cmp	r0, #0
   21a24:	f000 8130 	beq.w	21c88 <ull_conn_rx+0x142c>
		if (!conn->lll.role &&
   21a28:	f894 21a9 	ldrb.w	r2, [r4, #425]	; 0x1a9
   21a2c:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
   21a30:	429a      	cmp	r2, r3
   21a32:	f43e af1f 	beq.w	20874 <ull_conn_rx+0x18>
		    (conn->llcp_phy.state == LLCP_PHY_STATE_RSP_WAIT)) {
   21a36:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
		    (conn->llcp_phy.ack != conn->llcp_phy.req) &&
   21a3a:	f003 0203 	and.w	r2, r3, #3
   21a3e:	2a02      	cmp	r2, #2
   21a40:	f47e af18 	bne.w	20874 <ull_conn_rx+0x18>
			conn->llcp_phy.state = LLCP_PHY_STATE_UPD;
   21a44:	f043 0303 	orr.w	r3, r3, #3
   21a48:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
			conn->llcp_phy.tx &= p->rx_phys;
   21a4c:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
   21a50:	f3c3 0182 	ubfx	r1, r3, #2, #3
   21a54:	400a      	ands	r2, r1
   21a56:	f362 0384 	bfi	r3, r2, #2, #3
   21a5a:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
			conn->llcp_phy.rx &= p->tx_phys;
   21a5e:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
   21a62:	b2db      	uxtb	r3, r3
   21a64:	ea02 1253 	and.w	r2, r2, r3, lsr #5
   21a68:	f362 1347 	bfi	r3, r2, #5, #3
   21a6c:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
			if (!conn->llcp_phy.tx || !conn->llcp_phy.rx) {
   21a70:	b2db      	uxtb	r3, r3
   21a72:	f013 0f1c 	tst.w	r3, #28
   21a76:	d002      	beq.n	21a7e <ull_conn_rx+0x1222>
   21a78:	f013 0fe0 	tst.w	r3, #224	; 0xe0
   21a7c:	d105      	bne.n	21a8a <ull_conn_rx+0x122e>
				conn->llcp_phy.tx = 0;
   21a7e:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
   21a82:	f003 0303 	and.w	r3, r3, #3
   21a86:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
			conn->llcp_phy.pause_tx = 1U;
   21a8a:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   21a8e:	f043 0301 	orr.w	r3, r3, #1
   21a92:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
			conn->procedure_expire = 0U;
   21a96:	2300      	movs	r3, #0
   21a98:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   21a9c:	f7fe beea 	b.w	20874 <ull_conn_rx+0x18>
		if (!conn->lll.role ||
   21aa0:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   21aa4:	2b00      	cmp	r3, #0
   21aa6:	f280 80ef 	bge.w	21c88 <ull_conn_rx+0x142c>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PHY_UPD_IND,
   21aaa:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   21aae:	2018      	movs	r0, #24
   21ab0:	f7fe fb6c 	bl	2018c <pdu_len_cmp>
		if (!conn->lll.role ||
   21ab4:	2800      	cmp	r0, #0
   21ab6:	f000 80e7 	beq.w	21c88 <ull_conn_rx+0x142c>
	if (!((ind->m_to_s_phy | ind->s_to_m_phy) & 0x07)) {
   21aba:	f895 1024 	ldrb.w	r1, [r5, #36]	; 0x24
   21abe:	f895 7025 	ldrb.w	r7, [r5, #37]	; 0x25
   21ac2:	ea41 0007 	orr.w	r0, r1, r7
   21ac6:	f010 0007 	ands.w	r0, r0, #7
   21aca:	d135      	bne.n	21b38 <ull_conn_rx+0x12dc>
		if ((conn->llcp_phy.ack == conn->llcp_phy.req) ||
   21acc:	f894 21a8 	ldrb.w	r2, [r4, #424]	; 0x1a8
   21ad0:	f894 31a9 	ldrb.w	r3, [r4, #425]	; 0x1a9
   21ad4:	4293      	cmp	r3, r2
   21ad6:	f43e aecd 	beq.w	20874 <ull_conn_rx+0x18>
		    (conn->llcp_phy.state != LLCP_PHY_STATE_RSP_WAIT)) {
   21ada:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
		if ((conn->llcp_phy.ack == conn->llcp_phy.req) ||
   21ade:	f003 0303 	and.w	r3, r3, #3
   21ae2:	2b02      	cmp	r3, #2
   21ae4:	f47e aec6 	bne.w	20874 <ull_conn_rx+0x18>
		conn->llcp_phy.ack = conn->llcp_phy.req;
   21ae8:	f884 21a9 	strb.w	r2, [r4, #425]	; 0x1a9
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   21aec:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
		conn->llcp_phy.pause_tx = 0U;
   21af0:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
		conn->procedure_expire = 0U;
   21af4:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   21af8:	f3c2 0102 	ubfx	r1, r2, #0, #3
		conn->llcp_phy.pause_tx = 0U;
   21afc:	f360 0300 	bfi	r3, r0, #0, #1
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   21b00:	f361 1206 	bfi	r2, r1, #4, #3
		conn->llcp_phy.pause_tx = 0U;
   21b04:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
		conn->lll.phy_tx_time = conn->lll.phy_tx;
   21b08:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
		if (!conn->llcp_phy.cmd) {
   21b0c:	f013 0304 	ands.w	r3, r3, #4
   21b10:	6832      	ldr	r2, [r6, #0]
   21b12:	d103      	bne.n	21b1c <ull_conn_rx+0x12c0>
			(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   21b14:	2103      	movs	r1, #3
   21b16:	7111      	strb	r1, [r2, #4]
		if (err) {
   21b18:	f7ff b855 	b.w	20bc6 <ull_conn_rx+0x36a>
		(*rx)->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
   21b1c:	230e      	movs	r3, #14
   21b1e:	7113      	strb	r3, [r2, #4]
		p->status = 0U;
   21b20:	f885 0020 	strb.w	r0, [r5, #32]
		p->tx = conn->lll.phy_tx;
   21b24:	f885 1021 	strb.w	r1, [r5, #33]	; 0x21
		p->rx = conn->lll.phy_rx;
   21b28:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
   21b2c:	f3c3 0302 	ubfx	r3, r3, #0, #3
   21b30:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
		if (err) {
   21b34:	f7ff b92b 	b.w	20d8e <ull_conn_rx+0x532>
	instant = sys_le16_to_cpu(ind->instant);
   21b38:	8cea      	ldrh	r2, [r5, #38]	; 0x26
	if (((instant - conn->lll.event_counter) & 0xffff) > 0x7fff) {
   21b3a:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
   21b3c:	1ad3      	subs	r3, r2, r3
   21b3e:	041b      	lsls	r3, r3, #16
   21b40:	f53e af61 	bmi.w	20a06 <ull_conn_rx+0x1aa>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
   21b44:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   21b48:	f894 00e9 	ldrb.w	r0, [r4, #233]	; 0xe9
   21b4c:	1a1b      	subs	r3, r3, r0
   21b4e:	f003 0303 	and.w	r3, r3, #3
   21b52:	2b02      	cmp	r3, #2
   21b54:	f43e af66 	beq.w	20a24 <ull_conn_rx+0x1c8>
	if ((conn->llcp_phy.ack != conn->llcp_phy.req) &&
   21b58:	f894 01a8 	ldrb.w	r0, [r4, #424]	; 0x1a8
   21b5c:	f894 31a9 	ldrb.w	r3, [r4, #425]	; 0x1a9
   21b60:	4283      	cmp	r3, r0
   21b62:	d018      	beq.n	21b96 <ull_conn_rx+0x133a>
	    (conn->llcp_phy.state == LLCP_PHY_STATE_RSP_WAIT)) {
   21b64:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
	if ((conn->llcp_phy.ack != conn->llcp_phy.req) &&
   21b68:	f003 0303 	and.w	r3, r3, #3
   21b6c:	2b02      	cmp	r3, #2
   21b6e:	d112      	bne.n	21b96 <ull_conn_rx+0x133a>
		conn->llcp_phy.pause_tx = 0U;
   21b70:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
		conn->llcp_phy.ack = conn->llcp_phy.req;
   21b74:	f884 01a9 	strb.w	r0, [r4, #425]	; 0x1a9
		conn->procedure_expire = 0U;
   21b78:	2000      	movs	r0, #0
		conn->llcp_phy.pause_tx = 0U;
   21b7a:	f36f 0300 	bfc	r3, #0, #1
		conn->procedure_expire = 0U;
   21b7e:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
   21b82:	f894 00ec 	ldrb.w	r0, [r4, #236]	; 0xec
		conn->llcp_phy.pause_tx = 0U;
   21b86:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
   21b8a:	f3c3 0380 	ubfx	r3, r3, #2, #1
   21b8e:	f363 0041 	bfi	r0, r3, #1, #1
   21b92:	f884 00ec 	strb.w	r0, [r4, #236]	; 0xec
	conn->llcp.phy_upd_ind.tx = ind->s_to_m_phy;
   21b96:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
	conn->llcp.phy_upd_ind.instant = instant;
   21b9a:	f8a4 20ee 	strh.w	r2, [r4, #238]	; 0xee
	conn->llcp.phy_upd_ind.tx = ind->s_to_m_phy;
   21b9e:	f367 0384 	bfi	r3, r7, #2, #3
	conn->llcp.phy_upd_ind.rx = ind->m_to_s_phy;
   21ba2:	f361 1347 	bfi	r3, r1, #5, #3
	conn->llcp.phy_upd_ind.initiate = 0U;
   21ba6:	f36f 0300 	bfc	r3, #0, #1
   21baa:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
	link->mem = conn->llcp_rx;
   21bae:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
   21bb2:	f8c8 3004 	str.w	r3, [r8, #4]
	(*rx)->hdr.link = link;
   21bb6:	6833      	ldr	r3, [r6, #0]
   21bb8:	f8c3 8000 	str.w	r8, [r3]
	conn->llcp_rx = *rx;
   21bbc:	6833      	ldr	r3, [r6, #0]
   21bbe:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
	*rx = NULL;
   21bc2:	2300      	movs	r3, #0
   21bc4:	6033      	str	r3, [r6, #0]
	struct node_rx_pdu *rx_dle = ll_pdu_rx_alloc();
   21bc6:	f7fc fbed 	bl	1e3a4 <ll_pdu_rx_alloc>
	LL_ASSERT(rx_dle);
   21bca:	4605      	mov	r5, r0
   21bcc:	b940      	cbnz	r0, 21be0 <ull_conn_rx+0x1384>
   21bce:	483e      	ldr	r0, [pc, #248]	; (21cc8 <ull_conn_rx+0x146c>)
   21bd0:	f006 fab8 	bl	28144 <printk>
   21bd4:	4040      	eors	r0, r0
   21bd6:	f380 8811 	msr	BASEPRI, r0
   21bda:	f04f 0003 	mov.w	r0, #3
   21bde:	df02      	svc	2
	rx_dle->hdr.link->mem = conn->llcp_rx;
   21be0:	682b      	ldr	r3, [r5, #0]
   21be2:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
   21be6:	605a      	str	r2, [r3, #4]
	conn->llcp_type = LLCP_PHY_UPD;
   21be8:	2306      	movs	r3, #6
   21bea:	f884 30ea 	strb.w	r3, [r4, #234]	; 0xea
	conn->llcp_ack -= 2U;
   21bee:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
	conn->llcp_rx = rx_dle;
   21bf2:	f8c4 5100 	str.w	r5, [r4, #256]	; 0x100
	conn->llcp_ack -= 2U;
   21bf6:	3b02      	subs	r3, #2
   21bf8:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
	if (conn->llcp.phy_upd_ind.tx) {
   21bfc:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
   21c00:	f013 0f1c 	tst.w	r3, #28
   21c04:	f43e afdf 	beq.w	20bc6 <ull_conn_rx+0x36a>
		conn->lll.phy_tx_time = conn->llcp.phy_upd_ind.tx;
   21c08:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
   21c0c:	f3c3 0382 	ubfx	r3, r3, #2, #3
   21c10:	f363 1206 	bfi	r2, r3, #4, #3
   21c14:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
		if (err) {
   21c18:	f7fe bfd5 	b.w	20bc6 <ull_conn_rx+0x36a>
	break;
#endif /* CONFIG_BT_CTLR_PHY */

#if defined(CONFIG_BT_CTLR_MIN_USED_CHAN)
	case PDU_DATA_LLCTRL_TYPE_MIN_USED_CHAN_IND:
		if (conn->lll.role ||
   21c1c:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   21c20:	2b00      	cmp	r3, #0
   21c22:	db31      	blt.n	21c88 <ull_conn_rx+0x142c>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_MIN_USED_CHAN_IND,
   21c24:	f895 1021 	ldrb.w	r1, [r5, #33]	; 0x21
   21c28:	2019      	movs	r0, #25
   21c2a:	f7fe faaf 	bl	2018c <pdu_len_cmp>
		if (conn->lll.role ||
   21c2e:	b358      	cbz	r0, 21c88 <ull_conn_rx+0x142c>
		if (!conn->lll.role) {
			struct pdu_data_llctrl_min_used_chans_ind *p =
				&pdu_rx->llctrl.min_used_chans_ind;

#if defined(CONFIG_BT_CTLR_PHY)
			if (!(p->phys & (conn->lll.phy_tx |
   21c30:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
					 conn->lll.phy_rx))) {
   21c34:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
			if (!(p->phys & (conn->lll.phy_tx |
   21c38:	4313      	orrs	r3, r2
   21c3a:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
   21c3e:	f003 0307 	and.w	r3, r3, #7
   21c42:	4213      	tst	r3, r2
   21c44:	f43e afbf 	beq.w	20bc6 <ull_conn_rx+0x36a>
			if (!(p->phys & 0x01)) {
#endif /* !CONFIG_BT_CTLR_PHY */
				break;
			}

			if (((conn->llcp_req - conn->llcp_ack) & 0x03) ==
   21c48:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   21c4c:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
   21c50:	1a9b      	subs	r3, r3, r2
   21c52:	f003 0303 	and.w	r3, r3, #3
   21c56:	2b02      	cmp	r3, #2
   21c58:	f43e afb5 	beq.w	20bc6 <ull_conn_rx+0x36a>
			    0x02) {
				break;
			}

			memcpy(&conn->llcp.chan_map.chm[0], data_chan_map,
   21c5c:	2205      	movs	r2, #5
   21c5e:	491b      	ldr	r1, [pc, #108]	; (21ccc <ull_conn_rx+0x1470>)
   21c60:	f104 00ed 	add.w	r0, r4, #237	; 0xed
   21c64:	f008 fbf3 	bl	2a44e <memcpy>
			       sizeof(conn->llcp.chan_map.chm));
			/* conn->llcp.chan_map.instant     = 0; */
			conn->llcp.chan_map.initiate = 1U;
   21c68:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
   21c6c:	f043 0301 	orr.w	r3, r3, #1
   21c70:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec

			conn->llcp_type = LLCP_CHAN_MAP;
   21c74:	2302      	movs	r3, #2
   21c76:	f884 30ea 	strb.w	r3, [r4, #234]	; 0xea
			conn->llcp_ack -= 2U;
   21c7a:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
   21c7e:	3b02      	subs	r3, #2
   21c80:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
		}

		/* Mark for buffer for release */
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
   21c84:	f7fe bfc2 	b.w	20c0c <ull_conn_rx+0x3b0>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
   21c88:	480e      	ldr	r0, [pc, #56]	; (21cc4 <ull_conn_rx+0x1468>)
   21c8a:	f009 fe51 	bl	2b930 <mem_acquire>
	if (!tx) {
   21c8e:	4601      	mov	r1, r0
   21c90:	2800      	cmp	r0, #0
   21c92:	f43f a87a 	beq.w	20d8a <ull_conn_rx+0x52e>
	pdu->ll_id = PDU_DATA_LLID_CTRL;
   21c96:	7903      	ldrb	r3, [r0, #4]
	pdu->llctrl.unknown_rsp.type = type;
   21c98:	f880 9008 	strb.w	r9, [r0, #8]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
   21c9c:	f043 0303 	orr.w	r3, r3, #3
   21ca0:	7103      	strb	r3, [r0, #4]
	pdu->len = offsetof(struct pdu_data_llctrl, unknown_rsp) +
   21ca2:	2302      	movs	r3, #2
   21ca4:	7143      	strb	r3, [r0, #5]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP;
   21ca6:	2307      	movs	r3, #7
   21ca8:	71c3      	strb	r3, [r0, #7]
	pdu->llctrl.unknown_rsp.type = type;
   21caa:	f7ff b889 	b.w	20dc0 <ull_conn_rx+0x564>
		if (conn->llcp_enc.pause_rx) {
   21cae:	2a00      	cmp	r2, #0
   21cb0:	f43e af89 	beq.w	20bc6 <ull_conn_rx+0x36a>
   21cb4:	f7fe be34 	b.w	20920 <ull_conn_rx+0xc4>
		if (conn->llcp_enc.pause_rx) {
   21cb8:	2a00      	cmp	r2, #0
   21cba:	f43e afa7 	beq.w	20c0c <ull_conn_rx+0x3b0>
   21cbe:	f7fe be2f 	b.w	20920 <ull_conn_rx+0xc4>
   21cc2:	bf00      	nop
   21cc4:	200034bc 	.word	0x200034bc
   21cc8:	00031edd 	.word	0x00031edd
   21ccc:	2000fec6 	.word	0x2000fec6
	else if (rej_ext_ind->error_code != BT_HCI_ERR_LL_PROC_COLLISION) {
   21cd0:	2b23      	cmp	r3, #35	; 0x23
   21cd2:	d003      	beq.n	21cdc <ull_conn_rx+0x1480>
			conn->slave.ticks_to_offset =
   21cd4:	f8d4 3194 	ldr.w	r3, [r4, #404]	; 0x194
   21cd8:	f8c4 30e4 	str.w	r3, [r4, #228]	; 0xe4
	if (conn->llcp_conn_param.state == LLCP_CPR_STATE_RSP_WAIT) {
   21cdc:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   21ce0:	f003 0307 	and.w	r3, r3, #7
   21ce4:	2b04      	cmp	r3, #4
   21ce6:	d114      	bne.n	21d12 <ull_conn_rx+0x14b6>
		LL_ASSERT(conn_upd_curr == conn);
   21ce8:	4e17      	ldr	r6, [pc, #92]	; (21d48 <ull_conn_rx+0x14ec>)
   21cea:	6832      	ldr	r2, [r6, #0]
   21cec:	4294      	cmp	r4, r2
   21cee:	d008      	beq.n	21d02 <ull_conn_rx+0x14a6>
   21cf0:	4816      	ldr	r0, [pc, #88]	; (21d4c <ull_conn_rx+0x14f0>)
   21cf2:	f006 fa27 	bl	28144 <printk>
   21cf6:	4040      	eors	r0, r0
   21cf8:	f380 8811 	msr	BASEPRI, r0
   21cfc:	f04f 0003 	mov.w	r0, #3
   21d00:	df02      	svc	2
		conn_upd_curr = NULL;
   21d02:	2300      	movs	r3, #0
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   21d04:	f894 2170 	ldrb.w	r2, [r4, #368]	; 0x170
		conn_upd_curr = NULL;
   21d08:	6033      	str	r3, [r6, #0]
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
   21d0a:	f884 2171 	strb.w	r2, [r4, #369]	; 0x171
		conn->procedure_expire = 0U;
   21d0e:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	if (!conn->llcp_conn_param.cmd) {
   21d12:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
   21d16:	071e      	lsls	r6, r3, #28
   21d18:	f57e adac 	bpl.w	20874 <ull_conn_rx+0x18>
	rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
   21d1c:	230a      	movs	r3, #10
   21d1e:	712b      	strb	r3, [r5, #4]
	cu->status = rej_ext_ind->error_code;
   21d20:	f895 3025 	ldrb.w	r3, [r5, #37]	; 0x25
   21d24:	f885 3020 	strb.w	r3, [r5, #32]
	cu->latency = lll->latency;
   21d28:	8e22      	ldrh	r2, [r4, #48]	; 0x30
	cu->interval = lll->interval;
   21d2a:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
	cu->latency = lll->latency;
   21d2c:	84aa      	strh	r2, [r5, #36]	; 0x24
	cu->timeout = conn->supervision_reload *
   21d2e:	f8b4 20c6 	ldrh.w	r2, [r4, #198]	; 0xc6
	cu->interval = lll->interval;
   21d32:	846b      	strh	r3, [r5, #34]	; 0x22
	cu->timeout = conn->supervision_reload *
   21d34:	435a      	muls	r2, r3
		      lll->interval * 125U / 1000;
   21d36:	237d      	movs	r3, #125	; 0x7d
   21d38:	4353      	muls	r3, r2
   21d3a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   21d3e:	fbb3 f3f2 	udiv	r3, r3, r2
	cu->timeout = conn->supervision_reload *
   21d42:	84eb      	strh	r3, [r5, #38]	; 0x26
	if (err) {
   21d44:	f7fe bf3f 	b.w	20bc6 <ull_conn_rx+0x36a>
   21d48:	20003184 	.word	0x20003184
   21d4c:	00031e6a 	.word	0x00031e6a

00021d50 <ull_conn_tx_demux>:
{
   21d50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		lll_tx = MFIFO_DEQUEUE_GET(conn_tx);
   21d54:	4e20      	ldr	r6, [pc, #128]	; (21dd8 <ull_conn_tx_demux+0x88>)
{
   21d56:	4604      	mov	r4, r0
   21d58:	4637      	mov	r7, r6
	return (void *)(fifo + first * size);
   21d5a:	1d35      	adds	r5, r6, #4
		lll_tx = MFIFO_DEQUEUE_GET(conn_tx);
   21d5c:	78b3      	ldrb	r3, [r6, #2]
	if (first == last) {
   21d5e:	78f1      	ldrb	r1, [r6, #3]
   21d60:	7832      	ldrb	r2, [r6, #0]
   21d62:	4299      	cmp	r1, r3
   21d64:	d02d      	beq.n	21dc2 <ull_conn_tx_demux+0x72>
	return (void *)(fifo + first * size);
   21d66:	fb13 f302 	smulbb	r3, r3, r2
		if (!lll_tx) {
   21d6a:	eb15 0803 	adds.w	r8, r5, r3
   21d6e:	d028      	beq.n	21dc2 <ull_conn_tx_demux+0x72>
		conn = ll_connected_get(lll_tx->handle);
   21d70:	5ae8      	ldrh	r0, [r5, r3]
   21d72:	f00a fb0a 	bl	2c38a <ll_connected_get>
		if (conn) {
   21d76:	f8d8 1004 	ldr.w	r1, [r8, #4]
   21d7a:	b320      	cbz	r0, 21dc6 <ull_conn_tx_demux+0x76>
			tx->next = NULL;
   21d7c:	2300      	movs	r3, #0
   21d7e:	600b      	str	r3, [r1, #0]
			if (!conn->tx_data) {
   21d80:	f8d0 31bc 	ldr.w	r3, [r0, #444]	; 0x1bc
   21d84:	b943      	cbnz	r3, 21d98 <ull_conn_tx_demux+0x48>
				if (!conn->tx_head) {
   21d86:	f8d0 31b0 	ldr.w	r3, [r0, #432]	; 0x1b0
				conn->tx_data = tx;
   21d8a:	f8c0 11bc 	str.w	r1, [r0, #444]	; 0x1bc
				if (!conn->tx_head) {
   21d8e:	b91b      	cbnz	r3, 21d98 <ull_conn_tx_demux+0x48>
					conn->tx_head = tx;
   21d90:	f8c0 11b0 	str.w	r1, [r0, #432]	; 0x1b0
					conn->tx_data_last = NULL;
   21d94:	f8c0 31c0 	str.w	r3, [r0, #448]	; 0x1c0
			if (conn->tx_data_last) {
   21d98:	f8d0 31c0 	ldr.w	r3, [r0, #448]	; 0x1c0
   21d9c:	b103      	cbz	r3, 21da0 <ull_conn_tx_demux+0x50>
				conn->tx_data_last->next = tx;
   21d9e:	6019      	str	r1, [r3, #0]
			conn->tx_data_last = tx;
   21da0:	f8c0 11c0 	str.w	r1, [r0, #448]	; 0x1c0
	u8_t _first = *first; /* Copy read-index */
   21da4:	78bb      	ldrb	r3, [r7, #2]
	if (_first == last) {
   21da6:	78f9      	ldrb	r1, [r7, #3]
		MFIFO_DEQUEUE(conn_tx);
   21da8:	787a      	ldrb	r2, [r7, #1]
   21daa:	4299      	cmp	r1, r3
   21dac:	d005      	beq.n	21dba <ull_conn_tx_demux+0x6a>
	_first += 1U;
   21dae:	3301      	adds	r3, #1
   21db0:	b2db      	uxtb	r3, r3
		_first = 0U;
   21db2:	429a      	cmp	r2, r3
   21db4:	bf08      	it	eq
   21db6:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
   21db8:	70bb      	strb	r3, [r7, #2]
	} while (--count);
   21dba:	3c01      	subs	r4, #1
   21dbc:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
   21dc0:	d1cc      	bne.n	21d5c <ull_conn_tx_demux+0xc>
}
   21dc2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			p->ll_id = PDU_DATA_LLID_RESV;
   21dc6:	790b      	ldrb	r3, [r1, #4]
   21dc8:	f360 0301 	bfi	r3, r0, #0, #2
   21dcc:	710b      	strb	r3, [r1, #4]
			ll_tx_ack_put(0xFFFF, tx);
   21dce:	f64f 70ff 	movw	r0, #65535	; 0xffff
   21dd2:	f7fc fafd 	bl	1e3d0 <ll_tx_ack_put>
   21dd6:	e7e5      	b.n	21da4 <ull_conn_tx_demux+0x54>
   21dd8:	2000fd1c 	.word	0x2000fd1c

00021ddc <conn_cleanup>:
	rx->hdr.handle = conn->lll.handle;
   21ddc:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
{
   21dde:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	rx->hdr.handle = conn->lll.handle;
   21de2:	f8a0 3132 	strh.w	r3, [r0, #306]	; 0x132
	*((u8_t *)rx->pdu) = reason;
   21de6:	f880 114c 	strb.w	r1, [r0, #332]	; 0x14c
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
   21dea:	2309      	movs	r3, #9
	rx = conn->llcp_rx;
   21dec:	f8d0 1100 	ldr.w	r1, [r0, #256]	; 0x100
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
   21df0:	f880 3130 	strb.w	r3, [r0, #304]	; 0x130
{
   21df4:	4604      	mov	r4, r0
	struct lll_conn *lll = &conn->lll;
   21df6:	f100 061c 	add.w	r6, r0, #28
		hdr->type = NODE_RX_TYPE_DC_PDU_RELEASE;
   21dfa:	2503      	movs	r5, #3
	while (rx) {
   21dfc:	bb29      	cbnz	r1, 21e4a <conn_cleanup+0x6e>
		link = mem_acquire(&mem_link_tx.free);
   21dfe:	4f23      	ldr	r7, [pc, #140]	; (21e8c <conn_cleanup+0xb0>)
		LL_ASSERT(link);
   21e00:	f8df 8094 	ldr.w	r8, [pc, #148]	; 21e98 <conn_cleanup+0xbc>
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
   21e04:	f104 096c 	add.w	r9, r4, #108	; 0x6c
	while (conn->tx_head) {
   21e08:	f8d4 01b0 	ldr.w	r0, [r4, #432]	; 0x1b0
   21e0c:	bb20      	cbnz	r0, 21e58 <conn_cleanup+0x7c>
				    TICKER_ID_CONN_BASE + lll->handle,
   21e0e:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   21e12:	4b1f      	ldr	r3, [pc, #124]	; (21e90 <conn_cleanup+0xb4>)
   21e14:	9600      	str	r6, [sp, #0]
				    TICKER_ID_CONN_BASE + lll->handle,
   21e16:	3205      	adds	r2, #5
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
   21e18:	b2d2      	uxtb	r2, r2
   21e1a:	2101      	movs	r1, #1
   21e1c:	f7fa f9de 	bl	1c1dc <ticker_stop>
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   21e20:	f030 0302 	bics.w	r3, r0, #2
   21e24:	d008      	beq.n	21e38 <conn_cleanup+0x5c>
   21e26:	481b      	ldr	r0, [pc, #108]	; (21e94 <conn_cleanup+0xb8>)
   21e28:	f006 f98c 	bl	28144 <printk>
   21e2c:	4040      	eors	r0, r0
   21e2e:	f380 8811 	msr	BASEPRI, r0
   21e32:	f04f 0003 	mov.w	r0, #3
   21e36:	df02      	svc	2
	lll->handle = 0xFFFF;
   21e38:	f64f 73ff 	movw	r3, #65535	; 0xffff
	ull_conn_tx_demux(UINT8_MAX);
   21e3c:	20ff      	movs	r0, #255	; 0xff
	lll->handle = 0xFFFF;
   21e3e:	85a3      	strh	r3, [r4, #44]	; 0x2c
}
   21e40:	b002      	add	sp, #8
   21e42:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	ull_conn_tx_demux(UINT8_MAX);
   21e46:	f7ff bf83 	b.w	21d50 <ull_conn_tx_demux>
		rx = hdr->link->mem;
   21e4a:	6808      	ldr	r0, [r1, #0]
   21e4c:	6847      	ldr	r7, [r0, #4]
		hdr->type = NODE_RX_TYPE_DC_PDU_RELEASE;
   21e4e:	710d      	strb	r5, [r1, #4]
		ll_rx_put(hdr->link, hdr);
   21e50:	f7fc fa80 	bl	1e354 <ll_rx_put>
		rx = hdr->link->mem;
   21e54:	4639      	mov	r1, r7
   21e56:	e7d1      	b.n	21dfc <conn_cleanup+0x20>
		tx = tx_ull_dequeue(conn, conn->tx_head);
   21e58:	4601      	mov	r1, r0
   21e5a:	4620      	mov	r0, r4
   21e5c:	f00a f9ff 	bl	2c25e <tx_ull_dequeue>
   21e60:	4682      	mov	sl, r0
		link = mem_acquire(&mem_link_tx.free);
   21e62:	4638      	mov	r0, r7
   21e64:	f009 fd64 	bl	2b930 <mem_acquire>
		LL_ASSERT(link);
   21e68:	4605      	mov	r5, r0
   21e6a:	b940      	cbnz	r0, 21e7e <conn_cleanup+0xa2>
   21e6c:	4640      	mov	r0, r8
   21e6e:	f006 f969 	bl	28144 <printk>
   21e72:	4040      	eors	r0, r0
   21e74:	f380 8811 	msr	BASEPRI, r0
   21e78:	f04f 0003 	mov.w	r0, #3
   21e7c:	df02      	svc	2
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
   21e7e:	464a      	mov	r2, r9
   21e80:	4651      	mov	r1, sl
   21e82:	4628      	mov	r0, r5
   21e84:	f009 fdb2 	bl	2b9ec <memq_enqueue>
   21e88:	e7be      	b.n	21e08 <conn_cleanup+0x2c>
   21e8a:	bf00      	nop
   21e8c:	20003540 	.word	0x20003540
   21e90:	0002026d 	.word	0x0002026d
   21e94:	00031c28 	.word	0x00031c28
   21e98:	00031657 	.word	0x00031657

00021e9c <ull_conn_done>:
{
   21e9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct lll_conn *lll = (void *)HDR_ULL2LLL(done->param);
   21ea0:	6a05      	ldr	r5, [r0, #32]
	if (lll->handle == 0xFFFF) {
   21ea2:	8baa      	ldrh	r2, [r5, #28]
   21ea4:	f64f 73ff 	movw	r3, #65535	; 0xffff
   21ea8:	429a      	cmp	r2, r3
{
   21eaa:	b08a      	sub	sp, #40	; 0x28
   21eac:	4607      	mov	r7, r0
	if (lll->handle == 0xFFFF) {
   21eae:	d016      	beq.n	21ede <ull_conn_done+0x42>
	switch (done->extra.mic_state) {
   21eb0:	f890 302b 	ldrb.w	r3, [r0, #43]	; 0x2b
	struct ll_conn *conn = (void *)HDR_LLL2EVT(lll);
   21eb4:	68ec      	ldr	r4, [r5, #12]
	switch (done->extra.mic_state) {
   21eb6:	2b01      	cmp	r3, #1
   21eb8:	d039      	beq.n	21f2e <ull_conn_done+0x92>
   21eba:	b19b      	cbz	r3, 21ee4 <ull_conn_done+0x48>
   21ebc:	2b02      	cmp	r3, #2
   21ebe:	d03c      	beq.n	21f3a <ull_conn_done+0x9e>
	reason_peer = conn->llcp_terminate.reason_peer;
   21ec0:	f894 112b 	ldrb.w	r1, [r4, #299]	; 0x12b
	if (reason_peer && (
   21ec4:	2900      	cmp	r1, #0
   21ec6:	d03c      	beq.n	21f42 <ull_conn_done+0xa6>
   21ec8:	f995 302d 	ldrsb.w	r3, [r5, #45]	; 0x2d
   21ecc:	2b00      	cmp	r3, #0
   21ece:	db03      	blt.n	21ed8 <ull_conn_done+0x3c>
			    lll->role ||
   21ed0:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
   21ed4:	079a      	lsls	r2, r3, #30
   21ed6:	d534      	bpl.n	21f42 <ull_conn_done+0xa6>
			conn_cleanup(conn, BT_HCI_ERR_CONN_FAIL_TO_ESTAB);
   21ed8:	4620      	mov	r0, r4
   21eda:	f7ff ff7f 	bl	21ddc <conn_cleanup>
}
   21ede:	b00a      	add	sp, #40	; 0x28
   21ee0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (lll->enc_rx || conn->llcp_enc.pause_rx) {
   21ee4:	f895 306e 	ldrb.w	r3, [r5, #110]	; 0x6e
   21ee8:	0718      	lsls	r0, r3, #28
   21eea:	d403      	bmi.n	21ef4 <ull_conn_done+0x58>
   21eec:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   21ef0:	07d9      	lsls	r1, r3, #31
   21ef2:	d5e5      	bpl.n	21ec0 <ull_conn_done+0x24>
					    (lll->latency + 6)) ?
   21ef4:	8c2b      	ldrh	r3, [r5, #32]
			appto_reload_new = (conn->apto_reload >
   21ef6:	f8b4 20d2 	ldrh.w	r2, [r4, #210]	; 0xd2
					    (lll->latency + 6)) ?
   21efa:	1d99      	adds	r1, r3, #6
			appto_reload_new = (conn->apto_reload >
   21efc:	428a      	cmp	r2, r1
					   (conn->apto_reload -
   21efe:	bfc4      	itt	gt
   21f00:	1ad3      	subgt	r3, r2, r3
   21f02:	3b06      	subgt	r3, #6
			if (conn->appto_reload != appto_reload_new) {
   21f04:	f8b4 10ce 	ldrh.w	r1, [r4, #206]	; 0xce
			appto_reload_new = (conn->apto_reload >
   21f08:	bfcc      	ite	gt
   21f0a:	b29b      	uxthgt	r3, r3
   21f0c:	4613      	movle	r3, r2
			if (conn->appto_reload != appto_reload_new) {
   21f0e:	4299      	cmp	r1, r3
   21f10:	d008      	beq.n	21f24 <ull_conn_done+0x88>
				conn->appto_reload = appto_reload_new;
   21f12:	f8a4 30ce 	strh.w	r3, [r4, #206]	; 0xce
				conn->appto_expire = conn->appto_reload;
   21f16:	f8b4 30ce 	ldrh.w	r3, [r4, #206]	; 0xce
   21f1a:	f8a4 30d0 	strh.w	r3, [r4, #208]	; 0xd0
				conn->apto_expire = conn->apto_reload;
   21f1e:	f8a4 20d4 	strh.w	r2, [r4, #212]	; 0xd4
   21f22:	e7cd      	b.n	21ec0 <ull_conn_done+0x24>
			if (conn->apto_expire == 0U) {
   21f24:	f8b4 30d4 	ldrh.w	r3, [r4, #212]	; 0xd4
   21f28:	2b00      	cmp	r3, #0
   21f2a:	d1c9      	bne.n	21ec0 <ull_conn_done+0x24>
   21f2c:	e7f3      	b.n	21f16 <ull_conn_done+0x7a>
		conn->appto_expire = conn->apto_expire = 0U;
   21f2e:	2300      	movs	r3, #0
   21f30:	f8a4 30d4 	strh.w	r3, [r4, #212]	; 0xd4
   21f34:	f8a4 30d0 	strh.w	r3, [r4, #208]	; 0xd0
		break;
   21f38:	e7c2      	b.n	21ec0 <ull_conn_done+0x24>
		conn->llcp_terminate.reason_peer =
   21f3a:	233d      	movs	r3, #61	; 0x3d
   21f3c:	f884 312b 	strb.w	r3, [r4, #299]	; 0x12b
		break;
   21f40:	e7be      	b.n	21ec0 <ull_conn_done+0x24>
	ticks_drift_plus = 0U;
   21f42:	2300      	movs	r3, #0
	latency_event = lll->latency_event;
   21f44:	f8b5 8024 	ldrh.w	r8, [r5, #36]	; 0x24
	ticks_drift_minus = 0U;
   21f48:	e9cd 3308 	strd	r3, r3, [sp, #32]
	if (done->extra.trx_cnt) {
   21f4c:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
	elapsed_event = latency_event + 1;
   21f4e:	f108 0601 	add.w	r6, r8, #1
   21f52:	b2b6      	uxth	r6, r6
	if (done->extra.trx_cnt) {
   21f54:	b183      	cbz	r3, 21f78 <ull_conn_done+0xdc>
		} else if (lll->role) {
   21f56:	f995 302d 	ldrsb.w	r3, [r5, #45]	; 0x2d
   21f5a:	2b00      	cmp	r3, #0
   21f5c:	da1f      	bge.n	21f9e <ull_conn_done+0x102>
			ull_slave_done(done, &ticks_drift_plus,
   21f5e:	aa08      	add	r2, sp, #32
   21f60:	a909      	add	r1, sp, #36	; 0x24
   21f62:	4638      	mov	r0, r7
   21f64:	f7ec fc50 	bl	e808 <ull_slave_done>
			if (conn->tx_head || memq_peek(lll->memq_tx.head,
   21f68:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
   21f6c:	b15a      	cbz	r2, 21f86 <ull_conn_done+0xea>
				lll->latency_event = 0;
   21f6e:	2300      	movs	r3, #0
				lll->latency_event = lll->latency;
   21f70:	84ab      	strh	r3, [r5, #36]	; 0x24
		conn->connect_expire = 0U;
   21f72:	2300      	movs	r3, #0
   21f74:	f8a4 30c4 	strh.w	r3, [r4, #196]	; 0xc4
	if (done->extra.crc_valid) {
   21f78:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
   21f7c:	b1c3      	cbz	r3, 21fb0 <ull_conn_done+0x114>
		conn->supervision_expire = 0U;
   21f7e:	2300      	movs	r3, #0
			conn->supervision_expire = conn->supervision_reload;
   21f80:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
   21f84:	e01c      	b.n	21fc0 <ull_conn_done+0x124>
			if (conn->tx_head || memq_peek(lll->memq_tx.head,
   21f86:	e9d5 0116 	ldrd	r0, r1, [r5, #88]	; 0x58
   21f8a:	f009 fd36 	bl	2b9fa <memq_peek>
   21f8e:	2800      	cmp	r0, #0
   21f90:	d1ed      	bne.n	21f6e <ull_conn_done+0xd2>
			} else if (lll->slave.latency_enabled) {
   21f92:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
   21f96:	07db      	lsls	r3, r3, #31
   21f98:	d5eb      	bpl.n	21f72 <ull_conn_done+0xd6>
				lll->latency_event = lll->latency;
   21f9a:	8c2b      	ldrh	r3, [r5, #32]
   21f9c:	e7e8      	b.n	21f70 <ull_conn_done+0xd4>
		} else if (reason_peer) {
   21f9e:	2900      	cmp	r1, #0
   21fa0:	d0e7      	beq.n	21f72 <ull_conn_done+0xd6>
			conn->master.terminate_ack = 1;
   21fa2:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
   21fa6:	f043 0302 	orr.w	r3, r3, #2
   21faa:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
   21fae:	e7e0      	b.n	21f72 <ull_conn_done+0xd6>
	else if (conn->connect_expire) {
   21fb0:	f8b4 30c4 	ldrh.w	r3, [r4, #196]	; 0xc4
   21fb4:	b323      	cbz	r3, 22000 <ull_conn_done+0x164>
		if (conn->connect_expire > elapsed_event) {
   21fb6:	42b3      	cmp	r3, r6
   21fb8:	d920      	bls.n	21ffc <ull_conn_done+0x160>
			conn->connect_expire -= elapsed_event;
   21fba:	1b9b      	subs	r3, r3, r6
   21fbc:	f8a4 30c4 	strh.w	r3, [r4, #196]	; 0xc4
	if (conn->supervision_expire) {
   21fc0:	f8b4 30c8 	ldrh.w	r3, [r4, #200]	; 0xc8
   21fc4:	b1c3      	cbz	r3, 21ff8 <ull_conn_done+0x15c>
		if (conn->supervision_expire > elapsed_event) {
   21fc6:	42b3      	cmp	r3, r6
   21fc8:	d936      	bls.n	22038 <ull_conn_done+0x19c>
			conn->supervision_expire -= elapsed_event;
   21fca:	1b9b      	subs	r3, r3, r6
   21fcc:	b29b      	uxth	r3, r3
			lll->latency_event = 0;
   21fce:	2200      	movs	r2, #0
			if (conn->supervision_expire <= 6U) {
   21fd0:	2b06      	cmp	r3, #6
			conn->supervision_expire -= elapsed_event;
   21fd2:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
			lll->latency_event = 0;
   21fd6:	84aa      	strh	r2, [r5, #36]	; 0x24
			if (conn->supervision_expire <= 6U) {
   21fd8:	d930      	bls.n	2203c <ull_conn_done+0x1a0>
			else if (lll->role) {
   21fda:	f995 302d 	ldrsb.w	r3, [r5, #45]	; 0x2d
   21fde:	4293      	cmp	r3, r2
   21fe0:	da0a      	bge.n	21ff8 <ull_conn_done+0x15c>
				if (latency_event) {
   21fe2:	f1b8 0f00 	cmp.w	r8, #0
   21fe6:	d129      	bne.n	2203c <ull_conn_done+0x1a0>
					force = conn->slave.force & 0x01;
   21fe8:	f8d4 70e0 	ldr.w	r7, [r4, #224]	; 0xe0
					conn->slave.force >>= 1;
   21fec:	087b      	lsrs	r3, r7, #1
					if (force) {
   21fee:	f017 0701 	ands.w	r7, r7, #1
   21ff2:	d10c      	bne.n	2200e <ull_conn_done+0x172>
					conn->slave.force >>= 1;
   21ff4:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
	force = 0U;
   21ff8:	2700      	movs	r7, #0
   21ffa:	e00c      	b.n	22016 <ull_conn_done+0x17a>
			conn_cleanup(conn, BT_HCI_ERR_CONN_FAIL_TO_ESTAB);
   21ffc:	213e      	movs	r1, #62	; 0x3e
   21ffe:	e76b      	b.n	21ed8 <ull_conn_done+0x3c>
		if (!conn->supervision_expire) {
   22000:	f8b4 30c8 	ldrh.w	r3, [r4, #200]	; 0xc8
   22004:	2b00      	cmp	r3, #0
   22006:	d1db      	bne.n	21fc0 <ull_conn_done+0x124>
			conn->supervision_expire = conn->supervision_reload;
   22008:	f8b4 30c6 	ldrh.w	r3, [r4, #198]	; 0xc6
   2200c:	e7b8      	b.n	21f80 <ull_conn_done+0xe4>
						conn->slave.force |= BIT(31);
   2200e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   22012:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
	if (conn->procedure_expire != 0U) {
   22016:	f8b4 30cc 	ldrh.w	r3, [r4, #204]	; 0xcc
   2201a:	b123      	cbz	r3, 22026 <ull_conn_done+0x18a>
		if (conn->procedure_expire > elapsed_event) {
   2201c:	42b3      	cmp	r3, r6
   2201e:	d90f      	bls.n	22040 <ull_conn_done+0x1a4>
			conn->procedure_expire -= elapsed_event;
   22020:	1b9b      	subs	r3, r3, r6
   22022:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	if (conn->apto_expire != 0U) {
   22026:	f8b4 30d4 	ldrh.w	r3, [r4, #212]	; 0xd4
   2202a:	b1db      	cbz	r3, 22064 <ull_conn_done+0x1c8>
		if (conn->apto_expire > elapsed_event) {
   2202c:	42b3      	cmp	r3, r6
   2202e:	d909      	bls.n	22044 <ull_conn_done+0x1a8>
			conn->apto_expire -= elapsed_event;
   22030:	1b9b      	subs	r3, r3, r6
				conn->apto_expire = 1U;
   22032:	f8a4 30d4 	strh.w	r3, [r4, #212]	; 0xd4
   22036:	e015      	b.n	22064 <ull_conn_done+0x1c8>
			conn_cleanup(conn, BT_HCI_ERR_CONN_TIMEOUT);
   22038:	2108      	movs	r1, #8
   2203a:	e74d      	b.n	21ed8 <ull_conn_done+0x3c>
				force = 1U;
   2203c:	2701      	movs	r7, #1
   2203e:	e7ea      	b.n	22016 <ull_conn_done+0x17a>
			conn_cleanup(conn, BT_HCI_ERR_LL_RESP_TIMEOUT);
   22040:	2122      	movs	r1, #34	; 0x22
   22042:	e749      	b.n	21ed8 <ull_conn_done+0x3c>
			rx = ll_pdu_rx_alloc();
   22044:	f7fc f9ae 	bl	1e3a4 <ll_pdu_rx_alloc>
			if (rx) {
   22048:	4601      	mov	r1, r0
   2204a:	b320      	cbz	r0, 22096 <ull_conn_done+0x1fa>
				conn->apto_expire = 0U;
   2204c:	2300      	movs	r3, #0
   2204e:	f8a4 30d4 	strh.w	r3, [r4, #212]	; 0xd4
				rx->handle = lll->handle;
   22052:	8bab      	ldrh	r3, [r5, #28]
   22054:	80c3      	strh	r3, [r0, #6]
				rx->type = NODE_RX_TYPE_APTO;
   22056:	230c      	movs	r3, #12
   22058:	7103      	strb	r3, [r0, #4]
				ll_rx_put(rx->link, rx);
   2205a:	6800      	ldr	r0, [r0, #0]
   2205c:	f7fc f97a 	bl	1e354 <ll_rx_put>
				ll_rx_sched();
   22060:	f7fc f982 	bl	1e368 <ll_rx_sched>
	if (conn->appto_expire != 0U) {
   22064:	f8b4 20d0 	ldrh.w	r2, [r4, #208]	; 0xd0
   22068:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   2206c:	f894 10e9 	ldrb.w	r1, [r4, #233]	; 0xe9
   22070:	b122      	cbz	r2, 2207c <ull_conn_done+0x1e0>
		if (conn->appto_expire > elapsed_event) {
   22072:	42b2      	cmp	r2, r6
   22074:	d911      	bls.n	2209a <ull_conn_done+0x1fe>
			conn->appto_expire -= elapsed_event;
   22076:	1b96      	subs	r6, r2, r6
   22078:	f8a4 60d0 	strh.w	r6, [r4, #208]	; 0xd0
	if ((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
   2207c:	1a5b      	subs	r3, r3, r1
   2207e:	f003 0303 	and.w	r3, r3, #3
   22082:	2b02      	cmp	r3, #2
   22084:	d118      	bne.n	220b8 <ull_conn_done+0x21c>
	    ((conn->llcp_type == LLCP_CONN_UPD) ||
   22086:	f894 30ea 	ldrb.w	r3, [r4, #234]	; 0xea
	if ((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
   2208a:	3b01      	subs	r3, #1
   2208c:	2b01      	cmp	r3, #1
		lll->latency_event = 0;
   2208e:	bf9c      	itt	ls
   22090:	2300      	movls	r3, #0
   22092:	84ab      	strhls	r3, [r5, #36]	; 0x24
   22094:	e010      	b.n	220b8 <ull_conn_done+0x21c>
				conn->apto_expire = 1U;
   22096:	2301      	movs	r3, #1
   22098:	e7cb      	b.n	22032 <ull_conn_done+0x196>
			conn->appto_expire = 0U;
   2209a:	2200      	movs	r2, #0
   2209c:	f8a4 20d0 	strh.w	r2, [r4, #208]	; 0xd0
			if ((conn->procedure_expire == 0U) &&
   220a0:	f8b4 20cc 	ldrh.w	r2, [r4, #204]	; 0xcc
   220a4:	2a00      	cmp	r2, #0
   220a6:	d1e9      	bne.n	2207c <ull_conn_done+0x1e0>
   220a8:	428b      	cmp	r3, r1
   220aa:	d1e7      	bne.n	2207c <ull_conn_done+0x1e0>
				conn->llcp_type = LLCP_PING;
   220ac:	2205      	movs	r2, #5
				conn->llcp_ack -= 2U;
   220ae:	3b02      	subs	r3, #2
				conn->llcp_type = LLCP_PING;
   220b0:	f884 20ea 	strb.w	r2, [r4, #234]	; 0xea
				conn->llcp_ack -= 2U;
   220b4:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
	if ((force) || (latency_event != lll->latency_event)) {
   220b8:	8ca9      	ldrh	r1, [r5, #36]	; 0x24
   220ba:	b90f      	cbnz	r7, 220c0 <ull_conn_done+0x224>
   220bc:	4588      	cmp	r8, r1
   220be:	d02d      	beq.n	2211c <ull_conn_done+0x280>
		lazy = lll->latency_event + 1;
   220c0:	3101      	adds	r1, #1
   220c2:	b289      	uxth	r1, r1
	if ((ticks_drift_plus != 0U) || (ticks_drift_minus != 0U) ||
   220c4:	e9dd 6308 	ldrd	r6, r3, [sp, #32]
   220c8:	ea53 0206 	orrs.w	r2, r3, r6
   220cc:	d103      	bne.n	220d6 <ull_conn_done+0x23a>
   220ce:	b911      	cbnz	r1, 220d6 <ull_conn_done+0x23a>
	    (lazy != 0U) || (force != 0U)) {
   220d0:	2f00      	cmp	r7, #0
   220d2:	f43f af04 	beq.w	21ede <ull_conn_done+0x42>
		u8_t ticker_id = TICKER_ID_CONN_BASE + lll->handle;
   220d6:	7f2a      	ldrb	r2, [r5, #28]
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
   220d8:	4811      	ldr	r0, [pc, #68]	; (22120 <ull_conn_done+0x284>)
		struct ll_conn *conn = lll->hdr.parent;
   220da:	68ec      	ldr	r4, [r5, #12]
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
   220dc:	9406      	str	r4, [sp, #24]
   220de:	e9cd 7004 	strd	r7, r0, [sp, #16]
		u8_t ticker_id = TICKER_ID_CONN_BASE + lll->handle;
   220e2:	3205      	adds	r2, #5
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
   220e4:	2000      	movs	r0, #0
   220e6:	9103      	str	r1, [sp, #12]
   220e8:	e9cd 0001 	strd	r0, r0, [sp, #4]
   220ec:	9600      	str	r6, [sp, #0]
   220ee:	b2d2      	uxtb	r2, r2
   220f0:	2101      	movs	r1, #1
   220f2:	f7fa f82b 	bl	1c14c <ticker_update>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
   220f6:	f030 0302 	bics.w	r3, r0, #2
   220fa:	f43f aef0 	beq.w	21ede <ull_conn_done+0x42>
   220fe:	f7fc f9cb 	bl	1e498 <ull_disable_mark_get>
   22102:	4284      	cmp	r4, r0
   22104:	f43f aeeb 	beq.w	21ede <ull_conn_done+0x42>
   22108:	4806      	ldr	r0, [pc, #24]	; (22124 <ull_conn_done+0x288>)
   2210a:	f006 f81b 	bl	28144 <printk>
   2210e:	4040      	eors	r0, r0
   22110:	f380 8811 	msr	BASEPRI, r0
   22114:	f04f 0003 	mov.w	r0, #3
   22118:	df02      	svc	2
			  ((void *)conn == ull_disable_mark_get()));
   2211a:	e6e0      	b.n	21ede <ull_conn_done+0x42>
	lazy = 0U;
   2211c:	4639      	mov	r1, r7
   2211e:	e7d1      	b.n	220c4 <ull_conn_done+0x228>
   22120:	00020331 	.word	0x00020331
   22124:	00031d55 	.word	0x00031d55

00022128 <ull_conn_tx_lll_enqueue>:
{
   22128:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		link = mem_acquire(&mem_link_tx.free);
   2212c:	4f54      	ldr	r7, [pc, #336]	; (22280 <ull_conn_tx_lll_enqueue+0x158>)
		LL_ASSERT(link);
   2212e:	f8df 8154 	ldr.w	r8, [pc, #340]	; 22284 <ull_conn_tx_lll_enqueue+0x15c>
{
   22132:	4604      	mov	r4, r0
   22134:	460d      	mov	r5, r1
			conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
   22136:	2601      	movs	r6, #1
	while (conn->tx_head &&
   22138:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
   2213c:	b1f3      	cbz	r3, 2217c <ull_conn_tx_lll_enqueue+0x54>
		 !conn->llcp_phy.pause_tx &&
   2213e:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
	while (conn->tx_head &&
   22142:	07d1      	lsls	r1, r2, #31
   22144:	f100 8095 	bmi.w	22272 <ull_conn_tx_lll_enqueue+0x14a>
		 !conn->llcp_enc.pause_tx &&
   22148:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
		 !conn->llcp_phy.pause_tx &&
   2214c:	0792      	lsls	r2, r2, #30
   2214e:	f100 8090 	bmi.w	22272 <ull_conn_tx_lll_enqueue+0x14a>
	if ((pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
   22152:	791a      	ldrb	r2, [r3, #4]
   22154:	f002 0203 	and.w	r2, r2, #3
   22158:	2a03      	cmp	r2, #3
   2215a:	d10e      	bne.n	2217a <ull_conn_tx_lll_enqueue+0x52>
	    ((pdu_data_tx->llctrl.opcode ==
   2215c:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
   2215e:	2a03      	cmp	r2, #3
   22160:	d001      	beq.n	22166 <ull_conn_tx_lll_enqueue+0x3e>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) ||
   22162:	2a0a      	cmp	r2, #10
   22164:	d109      	bne.n	2217a <ull_conn_tx_lll_enqueue+0x52>
		if (((conn->llcp_req != conn->llcp_ack) &&
   22166:	f894 10e9 	ldrb.w	r1, [r4, #233]	; 0xe9
   2216a:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
   2216e:	428a      	cmp	r2, r1
   22170:	d03d      	beq.n	221ee <ull_conn_tx_lll_enqueue+0xc6>
   22172:	f894 20ea 	ldrb.w	r2, [r4, #234]	; 0xea
   22176:	2a03      	cmp	r2, #3
   22178:	d157      	bne.n	2222a <ull_conn_tx_lll_enqueue+0x102>
		(!pause_tx && (conn->tx_head == conn->tx_ctrl))) && count--) {
   2217a:	b90d      	cbnz	r5, 22180 <ull_conn_tx_lll_enqueue+0x58>
}
   2217c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		tx = tx_ull_dequeue(conn, conn->tx_head);
   22180:	f8d4 11b0 	ldr.w	r1, [r4, #432]	; 0x1b0
   22184:	4620      	mov	r0, r4
   22186:	f00a f86a 	bl	2c25e <tx_ull_dequeue>
		if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
   2218a:	7903      	ldrb	r3, [r0, #4]
   2218c:	f003 0303 	and.w	r3, r3, #3
   22190:	2b03      	cmp	r3, #3
		tx = tx_ull_dequeue(conn, conn->tx_head);
   22192:	4681      	mov	r9, r0
		if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
   22194:	d114      	bne.n	221c0 <ull_conn_tx_lll_enqueue+0x98>
	switch (pdu_tx->llctrl.opcode) {
   22196:	79c3      	ldrb	r3, [r0, #7]
   22198:	3b03      	subs	r3, #3
   2219a:	2b08      	cmp	r3, #8
   2219c:	d810      	bhi.n	221c0 <ull_conn_tx_lll_enqueue+0x98>
   2219e:	e8df f003 	tbb	[pc, r3]
   221a2:	0909      	.short	0x0909
   221a4:	0f0f0f0f 	.word	0x0f0f0f0f
   221a8:	090f      	.short	0x090f
   221aa:	05          	.byte	0x05
   221ab:	00          	.byte	0x00
		if (!conn->lll.role) {
   221ac:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   221b0:	2b00      	cmp	r3, #0
   221b2:	da05      	bge.n	221c0 <ull_conn_tx_lll_enqueue+0x98>
		conn->llcp_enc.pause_tx = 1U;
   221b4:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   221b8:	f043 0302 	orr.w	r3, r3, #2
   221bc:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		link = mem_acquire(&mem_link_tx.free);
   221c0:	4638      	mov	r0, r7
   221c2:	f009 fbb5 	bl	2b930 <mem_acquire>
		LL_ASSERT(link);
   221c6:	4682      	mov	sl, r0
   221c8:	b940      	cbnz	r0, 221dc <ull_conn_tx_lll_enqueue+0xb4>
   221ca:	4640      	mov	r0, r8
   221cc:	f005 ffba 	bl	28144 <printk>
   221d0:	4040      	eors	r0, r0
   221d2:	f380 8811 	msr	BASEPRI, r0
   221d6:	f04f 0003 	mov.w	r0, #3
   221da:	df02      	svc	2
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
   221dc:	f104 026c 	add.w	r2, r4, #108	; 0x6c
   221e0:	4649      	mov	r1, r9
   221e2:	4650      	mov	r0, sl
   221e4:	3d01      	subs	r5, #1
   221e6:	f009 fc01 	bl	2b9ec <memq_enqueue>
   221ea:	b2ed      	uxtb	r5, r5
   221ec:	e7a4      	b.n	22138 <ull_conn_tx_lll_enqueue+0x10>
		    ((conn->llcp_req == conn->llcp_ack) &&
   221ee:	f894 0119 	ldrb.w	r0, [r4, #281]	; 0x119
   221f2:	f894 1118 	ldrb.w	r1, [r4, #280]	; 0x118
   221f6:	4288      	cmp	r0, r1
   221f8:	d117      	bne.n	2222a <ull_conn_tx_lll_enqueue+0x102>
		     ((conn->llcp_feature.ack != conn->llcp_feature.req) ||
   221fa:	f894 0121 	ldrb.w	r0, [r4, #289]	; 0x121
   221fe:	f894 1120 	ldrb.w	r1, [r4, #288]	; 0x120
   22202:	4288      	cmp	r0, r1
   22204:	d111      	bne.n	2222a <ull_conn_tx_lll_enqueue+0x102>
		      (conn->llcp_version.ack != conn->llcp_version.req) ||
   22206:	f894 0171 	ldrb.w	r0, [r4, #369]	; 0x171
   2220a:	f894 1170 	ldrb.w	r1, [r4, #368]	; 0x170
   2220e:	4288      	cmp	r0, r1
   22210:	d10b      	bne.n	2222a <ull_conn_tx_lll_enqueue+0x102>
		       conn->llcp_conn_param.req) ||
   22212:	f894 0199 	ldrb.w	r0, [r4, #409]	; 0x199
   22216:	f894 1198 	ldrb.w	r1, [r4, #408]	; 0x198
   2221a:	4288      	cmp	r0, r1
   2221c:	d105      	bne.n	2222a <ull_conn_tx_lll_enqueue+0x102>
		      (conn->llcp_phy.ack != conn->llcp_phy.req) ||
   2221e:	f894 01a9 	ldrb.w	r0, [r4, #425]	; 0x1a9
   22222:	f894 11a8 	ldrb.w	r1, [r4, #424]	; 0x1a8
   22226:	4288      	cmp	r0, r1
   22228:	d016      	beq.n	22258 <ull_conn_tx_lll_enqueue+0x130>
			if ((tx->next != NULL) &&
   2222a:	681a      	ldr	r2, [r3, #0]
   2222c:	2a00      	cmp	r2, #0
   2222e:	d0a5      	beq.n	2217c <ull_conn_tx_lll_enqueue+0x54>
   22230:	f8d4 11b4 	ldr.w	r1, [r4, #436]	; 0x1b4
   22234:	428a      	cmp	r2, r1
   22236:	d1a1      	bne.n	2217c <ull_conn_tx_lll_enqueue+0x54>
				conn->tx_head = tx->next;
   22238:	f8c4 21b0 	str.w	r2, [r4, #432]	; 0x1b0
				tx->next = conn->tx_ctrl_last->next;
   2223c:	f8d4 21b8 	ldr.w	r2, [r4, #440]	; 0x1b8
   22240:	6811      	ldr	r1, [r2, #0]
   22242:	6019      	str	r1, [r3, #0]
				conn->tx_ctrl_last->next = tx;
   22244:	6013      	str	r3, [r2, #0]
				if (!conn->tx_data_last) {
   22246:	f8d4 21c0 	ldr.w	r2, [r4, #448]	; 0x1c0
				conn->tx_data = tx;
   2224a:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
				if (!conn->tx_data_last) {
   2224e:	2a00      	cmp	r2, #0
   22250:	d193      	bne.n	2217a <ull_conn_tx_lll_enqueue+0x52>
					conn->tx_data_last = tx;
   22252:	f8c4 31c0 	str.w	r3, [r4, #448]	; 0x1c0
   22256:	e790      	b.n	2217a <ull_conn_tx_lll_enqueue+0x52>
			conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
   22258:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
   2225c:	f366 0301 	bfi	r3, r6, #0, #2
   22260:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
			conn->llcp_ack -= 2U;
   22264:	3a02      	subs	r2, #2
			conn->llcp_type = LLCP_ENCRYPTION;
   22266:	2303      	movs	r3, #3
   22268:	f884 30ea 	strb.w	r3, [r4, #234]	; 0xea
			conn->llcp_ack -= 2U;
   2226c:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
   22270:	e783      	b.n	2217a <ull_conn_tx_lll_enqueue+0x52>
		(!pause_tx && (conn->tx_head == conn->tx_ctrl))) && count--) {
   22272:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
   22276:	4293      	cmp	r3, r2
   22278:	f43f af7f 	beq.w	2217a <ull_conn_tx_lll_enqueue+0x52>
   2227c:	e77e      	b.n	2217c <ull_conn_tx_lll_enqueue+0x54>
   2227e:	bf00      	nop
   22280:	20003540 	.word	0x20003540
   22284:	00031657 	.word	0x00031657

00022288 <ull_conn_link_tx_release>:
	mem_release(link, &mem_link_tx.free);
   22288:	4901      	ldr	r1, [pc, #4]	; (22290 <ull_conn_link_tx_release+0x8>)
   2228a:	f009 bb6a 	b.w	2b962 <mem_release>
   2228e:	bf00      	nop
   22290:	20003540 	.word	0x20003540

00022294 <ull_conn_ack_last_idx_get>:
}
   22294:	4b01      	ldr	r3, [pc, #4]	; (2229c <ull_conn_ack_last_idx_get+0x8>)
   22296:	78d8      	ldrb	r0, [r3, #3]
   22298:	4770      	bx	lr
   2229a:	bf00      	nop
   2229c:	2000fcd8 	.word	0x2000fcd8

000222a0 <ull_conn_ack_peek>:
{
   222a0:	b570      	push	{r4, r5, r6, lr}
	lll_tx = MFIFO_DEQUEUE_GET(conn_ack);
   222a2:	4b0a      	ldr	r3, [pc, #40]	; (222cc <ull_conn_ack_peek+0x2c>)
   222a4:	789c      	ldrb	r4, [r3, #2]
   222a6:	78dd      	ldrb	r5, [r3, #3]
	if (first == last) {
   222a8:	42ac      	cmp	r4, r5
{
   222aa:	4606      	mov	r6, r0
	lll_tx = MFIFO_DEQUEUE_GET(conn_ack);
   222ac:	7818      	ldrb	r0, [r3, #0]
   222ae:	d00b      	beq.n	222c8 <ull_conn_ack_peek+0x28>
	return (void *)(fifo + first * size);
   222b0:	3304      	adds	r3, #4
   222b2:	fb14 f400 	smulbb	r4, r4, r0
	if (!lll_tx) {
   222b6:	1918      	adds	r0, r3, r4
   222b8:	d005      	beq.n	222c6 <ull_conn_ack_peek+0x26>
	*ack_last = mfifo_conn_ack.l;
   222ba:	7035      	strb	r5, [r6, #0]
	*handle = lll_tx->handle;
   222bc:	5b1b      	ldrh	r3, [r3, r4]
   222be:	800b      	strh	r3, [r1, #0]
	*tx = lll_tx->node;
   222c0:	6843      	ldr	r3, [r0, #4]
   222c2:	6013      	str	r3, [r2, #0]
	return (*tx)->link;
   222c4:	6818      	ldr	r0, [r3, #0]
}
   222c6:	bd70      	pop	{r4, r5, r6, pc}
		return NULL;
   222c8:	2000      	movs	r0, #0
   222ca:	e7fc      	b.n	222c6 <ull_conn_ack_peek+0x26>
   222cc:	2000fcd8 	.word	0x2000fcd8

000222d0 <ull_conn_ack_by_last_peek>:
{
   222d0:	b530      	push	{r4, r5, lr}
	lll_tx = mfifo_dequeue_get(mfifo_conn_ack.m, mfifo_conn_ack.s,
   222d2:	4b09      	ldr	r3, [pc, #36]	; (222f8 <ull_conn_ack_by_last_peek+0x28>)
   222d4:	789c      	ldrb	r4, [r3, #2]
   222d6:	781d      	ldrb	r5, [r3, #0]
	if (first == last) {
   222d8:	4284      	cmp	r4, r0
   222da:	d00a      	beq.n	222f2 <ull_conn_ack_by_last_peek+0x22>
	return (void *)(fifo + first * size);
   222dc:	3304      	adds	r3, #4
   222de:	fb14 f405 	smulbb	r4, r4, r5
	if (!lll_tx) {
   222e2:	1918      	adds	r0, r3, r4
   222e4:	d004      	beq.n	222f0 <ull_conn_ack_by_last_peek+0x20>
	*handle = lll_tx->handle;
   222e6:	5b1b      	ldrh	r3, [r3, r4]
   222e8:	800b      	strh	r3, [r1, #0]
	*tx = lll_tx->node;
   222ea:	6843      	ldr	r3, [r0, #4]
   222ec:	6013      	str	r3, [r2, #0]
	return (*tx)->link;
   222ee:	6818      	ldr	r0, [r3, #0]
}
   222f0:	bd30      	pop	{r4, r5, pc}
		return NULL;
   222f2:	2000      	movs	r0, #0
   222f4:	e7fc      	b.n	222f0 <ull_conn_ack_by_last_peek+0x20>
   222f6:	bf00      	nop
   222f8:	2000fcd8 	.word	0x2000fcd8

000222fc <ull_conn_ack_dequeue>:
{
   222fc:	b510      	push	{r4, lr}
	return MFIFO_DEQUEUE(conn_ack);
   222fe:	4a09      	ldr	r2, [pc, #36]	; (22324 <ull_conn_ack_dequeue+0x28>)
	u8_t _first = *first; /* Copy read-index */
   22300:	7893      	ldrb	r3, [r2, #2]
	if (_first == last) {
   22302:	78d0      	ldrb	r0, [r2, #3]
   22304:	7811      	ldrb	r1, [r2, #0]
   22306:	7854      	ldrb	r4, [r2, #1]
   22308:	4298      	cmp	r0, r3
   2230a:	d009      	beq.n	22320 <ull_conn_ack_dequeue+0x24>
	mem = *((void **)(fifo + _first * size));
   2230c:	fb03 2101 	mla	r1, r3, r1, r2
	_first += 1U;
   22310:	3301      	adds	r3, #1
   22312:	b2db      	uxtb	r3, r3
		_first = 0U;
   22314:	429c      	cmp	r4, r3
   22316:	bf08      	it	eq
   22318:	2300      	moveq	r3, #0
	mem = *((void **)(fifo + _first * size));
   2231a:	6848      	ldr	r0, [r1, #4]
	*first = _first; /* Write back read-index */
   2231c:	7093      	strb	r3, [r2, #2]
}
   2231e:	bd10      	pop	{r4, pc}
		return NULL;
   22320:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(conn_ack);
   22322:	e7fc      	b.n	2231e <ull_conn_ack_dequeue+0x22>
   22324:	2000fcd8 	.word	0x2000fcd8

00022328 <ull_conn_lll_ack_enqueue>:
{
   22328:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
   2232a:	4a10      	ldr	r2, [pc, #64]	; (2236c <ull_conn_lll_ack_enqueue+0x44>)
   2232c:	78d4      	ldrb	r4, [r2, #3]
	if (last == count) {
   2232e:	7857      	ldrb	r7, [r2, #1]
   22330:	7895      	ldrb	r5, [r2, #2]
   22332:	7816      	ldrb	r6, [r2, #0]
	last = last + 1;
   22334:	1c63      	adds	r3, r4, #1
   22336:	b2db      	uxtb	r3, r3
		last = 0U;
   22338:	429f      	cmp	r7, r3
   2233a:	bf08      	it	eq
   2233c:	2300      	moveq	r3, #0
	if (last == first) {
   2233e:	429d      	cmp	r5, r3
   22340:	d004      	beq.n	2234c <ull_conn_lll_ack_enqueue+0x24>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
   22342:	1d15      	adds	r5, r2, #4
   22344:	fb14 f406 	smulbb	r4, r4, r6
	LL_ASSERT(lll_tx);
   22348:	192e      	adds	r6, r5, r4
   2234a:	d10b      	bne.n	22364 <ull_conn_lll_ack_enqueue+0x3c>
   2234c:	4808      	ldr	r0, [pc, #32]	; (22370 <ull_conn_lll_ack_enqueue+0x48>)
   2234e:	f005 fef9 	bl	28144 <printk>
   22352:	4040      	eors	r0, r0
   22354:	f380 8811 	msr	BASEPRI, r0
   22358:	f04f 0003 	mov.w	r0, #3
   2235c:	df02      	svc	2
	lll_tx->handle = handle;
   2235e:	2300      	movs	r3, #0
   22360:	801b      	strh	r3, [r3, #0]
   22362:	deff      	udf	#255	; 0xff
   22364:	5328      	strh	r0, [r5, r4]
	*last = idx; /* Commit: Update write index */
   22366:	70d3      	strb	r3, [r2, #3]
	lll_tx->node = tx;
   22368:	6071      	str	r1, [r6, #4]
}
   2236a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2236c:	2000fcd8 	.word	0x2000fcd8
   22370:	00031d1d 	.word	0x00031d1d

00022374 <ull_conn_tx_ack>:
{
   22374:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	LL_ASSERT(pdu_tx->len);
   22378:	7953      	ldrb	r3, [r2, #5]
{
   2237a:	4606      	mov	r6, r0
   2237c:	460f      	mov	r7, r1
   2237e:	4615      	mov	r5, r2
	LL_ASSERT(pdu_tx->len);
   22380:	b943      	cbnz	r3, 22394 <ull_conn_tx_ack+0x20>
   22382:	4898      	ldr	r0, [pc, #608]	; (225e4 <ull_conn_tx_ack+0x270>)
   22384:	f005 fede 	bl	28144 <printk>
   22388:	4040      	eors	r0, r0
   2238a:	f380 8811 	msr	BASEPRI, r0
   2238e:	f04f 0003 	mov.w	r0, #3
   22392:	df02      	svc	2
	if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
   22394:	792b      	ldrb	r3, [r5, #4]
   22396:	f003 0203 	and.w	r2, r3, #3
   2239a:	2a03      	cmp	r2, #3
   2239c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   223a0:	f040 8113 	bne.w	225ca <ull_conn_tx_ack+0x256>
		if (handle != 0xFFFF) {
   223a4:	4296      	cmp	r6, r2
   223a6:	f000 80fc 	beq.w	225a2 <ull_conn_tx_ack+0x22e>
			conn = ll_conn_get(handle);
   223aa:	4630      	mov	r0, r6
   223ac:	f7fe f8f0 	bl	20590 <ll_conn_get>
	switch (pdu_tx->llctrl.opcode) {
   223b0:	79eb      	ldrb	r3, [r5, #7]
   223b2:	3b02      	subs	r3, #2
			conn = ll_conn_get(handle);
   223b4:	4604      	mov	r4, r0
	switch (pdu_tx->llctrl.opcode) {
   223b6:	2b16      	cmp	r3, #22
   223b8:	d813      	bhi.n	223e2 <ull_conn_tx_ack+0x6e>
   223ba:	e8df f003 	tbb	[pc, r3]
   223be:	280c      	.short	0x280c
   223c0:	12121276 	.word	0x12121276
   223c4:	4b441212 	.word	0x4b441212
   223c8:	12128012 	.word	0x12128012
   223cc:	12127d12 	.word	0x12127d12
   223d0:	cbc4928a 	.word	0xcbc4928a
   223d4:	eb          	.byte	0xeb
   223d5:	00          	.byte	0x00
		u8_t reason = (pdu_tx->llctrl.terminate_ind.error_code ==
   223d6:	7a29      	ldrb	r1, [r5, #8]
   223d8:	2913      	cmp	r1, #19
		conn_cleanup(conn, reason);
   223da:	bf08      	it	eq
   223dc:	2116      	moveq	r1, #22
   223de:	f7ff fcfd 	bl	21ddc <conn_cleanup>
		if (link->next == (void *)tx) {
   223e2:	683b      	ldr	r3, [r7, #0]
   223e4:	42ab      	cmp	r3, r5
   223e6:	f040 80de 	bne.w	225a6 <ull_conn_tx_ack+0x232>
			LL_ASSERT(link->next);
   223ea:	b945      	cbnz	r5, 223fe <ull_conn_tx_ack+0x8a>
   223ec:	487e      	ldr	r0, [pc, #504]	; (225e8 <ull_conn_tx_ack+0x274>)
   223ee:	f005 fea9 	bl	28144 <printk>
   223f2:	4040      	eors	r0, r0
   223f4:	f380 8811 	msr	BASEPRI, r0
   223f8:	f04f 0003 	mov.w	r0, #3
   223fc:	df02      	svc	2
			mem_release(tx, &mem_conn_tx_ctrl.free);
   223fe:	497b      	ldr	r1, [pc, #492]	; (225ec <ull_conn_tx_ack+0x278>)
   22400:	4628      	mov	r0, r5
   22402:	f009 faae 	bl	2b962 <mem_release>
}
   22406:	4620      	mov	r0, r4
   22408:	b002      	add	sp, #8
   2240a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		memcpy(&conn->llcp.encryption.skd[0],
   2240e:	2208      	movs	r2, #8
   22410:	f105 0112 	add.w	r1, r5, #18
   22414:	30ee      	adds	r0, #238	; 0xee
   22416:	f008 f81a 	bl	2a44e <memcpy>
		memcpy(&conn->lll.ccm_rx.iv[0],
   2241a:	2204      	movs	r2, #4
   2241c:	f105 011a 	add.w	r1, r5, #26
   22420:	f104 0098 	add.w	r0, r4, #152	; 0x98
   22424:	f008 f813 	bl	2a44e <memcpy>
		conn->llcp_enc.pause_tx = 1U;
   22428:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   2242c:	f043 0302 	orr.w	r3, r3, #2
		conn->llcp_enc.pause_tx = 1U;
   22430:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		conn->procedure_expire = conn->procedure_reload;
   22434:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
   22438:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
		conn->llcp_enc.ack = conn->llcp_enc.req;
   2243c:	f894 3150 	ldrb.w	r3, [r4, #336]	; 0x150
   22440:	f884 3151 	strb.w	r3, [r4, #337]	; 0x151
		break;
   22444:	e7cd      	b.n	223e2 <ull_conn_tx_ack+0x6e>
		conn->llcp_enc.pause_tx = 1U;
   22446:	f890 3152 	ldrb.w	r3, [r0, #338]	; 0x152
   2244a:	f023 0306 	bic.w	r3, r3, #6
   2244e:	f043 0306 	orr.w	r3, r3, #6
   22452:	e7ed      	b.n	22430 <ull_conn_tx_ack+0xbc>
		if (!conn->lll.role) {
   22454:	f990 303d 	ldrsb.w	r3, [r0, #61]	; 0x3d
   22458:	2b00      	cmp	r3, #0
   2245a:	db26      	blt.n	224aa <ull_conn_tx_ack+0x136>
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   2245c:	792b      	ldrb	r3, [r5, #4]
   2245e:	f043 0303 	orr.w	r3, r3, #3
   22462:	712b      	strb	r3, [r5, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_req) +
   22464:	2317      	movs	r3, #23
   22466:	716b      	strb	r3, [r5, #5]
	memcpy(&pdu_ctrl_tx->llctrl.enc_req.rand[0], &conn->llcp_enc.rand[0],
   22468:	2208      	movs	r2, #8
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
   2246a:	2303      	movs	r3, #3
	memcpy(&pdu_ctrl_tx->llctrl.enc_req.rand[0], &conn->llcp_enc.rand[0],
   2246c:	f200 1155 	addw	r1, r0, #341	; 0x155
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
   22470:	71eb      	strb	r3, [r5, #7]
	memcpy(&pdu_ctrl_tx->llctrl.enc_req.rand[0], &conn->llcp_enc.rand[0],
   22472:	18a8      	adds	r0, r5, r2
   22474:	f007 ffeb 	bl	2a44e <memcpy>
	pdu_ctrl_tx->llctrl.enc_req.ediv[0] = conn->llcp_enc.ediv[0];
   22478:	f894 3153 	ldrb.w	r3, [r4, #339]	; 0x153
   2247c:	742b      	strb	r3, [r5, #16]
	pdu_ctrl_tx->llctrl.enc_req.ediv[1] = conn->llcp_enc.ediv[1];
   2247e:	f894 3154 	ldrb.w	r3, [r4, #340]	; 0x154
   22482:	746b      	strb	r3, [r5, #17]
	entropy_get_entropy_isr(entropy, pdu_ctrl_tx->llctrl.enc_req.skdm,
   22484:	4b5a      	ldr	r3, [pc, #360]	; (225f0 <ull_conn_tx_ack+0x27c>)
   22486:	6818      	ldr	r0, [r3, #0]
	if (unlikely(!api->get_entropy_isr)) {
   22488:	6843      	ldr	r3, [r0, #4]
   2248a:	f8d3 8004 	ldr.w	r8, [r3, #4]
   2248e:	f105 0112 	add.w	r1, r5, #18
   22492:	f1b8 0f00 	cmp.w	r8, #0
   22496:	d002      	beq.n	2249e <ull_conn_tx_ack+0x12a>
	return api->get_entropy_isr(dev, buffer, length, flags);
   22498:	2300      	movs	r3, #0
   2249a:	220c      	movs	r2, #12
   2249c:	47c0      	blx	r8
	ctrl_tx_enqueue(conn, *tx);
   2249e:	4629      	mov	r1, r5
   224a0:	4620      	mov	r0, r4
   224a2:	f009 ff5f 	bl	2c364 <ctrl_tx_enqueue>
	*tx = NULL;
   224a6:	2500      	movs	r5, #0
   224a8:	e79b      	b.n	223e2 <ull_conn_tx_ack+0x6e>
			conn->llcp_enc.pause_tx = 1U;
   224aa:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   224ae:	f043 0302 	orr.w	r3, r3, #2
   224b2:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
   224b6:	e794      	b.n	223e2 <ull_conn_tx_ack+0x6e>
		if (pdu_tx->llctrl.reject_ext_ind.reject_opcode !=
   224b8:	7a2b      	ldrb	r3, [r5, #8]
   224ba:	2b03      	cmp	r3, #3
   224bc:	d191      	bne.n	223e2 <ull_conn_tx_ack+0x6e>
		conn->llcp_enc.pause_rx = 0U;
   224be:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
   224c2:	f023 0303 	bic.w	r3, r3, #3
   224c6:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		conn->procedure_expire = 0U;
   224ca:	2300      	movs	r3, #0
   224cc:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
		break;
   224d0:	e787      	b.n	223e2 <ull_conn_tx_ack+0x6e>
		conn->llcp_length.state = LLCP_LENGTH_STATE_RSP_WAIT;
   224d2:	f890 319a 	ldrb.w	r3, [r0, #410]	; 0x19a
   224d6:	2202      	movs	r2, #2
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
   224d8:	f362 0302 	bfi	r3, r2, #0, #3
   224dc:	f884 319a 	strb.w	r3, [r4, #410]	; 0x19a
				break;
   224e0:	e77f      	b.n	223e2 <ull_conn_tx_ack+0x6e>
		if (conn->llcp_length.req != conn->llcp_length.ack) {
   224e2:	f890 1198 	ldrb.w	r1, [r0, #408]	; 0x198
   224e6:	f890 3199 	ldrb.w	r3, [r0, #409]	; 0x199
   224ea:	428b      	cmp	r3, r1
   224ec:	f43f af79 	beq.w	223e2 <ull_conn_tx_ack+0x6e>
			switch (conn->llcp_length.state) {
   224f0:	f890 319a 	ldrb.w	r3, [r0, #410]	; 0x19a
   224f4:	f003 0007 	and.w	r0, r3, #7
   224f8:	2807      	cmp	r0, #7
   224fa:	f43f af72 	beq.w	223e2 <ull_conn_tx_ack+0x6e>
   224fe:	2201      	movs	r2, #1
   22500:	4082      	lsls	r2, r0
   22502:	f012 0f68 	tst.w	r2, #104	; 0x68
   22506:	f43f af6c 	beq.w	223e2 <ull_conn_tx_ack+0x6e>
				conn->lll.max_tx_octets =
   2250a:	f8b4 219e 	ldrh.w	r2, [r4, #414]	; 0x19e
   2250e:	f8a4 205c 	strh.w	r2, [r4, #92]	; 0x5c
				if (conn->llcp_length.state ==
   22512:	2805      	cmp	r0, #5
				conn->lll.max_tx_time =
   22514:	f8b4 21a2 	ldrh.w	r2, [r4, #418]	; 0x1a2
   22518:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
				if (conn->llcp_length.state ==
   2251c:	d101      	bne.n	22522 <ull_conn_tx_ack+0x1ae>
					conn->llcp_length.state =
   2251e:	2204      	movs	r2, #4
   22520:	e7da      	b.n	224d8 <ull_conn_tx_ack+0x164>
				if (!conn->llcp_length.cache.tx_octets) {
   22522:	f8b4 21a4 	ldrh.w	r2, [r4, #420]	; 0x1a4
   22526:	b922      	cbnz	r2, 22532 <ull_conn_tx_ack+0x1be>
					conn->llcp_length.ack =
   22528:	f884 1199 	strb.w	r1, [r4, #409]	; 0x199
					conn->procedure_expire = 0U;
   2252c:	f8a4 20cc 	strh.w	r2, [r4, #204]	; 0xcc
					break;
   22530:	e757      	b.n	223e2 <ull_conn_tx_ack+0x6e>
				conn->llcp_length.tx_octets =
   22532:	f8a4 219e 	strh.w	r2, [r4, #414]	; 0x19e
				conn->llcp_length.tx_time =
   22536:	f8b4 11a6 	ldrh.w	r1, [r4, #422]	; 0x1a6
   2253a:	f8a4 11a2 	strh.w	r1, [r4, #418]	; 0x1a2
				conn->llcp_length.cache.tx_octets = 0;
   2253e:	2200      	movs	r2, #0
   22540:	f8a4 21a4 	strh.w	r2, [r4, #420]	; 0x1a4
				conn->llcp_length.tx_time =
   22544:	e7c8      	b.n	224d8 <ull_conn_tx_ack+0x164>
		conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
   22546:	f890 31aa 	ldrb.w	r3, [r0, #426]	; 0x1aa
   2254a:	2202      	movs	r2, #2
   2254c:	f362 0301 	bfi	r3, r2, #0, #2
   22550:	f880 31aa 	strb.w	r3, [r0, #426]	; 0x1aa
		if (conn->lll.role) {
   22554:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   22558:	2b00      	cmp	r3, #0
   2255a:	da14      	bge.n	22586 <ull_conn_tx_ack+0x212>
			u8_t phy_tx_time[8] = {BIT(0), BIT(0), BIT(1), BIT(0),
   2255c:	4a25      	ldr	r2, [pc, #148]	; (225f4 <ull_conn_tx_ack+0x280>)
   2255e:	f04f 3304 	mov.w	r3, #67372036	; 0x4040404
   22562:	e9cd 2300 	strd	r2, r3, [sp]
			phys = conn->llcp_phy.tx | lll->phy_tx;
   22566:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
   2256a:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
   2256e:	ea42 0393 	orr.w	r3, r2, r3, lsr #2
			lll->phy_tx_time = phy_tx_time[phys];
   22572:	f003 0307 	and.w	r3, r3, #7
   22576:	a902      	add	r1, sp, #8
   22578:	440b      	add	r3, r1
   2257a:	f813 3c08 	ldrb.w	r3, [r3, #-8]
   2257e:	f363 1206 	bfi	r2, r3, #4, #3
   22582:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
		conn->llcp_phy.pause_tx = 0U;
   22586:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
   2258a:	f36f 0300 	bfc	r3, #0, #1
   2258e:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
		break;
   22592:	e726      	b.n	223e2 <ull_conn_tx_ack+0x6e>
		conn->lll.phy_tx_time = conn->llcp.phy_upd_ind.tx;
   22594:	f890 30ec 	ldrb.w	r3, [r0, #236]	; 0xec
   22598:	f890 2064 	ldrb.w	r2, [r0, #100]	; 0x64
   2259c:	f3c3 0382 	ubfx	r3, r3, #2, #3
   225a0:	e7ed      	b.n	2257e <ull_conn_tx_ack+0x20a>
	struct ll_conn *conn = NULL;
   225a2:	2400      	movs	r4, #0
   225a4:	e71d      	b.n	223e2 <ull_conn_tx_ack+0x6e>
		} else if (!tx) {
   225a6:	2d00      	cmp	r5, #0
   225a8:	f43f af2d 	beq.w	22406 <ull_conn_tx_ack+0x92>
			LL_ASSERT(!link->next);
   225ac:	b143      	cbz	r3, 225c0 <ull_conn_tx_ack+0x24c>
   225ae:	4812      	ldr	r0, [pc, #72]	; (225f8 <ull_conn_tx_ack+0x284>)
   225b0:	f005 fdc8 	bl	28144 <printk>
   225b4:	4040      	eors	r0, r0
   225b6:	f380 8811 	msr	BASEPRI, r0
   225ba:	f04f 0003 	mov.w	r0, #3
   225be:	df02      	svc	2
	ll_tx_ack_put(handle, tx);
   225c0:	4629      	mov	r1, r5
   225c2:	4630      	mov	r0, r6
   225c4:	f7fb ff04 	bl	1e3d0 <ll_tx_ack_put>
	return conn;
   225c8:	e71d      	b.n	22406 <ull_conn_tx_ack+0x92>
	} else if (handle != 0xFFFF) {
   225ca:	4296      	cmp	r6, r2
   225cc:	d004      	beq.n	225d8 <ull_conn_tx_ack+0x264>
		conn = ll_conn_get(handle);
   225ce:	4630      	mov	r0, r6
   225d0:	f7fd ffde 	bl	20590 <ll_conn_get>
   225d4:	4604      	mov	r4, r0
   225d6:	e7f3      	b.n	225c0 <ull_conn_tx_ack+0x24c>
		pdu_tx->ll_id = PDU_DATA_LLID_RESV;
   225d8:	f36f 0301 	bfc	r3, #0, #2
   225dc:	712b      	strb	r3, [r5, #4]
	struct ll_conn *conn = NULL;
   225de:	2400      	movs	r4, #0
   225e0:	e7ee      	b.n	225c0 <ull_conn_tx_ack+0x24c>
   225e2:	bf00      	nop
   225e4:	00031ef6 	.word	0x00031ef6
   225e8:	00031f14 	.word	0x00031f14
   225ec:	200034bc 	.word	0x200034bc
   225f0:	20003188 	.word	0x20003188
   225f4:	01020101 	.word	0x01020101
   225f8:	00031f31 	.word	0x00031f31

000225fc <lll_clock_wait>:

void lll_clock_wait(void)
{
	static bool done;

	if (done) {
   225fc:	4b12      	ldr	r3, [pc, #72]	; (22648 <lll_clock_wait+0x4c>)
   225fe:	781a      	ldrb	r2, [r3, #0]
{
   22600:	b510      	push	{r4, lr}
	if (done) {
   22602:	b9e2      	cbnz	r2, 2263e <lll_clock_wait+0x42>
		return;
	}
	done = true;
   22604:	2201      	movs	r2, #1
   22606:	701a      	strb	r2, [r3, #0]
   22608:	4810      	ldr	r0, [pc, #64]	; (2264c <lll_clock_wait+0x50>)
   2260a:	f003 fe7b 	bl	26304 <z_impl_device_get_binding>

	struct device *lf_clock = device_get_binding(
		DT_INST_0_NORDIC_NRF_CLOCK_LABEL "_32K");

	LL_ASSERT(lf_clock);
   2260e:	4604      	mov	r4, r0
   22610:	b940      	cbnz	r0, 22624 <lll_clock_wait+0x28>
   22612:	480f      	ldr	r0, [pc, #60]	; (22650 <lll_clock_wait+0x54>)
   22614:	f005 fd96 	bl	28144 <printk>
   22618:	4040      	eors	r0, r0
   2261a:	f380 8811 	msr	BASEPRI, r0
   2261e:	f04f 0003 	mov.w	r0, #3
   22622:	df02      	svc	2
	return api->on(dev, sys);
   22624:	6863      	ldr	r3, [r4, #4]
   22626:	2100      	movs	r1, #0
   22628:	681b      	ldr	r3, [r3, #0]
   2262a:	4620      	mov	r0, r4
   2262c:	4798      	blx	r3
						clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	if (!api->get_status) {
   2262e:	6863      	ldr	r3, [r4, #4]
   22630:	691b      	ldr	r3, [r3, #16]
   22632:	b12b      	cbz	r3, 22640 <lll_clock_wait+0x44>
		return CLOCK_CONTROL_STATUS_UNKNOWN;
	}

	return api->get_status(dev, sys);
   22634:	2100      	movs	r1, #0
   22636:	4620      	mov	r0, r4
   22638:	4798      	blx	r3

	clock_control_on(lf_clock, NULL);
	while (clock_control_get_status(lf_clock, NULL) !=
   2263a:	2802      	cmp	r0, #2
   2263c:	d100      	bne.n	22640 <lll_clock_wait+0x44>
			CLOCK_CONTROL_STATUS_ON) {
		DEBUG_CPU_SLEEP(1);
		k_cpu_idle();
		DEBUG_CPU_SLEEP(0);
	}
}
   2263e:	bd10      	pop	{r4, pc}
	arch_cpu_idle();
   22640:	f7f1 fadc 	bl	13bfc <arch_cpu_idle>
   22644:	e7f3      	b.n	2262e <lll_clock_wait+0x32>
   22646:	bf00      	nop
   22648:	20003ea5 	.word	0x20003ea5
   2264c:	000301ee 	.word	0x000301ee
   22650:	00031f4f 	.word	0x00031f4f

00022654 <isr_cleanup>:

	isr_cleanup(param);
}

static void isr_cleanup(void *param)
{
   22654:	b508      	push	{r3, lr}
	int err;

	radio_isr_set(isr_race, param);
   22656:	4601      	mov	r1, r0
   22658:	480b      	ldr	r0, [pc, #44]	; (22688 <isr_cleanup+0x34>)
   2265a:	f002 f919 	bl	24890 <radio_isr_set>
	radio_tmr_stop();
   2265e:	f002 fb91 	bl	24d84 <radio_tmr_stop>

	err = lll_clk_off();
   22662:	f7fc fbcd 	bl	1ee00 <lll_clk_off>
	LL_ASSERT(!err || err == -EBUSY);
   22666:	b150      	cbz	r0, 2267e <isr_cleanup+0x2a>
   22668:	3010      	adds	r0, #16
   2266a:	d008      	beq.n	2267e <isr_cleanup+0x2a>
   2266c:	4807      	ldr	r0, [pc, #28]	; (2268c <isr_cleanup+0x38>)
   2266e:	f005 fd69 	bl	28144 <printk>
   22672:	4040      	eors	r0, r0
   22674:	f380 8811 	msr	BASEPRI, r0
   22678:	f04f 0003 	mov.w	r0, #3
   2267c:	df02      	svc	2

	lll_done(NULL);
   2267e:	2000      	movs	r0, #0
}
   22680:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
   22684:	f7fc bb74 	b.w	1ed70 <lll_done>
   22688:	0002c6e1 	.word	0x0002c6e1
   2268c:	00031b3d 	.word	0x00031b3d

00022690 <isr_done>:
{
   22690:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   22692:	4605      	mov	r5, r0
	radio_status_reset();
   22694:	f002 fa02 	bl	24a9c <radio_status_reset>
	radio_tmr_status_reset();
   22698:	f002 fad0 	bl	24c3c <radio_tmr_status_reset>
	radio_filter_status_reset();
   2269c:	f002 faaa 	bl	24bf4 <radio_filter_status_reset>
	radio_ar_status_reset();
   226a0:	f002 fc96 	bl	24fd0 <radio_ar_status_reset>
	radio_rssi_status_reset();
   226a4:	f002 fa6e 	bl	24b84 <radio_rssi_status_reset>
	e = ull_event_done_extra_get();
   226a8:	f7fc f900 	bl	1e8ac <ull_event_done_extra_get>
	LL_ASSERT(e);
   226ac:	4604      	mov	r4, r0
   226ae:	b940      	cbnz	r0, 226c2 <isr_done+0x32>
   226b0:	481b      	ldr	r0, [pc, #108]	; (22720 <isr_done+0x90>)
   226b2:	f005 fd47 	bl	28144 <printk>
   226b6:	4040      	eors	r0, r0
   226b8:	f380 8811 	msr	BASEPRI, r0
   226bc:	f04f 0003 	mov.w	r0, #3
   226c0:	df02      	svc	2
	e->crc_valid = crc_valid;
   226c2:	4a18      	ldr	r2, [pc, #96]	; (22724 <isr_done+0x94>)
	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
   226c4:	2301      	movs	r3, #1
	e->crc_valid = crc_valid;
   226c6:	7812      	ldrb	r2, [r2, #0]
	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
   226c8:	7023      	strb	r3, [r4, #0]
	e->trx_cnt = trx_cnt;
   226ca:	4b17      	ldr	r3, [pc, #92]	; (22728 <isr_done+0x98>)
	e->crc_valid = crc_valid;
   226cc:	71a2      	strb	r2, [r4, #6]
	e->mic_state = mic_state;
   226ce:	4a17      	ldr	r2, [pc, #92]	; (2272c <isr_done+0x9c>)
	e->trx_cnt = trx_cnt;
   226d0:	881b      	ldrh	r3, [r3, #0]
	e->mic_state = mic_state;
   226d2:	7812      	ldrb	r2, [r2, #0]
	e->trx_cnt = trx_cnt;
   226d4:	80a3      	strh	r3, [r4, #4]
	e->mic_state = mic_state;
   226d6:	71e2      	strb	r2, [r4, #7]
	if (trx_cnt) {
   226d8:	b1db      	cbz	r3, 22712 <isr_done+0x82>
		if (lll->role) {
   226da:	f995 3021 	ldrsb.w	r3, [r5, #33]	; 0x21
   226de:	2b00      	cmp	r3, #0
   226e0:	da17      	bge.n	22712 <isr_done+0x82>
				addr_us_get(lll->phy_rx);
   226e2:	f895 3049 	ldrb.w	r3, [r5, #73]	; 0x49
   226e6:	f003 0307 	and.w	r3, r3, #7
#define RANGE_DISTANCE 1000 /* meters */
#define RANGE_DELAY_US (2 * RANGE_DISTANCE * 4 / 1000)

static inline u32_t addr_us_get(u8_t phy)
{
	switch (phy) {
   226ea:	2b02      	cmp	r3, #2
   226ec:	d016      	beq.n	2271c <isr_done+0x8c>
	default:
	case BIT(0):
		return 40;
   226ee:	2b04      	cmp	r3, #4
   226f0:	bf0c      	ite	eq
   226f2:	f44f 77bc 	moveq.w	r7, #376	; 0x178
   226f6:	2728      	movne	r7, #40	; 0x28
				radio_tmr_aa_restore() - radio_tmr_ready_get();
   226f8:	f002 fb7c 	bl	24df4 <radio_tmr_aa_restore>
   226fc:	4606      	mov	r6, r0
   226fe:	f002 fb7f 	bl	24e00 <radio_tmr_ready_get>
			e->slave.window_widening_event_us =
   22702:	6b6b      	ldr	r3, [r5, #52]	; 0x34
				radio_tmr_aa_restore() - radio_tmr_ready_get();
   22704:	1a30      	subs	r0, r6, r0
			e->slave.preamble_to_addr_us = preamble_to_addr_us;
   22706:	e9c4 3703 	strd	r3, r7, [r4, #12]
			lll->slave.window_widening_event_us = 0;
   2270a:	2300      	movs	r3, #0
			e->slave.start_to_address_actual_us =
   2270c:	60a0      	str	r0, [r4, #8]
			lll->slave.window_widening_event_us = 0;
   2270e:	636b      	str	r3, [r5, #52]	; 0x34
			lll->slave.window_size_event_us = 0;
   22710:	63eb      	str	r3, [r5, #60]	; 0x3c
	isr_cleanup(param);
   22712:	4628      	mov	r0, r5
}
   22714:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	isr_cleanup(param);
   22718:	f7ff bf9c 	b.w	22654 <isr_cleanup>
	case BIT(1):
		return 24;
   2271c:	2718      	movs	r7, #24
   2271e:	e7eb      	b.n	226f8 <isr_done+0x68>
   22720:	00031f7c 	.word	0x00031f7c
   22724:	20003ea7 	.word	0x20003ea7
   22728:	20003cf8 	.word	0x20003cf8
   2272c:	20003ea8 	.word	0x20003ea8

00022730 <lll_conn_ppm_get>:
}
   22730:	4b01      	ldr	r3, [pc, #4]	; (22738 <lll_conn_ppm_get+0x8>)
   22732:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
   22736:	4770      	bx	lr
   22738:	0002e848 	.word	0x0002e848

0002273c <lll_conn_prepare_reset>:
	trx_cnt = 0U;
   2273c:	4a04      	ldr	r2, [pc, #16]	; (22750 <lll_conn_prepare_reset+0x14>)
   2273e:	2300      	movs	r3, #0
   22740:	8013      	strh	r3, [r2, #0]
	crc_expire = 0U;
   22742:	4a04      	ldr	r2, [pc, #16]	; (22754 <lll_conn_prepare_reset+0x18>)
   22744:	7013      	strb	r3, [r2, #0]
	crc_valid = 0U;
   22746:	4a04      	ldr	r2, [pc, #16]	; (22758 <lll_conn_prepare_reset+0x1c>)
   22748:	7013      	strb	r3, [r2, #0]
	mic_state = LLL_CONN_MIC_NONE;
   2274a:	4a04      	ldr	r2, [pc, #16]	; (2275c <lll_conn_prepare_reset+0x20>)
   2274c:	7013      	strb	r3, [r2, #0]
}
   2274e:	4770      	bx	lr
   22750:	20003cf8 	.word	0x20003cf8
   22754:	20003ea6 	.word	0x20003ea6
   22758:	20003ea7 	.word	0x20003ea7
   2275c:	20003ea8 	.word	0x20003ea8

00022760 <lll_conn_abort_cb>:
{
   22760:	b510      	push	{r4, lr}
   22762:	460c      	mov	r4, r1
	if (!prepare_param) {
   22764:	b930      	cbnz	r0, 22774 <lll_conn_abort_cb+0x14>
		radio_isr_set(isr_done, param);
   22766:	480d      	ldr	r0, [pc, #52]	; (2279c <lll_conn_abort_cb+0x3c>)
   22768:	f002 f892 	bl	24890 <radio_isr_set>
}
   2276c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
   22770:	f002 b982 	b.w	24a78 <radio_disable>
	err = lll_clk_off();
   22774:	f7fc fb44 	bl	1ee00 <lll_clk_off>
	LL_ASSERT(!err || err == -EBUSY);
   22778:	b150      	cbz	r0, 22790 <lll_conn_abort_cb+0x30>
   2277a:	3010      	adds	r0, #16
   2277c:	d008      	beq.n	22790 <lll_conn_abort_cb+0x30>
   2277e:	4808      	ldr	r0, [pc, #32]	; (227a0 <lll_conn_abort_cb+0x40>)
   22780:	f005 fce0 	bl	28144 <printk>
   22784:	4040      	eors	r0, r0
   22786:	f380 8811 	msr	BASEPRI, r0
   2278a:	f04f 0003 	mov.w	r0, #3
   2278e:	df02      	svc	2
	lll_done(param);
   22790:	4620      	mov	r0, r4
}
   22792:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
   22796:	f7fc baeb 	b.w	1ed70 <lll_done>
   2279a:	bf00      	nop
   2279c:	00022691 	.word	0x00022691
   227a0:	00031b3d 	.word	0x00031b3d

000227a4 <lll_conn_rx_pkt_set>:
{
   227a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   227a6:	4607      	mov	r7, r0
	node_rx = ull_pdu_rx_alloc_peek(1);
   227a8:	2001      	movs	r0, #1
   227aa:	f7fb fec7 	bl	1e53c <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   227ae:	4604      	mov	r4, r0
   227b0:	b940      	cbnz	r0, 227c4 <lll_conn_rx_pkt_set+0x20>
   227b2:	4818      	ldr	r0, [pc, #96]	; (22814 <lll_conn_rx_pkt_set+0x70>)
   227b4:	f005 fcc6 	bl	28144 <printk>
   227b8:	4040      	eors	r0, r0
   227ba:	f380 8811 	msr	BASEPRI, r0
   227be:	f04f 0003 	mov.w	r0, #3
   227c2:	df02      	svc	2
	phy = lll->phy_rx;
   227c4:	f897 5049 	ldrb.w	r5, [r7, #73]	; 0x49
	max_rx_octets = lll->max_rx_octets;
   227c8:	f8b7 6042 	ldrh.w	r6, [r7, #66]	; 0x42
	phy = lll->phy_rx;
   227cc:	f005 0507 	and.w	r5, r5, #7
	radio_phy_set(phy, 0);
   227d0:	2100      	movs	r1, #0
   227d2:	4628      	mov	r0, r5
   227d4:	f002 f8a2 	bl	2491c <radio_phy_set>
	} else if (lll->enc_rx) {
   227d8:	f897 3062 	ldrb.w	r3, [r7, #98]	; 0x62
   227dc:	006a      	lsls	r2, r5, #1
   227de:	071b      	lsls	r3, r3, #28
   227e0:	f042 0201 	orr.w	r2, r2, #1
   227e4:	f104 0420 	add.w	r4, r4, #32
   227e8:	d50e      	bpl.n	22808 <lll_conn_rx_pkt_set+0x64>
		radio_pkt_configure(8, (max_rx_octets + 4), (phy << 1) | 0x01);
   227ea:	1d31      	adds	r1, r6, #4
   227ec:	b2c9      	uxtb	r1, r1
   227ee:	2008      	movs	r0, #8
   227f0:	f002 f8f8 	bl	249e4 <radio_pkt_configure>
		radio_pkt_rx_set(radio_ccm_rx_pkt_set(&lll->ccm_rx, phy,
   227f4:	4622      	mov	r2, r4
   227f6:	4629      	mov	r1, r5
   227f8:	f107 0063 	add.w	r0, r7, #99	; 0x63
   227fc:	f002 fb1a 	bl	24e34 <radio_ccm_rx_pkt_set>
}
   22800:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_rx_set(node_rx->pdu);
   22804:	f002 b920 	b.w	24a48 <radio_pkt_rx_set>
		radio_pkt_configure(8, max_rx_octets, (phy << 1) | 0x01);
   22808:	2008      	movs	r0, #8
   2280a:	b2f1      	uxtb	r1, r6
   2280c:	f002 f8ea 	bl	249e4 <radio_pkt_configure>
		radio_pkt_rx_set(node_rx->pdu);
   22810:	4620      	mov	r0, r4
   22812:	e7f5      	b.n	22800 <lll_conn_rx_pkt_set+0x5c>
   22814:	00031bc6 	.word	0x00031bc6

00022818 <lll_conn_isr_tx>:
{
   22818:	b538      	push	{r3, r4, r5, lr}
   2281a:	4605      	mov	r5, r0
	radio_status_reset();
   2281c:	f002 f93e 	bl	24a9c <radio_status_reset>
	radio_tmr_status_reset();
   22820:	f002 fa0c 	bl	24c3c <radio_tmr_status_reset>
	radio_isr_set(lll_conn_isr_rx, param);
   22824:	4629      	mov	r1, r5
   22826:	4825      	ldr	r0, [pc, #148]	; (228bc <lll_conn_isr_tx+0xa4>)
   22828:	f002 f832 	bl	24890 <radio_isr_set>
	radio_tmr_tifs_set(EVENT_IFS_US);
   2282c:	2096      	movs	r0, #150	; 0x96
   2282e:	f002 fa15 	bl	24c5c <radio_tmr_tifs_set>
				     lll->phy_flags);
   22832:	f895 2048 	ldrb.w	r2, [r5, #72]	; 0x48
	radio_switch_complete_and_tx(lll->phy_rx, 0,
   22836:	f895 0049 	ldrb.w	r0, [r5, #73]	; 0x49
   2283a:	f3c2 03c0 	ubfx	r3, r2, #3, #1
   2283e:	2100      	movs	r1, #0
   22840:	f002 0207 	and.w	r2, r2, #7
   22844:	f000 0007 	and.w	r0, r0, #7
   22848:	f002 f972 	bl	24b30 <radio_switch_complete_and_tx>
	lll_conn_rx_pkt_set(lll);
   2284c:	4628      	mov	r0, r5
   2284e:	f7ff ffa9 	bl	227a4 <lll_conn_rx_pkt_set>
	LL_ASSERT(!radio_is_ready());
   22852:	f002 f92f 	bl	24ab4 <radio_is_ready>
   22856:	b140      	cbz	r0, 2286a <lll_conn_isr_tx+0x52>
   22858:	4819      	ldr	r0, [pc, #100]	; (228c0 <lll_conn_isr_tx+0xa8>)
   2285a:	f005 fc73 	bl	28144 <printk>
   2285e:	4040      	eors	r0, r0
   22860:	f380 8811 	msr	BASEPRI, r0
   22864:	f04f 0003 	mov.w	r0, #3
   22868:	df02      	svc	2
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 +
   2286a:	f002 fadd 	bl	24e28 <radio_tmr_tifs_base_get>
   2286e:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
   22870:	f895 0049 	ldrb.w	r0, [r5, #73]	; 0x49
   22874:	2101      	movs	r1, #1
   22876:	f000 0007 	and.w	r0, r0, #7
   2287a:	f00a f91d 	bl	2cab8 <radio_rx_chain_delay_get>
	hcto += addr_us_get(lll->phy_rx);
   2287e:	f895 3049 	ldrb.w	r3, [r5, #73]	; 0x49
   22882:	f003 0307 	and.w	r3, r3, #7
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
   22886:	4404      	add	r4, r0
	switch (phy) {
   22888:	2b02      	cmp	r3, #2
   2288a:	f104 04a3 	add.w	r4, r4, #163	; 0xa3
   2288e:	d012      	beq.n	228b6 <lll_conn_isr_tx+0x9e>
		return 40;
   22890:	2b04      	cmp	r3, #4
   22892:	bf0c      	ite	eq
   22894:	f44f 70bc 	moveq.w	r0, #376	; 0x178
   22898:	2028      	movne	r0, #40	; 0x28
	hcto += addr_us_get(lll->phy_rx);
   2289a:	4404      	add	r4, r0
	hcto -= radio_tx_chain_delay_get(lll->phy_tx, lll->phy_flags);
   2289c:	f895 0048 	ldrb.w	r0, [r5, #72]	; 0x48
   228a0:	f3c0 01c0 	ubfx	r1, r0, #3, #1
   228a4:	f000 0007 	and.w	r0, r0, #7
   228a8:	f00a f902 	bl	2cab0 <radio_tx_chain_delay_get>
	radio_tmr_hcto_configure(hcto);
   228ac:	1a20      	subs	r0, r4, r0
}
   228ae:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	radio_tmr_hcto_configure(hcto);
   228b2:	f002 ba73 	b.w	24d9c <radio_tmr_hcto_configure>
		return 24;
   228b6:	2018      	movs	r0, #24
   228b8:	e7ef      	b.n	2289a <lll_conn_isr_tx+0x82>
   228ba:	bf00      	nop
   228bc:	000228c5 	.word	0x000228c5
   228c0:	00031b62 	.word	0x00031b62

000228c4 <lll_conn_isr_rx>:
{
   228c4:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   228c8:	4604      	mov	r4, r0
	trx_done = radio_is_done();
   228ca:	f002 f8fd 	bl	24ac8 <radio_is_done>
   228ce:	b2c5      	uxtb	r5, r0
	if (trx_done) {
   228d0:	b1a5      	cbz	r5, 228fc <lll_conn_isr_rx+0x38>
		crc_ok = radio_crc_is_valid();
   228d2:	f002 f90f 	bl	24af4 <radio_crc_is_valid>
   228d6:	b2c7      	uxtb	r7, r0
		rssi_ready = radio_rssi_is_ready();
   228d8:	f002 f95c 	bl	24b94 <radio_rssi_is_ready>
	radio_status_reset();
   228dc:	f002 f8de 	bl	24a9c <radio_status_reset>
	radio_tmr_status_reset();
   228e0:	f002 f9ac 	bl	24c3c <radio_tmr_status_reset>
	radio_rssi_status_reset();
   228e4:	f002 f94e 	bl	24b84 <radio_rssi_status_reset>
	if (!trx_done) {
   228e8:	b955      	cbnz	r5, 22900 <lll_conn_isr_rx+0x3c>
		radio_isr_set(isr_done, param);
   228ea:	4621      	mov	r1, r4
   228ec:	48a0      	ldr	r0, [pc, #640]	; (22b70 <lll_conn_isr_rx+0x2ac>)
   228ee:	f001 ffcf 	bl	24890 <radio_isr_set>
		radio_disable();
   228f2:	f002 f8c1 	bl	24a78 <radio_disable>
}
   228f6:	b002      	add	sp, #8
   228f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		crc_ok = rssi_ready = 0U;
   228fc:	462f      	mov	r7, r5
   228fe:	e7ed      	b.n	228dc <lll_conn_isr_rx+0x18>
	trx_cnt++;
   22900:	4a9c      	ldr	r2, [pc, #624]	; (22b74 <lll_conn_isr_rx+0x2b0>)
   22902:	8813      	ldrh	r3, [r2, #0]
	node_rx = ull_pdu_rx_alloc_peek(1);
   22904:	2001      	movs	r0, #1
	trx_cnt++;
   22906:	3301      	adds	r3, #1
   22908:	8013      	strh	r3, [r2, #0]
	node_rx = ull_pdu_rx_alloc_peek(1);
   2290a:	f7fb fe17 	bl	1e53c <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
   2290e:	4606      	mov	r6, r0
   22910:	b940      	cbnz	r0, 22924 <lll_conn_isr_rx+0x60>
   22912:	4899      	ldr	r0, [pc, #612]	; (22b78 <lll_conn_isr_rx+0x2b4>)
   22914:	f005 fc16 	bl	28144 <printk>
   22918:	4040      	eors	r0, r0
   2291a:	f380 8811 	msr	BASEPRI, r0
   2291e:	f04f 0003 	mov.w	r0, #3
   22922:	df02      	svc	2
	if (crc_ok) {
   22924:	2f00      	cmp	r7, #0
   22926:	f000 8113 	beq.w	22b50 <lll_conn_isr_rx+0x28c>

static int isr_rx_pdu(struct lll_conn *lll, struct pdu_data *pdu_data_rx,
		      struct node_tx **tx_release, u8_t *is_rx_enqueue)
{
	/* Ack for tx-ed data */
	if (pdu_data_rx->nesn != lll->sn) {
   2292a:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
   2292e:	f896 1020 	ldrb.w	r1, [r6, #32]
   22932:	f003 0201 	and.w	r2, r3, #1
   22936:	f3c1 0180 	ubfx	r1, r1, #2, #1
   2293a:	4291      	cmp	r1, r2
   2293c:	f000 80a9 	beq.w	22a92 <lll_conn_isr_rx+0x1ce>
		/* Increment serial number */
		lll->sn++;
   22940:	f082 0201 	eor.w	r2, r2, #1
   22944:	f362 0300 	bfi	r3, r2, #0, #1
   22948:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62

#if defined(CONFIG_BT_PERIPHERAL)
		/* First ack (and redundantly any other ack) enable use of
		 * slave latency.
		 */
		if (lll->role) {
   2294c:	f994 3021 	ldrsb.w	r3, [r4, #33]	; 0x21
   22950:	2b00      	cmp	r3, #0
			lll->slave.latency_enabled = 1;
   22952:	bfbe      	ittt	lt
   22954:	f894 3024 	ldrblt.w	r3, [r4, #36]	; 0x24
   22958:	f043 0301 	orrlt.w	r3, r3, #1
   2295c:	f884 3024 	strblt.w	r3, [r4, #36]	; 0x24
		}
#endif /* CONFIG_BT_PERIPHERAL */

		if (!lll->empty) {
   22960:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
   22964:	0758      	lsls	r0, r3, #29
   22966:	f100 8090 	bmi.w	22a8a <lll_conn_isr_rx+0x1c6>
			struct pdu_data *pdu_data_tx;
			u8_t pdu_data_tx_len;
			struct node_tx *tx;
			memq_link_t *link;

			link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail,
   2296a:	aa01      	add	r2, sp, #4
   2296c:	e9d4 0113 	ldrd	r0, r1, [r4, #76]	; 0x4c
   22970:	f009 f843 	bl	2b9fa <memq_peek>
					 (void **)&tx);
			LL_ASSERT(link);
   22974:	4605      	mov	r5, r0
   22976:	b940      	cbnz	r0, 2298a <lll_conn_isr_rx+0xc6>
   22978:	4880      	ldr	r0, [pc, #512]	; (22b7c <lll_conn_isr_rx+0x2b8>)
   2297a:	f005 fbe3 	bl	28144 <printk>
   2297e:	4040      	eors	r0, r0
   22980:	f380 8811 	msr	BASEPRI, r0
   22984:	f04f 0003 	mov.w	r0, #3
   22988:	df02      	svc	2

			pdu_data_tx = (void *)(tx->pdu +
					       lll->packet_tx_head_offset);
   2298a:	f894 3061 	ldrb.w	r3, [r4, #97]	; 0x61

			pdu_data_tx_len = pdu_data_tx->len;
   2298e:	9a01      	ldr	r2, [sp, #4]
   22990:	441a      	add	r2, r3
   22992:	7950      	ldrb	r0, [r2, #5]
#if defined(CONFIG_BT_CTLR_LE_ENC)
			if (pdu_data_tx_len != 0U) {
   22994:	b150      	cbz	r0, 229ac <lll_conn_isr_rx+0xe8>
				/* if encrypted increment tx counter */
				if (lll->enc_tx) {
   22996:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
   2299a:	06d1      	lsls	r1, r2, #27
   2299c:	d506      	bpl.n	229ac <lll_conn_isr_rx+0xe8>
					lll->ccm_tx.counter++;
   2299e:	e9d4 2125 	ldrd	r2, r1, [r4, #148]	; 0x94
   229a2:	3201      	adds	r2, #1
   229a4:	f141 0100 	adc.w	r1, r1, #0
   229a8:	e9c4 2125 	strd	r2, r1, [r4, #148]	; 0x94
				}
			}
#endif /* CONFIG_BT_CTLR_LE_ENC */

			lll->packet_tx_head_offset += pdu_data_tx_len;
			if (lll->packet_tx_head_offset ==
   229ac:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
			lll->packet_tx_head_offset += pdu_data_tx_len;
   229b0:	4403      	add	r3, r0
   229b2:	b2db      	uxtb	r3, r3
			if (lll->packet_tx_head_offset ==
   229b4:	429a      	cmp	r2, r3
			lll->packet_tx_head_offset += pdu_data_tx_len;
   229b6:	f884 3061 	strb.w	r3, [r4, #97]	; 0x61
			if (lll->packet_tx_head_offset ==
   229ba:	f04f 0200 	mov.w	r2, #0
   229be:	d168      	bne.n	22a92 <lll_conn_isr_rx+0x1ce>
			    lll->packet_tx_head_len) {
				lll->packet_tx_head_len = 0;
   229c0:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
				lll->packet_tx_head_offset = 0;

				memq_dequeue(lll->memq_tx.tail,
   229c4:	f104 014c 	add.w	r1, r4, #76	; 0x4c
   229c8:	6d20      	ldr	r0, [r4, #80]	; 0x50
   229ca:	f009 f81e 	bl	2ba0a <memq_dequeue>
					     &lll->memq_tx.head, NULL);

				/* TX node UPSTREAM, i.e. Tx node ack path */
				link->next = tx->next; /* Indicates ctrl or data
   229ce:	f8dd 8004 	ldr.w	r8, [sp, #4]
   229d2:	f8d8 3000 	ldr.w	r3, [r8]
   229d6:	602b      	str	r3, [r5, #0]
							* pool.
							*/
				tx->next = link;
   229d8:	f8c8 5000 	str.w	r5, [r8]
			lll->empty = 0;
		}
	}

	/* process received data */
	if ((pdu_data_rx->sn == lll->nesn) &&
   229dc:	f896 2020 	ldrb.w	r2, [r6, #32]
   229e0:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
   229e4:	f3c2 02c0 	ubfx	r2, r2, #3, #1
   229e8:	f3c3 0340 	ubfx	r3, r3, #1, #1
   229ec:	429a      	cmp	r2, r3
   229ee:	d053      	beq.n	22a98 <lll_conn_isr_rx+0x1d4>
	u8_t is_rx_enqueue = 0U;
   229f0:	f04f 0900 	mov.w	r9, #0
		crc_expire = 0U;
   229f4:	4b62      	ldr	r3, [pc, #392]	; (22b80 <lll_conn_isr_rx+0x2bc>)
   229f6:	2500      	movs	r5, #0
   229f8:	701d      	strb	r5, [r3, #0]
		crc_valid = 1U;
   229fa:	4b62      	ldr	r3, [pc, #392]	; (22b84 <lll_conn_isr_rx+0x2c0>)
   229fc:	2201      	movs	r2, #1
   229fe:	701a      	strb	r2, [r3, #0]
	is_empty_pdu_tx_retry = lll->empty;
   22a00:	f894 a062 	ldrb.w	sl, [r4, #98]	; 0x62
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
   22a04:	a901      	add	r1, sp, #4
   22a06:	4620      	mov	r0, r4
	is_empty_pdu_tx_retry = lll->empty;
   22a08:	f3ca 0a80 	ubfx	sl, sl, #2, #1
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
   22a0c:	f009 fece 	bl	2c7ac <lll_conn_pdu_tx_prep>
	is_done = is_crc_backoff || ((crc_ok) && (pdu_data_rx->md == 0) &&
   22a10:	2d00      	cmp	r5, #0
   22a12:	f040 80c1 	bne.w	22b98 <lll_conn_isr_rx+0x2d4>
   22a16:	b147      	cbz	r7, 22a2a <lll_conn_isr_rx+0x166>
   22a18:	f896 3020 	ldrb.w	r3, [r6, #32]
   22a1c:	06db      	lsls	r3, r3, #27
   22a1e:	d404      	bmi.n	22a2a <lll_conn_isr_rx+0x166>
				     (pdu_data_tx->len == 0));
   22a20:	9b01      	ldr	r3, [sp, #4]
	is_done = is_crc_backoff || ((crc_ok) && (pdu_data_rx->md == 0) &&
   22a22:	785b      	ldrb	r3, [r3, #1]
   22a24:	2b00      	cmp	r3, #0
   22a26:	f000 80b7 	beq.w	22b98 <lll_conn_isr_rx+0x2d4>
		radio_isr_set(lll_conn_isr_tx, param);
   22a2a:	4621      	mov	r1, r4
   22a2c:	4856      	ldr	r0, [pc, #344]	; (22b88 <lll_conn_isr_rx+0x2c4>)
   22a2e:	f001 ff2f 	bl	24890 <radio_isr_set>
		radio_tmr_tifs_set(EVENT_IFS_US);
   22a32:	2096      	movs	r0, #150	; 0x96
   22a34:	f002 f912 	bl	24c5c <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(lll->phy_rx);
   22a38:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
   22a3c:	f000 0007 	and.w	r0, r0, #7
   22a40:	f002 f86a 	bl	24b18 <radio_switch_complete_and_rx>
		radio_tmr_end_capture();
   22a44:	f002 f9e2 	bl	24e0c <radio_tmr_end_capture>
	pdu_data_tx->sn = lll->sn;
   22a48:	9901      	ldr	r1, [sp, #4]
   22a4a:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
   22a4e:	780b      	ldrb	r3, [r1, #0]
   22a50:	f3c2 0200 	ubfx	r2, r2, #0, #1
   22a54:	f362 03c3 	bfi	r3, r2, #3, #1
	pdu_data_tx->nesn = lll->nesn;
   22a58:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
   22a5c:	f3c2 0240 	ubfx	r2, r2, #1, #1
   22a60:	f362 0382 	bfi	r3, r2, #2, #1
   22a64:	700b      	strb	r3, [r1, #0]
	lll_conn_tx_pkt_set(lll, pdu_data_tx);
   22a66:	4620      	mov	r0, r4
   22a68:	f009 fe77 	bl	2c75a <lll_conn_tx_pkt_set>
	LL_ASSERT(!radio_is_ready());
   22a6c:	f002 f822 	bl	24ab4 <radio_is_ready>
   22a70:	2800      	cmp	r0, #0
   22a72:	f000 80ad 	beq.w	22bd0 <lll_conn_isr_rx+0x30c>
   22a76:	4845      	ldr	r0, [pc, #276]	; (22b8c <lll_conn_isr_rx+0x2c8>)
   22a78:	f005 fb64 	bl	28144 <printk>
   22a7c:	4040      	eors	r0, r0
   22a7e:	f380 8811 	msr	BASEPRI, r0
   22a82:	f04f 0003 	mov.w	r0, #3
   22a86:	df02      	svc	2
   22a88:	e0a2      	b.n	22bd0 <lll_conn_isr_rx+0x30c>
			lll->empty = 0;
   22a8a:	f36f 0382 	bfc	r3, #2, #1
   22a8e:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62
	struct node_tx *tx_release = NULL;
   22a92:	f04f 0800 	mov.w	r8, #0
   22a96:	e7a1      	b.n	229dc <lll_conn_isr_rx+0x118>
	    /* check so that we will NEVER use the rx buffer reserved for empty
	     * packet and internal control enqueue
	     */
	    (ull_pdu_rx_alloc_peek(3) != 0)) {
   22a98:	2003      	movs	r0, #3
   22a9a:	f7fb fd4f 	bl	1e53c <ull_pdu_rx_alloc_peek>
	if ((pdu_data_rx->sn == lll->nesn) &&
   22a9e:	2800      	cmp	r0, #0
   22aa0:	d0a6      	beq.n	229f0 <lll_conn_isr_rx+0x12c>
		/* Increment next expected serial number */
		lll->nesn++;
   22aa2:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
   22aa6:	f083 0302 	eor.w	r3, r3, #2
   22aaa:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62

		if (pdu_data_rx->len != 0) {
   22aae:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
   22ab2:	2b00      	cmp	r3, #0
   22ab4:	d09c      	beq.n	229f0 <lll_conn_isr_rx+0x12c>
#if defined(CONFIG_BT_CTLR_LE_ENC)
			/* If required, wait for CCM to finish
			 */
			if (lll->enc_rx) {
   22ab6:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
   22aba:	071a      	lsls	r2, r3, #28
   22abc:	d545      	bpl.n	22b4a <lll_conn_isr_rx+0x286>
				u32_t done;

				done = radio_ccm_is_done();
   22abe:	f002 fa2d 	bl	24f1c <radio_ccm_is_done>
				LL_ASSERT(done);
   22ac2:	b940      	cbnz	r0, 22ad6 <lll_conn_isr_rx+0x212>
   22ac4:	4832      	ldr	r0, [pc, #200]	; (22b90 <lll_conn_isr_rx+0x2cc>)
   22ac6:	f005 fb3d 	bl	28144 <printk>
   22aca:	4040      	eors	r0, r0
   22acc:	f380 8811 	msr	BASEPRI, r0
   22ad0:	f04f 0003 	mov.w	r0, #3
   22ad4:	df02      	svc	2

				bool mic_failure = !radio_ccm_mic_is_valid();
   22ad6:	f002 fa3f 	bl	24f58 <radio_ccm_mic_is_valid>

				if (mic_failure &&
   22ada:	4d2e      	ldr	r5, [pc, #184]	; (22b94 <lll_conn_isr_rx+0x2d0>)
   22adc:	bb28      	cbnz	r0, 22b2a <lll_conn_isr_rx+0x266>
				    lll->ccm_rx.counter == 0 &&
   22ade:	f8d4 2073 	ldr.w	r2, [r4, #115]	; 0x73
   22ae2:	f8d4 3077 	ldr.w	r3, [r4, #119]	; 0x77
				if (mic_failure &&
   22ae6:	4313      	orrs	r3, r2
   22ae8:	f040 80a6 	bne.w	22c38 <lll_conn_isr_rx+0x374>
				    (pdu_data_rx->ll_id ==
   22aec:	f896 3020 	ldrb.w	r3, [r6, #32]
				    lll->ccm_rx.counter == 0 &&
   22af0:	f003 0303 	and.w	r3, r3, #3
   22af4:	2b03      	cmp	r3, #3
   22af6:	f040 809f 	bne.w	22c38 <lll_conn_isr_rx+0x374>
					 * middle of the LL encryption procedure
					 * with MIC failure.
					 * This could be an unencrypted packet
					 */
					struct pdu_data *scratch_pkt =
						radio_pkt_scratch_get();
   22afa:	f002 f809 	bl	24b10 <radio_pkt_scratch_get>

					if (ctrl_pdu_len_check(
   22afe:	7842      	ldrb	r2, [r0, #1]
   22b00:	2a1b      	cmp	r2, #27
						radio_pkt_scratch_get();
   22b02:	4601      	mov	r1, r0
					if (ctrl_pdu_len_check(
   22b04:	f200 8098 	bhi.w	22c38 <lll_conn_isr_rx+0x374>
						scratch_pkt->len)) {
						memcpy(pdu_data_rx,
   22b08:	3203      	adds	r2, #3
   22b0a:	f106 0020 	add.w	r0, r6, #32
   22b0e:	f007 fc9e 	bl	2a44e <memcpy>
						       scratch_pkt,
						       scratch_pkt->len +
						       offsetof(struct pdu_data,
							llctrl));
						mic_failure = false;
						lll->ccm_rx.counter--;
   22b12:	f8d4 3073 	ldr.w	r3, [r4, #115]	; 0x73
   22b16:	f8d4 2077 	ldr.w	r2, [r4, #119]	; 0x77
   22b1a:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
   22b1e:	f142 32ff 	adc.w	r2, r2, #4294967295	; 0xffffffff
   22b22:	f8c4 3073 	str.w	r3, [r4, #115]	; 0x73
   22b26:	f8c4 2077 	str.w	r2, [r4, #119]	; 0x77

					return -EINVAL;
				}

				/* Increment counter */
				lll->ccm_rx.counter++;
   22b2a:	f8d4 3073 	ldr.w	r3, [r4, #115]	; 0x73
   22b2e:	f8d4 2077 	ldr.w	r2, [r4, #119]	; 0x77
   22b32:	3301      	adds	r3, #1
   22b34:	f142 0200 	adc.w	r2, r2, #0

				/* Record MIC valid */
				mic_state = LLL_CONN_MIC_PASS;
   22b38:	f04f 0901 	mov.w	r9, #1
				lll->ccm_rx.counter++;
   22b3c:	f8c4 3073 	str.w	r3, [r4, #115]	; 0x73
   22b40:	f8c4 2077 	str.w	r2, [r4, #119]	; 0x77
				mic_state = LLL_CONN_MIC_PASS;
   22b44:	f885 9000 	strb.w	r9, [r5]
		if (err) {
   22b48:	e754      	b.n	229f4 <lll_conn_isr_rx+0x130>
			}
#endif /* CONFIG_BT_CTLR_LE_ENC */

			/* Enqueue non-empty PDU */
			*is_rx_enqueue = 1U;
   22b4a:	f04f 0901 	mov.w	r9, #1
   22b4e:	e751      	b.n	229f4 <lll_conn_isr_rx+0x130>
		if (crc_expire == 0U) {
   22b50:	4b0b      	ldr	r3, [pc, #44]	; (22b80 <lll_conn_isr_rx+0x2bc>)
   22b52:	781a      	ldrb	r2, [r3, #0]
   22b54:	b90a      	cbnz	r2, 22b5a <lll_conn_isr_rx+0x296>
			crc_expire = 2U;
   22b56:	2202      	movs	r2, #2
   22b58:	701a      	strb	r2, [r3, #0]
		crc_expire--;
   22b5a:	781d      	ldrb	r5, [r3, #0]
   22b5c:	3d01      	subs	r5, #1
   22b5e:	b2ed      	uxtb	r5, r5
   22b60:	701d      	strb	r5, [r3, #0]
	u8_t is_rx_enqueue = 0U;
   22b62:	f04f 0900 	mov.w	r9, #0
		is_crc_backoff = (crc_expire == 0U);
   22b66:	fab5 f585 	clz	r5, r5
   22b6a:	096d      	lsrs	r5, r5, #5
	struct node_tx *tx_release = NULL;
   22b6c:	46c8      	mov	r8, r9
   22b6e:	e747      	b.n	22a00 <lll_conn_isr_rx+0x13c>
   22b70:	00022691 	.word	0x00022691
   22b74:	20003cf8 	.word	0x20003cf8
   22b78:	00031bc6 	.word	0x00031bc6
   22b7c:	00031657 	.word	0x00031657
   22b80:	20003ea6 	.word	0x20003ea6
   22b84:	20003ea7 	.word	0x20003ea7
   22b88:	00022819 	.word	0x00022819
   22b8c:	00031b62 	.word	0x00031b62
   22b90:	00031f90 	.word	0x00031f90
   22b94:	20003ea8 	.word	0x20003ea8
		radio_isr_set(isr_done, param);
   22b98:	4621      	mov	r1, r4
   22b9a:	482a      	ldr	r0, [pc, #168]	; (22c44 <lll_conn_isr_rx+0x380>)
   22b9c:	f001 fe78 	bl	24890 <radio_isr_set>
		} else if (!lll->role) {
   22ba0:	f994 3021 	ldrsb.w	r3, [r4, #33]	; 0x21
   22ba4:	2b00      	cmp	r3, #0
   22ba6:	db3f      	blt.n	22c28 <lll_conn_isr_rx+0x364>
			radio_disable();
   22ba8:	f001 ff66 	bl	24a78 <radio_disable>
			LL_ASSERT(!radio_is_ready());
   22bac:	f001 ff82 	bl	24ab4 <radio_is_ready>
   22bb0:	b140      	cbz	r0, 22bc4 <lll_conn_isr_rx+0x300>
   22bb2:	4825      	ldr	r0, [pc, #148]	; (22c48 <lll_conn_isr_rx+0x384>)
   22bb4:	f005 fac6 	bl	28144 <printk>
   22bb8:	4040      	eors	r0, r0
   22bba:	f380 8811 	msr	BASEPRI, r0
   22bbe:	f04f 0003 	mov.w	r0, #3
   22bc2:	df02      	svc	2
			lll->empty = is_empty_pdu_tx_retry;
   22bc4:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
   22bc8:	f36a 0382 	bfi	r3, sl, #2, #1
   22bcc:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62
	if (!radio_tmr_aa_restore()) {
   22bd0:	f002 f910 	bl	24df4 <radio_tmr_aa_restore>
   22bd4:	b918      	cbnz	r0, 22bde <lll_conn_isr_rx+0x31a>
		radio_tmr_aa_save(radio_tmr_aa_get());
   22bd6:	f002 f901 	bl	24ddc <radio_tmr_aa_get>
   22bda:	f002 f905 	bl	24de8 <radio_tmr_aa_save>
	if (tx_release) {
   22bde:	f1b8 0f00 	cmp.w	r8, #0
   22be2:	d024      	beq.n	22c2e <lll_conn_isr_rx+0x36a>
		LL_ASSERT(lll->handle != 0xFFFF);
   22be4:	8a22      	ldrh	r2, [r4, #16]
   22be6:	f64f 73ff 	movw	r3, #65535	; 0xffff
   22bea:	429a      	cmp	r2, r3
   22bec:	d108      	bne.n	22c00 <lll_conn_isr_rx+0x33c>
   22bee:	4817      	ldr	r0, [pc, #92]	; (22c4c <lll_conn_isr_rx+0x388>)
   22bf0:	f005 faa8 	bl	28144 <printk>
   22bf4:	4040      	eors	r0, r0
   22bf6:	f380 8811 	msr	BASEPRI, r0
   22bfa:	f04f 0003 	mov.w	r0, #3
   22bfe:	df02      	svc	2
		ull_conn_lll_ack_enqueue(lll->handle, tx_release);
   22c00:	4641      	mov	r1, r8
   22c02:	8a20      	ldrh	r0, [r4, #16]
   22c04:	f7ff fb90 	bl	22328 <ull_conn_lll_ack_enqueue>
	if (is_rx_enqueue) {
   22c08:	f1b9 0f00 	cmp.w	r9, #0
   22c0c:	d009      	beq.n	22c22 <lll_conn_isr_rx+0x35e>
		ull_pdu_rx_alloc();
   22c0e:	f7fb fcad 	bl	1e56c <ull_pdu_rx_alloc>
		node_rx->hdr.type = NODE_RX_TYPE_DC_PDU;
   22c12:	2302      	movs	r3, #2
   22c14:	7133      	strb	r3, [r6, #4]
		node_rx->hdr.handle = lll->handle;
   22c16:	8a23      	ldrh	r3, [r4, #16]
   22c18:	80f3      	strh	r3, [r6, #6]
		ull_rx_put(node_rx->hdr.link, node_rx);
   22c1a:	4631      	mov	r1, r6
   22c1c:	6830      	ldr	r0, [r6, #0]
   22c1e:	f7fb fcbb 	bl	1e598 <ull_rx_put>
		ull_rx_sched();
   22c22:	f7fb fcc9 	bl	1e5b8 <ull_rx_sched>
	ARG_UNUSED(rssi_ready);
   22c26:	e666      	b.n	228f6 <lll_conn_isr_rx+0x32>
			radio_switch_complete_and_disable();
   22c28:	f001 ff8e 	bl	24b48 <radio_switch_complete_and_disable>
   22c2c:	e70c      	b.n	22a48 <lll_conn_isr_rx+0x184>
	if (is_rx_enqueue) {
   22c2e:	f1b9 0f00 	cmp.w	r9, #0
   22c32:	f43f ae60 	beq.w	228f6 <lll_conn_isr_rx+0x32>
   22c36:	e7ea      	b.n	22c0e <lll_conn_isr_rx+0x34a>
					mic_state = LLL_CONN_MIC_FAIL;
   22c38:	2302      	movs	r3, #2
   22c3a:	702b      	strb	r3, [r5, #0]
	u8_t is_rx_enqueue = 0U;
   22c3c:	f04f 0900 	mov.w	r9, #0
   22c40:	e7c6      	b.n	22bd0 <lll_conn_isr_rx+0x30c>
   22c42:	bf00      	nop
   22c44:	00022691 	.word	0x00022691
   22c48:	00031b62 	.word	0x00031b62
   22c4c:	00031fa7 	.word	0x00031fa7

00022c50 <ticker_op_cb>:
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
		  param == ull_disable_mark_get());
}

static void ticker_op_cb(u32_t status, void *param)
{
   22c50:	b508      	push	{r3, lr}
	ARG_UNUSED(param);

	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   22c52:	b140      	cbz	r0, 22c66 <ticker_op_cb+0x16>
   22c54:	4804      	ldr	r0, [pc, #16]	; (22c68 <ticker_op_cb+0x18>)
   22c56:	f005 fa75 	bl	28144 <printk>
   22c5a:	4040      	eors	r0, r0
   22c5c:	f380 8811 	msr	BASEPRI, r0
   22c60:	f04f 0003 	mov.w	r0, #3
   22c64:	df02      	svc	2
}
   22c66:	bd08      	pop	{r3, pc}
   22c68:	00031bf1 	.word	0x00031bf1

00022c6c <ticker_op_stop_adv_cb>:
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
   22c6c:	2801      	cmp	r0, #1
{
   22c6e:	b510      	push	{r4, lr}
   22c70:	460c      	mov	r4, r1
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
   22c72:	d10c      	bne.n	22c8e <ticker_op_stop_adv_cb+0x22>
   22c74:	f7fb fc10 	bl	1e498 <ull_disable_mark_get>
   22c78:	4284      	cmp	r4, r0
   22c7a:	d008      	beq.n	22c8e <ticker_op_stop_adv_cb+0x22>
   22c7c:	4804      	ldr	r0, [pc, #16]	; (22c90 <ticker_op_stop_adv_cb+0x24>)
   22c7e:	f005 fa61 	bl	28144 <printk>
   22c82:	4040      	eors	r0, r0
   22c84:	f380 8811 	msr	BASEPRI, r0
   22c88:	f04f 0003 	mov.w	r0, #3
   22c8c:	df02      	svc	2
}
   22c8e:	bd10      	pop	{r4, pc}
   22c90:	00031ff2 	.word	0x00031ff2

00022c94 <ull_slave_ticker_cb>:
{
   22c94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   22c96:	4605      	mov	r5, r0
   22c98:	460f      	mov	r7, r1
	ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
   22c9a:	4601      	mov	r1, r0
   22c9c:	4618      	mov	r0, r3
{
   22c9e:	4616      	mov	r6, r2
   22ca0:	461c      	mov	r4, r3
	ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
   22ca2:	f7ea fa81 	bl	d1a8 <ull_conn_llcp>
	if (ret) {
   22ca6:	bb70      	cbnz	r0, 22d06 <ull_slave_ticker_cb+0x72>
   22ca8:	7c23      	ldrb	r3, [r4, #16]
   22caa:	3301      	adds	r3, #1
   22cac:	b2db      	uxtb	r3, r3
   22cae:	7423      	strb	r3, [r4, #16]
	LL_ASSERT(ref);
   22cb0:	b943      	cbnz	r3, 22cc4 <ull_slave_ticker_cb+0x30>
   22cb2:	4815      	ldr	r0, [pc, #84]	; (22d08 <ull_slave_ticker_cb+0x74>)
   22cb4:	f005 fa46 	bl	28144 <printk>
   22cb8:	4040      	eors	r0, r0
   22cba:	f380 8811 	msr	BASEPRI, r0
   22cbe:	f04f 0003 	mov.w	r0, #3
   22cc2:	df02      	svc	2
	p.ticks_at_expire = ticks_at_expire;
   22cc4:	4a11      	ldr	r2, [pc, #68]	; (22d0c <ull_slave_ticker_cb+0x78>)
	p.param = &conn->lll;
   22cc6:	f104 031c 	add.w	r3, r4, #28
   22cca:	60d3      	str	r3, [r2, #12]
	mfy.param = &p;
   22ccc:	4b10      	ldr	r3, [pc, #64]	; (22d10 <ull_slave_ticker_cb+0x7c>)
	p.lazy = lazy;
   22cce:	8116      	strh	r6, [r2, #8]
	p.remainder = remainder;
   22cd0:	e9c2 5700 	strd	r5, r7, [r2]
	mfy.param = &p;
   22cd4:	609a      	str	r2, [r3, #8]
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   22cd6:	2200      	movs	r2, #0
   22cd8:	4611      	mov	r1, r2
   22cda:	2001      	movs	r0, #1
   22cdc:	f7f8 fd7a 	bl	1b7d4 <mayfly_enqueue>
	LL_ASSERT(!err);
   22ce0:	b140      	cbz	r0, 22cf4 <ull_slave_ticker_cb+0x60>
   22ce2:	480c      	ldr	r0, [pc, #48]	; (22d14 <ull_slave_ticker_cb+0x80>)
   22ce4:	f005 fa2e 	bl	28144 <printk>
   22ce8:	4040      	eors	r0, r0
   22cea:	f380 8811 	msr	BASEPRI, r0
   22cee:	f04f 0003 	mov.w	r0, #3
   22cf2:	df02      	svc	2
	ull_conn_tx_demux(UINT8_MAX);
   22cf4:	20ff      	movs	r0, #255	; 0xff
   22cf6:	f7ff f82b 	bl	21d50 <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
   22cfa:	4620      	mov	r0, r4
   22cfc:	21ff      	movs	r1, #255	; 0xff
}
   22cfe:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
   22d02:	f7ff ba11 	b.w	22128 <ull_conn_tx_lll_enqueue>
}
   22d06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   22d08:	00031a3e 	.word	0x00031a3e
   22d0c:	20003594 	.word	0x20003594
   22d10:	2000fd70 	.word	0x2000fd70
   22d14:	000317e5 	.word	0x000317e5

00022d18 <prepare_cb>:
{
	return 0;
}

static int prepare_cb(struct lll_prepare_param *prepare_param)
{
   22d18:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	struct lll_conn *lll = prepare_param->param;
   22d1c:	68c4      	ldr	r4, [r0, #12]

	DEBUG_RADIO_START_S(1);

	/* TODO: Do the below in ULL ?  */

	lazy = prepare_param->lazy;
   22d1e:	8903      	ldrh	r3, [r0, #8]

	/* Calc window widening */
	if (lll->role) {
   22d20:	f994 2021 	ldrsb.w	r2, [r4, #33]	; 0x21
   22d24:	2a00      	cmp	r2, #0
{
   22d26:	4605      	mov	r5, r0
	if (lll->role) {
   22d28:	da09      	bge.n	22d3e <prepare_cb+0x26>
		lll->slave.window_widening_prepare_us +=
		    lll->slave.window_widening_periodic_us * (lazy + 1);
   22d2a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
		lll->slave.window_widening_prepare_us +=
   22d2c:	6b21      	ldr	r1, [r4, #48]	; 0x30
		    lll->slave.window_widening_periodic_us * (lazy + 1);
   22d2e:	fb03 2202 	mla	r2, r3, r2, r2
		lll->slave.window_widening_prepare_us +=
   22d32:	440a      	add	r2, r1
		if (lll->slave.window_widening_prepare_us >
		    lll->slave.window_widening_max_us) {
   22d34:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
			lll->slave.window_widening_prepare_us =
   22d36:	4291      	cmp	r1, r2
   22d38:	bf94      	ite	ls
   22d3a:	6321      	strls	r1, [r4, #48]	; 0x30
   22d3c:	6322      	strhi	r2, [r4, #48]	; 0x30
				lll->slave.window_widening_max_us;
		}
	}

	/* save the latency for use in event */
	lll->latency_prepare += lazy;
   22d3e:	8ae2      	ldrh	r2, [r4, #22]
   22d40:	4413      	add	r3, r2

	/* calc current event counter value */
	event_counter = lll->event_counter + lll->latency_prepare;
   22d42:	8b62      	ldrh	r2, [r4, #26]
	lll->latency_prepare += lazy;
   22d44:	b29b      	uxth	r3, r3
   22d46:	82e3      	strh	r3, [r4, #22]
	event_counter = lll->event_counter + lll->latency_prepare;
   22d48:	4413      	add	r3, r2

	/* store the next event counter value */
	lll->event_counter = event_counter + 1;
   22d4a:	3301      	adds	r3, #1
   22d4c:	8363      	strh	r3, [r4, #26]

	/* TODO: Do the above in ULL ?  */

	/* Reset connection event global variables */
	lll_conn_prepare_reset();
   22d4e:	f7ff fcf5 	bl	2273c <lll_conn_prepare_reset>

	/* TODO: can we do something in ULL? */
	lll->latency_event = lll->latency_prepare;
	lll->latency_prepare = 0;
   22d52:	2300      	movs	r3, #0
	lll->latency_event = lll->latency_prepare;
   22d54:	8ae2      	ldrh	r2, [r4, #22]
	lll->latency_prepare = 0;
   22d56:	82e3      	strh	r3, [r4, #22]

	if (lll->data_chan_sel) {
   22d58:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
	lll->latency_event = lll->latency_prepare;
   22d5c:	8322      	strh	r2, [r4, #24]
	if (lll->data_chan_sel) {
   22d5e:	0659      	lsls	r1, r3, #25
   22d60:	f104 061c 	add.w	r6, r4, #28
   22d64:	f140 808e 	bpl.w	22e84 <prepare_cb+0x16c>
#if defined(CONFIG_BT_CTLR_CHAN_SEL_2)
		data_chan_use = lll_chan_sel_2(lll->event_counter - 1,
   22d68:	8b60      	ldrh	r0, [r4, #26]
   22d6a:	8c61      	ldrh	r1, [r4, #34]	; 0x22
   22d6c:	3801      	subs	r0, #1
   22d6e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   22d72:	4632      	mov	r2, r6
   22d74:	b280      	uxth	r0, r0
   22d76:	f7fb fdcd 	bl	1e914 <lll_chan_sel_2>
					       &lll->data_chan_map[0],
					       lll->data_chan_count);
	}

	/* current window widening */
	lll->slave.window_widening_event_us +=
   22d7a:	e9d4 230c 	ldrd	r2, r3, [r4, #48]	; 0x30
   22d7e:	4413      	add	r3, r2
		lll->slave.window_widening_prepare_us;
	lll->slave.window_widening_prepare_us = 0;
	if (lll->slave.window_widening_event_us >
	    lll->slave.window_widening_max_us) {
   22d80:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
		lll->slave.window_widening_event_us =
   22d82:	429a      	cmp	r2, r3
   22d84:	bf94      	ite	ls
   22d86:	6362      	strls	r2, [r4, #52]	; 0x34
   22d88:	6363      	strhi	r3, [r4, #52]	; 0x34
			lll->slave.window_widening_max_us;
	}

	/* current window size */
	lll->slave.window_size_event_us +=
   22d8a:	e9d4 230e 	ldrd	r2, r3, [r4, #56]	; 0x38
	lll->slave.window_widening_prepare_us = 0;
   22d8e:	f04f 0800 	mov.w	r8, #0
	lll->slave.window_size_event_us +=
   22d92:	4413      	add	r3, r2
		lll->slave.window_size_prepare_us;
	lll->slave.window_size_prepare_us = 0;
   22d94:	e9c4 830e 	strd	r8, r3, [r4, #56]	; 0x38
	lll->slave.window_widening_prepare_us = 0;
   22d98:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
		data_chan_use = lll_chan_sel_1(&lll->data_chan_use,
   22d9c:	4606      	mov	r6, r0

	/* Start setting up Radio h/w */
	radio_reset();
   22d9e:	f001 fd97 	bl	248d0 <radio_reset>
	/* TODO: other Tx Power settings */
	radio_tx_power_set(RADIO_TXP_DEFAULT);
   22da2:	2008      	movs	r0, #8
   22da4:	f001 fde8 	bl	24978 <radio_tx_power_set>

	lll_conn_rx_pkt_set(lll);
   22da8:	4620      	mov	r0, r4
   22daa:	f7ff fcfb 	bl	227a4 <lll_conn_rx_pkt_set>

	radio_aa_set(lll->access_addr);
   22dae:	f104 0008 	add.w	r0, r4, #8
   22db2:	f001 fdff 	bl	249b4 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
			    (((u32_t)lll->crc_init[2] << 16) |
			     ((u32_t)lll->crc_init[1] << 8) |
   22db6:	7b63      	ldrb	r3, [r4, #13]
			    (((u32_t)lll->crc_init[2] << 16) |
   22db8:	7ba1      	ldrb	r1, [r4, #14]
			     ((u32_t)lll->crc_init[1] << 8) |
   22dba:	021b      	lsls	r3, r3, #8
			    (((u32_t)lll->crc_init[2] << 16) |
   22dbc:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
			     ((u32_t)lll->crc_init[0])));
   22dc0:	7b21      	ldrb	r1, [r4, #12]
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
   22dc2:	f240 605b 	movw	r0, #1627	; 0x65b
   22dc6:	4319      	orrs	r1, r3
   22dc8:	f001 fe88 	bl	24adc <radio_crc_configure>

	lll_chan_set(data_chan_use);
   22dcc:	4630      	mov	r0, r6
   22dce:	f7fc f81f 	bl	1ee10 <lll_chan_set>

	radio_isr_set(lll_conn_isr_rx, lll);
   22dd2:	4621      	mov	r1, r4
   22dd4:	4839      	ldr	r0, [pc, #228]	; (22ebc <prepare_cb+0x1a4>)
   22dd6:	f001 fd5b 	bl	24890 <radio_isr_set>

	radio_tmr_tifs_set(EVENT_IFS_US);
   22dda:	2096      	movs	r0, #150	; 0x96
   22ddc:	f001 ff3e 	bl	24c5c <radio_tmr_tifs_set>

#if defined(CONFIG_BT_CTLR_PHY)
	radio_switch_complete_and_tx(lll->phy_rx, 0, lll->phy_tx,
				     lll->phy_flags);
   22de0:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
	radio_switch_complete_and_tx(lll->phy_rx, 0, lll->phy_tx,
   22de4:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
   22de8:	f3c2 03c0 	ubfx	r3, r2, #3, #1
   22dec:	4641      	mov	r1, r8
   22dee:	f002 0207 	and.w	r2, r2, #7
   22df2:	f000 0007 	and.w	r0, r0, #7
   22df6:	f001 fe9b 	bl	24b30 <radio_switch_complete_and_tx>
#else /* !CONFIG_BT_CTLR_PHY */
	radio_switch_complete_and_tx(0, 0, 0, 0);
#endif /* !CONFIG_BT_CTLR_PHY */

	ticks_at_event = prepare_param->ticks_at_expire;
	evt = HDR_LLL2EVT(lll);
   22dfa:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
   22dfc:	682e      	ldr	r6, [r5, #0]
	ticks_at_event += lll_evt_offset_get(evt);
   22dfe:	4638      	mov	r0, r7
   22e00:	f009 f845 	bl	2be8e <lll_evt_offset_get>
   22e04:	4406      	add	r6, r0

	ticks_at_start = ticks_at_event;
	ticks_at_start += HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US);

	remainder = prepare_param->remainder;
	remainder_us = radio_tmr_start(0, ticks_at_start, remainder);
   22e06:	686a      	ldr	r2, [r5, #4]
   22e08:	f106 0109 	add.w	r1, r6, #9
   22e0c:	4640      	mov	r0, r8
   22e0e:	f001 ff31 	bl	24c74 <radio_tmr_start>
   22e12:	4681      	mov	r9, r0

	radio_tmr_aa_capture();
   22e14:	f001 ffce 	bl	24db4 <radio_tmr_aa_capture>
	radio_tmr_aa_save(0);
   22e18:	4640      	mov	r0, r8
   22e1a:	f001 ffe5 	bl	24de8 <radio_tmr_aa_save>

	hcto = remainder_us + EVENT_JITTER_US + (EVENT_JITTER_US << 2) +
   22e1e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	       (lll->slave.window_widening_event_us << 1) +
   22e20:	6b60      	ldr	r0, [r4, #52]	; 0x34
	hcto = remainder_us + EVENT_JITTER_US + (EVENT_JITTER_US << 2) +
   22e22:	f103 0550 	add.w	r5, r3, #80	; 0x50
   22e26:	eb05 0540 	add.w	r5, r5, r0, lsl #1
	       lll->slave.window_size_event_us;

#if defined(CONFIG_BT_CTLR_PHY)
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
   22e2a:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
   22e2e:	2101      	movs	r1, #1
   22e30:	f000 0007 	and.w	r0, r0, #7
   22e34:	f009 fe3e 	bl	2cab4 <radio_rx_ready_delay_get>
	hcto = remainder_us + EVENT_JITTER_US + (EVENT_JITTER_US << 2) +
   22e38:	444d      	add	r5, r9
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
   22e3a:	4405      	add	r5, r0
	hcto += addr_us_get(lll->phy_rx);
   22e3c:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
   22e40:	f000 0007 	and.w	r0, r0, #7
	switch (phy) {
   22e44:	2802      	cmp	r0, #2
   22e46:	d028      	beq.n	22e9a <prepare_cb+0x182>
		return 40;
   22e48:	2804      	cmp	r0, #4
   22e4a:	bf0c      	ite	eq
   22e4c:	f44f 73bc 	moveq.w	r3, #376	; 0x178
   22e50:	2328      	movne	r3, #40	; 0x28
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
   22e52:	2101      	movs	r1, #1
	hcto += addr_us_get(lll->phy_rx);
   22e54:	441d      	add	r5, r3
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
   22e56:	f009 fe2f 	bl	2cab8 <radio_rx_chain_delay_get>
	hcto += radio_rx_ready_delay_get(0, 0);
	hcto += addr_us_get(0);
	hcto += radio_rx_chain_delay_get(0, 0);
#endif /* !CONFIG_BT_CTLR_PHY */

	radio_tmr_hcto_configure(hcto);
   22e5a:	4428      	add	r0, r5
   22e5c:	f001 ff9e 	bl	24d9c <radio_tmr_hcto_configure>
#endif /* CONFIG_BT_CTLR_CONN_RSSI */

#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED) && \
	(EVENT_OVERHEAD_PREEMPT_US <= EVENT_OVERHEAD_PREEMPT_MIN_US)
	/* check if preempt to start has changed */
	if (lll_preempt_calc(evt, (TICKER_ID_CONN_BASE + lll->handle),
   22e60:	7c21      	ldrb	r1, [r4, #16]
   22e62:	3105      	adds	r1, #5
   22e64:	4632      	mov	r2, r6
   22e66:	b2c9      	uxtb	r1, r1
   22e68:	4638      	mov	r0, r7
   22e6a:	f009 f81e 	bl	2beaa <lll_preempt_calc>
   22e6e:	b1b0      	cbz	r0, 22e9e <prepare_cb+0x186>
			     ticks_at_event)) {
		radio_isr_set(lll_conn_isr_abort, lll);
   22e70:	4621      	mov	r1, r4
   22e72:	4813      	ldr	r0, [pc, #76]	; (22ec0 <prepare_cb+0x1a8>)
   22e74:	f001 fd0c 	bl	24890 <radio_isr_set>
		radio_disable();
   22e78:	f001 fdfe 	bl	24a78 <radio_disable>
	}

	DEBUG_RADIO_START_S(1);

	return 0;
}
   22e7c:	2000      	movs	r0, #0
   22e7e:	b003      	add	sp, #12
   22e80:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		data_chan_use = lll_chan_sel_1(&lll->data_chan_use,
   22e84:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   22e88:	f894 1022 	ldrb.w	r1, [r4, #34]	; 0x22
   22e8c:	9300      	str	r3, [sp, #0]
   22e8e:	f104 0023 	add.w	r0, r4, #35	; 0x23
   22e92:	4633      	mov	r3, r6
   22e94:	f008 ffb6 	bl	2be04 <lll_chan_sel_1>
   22e98:	e76f      	b.n	22d7a <prepare_cb+0x62>
		return 24;
   22e9a:	2318      	movs	r3, #24
   22e9c:	e7d9      	b.n	22e52 <prepare_cb+0x13a>
		ret = lll_prepare_done(lll);
   22e9e:	4620      	mov	r0, r4
   22ea0:	f008 fff3 	bl	2be8a <lll_prepare_done>
		LL_ASSERT(!ret);
   22ea4:	2800      	cmp	r0, #0
   22ea6:	d0e9      	beq.n	22e7c <prepare_cb+0x164>
   22ea8:	4806      	ldr	r0, [pc, #24]	; (22ec4 <prepare_cb+0x1ac>)
   22eaa:	f005 f94b 	bl	28144 <printk>
   22eae:	4040      	eors	r0, r0
   22eb0:	f380 8811 	msr	BASEPRI, r0
   22eb4:	f04f 0003 	mov.w	r0, #3
   22eb8:	df02      	svc	2
   22eba:	e7df      	b.n	22e7c <prepare_cb+0x164>
   22ebc:	000228c5 	.word	0x000228c5
   22ec0:	0002c739 	.word	0x0002c739
   22ec4:	0003166e 	.word	0x0003166e

00022ec8 <lll_slave_prepare>:
{
   22ec8:	b513      	push	{r0, r1, r4, lr}
   22eca:	4604      	mov	r4, r0
	err = lll_clk_on();
   22ecc:	f7fb ff92 	bl	1edf4 <lll_clk_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
   22ed0:	b150      	cbz	r0, 22ee8 <lll_slave_prepare+0x20>
   22ed2:	3044      	adds	r0, #68	; 0x44
   22ed4:	d008      	beq.n	22ee8 <lll_slave_prepare+0x20>
   22ed6:	480f      	ldr	r0, [pc, #60]	; (22f14 <lll_slave_prepare+0x4c>)
   22ed8:	f005 f934 	bl	28144 <printk>
   22edc:	4040      	eors	r0, r0
   22ede:	f380 8811 	msr	BASEPRI, r0
   22ee2:	f04f 0003 	mov.w	r0, #3
   22ee6:	df02      	svc	2
	err = lll_prepare(lll_conn_is_abort_cb, lll_conn_abort_cb, prepare_cb,
   22ee8:	9400      	str	r4, [sp, #0]
   22eea:	2300      	movs	r3, #0
   22eec:	4a0a      	ldr	r2, [pc, #40]	; (22f18 <lll_slave_prepare+0x50>)
   22eee:	490b      	ldr	r1, [pc, #44]	; (22f1c <lll_slave_prepare+0x54>)
   22ef0:	480b      	ldr	r0, [pc, #44]	; (22f20 <lll_slave_prepare+0x58>)
   22ef2:	f008 ffc1 	bl	2be78 <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
   22ef6:	b150      	cbz	r0, 22f0e <lll_slave_prepare+0x46>
   22ef8:	3044      	adds	r0, #68	; 0x44
   22efa:	d008      	beq.n	22f0e <lll_slave_prepare+0x46>
   22efc:	4805      	ldr	r0, [pc, #20]	; (22f14 <lll_slave_prepare+0x4c>)
   22efe:	f005 f921 	bl	28144 <printk>
   22f02:	4040      	eors	r0, r0
   22f04:	f380 8811 	msr	BASEPRI, r0
   22f08:	f04f 0003 	mov.w	r0, #3
   22f0c:	df02      	svc	2
}
   22f0e:	b002      	add	sp, #8
   22f10:	bd10      	pop	{r4, pc}
   22f12:	bf00      	nop
   22f14:	00031b18 	.word	0x00031b18
   22f18:	00022d19 	.word	0x00022d19
   22f1c:	00022761 	.word	0x00022761
   22f20:	0002c733 	.word	0x0002c733

00022f24 <ticker_op_cb>:
{
	/* TODO: */
}

static void ticker_op_cb(u32_t status, void *params)
{
   22f24:	b508      	push	{r3, lr}
	ARG_UNUSED(params);

	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
   22f26:	b140      	cbz	r0, 22f3a <ticker_op_cb+0x16>
   22f28:	4804      	ldr	r0, [pc, #16]	; (22f3c <ticker_op_cb+0x18>)
   22f2a:	f005 f90b 	bl	28144 <printk>
   22f2e:	4040      	eors	r0, r0
   22f30:	f380 8811 	msr	BASEPRI, r0
   22f34:	f04f 0003 	mov.w	r0, #3
   22f38:	df02      	svc	2
}
   22f3a:	bd08      	pop	{r3, pc}
   22f3c:	00031bf1 	.word	0x00031bf1

00022f40 <ull_master_ticker_cb>:
{
   22f40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   22f42:	4605      	mov	r5, r0
   22f44:	460f      	mov	r7, r1
	ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
   22f46:	4601      	mov	r1, r0
   22f48:	4618      	mov	r0, r3
{
   22f4a:	4616      	mov	r6, r2
   22f4c:	461c      	mov	r4, r3
	ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
   22f4e:	f7ea f92b 	bl	d1a8 <ull_conn_llcp>
	if (ret) {
   22f52:	2800      	cmp	r0, #0
   22f54:	d135      	bne.n	22fc2 <ull_master_ticker_cb+0x82>
   22f56:	7c23      	ldrb	r3, [r4, #16]
   22f58:	3301      	adds	r3, #1
   22f5a:	b2db      	uxtb	r3, r3
   22f5c:	7423      	strb	r3, [r4, #16]
	LL_ASSERT(ref);
   22f5e:	b943      	cbnz	r3, 22f72 <ull_master_ticker_cb+0x32>
   22f60:	4818      	ldr	r0, [pc, #96]	; (22fc4 <ull_master_ticker_cb+0x84>)
   22f62:	f005 f8ef 	bl	28144 <printk>
   22f66:	4040      	eors	r0, r0
   22f68:	f380 8811 	msr	BASEPRI, r0
   22f6c:	f04f 0003 	mov.w	r0, #3
   22f70:	df02      	svc	2
	ull_conn_tx_demux(1);
   22f72:	2001      	movs	r0, #1
   22f74:	f7fe feec 	bl	21d50 <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(conn, 1);
   22f78:	2101      	movs	r1, #1
   22f7a:	4620      	mov	r0, r4
   22f7c:	f7ff f8d4 	bl	22128 <ull_conn_tx_lll_enqueue>
	p.ticks_at_expire = ticks_at_expire;
   22f80:	4a11      	ldr	r2, [pc, #68]	; (22fc8 <ull_master_ticker_cb+0x88>)
	p.param = &conn->lll;
   22f82:	f104 031c 	add.w	r3, r4, #28
   22f86:	60d3      	str	r3, [r2, #12]
	mfy.param = &p;
   22f88:	4b10      	ldr	r3, [pc, #64]	; (22fcc <ull_master_ticker_cb+0x8c>)
	p.lazy = lazy;
   22f8a:	8116      	strh	r6, [r2, #8]
	p.remainder = remainder;
   22f8c:	e9c2 5700 	strd	r5, r7, [r2]
	mfy.param = &p;
   22f90:	609a      	str	r2, [r3, #8]
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
   22f92:	2200      	movs	r2, #0
   22f94:	4611      	mov	r1, r2
   22f96:	2001      	movs	r0, #1
   22f98:	f7f8 fc1c 	bl	1b7d4 <mayfly_enqueue>
	LL_ASSERT(!err);
   22f9c:	b140      	cbz	r0, 22fb0 <ull_master_ticker_cb+0x70>
   22f9e:	480c      	ldr	r0, [pc, #48]	; (22fd0 <ull_master_ticker_cb+0x90>)
   22fa0:	f005 f8d0 	bl	28144 <printk>
   22fa4:	4040      	eors	r0, r0
   22fa6:	f380 8811 	msr	BASEPRI, r0
   22faa:	f04f 0003 	mov.w	r0, #3
   22fae:	df02      	svc	2
	ull_conn_tx_demux(UINT8_MAX);
   22fb0:	20ff      	movs	r0, #255	; 0xff
   22fb2:	f7fe fecd 	bl	21d50 <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
   22fb6:	4620      	mov	r0, r4
   22fb8:	21ff      	movs	r1, #255	; 0xff
}
   22fba:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
   22fbe:	f7ff b8b3 	b.w	22128 <ull_conn_tx_lll_enqueue>
}
   22fc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   22fc4:	00031a3e 	.word	0x00031a3e
   22fc8:	200035ac 	.word	0x200035ac
   22fcc:	2000fd80 	.word	0x2000fd80
   22fd0:	000317e5 	.word	0x000317e5

00022fd4 <ll_create_connection>:
{
   22fd4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   22fd8:	b08b      	sub	sp, #44	; 0x2c
   22fda:	4681      	mov	r9, r0
   22fdc:	9304      	str	r3, [sp, #16]
   22fde:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
   22fe2:	9305      	str	r3, [sp, #20]
	scan = ull_scan_is_disabled_get(0);
   22fe4:	2000      	movs	r0, #0
{
   22fe6:	f8bd 3060 	ldrh.w	r3, [sp, #96]	; 0x60
   22fea:	f89d 8054 	ldrb.w	r8, [sp, #84]	; 0x54
   22fee:	9306      	str	r3, [sp, #24]
   22ff0:	468a      	mov	sl, r1
   22ff2:	4617      	mov	r7, r2
	scan = ull_scan_is_disabled_get(0);
   22ff4:	f7fc fe6a 	bl	1fccc <ull_scan_is_disabled_get>
	if (!scan) {
   22ff8:	4606      	mov	r6, r0
   22ffa:	2800      	cmp	r0, #0
   22ffc:	f000 80bb 	beq.w	23176 <ll_create_connection+0x1a2>
	if (lll->conn) {
   23000:	6a45      	ldr	r5, [r0, #36]	; 0x24
   23002:	2d00      	cmp	r5, #0
   23004:	f040 80b7 	bne.w	23176 <ll_create_connection+0x1a2>
	link = ll_rx_link_alloc();
   23008:	f7fb f8f2 	bl	1e1f0 <ll_rx_link_alloc>
	if (!link) {
   2300c:	9002      	str	r0, [sp, #8]
   2300e:	b130      	cbz	r0, 2301e <ll_create_connection+0x4a>
	conn = ll_conn_acquire();
   23010:	f7fd faaa 	bl	20568 <ll_conn_acquire>
	if (!conn) {
   23014:	4604      	mov	r4, r0
   23016:	b920      	cbnz	r0, 23022 <ll_create_connection+0x4e>
		ll_rx_link_release(link);
   23018:	9802      	ldr	r0, [sp, #8]
   2301a:	f7fb f8ef 	bl	1e1fc <ll_rx_link_release>
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
   2301e:	2007      	movs	r0, #7
   23020:	e222      	b.n	23468 <ll_create_connection+0x494>
	ull_scan_params_set(lll, 0, scan_interval, scan_window, filter_policy);
   23022:	4653      	mov	r3, sl
   23024:	464a      	mov	r2, r9
   23026:	4629      	mov	r1, r5
   23028:	f106 001c 	add.w	r0, r6, #28
   2302c:	9700      	str	r7, [sp, #0]
   2302e:	f7e9 fd0b 	bl	ca48 <ull_scan_params_set>
	lll->adv_addr_type = peer_addr_type;
   23032:	f896 3032 	ldrb.w	r3, [r6, #50]	; 0x32
   23036:	9a04      	ldr	r2, [sp, #16]
	memcpy(lll->adv_addr, peer_addr, BDADDR_SIZE);
   23038:	9914      	ldr	r1, [sp, #80]	; 0x50
	lll->adv_addr_type = peer_addr_type;
   2303a:	f362 1345 	bfi	r3, r2, #5, #1
   2303e:	f886 3032 	strb.w	r3, [r6, #50]	; 0x32
	memcpy(lll->adv_addr, peer_addr, BDADDR_SIZE);
   23042:	2206      	movs	r2, #6
   23044:	f106 003b 	add.w	r0, r6, #59	; 0x3b
   23048:	f007 fa01 	bl	2a44e <memcpy>
	lll->conn_timeout = timeout;
   2304c:	9b06      	ldr	r3, [sp, #24]
   2304e:	8633      	strh	r3, [r6, #48]	; 0x30
	conn_lll = &conn->lll;
   23050:	f104 031c 	add.w	r3, r4, #28
   23054:	9307      	str	r3, [sp, #28]
	u32_t aa;
	u8_t transitions;
	u8_t bit_idx;
	u8_t retry;

	retry = 3U;
   23056:	2303      	movs	r3, #3
	lll->conn_ticks_slot = 0; /* TODO: */
   23058:	62b5      	str	r5, [r6, #40]	; 0x28
	retry = 3U;
   2305a:	9303      	str	r3, [sp, #12]
again:
	LL_ASSERT(retry);
	retry--;
   2305c:	9b03      	ldr	r3, [sp, #12]
   2305e:	3b01      	subs	r3, #1
   23060:	b2db      	uxtb	r3, r3

	bt_rand(access_addr, 4);
   23062:	2104      	movs	r1, #4
   23064:	a808      	add	r0, sp, #32
	retry--;
   23066:	9303      	str	r3, [sp, #12]
	bt_rand(access_addr, 4);
   23068:	f7fa fd04 	bl	1da74 <bt_rand>
	return ((u16_t)src[1] << 8) | src[0];
   2306c:	f89d 5022 	ldrb.w	r5, [sp, #34]	; 0x22
   23070:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
   23074:	f89d 2021 	ldrb.w	r2, [sp, #33]	; 0x21
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
   23078:	ea45 2303 	orr.w	r3, r5, r3, lsl #8
	return ((u16_t)src[1] << 8) | src[0];
   2307c:	f89d 5020 	ldrb.w	r5, [sp, #32]
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
   23080:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
   23084:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
	aa = sys_get_le32(access_addr);

	bit_idx = 31U;
	transitions = 0U;
   23088:	f04f 0e00 	mov.w	lr, #0
	consecutive_cnt = 1U;
#if defined(CONFIG_BT_CTLR_PHY_CODED)
	ones_count_lsb8 = 0U;
	transitions_lsb16 = 0U;
#endif /* CONFIG_BT_CTLR_PHY_CODED */
	consecutive_bit = (aa >> bit_idx) & 0x01;
   2308c:	ea4f 79d5 	mov.w	r9, r5, lsr #31
	bit_idx = 31U;
   23090:	231f      	movs	r3, #31
	consecutive_cnt = 1U;
   23092:	f04f 0b01 	mov.w	fp, #1
	ones_count_lsb8 = 0U;
   23096:	4671      	mov	r1, lr
	transitions_lsb16 = 0U;
   23098:	46f2      	mov	sl, lr
	while (bit_idx--) {
   2309a:	3b01      	subs	r3, #1
   2309c:	b2db      	uxtb	r3, r3
   2309e:	2bff      	cmp	r3, #255	; 0xff
   230a0:	f000 80a6 	beq.w	231f0 <ll_create_connection+0x21c>
#endif /* CONFIG_BT_CTLR_PHY_CODED */
		u8_t consecutive_cnt_prev = consecutive_cnt;
		u8_t transitions_prev = transitions;
		u8_t bit;

		bit = (aa >> bit_idx) & 0x01;
   230a4:	fa25 f003 	lsr.w	r0, r5, r3
   230a8:	f000 0001 	and.w	r0, r0, #1
		if (bit == consecutive_bit) {
   230ac:	4548      	cmp	r0, r9
   230ae:	d11d      	bne.n	230ec <ll_create_connection+0x118>
			consecutive_cnt++;
   230b0:	f10b 0001 	add.w	r0, fp, #1
			}
#endif /* CONFIG_BT_CTLR_PHY_CODED */
		}

#if defined(CONFIG_BT_CTLR_PHY_CODED)
		if ((bit_idx < 8) && consecutive_bit) {
   230b4:	2b07      	cmp	r3, #7
			consecutive_cnt++;
   230b6:	b2c0      	uxtb	r0, r0
		if ((bit_idx < 8) && consecutive_bit) {
   230b8:	d828      	bhi.n	2310c <ll_create_connection+0x138>
   230ba:	46d4      	mov	ip, sl
   230bc:	4672      	mov	r2, lr
   230be:	f1b9 0f00 	cmp.w	r9, #0
   230c2:	d061      	beq.n	23188 <ll_create_connection+0x1b4>
			ones_count_lsb8++;
   230c4:	3101      	adds	r1, #1

		/* It shall have no more than six consecutive zeros or ones. */
		/* It shall have a minimum of two transitions in the most
		 * significant six bits.
		 */
		if ((consecutive_cnt > 6) ||
   230c6:	2806      	cmp	r0, #6
			ones_count_lsb8++;
   230c8:	b2c9      	uxtb	r1, r1
		if ((consecutive_cnt > 6) ||
   230ca:	d831      	bhi.n	23130 <ll_create_connection+0x15c>
		    (!consecutive_bit && (((bit_idx < 6) &&
					   (ones_count_lsb8 < 1)) ||
					  ((bit_idx < 5) &&
					   (ones_count_lsb8 < 2)) ||
					  ((bit_idx < 4) &&
					   (ones_count_lsb8 < 3)))) ||
   230cc:	2806      	cmp	r0, #6
   230ce:	d127      	bne.n	23120 <ll_create_connection+0x14c>
   230d0:	e081      	b.n	231d6 <ll_create_connection+0x202>
	LL_ASSERT(retry);
   230d2:	9b03      	ldr	r3, [sp, #12]
   230d4:	2b00      	cmp	r3, #0
   230d6:	d1c1      	bne.n	2305c <ll_create_connection+0x88>
   230d8:	482a      	ldr	r0, [pc, #168]	; (23184 <ll_create_connection+0x1b0>)
   230da:	f005 f833 	bl	28144 <printk>
   230de:	4040      	eors	r0, r0
   230e0:	f380 8811 	msr	BASEPRI, r0
   230e4:	f04f 0003 	mov.w	r0, #3
   230e8:	df02      	svc	2
   230ea:	e7b7      	b.n	2305c <ll_create_connection+0x88>
			transitions++;
   230ec:	f10e 0201 	add.w	r2, lr, #1
			if (bit_idx < 15) {
   230f0:	2b0e      	cmp	r3, #14
			transitions++;
   230f2:	b2d2      	uxtb	r2, r2
			if (bit_idx < 15) {
   230f4:	f200 81bb 	bhi.w	2346e <ll_create_connection+0x49a>
				transitions_lsb16++;
   230f8:	f10a 0c01 	add.w	ip, sl, #1
   230fc:	fa5f fc8c 	uxtb.w	ip, ip
		if ((bit_idx < 8) && consecutive_bit) {
   23100:	2b07      	cmp	r3, #7
   23102:	4681      	mov	r9, r0
   23104:	f04f 0001 	mov.w	r0, #1
   23108:	d808      	bhi.n	2311c <ll_create_connection+0x148>
   2310a:	e7d8      	b.n	230be <ll_create_connection+0xea>
		if ((consecutive_cnt > 6) ||
   2310c:	2806      	cmp	r0, #6
   2310e:	d821      	bhi.n	23154 <ll_create_connection+0x180>
					   (ones_count_lsb8 < 3)))) ||
   23110:	d02d      	beq.n	2316e <ll_create_connection+0x19a>
   23112:	4672      	mov	r2, lr
   23114:	46d4      	mov	ip, sl
   23116:	e001      	b.n	2311c <ll_create_connection+0x148>
   23118:	2806      	cmp	r0, #6
   2311a:	d05c      	beq.n	231d6 <ll_create_connection+0x202>
#endif /* CONFIG_BT_CTLR_PHY_CODED */
		    ((consecutive_cnt < 6) &&
   2311c:	2b1c      	cmp	r3, #28
   2311e:	d800      	bhi.n	23122 <ll_create_connection+0x14e>
		     (((bit_idx < 29) && (transitions < 1)) ||
   23120:	b11a      	cbz	r2, 2312a <ll_create_connection+0x156>
   23122:	2b1b      	cmp	r3, #27
   23124:	d857      	bhi.n	231d6 <ll_create_connection+0x202>
		      ((bit_idx < 28) && (transitions < 2))))) {
   23126:	2a01      	cmp	r2, #1
   23128:	d855      	bhi.n	231d6 <ll_create_connection+0x202>
			if (consecutive_bit) {
   2312a:	f1b9 0f00 	cmp.w	r9, #0
   2312e:	d038      	beq.n	231a2 <ll_create_connection+0x1ce>
				consecutive_bit = 0U;
				aa &= ~BIT(bit_idx);
   23130:	2001      	movs	r0, #1
   23132:	4098      	lsls	r0, r3
#if defined(CONFIG_BT_CTLR_PHY_CODED)
				if (bit_idx < 8) {
   23134:	2b07      	cmp	r3, #7
				aa &= ~BIT(bit_idx);
   23136:	ea25 0500 	bic.w	r5, r5, r0
				if (bit_idx < 8) {
   2313a:	d801      	bhi.n	23140 <ll_create_connection+0x16c>
					ones_count_lsb8--;
   2313c:	3901      	subs	r1, #1
   2313e:	b2c9      	uxtb	r1, r1
				consecutive_bit = 0U;
   23140:	f04f 0900 	mov.w	r9, #0
					ones_count_lsb8++;
				}
#endif /* CONFIG_BT_CTLR_PHY_CODED */
			}

			if (transitions != transitions_prev) {
   23144:	4596      	cmp	lr, r2
   23146:	d039      	beq.n	231bc <ll_create_connection+0x1e8>
				consecutive_cnt = 1U;
				transitions++;
			}

#if defined(CONFIG_BT_CTLR_PHY_CODED)
			if (bit_idx < 15) {
   23148:	2b0e      	cmp	r3, #14
   2314a:	f240 8192 	bls.w	23472 <ll_create_connection+0x49e>
   2314e:	4658      	mov	r0, fp
   23150:	4672      	mov	r2, lr
   23152:	e042      	b.n	231da <ll_create_connection+0x206>
		if ((consecutive_cnt > 6) ||
   23154:	46d4      	mov	ip, sl
   23156:	4672      	mov	r2, lr
   23158:	e7e7      	b.n	2312a <ll_create_connection+0x156>
				consecutive_bit = 1U;
   2315a:	f04f 0901 	mov.w	r9, #1
   2315e:	e7f1      	b.n	23144 <ll_create_connection+0x170>
				consecutive_cnt = 1U;
   23160:	2001      	movs	r0, #1
   23162:	e038      	b.n	231d6 <ll_create_connection+0x202>
#endif /* CONFIG_BT_CTLR_PHY_CODED */
		    0) {
			if (consecutive_bit) {
				aa &= ~(BIT(bit_idx + 1) - 1);
			} else {
				aa |= (BIT(bit_idx + 1) - 1);
   23164:	3b01      	subs	r3, #1
   23166:	431d      	orrs	r5, r3
   23168:	e042      	b.n	231f0 <ll_create_connection+0x21c>
		    (transitions_lsb16 > 11) ||
   2316a:	4696      	mov	lr, r2
   2316c:	46e2      	mov	sl, ip
				if (transitions_lsb16 !=
   2316e:	4683      	mov	fp, r0
   23170:	e793      	b.n	2309a <ll_create_connection+0xc6>
   23172:	4658      	mov	r0, fp
   23174:	e7fb      	b.n	2316e <ll_create_connection+0x19a>
		return BT_HCI_ERR_CMD_DISALLOWED;
   23176:	200c      	movs	r0, #12
   23178:	e176      	b.n	23468 <ll_create_connection+0x494>
		if ((transitions > 24) ||
   2317a:	2a19      	cmp	r2, #25
   2317c:	d030      	beq.n	231e0 <ll_create_connection+0x20c>
				transitions++;
   2317e:	4696      	mov	lr, r2
				consecutive_cnt = 1U;
   23180:	2001      	movs	r0, #1
   23182:	e7f4      	b.n	2316e <ll_create_connection+0x19a>
   23184:	00032045 	.word	0x00032045
		if ((consecutive_cnt > 6) ||
   23188:	2806      	cmp	r0, #6
   2318a:	d80a      	bhi.n	231a2 <ll_create_connection+0x1ce>
		    (!consecutive_bit && (((bit_idx < 6) &&
   2318c:	2b05      	cmp	r3, #5
   2318e:	d800      	bhi.n	23192 <ll_create_connection+0x1be>
   23190:	b139      	cbz	r1, 231a2 <ll_create_connection+0x1ce>
					   (ones_count_lsb8 < 1)) ||
   23192:	2b04      	cmp	r3, #4
   23194:	d801      	bhi.n	2319a <ll_create_connection+0x1c6>
					  ((bit_idx < 5) &&
   23196:	2901      	cmp	r1, #1
   23198:	d903      	bls.n	231a2 <ll_create_connection+0x1ce>
					   (ones_count_lsb8 < 2)) ||
   2319a:	2b03      	cmp	r3, #3
   2319c:	d8bc      	bhi.n	23118 <ll_create_connection+0x144>
					  ((bit_idx < 4) &&
   2319e:	2902      	cmp	r1, #2
   231a0:	d894      	bhi.n	230cc <ll_create_connection+0xf8>
				aa |= BIT(bit_idx);
   231a2:	2001      	movs	r0, #1
   231a4:	4098      	lsls	r0, r3
				if (bit_idx < 8) {
   231a6:	2b07      	cmp	r3, #7
				aa |= BIT(bit_idx);
   231a8:	ea45 0500 	orr.w	r5, r5, r0
				if (bit_idx < 8) {
   231ac:	d8d5      	bhi.n	2315a <ll_create_connection+0x186>
					ones_count_lsb8++;
   231ae:	3101      	adds	r1, #1
			if (transitions != transitions_prev) {
   231b0:	4596      	cmp	lr, r2
					ones_count_lsb8++;
   231b2:	b2c9      	uxtb	r1, r1
				consecutive_bit = 1U;
   231b4:	f04f 0901 	mov.w	r9, #1
			if (transitions != transitions_prev) {
   231b8:	f040 815b 	bne.w	23472 <ll_create_connection+0x49e>
				transitions++;
   231bc:	3201      	adds	r2, #1
			if (bit_idx < 15) {
   231be:	2b0e      	cmp	r3, #14
				transitions++;
   231c0:	b2d2      	uxtb	r2, r2
			if (bit_idx < 15) {
   231c2:	d8cd      	bhi.n	23160 <ll_create_connection+0x18c>
				if (transitions_lsb16 !=
   231c4:	45e2      	cmp	sl, ip
   231c6:	d1d8      	bne.n	2317a <ll_create_connection+0x1a6>
				consecutive_cnt = 1U;
   231c8:	f04f 0b01 	mov.w	fp, #1
					transitions_lsb16++;
   231cc:	f10c 0c01 	add.w	ip, ip, #1
   231d0:	fa5f fc8c 	uxtb.w	ip, ip
   231d4:	4658      	mov	r0, fp
		if ((transitions > 24) ||
   231d6:	2a19      	cmp	r2, #25
   231d8:	d002      	beq.n	231e0 <ll_create_connection+0x20c>
		    (transitions_lsb16 > 11) ||
   231da:	f1bc 0f0c 	cmp.w	ip, #12
   231de:	d1c4      	bne.n	2316a <ll_create_connection+0x196>
			if (consecutive_bit) {
   231e0:	1c5a      	adds	r2, r3, #1
   231e2:	2301      	movs	r3, #1
   231e4:	4093      	lsls	r3, r2
   231e6:	f1b9 0f00 	cmp.w	r9, #0
   231ea:	d0bb      	beq.n	23164 <ll_create_connection+0x190>
				aa &= ~(BIT(bit_idx + 1) - 1);
   231ec:	425b      	negs	r3, r3
   231ee:	401d      	ands	r5, r3

	/* It shall not be the advertising channel packets Access Address.
	 * It shall not be a sequence that differs from the advertising channel
	 * packets Access Address by only one bit.
	 */
	adv_aa_check = aa ^ 0x8e89bed6;
   231f0:	4ba2      	ldr	r3, [pc, #648]	; (2347c <ll_create_connection+0x4a8>)
	if (util_ones_count_get((u8_t *)&adv_aa_check,
   231f2:	2104      	movs	r1, #4
	adv_aa_check = aa ^ 0x8e89bed6;
   231f4:	406b      	eors	r3, r5
	if (util_ones_count_get((u8_t *)&adv_aa_check,
   231f6:	a809      	add	r0, sp, #36	; 0x24
	adv_aa_check = aa ^ 0x8e89bed6;
   231f8:	9309      	str	r3, [sp, #36]	; 0x24
	if (util_ones_count_get((u8_t *)&adv_aa_check,
   231fa:	f008 fc15 	bl	2ba28 <util_ones_count_get>
   231fe:	2801      	cmp	r0, #1
   23200:	f67f af67 	bls.w	230d2 <ll_create_connection+0xfe>
				sizeof(adv_aa_check)) <= 1) {
		goto again;
	}

	/* It shall not have all four octets equal. */
	if (!((aa & 0xFFFF) ^ (aa >> 16)) &&
   23204:	b2ab      	uxth	r3, r5
   23206:	ebb3 4f15 	cmp.w	r3, r5, lsr #16
   2320a:	d104      	bne.n	23216 <ll_create_connection+0x242>
	    !((aa & 0xFF) ^ (aa >> 24))) {
   2320c:	b2eb      	uxtb	r3, r5
	if (!((aa & 0xFFFF) ^ (aa >> 16)) &&
   2320e:	ebb3 6f15 	cmp.w	r3, r5, lsr #24
   23212:	f43f af5e 	beq.w	230d2 <ll_create_connection+0xfe>
	memcpy(conn_lll->access_addr, &access_addr,
   23216:	2204      	movs	r2, #4
   23218:	a908      	add	r1, sp, #32
   2321a:	f104 0024 	add.w	r0, r4, #36	; 0x24
	dst[0] = val;
   2321e:	9508      	str	r5, [sp, #32]
   23220:	f007 f915 	bl	2a44e <memcpy>
	bt_rand(&conn_lll->crc_init[0], 3);
   23224:	2103      	movs	r1, #3
   23226:	f104 0028 	add.w	r0, r4, #40	; 0x28
   2322a:	f7fa fc23 	bl	1da74 <bt_rand>
	conn_lll->handle = 0xFFFF;
   2322e:	f64f 73ff 	movw	r3, #65535	; 0xffff
   23232:	85a3      	strh	r3, [r4, #44]	; 0x2c
	conn_lll->interval = interval;
   23234:	9b05      	ldr	r3, [sp, #20]
   23236:	85e3      	strh	r3, [r4, #46]	; 0x2e
	conn_lll->latency = latency;
   23238:	f8bd 305c 	ldrh.w	r3, [sp, #92]	; 0x5c
   2323c:	8623      	strh	r3, [r4, #48]	; 0x30
	if (!conn_lll->link_tx_free) {
   2323e:	6fa3      	ldr	r3, [r4, #120]	; 0x78
   23240:	b913      	cbnz	r3, 23248 <ll_create_connection+0x274>
		conn_lll->link_tx_free = &conn_lll->link_tx;
   23242:	f104 0370 	add.w	r3, r4, #112	; 0x70
   23246:	67a3      	str	r3, [r4, #120]	; 0x78
	memq_init(conn_lll->link_tx_free, &conn_lll->memq_tx.head,
   23248:	f104 0168 	add.w	r1, r4, #104	; 0x68
   2324c:	f104 026c 	add.w	r2, r4, #108	; 0x6c
   23250:	6fa0      	ldr	r0, [r4, #120]	; 0x78
   23252:	f008 fbbd 	bl	2b9d0 <memq_init>
	conn_lll->sn = 0;
   23256:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
   2325a:	f023 0307 	bic.w	r3, r3, #7
   2325e:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
	conn_lll->max_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0);
   23262:	4b87      	ldr	r3, [pc, #540]	; (23480 <ll_create_connection+0x4ac>)
   23264:	f04f 121b 	mov.w	r2, #1769499	; 0x1b001b
   23268:	e9c4 2317 	strd	r2, r3, [r4, #92]	; 0x5c
	conn_lll->phy_tx = BIT(0);
   2326c:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
   23270:	f423 63ef 	bic.w	r3, r3, #1912	; 0x778
   23274:	f023 0307 	bic.w	r3, r3, #7
   23278:	f443 7388 	orr.w	r3, r3, #272	; 0x110
	conn_lll->link_tx_free = NULL;
   2327c:	2500      	movs	r5, #0
	conn_lll->phy_tx = BIT(0);
   2327e:	f043 0301 	orr.w	r3, r3, #1
	conn_lll->link_tx_free = NULL;
   23282:	67a5      	str	r5, [r4, #120]	; 0x78
	conn_lll->packet_tx_head_len = 0;
   23284:	f8a4 507c 	strh.w	r5, [r4, #124]	; 0x7c
	conn_lll->phy_tx = BIT(0);
   23288:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
	conn_lll->latency_prepare = 0;
   2328c:	8665      	strh	r5, [r4, #50]	; 0x32
	conn_lll->latency_event = 0;
   2328e:	6365      	str	r5, [r4, #52]	; 0x34
		ull_conn_chan_map_cpy(conn_lll->data_chan_map);
   23290:	f104 0038 	add.w	r0, r4, #56	; 0x38
   23294:	f7fd fa8e 	bl	207b4 <ull_conn_chan_map_cpy>
	conn_lll->data_chan_count =
   23298:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
   2329c:	f360 0305 	bfi	r3, r0, #0, #6
   232a0:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
	bt_rand(&hop, sizeof(u8_t));
   232a4:	2101      	movs	r1, #1
   232a6:	a809      	add	r0, sp, #36	; 0x24
   232a8:	f7fa fbe4 	bl	1da74 <bt_rand>
	conn_lll->data_chan_hop = 5 + (hop % 12);
   232ac:	f89d 1024 	ldrb.w	r1, [sp, #36]	; 0x24
	conn->supervision_reload = RADIO_CONN_EVENTS(timeout * 10000U,
   232b0:	9806      	ldr	r0, [sp, #24]
	conn_lll->data_chan_use = 0;
   232b2:	f884 503f 	strb.w	r5, [r4, #63]	; 0x3f
	conn_lll->data_chan_hop = 5 + (hop % 12);
   232b6:	220c      	movs	r2, #12
   232b8:	fbb1 f3f2 	udiv	r3, r1, r2
   232bc:	fb02 1313 	mls	r3, r2, r3, r1
   232c0:	3305      	adds	r3, #5
   232c2:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
	conn_lll->data_chan_sel = 0;
   232c6:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
	conn->supervision_expire = 0U;
   232ca:	f8a4 50c8 	strh.w	r5, [r4, #200]	; 0xc8
	conn_lll->data_chan_sel = 0;
   232ce:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   232d2:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
	conn->connect_expire = 6U;
   232d6:	2306      	movs	r3, #6
   232d8:	f8a4 30c4 	strh.w	r3, [r4, #196]	; 0xc4
	conn_interval_us = (u32_t)interval * 1250U;
   232dc:	9b05      	ldr	r3, [sp, #20]
	conn->procedure_expire = 0U;
   232de:	f8a4 50cc 	strh.w	r5, [r4, #204]	; 0xcc
	conn_interval_us = (u32_t)interval * 1250U;
   232e2:	f240 42e2 	movw	r2, #1250	; 0x4e2
   232e6:	435a      	muls	r2, r3
	conn->supervision_reload = RADIO_CONN_EVENTS(timeout * 10000U,
   232e8:	1e51      	subs	r1, r2, #1
   232ea:	f242 7310 	movw	r3, #10000	; 0x2710
   232ee:	fb03 1300 	mla	r3, r3, r0, r1
   232f2:	fbb3 f3f2 	udiv	r3, r3, r2
   232f6:	f8a4 30c6 	strh.w	r3, [r4, #198]	; 0xc6
	conn->procedure_reload = RADIO_CONN_EVENTS(40000000,
   232fa:	4b62      	ldr	r3, [pc, #392]	; (23484 <ll_create_connection+0x4b0>)
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
   232fc:	8e21      	ldrh	r1, [r4, #48]	; 0x30
	conn->apto_expire = 0U;
   232fe:	f8a4 50d4 	strh.w	r5, [r4, #212]	; 0xd4
	conn->procedure_reload = RADIO_CONN_EVENTS(40000000,
   23302:	4413      	add	r3, r2
   23304:	fbb3 f3f2 	udiv	r3, r3, r2
   23308:	f8a4 30ca 	strh.w	r3, [r4, #202]	; 0xca
	conn->apto_reload = RADIO_CONN_EVENTS((30000000), conn_interval_us);
   2330c:	4b5e      	ldr	r3, [pc, #376]	; (23488 <ll_create_connection+0x4b4>)
	conn->appto_expire = 0U;
   2330e:	f8a4 50d0 	strh.w	r5, [r4, #208]	; 0xd0
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
   23312:	1d88      	adds	r0, r1, #6
	conn->apto_reload = RADIO_CONN_EVENTS((30000000), conn_interval_us);
   23314:	4413      	add	r3, r2
   23316:	fbb3 f2f2 	udiv	r2, r3, r2
   2331a:	b293      	uxth	r3, r2
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
   2331c:	4283      	cmp	r3, r0
	conn->apto_reload = RADIO_CONN_EVENTS((30000000), conn_interval_us);
   2331e:	f8a4 30d2 	strh.w	r3, [r4, #210]	; 0xd2
			     (conn->apto_reload - (conn_lll->latency + 6)) :
   23322:	bfc2      	ittt	gt
   23324:	1a5b      	subgt	r3, r3, r1
   23326:	3b06      	subgt	r3, #6
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
   23328:	b29b      	uxthgt	r3, r3
   2332a:	f8a4 30ce 	strh.w	r3, [r4, #206]	; 0xce
	conn->common.fex_valid = 0U;
   2332e:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
   23332:	f023 0303 	bic.w	r3, r3, #3
   23336:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
	conn->llcp_feature.features = LL_FEAT;
   2333a:	4b54      	ldr	r3, [pc, #336]	; (2348c <ll_create_connection+0x4b8>)
   2333c:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
	conn->llcp_version.tx = conn->llcp_version.rx = 0U;
   23340:	f894 3122 	ldrb.w	r3, [r4, #290]	; 0x122
   23344:	f023 0303 	bic.w	r3, r3, #3
   23348:	f884 3122 	strb.w	r3, [r4, #290]	; 0x122
	conn->llcp_terminate.node_rx.hdr.link = link;
   2334c:	9b02      	ldr	r3, [sp, #8]
   2334e:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
	conn_lll->enc_rx = conn_lll->enc_tx = 0U;
   23352:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
	conn->llcp_req = conn->llcp_ack = conn->llcp_type = 0U;
   23356:	2500      	movs	r5, #0
	conn_lll->enc_rx = conn_lll->enc_tx = 0U;
   23358:	f023 0318 	bic.w	r3, r3, #24
	conn->llcp_req = conn->llcp_ack = conn->llcp_type = 0U;
   2335c:	f8a4 50e8 	strh.w	r5, [r4, #232]	; 0xe8
   23360:	f884 50ea 	strb.w	r5, [r4, #234]	; 0xea
	conn->llcp_rx = NULL;
   23364:	f8c4 5100 	str.w	r5, [r4, #256]	; 0x100
	conn->llcp_cu.req = conn->llcp_cu.ack = 0;
   23368:	f8a4 5104 	strh.w	r5, [r4, #260]	; 0x104
	conn->llcp_feature.req = conn->llcp_feature.ack = 0;
   2336c:	f8a4 5118 	strh.w	r5, [r4, #280]	; 0x118
	conn->llcp_version.req = conn->llcp_version.ack = 0;
   23370:	f8a4 5120 	strh.w	r5, [r4, #288]	; 0x120
	conn->llcp_terminate.reason_peer = 0U;
   23374:	f884 512b 	strb.w	r5, [r4, #299]	; 0x12b
	conn_lll->enc_rx = conn_lll->enc_tx = 0U;
   23378:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
	conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
   2337c:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
	conn->llcp_enc.req = conn->llcp_enc.ack = 0U;
   23380:	f8a4 5150 	strh.w	r5, [r4, #336]	; 0x150
	conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
   23384:	f023 0307 	bic.w	r3, r3, #7
   23388:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
	conn->llcp_conn_param.disabled = 0U;
   2338c:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
	conn->llcp_conn_param.req = 0U;
   23390:	f8a4 5170 	strh.w	r5, [r4, #368]	; 0x170
	conn->llcp_conn_param.disabled = 0U;
   23394:	f365 1304 	bfi	r3, r5, #4, #1
   23398:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
	conn->llcp_length.req = conn->llcp_length.ack = 0U;
   2339c:	f8a4 5198 	strh.w	r5, [r4, #408]	; 0x198
	conn->llcp_length.cache.tx_octets = 0U;
   233a0:	f8a4 51a4 	strh.w	r5, [r4, #420]	; 0x1a4
	conn->default_tx_octets = ull_conn_default_tx_octets_get();
   233a4:	f7fd fa24 	bl	207f0 <ull_conn_default_tx_octets_get>
   233a8:	f8a4 00d6 	strh.w	r0, [r4, #214]	; 0xd6
	conn->default_tx_time = ull_conn_default_tx_time_get();
   233ac:	f7fd fa26 	bl	207fc <ull_conn_default_tx_time_get>
	conn->llcp_phy.req = conn->llcp_phy.ack = 0U;
   233b0:	f8d4 21a8 	ldr.w	r2, [r4, #424]	; 0x1a8
   233b4:	4b36      	ldr	r3, [pc, #216]	; (23490 <ll_create_connection+0x4bc>)
	conn->default_tx_time = ull_conn_default_tx_time_get();
   233b6:	f8a4 00d8 	strh.w	r0, [r4, #216]	; 0xd8
	conn->llcp_phy.req = conn->llcp_phy.ack = 0U;
   233ba:	4013      	ands	r3, r2
   233bc:	f8c4 31a8 	str.w	r3, [r4, #424]	; 0x1a8
	conn->phy_pref_tx = ull_conn_default_phy_tx_get();
   233c0:	f7fd fa22 	bl	20808 <ull_conn_default_phy_tx_get>
   233c4:	f894 31ac 	ldrb.w	r3, [r4, #428]	; 0x1ac
   233c8:	f360 0302 	bfi	r3, r0, #0, #3
   233cc:	f884 31ac 	strb.w	r3, [r4, #428]	; 0x1ac
	conn->phy_pref_rx = ull_conn_default_phy_rx_get();
   233d0:	f7fd fa20 	bl	20814 <ull_conn_default_phy_rx_get>
   233d4:	f894 31ac 	ldrb.w	r3, [r4, #428]	; 0x1ac
	conn->tx_head = conn->tx_ctrl = conn->tx_ctrl_last =
   233d8:	f8c4 51b0 	str.w	r5, [r4, #432]	; 0x1b0
	conn->phy_pref_rx = ull_conn_default_phy_rx_get();
   233dc:	f360 1306 	bfi	r3, r0, #4, #3
	conn->phy_pref_flags = 0U;
   233e0:	f365 03c3 	bfi	r3, r5, #3, #1
   233e4:	f884 31ac 	strb.w	r3, [r4, #428]	; 0x1ac
	lll->conn = conn_lll;
   233e8:	9b07      	ldr	r3, [sp, #28]
	conn->tx_data = conn->tx_data_last = 0;
   233ea:	e9c4 556f 	strd	r5, r5, [r4, #444]	; 0x1bc
	conn->tx_head = conn->tx_ctrl = conn->tx_ctrl_last =
   233ee:	e9c4 556d 	strd	r5, r5, [r4, #436]	; 0x1b4
	lll->conn = conn_lll;
   233f2:	6273      	str	r3, [r6, #36]	; 0x24
	hdr->is_stop = 0U;
   233f4:	f894 3020 	ldrb.w	r3, [r4, #32]
	hdr->parent = parent;
   233f8:	61e4      	str	r4, [r4, #28]
	hdr->is_stop = 0U;
   233fa:	f365 0300 	bfi	r3, r5, #0, #1
   233fe:	f884 3020 	strb.w	r3, [r4, #32]
	hdr->disabled_cb = hdr->disabled_param = NULL;
   23402:	e9c4 5505 	strd	r5, r5, [r4, #20]
	ull_filter_scan_update(filter_policy);
   23406:	4638      	mov	r0, r7
   23408:	f000 fb16 	bl	23a38 <ull_filter_scan_update>
	lll->rl_idx = FILTER_IDX_NONE;
   2340c:	23ff      	movs	r3, #255	; 0xff
   2340e:	f886 3034 	strb.w	r3, [r6, #52]	; 0x34
	lll->rpa_gen = 0;
   23412:	f896 3033 	ldrb.w	r3, [r6, #51]	; 0x33
   23416:	f365 0300 	bfi	r3, r5, #0, #1
   2341a:	f886 3033 	strb.w	r3, [r6, #51]	; 0x33
	if (!filter_policy && ull_filter_lll_rl_enabled()) {
   2341e:	b94f      	cbnz	r7, 23434 <ll_create_connection+0x460>
   23420:	f001 f888 	bl	24534 <ull_filter_lll_rl_enabled>
   23424:	b130      	cbz	r0, 23434 <ll_create_connection+0x460>
		lll->rl_idx = ull_filter_rl_find(peer_addr_type, peer_addr,
   23426:	463a      	mov	r2, r7
   23428:	9914      	ldr	r1, [sp, #80]	; 0x50
   2342a:	9804      	ldr	r0, [sp, #16]
   2342c:	f000 fb88 	bl	23b40 <ull_filter_rl_find>
   23430:	f886 0034 	strb.w	r0, [r6, #52]	; 0x34
	if (own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
   23434:	f1a8 0302 	sub.w	r3, r8, #2
   23438:	2b01      	cmp	r3, #1
   2343a:	d80a      	bhi.n	23452 <ll_create_connection+0x47e>
		ull_filter_rpa_update(false);
   2343c:	2000      	movs	r0, #0
   2343e:	f000 fda9 	bl	23f94 <ull_filter_rpa_update>
		lll->rpa_gen = 1;
   23442:	f896 3033 	ldrb.w	r3, [r6, #51]	; 0x33
   23446:	f043 0301 	orr.w	r3, r3, #1
		own_addr_type &= 0x1;
   2344a:	f008 0801 	and.w	r8, r8, #1
		lll->rpa_gen = 1;
   2344e:	f886 3033 	strb.w	r3, [r6, #51]	; 0x33
	scan->own_addr_type = own_addr_type;
   23452:	f896 3048 	ldrb.w	r3, [r6, #72]	; 0x48
   23456:	f368 0342 	bfi	r3, r8, #1, #2
   2345a:	f886 3048 	strb.w	r3, [r6, #72]	; 0x48
	lll_clock_wait();
   2345e:	f7ff f8cd 	bl	225fc <lll_clock_wait>
	return ull_scan_enable(scan);
   23462:	4630      	mov	r0, r6
   23464:	f7e9 fb14 	bl	ca90 <ull_scan_enable>
}
   23468:	b00b      	add	sp, #44	; 0x2c
   2346a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (bit_idx < 15) {
   2346e:	46d4      	mov	ip, sl
   23470:	e646      	b.n	23100 <ll_create_connection+0x12c>
				if (transitions_lsb16 !=
   23472:	45e2      	cmp	sl, ip
   23474:	f47f ae7d 	bne.w	23172 <ll_create_connection+0x19e>
   23478:	4672      	mov	r2, lr
   2347a:	e6a7      	b.n	231cc <ll_create_connection+0x1f8>
   2347c:	8e89bed6 	.word	0x8e89bed6
   23480:	01480148 	.word	0x01480148
   23484:	026259ff 	.word	0x026259ff
   23488:	01c9c37f 	.word	0x01c9c37f
   2348c:	000149ff 	.word	0x000149ff
   23490:	feff0000 	.word	0xfeff0000

00023494 <ll_connect_disable>:
{
   23494:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   23498:	4607      	mov	r7, r0
	scan = ull_scan_is_enabled_get(0);
   2349a:	2000      	movs	r0, #0
   2349c:	f7fc fc08 	bl	1fcb0 <ull_scan_is_enabled_get>
	if (!scan) {
   234a0:	4601      	mov	r1, r0
   234a2:	b338      	cbz	r0, 234f4 <ll_connect_disable+0x60>
	conn_lll = scan->lll.conn;
   234a4:	6a44      	ldr	r4, [r0, #36]	; 0x24
	if (!conn_lll) {
   234a6:	b32c      	cbz	r4, 234f4 <ll_connect_disable+0x60>
	status = ull_scan_disable(0, scan);
   234a8:	2000      	movs	r0, #0
   234aa:	f7fc fb97 	bl	1fbdc <ull_scan_disable>
	if (!status) {
   234ae:	4605      	mov	r5, r0
   234b0:	b9e8      	cbnz	r0, 234ee <ll_connect_disable+0x5a>
		struct ll_conn *conn = (void *)HDR_LLL2EVT(conn_lll);
   234b2:	6824      	ldr	r4, [r4, #0]
		link = cc->hdr.link;
   234b4:	f8d4 612c 	ldr.w	r6, [r4, #300]	; 0x12c
		cc = (void *)&conn->llcp_terminate.node_rx;
   234b8:	f504 7896 	add.w	r8, r4, #300	; 0x12c
		LL_ASSERT(link);
   234bc:	b946      	cbnz	r6, 234d0 <ll_connect_disable+0x3c>
   234be:	480e      	ldr	r0, [pc, #56]	; (234f8 <ll_connect_disable+0x64>)
   234c0:	f004 fe40 	bl	28144 <printk>
   234c4:	4040      	eors	r0, r0
   234c6:	f380 8811 	msr	BASEPRI, r0
   234ca:	f04f 0003 	mov.w	r0, #3
   234ce:	df02      	svc	2
		ll_rx_link_release(link);
   234d0:	4630      	mov	r0, r6
   234d2:	f7fa fe93 	bl	1e1fc <ll_rx_link_release>
		cc->hdr.type = NODE_RX_TYPE_CONNECTION;
   234d6:	2308      	movs	r3, #8
   234d8:	f884 3130 	strb.w	r3, [r4, #304]	; 0x130
		cc->hdr.handle = 0xffff;
   234dc:	f64f 73ff 	movw	r3, #65535	; 0xffff
   234e0:	f8a4 3132 	strh.w	r3, [r4, #306]	; 0x132
		*((u8_t *)cc->pdu) = BT_HCI_ERR_UNKNOWN_CONN_ID;
   234e4:	2302      	movs	r3, #2
   234e6:	f884 314c 	strb.w	r3, [r4, #332]	; 0x14c
		*rx = cc;
   234ea:	f8c7 8000 	str.w	r8, [r7]
}
   234ee:	4628      	mov	r0, r5
   234f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   234f4:	250c      	movs	r5, #12
   234f6:	e7fa      	b.n	234ee <ll_connect_disable+0x5a>
   234f8:	00031657 	.word	0x00031657

000234fc <prepare_cb>:
{
	return 0;
}

static int prepare_cb(struct lll_prepare_param *prepare_param)
{
   234fc:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct lll_conn *lll = prepare_param->param;
   234fe:	68c4      	ldr	r4, [r0, #12]
	/* TODO: Do the below in ULL ?  */

	lazy = prepare_param->lazy;

	/* save the latency for use in event */
	lll->latency_prepare += lazy;
   23500:	8902      	ldrh	r2, [r0, #8]
   23502:	8ae3      	ldrh	r3, [r4, #22]
   23504:	4413      	add	r3, r2

	/* calc current event counter value */
	event_counter = lll->event_counter + lll->latency_prepare;
   23506:	8b62      	ldrh	r2, [r4, #26]
	lll->latency_prepare += lazy;
   23508:	b29b      	uxth	r3, r3
   2350a:	82e3      	strh	r3, [r4, #22]
	event_counter = lll->event_counter + lll->latency_prepare;
   2350c:	4413      	add	r3, r2

	/* store the next event counter value */
	lll->event_counter = event_counter + 1;
   2350e:	3301      	adds	r3, #1
   23510:	8363      	strh	r3, [r4, #26]
{
   23512:	b085      	sub	sp, #20
   23514:	4605      	mov	r5, r0

	/* TODO: Do the above in ULL ?  */

	/* Reset connection event global variables */
	lll_conn_prepare_reset();
   23516:	f7ff f911 	bl	2273c <lll_conn_prepare_reset>

	/* TODO: can we do something in ULL? */
	lll->latency_event = lll->latency_prepare;
	lll->latency_prepare = 0;
   2351a:	2300      	movs	r3, #0
	lll->latency_event = lll->latency_prepare;
   2351c:	8ae2      	ldrh	r2, [r4, #22]
	lll->latency_prepare = 0;
   2351e:	82e3      	strh	r3, [r4, #22]

	if (lll->data_chan_sel) {
   23520:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
	lll->latency_event = lll->latency_prepare;
   23524:	8322      	strh	r2, [r4, #24]
	if (lll->data_chan_sel) {
   23526:	0659      	lsls	r1, r3, #25
   23528:	f104 061c 	add.w	r6, r4, #28
   2352c:	d563      	bpl.n	235f6 <prepare_cb+0xfa>
#if defined(CONFIG_BT_CTLR_CHAN_SEL_2)
		data_chan_use = lll_chan_sel_2(lll->event_counter - 1,
   2352e:	8b60      	ldrh	r0, [r4, #26]
   23530:	8c61      	ldrh	r1, [r4, #34]	; 0x22
   23532:	3801      	subs	r0, #1
   23534:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   23538:	4632      	mov	r2, r6
   2353a:	b280      	uxth	r0, r0
   2353c:	f7fb f9ea 	bl	1e914 <lll_chan_sel_2>
#else /* !CONFIG_BT_CTLR_CHAN_SEL_2 */
		data_chan_use = 0;
		LL_ASSERT(0);
#endif /* !CONFIG_BT_CTLR_CHAN_SEL_2 */
	} else {
		data_chan_use = lll_chan_sel_1(&lll->data_chan_use,
   23540:	4606      	mov	r6, r0
					       &lll->data_chan_map[0],
					       lll->data_chan_count);
	}

	/* Prepare the Tx PDU */
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
   23542:	a903      	add	r1, sp, #12
   23544:	4620      	mov	r0, r4
   23546:	f009 f931 	bl	2c7ac <lll_conn_pdu_tx_prep>
	pdu_data_tx->sn = lll->sn;
   2354a:	9903      	ldr	r1, [sp, #12]
   2354c:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
   23550:	780b      	ldrb	r3, [r1, #0]
   23552:	f3c2 0200 	ubfx	r2, r2, #0, #1
   23556:	f362 03c3 	bfi	r3, r2, #3, #1
	pdu_data_tx->nesn = lll->nesn;
   2355a:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
   2355e:	f3c2 0240 	ubfx	r2, r2, #1, #1
   23562:	f362 0382 	bfi	r3, r2, #2, #1
   23566:	700b      	strb	r3, [r1, #0]

	/* Start setting up of Radio h/w */
	radio_reset();
   23568:	f001 f9b2 	bl	248d0 <radio_reset>
	/* TODO: other Tx Power settings */
	radio_tx_power_set(RADIO_TXP_DEFAULT);
   2356c:	2008      	movs	r0, #8
   2356e:	f001 fa03 	bl	24978 <radio_tx_power_set>
	radio_aa_set(lll->access_addr);
   23572:	f104 0008 	add.w	r0, r4, #8
   23576:	f001 fa1d 	bl	249b4 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
			    (((u32_t)lll->crc_init[2] << 16) |
			     ((u32_t)lll->crc_init[1] << 8) |
   2357a:	7b63      	ldrb	r3, [r4, #13]
			    (((u32_t)lll->crc_init[2] << 16) |
   2357c:	7ba1      	ldrb	r1, [r4, #14]
			     ((u32_t)lll->crc_init[1] << 8) |
   2357e:	021b      	lsls	r3, r3, #8
			    (((u32_t)lll->crc_init[2] << 16) |
   23580:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
			     ((u32_t)lll->crc_init[0])));
   23584:	7b21      	ldrb	r1, [r4, #12]
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
   23586:	f240 605b 	movw	r0, #1627	; 0x65b
   2358a:	4319      	orrs	r1, r3
   2358c:	f001 faa6 	bl	24adc <radio_crc_configure>
	lll_chan_set(data_chan_use);
   23590:	4630      	mov	r0, r6
   23592:	f7fb fc3d 	bl	1ee10 <lll_chan_set>

	/* setup the radio tx packet buffer */
	lll_conn_tx_pkt_set(lll, pdu_data_tx);
   23596:	9903      	ldr	r1, [sp, #12]
   23598:	4620      	mov	r0, r4
   2359a:	f009 f8de 	bl	2c75a <lll_conn_tx_pkt_set>

	radio_isr_set(lll_conn_isr_tx, lll);
   2359e:	4621      	mov	r1, r4
   235a0:	4822      	ldr	r0, [pc, #136]	; (2362c <prepare_cb+0x130>)
   235a2:	f001 f975 	bl	24890 <radio_isr_set>

	radio_tmr_tifs_set(EVENT_IFS_US);
   235a6:	2096      	movs	r0, #150	; 0x96
   235a8:	f001 fb58 	bl	24c5c <radio_tmr_tifs_set>

#if defined(CONFIG_BT_CTLR_PHY)
	radio_switch_complete_and_rx(lll->phy_rx);
   235ac:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
   235b0:	f000 0007 	and.w	r0, r0, #7
   235b4:	f001 fab0 	bl	24b18 <radio_switch_complete_and_rx>
#else /* !CONFIG_BT_CTLR_PHY */
	radio_switch_complete_and_rx(0);
#endif /* !CONFIG_BT_CTLR_PHY */

	ticks_at_event = prepare_param->ticks_at_expire;
	evt = HDR_LLL2EVT(lll);
   235b8:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
   235ba:	682e      	ldr	r6, [r5, #0]
	ticks_at_event += lll_evt_offset_get(evt);
   235bc:	4638      	mov	r0, r7
   235be:	f008 fc66 	bl	2be8e <lll_evt_offset_get>
   235c2:	4406      	add	r6, r0

	ticks_at_start = ticks_at_event;
	ticks_at_start += HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US);

	remainder = prepare_param->remainder;
	remainder_us = radio_tmr_start(1, ticks_at_start, remainder);
   235c4:	686a      	ldr	r2, [r5, #4]
   235c6:	f106 0109 	add.w	r1, r6, #9
   235ca:	2001      	movs	r0, #1
   235cc:	f001 fb52 	bl	24c74 <radio_tmr_start>

	/* capture end of Tx-ed PDU, used to calculate HCTO. */
	radio_tmr_end_capture();
   235d0:	f001 fc1c 	bl	24e0c <radio_tmr_end_capture>
#endif /* !CONFIG_BT_CTLR_GPIO_PA_PIN */

#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED) && \
	(EVENT_OVERHEAD_PREEMPT_US <= EVENT_OVERHEAD_PREEMPT_MIN_US)
	/* check if preempt to start has changed */
	if (lll_preempt_calc(evt, (TICKER_ID_CONN_BASE + lll->handle),
   235d4:	7c21      	ldrb	r1, [r4, #16]
   235d6:	3105      	adds	r1, #5
   235d8:	4632      	mov	r2, r6
   235da:	b2c9      	uxtb	r1, r1
   235dc:	4638      	mov	r0, r7
   235de:	f008 fc64 	bl	2beaa <lll_preempt_calc>
   235e2:	b198      	cbz	r0, 2360c <prepare_cb+0x110>
			     ticks_at_event)) {
		radio_isr_set(lll_conn_isr_abort, lll);
   235e4:	4621      	mov	r1, r4
   235e6:	4812      	ldr	r0, [pc, #72]	; (23630 <prepare_cb+0x134>)
   235e8:	f001 f952 	bl	24890 <radio_isr_set>
		radio_disable();
   235ec:	f001 fa44 	bl	24a78 <radio_disable>
	}

	DEBUG_RADIO_START_M(1);

	return 0;
}
   235f0:	2000      	movs	r0, #0
   235f2:	b005      	add	sp, #20
   235f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		data_chan_use = lll_chan_sel_1(&lll->data_chan_use,
   235f6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   235fa:	f894 1022 	ldrb.w	r1, [r4, #34]	; 0x22
   235fe:	9300      	str	r3, [sp, #0]
   23600:	f104 0023 	add.w	r0, r4, #35	; 0x23
   23604:	4633      	mov	r3, r6
   23606:	f008 fbfd 	bl	2be04 <lll_chan_sel_1>
   2360a:	e799      	b.n	23540 <prepare_cb+0x44>
		ret = lll_prepare_done(lll);
   2360c:	4620      	mov	r0, r4
   2360e:	f008 fc3c 	bl	2be8a <lll_prepare_done>
		LL_ASSERT(!ret);
   23612:	2800      	cmp	r0, #0
   23614:	d0ec      	beq.n	235f0 <prepare_cb+0xf4>
   23616:	4807      	ldr	r0, [pc, #28]	; (23634 <prepare_cb+0x138>)
   23618:	f004 fd94 	bl	28144 <printk>
   2361c:	4040      	eors	r0, r0
   2361e:	f380 8811 	msr	BASEPRI, r0
   23622:	f04f 0003 	mov.w	r0, #3
   23626:	df02      	svc	2
   23628:	e7e2      	b.n	235f0 <prepare_cb+0xf4>
   2362a:	bf00      	nop
   2362c:	00022819 	.word	0x00022819
   23630:	0002c739 	.word	0x0002c739
   23634:	0003166e 	.word	0x0003166e

00023638 <lll_master_prepare>:
{
   23638:	b513      	push	{r0, r1, r4, lr}
   2363a:	4604      	mov	r4, r0
	err = lll_clk_on();
   2363c:	f7fb fbda 	bl	1edf4 <lll_clk_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
   23640:	b150      	cbz	r0, 23658 <lll_master_prepare+0x20>
   23642:	3044      	adds	r0, #68	; 0x44
   23644:	d008      	beq.n	23658 <lll_master_prepare+0x20>
   23646:	480f      	ldr	r0, [pc, #60]	; (23684 <lll_master_prepare+0x4c>)
   23648:	f004 fd7c 	bl	28144 <printk>
   2364c:	4040      	eors	r0, r0
   2364e:	f380 8811 	msr	BASEPRI, r0
   23652:	f04f 0003 	mov.w	r0, #3
   23656:	df02      	svc	2
	err = lll_prepare(lll_conn_is_abort_cb, lll_conn_abort_cb, prepare_cb,
   23658:	9400      	str	r4, [sp, #0]
   2365a:	2300      	movs	r3, #0
   2365c:	4a0a      	ldr	r2, [pc, #40]	; (23688 <lll_master_prepare+0x50>)
   2365e:	490b      	ldr	r1, [pc, #44]	; (2368c <lll_master_prepare+0x54>)
   23660:	480b      	ldr	r0, [pc, #44]	; (23690 <lll_master_prepare+0x58>)
   23662:	f008 fc09 	bl	2be78 <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
   23666:	b150      	cbz	r0, 2367e <lll_master_prepare+0x46>
   23668:	3044      	adds	r0, #68	; 0x44
   2366a:	d008      	beq.n	2367e <lll_master_prepare+0x46>
   2366c:	4805      	ldr	r0, [pc, #20]	; (23684 <lll_master_prepare+0x4c>)
   2366e:	f004 fd69 	bl	28144 <printk>
   23672:	4040      	eors	r0, r0
   23674:	f380 8811 	msr	BASEPRI, r0
   23678:	f04f 0003 	mov.w	r0, #3
   2367c:	df02      	svc	2
}
   2367e:	b002      	add	sp, #8
   23680:	bd10      	pop	{r4, pc}
   23682:	bf00      	nop
   23684:	00031b18 	.word	0x00031b18
   23688:	000234fd 	.word	0x000234fd
   2368c:	00022761 	.word	0x00022761
   23690:	0002c733 	.word	0x0002c733

00023694 <wl_find>:
		wl[i].taken = 0U;
	}
}

static u8_t wl_find(u8_t addr_type, u8_t *addr, u8_t *free)
{
   23694:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   23698:	4688      	mov	r8, r1
	int i;

	if (free) {
   2369a:	4615      	mov	r5, r2
   2369c:	b10a      	cbz	r2, 236a2 <wl_find+0xe>
		*free = FILTER_IDX_NONE;
   2369e:	23ff      	movs	r3, #255	; 0xff
   236a0:	7013      	strb	r3, [r2, #0]
	}

	for (i = 0; i < WL_SIZE; i++) {
		if (LIST_MATCH(wl, i, addr_type, addr)) {
   236a2:	4f14      	ldr	r7, [pc, #80]	; (236f4 <wl_find+0x60>)
{
   236a4:	2400      	movs	r4, #0
		if (LIST_MATCH(wl, i, addr_type, addr)) {
   236a6:	f000 0601 	and.w	r6, r0, #1
   236aa:	f817 3034 	ldrb.w	r3, [r7, r4, lsl #3]
   236ae:	07da      	lsls	r2, r3, #31
   236b0:	d51c      	bpl.n	236ec <wl_find+0x58>
   236b2:	f3c3 0340 	ubfx	r3, r3, #1, #1
   236b6:	42b3      	cmp	r3, r6
   236b8:	d113      	bne.n	236e2 <wl_find+0x4e>
   236ba:	480f      	ldr	r0, [pc, #60]	; (236f8 <wl_find+0x64>)
   236bc:	2206      	movs	r2, #6
   236be:	4641      	mov	r1, r8
   236c0:	eb00 00c4 	add.w	r0, r0, r4, lsl #3
   236c4:	f006 fe9c 	bl	2a400 <memcmp>
   236c8:	b910      	cbnz	r0, 236d0 <wl_find+0x3c>
			return i;
   236ca:	b2e0      	uxtb	r0, r4
			*free = i;
		}
	}

	return FILTER_IDX_NONE;
}
   236cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		} else if (free && !wl[i].taken && (*free == FILTER_IDX_NONE)) {
   236d0:	b13d      	cbz	r5, 236e2 <wl_find+0x4e>
   236d2:	f817 3034 	ldrb.w	r3, [r7, r4, lsl #3]
   236d6:	07db      	lsls	r3, r3, #31
   236d8:	d403      	bmi.n	236e2 <wl_find+0x4e>
   236da:	782b      	ldrb	r3, [r5, #0]
   236dc:	2bff      	cmp	r3, #255	; 0xff
			*free = i;
   236de:	bf08      	it	eq
   236e0:	702c      	strbeq	r4, [r5, #0]
	for (i = 0; i < WL_SIZE; i++) {
   236e2:	3401      	adds	r4, #1
   236e4:	2c08      	cmp	r4, #8
   236e6:	d1e0      	bne.n	236aa <wl_find+0x16>
	return FILTER_IDX_NONE;
   236e8:	20ff      	movs	r0, #255	; 0xff
   236ea:	e7ef      	b.n	236cc <wl_find+0x38>
		} else if (free && !wl[i].taken && (*free == FILTER_IDX_NONE)) {
   236ec:	2d00      	cmp	r5, #0
   236ee:	d1f4      	bne.n	236da <wl_find+0x46>
   236f0:	e7f7      	b.n	236e2 <wl_find+0x4e>
   236f2:	bf00      	nop
   236f4:	20003f95 	.word	0x20003f95
   236f8:	20003f97 	.word	0x20003f97

000236fc <rl_update>:
		}
	}
}

static void rl_update(void)
{
   236fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#endif /* !CONFIG_BT_CTLR_PRIVACY */

static void filter_insert(struct lll_filter *filter, int index, u8_t addr_type,
			   u8_t *bdaddr)
{
	filter->enable_bitmask |= BIT(index);
   236fe:	4d10      	ldr	r5, [pc, #64]	; (23740 <rl_update+0x44>)
		if (rl[i].taken) {
   23700:	4e10      	ldr	r6, [pc, #64]	; (23744 <rl_update+0x48>)
{
   23702:	2400      	movs	r4, #0
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
   23704:	1caf      	adds	r7, r5, #2
		if (rl[i].taken) {
   23706:	2128      	movs	r1, #40	; 0x28
   23708:	4361      	muls	r1, r4
   2370a:	5c73      	ldrb	r3, [r6, r1]
   2370c:	07da      	lsls	r2, r3, #31
   2370e:	d512      	bpl.n	23736 <rl_update+0x3a>
	filter->enable_bitmask |= BIT(index);
   23710:	2201      	movs	r2, #1
   23712:	fa02 f004 	lsl.w	r0, r2, r4
   23716:	782a      	ldrb	r2, [r5, #0]
   23718:	4302      	orrs	r2, r0
			filter_insert(&rl_filter, i, rl[i].id_addr_type,
   2371a:	f3c3 1380 	ubfx	r3, r3, #6, #1
	filter->enable_bitmask |= BIT(index);
   2371e:	702a      	strb	r2, [r5, #0]
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
   23720:	786a      	ldrb	r2, [r5, #1]
   23722:	40a3      	lsls	r3, r4
   23724:	4313      	orrs	r3, r2
   23726:	706b      	strb	r3, [r5, #1]
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
   23728:	4b07      	ldr	r3, [pc, #28]	; (23748 <rl_update+0x4c>)
   2372a:	2206      	movs	r2, #6
   2372c:	4419      	add	r1, r3
   2372e:	fb02 7004 	mla	r0, r2, r4, r7
   23732:	f006 fe8c 	bl	2a44e <memcpy>
   23736:	3401      	adds	r4, #1
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
   23738:	2c08      	cmp	r4, #8
   2373a:	d1e4      	bne.n	23706 <rl_update+0xa>
}
   2373c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2373e:	bf00      	nop
   23740:	20003f63 	.word	0x20003f63
   23744:	200035bc 	.word	0x200035bc
   23748:	200035bd 	.word	0x200035bd

0002374c <wl_update>:
{
   2374c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   23750:	4d1a      	ldr	r5, [pc, #104]	; (237bc <wl_update+0x70>)
	filter->enable_bitmask |= BIT(index);
   23752:	4e1b      	ldr	r6, [pc, #108]	; (237c0 <wl_update+0x74>)
		if (!rl_enable || j >= ARRAY_SIZE(rl) || !rl[j].pirk ||
   23754:	f8df 8070 	ldr.w	r8, [pc, #112]	; 237c8 <wl_update+0x7c>
{
   23758:	2400      	movs	r4, #0
   2375a:	462f      	mov	r7, r5
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
   2375c:	f106 0902 	add.w	r9, r6, #2
		if (!wl[i].taken) {
   23760:	f817 3034 	ldrb.w	r3, [r7, r4, lsl #3]
   23764:	07d9      	lsls	r1, r3, #31
   23766:	d521      	bpl.n	237ac <wl_update+0x60>
		if (!rl_enable || j >= ARRAY_SIZE(rl) || !rl[j].pirk ||
   23768:	f898 3000 	ldrb.w	r3, [r8]
   2376c:	b153      	cbz	r3, 23784 <wl_update+0x38>
		j = wl[i].rl_idx;
   2376e:	786a      	ldrb	r2, [r5, #1]
		if (!rl_enable || j >= ARRAY_SIZE(rl) || !rl[j].pirk ||
   23770:	2a07      	cmp	r2, #7
   23772:	d807      	bhi.n	23784 <wl_update+0x38>
   23774:	2328      	movs	r3, #40	; 0x28
   23776:	4353      	muls	r3, r2
   23778:	4a12      	ldr	r2, [pc, #72]	; (237c4 <wl_update+0x78>)
   2377a:	5cd3      	ldrb	r3, [r2, r3]
   2377c:	075a      	lsls	r2, r3, #29
   2377e:	d501      	bpl.n	23784 <wl_update+0x38>
   23780:	06db      	lsls	r3, r3, #27
   23782:	d513      	bpl.n	237ac <wl_update+0x60>
	filter->enable_bitmask |= BIT(index);
   23784:	2201      	movs	r2, #1
   23786:	fa02 f104 	lsl.w	r1, r2, r4
   2378a:	7832      	ldrb	r2, [r6, #0]
			filter_insert(&wl_filter, i, wl[i].id_addr_type,
   2378c:	f817 3034 	ldrb.w	r3, [r7, r4, lsl #3]
	filter->enable_bitmask |= BIT(index);
   23790:	430a      	orrs	r2, r1
			filter_insert(&wl_filter, i, wl[i].id_addr_type,
   23792:	f3c3 0340 	ubfx	r3, r3, #1, #1
	filter->enable_bitmask |= BIT(index);
   23796:	7032      	strb	r2, [r6, #0]
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
   23798:	7872      	ldrb	r2, [r6, #1]
   2379a:	40a3      	lsls	r3, r4
   2379c:	4313      	orrs	r3, r2
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
   2379e:	2206      	movs	r2, #6
   237a0:	1ca9      	adds	r1, r5, #2
   237a2:	fb02 9004 	mla	r0, r2, r4, r9
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
   237a6:	7073      	strb	r3, [r6, #1]
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
   237a8:	f006 fe51 	bl	2a44e <memcpy>
   237ac:	3401      	adds	r4, #1
	for (i = 0U; i < WL_SIZE; i++) {
   237ae:	2c08      	cmp	r4, #8
   237b0:	f105 0508 	add.w	r5, r5, #8
   237b4:	d1d4      	bne.n	23760 <wl_update+0x14>
}
   237b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   237ba:	bf00      	nop
   237bc:	20003f95 	.word	0x20003f95
   237c0:	20003fd6 	.word	0x20003fd6
   237c4:	200035bc 	.word	0x200035bc
   237c8:	20003f62 	.word	0x20003f62

000237cc <ll_wl_clear>:
{
   237cc:	b508      	push	{r3, lr}
	if (ull_adv_filter_pol_get(0)) {
   237ce:	2000      	movs	r0, #0
   237d0:	f008 fb8a 	bl	2bee8 <ull_adv_filter_pol_get>
   237d4:	b108      	cbz	r0, 237da <ll_wl_clear+0xe>
		return BT_HCI_ERR_CMD_DISALLOWED;
   237d6:	200c      	movs	r0, #12
}
   237d8:	bd08      	pop	{r3, pc}
	if (ull_scan_filter_pol_get(0) & 0x1) {
   237da:	f008 fc81 	bl	2c0e0 <ull_scan_filter_pol_get>
   237de:	f010 0001 	ands.w	r0, r0, #1
   237e2:	d1f8      	bne.n	237d6 <ll_wl_clear+0xa>
		wl[i].taken = 0U;
   237e4:	4b15      	ldr	r3, [pc, #84]	; (2383c <ll_wl_clear+0x70>)
   237e6:	781a      	ldrb	r2, [r3, #0]
   237e8:	f360 0200 	bfi	r2, r0, #0, #1
   237ec:	701a      	strb	r2, [r3, #0]
   237ee:	7a1a      	ldrb	r2, [r3, #8]
   237f0:	f360 0200 	bfi	r2, r0, #0, #1
   237f4:	721a      	strb	r2, [r3, #8]
   237f6:	7c1a      	ldrb	r2, [r3, #16]
   237f8:	f360 0200 	bfi	r2, r0, #0, #1
   237fc:	741a      	strb	r2, [r3, #16]
   237fe:	7e1a      	ldrb	r2, [r3, #24]
   23800:	f360 0200 	bfi	r2, r0, #0, #1
   23804:	761a      	strb	r2, [r3, #24]
   23806:	f893 2020 	ldrb.w	r2, [r3, #32]
   2380a:	f360 0200 	bfi	r2, r0, #0, #1
   2380e:	f883 2020 	strb.w	r2, [r3, #32]
   23812:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
   23816:	f360 0200 	bfi	r2, r0, #0, #1
   2381a:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
   2381e:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
   23822:	f360 0200 	bfi	r2, r0, #0, #1
   23826:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
   2382a:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
   2382e:	f360 0200 	bfi	r2, r0, #0, #1
   23832:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
	wl_anon = 0U;
   23836:	4b02      	ldr	r3, [pc, #8]	; (23840 <ll_wl_clear+0x74>)
   23838:	7018      	strb	r0, [r3, #0]
	return 0;
   2383a:	e7cd      	b.n	237d8 <ll_wl_clear+0xc>
   2383c:	20003f95 	.word	0x20003f95
   23840:	20003fd5 	.word	0x20003fd5

00023844 <ll_wl_remove>:
{
   23844:	b538      	push	{r3, r4, r5, lr}
   23846:	4605      	mov	r5, r0
	if (ull_adv_filter_pol_get(0)) {
   23848:	2000      	movs	r0, #0
   2384a:	f008 fb4d 	bl	2bee8 <ull_adv_filter_pol_get>
   2384e:	b108      	cbz	r0, 23854 <ll_wl_remove+0x10>
		return BT_HCI_ERR_CMD_DISALLOWED;
   23850:	200c      	movs	r0, #12
}
   23852:	bd38      	pop	{r3, r4, r5, pc}
	if (ull_scan_filter_pol_get(0) & 0x1) {
   23854:	f008 fc44 	bl	2c0e0 <ull_scan_filter_pol_get>
   23858:	f010 0401 	ands.w	r4, r0, #1
   2385c:	d1f8      	bne.n	23850 <ll_wl_remove+0xc>
	if (addr->type == ADDR_TYPE_ANON) {
   2385e:	7828      	ldrb	r0, [r5, #0]
   23860:	28ff      	cmp	r0, #255	; 0xff
   23862:	d103      	bne.n	2386c <ll_wl_remove+0x28>
		wl_anon = 0U;
   23864:	4b10      	ldr	r3, [pc, #64]	; (238a8 <ll_wl_remove+0x64>)
		return 0;
   23866:	4620      	mov	r0, r4
		wl_anon = 0U;
   23868:	701c      	strb	r4, [r3, #0]
		return 0;
   2386a:	e7f2      	b.n	23852 <ll_wl_remove+0xe>
	u8_t i = wl_find(id_addr->type, id_addr->a.val, NULL);
   2386c:	4622      	mov	r2, r4
   2386e:	1c69      	adds	r1, r5, #1
   23870:	f7ff ff10 	bl	23694 <wl_find>
	if (i < ARRAY_SIZE(wl)) {
   23874:	2807      	cmp	r0, #7
   23876:	d814      	bhi.n	238a2 <ll_wl_remove+0x5e>
		u8_t j = wl[i].rl_idx;
   23878:	4b0c      	ldr	r3, [pc, #48]	; (238ac <ll_wl_remove+0x68>)
   2387a:	eb03 02c0 	add.w	r2, r3, r0, lsl #3
   2387e:	7855      	ldrb	r5, [r2, #1]
		if (j < ARRAY_SIZE(rl)) {
   23880:	2d07      	cmp	r5, #7
   23882:	d806      	bhi.n	23892 <ll_wl_remove+0x4e>
			rl[j].wl = 0U;
   23884:	2228      	movs	r2, #40	; 0x28
   23886:	490a      	ldr	r1, [pc, #40]	; (238b0 <ll_wl_remove+0x6c>)
   23888:	436a      	muls	r2, r5
   2388a:	5c8d      	ldrb	r5, [r1, r2]
   2388c:	f364 1545 	bfi	r5, r4, #5, #1
   23890:	548d      	strb	r5, [r1, r2]
		wl[i].taken = 0U;
   23892:	f813 2030 	ldrb.w	r2, [r3, r0, lsl #3]
   23896:	f36f 0200 	bfc	r2, #0, #1
   2389a:	f803 2030 	strb.w	r2, [r3, r0, lsl #3]
	return wl_remove(addr);
   2389e:	b2e0      	uxtb	r0, r4
   238a0:	e7d7      	b.n	23852 <ll_wl_remove+0xe>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
   238a2:	2402      	movs	r4, #2
   238a4:	e7fb      	b.n	2389e <ll_wl_remove+0x5a>
   238a6:	bf00      	nop
   238a8:	20003fd5 	.word	0x20003fd5
   238ac:	20003f95 	.word	0x20003f95
   238b0:	200035bc 	.word	0x200035bc

000238b4 <ll_rl_id_addr_get>:
	LL_ASSERT(rl_idx < CONFIG_BT_CTLR_RL_SIZE);
   238b4:	2807      	cmp	r0, #7
{
   238b6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   238b8:	4604      	mov	r4, r0
   238ba:	460f      	mov	r7, r1
   238bc:	4616      	mov	r6, r2
	LL_ASSERT(rl_idx < CONFIG_BT_CTLR_RL_SIZE);
   238be:	d908      	bls.n	238d2 <ll_rl_id_addr_get+0x1e>
   238c0:	4813      	ldr	r0, [pc, #76]	; (23910 <ll_rl_id_addr_get+0x5c>)
   238c2:	f004 fc3f 	bl	28144 <printk>
   238c6:	4040      	eors	r0, r0
   238c8:	f380 8811 	msr	BASEPRI, r0
   238cc:	f04f 0003 	mov.w	r0, #3
   238d0:	df02      	svc	2
	LL_ASSERT(rl[rl_idx].taken);
   238d2:	2328      	movs	r3, #40	; 0x28
   238d4:	4d0f      	ldr	r5, [pc, #60]	; (23914 <ll_rl_id_addr_get+0x60>)
   238d6:	4363      	muls	r3, r4
   238d8:	5ceb      	ldrb	r3, [r5, r3]
   238da:	07db      	lsls	r3, r3, #31
   238dc:	d408      	bmi.n	238f0 <ll_rl_id_addr_get+0x3c>
   238de:	480e      	ldr	r0, [pc, #56]	; (23918 <ll_rl_id_addr_get+0x64>)
   238e0:	f004 fc30 	bl	28144 <printk>
   238e4:	4040      	eors	r0, r0
   238e6:	f380 8811 	msr	BASEPRI, r0
   238ea:	f04f 0003 	mov.w	r0, #3
   238ee:	df02      	svc	2
	*id_addr_type = rl[rl_idx].id_addr_type;
   238f0:	2128      	movs	r1, #40	; 0x28
   238f2:	fb01 f304 	mul.w	r3, r1, r4
	memcpy(id_addr, rl[rl_idx].id_addr.val, BDADDR_SIZE);
   238f6:	fb01 5104 	mla	r1, r1, r4, r5
	*id_addr_type = rl[rl_idx].id_addr_type;
   238fa:	5ceb      	ldrb	r3, [r5, r3]
   238fc:	f3c3 1380 	ubfx	r3, r3, #6, #1
   23900:	703b      	strb	r3, [r7, #0]
	memcpy(id_addr, rl[rl_idx].id_addr.val, BDADDR_SIZE);
   23902:	4630      	mov	r0, r6
   23904:	2206      	movs	r2, #6
   23906:	3101      	adds	r1, #1
}
   23908:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	memcpy(id_addr, rl[rl_idx].id_addr.val, BDADDR_SIZE);
   2390c:	f006 bd9f 	b.w	2a44e <memcpy>
   23910:	00032083 	.word	0x00032083
   23914:	200035bc 	.word	0x200035bc
   23918:	000320a0 	.word	0x000320a0

0002391c <ll_rl_clear>:
{
   2391c:	b508      	push	{r3, lr}
	if (!rl_access_check(false)) {
   2391e:	f009 f88c 	bl	2ca3a <rl_access_check.constprop.2>
   23922:	b390      	cbz	r0, 2398a <ll_rl_clear+0x6e>
		rl[i].taken = 0U;
   23924:	4b1a      	ldr	r3, [pc, #104]	; (23990 <ll_rl_clear+0x74>)
   23926:	781a      	ldrb	r2, [r3, #0]
   23928:	f36f 0200 	bfc	r2, #0, #1
   2392c:	701a      	strb	r2, [r3, #0]
   2392e:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
   23932:	f36f 0200 	bfc	r2, #0, #1
   23936:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
   2393a:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
   2393e:	f36f 0200 	bfc	r2, #0, #1
   23942:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
   23946:	f893 2078 	ldrb.w	r2, [r3, #120]	; 0x78
   2394a:	f36f 0200 	bfc	r2, #0, #1
   2394e:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
   23952:	f893 20a0 	ldrb.w	r2, [r3, #160]	; 0xa0
   23956:	f36f 0200 	bfc	r2, #0, #1
   2395a:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0
   2395e:	f893 20c8 	ldrb.w	r2, [r3, #200]	; 0xc8
   23962:	f36f 0200 	bfc	r2, #0, #1
   23966:	f883 20c8 	strb.w	r2, [r3, #200]	; 0xc8
   2396a:	f893 20f0 	ldrb.w	r2, [r3, #240]	; 0xf0
   2396e:	f36f 0200 	bfc	r2, #0, #1
   23972:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
   23976:	f893 2118 	ldrb.w	r2, [r3, #280]	; 0x118
   2397a:	f36f 0200 	bfc	r2, #0, #1
   2397e:	f883 2118 	strb.w	r2, [r3, #280]	; 0x118
	peer_irk_count = 0U;
   23982:	4b04      	ldr	r3, [pc, #16]	; (23994 <ll_rl_clear+0x78>)
   23984:	2000      	movs	r0, #0
   23986:	7018      	strb	r0, [r3, #0]
}
   23988:	bd08      	pop	{r3, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   2398a:	200c      	movs	r0, #12
   2398c:	e7fc      	b.n	23988 <ll_rl_clear+0x6c>
   2398e:	bf00      	nop
   23990:	200035bc 	.word	0x200035bc
   23994:	20003ed9 	.word	0x20003ed9

00023998 <ll_rl_enable>:
{
   23998:	b510      	push	{r4, lr}
   2399a:	4604      	mov	r4, r0
	if (!rl_access_check(false)) {
   2399c:	f009 f84d 	bl	2ca3a <rl_access_check.constprop.2>
   239a0:	b160      	cbz	r0, 239bc <ll_rl_enable+0x24>
	switch (enable) {
   239a2:	b124      	cbz	r4, 239ae <ll_rl_enable+0x16>
   239a4:	2c01      	cmp	r4, #1
   239a6:	d005      	beq.n	239b4 <ll_rl_enable+0x1c>
		return BT_HCI_ERR_INVALID_PARAM;
   239a8:	2412      	movs	r4, #18
}
   239aa:	4620      	mov	r0, r4
   239ac:	bd10      	pop	{r4, pc}
		rl_enable = 0U;
   239ae:	4b04      	ldr	r3, [pc, #16]	; (239c0 <ll_rl_enable+0x28>)
   239b0:	701c      	strb	r4, [r3, #0]
		break;
   239b2:	e7fa      	b.n	239aa <ll_rl_enable+0x12>
		rl_enable = 1U;
   239b4:	4b02      	ldr	r3, [pc, #8]	; (239c0 <ll_rl_enable+0x28>)
   239b6:	701c      	strb	r4, [r3, #0]
	return 0;
   239b8:	2400      	movs	r4, #0
		break;
   239ba:	e7f6      	b.n	239aa <ll_rl_enable+0x12>
		return BT_HCI_ERR_CMD_DISALLOWED;
   239bc:	240c      	movs	r4, #12
   239be:	e7f4      	b.n	239aa <ll_rl_enable+0x12>
   239c0:	20003f62 	.word	0x20003f62

000239c4 <ll_rl_timeout_set>:
	rpa_timeout_ms = timeout * 1000U;
   239c4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   239c8:	4358      	muls	r0, r3
   239ca:	4b01      	ldr	r3, [pc, #4]	; (239d0 <ll_rl_timeout_set+0xc>)
   239cc:	6018      	str	r0, [r3, #0]
}
   239ce:	4770      	bx	lr
   239d0:	200036fc 	.word	0x200036fc

000239d4 <ull_filter_adv_scan_state_cb>:
	if (bm) {
   239d4:	b128      	cbz	r0, 239e2 <ull_filter_adv_scan_state_cb+0xe>
	k_delayed_work_submit(&rpa_work, rpa_timeout_ms);
   239d6:	4b04      	ldr	r3, [pc, #16]	; (239e8 <ull_filter_adv_scan_state_cb+0x14>)
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   239d8:	4904      	ldr	r1, [pc, #16]	; (239ec <ull_filter_adv_scan_state_cb+0x18>)
   239da:	681a      	ldr	r2, [r3, #0]
   239dc:	4804      	ldr	r0, [pc, #16]	; (239f0 <ull_filter_adv_scan_state_cb+0x1c>)
   239de:	f003 bd2d 	b.w	2743c <k_delayed_work_submit_to_queue>
	k_delayed_work_cancel(&rpa_work);
   239e2:	4802      	ldr	r0, [pc, #8]	; (239ec <ull_filter_adv_scan_state_cb+0x18>)
   239e4:	f009 bdbd 	b.w	2d562 <k_delayed_work_cancel>
   239e8:	200036fc 	.word	0x200036fc
   239ec:	20003700 	.word	0x20003700
   239f0:	20003b5c 	.word	0x20003b5c

000239f4 <ull_filter_adv_update>:
}

static void filter_clear(struct lll_filter *filter)
{
	filter->enable_bitmask = 0;
   239f4:	4a0d      	ldr	r2, [pc, #52]	; (23a2c <ull_filter_adv_update+0x38>)
{
   239f6:	b508      	push	{r3, lr}
	filter->enable_bitmask = 0;
   239f8:	2300      	movs	r3, #0
   239fa:	7013      	strb	r3, [r2, #0]
	filter->addr_type_bitmask = 0;
   239fc:	7053      	strb	r3, [r2, #1]
	if (IS_ENABLED(CONFIG_BT_OBSERVER) &&
   239fe:	b130      	cbz	r0, 23a0e <ull_filter_adv_update+0x1a>
	    adv_fp && !(ull_scan_filter_pol_get(0) & 0x1)) {
   23a00:	4618      	mov	r0, r3
   23a02:	f008 fb6d 	bl	2c0e0 <ull_scan_filter_pol_get>
   23a06:	07c3      	lsls	r3, r0, #31
   23a08:	d401      	bmi.n	23a0e <ull_filter_adv_update+0x1a>
		wl_update();
   23a0a:	f7ff fe9f 	bl	2374c <wl_update>
	filter->enable_bitmask = 0;
   23a0e:	4b08      	ldr	r3, [pc, #32]	; (23a30 <ull_filter_adv_update+0x3c>)
   23a10:	2000      	movs	r0, #0
   23a12:	7018      	strb	r0, [r3, #0]
	filter->addr_type_bitmask = 0;
   23a14:	7058      	strb	r0, [r3, #1]
	if (rl_enable &&
   23a16:	4b07      	ldr	r3, [pc, #28]	; (23a34 <ull_filter_adv_update+0x40>)
   23a18:	781b      	ldrb	r3, [r3, #0]
   23a1a:	b133      	cbz	r3, 23a2a <ull_filter_adv_update+0x36>
	    IS_ENABLED(CONFIG_BT_OBSERVER) && !ull_scan_is_enabled(0)) {
   23a1c:	f008 fb4d 	bl	2c0ba <ull_scan_is_enabled>
   23a20:	b918      	cbnz	r0, 23a2a <ull_filter_adv_update+0x36>
}
   23a22:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		rl_update();
   23a26:	f7ff be69 	b.w	236fc <rl_update>
}
   23a2a:	bd08      	pop	{r3, pc}
   23a2c:	20003fd6 	.word	0x20003fd6
   23a30:	20003f63 	.word	0x20003f63
   23a34:	20003f62 	.word	0x20003f62

00023a38 <ull_filter_scan_update>:
	filter->enable_bitmask = 0;
   23a38:	4a0d      	ldr	r2, [pc, #52]	; (23a70 <ull_filter_scan_update+0x38>)
{
   23a3a:	b508      	push	{r3, lr}
	filter->enable_bitmask = 0;
   23a3c:	2300      	movs	r3, #0
   23a3e:	7013      	strb	r3, [r2, #0]
	filter->addr_type_bitmask = 0;
   23a40:	7053      	strb	r3, [r2, #1]
	if ((scan_fp & 0x1) &&
   23a42:	07c2      	lsls	r2, r0, #31
   23a44:	d505      	bpl.n	23a52 <ull_filter_scan_update+0x1a>
	    (IS_ENABLED(CONFIG_BT_BROADCASTER) && !ull_adv_filter_pol_get(0))) {
   23a46:	4618      	mov	r0, r3
   23a48:	f008 fa4e 	bl	2bee8 <ull_adv_filter_pol_get>
	if ((scan_fp & 0x1) &&
   23a4c:	b908      	cbnz	r0, 23a52 <ull_filter_scan_update+0x1a>
		wl_update();
   23a4e:	f7ff fe7d 	bl	2374c <wl_update>
	filter->enable_bitmask = 0;
   23a52:	4b08      	ldr	r3, [pc, #32]	; (23a74 <ull_filter_scan_update+0x3c>)
   23a54:	2000      	movs	r0, #0
   23a56:	7018      	strb	r0, [r3, #0]
	filter->addr_type_bitmask = 0;
   23a58:	7058      	strb	r0, [r3, #1]
	if (rl_enable &&
   23a5a:	4b07      	ldr	r3, [pc, #28]	; (23a78 <ull_filter_scan_update+0x40>)
   23a5c:	781b      	ldrb	r3, [r3, #0]
   23a5e:	b133      	cbz	r3, 23a6e <ull_filter_scan_update+0x36>
	    (IS_ENABLED(CONFIG_BT_BROADCASTER) && !ull_adv_is_enabled(0))) {
   23a60:	f008 fa3b 	bl	2beda <ull_adv_is_enabled>
	if (rl_enable &&
   23a64:	b918      	cbnz	r0, 23a6e <ull_filter_scan_update+0x36>
}
   23a66:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		rl_update();
   23a6a:	f7ff be47 	b.w	236fc <rl_update>
}
   23a6e:	bd08      	pop	{r3, pc}
   23a70:	20003fd6 	.word	0x20003fd6
   23a74:	20003f63 	.word	0x20003f63
   23a78:	20003f62 	.word	0x20003f62

00023a7c <ull_filter_adv_pdu_update>:
	if (idx < ARRAY_SIZE(rl) && rl[idx].lirk) {
   23a7c:	2907      	cmp	r1, #7
{
   23a7e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   23a82:	4607      	mov	r7, r0
   23a84:	460d      	mov	r5, r1
   23a86:	4614      	mov	r4, r2
   23a88:	f102 0802 	add.w	r8, r2, #2
	if (idx < ARRAY_SIZE(rl) && rl[idx].lirk) {
   23a8c:	d837      	bhi.n	23afe <ull_filter_adv_pdu_update+0x82>
   23a8e:	2228      	movs	r2, #40	; 0x28
   23a90:	434a      	muls	r2, r1
   23a92:	4e29      	ldr	r6, [pc, #164]	; (23b38 <ull_filter_adv_pdu_update+0xbc>)
   23a94:	5cb2      	ldrb	r2, [r6, r2]
   23a96:	0711      	lsls	r1, r2, #28
   23a98:	d531      	bpl.n	23afe <ull_filter_adv_pdu_update+0x82>
		LL_ASSERT(rl[idx].rpas_ready);
   23a9a:	0793      	lsls	r3, r2, #30
   23a9c:	d408      	bmi.n	23ab0 <ull_filter_adv_pdu_update+0x34>
   23a9e:	4827      	ldr	r0, [pc, #156]	; (23b3c <ull_filter_adv_pdu_update+0xc0>)
   23aa0:	f004 fb50 	bl	28144 <printk>
   23aa4:	4040      	eors	r0, r0
   23aa6:	f380 8811 	msr	BASEPRI, r0
   23aaa:	f04f 0003 	mov.w	r0, #3
   23aae:	df02      	svc	2
		pdu->tx_addr = 1;
   23ab0:	7823      	ldrb	r3, [r4, #0]
   23ab2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   23ab6:	7023      	strb	r3, [r4, #0]
		memcpy(adva, rl[idx].local_rpa->val, BDADDR_SIZE);
   23ab8:	2328      	movs	r3, #40	; 0x28
   23aba:	fb03 6305 	mla	r3, r3, r5, r6
   23abe:	2206      	movs	r2, #6
   23ac0:	6a59      	ldr	r1, [r3, #36]	; 0x24
   23ac2:	4640      	mov	r0, r8
   23ac4:	f006 fcc3 	bl	2a44e <memcpy>
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
   23ac8:	7823      	ldrb	r3, [r4, #0]
   23aca:	f003 020f 	and.w	r2, r3, #15
   23ace:	2a01      	cmp	r2, #1
   23ad0:	d12f      	bne.n	23b32 <ull_filter_adv_pdu_update+0xb6>
		if (idx < ARRAY_SIZE(rl) && rl[idx].pirk) {
   23ad2:	2d07      	cmp	r5, #7
   23ad4:	f104 0008 	add.w	r0, r4, #8
   23ad8:	d81f      	bhi.n	23b1a <ull_filter_adv_pdu_update+0x9e>
   23ada:	2228      	movs	r2, #40	; 0x28
   23adc:	4916      	ldr	r1, [pc, #88]	; (23b38 <ull_filter_adv_pdu_update+0xbc>)
   23ade:	fb02 f605 	mul.w	r6, r2, r5
   23ae2:	5d8e      	ldrb	r6, [r1, r6]
   23ae4:	0776      	lsls	r6, r6, #29
   23ae6:	d518      	bpl.n	23b1a <ull_filter_adv_pdu_update+0x9e>
			       rl[idx].peer_rpa.val, BDADDR_SIZE);
   23ae8:	fb02 1105 	mla	r1, r2, r5, r1
			pdu->rx_addr = 1;
   23aec:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   23af0:	7023      	strb	r3, [r4, #0]
			memcpy(&pdu->direct_ind.tgt_addr[0],
   23af2:	2206      	movs	r2, #6
   23af4:	311e      	adds	r1, #30
}
   23af6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			memcpy(&pdu->direct_ind.tgt_addr[0],
   23afa:	f006 bca8 	b.w	2a44e <memcpy>
		pdu->tx_addr = adv->own_addr_type & 0x1;
   23afe:	f897 00da 	ldrb.w	r0, [r7, #218]	; 0xda
   23b02:	7823      	ldrb	r3, [r4, #0]
   23b04:	f000 0003 	and.w	r0, r0, #3
   23b08:	f360 1386 	bfi	r3, r0, #6, #1
   23b0c:	7023      	strb	r3, [r4, #0]
		ll_addr_get(adv->own_addr_type & 0x1, adva);
   23b0e:	4641      	mov	r1, r8
   23b10:	f000 0001 	and.w	r0, r0, #1
   23b14:	f7f8 fb9c 	bl	1c250 <ll_addr_get>
   23b18:	e7d6      	b.n	23ac8 <ull_filter_adv_pdu_update+0x4c>
			pdu->rx_addr = adv->id_addr_type;
   23b1a:	f897 30da 	ldrb.w	r3, [r7, #218]	; 0xda
   23b1e:	7822      	ldrb	r2, [r4, #0]
   23b20:	f3c3 0380 	ubfx	r3, r3, #2, #1
   23b24:	f363 12c7 	bfi	r2, r3, #7, #1
   23b28:	7022      	strb	r2, [r4, #0]
			memcpy(&pdu->direct_ind.tgt_addr[0],
   23b2a:	f107 01dc 	add.w	r1, r7, #220	; 0xdc
   23b2e:	2206      	movs	r2, #6
   23b30:	e7e1      	b.n	23af6 <ull_filter_adv_pdu_update+0x7a>
}
   23b32:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   23b36:	bf00      	nop
   23b38:	200035bc 	.word	0x200035bc
   23b3c:	000320d6 	.word	0x000320d6

00023b40 <ull_filter_rl_find>:
{
   23b40:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   23b44:	468a      	mov	sl, r1
	if (free) {
   23b46:	4614      	mov	r4, r2
   23b48:	b10a      	cbz	r2, 23b4e <ull_filter_rl_find+0xe>
		*free = FILTER_IDX_NONE;
   23b4a:	23ff      	movs	r3, #255	; 0xff
   23b4c:	7013      	strb	r3, [r2, #0]
		if (LIST_MATCH(rl, i, id_addr_type, id_addr)) {
   23b4e:	f8df 9058 	ldr.w	r9, [pc, #88]	; 23ba8 <ull_filter_rl_find+0x68>
{
   23b52:	2500      	movs	r5, #0
		if (LIST_MATCH(rl, i, id_addr_type, id_addr)) {
   23b54:	f000 0801 	and.w	r8, r0, #1
   23b58:	2628      	movs	r6, #40	; 0x28
   23b5a:	436e      	muls	r6, r5
   23b5c:	b2ef      	uxtb	r7, r5
   23b5e:	f819 3006 	ldrb.w	r3, [r9, r6]
   23b62:	07da      	lsls	r2, r3, #31
   23b64:	d51a      	bpl.n	23b9c <ull_filter_rl_find+0x5c>
   23b66:	f3c3 1380 	ubfx	r3, r3, #6, #1
   23b6a:	4543      	cmp	r3, r8
   23b6c:	d10f      	bne.n	23b8e <ull_filter_rl_find+0x4e>
   23b6e:	480d      	ldr	r0, [pc, #52]	; (23ba4 <ull_filter_rl_find+0x64>)
   23b70:	2206      	movs	r2, #6
   23b72:	4651      	mov	r1, sl
   23b74:	4430      	add	r0, r6
   23b76:	f006 fc43 	bl	2a400 <memcmp>
   23b7a:	b160      	cbz	r0, 23b96 <ull_filter_rl_find+0x56>
		} else if (free && !rl[i].taken && (*free == FILTER_IDX_NONE)) {
   23b7c:	b13c      	cbz	r4, 23b8e <ull_filter_rl_find+0x4e>
   23b7e:	f819 3006 	ldrb.w	r3, [r9, r6]
   23b82:	07db      	lsls	r3, r3, #31
   23b84:	d403      	bmi.n	23b8e <ull_filter_rl_find+0x4e>
   23b86:	7823      	ldrb	r3, [r4, #0]
   23b88:	2bff      	cmp	r3, #255	; 0xff
			*free = i;
   23b8a:	bf08      	it	eq
   23b8c:	7027      	strbeq	r7, [r4, #0]
   23b8e:	3501      	adds	r5, #1
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
   23b90:	2d08      	cmp	r5, #8
   23b92:	d1e1      	bne.n	23b58 <ull_filter_rl_find+0x18>
	return FILTER_IDX_NONE;
   23b94:	27ff      	movs	r7, #255	; 0xff
}
   23b96:	4638      	mov	r0, r7
   23b98:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		} else if (free && !rl[i].taken && (*free == FILTER_IDX_NONE)) {
   23b9c:	2c00      	cmp	r4, #0
   23b9e:	d1f2      	bne.n	23b86 <ull_filter_rl_find+0x46>
   23ba0:	e7f5      	b.n	23b8e <ull_filter_rl_find+0x4e>
   23ba2:	bf00      	nop
   23ba4:	200035bd 	.word	0x200035bd
   23ba8:	200035bc 	.word	0x200035bc

00023bac <ll_wl_add>:
{
   23bac:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   23bb0:	4607      	mov	r7, r0
	if (ull_adv_filter_pol_get(0)) {
   23bb2:	2000      	movs	r0, #0
   23bb4:	f008 f998 	bl	2bee8 <ull_adv_filter_pol_get>
   23bb8:	b118      	cbz	r0, 23bc2 <ll_wl_add+0x16>
		return BT_HCI_ERR_CMD_DISALLOWED;
   23bba:	200c      	movs	r0, #12
}
   23bbc:	b002      	add	sp, #8
   23bbe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (ull_scan_filter_pol_get(0) & 0x1) {
   23bc2:	f008 fa8d 	bl	2c0e0 <ull_scan_filter_pol_get>
   23bc6:	f010 0401 	ands.w	r4, r0, #1
   23bca:	d1f6      	bne.n	23bba <ll_wl_add+0xe>
	if (addr->type == ADDR_TYPE_ANON) {
   23bcc:	7838      	ldrb	r0, [r7, #0]
   23bce:	28ff      	cmp	r0, #255	; 0xff
   23bd0:	d104      	bne.n	23bdc <ll_wl_add+0x30>
		wl_anon = 1U;
   23bd2:	4b20      	ldr	r3, [pc, #128]	; (23c54 <ll_wl_add+0xa8>)
   23bd4:	2201      	movs	r2, #1
   23bd6:	701a      	strb	r2, [r3, #0]
		return 0;
   23bd8:	4620      	mov	r0, r4
   23bda:	e7ef      	b.n	23bbc <ll_wl_add+0x10>
	i = wl_find(id_addr->type, id_addr->a.val, &j);
   23bdc:	f107 0801 	add.w	r8, r7, #1
   23be0:	f10d 0207 	add.w	r2, sp, #7
   23be4:	4641      	mov	r1, r8
   23be6:	f7ff fd55 	bl	23694 <wl_find>
	if (i < ARRAY_SIZE(wl)) {
   23bea:	2807      	cmp	r0, #7
   23bec:	d92e      	bls.n	23c4c <ll_wl_add+0xa0>
	} else if (j >= ARRAY_SIZE(wl)) {
   23bee:	f89d 6007 	ldrb.w	r6, [sp, #7]
   23bf2:	2e07      	cmp	r6, #7
   23bf4:	d82c      	bhi.n	23c50 <ll_wl_add+0xa4>
	wl[i].id_addr_type = id_addr->type & 0x1;
   23bf6:	4d18      	ldr	r5, [pc, #96]	; (23c58 <ll_wl_add+0xac>)
   23bf8:	783a      	ldrb	r2, [r7, #0]
   23bfa:	f815 3036 	ldrb.w	r3, [r5, r6, lsl #3]
	bt_addr_copy(&wl[i].id_addr, &id_addr->a);
   23bfe:	eb05 00c6 	add.w	r0, r5, r6, lsl #3
	wl[i].id_addr_type = id_addr->type & 0x1;
   23c02:	f362 0341 	bfi	r3, r2, #1, #1
	memcpy(dst, src, sizeof(*dst));
   23c06:	4641      	mov	r1, r8
   23c08:	2206      	movs	r2, #6
   23c0a:	3002      	adds	r0, #2
   23c0c:	f805 3036 	strb.w	r3, [r5, r6, lsl #3]
   23c10:	f006 fc1d 	bl	2a44e <memcpy>
	j = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
   23c14:	4622      	mov	r2, r4
   23c16:	4641      	mov	r1, r8
   23c18:	7838      	ldrb	r0, [r7, #0]
   23c1a:	f7ff ff91 	bl	23b40 <ull_filter_rl_find>
	if (j < ARRAY_SIZE(rl)) {
   23c1e:	00f3      	lsls	r3, r6, #3
   23c20:	2807      	cmp	r0, #7
		wl[i].rl_idx = j;
   23c22:	442b      	add	r3, r5
	if (j < ARRAY_SIZE(rl)) {
   23c24:	d80f      	bhi.n	23c46 <ll_wl_add+0x9a>
		wl[i].rl_idx = j;
   23c26:	7058      	strb	r0, [r3, #1]
		rl[j].wl = 1U;
   23c28:	2328      	movs	r3, #40	; 0x28
   23c2a:	4a0c      	ldr	r2, [pc, #48]	; (23c5c <ll_wl_add+0xb0>)
   23c2c:	4358      	muls	r0, r3
   23c2e:	5c13      	ldrb	r3, [r2, r0]
   23c30:	f043 0320 	orr.w	r3, r3, #32
   23c34:	5413      	strb	r3, [r2, r0]
	wl[i].taken = 1U;
   23c36:	f815 3036 	ldrb.w	r3, [r5, r6, lsl #3]
   23c3a:	f043 0301 	orr.w	r3, r3, #1
   23c3e:	f805 3036 	strb.w	r3, [r5, r6, lsl #3]
	return wl_add(addr);
   23c42:	b2e0      	uxtb	r0, r4
   23c44:	e7ba      	b.n	23bbc <ll_wl_add+0x10>
		wl[i].rl_idx = FILTER_IDX_NONE;
   23c46:	22ff      	movs	r2, #255	; 0xff
   23c48:	705a      	strb	r2, [r3, #1]
   23c4a:	e7f4      	b.n	23c36 <ll_wl_add+0x8a>
		return BT_HCI_ERR_INVALID_PARAM;
   23c4c:	2412      	movs	r4, #18
   23c4e:	e7f8      	b.n	23c42 <ll_wl_add+0x96>
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
   23c50:	2407      	movs	r4, #7
   23c52:	e7f6      	b.n	23c42 <ll_wl_add+0x96>
   23c54:	20003fd5 	.word	0x20003fd5
   23c58:	20003f95 	.word	0x20003f95
   23c5c:	200035bc 	.word	0x200035bc

00023c60 <ll_rl_add>:
{
   23c60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   23c64:	b085      	sub	sp, #20
   23c66:	4680      	mov	r8, r0
   23c68:	4689      	mov	r9, r1
   23c6a:	4692      	mov	sl, r2
	if (!rl_access_check(false)) {
   23c6c:	f008 fee5 	bl	2ca3a <rl_access_check.constprop.2>
   23c70:	2800      	cmp	r0, #0
   23c72:	f000 8086 	beq.w	23d82 <ll_rl_add+0x122>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, &j);
   23c76:	4647      	mov	r7, r8
   23c78:	f10d 020f 	add.w	r2, sp, #15
   23c7c:	f817 0b01 	ldrb.w	r0, [r7], #1
   23c80:	4639      	mov	r1, r7
   23c82:	f7ff ff5d 	bl	23b40 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
   23c86:	2807      	cmp	r0, #7
   23c88:	d97d      	bls.n	23d86 <ll_rl_add+0x126>
	} else if (j >= ARRAY_SIZE(rl)) {
   23c8a:	f89d 500f 	ldrb.w	r5, [sp, #15]
   23c8e:	2d07      	cmp	r5, #7
   23c90:	d87b      	bhi.n	23d8a <ll_rl_add+0x12a>
	bt_addr_copy(&rl[i].id_addr, &id_addr->a);
   23c92:	eb05 0b85 	add.w	fp, r5, r5, lsl #2
   23c96:	4c3e      	ldr	r4, [pc, #248]	; (23d90 <ll_rl_add+0x130>)
   23c98:	ea4f 0bcb 	mov.w	fp, fp, lsl #3
	rl[i].id_addr_type = id_addr->type & 0x1;
   23c9c:	2628      	movs	r6, #40	; 0x28
   23c9e:	436e      	muls	r6, r5
	bt_addr_copy(&rl[i].id_addr, &id_addr->a);
   23ca0:	f10b 0001 	add.w	r0, fp, #1
   23ca4:	2206      	movs	r2, #6
   23ca6:	4639      	mov	r1, r7
   23ca8:	4420      	add	r0, r4
   23caa:	f006 fbd0 	bl	2a44e <memcpy>
	rl[i].id_addr_type = id_addr->type & 0x1;
   23cae:	f898 1000 	ldrb.w	r1, [r8]
   23cb2:	5da3      	ldrb	r3, [r4, r6]
   23cb4:	19a2      	adds	r2, r4, r6
   23cb6:	f361 1386 	bfi	r3, r1, #6, #1
	rl[i].pirk = mem_nz((u8_t *)pirk, 16);
   23cba:	4648      	mov	r0, r9
   23cbc:	2110      	movs	r1, #16
	rl[i].id_addr_type = id_addr->type & 0x1;
   23cbe:	9201      	str	r2, [sp, #4]
   23cc0:	55a3      	strb	r3, [r4, r6]
	rl[i].pirk = mem_nz((u8_t *)pirk, 16);
   23cc2:	f007 fe7a 	bl	2b9ba <mem_nz>
   23cc6:	5da3      	ldrb	r3, [r4, r6]
	rl[i].lirk = mem_nz((u8_t *)lirk, 16);
   23cc8:	2110      	movs	r1, #16
	rl[i].pirk = mem_nz((u8_t *)pirk, 16);
   23cca:	f360 0382 	bfi	r3, r0, #2, #1
	rl[i].lirk = mem_nz((u8_t *)lirk, 16);
   23cce:	4650      	mov	r0, sl
	rl[i].pirk = mem_nz((u8_t *)pirk, 16);
   23cd0:	55a3      	strb	r3, [r4, r6]
	rl[i].lirk = mem_nz((u8_t *)lirk, 16);
   23cd2:	f007 fe72 	bl	2b9ba <mem_nz>
   23cd6:	5da3      	ldrb	r3, [r4, r6]
	if (rl[i].pirk) {
   23cd8:	9a01      	ldr	r2, [sp, #4]
	rl[i].lirk = mem_nz((u8_t *)lirk, 16);
   23cda:	f000 0001 	and.w	r0, r0, #1
   23cde:	f360 03c3 	bfi	r3, r0, #3, #1
	if (rl[i].pirk) {
   23ce2:	f013 0f04 	tst.w	r3, #4
	rl[i].lirk = mem_nz((u8_t *)lirk, 16);
   23ce6:	55a3      	strb	r3, [r4, r6]
	if (rl[i].pirk) {
   23ce8:	d137      	bne.n	23d5a <ll_rl_add+0xfa>
	if (rl[i].lirk) {
   23cea:	b158      	cbz	r0, 23d04 <ll_rl_add+0xa4>
		memcpy(rl[i].local_irk, lirk, 16);
   23cec:	f10b 0007 	add.w	r0, fp, #7
   23cf0:	2210      	movs	r2, #16
   23cf2:	4651      	mov	r1, sl
   23cf4:	4420      	add	r0, r4
   23cf6:	f006 fbaa 	bl	2a44e <memcpy>
		rl[i].local_rpa = NULL;
   23cfa:	2328      	movs	r3, #40	; 0x28
   23cfc:	fb03 4305 	mla	r3, r3, r5, r4
   23d00:	2200      	movs	r2, #0
   23d02:	625a      	str	r2, [r3, #36]	; 0x24
	memset(rl[i].curr_rpa.val, 0x00, sizeof(rl[i].curr_rpa));
   23d04:	2628      	movs	r6, #40	; 0x28
   23d06:	436e      	muls	r6, r5
   23d08:	f10b 0018 	add.w	r0, fp, #24
   23d0c:	2206      	movs	r2, #6
   23d0e:	2100      	movs	r1, #0
   23d10:	4420      	add	r0, r4
   23d12:	f006 fbc6 	bl	2a4a2 <memset>
	rl[i].rpas_ready = 0U;
   23d16:	5da3      	ldrb	r3, [r4, r6]
   23d18:	f023 0312 	bic.w	r3, r3, #18
   23d1c:	55a3      	strb	r3, [r4, r6]
	j = wl_find(id_addr->type, id_addr->a.val, NULL);
   23d1e:	2200      	movs	r2, #0
   23d20:	4639      	mov	r1, r7
   23d22:	f898 0000 	ldrb.w	r0, [r8]
   23d26:	f7ff fcb5 	bl	23694 <wl_find>
	if (j < ARRAY_SIZE(wl)) {
   23d2a:	2807      	cmp	r0, #7
   23d2c:	5da3      	ldrb	r3, [r4, r6]
		wl[j].rl_idx = i;
   23d2e:	bf9d      	ittte	ls
   23d30:	4a18      	ldrls	r2, [pc, #96]	; (23d94 <ll_rl_add+0x134>)
		rl[i].wl = 1U;
   23d32:	f043 0320 	orrls.w	r3, r3, #32
		wl[j].rl_idx = i;
   23d36:	eb02 02c0 	addls.w	r2, r2, r0, lsl #3
		rl[i].wl = 0U;
   23d3a:	f36f 1345 	bfchi	r3, #5, #1
   23d3e:	55a3      	strb	r3, [r4, r6]
	rl[i].taken = 1U;
   23d40:	f04f 0328 	mov.w	r3, #40	; 0x28
		wl[j].rl_idx = i;
   23d44:	bf98      	it	ls
   23d46:	7055      	strbls	r5, [r2, #1]
	rl[i].taken = 1U;
   23d48:	435d      	muls	r5, r3
	return 0;
   23d4a:	2000      	movs	r0, #0
	rl[i].taken = 1U;
   23d4c:	5d63      	ldrb	r3, [r4, r5]
   23d4e:	f043 0301 	orr.w	r3, r3, #1
   23d52:	5563      	strb	r3, [r4, r5]
}
   23d54:	b005      	add	sp, #20
   23d56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		rl[i].pirk_idx = peer_irk_count;
   23d5a:	4b0f      	ldr	r3, [pc, #60]	; (23d98 <ll_rl_add+0x138>)
   23d5c:	7819      	ldrb	r1, [r3, #0]
   23d5e:	75d1      	strb	r1, [r2, #23]
		peer_irk_rl_ids[peer_irk_count] = i;
   23d60:	4a0e      	ldr	r2, [pc, #56]	; (23d9c <ll_rl_add+0x13c>)
   23d62:	5455      	strb	r5, [r2, r1]
		sys_memcpy_swap(peer_irks[peer_irk_count++], pirk, 16);
   23d64:	1c4a      	adds	r2, r1, #1
   23d66:	701a      	strb	r2, [r3, #0]
	for (; length > 0; length--) {
   23d68:	4b0d      	ldr	r3, [pc, #52]	; (23da0 <ll_rl_add+0x140>)
   23d6a:	eb03 1301 	add.w	r3, r3, r1, lsl #4
   23d6e:	f109 0210 	add.w	r2, r9, #16
   23d72:	3b01      	subs	r3, #1
		*pdst++ = *psrc--;
   23d74:	f812 1d01 	ldrb.w	r1, [r2, #-1]!
   23d78:	f803 1f01 	strb.w	r1, [r3, #1]!
	for (; length > 0; length--) {
   23d7c:	454a      	cmp	r2, r9
   23d7e:	d1f9      	bne.n	23d74 <ll_rl_add+0x114>
   23d80:	e7b3      	b.n	23cea <ll_rl_add+0x8a>
		return BT_HCI_ERR_CMD_DISALLOWED;
   23d82:	200c      	movs	r0, #12
   23d84:	e7e6      	b.n	23d54 <ll_rl_add+0xf4>
		return BT_HCI_ERR_INVALID_PARAM;
   23d86:	2012      	movs	r0, #18
   23d88:	e7e4      	b.n	23d54 <ll_rl_add+0xf4>
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
   23d8a:	2007      	movs	r0, #7
   23d8c:	e7e2      	b.n	23d54 <ll_rl_add+0xf4>
   23d8e:	bf00      	nop
   23d90:	200035bc 	.word	0x200035bc
   23d94:	20003f95 	.word	0x20003f95
   23d98:	20003ed9 	.word	0x20003ed9
   23d9c:	20003eda 	.word	0x20003eda
   23da0:	20003ee2 	.word	0x20003ee2

00023da4 <ll_rl_remove>:
{
   23da4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   23da8:	4682      	mov	sl, r0
	if (!rl_access_check(false)) {
   23daa:	f008 fe46 	bl	2ca3a <rl_access_check.constprop.2>
   23dae:	2800      	cmp	r0, #0
   23db0:	d057      	beq.n	23e62 <ll_rl_remove+0xbe>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
   23db2:	4657      	mov	r7, sl
   23db4:	2200      	movs	r2, #0
   23db6:	f817 0b01 	ldrb.w	r0, [r7], #1
   23dba:	4639      	mov	r1, r7
   23dbc:	f7ff fec0 	bl	23b40 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
   23dc0:	2807      	cmp	r0, #7
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
   23dc2:	4681      	mov	r9, r0
	if (i < ARRAY_SIZE(rl)) {
   23dc4:	d84f      	bhi.n	23e66 <ll_rl_remove+0xc2>
		if (rl[i].pirk) {
   23dc6:	f04f 0b28 	mov.w	fp, #40	; 0x28
   23dca:	4c28      	ldr	r4, [pc, #160]	; (23e6c <ll_rl_remove+0xc8>)
   23dcc:	fb0b f300 	mul.w	r3, fp, r0
   23dd0:	18e2      	adds	r2, r4, r3
   23dd2:	5ce3      	ldrb	r3, [r4, r3]
   23dd4:	075b      	lsls	r3, r3, #29
   23dd6:	d527      	bpl.n	23e28 <ll_rl_remove+0x84>
			u8_t pi = rl[i].pirk_idx, pj = peer_irk_count - 1;
   23dd8:	4e25      	ldr	r6, [pc, #148]	; (23e70 <ll_rl_remove+0xcc>)
   23dda:	7835      	ldrb	r5, [r6, #0]
   23ddc:	3d01      	subs	r5, #1
			if (pj && pi != pj) {
   23dde:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
   23de2:	d01e      	beq.n	23e22 <ll_rl_remove+0x7e>
			u8_t pi = rl[i].pirk_idx, pj = peer_irk_count - 1;
   23de4:	f892 8017 	ldrb.w	r8, [r2, #23]
			if (pj && pi != pj) {
   23de8:	45a8      	cmp	r8, r5
   23dea:	d01a      	beq.n	23e22 <ll_rl_remove+0x7e>
				memcpy(peer_irks[pi], peer_irks[pj], 16);
   23dec:	4821      	ldr	r0, [pc, #132]	; (23e74 <ll_rl_remove+0xd0>)
   23dee:	2210      	movs	r2, #16
   23df0:	eb00 1105 	add.w	r1, r0, r5, lsl #4
   23df4:	eb00 1008 	add.w	r0, r0, r8, lsl #4
   23df8:	f006 fb29 	bl	2a44e <memcpy>
   23dfc:	2300      	movs	r3, #0
					if (rl[k].taken && rl[k].pirk &&
   23dfe:	fb0b f103 	mul.w	r1, fp, r3
   23e02:	1862      	adds	r2, r4, r1
   23e04:	5c61      	ldrb	r1, [r4, r1]
   23e06:	f011 0f01 	tst.w	r1, #1
   23e0a:	b2d8      	uxtb	r0, r3
   23e0c:	d025      	beq.n	23e5a <ll_rl_remove+0xb6>
   23e0e:	0749      	lsls	r1, r1, #29
   23e10:	d523      	bpl.n	23e5a <ll_rl_remove+0xb6>
   23e12:	7dd1      	ldrb	r1, [r2, #23]
   23e14:	42a9      	cmp	r1, r5
   23e16:	d120      	bne.n	23e5a <ll_rl_remove+0xb6>
						peer_irk_rl_ids[pi] = k;
   23e18:	4b17      	ldr	r3, [pc, #92]	; (23e78 <ll_rl_remove+0xd4>)
						rl[k].pirk_idx = pi;
   23e1a:	f882 8017 	strb.w	r8, [r2, #23]
						peer_irk_rl_ids[pi] = k;
   23e1e:	f803 0008 	strb.w	r0, [r3, r8]
			peer_irk_count--;
   23e22:	7833      	ldrb	r3, [r6, #0]
   23e24:	3b01      	subs	r3, #1
   23e26:	7033      	strb	r3, [r6, #0]
		j = wl_find(id_addr->type, id_addr->a.val, NULL);
   23e28:	2200      	movs	r2, #0
   23e2a:	4639      	mov	r1, r7
   23e2c:	f89a 0000 	ldrb.w	r0, [sl]
   23e30:	f7ff fc30 	bl	23694 <wl_find>
		if (j < ARRAY_SIZE(wl)) {
   23e34:	2807      	cmp	r0, #7
			wl[j].rl_idx = FILTER_IDX_NONE;
   23e36:	bf9c      	itt	ls
   23e38:	4b10      	ldrls	r3, [pc, #64]	; (23e7c <ll_rl_remove+0xd8>)
   23e3a:	eb03 03c0 	addls.w	r3, r3, r0, lsl #3
		rl[i].taken = 0U;
   23e3e:	f04f 0028 	mov.w	r0, #40	; 0x28
   23e42:	fb00 f009 	mul.w	r0, r0, r9
			wl[j].rl_idx = FILTER_IDX_NONE;
   23e46:	bf9c      	itt	ls
   23e48:	22ff      	movls	r2, #255	; 0xff
   23e4a:	705a      	strbls	r2, [r3, #1]
		rl[i].taken = 0U;
   23e4c:	5c23      	ldrb	r3, [r4, r0]
   23e4e:	f36f 0300 	bfc	r3, #0, #1
   23e52:	5423      	strb	r3, [r4, r0]
		return 0;
   23e54:	2000      	movs	r0, #0
}
   23e56:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   23e5a:	3301      	adds	r3, #1
				for (k = 0U;
   23e5c:	2b08      	cmp	r3, #8
   23e5e:	d1ce      	bne.n	23dfe <ll_rl_remove+0x5a>
   23e60:	e7df      	b.n	23e22 <ll_rl_remove+0x7e>
		return BT_HCI_ERR_CMD_DISALLOWED;
   23e62:	200c      	movs	r0, #12
   23e64:	e7f7      	b.n	23e56 <ll_rl_remove+0xb2>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
   23e66:	2002      	movs	r0, #2
   23e68:	e7f5      	b.n	23e56 <ll_rl_remove+0xb2>
   23e6a:	bf00      	nop
   23e6c:	200035bc 	.word	0x200035bc
   23e70:	20003ed9 	.word	0x20003ed9
   23e74:	20003ee2 	.word	0x20003ee2
   23e78:	20003eda 	.word	0x20003eda
   23e7c:	20003f95 	.word	0x20003f95

00023e80 <ll_rl_crpa_set>:
{
   23e80:	b570      	push	{r4, r5, r6, lr}
	if ((crpa[5] & 0xc0) == 0x40) {
   23e82:	795c      	ldrb	r4, [r3, #5]
   23e84:	f004 04c0 	and.w	r4, r4, #192	; 0xc0
   23e88:	2c40      	cmp	r4, #64	; 0x40
{
   23e8a:	461d      	mov	r5, r3
	if ((crpa[5] & 0xc0) == 0x40) {
   23e8c:	d117      	bne.n	23ebe <ll_rl_crpa_set+0x3e>
		if (id_addr) {
   23e8e:	b119      	cbz	r1, 23e98 <ll_rl_crpa_set+0x18>
			rl_idx = ull_filter_rl_find(id_addr_type, id_addr, NULL);
   23e90:	2200      	movs	r2, #0
   23e92:	f7ff fe55 	bl	23b40 <ull_filter_rl_find>
   23e96:	4602      	mov	r2, r0
		if (rl_idx < ARRAY_SIZE(rl) && rl[rl_idx].taken) {
   23e98:	2a07      	cmp	r2, #7
   23e9a:	d810      	bhi.n	23ebe <ll_rl_crpa_set+0x3e>
   23e9c:	2128      	movs	r1, #40	; 0x28
   23e9e:	4c08      	ldr	r4, [pc, #32]	; (23ec0 <ll_rl_crpa_set+0x40>)
   23ea0:	fb01 f302 	mul.w	r3, r1, r2
   23ea4:	5ce3      	ldrb	r3, [r4, r3]
   23ea6:	07db      	lsls	r3, r3, #31
   23ea8:	d509      	bpl.n	23ebe <ll_rl_crpa_set+0x3e>
			memcpy(rl[rl_idx].curr_rpa.val, crpa,
   23eaa:	2018      	movs	r0, #24
   23eac:	fb11 0002 	smlabb	r0, r1, r2, r0
   23eb0:	4420      	add	r0, r4
   23eb2:	4629      	mov	r1, r5
   23eb4:	2206      	movs	r2, #6
}
   23eb6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			memcpy(rl[rl_idx].curr_rpa.val, crpa,
   23eba:	f006 bac8 	b.w	2a44e <memcpy>
}
   23ebe:	bd70      	pop	{r4, r5, r6, pc}
   23ec0:	200035bc 	.word	0x200035bc

00023ec4 <ll_rl_crpa_get>:
{
   23ec4:	b538      	push	{r3, r4, r5, lr}
   23ec6:	460d      	mov	r5, r1
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
   23ec8:	4601      	mov	r1, r0
   23eca:	2200      	movs	r2, #0
   23ecc:	f811 0b01 	ldrb.w	r0, [r1], #1
   23ed0:	f7ff fe36 	bl	23b40 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl) &&
   23ed4:	2807      	cmp	r0, #7
   23ed6:	d901      	bls.n	23edc <ll_rl_crpa_get+0x18>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
   23ed8:	2002      	movs	r0, #2
}
   23eda:	bd38      	pop	{r3, r4, r5, pc}
	    mem_nz(rl[i].curr_rpa.val, sizeof(rl[i].curr_rpa.val))) {
   23edc:	2428      	movs	r4, #40	; 0x28
   23ede:	2318      	movs	r3, #24
   23ee0:	fb14 3000 	smlabb	r0, r4, r0, r3
   23ee4:	4c07      	ldr	r4, [pc, #28]	; (23f04 <ll_rl_crpa_get+0x40>)
   23ee6:	4404      	add	r4, r0
   23ee8:	2106      	movs	r1, #6
   23eea:	4620      	mov	r0, r4
   23eec:	f007 fd65 	bl	2b9ba <mem_nz>
	if (i < ARRAY_SIZE(rl) &&
   23ef0:	2800      	cmp	r0, #0
   23ef2:	d0f1      	beq.n	23ed8 <ll_rl_crpa_get+0x14>
   23ef4:	2206      	movs	r2, #6
   23ef6:	4621      	mov	r1, r4
   23ef8:	4628      	mov	r0, r5
   23efa:	f006 faa8 	bl	2a44e <memcpy>
		return 0;
   23efe:	2000      	movs	r0, #0
   23f00:	e7eb      	b.n	23eda <ll_rl_crpa_get+0x16>
   23f02:	bf00      	nop
   23f04:	200035bc 	.word	0x200035bc

00023f08 <ll_rl_lrpa_get>:
{
   23f08:	b510      	push	{r4, lr}
   23f0a:	460c      	mov	r4, r1
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
   23f0c:	4601      	mov	r1, r0
   23f0e:	2200      	movs	r2, #0
   23f10:	f811 0b01 	ldrb.w	r0, [r1], #1
   23f14:	f7ff fe14 	bl	23b40 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
   23f18:	2807      	cmp	r0, #7
   23f1a:	d80a      	bhi.n	23f32 <ll_rl_lrpa_get+0x2a>
		bt_addr_copy(lrpa, rl[i].local_rpa);
   23f1c:	4b06      	ldr	r3, [pc, #24]	; (23f38 <ll_rl_lrpa_get+0x30>)
   23f1e:	2228      	movs	r2, #40	; 0x28
   23f20:	fb02 3000 	mla	r0, r2, r0, r3
   23f24:	2206      	movs	r2, #6
   23f26:	6a41      	ldr	r1, [r0, #36]	; 0x24
   23f28:	4620      	mov	r0, r4
   23f2a:	f006 fa90 	bl	2a44e <memcpy>
		return 0;
   23f2e:	2000      	movs	r0, #0
}
   23f30:	bd10      	pop	{r4, pc}
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
   23f32:	2002      	movs	r0, #2
   23f34:	e7fc      	b.n	23f30 <ll_rl_lrpa_get+0x28>
   23f36:	bf00      	nop
   23f38:	200035bc 	.word	0x200035bc

00023f3c <ll_priv_mode_set>:
{
   23f3c:	b538      	push	{r3, r4, r5, lr}
   23f3e:	4605      	mov	r5, r0
   23f40:	460c      	mov	r4, r1
	if (!rl_access_check(false)) {
   23f42:	f008 fd7a 	bl	2ca3a <rl_access_check.constprop.2>
   23f46:	b1f0      	cbz	r0, 23f86 <ll_priv_mode_set+0x4a>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
   23f48:	4629      	mov	r1, r5
   23f4a:	2200      	movs	r2, #0
   23f4c:	f811 0b01 	ldrb.w	r0, [r1], #1
   23f50:	f7ff fdf6 	bl	23b40 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
   23f54:	2807      	cmp	r0, #7
   23f56:	d818      	bhi.n	23f8a <ll_priv_mode_set+0x4e>
		switch (mode) {
   23f58:	b124      	cbz	r4, 23f64 <ll_priv_mode_set+0x28>
   23f5a:	2c01      	cmp	r4, #1
   23f5c:	d00a      	beq.n	23f74 <ll_priv_mode_set+0x38>
			return BT_HCI_ERR_INVALID_PARAM;
   23f5e:	2412      	movs	r4, #18
}
   23f60:	4620      	mov	r0, r4
   23f62:	bd38      	pop	{r3, r4, r5, pc}
			rl[i].dev = 0U;
   23f64:	2328      	movs	r3, #40	; 0x28
   23f66:	4a0a      	ldr	r2, [pc, #40]	; (23f90 <ll_priv_mode_set+0x54>)
   23f68:	4358      	muls	r0, r3
   23f6a:	5c13      	ldrb	r3, [r2, r0]
   23f6c:	f364 1304 	bfi	r3, r4, #4, #1
   23f70:	5413      	strb	r3, [r2, r0]
			break;
   23f72:	e7f5      	b.n	23f60 <ll_priv_mode_set+0x24>
			rl[i].dev = 1U;
   23f74:	2328      	movs	r3, #40	; 0x28
   23f76:	4a06      	ldr	r2, [pc, #24]	; (23f90 <ll_priv_mode_set+0x54>)
   23f78:	4358      	muls	r0, r3
	return 0;
   23f7a:	2400      	movs	r4, #0
			rl[i].dev = 1U;
   23f7c:	5c13      	ldrb	r3, [r2, r0]
   23f7e:	f043 0310 	orr.w	r3, r3, #16
   23f82:	5413      	strb	r3, [r2, r0]
			break;
   23f84:	e7ec      	b.n	23f60 <ll_priv_mode_set+0x24>
		return BT_HCI_ERR_CMD_DISALLOWED;
   23f86:	240c      	movs	r4, #12
   23f88:	e7ea      	b.n	23f60 <ll_priv_mode_set+0x24>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   23f8a:	2402      	movs	r4, #2
   23f8c:	e7e8      	b.n	23f60 <ll_priv_mode_set+0x24>
   23f8e:	bf00      	nop
   23f90:	200035bc 	.word	0x200035bc

00023f94 <ull_filter_rpa_update>:
{
   23f94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   23f98:	4681      	mov	r9, r0
   23f9a:	b087      	sub	sp, #28
	return z_impl_k_uptime_get();
   23f9c:	f009 fb3a 	bl	2d614 <z_impl_k_uptime_get>
   23fa0:	4680      	mov	r8, r0
   23fa2:	468a      	mov	sl, r1
	bool all = timeout || (rpa_last_ms == -1) ||
   23fa4:	f1b9 0f00 	cmp.w	r9, #0
   23fa8:	f040 80cb 	bne.w	24142 <ull_filter_rpa_update+0x1ae>
   23fac:	4b66      	ldr	r3, [pc, #408]	; (24148 <ull_filter_rpa_update+0x1b4>)
   23fae:	e9d3 2300 	ldrd	r2, r3, [r3]
   23fb2:	1c59      	adds	r1, r3, #1
   23fb4:	bf08      	it	eq
   23fb6:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
   23fba:	f000 80c2 	beq.w	24142 <ull_filter_rpa_update+0x1ae>
		   (now - rpa_last_ms >= rpa_timeout_ms);
   23fbe:	ebb8 0402 	subs.w	r4, r8, r2
   23fc2:	eb6a 0503 	sbc.w	r5, sl, r3
   23fc6:	4b61      	ldr	r3, [pc, #388]	; (2414c <ull_filter_rpa_update+0x1b8>)
   23fc8:	681a      	ldr	r2, [r3, #0]
   23fca:	2300      	movs	r3, #0
	bool all = timeout || (rpa_last_ms == -1) ||
   23fcc:	4294      	cmp	r4, r2
   23fce:	eb75 0303 	sbcs.w	r3, r5, r3
   23fd2:	bfac      	ite	ge
   23fd4:	2701      	movge	r7, #1
   23fd6:	2700      	movlt	r7, #0
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
   23fd8:	4d5d      	ldr	r5, [pc, #372]	; (24150 <ull_filter_rpa_update+0x1bc>)
				LL_ASSERT(!err);
   23fda:	f8df b180 	ldr.w	fp, [pc, #384]	; 2415c <ull_filter_rpa_update+0x1c8>
	bool all = timeout || (rpa_last_ms == -1) ||
   23fde:	2400      	movs	r4, #0
   23fe0:	462e      	mov	r6, r5
		if ((rl[i].taken) && (all || !rl[i].rpas_ready)) {
   23fe2:	2328      	movs	r3, #40	; 0x28
   23fe4:	4363      	muls	r3, r4
   23fe6:	5cf3      	ldrb	r3, [r6, r3]
   23fe8:	07da      	lsls	r2, r3, #31
   23fea:	d549      	bpl.n	24080 <ull_filter_rpa_update+0xec>
   23fec:	b90f      	cbnz	r7, 23ff2 <ull_filter_rpa_update+0x5e>
   23fee:	0798      	lsls	r0, r3, #30
   23ff0:	d446      	bmi.n	24080 <ull_filter_rpa_update+0xec>
			if (rl[i].pirk) {
   23ff2:	2328      	movs	r3, #40	; 0x28
   23ff4:	4363      	muls	r3, r4
   23ff6:	5cf3      	ldrb	r3, [r6, r3]
   23ff8:	0759      	lsls	r1, r3, #29
   23ffa:	d51b      	bpl.n	24034 <ull_filter_rpa_update+0xa0>
				sys_memcpy_swap(irk, peer_irks[rl[i].pirk_idx],
   23ffc:	4a55      	ldr	r2, [pc, #340]	; (24154 <ull_filter_rpa_update+0x1c0>)
   23ffe:	7deb      	ldrb	r3, [r5, #23]
   24000:	a902      	add	r1, sp, #8
   24002:	eb02 1303 	add.w	r3, r2, r3, lsl #4
   24006:	f103 0210 	add.w	r2, r3, #16
   2400a:	4608      	mov	r0, r1
		*pdst++ = *psrc--;
   2400c:	f812 cd01 	ldrb.w	ip, [r2, #-1]!
   24010:	f801 cb01 	strb.w	ip, [r1], #1
	for (; length > 0; length--) {
   24014:	429a      	cmp	r2, r3
   24016:	d1f9      	bne.n	2400c <ull_filter_rpa_update+0x78>
				err = bt_rpa_create(irk, &rl[i].peer_rpa);
   24018:	f105 011e 	add.w	r1, r5, #30
   2401c:	f006 fb1c 	bl	2a658 <bt_rpa_create>
				LL_ASSERT(!err);
   24020:	b140      	cbz	r0, 24034 <ull_filter_rpa_update+0xa0>
   24022:	4658      	mov	r0, fp
   24024:	f004 f88e 	bl	28144 <printk>
   24028:	4040      	eors	r0, r0
   2402a:	f380 8811 	msr	BASEPRI, r0
   2402e:	f04f 0003 	mov.w	r0, #3
   24032:	df02      	svc	2
			if (rl[i].lirk) {
   24034:	2328      	movs	r3, #40	; 0x28
   24036:	4363      	muls	r3, r4
   24038:	5cf3      	ldrb	r3, [r6, r3]
   2403a:	071a      	lsls	r2, r3, #28
   2403c:	d51a      	bpl.n	24074 <ull_filter_rpa_update+0xe0>
				err = bt_rpa_create(rl[i].local_irk, &rpa);
   2403e:	a902      	add	r1, sp, #8
   24040:	1de8      	adds	r0, r5, #7
   24042:	f006 fb09 	bl	2a658 <bt_rpa_create>
				LL_ASSERT(!err);
   24046:	b140      	cbz	r0, 2405a <ull_filter_rpa_update+0xc6>
   24048:	4658      	mov	r0, fp
   2404a:	f004 f87b 	bl	28144 <printk>
   2404e:	4040      	eors	r0, r0
   24050:	f380 8811 	msr	BASEPRI, r0
   24054:	f04f 0003 	mov.w	r0, #3
   24058:	df02      	svc	2
				rl[i].local_rpa = &rpa;
   2405a:	ab02      	add	r3, sp, #8
   2405c:	626b      	str	r3, [r5, #36]	; 0x24
				bt_addr_copy(&local_rpas[i], &rpa);
   2405e:	4b3e      	ldr	r3, [pc, #248]	; (24158 <ull_filter_rpa_update+0x1c4>)
   24060:	2206      	movs	r2, #6
   24062:	fb02 3304 	mla	r3, r2, r4, r3
   24066:	4618      	mov	r0, r3
   24068:	a902      	add	r1, sp, #8
   2406a:	9301      	str	r3, [sp, #4]
   2406c:	f006 f9ef 	bl	2a44e <memcpy>
				rl[i].local_rpa = &local_rpas[i];
   24070:	9b01      	ldr	r3, [sp, #4]
   24072:	626b      	str	r3, [r5, #36]	; 0x24
			rl[i].rpas_ready = 1U;
   24074:	2328      	movs	r3, #40	; 0x28
   24076:	4363      	muls	r3, r4
   24078:	5cf2      	ldrb	r2, [r6, r3]
   2407a:	f042 0202 	orr.w	r2, r2, #2
   2407e:	54f2      	strb	r2, [r6, r3]
   24080:	3401      	adds	r4, #1
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
   24082:	2c08      	cmp	r4, #8
   24084:	f105 0528 	add.w	r5, r5, #40	; 0x28
   24088:	d1ab      	bne.n	23fe2 <ull_filter_rpa_update+0x4e>
	if (all) {
   2408a:	b117      	cbz	r7, 24092 <ull_filter_rpa_update+0xfe>
		rpa_last_ms = now;
   2408c:	4b2e      	ldr	r3, [pc, #184]	; (24148 <ull_filter_rpa_update+0x1b4>)
   2408e:	e9c3 8a00 	strd	r8, sl, [r3]
	if (timeout) {
   24092:	f1b9 0f00 	cmp.w	r9, #0
   24096:	d051      	beq.n	2413c <ull_filter_rpa_update+0x1a8>
		adv = ull_adv_is_enabled_get(0);
   24098:	2000      	movs	r0, #0
   2409a:	f7fb f987 	bl	1f3ac <ull_adv_is_enabled_get>
		if (adv) {
   2409e:	4605      	mov	r5, r0
   240a0:	2800      	cmp	r0, #0
   240a2:	d04b      	beq.n	2413c <ull_filter_rpa_update+0x1a8>
	if (adv->own_addr_type != BT_ADDR_LE_PUBLIC_ID &&
   240a4:	f890 00da 	ldrb.w	r0, [r0, #218]	; 0xda
   240a8:	0783      	lsls	r3, r0, #30
   240aa:	d547      	bpl.n	2413c <ull_filter_rpa_update+0x1a8>
	rl_idx = ull_filter_rl_find(adv->id_addr_type, adv->id_addr, NULL);
   240ac:	f105 01dc 	add.w	r1, r5, #220	; 0xdc
   240b0:	2200      	movs	r2, #0
   240b2:	f3c0 0080 	ubfx	r0, r0, #2, #1
   240b6:	f7ff fd43 	bl	23b40 <ull_filter_rl_find>
	if (rl_idx >= ARRAY_SIZE(rl)) {
   240ba:	2807      	cmp	r0, #7
	rl_idx = ull_filter_rl_find(adv->id_addr_type, adv->id_addr, NULL);
   240bc:	4601      	mov	r1, r0
	if (rl_idx >= ARRAY_SIZE(rl)) {
   240be:	d83d      	bhi.n	2413c <ull_filter_rpa_update+0x1a8>
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   240c0:	f895 402c 	ldrb.w	r4, [r5, #44]	; 0x2c
   240c4:	2311      	movs	r3, #17
   240c6:	2627      	movs	r6, #39	; 0x27
   240c8:	fb16 3604 	smlabb	r6, r6, r4, r3
	if (pdu->first == pdu->last) {
   240cc:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   240d0:	f105 0c1c 	add.w	ip, r5, #28
	if (pdu->first == pdu->last) {
   240d4:	42a3      	cmp	r3, r4
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
   240d6:	eb0c 0906 	add.w	r9, ip, r6
	if (pdu->first == pdu->last) {
   240da:	d104      	bne.n	240e6 <ull_filter_rpa_update+0x152>
		last = pdu->last + 1;
   240dc:	3401      	adds	r4, #1
   240de:	b2e4      	uxtb	r4, r4
			last = 0U;
   240e0:	2c02      	cmp	r4, #2
   240e2:	bf08      	it	eq
   240e4:	2400      	moveq	r4, #0
	return (void *)pdu->pdu[last];
   240e6:	2027      	movs	r0, #39	; 0x27
   240e8:	2302      	movs	r3, #2
   240ea:	fb10 3304 	smlabb	r3, r0, r4, r3
   240ee:	f105 022b 	add.w	r2, r5, #43	; 0x2b
	pdu->type = prev->type;
   240f2:	f81c 0006 	ldrb.w	r0, [ip, r6]
   240f6:	5cd7      	ldrb	r7, [r2, r3]
   240f8:	f360 0703 	bfi	r7, r0, #0, #4
	pdu->rfu = 0;
   240fc:	f36f 1704 	bfc	r7, #4, #1
   24100:	54d7      	strb	r7, [r2, r3]
		pdu->chan_sel = prev->chan_sel;
   24102:	f81c 6006 	ldrb.w	r6, [ip, r6]
   24106:	b2f8      	uxtb	r0, r7
   24108:	f3c6 1640 	ubfx	r6, r6, #5, #1
   2410c:	eb02 0803 	add.w	r8, r2, r3
   24110:	f366 1045 	bfi	r0, r6, #5, #1
   24114:	54d0      	strb	r0, [r2, r3]
	ull_filter_adv_pdu_update(adv, rl_idx, pdu);
   24116:	4642      	mov	r2, r8
   24118:	4628      	mov	r0, r5
   2411a:	f7ff fcaf 	bl	23a7c <ull_filter_adv_pdu_update>
	       prev->len - BDADDR_SIZE);
   2411e:	f899 2001 	ldrb.w	r2, [r9, #1]
	memcpy(&pdu->adv_ind.data[0], &prev->adv_ind.data[0],
   24122:	f109 0108 	add.w	r1, r9, #8
   24126:	3a06      	subs	r2, #6
   24128:	f108 0008 	add.w	r0, r8, #8
   2412c:	f006 f98f 	bl	2a44e <memcpy>
	pdu->len = prev->len;
   24130:	f899 3001 	ldrb.w	r3, [r9, #1]
   24134:	f888 3001 	strb.w	r3, [r8, #1]
	pdu->last = idx;
   24138:	f885 402c 	strb.w	r4, [r5, #44]	; 0x2c
}
   2413c:	b007      	add	sp, #28
   2413e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	bool all = timeout || (rpa_last_ms == -1) ||
   24142:	2701      	movs	r7, #1
   24144:	e748      	b.n	23fd8 <ull_filter_rpa_update+0x44>
   24146:	bf00      	nop
   24148:	20000008 	.word	0x20000008
   2414c:	200036fc 	.word	0x200036fc
   24150:	200035bc 	.word	0x200035bc
   24154:	20003ee2 	.word	0x20003ee2
   24158:	20003ea9 	.word	0x20003ea9
   2415c:	000317e5 	.word	0x000317e5

00024160 <rpa_timeout>:
{
   24160:	b508      	push	{r3, lr}
	ull_filter_rpa_update(true);
   24162:	2001      	movs	r0, #1
   24164:	f7ff ff16 	bl	23f94 <ull_filter_rpa_update>
   24168:	4b03      	ldr	r3, [pc, #12]	; (24178 <rpa_timeout+0x18>)
   2416a:	4904      	ldr	r1, [pc, #16]	; (2417c <rpa_timeout+0x1c>)
   2416c:	681a      	ldr	r2, [r3, #0]
   2416e:	4804      	ldr	r0, [pc, #16]	; (24180 <rpa_timeout+0x20>)
}
   24170:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   24174:	f003 b962 	b.w	2743c <k_delayed_work_submit_to_queue>
   24178:	200036fc 	.word	0x200036fc
   2417c:	20003700 	.word	0x20003700
   24180:	20003b5c 	.word	0x20003b5c

00024184 <ull_filter_reset>:
	wl_anon = 0U;
   24184:	4a39      	ldr	r2, [pc, #228]	; (2426c <ull_filter_reset+0xe8>)
   24186:	2300      	movs	r3, #0
{
   24188:	b430      	push	{r4, r5}
	wl_anon = 0U;
   2418a:	7013      	strb	r3, [r2, #0]
		wl[i].taken = 0U;
   2418c:	4a38      	ldr	r2, [pc, #224]	; (24270 <ull_filter_reset+0xec>)
   2418e:	7811      	ldrb	r1, [r2, #0]
   24190:	f363 0100 	bfi	r1, r3, #0, #1
   24194:	7011      	strb	r1, [r2, #0]
   24196:	7a11      	ldrb	r1, [r2, #8]
   24198:	f363 0100 	bfi	r1, r3, #0, #1
   2419c:	7211      	strb	r1, [r2, #8]
   2419e:	7c11      	ldrb	r1, [r2, #16]
   241a0:	f363 0100 	bfi	r1, r3, #0, #1
   241a4:	7411      	strb	r1, [r2, #16]
   241a6:	7e11      	ldrb	r1, [r2, #24]
   241a8:	f363 0100 	bfi	r1, r3, #0, #1
   241ac:	7611      	strb	r1, [r2, #24]
   241ae:	f892 1020 	ldrb.w	r1, [r2, #32]
   241b2:	f363 0100 	bfi	r1, r3, #0, #1
   241b6:	f882 1020 	strb.w	r1, [r2, #32]
   241ba:	f892 1028 	ldrb.w	r1, [r2, #40]	; 0x28
   241be:	f363 0100 	bfi	r1, r3, #0, #1
   241c2:	f882 1028 	strb.w	r1, [r2, #40]	; 0x28
   241c6:	f892 1030 	ldrb.w	r1, [r2, #48]	; 0x30
   241ca:	f363 0100 	bfi	r1, r3, #0, #1
   241ce:	f882 1030 	strb.w	r1, [r2, #48]	; 0x30
   241d2:	f892 1038 	ldrb.w	r1, [r2, #56]	; 0x38
   241d6:	f363 0100 	bfi	r1, r3, #0, #1
   241da:	f882 1038 	strb.w	r1, [r2, #56]	; 0x38
	rl_enable = 0U;
   241de:	4a25      	ldr	r2, [pc, #148]	; (24274 <ull_filter_reset+0xf0>)
	rpa_timeout_ms = DEFAULT_RPA_TIMEOUT_MS;
   241e0:	4925      	ldr	r1, [pc, #148]	; (24278 <ull_filter_reset+0xf4>)
	rl_enable = 0U;
   241e2:	7013      	strb	r3, [r2, #0]
	rpa_timeout_ms = DEFAULT_RPA_TIMEOUT_MS;
   241e4:	4a25      	ldr	r2, [pc, #148]	; (2427c <ull_filter_reset+0xf8>)
   241e6:	6011      	str	r1, [r2, #0]
	rpa_last_ms = -1;
   241e8:	4a25      	ldr	r2, [pc, #148]	; (24280 <ull_filter_reset+0xfc>)
   241ea:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   241ee:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   241f2:	e9c2 4500 	strd	r4, r5, [r2]
		rl[i].taken = 0U;
   241f6:	4a23      	ldr	r2, [pc, #140]	; (24284 <ull_filter_reset+0x100>)
   241f8:	7811      	ldrb	r1, [r2, #0]
   241fa:	f363 0100 	bfi	r1, r3, #0, #1
   241fe:	7011      	strb	r1, [r2, #0]
   24200:	f892 1028 	ldrb.w	r1, [r2, #40]	; 0x28
   24204:	f363 0100 	bfi	r1, r3, #0, #1
   24208:	f882 1028 	strb.w	r1, [r2, #40]	; 0x28
   2420c:	f892 1050 	ldrb.w	r1, [r2, #80]	; 0x50
   24210:	f363 0100 	bfi	r1, r3, #0, #1
   24214:	f882 1050 	strb.w	r1, [r2, #80]	; 0x50
   24218:	f892 1078 	ldrb.w	r1, [r2, #120]	; 0x78
   2421c:	f363 0100 	bfi	r1, r3, #0, #1
   24220:	f882 1078 	strb.w	r1, [r2, #120]	; 0x78
   24224:	f892 10a0 	ldrb.w	r1, [r2, #160]	; 0xa0
   24228:	f363 0100 	bfi	r1, r3, #0, #1
   2422c:	f882 10a0 	strb.w	r1, [r2, #160]	; 0xa0
   24230:	f892 10c8 	ldrb.w	r1, [r2, #200]	; 0xc8
   24234:	f363 0100 	bfi	r1, r3, #0, #1
   24238:	f882 10c8 	strb.w	r1, [r2, #200]	; 0xc8
   2423c:	f892 10f0 	ldrb.w	r1, [r2, #240]	; 0xf0
   24240:	f363 0100 	bfi	r1, r3, #0, #1
   24244:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
   24248:	f892 1118 	ldrb.w	r1, [r2, #280]	; 0x118
   2424c:	f363 0100 	bfi	r1, r3, #0, #1
   24250:	f882 1118 	strb.w	r1, [r2, #280]	; 0x118
	peer_irk_count = 0U;
   24254:	4a0c      	ldr	r2, [pc, #48]	; (24288 <ull_filter_reset+0x104>)
   24256:	7013      	strb	r3, [r2, #0]
	if (init) {
   24258:	b120      	cbz	r0, 24264 <ull_filter_reset+0xe0>
		k_delayed_work_init(&rpa_work, rpa_timeout);
   2425a:	490c      	ldr	r1, [pc, #48]	; (2428c <ull_filter_reset+0x108>)
   2425c:	480c      	ldr	r0, [pc, #48]	; (24290 <ull_filter_reset+0x10c>)
}
   2425e:	bc30      	pop	{r4, r5}
		k_delayed_work_init(&rpa_work, rpa_timeout);
   24260:	f009 b977 	b.w	2d552 <k_delayed_work_init>
		k_delayed_work_cancel(&rpa_work);
   24264:	480a      	ldr	r0, [pc, #40]	; (24290 <ull_filter_reset+0x10c>)
}
   24266:	bc30      	pop	{r4, r5}
		k_delayed_work_cancel(&rpa_work);
   24268:	f009 b97b 	b.w	2d562 <k_delayed_work_cancel>
   2426c:	20003fd5 	.word	0x20003fd5
   24270:	20003f95 	.word	0x20003f95
   24274:	20003f62 	.word	0x20003f62
   24278:	000dbba0 	.word	0x000dbba0
   2427c:	200036fc 	.word	0x200036fc
   24280:	20000008 	.word	0x20000008
   24284:	200035bc 	.word	0x200035bc
   24288:	20003ed9 	.word	0x20003ed9
   2428c:	00024161 	.word	0x00024161
   24290:	20003700 	.word	0x20003700

00024294 <ull_filter_lll_lrpa_get>:
	if ((rl_idx >= ARRAY_SIZE(rl)) || !rl[rl_idx].lirk ||
   24294:	2807      	cmp	r0, #7
   24296:	d80c      	bhi.n	242b2 <ull_filter_lll_lrpa_get+0x1e>
   24298:	2328      	movs	r3, #40	; 0x28
   2429a:	4358      	muls	r0, r3
   2429c:	4a06      	ldr	r2, [pc, #24]	; (242b8 <ull_filter_lll_lrpa_get+0x24>)
   2429e:	5c13      	ldrb	r3, [r2, r0]
   242a0:	1811      	adds	r1, r2, r0
   242a2:	f3c3 00c0 	ubfx	r0, r3, #3, #1
   242a6:	b128      	cbz	r0, 242b4 <ull_filter_lll_lrpa_get+0x20>
   242a8:	f3c3 0040 	ubfx	r0, r3, #1, #1
   242ac:	b110      	cbz	r0, 242b4 <ull_filter_lll_lrpa_get+0x20>
	return rl[rl_idx].local_rpa;
   242ae:	6a48      	ldr	r0, [r1, #36]	; 0x24
   242b0:	4770      	bx	lr
		return NULL;
   242b2:	2000      	movs	r0, #0
}
   242b4:	4770      	bx	lr
   242b6:	bf00      	nop
   242b8:	200035bc 	.word	0x200035bc

000242bc <ull_filter_lll_irks_get>:
	*count = peer_irk_count;
   242bc:	4b02      	ldr	r3, [pc, #8]	; (242c8 <ull_filter_lll_irks_get+0xc>)
   242be:	781b      	ldrb	r3, [r3, #0]
   242c0:	7003      	strb	r3, [r0, #0]
}
   242c2:	4802      	ldr	r0, [pc, #8]	; (242cc <ull_filter_lll_irks_get+0x10>)
   242c4:	4770      	bx	lr
   242c6:	bf00      	nop
   242c8:	20003ed9 	.word	0x20003ed9
   242cc:	20003ee2 	.word	0x20003ee2

000242d0 <ull_filter_lll_rl_idx>:
{
   242d0:	b538      	push	{r3, r4, r5, lr}
   242d2:	460c      	mov	r4, r1
	if (whitelist) {
   242d4:	b1e8      	cbz	r0, 24312 <ull_filter_lll_rl_idx+0x42>
		LL_ASSERT(devmatch_id < ARRAY_SIZE(wl));
   242d6:	2907      	cmp	r1, #7
   242d8:	d908      	bls.n	242ec <ull_filter_lll_rl_idx+0x1c>
   242da:	481b      	ldr	r0, [pc, #108]	; (24348 <ull_filter_lll_rl_idx+0x78>)
   242dc:	f003 ff32 	bl	28144 <printk>
   242e0:	4040      	eors	r0, r0
   242e2:	f380 8811 	msr	BASEPRI, r0
   242e6:	f04f 0003 	mov.w	r0, #3
   242ea:	df02      	svc	2
		LL_ASSERT(wl[devmatch_id].taken);
   242ec:	4d17      	ldr	r5, [pc, #92]	; (2434c <ull_filter_lll_rl_idx+0x7c>)
   242ee:	f815 3034 	ldrb.w	r3, [r5, r4, lsl #3]
   242f2:	07da      	lsls	r2, r3, #31
   242f4:	d408      	bmi.n	24308 <ull_filter_lll_rl_idx+0x38>
   242f6:	4816      	ldr	r0, [pc, #88]	; (24350 <ull_filter_lll_rl_idx+0x80>)
   242f8:	f003 ff24 	bl	28144 <printk>
   242fc:	4040      	eors	r0, r0
   242fe:	f380 8811 	msr	BASEPRI, r0
   24302:	f04f 0003 	mov.w	r0, #3
   24306:	df02      	svc	2
		i = wl[devmatch_id].rl_idx;
   24308:	eb05 01c4 	add.w	r1, r5, r4, lsl #3
   2430c:	784c      	ldrb	r4, [r1, #1]
}
   2430e:	4620      	mov	r0, r4
   24310:	bd38      	pop	{r3, r4, r5, pc}
		LL_ASSERT(devmatch_id < ARRAY_SIZE(rl));
   24312:	2907      	cmp	r1, #7
   24314:	d908      	bls.n	24328 <ull_filter_lll_rl_idx+0x58>
   24316:	480f      	ldr	r0, [pc, #60]	; (24354 <ull_filter_lll_rl_idx+0x84>)
   24318:	f003 ff14 	bl	28144 <printk>
   2431c:	4040      	eors	r0, r0
   2431e:	f380 8811 	msr	BASEPRI, r0
   24322:	f04f 0003 	mov.w	r0, #3
   24326:	df02      	svc	2
		LL_ASSERT(rl[i].taken);
   24328:	2328      	movs	r3, #40	; 0x28
   2432a:	4363      	muls	r3, r4
   2432c:	4a0a      	ldr	r2, [pc, #40]	; (24358 <ull_filter_lll_rl_idx+0x88>)
   2432e:	5cd3      	ldrb	r3, [r2, r3]
   24330:	07db      	lsls	r3, r3, #31
   24332:	d4ec      	bmi.n	2430e <ull_filter_lll_rl_idx+0x3e>
   24334:	4809      	ldr	r0, [pc, #36]	; (2435c <ull_filter_lll_rl_idx+0x8c>)
   24336:	f003 ff05 	bl	28144 <printk>
   2433a:	4040      	eors	r0, r0
   2433c:	f380 8811 	msr	BASEPRI, r0
   24340:	f04f 0003 	mov.w	r0, #3
   24344:	df02      	svc	2
   24346:	e7e2      	b.n	2430e <ull_filter_lll_rl_idx+0x3e>
   24348:	000320fb 	.word	0x000320fb
   2434c:	20003f95 	.word	0x20003f95
   24350:	000321b0 	.word	0x000321b0
   24354:	000321d8 	.word	0x000321d8
   24358:	200035bc 	.word	0x200035bc
   2435c:	0003228d 	.word	0x0003228d

00024360 <ull_filter_lll_rl_irk_idx>:
{
   24360:	b510      	push	{r4, lr}
	LL_ASSERT(irkmatch_id < peer_irk_count);
   24362:	4b16      	ldr	r3, [pc, #88]	; (243bc <ull_filter_lll_rl_irk_idx+0x5c>)
   24364:	781b      	ldrb	r3, [r3, #0]
   24366:	4283      	cmp	r3, r0
{
   24368:	4604      	mov	r4, r0
	LL_ASSERT(irkmatch_id < peer_irk_count);
   2436a:	d808      	bhi.n	2437e <ull_filter_lll_rl_irk_idx+0x1e>
   2436c:	4814      	ldr	r0, [pc, #80]	; (243c0 <ull_filter_lll_rl_irk_idx+0x60>)
   2436e:	f003 fee9 	bl	28144 <printk>
   24372:	4040      	eors	r0, r0
   24374:	f380 8811 	msr	BASEPRI, r0
   24378:	f04f 0003 	mov.w	r0, #3
   2437c:	df02      	svc	2
	i = peer_irk_rl_ids[irkmatch_id];
   2437e:	4b11      	ldr	r3, [pc, #68]	; (243c4 <ull_filter_lll_rl_irk_idx+0x64>)
   24380:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(i < CONFIG_BT_CTLR_RL_SIZE);
   24382:	2c07      	cmp	r4, #7
   24384:	d908      	bls.n	24398 <ull_filter_lll_rl_irk_idx+0x38>
   24386:	4810      	ldr	r0, [pc, #64]	; (243c8 <ull_filter_lll_rl_irk_idx+0x68>)
   24388:	f003 fedc 	bl	28144 <printk>
   2438c:	4040      	eors	r0, r0
   2438e:	f380 8811 	msr	BASEPRI, r0
   24392:	f04f 0003 	mov.w	r0, #3
   24396:	df02      	svc	2
	LL_ASSERT(rl[i].taken);
   24398:	2328      	movs	r3, #40	; 0x28
   2439a:	4363      	muls	r3, r4
   2439c:	4a0b      	ldr	r2, [pc, #44]	; (243cc <ull_filter_lll_rl_irk_idx+0x6c>)
   2439e:	5cd3      	ldrb	r3, [r2, r3]
   243a0:	07db      	lsls	r3, r3, #31
   243a2:	d408      	bmi.n	243b6 <ull_filter_lll_rl_irk_idx+0x56>
   243a4:	480a      	ldr	r0, [pc, #40]	; (243d0 <ull_filter_lll_rl_irk_idx+0x70>)
   243a6:	f003 fecd 	bl	28144 <printk>
   243aa:	4040      	eors	r0, r0
   243ac:	f380 8811 	msr	BASEPRI, r0
   243b0:	f04f 0003 	mov.w	r0, #3
   243b4:	df02      	svc	2
}
   243b6:	4620      	mov	r0, r4
   243b8:	bd10      	pop	{r4, pc}
   243ba:	bf00      	nop
   243bc:	20003ed9 	.word	0x20003ed9
   243c0:	000322ab 	.word	0x000322ab
   243c4:	20003eda 	.word	0x20003eda
   243c8:	000322da 	.word	0x000322da
   243cc:	200035bc 	.word	0x200035bc
   243d0:	0003228d 	.word	0x0003228d

000243d4 <ull_filter_lll_irk_whitelisted>:
	if (rl_idx >= ARRAY_SIZE(rl)) {
   243d4:	2807      	cmp	r0, #7
{
   243d6:	b538      	push	{r3, r4, r5, lr}
   243d8:	4605      	mov	r5, r0
	if (rl_idx >= ARRAY_SIZE(rl)) {
   243da:	d814      	bhi.n	24406 <ull_filter_lll_irk_whitelisted+0x32>
	LL_ASSERT(rl[rl_idx].taken);
   243dc:	2228      	movs	r2, #40	; 0x28
   243de:	4c0b      	ldr	r4, [pc, #44]	; (2440c <ull_filter_lll_irk_whitelisted+0x38>)
   243e0:	4342      	muls	r2, r0
   243e2:	5ca2      	ldrb	r2, [r4, r2]
   243e4:	07d3      	lsls	r3, r2, #31
   243e6:	d408      	bmi.n	243fa <ull_filter_lll_irk_whitelisted+0x26>
   243e8:	4809      	ldr	r0, [pc, #36]	; (24410 <ull_filter_lll_irk_whitelisted+0x3c>)
   243ea:	f003 feab 	bl	28144 <printk>
   243ee:	4040      	eors	r0, r0
   243f0:	f380 8811 	msr	BASEPRI, r0
   243f4:	f04f 0003 	mov.w	r0, #3
   243f8:	df02      	svc	2
	return rl[rl_idx].wl;
   243fa:	2028      	movs	r0, #40	; 0x28
   243fc:	4368      	muls	r0, r5
   243fe:	5c20      	ldrb	r0, [r4, r0]
   24400:	f3c0 1040 	ubfx	r0, r0, #5, #1
}
   24404:	bd38      	pop	{r3, r4, r5, pc}
		return false;
   24406:	2000      	movs	r0, #0
   24408:	e7fc      	b.n	24404 <ull_filter_lll_irk_whitelisted+0x30>
   2440a:	bf00      	nop
   2440c:	200035bc 	.word	0x200035bc
   24410:	000320a0 	.word	0x000320a0

00024414 <ull_filter_lll_get>:
}
   24414:	4a03      	ldr	r2, [pc, #12]	; (24424 <ull_filter_lll_get+0x10>)
   24416:	4b04      	ldr	r3, [pc, #16]	; (24428 <ull_filter_lll_get+0x14>)
   24418:	2800      	cmp	r0, #0
   2441a:	bf0c      	ite	eq
   2441c:	4610      	moveq	r0, r2
   2441e:	4618      	movne	r0, r3
   24420:	4770      	bx	lr
   24422:	bf00      	nop
   24424:	20003f63 	.word	0x20003f63
   24428:	20003fd6 	.word	0x20003fd6

0002442c <ull_filter_lll_rl_idx_allowed>:
{
   2442c:	b538      	push	{r3, r4, r5, lr}
	if (!rl_enable || rl_idx >= ARRAY_SIZE(rl) || irkmatch_ok) {
   2442e:	4b10      	ldr	r3, [pc, #64]	; (24470 <ull_filter_lll_rl_idx_allowed+0x44>)
   24430:	781b      	ldrb	r3, [r3, #0]
{
   24432:	460d      	mov	r5, r1
	if (!rl_enable || rl_idx >= ARRAY_SIZE(rl) || irkmatch_ok) {
   24434:	b1cb      	cbz	r3, 2446a <ull_filter_lll_rl_idx_allowed+0x3e>
   24436:	2907      	cmp	r1, #7
   24438:	d817      	bhi.n	2446a <ull_filter_lll_rl_idx_allowed+0x3e>
   2443a:	b9b0      	cbnz	r0, 2446a <ull_filter_lll_rl_idx_allowed+0x3e>
	LL_ASSERT(rl[rl_idx].taken);
   2443c:	2228      	movs	r2, #40	; 0x28
   2443e:	4c0d      	ldr	r4, [pc, #52]	; (24474 <ull_filter_lll_rl_idx_allowed+0x48>)
   24440:	434a      	muls	r2, r1
   24442:	5ca2      	ldrb	r2, [r4, r2]
   24444:	07d2      	lsls	r2, r2, #31
   24446:	d408      	bmi.n	2445a <ull_filter_lll_rl_idx_allowed+0x2e>
   24448:	480b      	ldr	r0, [pc, #44]	; (24478 <ull_filter_lll_rl_idx_allowed+0x4c>)
   2444a:	f003 fe7b 	bl	28144 <printk>
   2444e:	4040      	eors	r0, r0
   24450:	f380 8811 	msr	BASEPRI, r0
   24454:	f04f 0003 	mov.w	r0, #3
   24458:	df02      	svc	2
	return !rl[rl_idx].pirk || rl[rl_idx].dev;
   2445a:	2328      	movs	r3, #40	; 0x28
   2445c:	436b      	muls	r3, r5
   2445e:	5ce0      	ldrb	r0, [r4, r3]
   24460:	0743      	lsls	r3, r0, #29
   24462:	d502      	bpl.n	2446a <ull_filter_lll_rl_idx_allowed+0x3e>
   24464:	f3c0 1000 	ubfx	r0, r0, #4, #1
}
   24468:	bd38      	pop	{r3, r4, r5, pc}
		return true;
   2446a:	2001      	movs	r0, #1
   2446c:	e7fc      	b.n	24468 <ull_filter_lll_rl_idx_allowed+0x3c>
   2446e:	bf00      	nop
   24470:	20003f62 	.word	0x20003f62
   24474:	200035bc 	.word	0x200035bc
   24478:	000320a0 	.word	0x000320a0

0002447c <ull_filter_lll_rl_addr_allowed>:
{
   2447c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!rl_enable || *rl_idx != FILTER_IDX_NONE) {
   24480:	4b1a      	ldr	r3, [pc, #104]	; (244ec <ull_filter_lll_rl_addr_allowed+0x70>)
   24482:	781b      	ldrb	r3, [r3, #0]
   24484:	b383      	cbz	r3, 244e8 <ull_filter_lll_rl_addr_allowed+0x6c>
   24486:	7813      	ldrb	r3, [r2, #0]
   24488:	2bff      	cmp	r3, #255	; 0xff
   2448a:	d12d      	bne.n	244e8 <ull_filter_lll_rl_addr_allowed+0x6c>
		if (rl[i].taken && (rl[i].id_addr_type == id_addr_type)) {
   2448c:	4e18      	ldr	r6, [pc, #96]	; (244f0 <ull_filter_lll_rl_addr_allowed+0x74>)
   2448e:	2300      	movs	r3, #0
   24490:	f04f 0828 	mov.w	r8, #40	; 0x28
   24494:	46b4      	mov	ip, r6
   24496:	f106 0906 	add.w	r9, r6, #6
   2449a:	fb08 f403 	mul.w	r4, r8, r3
   2449e:	fa5f fe83 	uxtb.w	lr, r3
   244a2:	5d37      	ldrb	r7, [r6, r4]
   244a4:	f017 0f01 	tst.w	r7, #1
   244a8:	eb06 0504 	add.w	r5, r6, r4
   244ac:	d019      	beq.n	244e2 <ull_filter_lll_rl_addr_allowed+0x66>
   244ae:	f3c7 1780 	ubfx	r7, r7, #6, #1
   244b2:	4287      	cmp	r7, r0
   244b4:	d115      	bne.n	244e2 <ull_filter_lll_rl_addr_allowed+0x66>
			for (j = 0U; j < BDADDR_SIZE; j++) {
   244b6:	1e4f      	subs	r7, r1, #1
   244b8:	444c      	add	r4, r9
				if (addr[j] != id_addr[j]) {
   244ba:	f815 bf01 	ldrb.w	fp, [r5, #1]!
   244be:	f817 af01 	ldrb.w	sl, [r7, #1]!
   244c2:	45d3      	cmp	fp, sl
   244c4:	d10d      	bne.n	244e2 <ull_filter_lll_rl_addr_allowed+0x66>
			for (j = 0U; j < BDADDR_SIZE; j++) {
   244c6:	42a5      	cmp	r5, r4
   244c8:	d1f7      	bne.n	244ba <ull_filter_lll_rl_addr_allowed+0x3e>
				*rl_idx = i;
   244ca:	f882 e000 	strb.w	lr, [r2]
				return !rl[i].pirk || rl[i].dev;
   244ce:	2228      	movs	r2, #40	; 0x28
   244d0:	4353      	muls	r3, r2
   244d2:	f81c 0003 	ldrb.w	r0, [ip, r3]
   244d6:	0743      	lsls	r3, r0, #29
   244d8:	d506      	bpl.n	244e8 <ull_filter_lll_rl_addr_allowed+0x6c>
   244da:	f3c0 1000 	ubfx	r0, r0, #4, #1
}
   244de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   244e2:	3301      	adds	r3, #1
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
   244e4:	2b08      	cmp	r3, #8
   244e6:	d1d8      	bne.n	2449a <ull_filter_lll_rl_addr_allowed+0x1e>
				return !rl[i].pirk || rl[i].dev;
   244e8:	2001      	movs	r0, #1
   244ea:	e7f8      	b.n	244de <ull_filter_lll_rl_addr_allowed+0x62>
   244ec:	20003f62 	.word	0x20003f62
   244f0:	200035bc 	.word	0x200035bc

000244f4 <ull_filter_lll_rl_addr_resolve>:
{
   244f4:	b470      	push	{r4, r5, r6}
	if (!rl_enable || rl_idx >= ARRAY_SIZE(rl) || !rl[rl_idx].lirk) {
   244f6:	4c0d      	ldr	r4, [pc, #52]	; (2452c <ull_filter_lll_rl_addr_resolve+0x38>)
   244f8:	7824      	ldrb	r4, [r4, #0]
   244fa:	b1a4      	cbz	r4, 24526 <ull_filter_lll_rl_addr_resolve+0x32>
   244fc:	2a07      	cmp	r2, #7
   244fe:	d812      	bhi.n	24526 <ull_filter_lll_rl_addr_resolve+0x32>
   24500:	2528      	movs	r5, #40	; 0x28
   24502:	4c0b      	ldr	r4, [pc, #44]	; (24530 <ull_filter_lll_rl_addr_resolve+0x3c>)
   24504:	fb05 f602 	mul.w	r6, r5, r2
   24508:	5da6      	ldrb	r6, [r4, r6]
   2450a:	0736      	lsls	r6, r6, #28
   2450c:	d50b      	bpl.n	24526 <ull_filter_lll_rl_addr_resolve+0x32>
	if ((id_addr_type != 0U) && ((id_addr[5] & 0xc0) == 0x40)) {
   2450e:	b150      	cbz	r0, 24526 <ull_filter_lll_rl_addr_resolve+0x32>
   24510:	794b      	ldrb	r3, [r1, #5]
   24512:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   24516:	2b40      	cmp	r3, #64	; 0x40
   24518:	d105      	bne.n	24526 <ull_filter_lll_rl_addr_resolve+0x32>
		return bt_rpa_irk_matches(rl[rl_idx].local_irk,
   2451a:	fb05 4202 	mla	r2, r5, r2, r4
   2451e:	1dd0      	adds	r0, r2, #7
}
   24520:	bc70      	pop	{r4, r5, r6}
		return bt_rpa_irk_matches(rl[rl_idx].local_irk,
   24522:	f006 b886 	b.w	2a632 <bt_rpa_irk_matches>
}
   24526:	2000      	movs	r0, #0
   24528:	bc70      	pop	{r4, r5, r6}
   2452a:	4770      	bx	lr
   2452c:	20003f62 	.word	0x20003f62
   24530:	200035bc 	.word	0x200035bc

00024534 <ull_filter_lll_rl_enabled>:
	return rl_enable;
   24534:	4b02      	ldr	r3, [pc, #8]	; (24540 <ull_filter_lll_rl_enabled+0xc>)
   24536:	7818      	ldrb	r0, [r3, #0]
}
   24538:	3000      	adds	r0, #0
   2453a:	bf18      	it	ne
   2453c:	2001      	movne	r0, #1
   2453e:	4770      	bx	lr
   24540:	20003f62 	.word	0x20003f62

00024544 <cntr_init>:

static u8_t _refcount;

void cntr_init(void)
{
	NRF_RTC->PRESCALER = 0;
   24544:	4b05      	ldr	r3, [pc, #20]	; (2455c <cntr_init+0x18>)
   24546:	2200      	movs	r2, #0
   24548:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
   2454c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   24550:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
    p_reg->INTENSET = mask;
   24554:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	nrf_rtc_event_enable(NRF_RTC, RTC_EVTENSET_COMPARE0_Msk);
	nrf_rtc_int_enable(NRF_RTC, RTC_INTENSET_COMPARE0_Msk);
}
   24558:	4770      	bx	lr
   2455a:	bf00      	nop
   2455c:	4000b000 	.word	0x4000b000

00024560 <cntr_start>:

u32_t cntr_start(void)
{
	if (_refcount++) {
   24560:	4a04      	ldr	r2, [pc, #16]	; (24574 <cntr_start+0x14>)
   24562:	7813      	ldrb	r3, [r2, #0]
   24564:	1c59      	adds	r1, r3, #1
   24566:	7011      	strb	r1, [r2, #0]
   24568:	2001      	movs	r0, #1
   2456a:	b913      	cbnz	r3, 24572 <cntr_start+0x12>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   2456c:	4a02      	ldr	r2, [pc, #8]	; (24578 <cntr_start+0x18>)
   2456e:	6010      	str	r0, [r2, #0]
		return 1;
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_START);

	return 0;
   24570:	4618      	mov	r0, r3
}
   24572:	4770      	bx	lr
   24574:	20004008 	.word	0x20004008
   24578:	4000b000 	.word	0x4000b000

0002457c <cntr_stop>:

u32_t cntr_stop(void)
{
   2457c:	b510      	push	{r4, lr}
	LL_ASSERT(_refcount);
   2457e:	4c0b      	ldr	r4, [pc, #44]	; (245ac <cntr_stop+0x30>)
   24580:	7823      	ldrb	r3, [r4, #0]
   24582:	b943      	cbnz	r3, 24596 <cntr_stop+0x1a>
   24584:	480a      	ldr	r0, [pc, #40]	; (245b0 <cntr_stop+0x34>)
   24586:	f003 fddd 	bl	28144 <printk>
   2458a:	4040      	eors	r0, r0
   2458c:	f380 8811 	msr	BASEPRI, r0
   24590:	f04f 0003 	mov.w	r0, #3
   24594:	df02      	svc	2

	if (--_refcount) {
   24596:	7820      	ldrb	r0, [r4, #0]
   24598:	3801      	subs	r0, #1
   2459a:	b2c0      	uxtb	r0, r0
   2459c:	7020      	strb	r0, [r4, #0]
   2459e:	2301      	movs	r3, #1
   245a0:	b910      	cbnz	r0, 245a8 <cntr_stop+0x2c>
   245a2:	4a04      	ldr	r2, [pc, #16]	; (245b4 <cntr_stop+0x38>)
   245a4:	6013      	str	r3, [r2, #0]
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_STOP);

	return 0;
}
   245a6:	bd10      	pop	{r4, pc}
		return 1;
   245a8:	4618      	mov	r0, r3
   245aa:	e7fc      	b.n	245a6 <cntr_stop+0x2a>
   245ac:	20004008 	.word	0x20004008
   245b0:	000322f2 	.word	0x000322f2
   245b4:	4000b004 	.word	0x4000b004

000245b8 <cntr_cnt_get>:
     return p_reg->COUNTER;
   245b8:	4b01      	ldr	r3, [pc, #4]	; (245c0 <cntr_cnt_get+0x8>)
   245ba:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504

u32_t cntr_cnt_get(void)
{
	return nrf_rtc_counter_get(NRF_RTC);
}
   245be:	4770      	bx	lr
   245c0:	4000b000 	.word	0x4000b000

000245c4 <cntr_cmp_set>:
    p_reg->CC[ch] = cc_val;
   245c4:	f500 70a8 	add.w	r0, r0, #336	; 0x150
   245c8:	4b01      	ldr	r3, [pc, #4]	; (245d0 <cntr_cmp_set+0xc>)
   245ca:	f843 1020 	str.w	r1, [r3, r0, lsl #2]

void cntr_cmp_set(u8_t cmp, u32_t value)
{
	nrf_rtc_cc_set(NRF_RTC, cmp, value);
}
   245ce:	4770      	bx	lr
   245d0:	4000b000 	.word	0x4000b000

000245d4 <do_ecb>:
	u8_t clear_text[16];
	u8_t cipher_text[16];
} __packed;

static void do_ecb(struct ecb_param *ecb)
{
   245d4:	b5f0      	push	{r4, r5, r6, r7, lr}
	do {
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
		NRF_ECB->ECBDATAPTR = (u32_t)ecb;
   245d6:	4b13      	ldr	r3, [pc, #76]	; (24624 <do_ecb+0x50>)

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ecb_task_trigger(NRF_ECB_Type * p_reg, nrf_ecb_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   245d8:	4c13      	ldr	r4, [pc, #76]	; (24628 <do_ecb+0x54>)
   245da:	2501      	movs	r5, #1
{
   245dc:	4684      	mov	ip, r0
   245de:	462e      	mov	r6, r5
		NRF_ECB->EVENTS_ENDECB = 0;
   245e0:	2700      	movs	r7, #0
   245e2:	46a6      	mov	lr, r4
   245e4:	461a      	mov	r2, r3
   245e6:	6026      	str	r6, [r4, #0]
		NRF_ECB->ECBDATAPTR = (u32_t)ecb;
   245e8:	f8c3 c504 	str.w	ip, [r3, #1284]	; 0x504
		NRF_ECB->EVENTS_ENDECB = 0;
   245ec:	f8c3 7100 	str.w	r7, [r3, #256]	; 0x100
		NRF_ECB->EVENTS_ERRORECB = 0;
   245f0:	f8c3 7104 	str.w	r7, [r3, #260]	; 0x104
   245f4:	601e      	str	r6, [r3, #0]
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STARTECB);
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
   245f6:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
   245fa:	b931      	cbnz	r1, 2460a <do_ecb+0x36>
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
   245fc:	f8d3 1104 	ldr.w	r1, [r3, #260]	; 0x104
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
   24600:	b919      	cbnz	r1, 2460a <do_ecb+0x36>
		       (NRF_ECB->ECBDATAPTR != 0)) {
   24602:	f8d3 1504 	ldr.w	r1, [r3, #1284]	; 0x504
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
   24606:	2900      	cmp	r1, #0
   24608:	d1f5      	bne.n	245f6 <do_ecb+0x22>
   2460a:	f8ce 5000 	str.w	r5, [lr]
#else
			/*__WFE();*/
#endif
		}
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
	} while ((NRF_ECB->EVENTS_ERRORECB != 0) || (NRF_ECB->ECBDATAPTR == 0));
   2460e:	f8d2 1104 	ldr.w	r1, [r2, #260]	; 0x104
   24612:	2900      	cmp	r1, #0
   24614:	d1e7      	bne.n	245e6 <do_ecb+0x12>
   24616:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
   2461a:	2800      	cmp	r0, #0
   2461c:	d0e3      	beq.n	245e6 <do_ecb+0x12>

	NRF_ECB->ECBDATAPTR = 0;
   2461e:	f8c2 1504 	str.w	r1, [r2, #1284]	; 0x504
}
   24622:	bdf0      	pop	{r4, r5, r6, r7, pc}
   24624:	4000e000 	.word	0x4000e000
   24628:	4000e004 	.word	0x4000e004

0002462c <hal_radio_enable_on_tick_ppi_config_and_enable>:
static inline void hal_radio_enable_on_tick_ppi_config_and_enable(u8_t trx)
{
	/* No need to configure anything for the pre-programmed channels.
	 * Just enable and disable them accordingly.
	 */
	nrf_ppi_channels_disable(
   2462c:	2800      	cmp	r0, #0
    p_reg->CHENSET = mask;
}

NRF_STATIC_INLINE void nrf_ppi_channels_disable(NRF_PPI_Type * p_reg, uint32_t mask)
{
    p_reg->CHENCLR = mask;
   2462e:	4b08      	ldr	r3, [pc, #32]	; (24650 <hal_radio_enable_on_tick_ppi_config_and_enable+0x24>)
   24630:	bf14      	ite	ne
   24632:	f44f 1200 	movne.w	r2, #2097152	; 0x200000
   24636:	f44f 1280 	moveq.w	r2, #1048576	; 0x100000
   2463a:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
		NRF_PPI,
		trx ? BIT(HAL_RADIO_ENABLE_RX_ON_TICK_PPI)
		    : BIT(HAL_RADIO_ENABLE_TX_ON_TICK_PPI));
	nrf_ppi_channels_enable(
   2463e:	bf14      	ite	ne
   24640:	f44f 1280 	movne.w	r2, #1048576	; 0x100000
   24644:	f44f 1200 	moveq.w	r2, #2097152	; 0x200000
    p_reg->CHENSET = mask;
   24648:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
		NRF_PPI,
		trx ? BIT(HAL_RADIO_ENABLE_TX_ON_TICK_PPI)
		    : BIT(HAL_RADIO_ENABLE_RX_ON_TICK_PPI));
}
   2464c:	4770      	bx	lr
   2464e:	bf00      	nop
   24650:	4001f000 	.word	0x4001f000

00024654 <sw_switch.isra.5>:
}

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
static u8_t sw_tifs_toggle;

static void sw_switch(u8_t dir, u8_t phy_curr, u8_t flags_curr, u8_t phy_next,
   24654:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		      u8_t flags_next)
{
	u8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
   24658:	4b7d      	ldr	r3, [pc, #500]	; (24850 <sw_switch.isra.5+0x1fc>)
NRF_STATIC_INLINE void nrf_ppi_channel_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                      nrf_ppi_channel_t channel,
                                                      uint32_t          eep,
                                                      uint32_t          tep)
{
    p_reg->CH[(uint32_t) channel].EEP = eep;
   2465a:	4c7e      	ldr	r4, [pc, #504]	; (24854 <sw_switch.isra.5+0x200>)
   2465c:	f893 e000 	ldrb.w	lr, [r3]
   24660:	4e7d      	ldr	r6, [pc, #500]	; (24858 <sw_switch.isra.5+0x204>)
   24662:	f8c4 6560 	str.w	r6, [r4, #1376]	; 0x560
	 */
	nrf_ppi_channel_endpoint_setup(
		NRF_PPI,
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI,
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_EVT,
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_TASK(ppi_group_index));
   24666:	fa0f f58e 	sxth.w	r5, lr
   2466a:	fa4f fc8e 	sxtb.w	ip, lr
   2466e:	ea4f 0bc5 	mov.w	fp, r5, lsl #3
static void sw_switch(u8_t dir, u8_t phy_curr, u8_t flags_curr, u8_t phy_next,
   24672:	4688      	mov	r8, r1
	u8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
   24674:	f10c 060b 	add.w	r6, ip, #11
   24678:	f10b 4180 	add.w	r1, fp, #1073741824	; 0x40000000
   2467c:	f501 31f8 	add.w	r1, r1, #126976	; 0x1f000
    p_reg->CH[(uint32_t) channel].TEP = tep;
   24680:	b2f6      	uxtb	r6, r6
   24682:	f8c4 1564 	str.w	r1, [r4, #1380]	; 0x564
	 * PPI[<radio_enable_ppi>] for enabling Radio. Do
	 * not wire the task; it is done by the caller of
	 * the function depending on the desired direction
	 * (TX/RX).
	 */
	nrf_ppi_event_endpoint_setup(
   24686:	00f6      	lsls	r6, r6, #3
		NRF_PPI,
		radio_enable_ppi,
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(compare_reg));
   24688:	f5a4 34af 	sub.w	r4, r4, #89600	; 0x15e00
   2468c:	00a9      	lsls	r1, r5, #2
   2468e:	3cc0      	subs	r4, #192	; 0xc0
   24690:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
   24694:	eb01 0904 	add.w	r9, r1, r4
   24698:	9100      	str	r1, [sp, #0]
   2469a:	f506 36f8 	add.w	r6, r6, #126976	; 0x1f000
   2469e:	f10c 0708 	add.w	r7, ip, #8
   246a2:	496e      	ldr	r1, [pc, #440]	; (2485c <sw_switch.isra.5+0x208>)
   246a4:	9401      	str	r4, [sp, #4]
   246a6:	f10c 0a10 	add.w	sl, ip, #16
   246aa:	b2ff      	uxtb	r7, r7
   246ac:	4459      	add	r1, fp

NRF_STATIC_INLINE void nrf_ppi_event_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                    nrf_ppi_channel_t channel,
                                                    uint32_t          eep)
{
    p_reg->CH[(uint32_t) channel].EEP = eep;
   246ae:	f8c6 9510 	str.w	r9, [r6, #1296]	; 0x510
	u8_t cc = SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle);
	u32_t delay;

	hal_radio_sw_switch_setup(cc, ppi, sw_tifs_toggle);

	if (dir) {
   246b2:	469b      	mov	fp, r3
   246b4:	b23c      	sxth	r4, r7
   246b6:	fa5f f38a 	uxtb.w	r3, sl
   246ba:	2800      	cmp	r0, #0
   246bc:	f000 80b1 	beq.w	24822 <sw_switch.isra.5+0x1ce>
	}
}

static inline u32_t hal_radio_tx_ready_delay_ns_get(u8_t phy, u8_t flags)
{
	switch (phy) {
   246c0:	2a02      	cmp	r2, #2
   246c2:	f000 8095 	beq.w	247f0 <sw_switch.isra.5+0x19c>
	default:
	case BIT(0):
		return HAL_RADIO_NRF52840_TXEN_TXIDLE_TX_1M_NS;
   246c6:	f24a 5a3c 	movw	sl, #42300	; 0xa53c
   246ca:	f649 70c4 	movw	r0, #40900	; 0x9fc4
   246ce:	2a04      	cmp	r2, #4
   246d0:	bf0c      	ite	eq
   246d2:	4652      	moveq	r2, sl
   246d4:	4602      	movne	r2, r0
	}
}

static inline u32_t hal_radio_rx_chain_delay_ns_get(u8_t phy, u8_t flags)
{
	switch (phy) {
   246d6:	f1b8 0f02 	cmp.w	r8, #2
   246da:	f000 808c 	beq.w	247f6 <sw_switch.isra.5+0x1a2>
	default:
	case BIT(0):
		return HAL_RADIO_NRF52840_RX_CHAIN_DELAY_1M_NS;
   246de:	f247 3aa0 	movw	sl, #29600	; 0x73a0
   246e2:	f242 40b8 	movw	r0, #9400	; 0x24b8
   246e6:	f1b8 0f04 	cmp.w	r8, #4
   246ea:	bf08      	it	eq
   246ec:	4650      	moveq	r0, sl
   246ee:	f502 72fa 	add.w	r2, r2, #500	; 0x1f4
		/* TX */

		/* Calculate delay with respect to current (RX) and next
		 * (TX) PHY. If RX PHY is LE Coded, assume S8 coding scheme.
		 */
		delay = HAL_RADIO_NS2US_ROUND(
   246f2:	4410      	add	r0, r2
   246f4:	9200      	str	r2, [sp, #0]

NRF_STATIC_INLINE void nrf_ppi_task_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                   nrf_ppi_channel_t channel,
                                                   uint32_t          tep)
{
    p_reg->CH[(uint32_t) channel].TEP = tep;
   246f6:	4a5a      	ldr	r2, [pc, #360]	; (24860 <sw_switch.isra.5+0x20c>)
   246f8:	f8c6 2514 	str.w	r2, [r6, #1300]	; 0x514
		    HAL_SW_SWITCH_RADIO_ENABLE_S2_PPI(sw_tifs_toggle);
		u8_t ppi_dis =
			HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI(
			    sw_tifs_toggle);

		if (phy_curr & BIT(2)) {
   246fc:	f018 0604 	ands.w	r6, r8, #4
		delay = HAL_RADIO_NS2US_ROUND(
   24700:	f44f 7a7a 	mov.w	sl, #1000	; 0x3e8
   24704:	fbb0 f0fa 	udiv	r0, r0, sl
		if (phy_curr & BIT(2)) {
   24708:	d078      	beq.n	247fc <sw_switch.isra.5+0x1a8>
			/* Switching to TX after RX on LE Coded PHY. */

			u8_t cc_s2 =
			    SW_SWITCH_TIMER_S2_EVTS_COMP(sw_tifs_toggle);
   2470a:	f10c 0c02 	add.w	ip, ip, #2

			u32_t delay_s2;

			/* Calculate assuming reception on S2 coding scheme. */
			delay_s2 = HAL_RADIO_NS2US_ROUND(
   2470e:	9a00      	ldr	r2, [sp, #0]
#if defined(CONFIG_BT_CTLR_PHY_CODED)
	case BIT(2):
		if (flags & 0x01) {
			return HAL_RADIO_NRF52840_RX_CHAIN_DELAY_S8_NS;
		} else {
			return HAL_RADIO_NRF52840_RX_CHAIN_DELAY_S2_NS;
   24710:	f242 46b8 	movw	r6, #9400	; 0x24b8
   24714:	fa5f fc8c 	uxtb.w	ip, ip
   24718:	f246 0718 	movw	r7, #24600	; 0x6018
   2471c:	f1b8 0f04 	cmp.w	r8, #4
   24720:	bf14      	ite	ne
   24722:	46b0      	movne	r8, r6
   24724:	46b8      	moveq	r8, r7
   24726:	ea4f 098c 	mov.w	r9, ip, lsl #2
				hal_radio_tx_ready_delay_ns_get(
					phy_next, flags_next) +
				hal_radio_rx_chain_delay_ns_get(phy_curr, 0));

			SW_SWITCH_TIMER->CC[cc_s2] =
				SW_SWITCH_TIMER->CC[cc];
   2472a:	4e4e      	ldr	r6, [pc, #312]	; (24864 <sw_switch.isra.5+0x210>)
			delay_s2 = HAL_RADIO_NS2US_ROUND(
   2472c:	4442      	add	r2, r8
   2472e:	f109 4980 	add.w	r9, r9, #1073741824	; 0x40000000
   24732:	fbb2 fafa 	udiv	sl, r2, sl
				SW_SWITCH_TIMER->CC[cc];
   24736:	f50e 72a8 	add.w	r2, lr, #336	; 0x150
   2473a:	f509 4910 	add.w	r9, r9, #36864	; 0x9000
   2473e:	f856 2022 	ldr.w	r2, [r6, r2, lsl #2]
			SW_SWITCH_TIMER->CC[cc_s2] =
   24742:	f8c9 2540 	str.w	r2, [r9, #1344]	; 0x540

			if (delay_s2 < SW_SWITCH_TIMER->CC[cc_s2]) {
   24746:	f8d9 2540 	ldr.w	r2, [r9, #1344]	; 0x540
   2474a:	4592      	cmp	sl, r2
				SW_SWITCH_TIMER->CC[cc_s2] -= delay_s2;
   2474c:	bf34      	ite	cc
   2474e:	f8d9 6540 	ldrcc.w	r6, [r9, #1344]	; 0x540
			} else {
				SW_SWITCH_TIMER->CC[cc_s2] = 1;
   24752:	2201      	movcs	r2, #1
   24754:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   24758:	bf28      	it	cs
   2475a:	f8c9 2540 	strcs.w	r2, [r9, #1344]	; 0x540
   2475e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000

static inline void hal_radio_sw_switch_coded_tx_config_set(u8_t ppi_en,
	u8_t ppi_dis, u8_t cc_s2, u8_t group_index)
{
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_EVT(ppi_en) =
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(cc_s2);
   24762:	9a01      	ldr	r2, [sp, #4]
   24764:	f503 33f8 	add.w	r3, r3, #126976	; 0x1f000
				SW_SWITCH_TIMER->CC[cc_s2] -= delay_s2;
   24768:	bf3c      	itt	cc
   2476a:	eba6 060a 	subcc.w	r6, r6, sl
   2476e:	f8c9 6540 	strcc.w	r6, [r9, #1344]	; 0x540
   24772:	eb02 028c 	add.w	r2, r2, ip, lsl #2

	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_TASK(ppi_en) =
   24776:	4e3a      	ldr	r6, [pc, #232]	; (24860 <sw_switch.isra.5+0x20c>)
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_EVT(ppi_en) =
   24778:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_TASK(ppi_en) =
   2477c:	f8c3 6514 	str.w	r6, [r3, #1300]	; 0x514
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_TASK_TX;

	/* Wire the Group task disable
	 * to the S2 EVENTS_COMPARE.
	 */
	HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_REGISTER_EVT(
   24780:	00e3      	lsls	r3, r4, #3
   24782:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   24786:	f503 33f8 	add.w	r3, r3, #126976	; 0x1f000
	    ppi_dis)	=
   2478a:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	    HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_EVT(cc_s2);

	HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_REGISTER_TASK(
	    ppi_dis) =
   2478e:	f8c3 1514 	str.w	r1, [r3, #1300]	; 0x514
	    group_index);

	/* Capture CC to cancel the timer that has assumed
	 * S8 reception, if packet will be received in S2.
	 */
	HAL_SW_SWITCH_TIMER_S8_DISABLE_PPI_REGISTER_EVT =
   24792:	4a35      	ldr	r2, [pc, #212]	; (24868 <sw_switch.isra.5+0x214>)
   24794:	4b2f      	ldr	r3, [pc, #188]	; (24854 <sw_switch.isra.5+0x200>)
   24796:	f8c3 25a0 	str.w	r2, [r3, #1440]	; 0x5a0
		HAL_SW_SWITCH_TIMER_S8_DISABLE_PPI_EVT;
	HAL_SW_SWITCH_TIMER_S8_DISABLE_PPI_REGISTER_TASK =
		HAL_SW_SWITCH_TIMER_S8_DISABLE_PPI_TASK(
   2479a:	f502 42fd 	add.w	r2, r2, #32384	; 0x7e80
   2479e:	3270      	adds	r2, #112	; 0x70
   247a0:	00a9      	lsls	r1, r5, #2
   247a2:	4411      	add	r1, r2
    p_reg->CHENSET = mask;
   247a4:	f44f 2280 	mov.w	r2, #262144	; 0x40000
	HAL_SW_SWITCH_TIMER_S8_DISABLE_PPI_REGISTER_TASK =
   247a8:	f8c3 15a4 	str.w	r1, [r3, #1444]	; 0x5a4
   247ac:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
		}
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
	}

	if (delay <
   247b0:	00ad      	lsls	r5, r5, #2
   247b2:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
   247b6:	f505 4510 	add.w	r5, r5, #36864	; 0x9000
	 * always need to capture the PDU END time-stamp.
	 */
	radio_tmr_end_capture();
#endif /* CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */

	sw_tifs_toggle += 1U;
   247ba:	f10e 0e01 	add.w	lr, lr, #1
		SW_SWITCH_TIMER->CC[cc]) {
   247be:	f8d5 3540 	ldr.w	r3, [r5, #1344]	; 0x540
	if (delay <
   247c2:	4283      	cmp	r3, r0
				 SW_SWITCH_TIMER->CC[cc] - delay);
   247c4:	bf8b      	itete	hi
   247c6:	f8d5 3540 	ldrhi.w	r3, [r5, #1344]	; 0x540

NRF_STATIC_INLINE void nrf_timer_cc_set(NRF_TIMER_Type *       p_reg,
                                        nrf_timer_cc_channel_t cc_channel,
                                        uint32_t               cc_value)
{
    p_reg->CC[cc_channel] = cc_value;
   247ca:	2301      	movls	r3, #1
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
   247cc:	1a18      	subhi	r0, r3, r0
   247ce:	f8c5 3540 	strls.w	r3, [r5, #1344]	; 0x540
   247d2:	4b20      	ldr	r3, [pc, #128]	; (24854 <sw_switch.isra.5+0x200>)
   247d4:	bf88      	it	hi
   247d6:	f8c5 0540 	strhi.w	r0, [r5, #1344]	; 0x540
   247da:	f44f 6290 	mov.w	r2, #1152	; 0x480
	sw_tifs_toggle &= 1;
   247de:	f00e 0e01 	and.w	lr, lr, #1
   247e2:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
   247e6:	f88b e000 	strb.w	lr, [fp]
}
   247ea:	b003      	add	sp, #12
   247ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return HAL_RADIO_NRF52840_TXEN_TXIDLE_TX_2M_NS;
   247f0:	f649 4240 	movw	r2, #40000	; 0x9c40
   247f4:	e76f      	b.n	246d6 <sw_switch.isra.5+0x82>
		return HAL_RADIO_NRF52840_RX_CHAIN_DELAY_2M_NS;
   247f6:	f241 3088 	movw	r0, #5000	; 0x1388
   247fa:	e778      	b.n	246ee <sw_switch.isra.5+0x9a>

static inline void hal_radio_sw_switch_coded_config_clear(u8_t ppi_en,
	u8_t ppi_dis, u8_t cc_reg, u8_t group_index)
{
	/* Invalidate PPI used when RXing on LE Coded PHY. */
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_EVT(
   247fc:	00db      	lsls	r3, r3, #3
   247fe:	00ff      	lsls	r7, r7, #3
   24800:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   24804:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
   24808:	f503 33f8 	add.w	r3, r3, #126976	; 0x1f000
   2480c:	f507 37f8 	add.w	r7, r7, #126976	; 0x1f000
		ppi_en) = 0;
   24810:	f8c3 6510 	str.w	r6, [r3, #1296]	; 0x510
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_TASK(
		ppi_en) = 0;
   24814:	f8c3 6514 	str.w	r6, [r3, #1300]	; 0x514

	/* Wire the Group task disable to the default EVENTS_COMPARE. */
	HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_REGISTER_EVT(
		ppi_dis) =
   24818:	f8c7 9510 	str.w	r9, [r7, #1296]	; 0x510
		HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_EVT(cc_reg);
	HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_REGISTER_TASK(
		ppi_dis) =
   2481c:	f8c7 1514 	str.w	r1, [r7, #1300]	; 0x514
   24820:	e7c6      	b.n	247b0 <sw_switch.isra.5+0x15c>
    p_reg->CH[(uint32_t) channel].TEP = tep;
   24822:	00db      	lsls	r3, r3, #3
   24824:	00e4      	lsls	r4, r4, #3
   24826:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   2482a:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
   2482e:	f503 33f8 	add.w	r3, r3, #126976	; 0x1f000
   24832:	f504 34f8 	add.w	r4, r4, #126976	; 0x1f000
   24836:	4a0d      	ldr	r2, [pc, #52]	; (2486c <sw_switch.isra.5+0x218>)
   24838:	f8c6 2514 	str.w	r2, [r6, #1300]	; 0x514
		ppi_en) = 0;
   2483c:	f8c3 0510 	str.w	r0, [r3, #1296]	; 0x510
		ppi_en) = 0;
   24840:	f8c3 0514 	str.w	r0, [r3, #1300]	; 0x514
		ppi_dis) =
   24844:	f8c4 9510 	str.w	r9, [r4, #1296]	; 0x510
		delay = HAL_RADIO_NS2US_CEIL(
   24848:	202c      	movs	r0, #44	; 0x2c
		ppi_dis) =
   2484a:	f8c4 1514 	str.w	r1, [r4, #1300]	; 0x514
   2484e:	e7af      	b.n	247b0 <sw_switch.isra.5+0x15c>
   24850:	20004009 	.word	0x20004009
   24854:	4001f000 	.word	0x4001f000
   24858:	4000110c 	.word	0x4000110c
   2485c:	4001f004 	.word	0x4001f004
   24860:	40001000 	.word	0x40001000
   24864:	40009000 	.word	0x40009000
   24868:	40001150 	.word	0x40001150
   2486c:	40001004 	.word	0x40001004

00024870 <isr_radio>:
	return (NRF_RADIO->EVENTS_DISABLED != 0);
   24870:	4b04      	ldr	r3, [pc, #16]	; (24884 <isr_radio+0x14>)
   24872:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
	if (radio_has_disabled()) {
   24876:	b123      	cbz	r3, 24882 <isr_radio+0x12>
		isr_cb(isr_cb_param);
   24878:	4b03      	ldr	r3, [pc, #12]	; (24888 <isr_radio+0x18>)
   2487a:	4a04      	ldr	r2, [pc, #16]	; (2488c <isr_radio+0x1c>)
   2487c:	681b      	ldr	r3, [r3, #0]
   2487e:	6810      	ldr	r0, [r2, #0]
   24880:	4718      	bx	r3
}
   24882:	4770      	bx	lr
   24884:	40001000 	.word	0x40001000
   24888:	20003938 	.word	0x20003938
   2488c:	2000393c 	.word	0x2000393c

00024890 <radio_isr_set>:
{
   24890:	b538      	push	{r3, r4, r5, lr}
   24892:	4604      	mov	r4, r0
	irq_disable(RADIO_IRQn);
   24894:	2001      	movs	r0, #1
{
   24896:	460d      	mov	r5, r1
	irq_disable(RADIO_IRQn);
   24898:	f7ef f922 	bl	13ae0 <arch_irq_disable>
	isr_cb_param = param;
   2489c:	4b08      	ldr	r3, [pc, #32]	; (248c0 <radio_isr_set+0x30>)
   2489e:	601d      	str	r5, [r3, #0]
	isr_cb = cb;
   248a0:	4b08      	ldr	r3, [pc, #32]	; (248c4 <radio_isr_set+0x34>)
   248a2:	601c      	str	r4, [r3, #0]
    return p_reg->SHORTS;
}

NRF_STATIC_INLINE void nrf_radio_int_enable(NRF_RADIO_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
   248a4:	4b08      	ldr	r3, [pc, #32]	; (248c8 <radio_isr_set+0x38>)
   248a6:	2210      	movs	r2, #16
   248a8:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   248ac:	4b07      	ldr	r3, [pc, #28]	; (248cc <radio_isr_set+0x3c>)
   248ae:	2202      	movs	r2, #2
   248b0:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
	irq_enable(RADIO_IRQn);
   248b4:	2001      	movs	r0, #1
}
   248b6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	irq_enable(RADIO_IRQn);
   248ba:	f7ef b901 	b.w	13ac0 <arch_irq_enable>
   248be:	bf00      	nop
   248c0:	2000393c 	.word	0x2000393c
   248c4:	20003938 	.word	0x20003938
   248c8:	40001000 	.word	0x40001000
   248cc:	e000e100 	.word	0xe000e100

000248d0 <radio_reset>:
{
   248d0:	b508      	push	{r3, lr}
	irq_disable(RADIO_IRQn);
   248d2:	2001      	movs	r0, #1
   248d4:	f7ef f904 	bl	13ae0 <arch_irq_disable>
}
#endif

NRF_STATIC_INLINE void nrf_radio_power_set(NRF_RADIO_Type * p_reg, bool radio_power)
{
    p_reg->POWER = (uint32_t) radio_power;
   248d8:	4b0b      	ldr	r3, [pc, #44]	; (24908 <radio_reset+0x38>)
   248da:	2200      	movs	r2, #0
   248dc:	f8c3 2ffc 	str.w	r2, [r3, #4092]	; 0xffc
   248e0:	2201      	movs	r2, #1
   248e2:	f8c3 2ffc 	str.w	r2, [r3, #4092]	; 0xffc
	*(volatile u32_t *)0x40001774 = ((*(volatile u32_t *)0x40001774) &
   248e6:	4a09      	ldr	r2, [pc, #36]	; (2490c <radio_reset+0x3c>)
   248e8:	6813      	ldr	r3, [r2, #0]
					 0xfffffffe) | 0x01000000;
   248ea:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   248ee:	f023 0301 	bic.w	r3, r3, #1
   248f2:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
	*(volatile u32_t *)0x40001774 = ((*(volatile u32_t *)0x40001774) &
   248f6:	6013      	str	r3, [r2, #0]
			HAL_SW_SWITCH_RADIO_ENABLE_PPI_0_INCLUDE;
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(1)] =
		HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_1_INCLUDE |
			HAL_SW_SWITCH_RADIO_ENABLE_PPI_1_INCLUDE;
#else
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(0)] =
   248f8:	4b05      	ldr	r3, [pc, #20]	; (24910 <radio_reset+0x40>)
   248fa:	4a06      	ldr	r2, [pc, #24]	; (24914 <radio_reset+0x44>)
   248fc:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_0_INCLUDE |
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_0_INCLUDE |
		HAL_SW_SWITCH_RADIO_ENABLE_S2_PPI_0_INCLUDE;
	NRF_PPI->CHG[SW_SWITCH_TIMER_TASK_GROUP(1)] =
   24900:	4a05      	ldr	r2, [pc, #20]	; (24918 <radio_reset+0x48>)
   24902:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
}
   24906:	bd08      	pop	{r3, pc}
   24908:	40001000 	.word	0x40001000
   2490c:	40001774 	.word	0x40001774
   24910:	4001f000 	.word	0x4001f000
   24914:	00010900 	.word	0x00010900
   24918:	00021200 	.word	0x00021200

0002491c <radio_phy_set>:
	switch (phy) {
   2491c:	2802      	cmp	r0, #2
   2491e:	4b14      	ldr	r3, [pc, #80]	; (24970 <radio_phy_set+0x54>)
   24920:	d010      	beq.n	24944 <radio_phy_set+0x28>
   24922:	2804      	cmp	r0, #4
   24924:	d014      	beq.n	24950 <radio_phy_set+0x34>
		*(volatile u32_t *)0x4000173c &= ~0x80000000;
   24926:	681a      	ldr	r2, [r3, #0]
   24928:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
   2492c:	601a      	str	r2, [r3, #0]
		mode = RADIO_MODE_MODE_Ble_1Mbit;
   2492e:	2103      	movs	r1, #3
	NRF_RADIO->MODE = (mode << RADIO_MODE_MODE_Pos) & RADIO_MODE_MODE_Msk;
   24930:	4b10      	ldr	r3, [pc, #64]	; (24974 <radio_phy_set+0x58>)
   24932:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
	NRF_RADIO->MODECNF0 |= (RADIO_MODECNF0_RU_Fast <<
   24936:	f8d3 2650 	ldr.w	r2, [r3, #1616]	; 0x650
   2493a:	f042 0201 	orr.w	r2, r2, #1
   2493e:	f8c3 2650 	str.w	r2, [r3, #1616]	; 0x650
}
   24942:	4770      	bx	lr
		*(volatile u32_t *)0x4000173c &= ~0x80000000;
   24944:	681a      	ldr	r2, [r3, #0]
   24946:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
   2494a:	601a      	str	r2, [r3, #0]
		mode = RADIO_MODE_MODE_Ble_2Mbit;
   2494c:	2104      	movs	r1, #4
   2494e:	e7ef      	b.n	24930 <radio_phy_set+0x14>
		*(volatile u32_t *)0x4000173c |= 0x80000000;
   24950:	681a      	ldr	r2, [r3, #0]
   24952:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
   24956:	601a      	str	r2, [r3, #0]
				((*(volatile u32_t *)0x4000173c) & 0xFFFFFF00) |
   24958:	681a      	ldr	r2, [r3, #0]
   2495a:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
		if (flags & 0x01) {
   2495e:	f011 0f01 	tst.w	r1, #1
				((*(volatile u32_t *)0x4000173c) & 0xFFFFFF00) |
   24962:	f042 025c 	orr.w	r2, r2, #92	; 0x5c
			mode = RADIO_MODE_MODE_Ble_LR500Kbit;
   24966:	bf14      	ite	ne
   24968:	2105      	movne	r1, #5
   2496a:	2106      	moveq	r1, #6
		*(volatile u32_t *)0x4000173c =
   2496c:	601a      	str	r2, [r3, #0]
		break;
   2496e:	e7df      	b.n	24930 <radio_phy_set+0x14>
   24970:	4000173c 	.word	0x4000173c
   24974:	40001000 	.word	0x40001000

00024978 <radio_tx_power_set>:
	NRF_RADIO->TXPOWER = power;
   24978:	4b01      	ldr	r3, [pc, #4]	; (24980 <radio_tx_power_set+0x8>)
   2497a:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
}
   2497e:	4770      	bx	lr
   24980:	40001000 	.word	0x40001000

00024984 <radio_freq_chan_set>:
	NRF_RADIO->FREQUENCY = chan;
   24984:	4b01      	ldr	r3, [pc, #4]	; (2498c <radio_freq_chan_set+0x8>)
   24986:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
}
   2498a:	4770      	bx	lr
   2498c:	40001000 	.word	0x40001000

00024990 <radio_whiten_iv_set>:
	NRF_RADIO->DATAWHITEIV = iv;
   24990:	4b07      	ldr	r3, [pc, #28]	; (249b0 <radio_whiten_iv_set+0x20>)
   24992:	f8c3 0554 	str.w	r0, [r3, #1364]	; 0x554
	NRF_RADIO->PCNF1 &= ~RADIO_PCNF1_WHITEEN_Msk;
   24996:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
   2499a:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
   2499e:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((1UL) << RADIO_PCNF1_WHITEEN_Pos) &
   249a2:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
   249a6:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
   249aa:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
   249ae:	4770      	bx	lr
   249b0:	40001000 	.word	0x40001000

000249b4 <radio_aa_set>:
	NRF_RADIO->TXADDRESS =
   249b4:	4a0a      	ldr	r2, [pc, #40]	; (249e0 <radio_aa_set+0x2c>)
   249b6:	2300      	movs	r3, #0
   249b8:	f8c2 352c 	str.w	r3, [r2, #1324]	; 0x52c
	NRF_RADIO->RXADDRESSES =
   249bc:	2301      	movs	r3, #1
   249be:	f8c2 3530 	str.w	r3, [r2, #1328]	; 0x530
	NRF_RADIO->PREFIX0 = aa[3];
   249c2:	78c3      	ldrb	r3, [r0, #3]
   249c4:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
	NRF_RADIO->BASE0 = (aa[2] << 24) | (aa[1] << 16) | (aa[0] << 8);
   249c8:	7843      	ldrb	r3, [r0, #1]
   249ca:	7881      	ldrb	r1, [r0, #2]
   249cc:	041b      	lsls	r3, r3, #16
   249ce:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
   249d2:	7801      	ldrb	r1, [r0, #0]
   249d4:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   249d8:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c
}
   249dc:	4770      	bx	lr
   249de:	bf00      	nop
   249e0:	40001000 	.word	0x40001000

000249e4 <radio_pkt_configure>:
	u8_t dc = flags & 0x01; /* Adv or Data channel */
   249e4:	f002 0301 	and.w	r3, r2, #1
	phy = (flags >> 1) & 0x07; /* phy */
   249e8:	f3c2 0242 	ubfx	r2, r2, #1, #3
	switch (phy) {
   249ec:	2a02      	cmp	r2, #2
   249ee:	d023      	beq.n	24a38 <radio_pkt_configure+0x54>
		extra |= (RADIO_PCNF0_PLEN_8bit << RADIO_PCNF0_PLEN_Pos) &
   249f0:	2a04      	cmp	r2, #4
   249f2:	bf0c      	ite	eq
   249f4:	f04f 42c7 	moveq.w	r2, #1669332992	; 0x63800000
   249f8:	2200      	movne	r2, #0
	if (dc) {
   249fa:	b10b      	cbz	r3, 24a00 <radio_pkt_configure+0x1c>
		extra |= (RADIO_PCNF0_S1INCL_Include <<
   249fc:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
			   ((((u32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
   24a00:	f1c0 0308 	rsb	r3, r0, #8
   24a04:	041b      	lsls	r3, r3, #16
			   ((((u32_t)bits_len) << RADIO_PCNF0_LFLEN_Pos) &
   24a06:	f000 000f 	and.w	r0, r0, #15
			    RADIO_PCNF0_S1LEN_Msk) |
   24a0a:	4310      	orrs	r0, r2
			   ((((u32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
   24a0c:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
	NRF_RADIO->PCNF0 = (((1UL) << RADIO_PCNF0_S0LEN_Pos) &
   24a10:	4a0b      	ldr	r2, [pc, #44]	; (24a40 <radio_pkt_configure+0x5c>)
			    RADIO_PCNF0_S1LEN_Msk) |
   24a12:	4303      	orrs	r3, r0
   24a14:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	NRF_RADIO->PCNF0 = (((1UL) << RADIO_PCNF0_S0LEN_Pos) &
   24a18:	f8c2 3514 	str.w	r3, [r2, #1300]	; 0x514
	NRF_RADIO->PCNF1 &= ~(RADIO_PCNF1_MAXLEN_Msk | RADIO_PCNF1_STATLEN_Msk |
   24a1c:	f8d2 0518 	ldr.w	r0, [r2, #1304]	; 0x518
   24a20:	4b08      	ldr	r3, [pc, #32]	; (24a44 <radio_pkt_configure+0x60>)
   24a22:	4003      	ands	r3, r0
   24a24:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((((u32_t)max_len) << RADIO_PCNF1_MAXLEN_Pos) &
   24a28:	f8d2 3518 	ldr.w	r3, [r2, #1304]	; 0x518
   24a2c:	4319      	orrs	r1, r3
   24a2e:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
   24a32:	f8c2 1518 	str.w	r1, [r2, #1304]	; 0x518
}
   24a36:	4770      	bx	lr
		extra |= (RADIO_PCNF0_PLEN_16bit << RADIO_PCNF0_PLEN_Pos) &
   24a38:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   24a3c:	e7dd      	b.n	249fa <radio_pkt_configure+0x16>
   24a3e:	bf00      	nop
   24a40:	40001000 	.word	0x40001000
   24a44:	fef80000 	.word	0xfef80000

00024a48 <radio_pkt_rx_set>:
	NRF_RADIO->PACKETPTR = (u32_t)rx_packet;
   24a48:	4b01      	ldr	r3, [pc, #4]	; (24a50 <radio_pkt_rx_set+0x8>)
   24a4a:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
}
   24a4e:	4770      	bx	lr
   24a50:	40001000 	.word	0x40001000

00024a54 <radio_pkt_tx_set>:
   24a54:	4b01      	ldr	r3, [pc, #4]	; (24a5c <radio_pkt_tx_set+0x8>)
   24a56:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
   24a5a:	4770      	bx	lr
   24a5c:	40001000 	.word	0x40001000

00024a60 <radio_rx_enable>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   24a60:	4b01      	ldr	r3, [pc, #4]	; (24a68 <radio_rx_enable+0x8>)
   24a62:	2201      	movs	r2, #1
   24a64:	601a      	str	r2, [r3, #0]
}
   24a66:	4770      	bx	lr
   24a68:	40001004 	.word	0x40001004

00024a6c <radio_tx_enable>:
   24a6c:	4b01      	ldr	r3, [pc, #4]	; (24a74 <radio_tx_enable+0x8>)
   24a6e:	2201      	movs	r2, #1
   24a70:	601a      	str	r2, [r3, #0]
}
   24a72:	4770      	bx	lr
   24a74:	40001000 	.word	0x40001000

00024a78 <radio_disable>:
    p_reg->CHENCLR = mask;
   24a78:	4a07      	ldr	r2, [pc, #28]	; (24a98 <radio_disable+0x20>)
   24a7a:	f44f 6390 	mov.w	r3, #1152	; 0x480
   24a7e:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    p_reg->TASKS_CHG[(uint32_t) group].EN = 1UL;
}

NRF_STATIC_INLINE void nrf_ppi_group_disable(NRF_PPI_Type * p_reg, nrf_ppi_channel_group_t group)
{
    p_reg->TASKS_CHG[(uint32_t) group].DIS = 1UL;
   24a82:	2301      	movs	r3, #1
   24a84:	6053      	str	r3, [r2, #4]
   24a86:	60d3      	str	r3, [r2, #12]
	NRF_RADIO->SHORTS = 0;
   24a88:	f5a2 32f0 	sub.w	r2, r2, #122880	; 0x1e000
   24a8c:	2100      	movs	r1, #0
   24a8e:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
   24a92:	6113      	str	r3, [r2, #16]
}
   24a94:	4770      	bx	lr
   24a96:	bf00      	nop
   24a98:	4001f000 	.word	0x4001f000

00024a9c <radio_status_reset>:
	NRF_RADIO->EVENTS_READY = 0;
   24a9c:	4b04      	ldr	r3, [pc, #16]	; (24ab0 <radio_status_reset+0x14>)
   24a9e:	2200      	movs	r2, #0
   24aa0:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	NRF_RADIO->EVENTS_END = 0;
   24aa4:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
	NRF_RADIO->EVENTS_DISABLED = 0;
   24aa8:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
}
   24aac:	4770      	bx	lr
   24aae:	bf00      	nop
   24ab0:	40001000 	.word	0x40001000

00024ab4 <radio_is_ready>:
	return (NRF_RADIO->EVENTS_READY != 0);
   24ab4:	4b03      	ldr	r3, [pc, #12]	; (24ac4 <radio_is_ready+0x10>)
   24ab6:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
}
   24aba:	3000      	adds	r0, #0
   24abc:	bf18      	it	ne
   24abe:	2001      	movne	r0, #1
   24ac0:	4770      	bx	lr
   24ac2:	bf00      	nop
   24ac4:	40001000 	.word	0x40001000

00024ac8 <radio_is_done>:
	return (NRF_RADIO->EVENTS_END != 0);
   24ac8:	4b03      	ldr	r3, [pc, #12]	; (24ad8 <radio_is_done+0x10>)
   24aca:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
}
   24ace:	3000      	adds	r0, #0
   24ad0:	bf18      	it	ne
   24ad2:	2001      	movne	r0, #1
   24ad4:	4770      	bx	lr
   24ad6:	bf00      	nop
   24ad8:	40001000 	.word	0x40001000

00024adc <radio_crc_configure>:
	NRF_RADIO->CRCCNF =
   24adc:	4b04      	ldr	r3, [pc, #16]	; (24af0 <radio_crc_configure+0x14>)
   24ade:	f240 1203 	movw	r2, #259	; 0x103
   24ae2:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
	NRF_RADIO->CRCPOLY = polynomial;
   24ae6:	f8c3 0538 	str.w	r0, [r3, #1336]	; 0x538
	NRF_RADIO->CRCINIT = iv;
   24aea:	f8c3 153c 	str.w	r1, [r3, #1340]	; 0x53c
}
   24aee:	4770      	bx	lr
   24af0:	40001000 	.word	0x40001000

00024af4 <radio_crc_is_valid>:
	return (NRF_RADIO->CRCSTATUS != 0);
   24af4:	4b03      	ldr	r3, [pc, #12]	; (24b04 <radio_crc_is_valid+0x10>)
   24af6:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
   24afa:	3000      	adds	r0, #0
   24afc:	bf18      	it	ne
   24afe:	2001      	movne	r0, #1
   24b00:	4770      	bx	lr
   24b02:	bf00      	nop
   24b04:	40001000 	.word	0x40001000

00024b08 <radio_pkt_empty_get>:
}
   24b08:	4800      	ldr	r0, [pc, #0]	; (24b0c <radio_pkt_empty_get+0x4>)
   24b0a:	4770      	bx	lr
   24b0c:	20003830 	.word	0x20003830

00024b10 <radio_pkt_scratch_get>:
}
   24b10:	4800      	ldr	r0, [pc, #0]	; (24b14 <radio_pkt_scratch_get+0x4>)
   24b12:	4770      	bx	lr
   24b14:	20003834 	.word	0x20003834

00024b18 <radio_switch_complete_and_rx>:
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_RXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
   24b18:	4b04      	ldr	r3, [pc, #16]	; (24b2c <radio_switch_complete_and_rx+0x14>)
   24b1a:	2203      	movs	r2, #3
   24b1c:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
			    RADIO_SHORTS_END_DISABLE_Msk;
	sw_switch(0, 0, 0, phy_rx, 0);
   24b20:	2300      	movs	r3, #0
   24b22:	4602      	mov	r2, r0
   24b24:	4619      	mov	r1, r3
   24b26:	4618      	mov	r0, r3
   24b28:	f7ff bd94 	b.w	24654 <sw_switch.isra.5>
   24b2c:	40001000 	.word	0x40001000

00024b30 <radio_switch_complete_and_tx>:
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_TXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
   24b30:	4904      	ldr	r1, [pc, #16]	; (24b44 <radio_switch_complete_and_tx+0x14>)
{
   24b32:	b410      	push	{r4}
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
   24b34:	2403      	movs	r4, #3
   24b36:	f8c1 4200 	str.w	r4, [r1, #512]	; 0x200
			    RADIO_SHORTS_END_DISABLE_Msk;
	sw_switch(1, phy_rx, flags_rx, phy_tx, flags_tx);
   24b3a:	4601      	mov	r1, r0
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   24b3c:	bc10      	pop	{r4}
	sw_switch(1, phy_rx, flags_rx, phy_tx, flags_tx);
   24b3e:	2001      	movs	r0, #1
   24b40:	f7ff bd88 	b.w	24654 <sw_switch.isra.5>
   24b44:	40001000 	.word	0x40001000

00024b48 <radio_switch_complete_and_disable>:

void radio_switch_complete_and_disable(void)
{
	NRF_RADIO->SHORTS =
   24b48:	4b05      	ldr	r3, [pc, #20]	; (24b60 <radio_switch_complete_and_disable+0x18>)
   24b4a:	2203      	movs	r2, #3
   24b4c:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
    p_reg->CHENCLR = mask;
   24b50:	f503 33f0 	add.w	r3, r3, #122880	; 0x1e000
   24b54:	f44f 6290 	mov.w	r2, #1152	; 0x480
   24b58:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
	    (RADIO_SHORTS_READY_START_Msk | RADIO_SHORTS_END_DISABLE_Msk);

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	hal_radio_sw_switch_disable();
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   24b5c:	4770      	bx	lr
   24b5e:	bf00      	nop
   24b60:	40001000 	.word	0x40001000

00024b64 <radio_rssi_measure>:

void radio_rssi_measure(void)
{
	NRF_RADIO->SHORTS |=
   24b64:	4a03      	ldr	r2, [pc, #12]	; (24b74 <radio_rssi_measure+0x10>)
   24b66:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
   24b6a:	f443 7388 	orr.w	r3, r3, #272	; 0x110
   24b6e:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
	    (RADIO_SHORTS_ADDRESS_RSSISTART_Msk |
	     RADIO_SHORTS_DISABLED_RSSISTOP_Msk);
}
   24b72:	4770      	bx	lr
   24b74:	40001000 	.word	0x40001000

00024b78 <radio_rssi_get>:

u32_t radio_rssi_get(void)
{
	return NRF_RADIO->RSSISAMPLE;
   24b78:	4b01      	ldr	r3, [pc, #4]	; (24b80 <radio_rssi_get+0x8>)
   24b7a:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
}
   24b7e:	4770      	bx	lr
   24b80:	40001000 	.word	0x40001000

00024b84 <radio_rssi_status_reset>:

void radio_rssi_status_reset(void)
{
	NRF_RADIO->EVENTS_RSSIEND = 0;
   24b84:	4b02      	ldr	r3, [pc, #8]	; (24b90 <radio_rssi_status_reset+0xc>)
   24b86:	2200      	movs	r2, #0
   24b88:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
}
   24b8c:	4770      	bx	lr
   24b8e:	bf00      	nop
   24b90:	40001000 	.word	0x40001000

00024b94 <radio_rssi_is_ready>:

u32_t radio_rssi_is_ready(void)
{
	return (NRF_RADIO->EVENTS_RSSIEND != 0);
   24b94:	4b03      	ldr	r3, [pc, #12]	; (24ba4 <radio_rssi_is_ready+0x10>)
   24b96:	f8d3 011c 	ldr.w	r0, [r3, #284]	; 0x11c
}
   24b9a:	3000      	adds	r0, #0
   24b9c:	bf18      	it	ne
   24b9e:	2001      	movne	r0, #1
   24ba0:	4770      	bx	lr
   24ba2:	bf00      	nop
   24ba4:	40001000 	.word	0x40001000

00024ba8 <radio_filter_configure>:

void radio_filter_configure(u8_t bitmask_enable, u8_t bitmask_addr_type,
			    u8_t *bdaddr)
{
   24ba8:	b5f0      	push	{r4, r5, r6, r7, lr}
   24baa:	2400      	movs	r4, #0
   24bac:	2706      	movs	r7, #6
   24bae:	00a3      	lsls	r3, r4, #2
   24bb0:	fb07 2504 	mla	r5, r7, r4, r2
	u8_t index;

	for (index = 0U; index < 8; index++) {
		NRF_RADIO->DAB[index] = ((u32_t)bdaddr[3] << 24) |
   24bb4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   24bb8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
			((u32_t)bdaddr[2] << 16) |
			((u32_t)bdaddr[1] << 8) |
   24bbc:	682e      	ldr	r6, [r5, #0]
		NRF_RADIO->DAB[index] = ((u32_t)bdaddr[3] << 24) |
   24bbe:	f8c3 6600 	str.w	r6, [r3, #1536]	; 0x600
			bdaddr[0];
		NRF_RADIO->DAP[index] = ((u32_t)bdaddr[5] << 8) | bdaddr[4];
   24bc2:	3401      	adds	r4, #1
   24bc4:	88ad      	ldrh	r5, [r5, #4]
   24bc6:	f8c3 5620 	str.w	r5, [r3, #1568]	; 0x620
	for (index = 0U; index < 8; index++) {
   24bca:	2c08      	cmp	r4, #8
   24bcc:	d1ef      	bne.n	24bae <radio_filter_configure+0x6>
		bdaddr += 6;
	}

	NRF_RADIO->DACNF = ((u32_t)bitmask_addr_type << 8) | bitmask_enable;
   24bce:	4b03      	ldr	r3, [pc, #12]	; (24bdc <radio_filter_configure+0x34>)
   24bd0:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
   24bd4:	f8c3 0640 	str.w	r0, [r3, #1600]	; 0x640
}
   24bd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   24bda:	bf00      	nop
   24bdc:	40001000 	.word	0x40001000

00024be0 <radio_filter_disable>:

void radio_filter_disable(void)
{
	NRF_RADIO->DACNF &= ~(0x000000FF);
   24be0:	4a03      	ldr	r2, [pc, #12]	; (24bf0 <radio_filter_disable+0x10>)
   24be2:	f8d2 3640 	ldr.w	r3, [r2, #1600]	; 0x640
   24be6:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   24bea:	f8c2 3640 	str.w	r3, [r2, #1600]	; 0x640
}
   24bee:	4770      	bx	lr
   24bf0:	40001000 	.word	0x40001000

00024bf4 <radio_filter_status_reset>:

void radio_filter_status_reset(void)
{
	NRF_RADIO->EVENTS_DEVMATCH = 0;
   24bf4:	4b02      	ldr	r3, [pc, #8]	; (24c00 <radio_filter_status_reset+0xc>)
   24bf6:	2200      	movs	r2, #0
   24bf8:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
   24bfc:	4770      	bx	lr
   24bfe:	bf00      	nop
   24c00:	40001000 	.word	0x40001000

00024c04 <radio_filter_has_match>:

u32_t radio_filter_has_match(void)
{
	return (NRF_RADIO->EVENTS_DEVMATCH != 0);
   24c04:	4b03      	ldr	r3, [pc, #12]	; (24c14 <radio_filter_has_match+0x10>)
   24c06:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
}
   24c0a:	3000      	adds	r0, #0
   24c0c:	bf18      	it	ne
   24c0e:	2001      	movne	r0, #1
   24c10:	4770      	bx	lr
   24c12:	bf00      	nop
   24c14:	40001000 	.word	0x40001000

00024c18 <radio_filter_match_get>:

u32_t radio_filter_match_get(void)
{
	return NRF_RADIO->DAI;
   24c18:	4b01      	ldr	r3, [pc, #4]	; (24c20 <radio_filter_match_get+0x8>)
   24c1a:	f8d3 0410 	ldr.w	r0, [r3, #1040]	; 0x410
}
   24c1e:	4770      	bx	lr
   24c20:	40001000 	.word	0x40001000

00024c24 <radio_bc_configure>:
    p_reg->BCC = radio_bcc;
   24c24:	4b04      	ldr	r3, [pc, #16]	; (24c38 <radio_bc_configure+0x14>)
   24c26:	f8c3 0560 	str.w	r0, [r3, #1376]	; 0x560

void radio_bc_configure(u32_t n)
{
	nrf_radio_bcc_set(NRF_RADIO, n);
	NRF_RADIO->SHORTS |= RADIO_SHORTS_ADDRESS_BCSTART_Msk;
   24c2a:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   24c2e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   24c32:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
}
   24c36:	4770      	bx	lr
   24c38:	40001000 	.word	0x40001000

00024c3c <radio_tmr_status_reset>:
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
   24c3c:	4b05      	ldr	r3, [pc, #20]	; (24c54 <radio_tmr_status_reset+0x18>)
   24c3e:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   24c42:	f8c3 2348 	str.w	r2, [r3, #840]	; 0x348
   24c46:	f503 33a0 	add.w	r3, r3, #81920	; 0x14000
   24c4a:	4a03      	ldr	r2, [pc, #12]	; (24c58 <radio_tmr_status_reset+0x1c>)
   24c4c:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
			BIT(HAL_SW_SWITCH_TIMER_S8_DISABLE_PPI) |
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
			BIT(HAL_TRIGGER_CRYPT_PPI));
}
   24c50:	4770      	bx	lr
   24c52:	bf00      	nop
   24c54:	4000b000 	.word	0x4000b000
   24c58:	0e742060 	.word	0x0e742060

00024c5c <radio_tmr_tifs_set>:
void radio_tmr_tifs_set(u32_t tifs)
{
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->TIFS = tifs;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	nrf_timer_cc_set(SW_SWITCH_TIMER,
   24c5c:	4b03      	ldr	r3, [pc, #12]	; (24c6c <radio_tmr_tifs_set+0x10>)
   24c5e:	4a04      	ldr	r2, [pc, #16]	; (24c70 <radio_tmr_tifs_set+0x14>)
   24c60:	781b      	ldrb	r3, [r3, #0]
   24c62:	f503 73a8 	add.w	r3, r3, #336	; 0x150
   24c66:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
			 SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle), tifs);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   24c6a:	4770      	bx	lr
   24c6c:	20004009 	.word	0x20004009
   24c70:	40009000 	.word	0x40009000

00024c74 <radio_tmr_start>:

u32_t radio_tmr_start(u8_t trx, u32_t ticks_start, u32_t remainder)
{
   24c74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if ((!(remainder / 1000000UL)) || (remainder & 0x80000000)) {
   24c76:	f5a2 2374 	sub.w	r3, r2, #999424	; 0xf4000
   24c7a:	4c25      	ldr	r4, [pc, #148]	; (24d10 <radio_tmr_start+0x9c>)
   24c7c:	f5a3 7310 	sub.w	r3, r3, #576	; 0x240
   24c80:	42a3      	cmp	r3, r4
		ticks_start--;
		remainder += 30517578UL;
   24c82:	bf88      	it	hi
   24c84:	f102 72e8 	addhi.w	r2, r2, #30408704	; 0x1d00000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   24c88:	4b22      	ldr	r3, [pc, #136]	; (24d14 <radio_tmr_start+0xa0>)
	}
	remainder /= 1000000UL;
   24c8a:	4c23      	ldr	r4, [pc, #140]	; (24d18 <radio_tmr_start+0xa4>)
		remainder += 30517578UL;
   24c8c:	bf84      	itt	hi
   24c8e:	f502 32d4 	addhi.w	r2, r2, #108544	; 0x1a800
   24c92:	f502 72a5 	addhi.w	r2, r2, #330	; 0x14a
   24c96:	f04f 0501 	mov.w	r5, #1
	remainder /= 1000000UL;
   24c9a:	fbb2 f4f4 	udiv	r4, r2, r4

	nrf_timer_task_trigger(EVENT_TIMER, NRF_TIMER_TASK_CLEAR);
	EVENT_TIMER->MODE = 0;
   24c9e:	f04f 0600 	mov.w	r6, #0
	EVENT_TIMER->PRESCALER = 4;
   24ca2:	f04f 0704 	mov.w	r7, #4
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
   24ca6:	f04f 0202 	mov.w	r2, #2
   24caa:	601d      	str	r5, [r3, #0]
	EVENT_TIMER->MODE = 0;
   24cac:	f8c3 64f8 	str.w	r6, [r3, #1272]	; 0x4f8
	EVENT_TIMER->PRESCALER = 4;
   24cb0:	f8c3 7504 	str.w	r7, [r3, #1284]	; 0x504
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
   24cb4:	f8c3 24fc 	str.w	r2, [r3, #1276]	; 0x4fc
    p_reg->CC[ch] = cc_val;
   24cb8:	4a18      	ldr	r2, [pc, #96]	; (24d1c <radio_tmr_start+0xa8>)
    p_reg->CC[cc_channel] = cc_value;
   24cba:	f8c3 4534 	str.w	r4, [r3, #1332]	; 0x534
		ticks_start--;
   24cbe:	bf88      	it	hi
   24cc0:	f101 31ff 	addhi.w	r1, r1, #4294967295	; 0xffffffff
   24cc4:	f8c2 1548 	str.w	r1, [r2, #1352]	; 0x548
    p_reg->EVTENSET = mask;
   24cc8:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   24ccc:	f8c2 1344 	str.w	r1, [r2, #836]	; 0x344
    p_reg->CH[(uint32_t) channel].EEP = eep;
   24cd0:	4913      	ldr	r1, [pc, #76]	; (24d20 <radio_tmr_start+0xac>)
   24cd2:	f502 72a4 	add.w	r2, r2, #328	; 0x148
	EVENT_TIMER->MODE = 0;
   24cd6:	3b0c      	subs	r3, #12
   24cd8:	f8c1 2538 	str.w	r2, [r1, #1336]	; 0x538
    p_reg->CH[(uint32_t) channel].TEP = tep;
   24cdc:	f8c1 353c 	str.w	r3, [r1, #1340]	; 0x53c
    p_reg->CHENSET = mask;
   24ce0:	2320      	movs	r3, #32
   24ce2:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
	nrf_rtc_event_enable(NRF_RTC0, RTC_EVTENSET_COMPARE2_Msk);

	hal_event_timer_start_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_EVENT_TIMER_START_PPI));

	hal_radio_enable_on_tick_ppi_config_and_enable(trx);
   24ce6:	f7ff fca1 	bl	2462c <hal_radio_enable_on_tick_ppi_config_and_enable>
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	last_pdu_end_us = 0U;

#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_CLEAR);
	SW_SWITCH_TIMER->MODE = 0;
   24cea:	4b0e      	ldr	r3, [pc, #56]	; (24d24 <radio_tmr_start+0xb0>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   24cec:	4a0e      	ldr	r2, [pc, #56]	; (24d28 <radio_tmr_start+0xb4>)
   24cee:	6015      	str	r5, [r2, #0]
   24cf0:	f8c3 6504 	str.w	r6, [r3, #1284]	; 0x504
	SW_SWITCH_TIMER->PRESCALER = 4;
   24cf4:	f8c3 7510 	str.w	r7, [r3, #1296]	; 0x510
	SW_SWITCH_TIMER->BITMODE = 0; /* 16 bit */
   24cf8:	f8c3 6508 	str.w	r6, [r3, #1288]	; 0x508
   24cfc:	601d      	str	r5, [r3, #0]
    p_reg->CH[(uint32_t) channel].EEP = eep;
   24cfe:	f5a3 43fd 	sub.w	r3, r3, #32384	; 0x7e80
   24d02:	3b74      	subs	r3, #116	; 0x74
   24d04:	f8c1 3548 	str.w	r3, [r1, #1352]	; 0x548
	 */
#endif /* CONFIG_BT_CTLR_PHY_CODED && CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder;
}
   24d08:	4620      	mov	r0, r4
    p_reg->CH[(uint32_t) channel].TEP = tep;
   24d0a:	f8c1 254c 	str.w	r2, [r1, #1356]	; 0x54c
   24d0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   24d10:	7ff0bdbf 	.word	0x7ff0bdbf
   24d14:	4000800c 	.word	0x4000800c
   24d18:	000f4240 	.word	0x000f4240
   24d1c:	4000b000 	.word	0x4000b000
   24d20:	4001f000 	.word	0x4001f000
   24d24:	40009000 	.word	0x40009000
   24d28:	4000900c 	.word	0x4000900c

00024d2c <radio_tmr_start_tick>:
   24d2c:	4b0e      	ldr	r3, [pc, #56]	; (24d68 <radio_tmr_start_tick+0x3c>)
    p_reg->CC[cc_channel] = cc_value;
   24d2e:	4a0f      	ldr	r2, [pc, #60]	; (24d6c <radio_tmr_start_tick+0x40>)

u32_t radio_tmr_start_tick(u8_t trx, u32_t tick)
{
   24d30:	b510      	push	{r4, lr}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   24d32:	2401      	movs	r4, #1
   24d34:	601c      	str	r4, [r3, #0]
   24d36:	609c      	str	r4, [r3, #8]
    p_reg->CC[ch] = cc_val;
   24d38:	4b0d      	ldr	r3, [pc, #52]	; (24d70 <radio_tmr_start_tick+0x44>)
    p_reg->CC[cc_channel] = cc_value;
   24d3a:	f8c2 4540 	str.w	r4, [r2, #1344]	; 0x540
   24d3e:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
    p_reg->EVTENSET = mask;
   24d42:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   24d46:	f8c3 1344 	str.w	r1, [r3, #836]	; 0x344
    p_reg->CH[(uint32_t) channel].EEP = eep;
   24d4a:	f503 33a0 	add.w	r3, r3, #81920	; 0x14000
   24d4e:	4909      	ldr	r1, [pc, #36]	; (24d74 <radio_tmr_start_tick+0x48>)
   24d50:	f8c3 1538 	str.w	r1, [r3, #1336]	; 0x538
    p_reg->CH[(uint32_t) channel].TEP = tep;
   24d54:	f8c3 253c 	str.w	r2, [r3, #1340]	; 0x53c
    p_reg->CHENSET = mask;
   24d58:	2220      	movs	r2, #32
   24d5a:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	nrf_rtc_event_enable(NRF_RTC0, RTC_EVTENSET_COMPARE2_Msk);

	hal_event_timer_start_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_EVENT_TIMER_START_PPI));

	hal_radio_enable_on_tick_ppi_config_and_enable(trx);
   24d5e:	f7ff fc65 	bl	2462c <hal_radio_enable_on_tick_ppi_config_and_enable>
	last_pdu_end_us = 0U;
#endif /* CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder_us;
}
   24d62:	4620      	mov	r0, r4
   24d64:	bd10      	pop	{r4, pc}
   24d66:	bf00      	nop
   24d68:	40008004 	.word	0x40008004
   24d6c:	40008000 	.word	0x40008000
   24d70:	4000b000 	.word	0x4000b000
   24d74:	4000b148 	.word	0x4000b148

00024d78 <radio_tmr_start_get>:
    return p_reg->CC[ch];
   24d78:	4b01      	ldr	r3, [pc, #4]	; (24d80 <radio_tmr_start_get+0x8>)
   24d7a:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
}

u32_t radio_tmr_start_get(void)
{
	return nrf_rtc_cc_get(NRF_RTC0, 2);
}
   24d7e:	4770      	bx	lr
   24d80:	4000b000 	.word	0x4000b000

00024d84 <radio_tmr_stop>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   24d84:	4a04      	ldr	r2, [pc, #16]	; (24d98 <radio_tmr_stop+0x14>)
   24d86:	2301      	movs	r3, #1
   24d88:	6013      	str	r3, [r2, #0]
   24d8a:	60d3      	str	r3, [r2, #12]
   24d8c:	320c      	adds	r2, #12
   24d8e:	f602 72f4 	addw	r2, r2, #4084	; 0xff4
   24d92:	6013      	str	r3, [r2, #0]
   24d94:	60d3      	str	r3, [r2, #12]

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_STOP);
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_SHUTDOWN);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
   24d96:	4770      	bx	lr
   24d98:	40008004 	.word	0x40008004

00024d9c <radio_tmr_hcto_configure>:
    p_reg->CC[cc_channel] = cc_value;
   24d9c:	4b04      	ldr	r3, [pc, #16]	; (24db0 <radio_tmr_hcto_configure+0x14>)
   24d9e:	f8c3 0544 	str.w	r0, [r3, #1348]	; 0x544
   24da2:	f503 33b8 	add.w	r3, r3, #94208	; 0x17000
   24da6:	f04f 6288 	mov.w	r2, #71303168	; 0x4400000
   24daa:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_disable_on_hcto_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI) |
		BIT(HAL_RADIO_DISABLE_ON_HCTO_PPI));
}
   24dae:	4770      	bx	lr
   24db0:	40008000 	.word	0x40008000

00024db4 <radio_tmr_aa_capture>:
    p_reg->CH[(uint32_t) channel].EEP = eep;
   24db4:	4b06      	ldr	r3, [pc, #24]	; (24dd0 <radio_tmr_aa_capture+0x1c>)
   24db6:	4a07      	ldr	r2, [pc, #28]	; (24dd4 <radio_tmr_aa_capture+0x20>)
   24db8:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    p_reg->CH[(uint32_t) channel].TEP = tep;
   24dbc:	f502 42de 	add.w	r2, r2, #28416	; 0x6f00
   24dc0:	3240      	adds	r2, #64	; 0x40
   24dc2:	f8c3 2544 	str.w	r2, [r3, #1348]	; 0x544
    p_reg->CHENSET = mask;
   24dc6:	4a04      	ldr	r2, [pc, #16]	; (24dd8 <radio_tmr_aa_capture+0x24>)
   24dc8:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	hal_radio_ready_time_capture_ppi_config();
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_READY_TIME_CAPTURE_PPI) |
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI));
}
   24dcc:	4770      	bx	lr
   24dce:	bf00      	nop
   24dd0:	4001f000 	.word	0x4001f000
   24dd4:	40001100 	.word	0x40001100
   24dd8:	04000040 	.word	0x04000040

00024ddc <radio_tmr_aa_get>:

u32_t radio_tmr_aa_get(void)
{
	return EVENT_TIMER->CC[1];
   24ddc:	4b01      	ldr	r3, [pc, #4]	; (24de4 <radio_tmr_aa_get+0x8>)
   24dde:	f8d3 0544 	ldr.w	r0, [r3, #1348]	; 0x544
}
   24de2:	4770      	bx	lr
   24de4:	40008000 	.word	0x40008000

00024de8 <radio_tmr_aa_save>:

static u32_t radio_tmr_aa;

void radio_tmr_aa_save(u32_t aa)
{
	radio_tmr_aa = aa;
   24de8:	4b01      	ldr	r3, [pc, #4]	; (24df0 <radio_tmr_aa_save+0x8>)
   24dea:	6018      	str	r0, [r3, #0]
}
   24dec:	4770      	bx	lr
   24dee:	bf00      	nop
   24df0:	20003940 	.word	0x20003940

00024df4 <radio_tmr_aa_restore>:

u32_t radio_tmr_aa_restore(void)
{
	/* NOTE: we dont need to restore for now, but return the saved value. */
	return radio_tmr_aa;
}
   24df4:	4b01      	ldr	r3, [pc, #4]	; (24dfc <radio_tmr_aa_restore+0x8>)
   24df6:	6818      	ldr	r0, [r3, #0]
   24df8:	4770      	bx	lr
   24dfa:	bf00      	nop
   24dfc:	20003940 	.word	0x20003940

00024e00 <radio_tmr_ready_get>:

u32_t radio_tmr_ready_get(void)
{
	return EVENT_TIMER->CC[0];
   24e00:	4b01      	ldr	r3, [pc, #4]	; (24e08 <radio_tmr_ready_get+0x8>)
   24e02:	f8d3 0540 	ldr.w	r0, [r3, #1344]	; 0x540
}
   24e06:	4770      	bx	lr
   24e08:	40008000 	.word	0x40008000

00024e0c <radio_tmr_end_capture>:
   24e0c:	4b02      	ldr	r3, [pc, #8]	; (24e18 <radio_tmr_end_capture+0xc>)
   24e0e:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
   24e12:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504

void radio_tmr_end_capture(void)
{
	hal_radio_end_time_capture_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_RADIO_END_TIME_CAPTURE_PPI));
}
   24e16:	4770      	bx	lr
   24e18:	4001f000 	.word	0x4001f000

00024e1c <radio_tmr_end_get>:
u32_t radio_tmr_end_get(void)
{
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	return last_pdu_end_us;
#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	return EVENT_TIMER->CC[2];
   24e1c:	4b01      	ldr	r3, [pc, #4]	; (24e24 <radio_tmr_end_get+0x8>)
   24e1e:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
#endif /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
}
   24e22:	4770      	bx	lr
   24e24:	40008000 	.word	0x40008000

00024e28 <radio_tmr_tifs_base_get>:
   24e28:	4b01      	ldr	r3, [pc, #4]	; (24e30 <radio_tmr_tifs_base_get+0x8>)
   24e2a:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
   24e2e:	4770      	bx	lr
   24e30:	40008000 	.word	0x40008000

00024e34 <radio_ccm_rx_pkt_set>:
void *radio_ccm_rx_pkt_set(struct ccm *ccm, u8_t phy, void *pkt)
{

	u32_t mode;

	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   24e34:	4b1e      	ldr	r3, [pc, #120]	; (24eb0 <radio_ccm_rx_pkt_set+0x7c>)
{
   24e36:	b510      	push	{r4, lr}
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   24e38:	2400      	movs	r4, #0
   24e3a:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
   24e3e:	2402      	movs	r4, #2
	/* Enable CCM support for 8-bit length field PDUs. */
	mode |= (CCM_MODE_LENGTH_Extended << CCM_MODE_LENGTH_Pos) &
		CCM_MODE_LENGTH_Msk;

	/* Select CCM data rate based on current PHY in use. */
	switch (phy) {
   24e40:	42a1      	cmp	r1, r4
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
   24e42:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500
	switch (phy) {
   24e46:	d02f      	beq.n	24ea8 <radio_ccm_rx_pkt_set+0x74>
   24e48:	2904      	cmp	r1, #4
   24e4a:	d12f      	bne.n	24eac <radio_ccm_rx_pkt_set+0x78>
	case BIT(2):
		mode |= (CCM_MODE_DATARATE_125Kbps <<
			 CCM_MODE_DATARATE_Pos) &
			CCM_MODE_DATARATE_Msk;

		NRF_CCM->RATEOVERRIDE =
   24e4c:	2103      	movs	r1, #3
   24e4e:	f8c3 151c 	str.w	r1, [r3, #1308]	; 0x51c
    p_reg->CH[(uint32_t) channel].EEP = eep;
   24e52:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
   24e56:	4917      	ldr	r1, [pc, #92]	; (24eb4 <radio_ccm_rx_pkt_set+0x80>)
   24e58:	f8c3 1578 	str.w	r1, [r3, #1400]	; 0x578
    p_reg->CH[(uint32_t) channel].TEP = tep;
   24e5c:	f501 415e 	add.w	r1, r1, #56832	; 0xde00
   24e60:	31bc      	adds	r1, #188	; 0xbc
   24e62:	f8c3 157c 	str.w	r1, [r3, #1404]	; 0x57c
    p_reg->CHENSET = mask;
   24e66:	f44f 5100 	mov.w	r1, #8192	; 0x2000
   24e6a:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
		mode |= (CCM_MODE_DATARATE_125Kbps <<
   24e6e:	4912      	ldr	r1, [pc, #72]	; (24eb8 <radio_ccm_rx_pkt_set+0x84>)
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
	}
#endif /* !CONFIG_SOC_SERIES_NRF51X */

	NRF_CCM->MODE = mode;
   24e70:	4b0f      	ldr	r3, [pc, #60]	; (24eb0 <radio_ccm_rx_pkt_set+0x7c>)
   24e72:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
	NRF_CCM->CNFPTR = (u32_t)ccm;
   24e76:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
	NRF_CCM->INPTR = (u32_t)_pkt_scratch;
   24e7a:	4810      	ldr	r0, [pc, #64]	; (24ebc <radio_ccm_rx_pkt_set+0x88>)
   24e7c:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
	NRF_CCM->OUTPTR = (u32_t)pkt;
   24e80:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
   24e84:	4a0e      	ldr	r2, [pc, #56]	; (24ec0 <radio_ccm_rx_pkt_set+0x8c>)
   24e86:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
	NRF_CCM->SHORTS = 0;
   24e8a:	2200      	movs	r2, #0
   24e8c:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
	NRF_CCM->EVENTS_ENDCRYPT = 0;
   24e90:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	NRF_CCM->EVENTS_ERROR = 0;
   24e94:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   24e98:	4a0a      	ldr	r2, [pc, #40]	; (24ec4 <radio_ccm_rx_pkt_set+0x90>)
   24e9a:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
   24e9e:	f8c2 1504 	str.w	r1, [r2, #1284]	; 0x504
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ccm_task_trigger(NRF_CCM_Type * p_reg,
                                            nrf_ccm_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   24ea2:	2201      	movs	r2, #1
   24ea4:	601a      	str	r2, [r3, #0]
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_TRIGGER_CRYPT_PPI));

	nrf_ccm_task_trigger(NRF_CCM, NRF_CCM_TASK_KSGEN);

	return _pkt_scratch;
}
   24ea6:	bd10      	pop	{r4, pc}
		mode |= (CCM_MODE_DATARATE_2Mbit <<
   24ea8:	4907      	ldr	r1, [pc, #28]	; (24ec8 <radio_ccm_rx_pkt_set+0x94>)
   24eaa:	e7e1      	b.n	24e70 <radio_ccm_rx_pkt_set+0x3c>
		mode |= (CCM_MODE_DATARATE_1Mbit <<
   24eac:	4907      	ldr	r1, [pc, #28]	; (24ecc <radio_ccm_rx_pkt_set+0x98>)
   24eae:	e7df      	b.n	24e70 <radio_ccm_rx_pkt_set+0x3c>
   24eb0:	4000f000 	.word	0x4000f000
   24eb4:	40001150 	.word	0x40001150
   24eb8:	01020001 	.word	0x01020001
   24ebc:	20003834 	.word	0x20003834
   24ec0:	20003724 	.word	0x20003724
   24ec4:	4001f000 	.word	0x4001f000
   24ec8:	01010001 	.word	0x01010001
   24ecc:	01000001 	.word	0x01000001

00024ed0 <radio_ccm_tx_pkt_set>:

void *radio_ccm_tx_pkt_set(struct ccm *ccm, void *pkt)
{
   24ed0:	b510      	push	{r4, lr}
	u32_t mode;

	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   24ed2:	4b0e      	ldr	r3, [pc, #56]	; (24f0c <radio_ccm_tx_pkt_set+0x3c>)
   24ed4:	2200      	movs	r2, #0
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
   24ed6:	2402      	movs	r4, #2
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
   24ed8:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
   24edc:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500
	 * radio Tx on any PHY.
	 */
	mode |= (CCM_MODE_DATARATE_2Mbit << CCM_MODE_DATARATE_Pos) &
		CCM_MODE_DATARATE_Msk;
#endif
	NRF_CCM->MODE = mode;
   24ee0:	4c0b      	ldr	r4, [pc, #44]	; (24f10 <radio_ccm_tx_pkt_set+0x40>)
   24ee2:	f8c3 4504 	str.w	r4, [r3, #1284]	; 0x504
	NRF_CCM->CNFPTR = (u32_t)ccm;
   24ee6:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
	NRF_CCM->INPTR = (u32_t)pkt;
   24eea:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
	NRF_CCM->OUTPTR = (u32_t)_pkt_scratch;
   24eee:	4809      	ldr	r0, [pc, #36]	; (24f14 <radio_ccm_tx_pkt_set+0x44>)
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
   24ef0:	4909      	ldr	r1, [pc, #36]	; (24f18 <radio_ccm_tx_pkt_set+0x48>)
	NRF_CCM->OUTPTR = (u32_t)_pkt_scratch;
   24ef2:	f8c3 0510 	str.w	r0, [r3, #1296]	; 0x510
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
   24ef6:	f8c3 1514 	str.w	r1, [r3, #1300]	; 0x514
	NRF_CCM->SHORTS = CCM_SHORTS_ENDKSGEN_CRYPT_Msk;
   24efa:	2101      	movs	r1, #1
   24efc:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
	NRF_CCM->EVENTS_ENDCRYPT = 0;
   24f00:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	NRF_CCM->EVENTS_ERROR = 0;
   24f04:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   24f08:	6019      	str	r1, [r3, #0]

	nrf_ccm_task_trigger(NRF_CCM, NRF_CCM_TASK_KSGEN);

	return _pkt_scratch;
}
   24f0a:	bd10      	pop	{r4, pc}
   24f0c:	4000f000 	.word	0x4000f000
   24f10:	01010000 	.word	0x01010000
   24f14:	20003834 	.word	0x20003834
   24f18:	20003724 	.word	0x20003724

00024f1c <radio_ccm_is_done>:
    return ((uint32_t)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE void nrf_ccm_int_enable(NRF_CCM_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
   24f1c:	4b0c      	ldr	r3, [pc, #48]	; (24f50 <radio_ccm_is_done+0x34>)
   24f1e:	2202      	movs	r2, #2
   24f20:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

u32_t radio_ccm_is_done(void)
{
	nrf_ccm_int_enable(NRF_CCM, CCM_INTENSET_ENDCRYPT_Msk);
	while (NRF_CCM->EVENTS_ENDCRYPT == 0) {
   24f24:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
   24f28:	b16a      	cbz	r2, 24f46 <radio_ccm_is_done+0x2a>
}

NRF_STATIC_INLINE void nrf_ccm_int_disable(NRF_CCM_Type * p_reg, uint32_t mask)
{
    p_reg->INTENCLR = mask;
   24f2a:	2202      	movs	r2, #2
   24f2c:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
   24f30:	4a08      	ldr	r2, [pc, #32]	; (24f54 <radio_ccm_is_done+0x38>)
   24f32:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   24f36:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
		__WFE();
	}
	nrf_ccm_int_disable(NRF_CCM, CCM_INTENCLR_ENDCRYPT_Msk);
	NVIC_ClearPendingIRQ(nrfx_get_irq_number(NRF_CCM));

	return (NRF_CCM->EVENTS_ERROR == 0);
   24f3a:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
}
   24f3e:	fab0 f080 	clz	r0, r0
   24f42:	0940      	lsrs	r0, r0, #5
   24f44:	4770      	bx	lr
		__WFE();
   24f46:	bf20      	wfe
		__SEV();
   24f48:	bf40      	sev
		__WFE();
   24f4a:	bf20      	wfe
   24f4c:	e7ea      	b.n	24f24 <radio_ccm_is_done+0x8>
   24f4e:	bf00      	nop
   24f50:	4000f000 	.word	0x4000f000
   24f54:	e000e100 	.word	0xe000e100

00024f58 <radio_ccm_mic_is_valid>:

u32_t radio_ccm_mic_is_valid(void)
{
	return (NRF_CCM->MICSTATUS != 0);
   24f58:	4b03      	ldr	r3, [pc, #12]	; (24f68 <radio_ccm_mic_is_valid+0x10>)
   24f5a:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
   24f5e:	3000      	adds	r0, #0
   24f60:	bf18      	it	ne
   24f62:	2001      	movne	r0, #1
   24f64:	4770      	bx	lr
   24f66:	bf00      	nop
   24f68:	4000f000 	.word	0x4000f000

00024f6c <radio_ar_configure>:

static u8_t MALIGN(4) _aar_scratch[3];

void radio_ar_configure(u32_t nirk, void *irk)
{
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
   24f6c:	4b11      	ldr	r3, [pc, #68]	; (24fb4 <radio_ar_configure+0x48>)
{
   24f6e:	b510      	push	{r4, lr}
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
   24f70:	2203      	movs	r2, #3
			  AAR_ENABLE_ENABLE_Msk;
	NRF_AAR->NIRK = nirk;
	NRF_AAR->IRKPTR = (u32_t)irk;
	NRF_AAR->ADDRPTR = (u32_t)NRF_RADIO->PACKETPTR - 1;
   24f72:	4c11      	ldr	r4, [pc, #68]	; (24fb8 <radio_ar_configure+0x4c>)
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
   24f74:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
	NRF_AAR->NIRK = nirk;
   24f78:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
	NRF_AAR->IRKPTR = (u32_t)irk;
   24f7c:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
	NRF_AAR->ADDRPTR = (u32_t)NRF_RADIO->PACKETPTR - 1;
   24f80:	f8d4 2504 	ldr.w	r2, [r4, #1284]	; 0x504
   24f84:	3a01      	subs	r2, #1
   24f86:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_AAR->SCRATCHPTR = (u32_t)&_aar_scratch[0];

	NRF_AAR->EVENTS_END = 0;
   24f8a:	2100      	movs	r1, #0
	NRF_AAR->SCRATCHPTR = (u32_t)&_aar_scratch[0];
   24f8c:	4a0b      	ldr	r2, [pc, #44]	; (24fbc <radio_ar_configure+0x50>)
   24f8e:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
	NRF_AAR->EVENTS_RESOLVED = 0;
	NRF_AAR->EVENTS_NOTRESOLVED = 0;

	radio_bc_configure(64);
   24f92:	2040      	movs	r0, #64	; 0x40
	NRF_AAR->EVENTS_END = 0;
   24f94:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
	NRF_AAR->EVENTS_RESOLVED = 0;
   24f98:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
	NRF_AAR->EVENTS_NOTRESOLVED = 0;
   24f9c:	f8c3 1108 	str.w	r1, [r3, #264]	; 0x108
	radio_bc_configure(64);
   24fa0:	f7ff fe40 	bl	24c24 <radio_bc_configure>
   24fa4:	4b06      	ldr	r3, [pc, #24]	; (24fc0 <radio_ar_configure+0x54>)
	NRF_RADIO->EVENTS_BCMATCH = 0;
   24fa6:	f8c4 1128 	str.w	r1, [r4, #296]	; 0x128
   24faa:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   24fae:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	radio_bc_status_reset();

	hal_trigger_aar_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_TRIGGER_AAR_PPI));
}
   24fb2:	bd10      	pop	{r4, pc}
   24fb4:	4000f000 	.word	0x4000f000
   24fb8:	40001000 	.word	0x40001000
   24fbc:	20003720 	.word	0x20003720
   24fc0:	4001f000 	.word	0x4001f000

00024fc4 <radio_ar_match_get>:

u32_t radio_ar_match_get(void)
{
	return NRF_AAR->STATUS;
   24fc4:	4b01      	ldr	r3, [pc, #4]	; (24fcc <radio_ar_match_get+0x8>)
   24fc6:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
   24fca:	4770      	bx	lr
   24fcc:	4000f000 	.word	0x4000f000

00024fd0 <radio_ar_status_reset>:
	NRF_RADIO->EVENTS_BCMATCH = 0;
   24fd0:	4a04      	ldr	r2, [pc, #16]	; (24fe4 <radio_ar_status_reset+0x14>)
   24fd2:	2300      	movs	r3, #0
   24fd4:	f8c2 3128 	str.w	r3, [r2, #296]	; 0x128

void radio_ar_status_reset(void)
{
	radio_bc_status_reset();

	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Disabled << AAR_ENABLE_ENABLE_Pos) &
   24fd8:	f502 4260 	add.w	r2, r2, #57344	; 0xe000
   24fdc:	f8c2 3500 	str.w	r3, [r2, #1280]	; 0x500
			  AAR_ENABLE_ENABLE_Msk;
}
   24fe0:	4770      	bx	lr
   24fe2:	bf00      	nop
   24fe4:	40001000 	.word	0x40001000

00024fe8 <radio_ar_has_match>:
	return (NRF_RADIO->EVENTS_BCMATCH != 0);
   24fe8:	4b08      	ldr	r3, [pc, #32]	; (2500c <radio_ar_has_match+0x24>)
   24fea:	f8d3 0128 	ldr.w	r0, [r3, #296]	; 0x128

u32_t radio_ar_has_match(void)
{
	return (radio_bc_has_match() &&
		NRF_AAR->EVENTS_END &&
		NRF_AAR->EVENTS_RESOLVED &&
   24fee:	b160      	cbz	r0, 2500a <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_END &&
   24ff0:	f503 4360 	add.w	r3, r3, #57344	; 0xe000
   24ff4:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
	return (radio_bc_has_match() &&
   24ff8:	b138      	cbz	r0, 2500a <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_RESOLVED &&
   24ffa:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
		NRF_AAR->EVENTS_END &&
   24ffe:	b120      	cbz	r0, 2500a <radio_ar_has_match+0x22>
		!NRF_AAR->EVENTS_NOTRESOLVED);
   25000:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
		NRF_AAR->EVENTS_RESOLVED &&
   25004:	fab0 f080 	clz	r0, r0
   25008:	0940      	lsrs	r0, r0, #5
}
   2500a:	4770      	bx	lr
   2500c:	40001000 	.word	0x40001000

00025010 <mayfly_enable_cb>:

void mayfly_enable_cb(u8_t caller_id, u8_t callee_id, u8_t enable)
{
	(void)caller_id;

	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
   25010:	2902      	cmp	r1, #2
{
   25012:	b510      	push	{r4, lr}
   25014:	4614      	mov	r4, r2
	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
   25016:	d008      	beq.n	2502a <mayfly_enable_cb+0x1a>
   25018:	4809      	ldr	r0, [pc, #36]	; (25040 <mayfly_enable_cb+0x30>)
   2501a:	f003 f893 	bl	28144 <printk>
   2501e:	4040      	eors	r0, r0
   25020:	f380 8811 	msr	BASEPRI, r0
   25024:	f04f 0003 	mov.w	r0, #3
   25028:	df02      	svc	2

	if (enable) {
		irq_enable(HAL_SWI_JOB_IRQ);
   2502a:	200b      	movs	r0, #11
	if (enable) {
   2502c:	b11c      	cbz	r4, 25036 <mayfly_enable_cb+0x26>
	} else {
		irq_disable(HAL_SWI_JOB_IRQ);
	}
}
   2502e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_enable(HAL_SWI_JOB_IRQ);
   25032:	f7ee bd45 	b.w	13ac0 <arch_irq_enable>
}
   25036:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_disable(HAL_SWI_JOB_IRQ);
   2503a:	f7ee bd51 	b.w	13ae0 <arch_irq_disable>
   2503e:	bf00      	nop
   25040:	0003232f 	.word	0x0003232f

00025044 <mayfly_is_enabled>:

u32_t mayfly_is_enabled(u8_t caller_id, u8_t callee_id)
{
	(void)caller_id;

	switch (callee_id) {
   25044:	2901      	cmp	r1, #1
{
   25046:	b508      	push	{r3, lr}
	switch (callee_id) {
   25048:	d012      	beq.n	25070 <mayfly_is_enabled+0x2c>
   2504a:	b161      	cbz	r1, 25066 <mayfly_is_enabled+0x22>
   2504c:	2902      	cmp	r1, #2
   2504e:	d00f      	beq.n	25070 <mayfly_is_enabled+0x2c>

	case MAYFLY_CALL_ID_JOB:
		return irq_is_enabled(HAL_SWI_JOB_IRQ);

	default:
		LL_ASSERT(0);
   25050:	4808      	ldr	r0, [pc, #32]	; (25074 <mayfly_is_enabled+0x30>)
   25052:	f003 f877 	bl	28144 <printk>
   25056:	4040      	eors	r0, r0
   25058:	f380 8811 	msr	BASEPRI, r0
   2505c:	f04f 0003 	mov.w	r0, #3
   25060:	df02      	svc	2
		break;
	}

	return 0;
}
   25062:	2000      	movs	r0, #0
   25064:	bd08      	pop	{r3, pc}
		return irq_is_enabled(HAL_SWI_RADIO_IRQ);
   25066:	2018      	movs	r0, #24
}
   25068:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		return irq_is_enabled(HAL_SWI_WORKER_IRQ);
   2506c:	f7ee bd4c 	b.w	13b08 <arch_irq_is_enabled>
   25070:	200b      	movs	r0, #11
   25072:	e7f9      	b.n	25068 <mayfly_is_enabled+0x24>
   25074:	000314f5 	.word	0x000314f5

00025078 <mayfly_pend>:

void mayfly_pend(u8_t caller_id, u8_t callee_id)
{
	(void)caller_id;

	switch (callee_id) {
   25078:	2901      	cmp	r1, #1
{
   2507a:	b508      	push	{r3, lr}
	switch (callee_id) {
   2507c:	d012      	beq.n	250a4 <mayfly_pend+0x2c>
   2507e:	b159      	cbz	r1, 25098 <mayfly_pend+0x20>
   25080:	2902      	cmp	r1, #2
   25082:	d00f      	beq.n	250a4 <mayfly_pend+0x2c>
	case MAYFLY_CALL_ID_JOB:
		hal_swi_job_pend();
		break;

	default:
		LL_ASSERT(0);
   25084:	4809      	ldr	r0, [pc, #36]	; (250ac <mayfly_pend+0x34>)
   25086:	f003 f85d 	bl	28144 <printk>
   2508a:	4040      	eors	r0, r0
   2508c:	f380 8811 	msr	BASEPRI, r0
   25090:	f04f 0003 	mov.w	r0, #3
   25094:	df02      	svc	2
		break;
	}
}
   25096:	e004      	b.n	250a2 <mayfly_pend+0x2a>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   25098:	4b05      	ldr	r3, [pc, #20]	; (250b0 <mayfly_pend+0x38>)
   2509a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   2509e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   250a2:	bd08      	pop	{r3, pc}
   250a4:	4b02      	ldr	r3, [pc, #8]	; (250b0 <mayfly_pend+0x38>)
   250a6:	f44f 6200 	mov.w	r2, #2048	; 0x800
   250aa:	e7f8      	b.n	2509e <mayfly_pend+0x26>
   250ac:	000314f5 	.word	0x000314f5
   250b0:	e000e100 	.word	0xe000e100

000250b4 <hal_ticker_instance0_caller_id_get>:

u8_t hal_ticker_instance0_caller_id_get(u8_t user_id)
{
	u8_t caller_id;

	LL_ASSERT(user_id < sizeof(caller_id_lut));
   250b4:	2803      	cmp	r0, #3
{
   250b6:	b510      	push	{r4, lr}
   250b8:	4604      	mov	r4, r0
	LL_ASSERT(user_id < sizeof(caller_id_lut));
   250ba:	d908      	bls.n	250ce <hal_ticker_instance0_caller_id_get+0x1a>
   250bc:	480b      	ldr	r0, [pc, #44]	; (250ec <hal_ticker_instance0_caller_id_get+0x38>)
   250be:	f003 f841 	bl	28144 <printk>
   250c2:	4040      	eors	r0, r0
   250c4:	f380 8811 	msr	BASEPRI, r0
   250c8:	f04f 0003 	mov.w	r0, #3
   250cc:	df02      	svc	2

	caller_id = caller_id_lut[user_id];
   250ce:	4b08      	ldr	r3, [pc, #32]	; (250f0 <hal_ticker_instance0_caller_id_get+0x3c>)
   250d0:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(caller_id != TICKER_CALL_ID_NONE);
   250d2:	b944      	cbnz	r4, 250e6 <hal_ticker_instance0_caller_id_get+0x32>
   250d4:	4807      	ldr	r0, [pc, #28]	; (250f4 <hal_ticker_instance0_caller_id_get+0x40>)
   250d6:	f003 f835 	bl	28144 <printk>
   250da:	4040      	eors	r0, r0
   250dc:	f380 8811 	msr	BASEPRI, r0
   250e0:	f04f 0003 	mov.w	r0, #3
   250e4:	df02      	svc	2

	return caller_id;
}
   250e6:	4620      	mov	r0, r4
   250e8:	bd10      	pop	{r4, pc}
   250ea:	bf00      	nop
   250ec:	00032367 	.word	0x00032367
   250f0:	00032363 	.word	0x00032363
   250f4:	00032399 	.word	0x00032399

000250f8 <hal_ticker_instance0_sched>:
{
	/* return value not checked as we allow multiple calls to schedule
	 * before being actually needing the work to complete before new
	 * schedule.
	 */
	switch (caller_id) {
   250f8:	3801      	subs	r0, #1
{
   250fa:	b510      	push	{r4, lr}
   250fc:	461c      	mov	r4, r3
	switch (caller_id) {
   250fe:	2804      	cmp	r0, #4
   25100:	d820      	bhi.n	25144 <hal_ticker_instance0_sched+0x4c>
   25102:	e8df f000 	tbb	[pc, r0]
   25106:	0d03      	.short	0x0d03
   25108:	1b14      	.short	0x1b14
   2510a:	32          	.byte	0x32
   2510b:	00          	.byte	0x00
#if defined(CONFIG_BT_LL_SW_SPLIT)
	case TICKER_CALL_ID_ISR:
		switch (callee_id) {
   2510c:	2904      	cmp	r1, #4
   2510e:	d119      	bne.n	25144 <hal_ticker_instance0_sched+0x4c>
		{
			static memq_link_t link;
			static struct mayfly m = {0, 0, &link, NULL,
						  ticker_job};

			m.param = instance;
   25110:	4b19      	ldr	r3, [pc, #100]	; (25178 <hal_ticker_instance0_sched+0x80>)

			/* TODO: scheduler lock, if preemptive threads used */
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
   25112:	2102      	movs	r1, #2
			m.param = instance;
   25114:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
   25116:	2000      	movs	r0, #0

	default:
		LL_ASSERT(0);
		break;
	}
}
   25118:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
   2511c:	f7f6 bb5a 	b.w	1b7d4 <mayfly_enqueue>
		switch (callee_id) {
   25120:	2903      	cmp	r1, #3
   25122:	d10f      	bne.n	25144 <hal_ticker_instance0_sched+0x4c>
			m.param = instance;
   25124:	4b15      	ldr	r3, [pc, #84]	; (2517c <hal_ticker_instance0_sched+0x84>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
   25126:	2101      	movs	r1, #1
			m.param = instance;
   25128:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   2512a:	4608      	mov	r0, r1
   2512c:	e7f4      	b.n	25118 <hal_ticker_instance0_sched+0x20>
		switch (callee_id) {
   2512e:	2904      	cmp	r1, #4
   25130:	d108      	bne.n	25144 <hal_ticker_instance0_sched+0x4c>
			m.param = instance;
   25132:	4b13      	ldr	r3, [pc, #76]	; (25180 <hal_ticker_instance0_sched+0x88>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
   25134:	2102      	movs	r1, #2
			m.param = instance;
   25136:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
   25138:	2001      	movs	r0, #1
   2513a:	e7ed      	b.n	25118 <hal_ticker_instance0_sched+0x20>
		switch (callee_id) {
   2513c:	2903      	cmp	r1, #3
   2513e:	d00b      	beq.n	25158 <hal_ticker_instance0_sched+0x60>
   25140:	2904      	cmp	r1, #4
   25142:	d00e      	beq.n	25162 <hal_ticker_instance0_sched+0x6a>
		LL_ASSERT(0);
   25144:	480f      	ldr	r0, [pc, #60]	; (25184 <hal_ticker_instance0_sched+0x8c>)
   25146:	f002 fffd 	bl	28144 <printk>
   2514a:	4040      	eors	r0, r0
   2514c:	f380 8811 	msr	BASEPRI, r0
   25150:	f04f 0003 	mov.w	r0, #3
   25154:	df02      	svc	2
}
   25156:	bd10      	pop	{r4, pc}
			m.param = instance;
   25158:	4b0b      	ldr	r3, [pc, #44]	; (25188 <hal_ticker_instance0_sched+0x90>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   2515a:	2101      	movs	r1, #1
			m.param = instance;
   2515c:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   2515e:	2002      	movs	r0, #2
   25160:	e7da      	b.n	25118 <hal_ticker_instance0_sched+0x20>
			m.param = instance;
   25162:	4b0a      	ldr	r3, [pc, #40]	; (2518c <hal_ticker_instance0_sched+0x94>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   25164:	2102      	movs	r1, #2
			m.param = instance;
   25166:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
   25168:	e7df      	b.n	2512a <hal_ticker_instance0_sched+0x32>
		switch (callee_id) {
   2516a:	2904      	cmp	r1, #4
   2516c:	d1ea      	bne.n	25144 <hal_ticker_instance0_sched+0x4c>
			m.param = instance;
   2516e:	4b08      	ldr	r3, [pc, #32]	; (25190 <hal_ticker_instance0_sched+0x98>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
   25170:	2102      	movs	r1, #2
			m.param = instance;
   25172:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
   25174:	2003      	movs	r0, #3
   25176:	e7cf      	b.n	25118 <hal_ticker_instance0_sched+0x20>
   25178:	2000fd90 	.word	0x2000fd90
   2517c:	2000fda0 	.word	0x2000fda0
   25180:	2000fdb0 	.word	0x2000fdb0
   25184:	000314f5 	.word	0x000314f5
   25188:	2000fdc0 	.word	0x2000fdc0
   2518c:	2000fdd0 	.word	0x2000fdd0
   25190:	2000fde0 	.word	0x2000fde0

00025194 <net_buf_pool_get>:
extern struct net_buf_pool _net_buf_pool_list[];

struct net_buf_pool *net_buf_pool_get(int id)
{
	return &_net_buf_pool_list[id];
}
   25194:	4b01      	ldr	r3, [pc, #4]	; (2519c <net_buf_pool_get+0x8>)
   25196:	eb03 1040 	add.w	r0, r3, r0, lsl #5
   2519a:	4770      	bx	lr
   2519c:	20010180 	.word	0x20010180

000251a0 <net_buf_id>:
	return pool - _net_buf_pool_list;
}

int net_buf_id(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   251a0:	7982      	ldrb	r2, [r0, #6]

	return buf - pool->__bufs;
   251a2:	4b04      	ldr	r3, [pc, #16]	; (251b4 <net_buf_id+0x14>)
   251a4:	eb03 1342 	add.w	r3, r3, r2, lsl #5
   251a8:	69db      	ldr	r3, [r3, #28]
   251aa:	1ac0      	subs	r0, r0, r3
}
   251ac:	4b02      	ldr	r3, [pc, #8]	; (251b8 <net_buf_id+0x18>)
	return buf - pool->__bufs;
   251ae:	1080      	asrs	r0, r0, #2
}
   251b0:	4358      	muls	r0, r3
   251b2:	4770      	bx	lr
   251b4:	20010180 	.word	0x20010180
   251b8:	38e38e39 	.word	0x38e38e39

000251bc <fixed_data_alloc>:
	.ref   = generic_data_ref,
	.unref = mem_pool_data_unref,
};

static u8_t *fixed_data_alloc(struct net_buf *buf, size_t *size, s32_t timeout)
{
   251bc:	b510      	push	{r4, lr}
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   251be:	4b09      	ldr	r3, [pc, #36]	; (251e4 <fixed_data_alloc+0x28>)
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   251c0:	7982      	ldrb	r2, [r0, #6]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   251c2:	eb03 1342 	add.w	r3, r3, r2, lsl #5

	*size = MIN(fixed->data_size, *size);
   251c6:	680a      	ldr	r2, [r1, #0]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   251c8:	699b      	ldr	r3, [r3, #24]
   251ca:	685c      	ldr	r4, [r3, #4]
	*size = MIN(fixed->data_size, *size);
   251cc:	6823      	ldr	r3, [r4, #0]
   251ce:	429a      	cmp	r2, r3
   251d0:	bf94      	ite	ls
   251d2:	600a      	strls	r2, [r1, #0]
   251d4:	600b      	strhi	r3, [r1, #0]

	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
   251d6:	f7ff ffe3 	bl	251a0 <net_buf_id>
   251da:	e9d4 2300 	ldrd	r2, r3, [r4]
}
   251de:	fb02 3000 	mla	r0, r2, r0, r3
   251e2:	bd10      	pop	{r4, pc}
   251e4:	20010180 	.word	0x20010180

000251e8 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  s32_t timeout)
#endif
{
   251e8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   251ec:	4605      	mov	r5, r0
   251ee:	9101      	str	r1, [sp, #4]
   251f0:	4616      	mov	r6, r2
	u32_t alloc_start = k_uptime_get_32();
   251f2:	f007 fc8d 	bl	2cb10 <k_uptime_get_32>
   251f6:	4607      	mov	r7, r0
	__asm__ volatile(
   251f8:	f04f 0320 	mov.w	r3, #32
   251fc:	f3ef 8811 	mrs	r8, BASEPRI
   25200:	f383 8811 	msr	BASEPRI, r3
   25204:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
   25208:	8a6b      	ldrh	r3, [r5, #18]
   2520a:	2b00      	cmp	r3, #0
   2520c:	d041      	beq.n	25292 <net_buf_alloc_len+0xaa>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
   2520e:	8a2a      	ldrh	r2, [r5, #16]
   25210:	429a      	cmp	r2, r3
   25212:	d92c      	bls.n	2526e <net_buf_alloc_len+0x86>
	return z_impl_k_queue_get(queue, timeout);
   25214:	2100      	movs	r1, #0
   25216:	4628      	mov	r0, r5
   25218:	f007 ff9c 	bl	2d154 <z_impl_k_queue_get>
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
   2521c:	4604      	mov	r4, r0
   2521e:	b330      	cbz	r0, 2526e <net_buf_alloc_len+0x86>
	__asm__ volatile(
   25220:	f388 8811 	msr	BASEPRI, r8
   25224:	f3bf 8f6f 	isb	sy
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
   25228:	9b01      	ldr	r3, [sp, #4]
   2522a:	2b00      	cmp	r3, #0
   2522c:	d040      	beq.n	252b0 <net_buf_alloc_len+0xc8>
		if (timeout != K_NO_WAIT && timeout != K_FOREVER) {
   2522e:	1c73      	adds	r3, r6, #1
   25230:	2b01      	cmp	r3, #1
   25232:	d906      	bls.n	25242 <net_buf_alloc_len+0x5a>
			u32_t diff = k_uptime_get_32() - alloc_start;
   25234:	f007 fc6c 	bl	2cb10 <k_uptime_get_32>
   25238:	1bc0      	subs	r0, r0, r7

			timeout -= MIN(timeout, diff);
   2523a:	42b0      	cmp	r0, r6
   2523c:	bf94      	ite	ls
   2523e:	1a36      	subls	r6, r6, r0
   25240:	1bb6      	subhi	r6, r6, r6
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   25242:	79a3      	ldrb	r3, [r4, #6]
	return pool->alloc->cb->alloc(buf, size, timeout);
   25244:	4f20      	ldr	r7, [pc, #128]	; (252c8 <net_buf_alloc_len+0xe0>)
   25246:	eb07 1343 	add.w	r3, r7, r3, lsl #5
   2524a:	4632      	mov	r2, r6
   2524c:	699b      	ldr	r3, [r3, #24]
   2524e:	681b      	ldr	r3, [r3, #0]
   25250:	a901      	add	r1, sp, #4
   25252:	681b      	ldr	r3, [r3, #0]
   25254:	4620      	mov	r0, r4
   25256:	4798      	blx	r3
   25258:	4605      	mov	r5, r0
		}

		buf->__buf = data_alloc(buf, &size, timeout);
   2525a:	6120      	str	r0, [r4, #16]
		if (!buf->__buf) {
   2525c:	bb48      	cbnz	r0, 252b2 <net_buf_alloc_len+0xca>
 */
static inline void net_buf_destroy(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	k_lifo_put(&pool->free, buf);
   2525e:	79a0      	ldrb	r0, [r4, #6]
   25260:	4621      	mov	r1, r4
   25262:	eb07 1040 	add.w	r0, r7, r0, lsl #5
   25266:	f007 ff51 	bl	2d10c <k_queue_prepend>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
			return NULL;
   2526a:	462c      	mov	r4, r5
   2526c:	e01c      	b.n	252a8 <net_buf_alloc_len+0xc0>
		uninit_count = pool->uninit_count--;
   2526e:	8a6b      	ldrh	r3, [r5, #18]
   25270:	1e5a      	subs	r2, r3, #1
   25272:	826a      	strh	r2, [r5, #18]
   25274:	f388 8811 	msr	BASEPRI, r8
   25278:	f3bf 8f6f 	isb	sy
	buf = &pool->__bufs[pool->buf_count - uninit_count];
   2527c:	8a2c      	ldrh	r4, [r5, #16]
   2527e:	1ae4      	subs	r4, r4, r3
   25280:	69eb      	ldr	r3, [r5, #28]
   25282:	2224      	movs	r2, #36	; 0x24
   25284:	fb02 3404 	mla	r4, r2, r4, r3
	return pool - _net_buf_pool_list;
   25288:	4b0f      	ldr	r3, [pc, #60]	; (252c8 <net_buf_alloc_len+0xe0>)
   2528a:	1aed      	subs	r5, r5, r3
   2528c:	116d      	asrs	r5, r5, #5
	buf->pool_id = pool_id(pool);
   2528e:	71a5      	strb	r5, [r4, #6]
		goto success;
   25290:	e7ca      	b.n	25228 <net_buf_alloc_len+0x40>
   25292:	f388 8811 	msr	BASEPRI, r8
   25296:	f3bf 8f6f 	isb	sy
   2529a:	4631      	mov	r1, r6
   2529c:	4628      	mov	r0, r5
   2529e:	f007 ff59 	bl	2d154 <z_impl_k_queue_get>
	if (!buf) {
   252a2:	4604      	mov	r4, r0
   252a4:	2800      	cmp	r0, #0
   252a6:	d1bf      	bne.n	25228 <net_buf_alloc_len+0x40>
	pool->avail_count--;
	NET_BUF_ASSERT(pool->avail_count >= 0);
#endif

	return buf;
}
   252a8:	4620      	mov	r0, r4
   252aa:	b002      	add	sp, #8
   252ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		buf->__buf = NULL;
   252b0:	6123      	str	r3, [r4, #16]
	buf->frags = NULL;
   252b2:	2300      	movs	r3, #0
	buf->ref   = 1U;
   252b4:	2201      	movs	r2, #1
	buf->frags = NULL;
   252b6:	6023      	str	r3, [r4, #0]
	buf->ref   = 1U;
   252b8:	80a2      	strh	r2, [r4, #4]
	buf->len  = 0U;
   252ba:	81a3      	strh	r3, [r4, #12]
	buf->size  = size;
   252bc:	9a01      	ldr	r2, [sp, #4]
	buf->data = buf->__buf;
   252be:	6923      	ldr	r3, [r4, #16]
   252c0:	81e2      	strh	r2, [r4, #14]
   252c2:	60a3      	str	r3, [r4, #8]
	return buf;
   252c4:	e7f0      	b.n	252a8 <net_buf_alloc_len+0xc0>
   252c6:	bf00      	nop
   252c8:	20010180 	.word	0x20010180

000252cc <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
   252cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   252ce:	4d15      	ldr	r5, [pc, #84]	; (25324 <net_buf_unref+0x58>)
   252d0:	4604      	mov	r4, r0
			return;
		}

		if (buf->__buf) {
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
   252d2:	2600      	movs	r6, #0
	while (buf) {
   252d4:	b904      	cbnz	r4, 252d8 <net_buf_unref+0xc>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
   252d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (--buf->ref > 0) {
   252d8:	7923      	ldrb	r3, [r4, #4]
		struct net_buf *frags = buf->frags;
   252da:	6827      	ldr	r7, [r4, #0]
		if (--buf->ref > 0) {
   252dc:	3b01      	subs	r3, #1
   252de:	b2db      	uxtb	r3, r3
   252e0:	7123      	strb	r3, [r4, #4]
   252e2:	2b00      	cmp	r3, #0
   252e4:	d1f7      	bne.n	252d6 <net_buf_unref+0xa>
		if (buf->__buf) {
   252e6:	6921      	ldr	r1, [r4, #16]
   252e8:	b159      	cbz	r1, 25302 <net_buf_unref+0x36>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
   252ea:	7963      	ldrb	r3, [r4, #5]
   252ec:	079b      	lsls	r3, r3, #30
   252ee:	d407      	bmi.n	25300 <net_buf_unref+0x34>
	pool->alloc->cb->unref(buf, data);
   252f0:	79a3      	ldrb	r3, [r4, #6]
   252f2:	eb05 1343 	add.w	r3, r5, r3, lsl #5
   252f6:	4620      	mov	r0, r4
   252f8:	699b      	ldr	r3, [r3, #24]
   252fa:	681b      	ldr	r3, [r3, #0]
   252fc:	689b      	ldr	r3, [r3, #8]
   252fe:	4798      	blx	r3
			buf->__buf = NULL;
   25300:	6126      	str	r6, [r4, #16]
		pool = net_buf_pool_get(buf->pool_id);
   25302:	79a0      	ldrb	r0, [r4, #6]
		buf->data = NULL;
   25304:	60a6      	str	r6, [r4, #8]
		if (pool->destroy) {
   25306:	eb05 1340 	add.w	r3, r5, r0, lsl #5
		buf->frags = NULL;
   2530a:	6026      	str	r6, [r4, #0]
		if (pool->destroy) {
   2530c:	695b      	ldr	r3, [r3, #20]
   2530e:	b11b      	cbz	r3, 25318 <net_buf_unref+0x4c>
			pool->destroy(buf);
   25310:	4620      	mov	r0, r4
   25312:	4798      	blx	r3
{
   25314:	463c      	mov	r4, r7
   25316:	e7dd      	b.n	252d4 <net_buf_unref+0x8>
	k_lifo_put(&pool->free, buf);
   25318:	4621      	mov	r1, r4
   2531a:	eb05 1040 	add.w	r0, r5, r0, lsl #5
   2531e:	f007 fef5 	bl	2d10c <k_queue_prepend>
   25322:	e7f7      	b.n	25314 <net_buf_unref+0x48>
   25324:	20010180 	.word	0x20010180

00025328 <gpio_nrfx_init>:
#endif
	}
}

static int gpio_nrfx_init(struct device *port)
{
   25328:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
   2532a:	4b09      	ldr	r3, [pc, #36]	; (25350 <gpio_nrfx_init+0x28>)
   2532c:	781a      	ldrb	r2, [r3, #0]
   2532e:	b96a      	cbnz	r2, 2534c <gpio_nrfx_init+0x24>
		gpio_initialized = true;
   25330:	2101      	movs	r1, #1
   25332:	7019      	strb	r1, [r3, #0]
		IRQ_CONNECT(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0,
   25334:	2006      	movs	r0, #6
   25336:	2105      	movs	r1, #5
   25338:	f7ee fbf4 	bl	13b24 <z_arm_irq_priority_set>
			    DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0_PRIORITY,
			    gpiote_event_handler, NULL, 0);

		irq_enable(DT_NORDIC_NRF_GPIOTE_GPIOTE_0_IRQ_0);
   2533c:	2006      	movs	r0, #6
   2533e:	f7ee fbbf 	bl	13ac0 <arch_irq_enable>
    return ((uint32_t)p_reg + event);
}

NRF_STATIC_INLINE void nrf_gpiote_int_enable(NRF_GPIOTE_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
   25342:	4b04      	ldr	r3, [pc, #16]	; (25354 <gpio_nrfx_init+0x2c>)
   25344:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   25348:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
   2534c:	2000      	movs	r0, #0
   2534e:	bd08      	pop	{r3, pc}
   25350:	2000400a 	.word	0x2000400a
   25354:	40006000 	.word	0x40006000

00025358 <nrf_gpio_cfg_sense_set>:
{
    NRFX_ASSERT(*p_pin < NUMBER_OF_PINS);
#if (GPIO_COUNT == 1)
    return NRF_P0;
#else
    if (*p_pin < P0_PIN_NUM)
   25358:	281f      	cmp	r0, #31
        return NRF_P0;
    }
    else
    {
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
        return NRF_P1;
   2535a:	bf86      	itte	hi
   2535c:	4b07      	ldrhi	r3, [pc, #28]	; (2537c <nrf_gpio_cfg_sense_set+0x24>)
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
   2535e:	f000 001f 	andhi.w	r0, r0, #31
        return NRF_P0;
   25362:	f04f 43a0 	movls.w	r3, #1342177280	; 0x50000000
NRF_STATIC_INLINE void nrf_gpio_cfg_sense_set(uint32_t             pin_number,
                                              nrf_gpio_pin_sense_t sense_config)
{
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
   25366:	eb03 0380 	add.w	r3, r3, r0, lsl #2
   2536a:	f8d3 2700 	ldr.w	r2, [r3, #1792]	; 0x700
   2536e:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000

    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
   25372:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
   25376:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
}
   2537a:	4770      	bx	lr
   2537c:	50000300 	.word	0x50000300

00025380 <gpiote_pin_int_cfg>:
{
   25380:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	return port->config->config_info;
   25382:	6803      	ldr	r3, [r0, #0]
	struct gpio_nrfx_data *data = get_port_data(port);
   25384:	6887      	ldr	r7, [r0, #8]
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   25386:	689b      	ldr	r3, [r3, #8]
   25388:	f001 051f 	and.w	r5, r1, #31
{
   2538c:	460e      	mov	r6, r1
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
{
    return p_reg->INTENSET & mask;
   2538e:	494e      	ldr	r1, [pc, #312]	; (254c8 <gpiote_pin_int_cfg+0x148>)
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   25390:	791b      	ldrb	r3, [r3, #4]
   25392:	f8d1 2304 	ldr.w	r2, [r1, #772]	; 0x304
   25396:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
   2539a:	b2d2      	uxtb	r2, r2
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   2539c:	2300      	movs	r3, #0
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   2539e:	f503 70a2 	add.w	r0, r3, #324	; 0x144
   253a2:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
   253a6:	f3c0 2005 	ubfx	r0, r0, #8, #6
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
   253aa:	4285      	cmp	r5, r0
   253ac:	d170      	bne.n	25490 <gpiote_pin_int_cfg+0x110>
		    && (intenset & BIT(i))) {
   253ae:	fa22 f003 	lsr.w	r0, r2, r3
   253b2:	07c0      	lsls	r0, r0, #31
   253b4:	d56c      	bpl.n	25490 <gpiote_pin_int_cfg+0x110>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
   253b6:	009a      	lsls	r2, r3, #2
   253b8:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   253bc:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
   253c0:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
   253c4:	f020 0001 	bic.w	r0, r0, #1
   253c8:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
   253cc:	2201      	movs	r2, #1
   253ce:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENCLR = mask;
   253d2:	f8c1 3308 	str.w	r3, [r1, #776]	; 0x308
	nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
   253d6:	4628      	mov	r0, r5
   253d8:	2100      	movs	r1, #0
   253da:	f7ff ffbd 	bl	25358 <nrf_gpio_cfg_sense_set>
	if ((data->pin_int_en & BIT(pin)) && (data->int_en & BIT(pin))) {
   253de:	68b8      	ldr	r0, [r7, #8]
   253e0:	40f0      	lsrs	r0, r6
   253e2:	f010 0001 	ands.w	r0, r0, #1
   253e6:	d051      	beq.n	2548c <gpiote_pin_int_cfg+0x10c>
   253e8:	68f8      	ldr	r0, [r7, #12]
   253ea:	40f0      	lsrs	r0, r6
   253ec:	f010 0001 	ands.w	r0, r0, #1
   253f0:	d04c      	beq.n	2548c <gpiote_pin_int_cfg+0x10c>
		if (data->trig_edge & BIT(pin)) {
   253f2:	6978      	ldr	r0, [r7, #20]
   253f4:	40f0      	lsrs	r0, r6
   253f6:	f010 0401 	ands.w	r4, r0, #1
   253fa:	d055      	beq.n	254a8 <gpiote_pin_int_cfg+0x128>
			if (data->double_edge & BIT(pin)) {
   253fc:	69bb      	ldr	r3, [r7, #24]
   253fe:	40f3      	lsrs	r3, r6
   25400:	07db      	lsls	r3, r3, #31
   25402:	d449      	bmi.n	25498 <gpiote_pin_int_cfg+0x118>
			} else if (((data->active_level & BIT(pin)) != 0U)
   25404:	693b      	ldr	r3, [r7, #16]
				   ^ ((BIT(pin) & data->inverted) != 0)) {
   25406:	69fa      	ldr	r2, [r7, #28]
			} else if (((data->active_level & BIT(pin)) != 0U)
   25408:	40f3      	lsrs	r3, r6
				   ^ ((BIT(pin) & data->inverted) != 0)) {
   2540a:	fa22 f606 	lsr.w	r6, r2, r6
			} else if (((data->active_level & BIT(pin)) != 0U)
   2540e:	f003 0301 	and.w	r3, r3, #1
   25412:	f006 0601 	and.w	r6, r6, #1
				pol = NRF_GPIOTE_POLARITY_HITOLO;
   25416:	42b3      	cmp	r3, r6
   25418:	bf14      	ite	ne
   2541a:	2601      	movne	r6, #1
   2541c:	2602      	moveq	r6, #2
    p_reg->CONFIG[idx] = 0;
}

NRF_STATIC_INLINE bool nrf_gpiote_te_is_enabled(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return (p_reg->CONFIG[idx] & GPIOTE_CONFIG_MODE_Msk) != GPIOTE_CONFIG_MODE_Disabled;
   2541e:	4c2a      	ldr	r4, [pc, #168]	; (254c8 <gpiote_pin_int_cfg+0x148>)
   25420:	2100      	movs	r1, #0
   25422:	f501 73a2 	add.w	r3, r1, #324	; 0x144
   25426:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
		if (!nrf_gpiote_te_is_enabled(NRF_GPIOTE, channel)) {
   2542a:	f010 0003 	ands.w	r0, r0, #3
   2542e:	d135      	bne.n	2549c <gpiote_pin_int_cfg+0x11c>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   25430:	008b      	lsls	r3, r1, #2
   25432:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   25436:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   2543a:	022d      	lsls	r5, r5, #8
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   2543c:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   25440:	f422 324f 	bic.w	r2, r2, #211968	; 0x33c00
   25444:	f422 7240 	bic.w	r2, r2, #768	; 0x300
   25448:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   2544c:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   25450:	f405 557c 	and.w	r5, r5, #16128	; 0x3f00
   25454:	ea45 4606 	orr.w	r6, r5, r6, lsl #16
   25458:	4316      	orrs	r6, r2
			nrf_gpiote_event_t evt =
   2545a:	f101 0240 	add.w	r2, r1, #64	; 0x40
   2545e:	0092      	lsls	r2, r2, #2
    return ((uint32_t)p_reg + event);
   25460:	b292      	uxth	r2, r2
   25462:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   25466:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   2546a:	f8c3 6510 	str.w	r6, [r3, #1296]	; 0x510
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   2546e:	6010      	str	r0, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
   25470:	6812      	ldr	r2, [r2, #0]
   25472:	9201      	str	r2, [sp, #4]
    (void)dummy;
   25474:	9a01      	ldr	r2, [sp, #4]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   25476:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   2547a:	f042 0201 	orr.w	r2, r2, #1
   2547e:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
			nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
   25482:	2301      	movs	r3, #1
   25484:	fa03 f101 	lsl.w	r1, r3, r1
    p_reg->INTENSET = mask;
   25488:	f8c4 1304 	str.w	r1, [r4, #772]	; 0x304
}
   2548c:	b003      	add	sp, #12
   2548e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   25490:	3301      	adds	r3, #1
   25492:	2b08      	cmp	r3, #8
   25494:	d183      	bne.n	2539e <gpiote_pin_int_cfg+0x1e>
   25496:	e79e      	b.n	253d6 <gpiote_pin_int_cfg+0x56>
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
   25498:	2603      	movs	r6, #3
   2549a:	e7c0      	b.n	2541e <gpiote_pin_int_cfg+0x9e>
   2549c:	3101      	adds	r1, #1
	for (u8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
   2549e:	2908      	cmp	r1, #8
   254a0:	d1bf      	bne.n	25422 <gpiote_pin_int_cfg+0xa2>
	return -ENODEV;
   254a2:	f06f 0012 	mvn.w	r0, #18
   254a6:	e7f1      	b.n	2548c <gpiote_pin_int_cfg+0x10c>
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   254a8:	693b      	ldr	r3, [r7, #16]
   254aa:	69fa      	ldr	r2, [r7, #28]
   254ac:	4053      	eors	r3, r2
   254ae:	fa23 f606 	lsr.w	r6, r3, r6
		return NRF_GPIO_PIN_SENSE_HIGH;
   254b2:	f016 0f01 	tst.w	r6, #1
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   254b6:	4628      	mov	r0, r5
   254b8:	bf0c      	ite	eq
   254ba:	2103      	moveq	r1, #3
   254bc:	2102      	movne	r1, #2
   254be:	f7ff ff4b 	bl	25358 <nrf_gpio_cfg_sense_set>
	int res = 0;
   254c2:	4620      	mov	r0, r4
   254c4:	e7e2      	b.n	2548c <gpiote_pin_int_cfg+0x10c>
   254c6:	bf00      	nop
   254c8:	40006000 	.word	0x40006000

000254cc <gpio_nrfx_config>:
{
   254cc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   254d0:	4607      	mov	r7, r0
	struct gpio_nrfx_data *data = get_port_data(port);
   254d2:	6885      	ldr	r5, [r0, #8]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   254d4:	f403 4070 	and.w	r0, r3, #61440	; 0xf000
   254d8:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
{
   254dc:	461e      	mov	r6, r3
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   254de:	d03e      	beq.n	2555e <gpio_nrfx_config+0x92>
   254e0:	dc09      	bgt.n	254f6 <gpio_nrfx_config+0x2a>
   254e2:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
   254e6:	d03c      	beq.n	25562 <gpio_nrfx_config+0x96>
   254e8:	f5b0 5f40 	cmp.w	r0, #12288	; 0x3000
   254ec:	d03b      	beq.n	25566 <gpio_nrfx_config+0x9a>
   254ee:	b190      	cbz	r0, 25516 <gpio_nrfx_config+0x4a>
		return -EINVAL;
   254f0:	f06f 0015 	mvn.w	r0, #21
   254f4:	e031      	b.n	2555a <gpio_nrfx_config+0x8e>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   254f6:	f5b0 4fe0 	cmp.w	r0, #28672	; 0x7000
   254fa:	d036      	beq.n	2556a <gpio_nrfx_config+0x9e>
   254fc:	dc04      	bgt.n	25508 <gpio_nrfx_config+0x3c>
   254fe:	f5b0 4fa0 	cmp.w	r0, #20480	; 0x5000
   25502:	d1f5      	bne.n	254f0 <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0H1;
   25504:	2003      	movs	r0, #3
   25506:	e006      	b.n	25516 <gpio_nrfx_config+0x4a>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK)) {
   25508:	f5b0 4f40 	cmp.w	r0, #49152	; 0xc000
   2550c:	d02f      	beq.n	2556e <gpio_nrfx_config+0xa2>
   2550e:	f5b0 4f50 	cmp.w	r0, #53248	; 0xd000
   25512:	d1ed      	bne.n	254f0 <gpio_nrfx_config+0x24>
		drive = NRF_GPIO_PIN_H0D1;
   25514:	2007      	movs	r0, #7
	if ((flags & GPIO_PUD_MASK) == GPIO_PUD_PULL_UP) {
   25516:	f406 7840 	and.w	r8, r6, #768	; 0x300
   2551a:	f5b8 7f80 	cmp.w	r8, #256	; 0x100
   2551e:	d028      	beq.n	25572 <gpio_nrfx_config+0xa6>
		pull = NRF_GPIO_PIN_NOPULL;
   25520:	f5a8 7400 	sub.w	r4, r8, #512	; 0x200
   25524:	4263      	negs	r3, r4
   25526:	4163      	adcs	r3, r4
	dir = ((flags & GPIO_DIR_MASK) == GPIO_DIR_OUT)
   25528:	f006 0c01 	and.w	ip, r6, #1
                               | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
   2552c:	ea4f 084c 	mov.w	r8, ip, lsl #1
	if (access_op == GPIO_ACCESS_BY_PORT) {
   25530:	2901      	cmp	r1, #1
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
   25532:	ea48 080c 	orr.w	r8, r8, ip
		from_pin = pin;
   25536:	bf18      	it	ne
   25538:	b2d4      	uxtbne	r4, r2
   2553a:	ea48 2000 	orr.w	r0, r8, r0, lsl #8
        return NRF_P1;
   2553e:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 255f0 <gpio_nrfx_config+0x124>
		to_pin   = pin;
   25542:	bf12      	itee	ne
   25544:	46a1      	movne	r9, r4
		to_pin   = 31U;
   25546:	f04f 091f 	moveq.w	r9, #31
		from_pin = 0U;
   2554a:	2400      	moveq	r4, #0
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
   2554c:	ea40 0883 	orr.w	r8, r0, r3, lsl #2
   25550:	f04f 0b01 	mov.w	fp, #1
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   25554:	45a1      	cmp	r9, r4
   25556:	d20e      	bcs.n	25576 <gpio_nrfx_config+0xaa>
	return 0;
   25558:	2000      	movs	r0, #0
}
   2555a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		drive = NRF_GPIO_PIN_S0H1;
   2555e:	2002      	movs	r0, #2
   25560:	e7d9      	b.n	25516 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_H0S1;
   25562:	2001      	movs	r0, #1
   25564:	e7d7      	b.n	25516 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0S1;
   25566:	2004      	movs	r0, #4
   25568:	e7d5      	b.n	25516 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_D0H1;
   2556a:	2005      	movs	r0, #5
   2556c:	e7d3      	b.n	25516 <gpio_nrfx_config+0x4a>
		drive = NRF_GPIO_PIN_S0D1;
   2556e:	2006      	movs	r0, #6
   25570:	e7d1      	b.n	25516 <gpio_nrfx_config+0x4a>
		pull = NRF_GPIO_PIN_PULLUP;
   25572:	2303      	movs	r3, #3
   25574:	e7d8      	b.n	25528 <gpio_nrfx_config+0x5c>
	return port->config->config_info;
   25576:	683b      	ldr	r3, [r7, #0]
		nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num,
   25578:	689b      	ldr	r3, [r3, #8]
   2557a:	791a      	ldrb	r2, [r3, #4]
   2557c:	f004 031f 	and.w	r3, r4, #31
   25580:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
    if (*p_pin < P0_PIN_NUM)
   25584:	2b1f      	cmp	r3, #31
        *p_pin = *p_pin & (P0_PIN_NUM - 1);
   25586:	bfc6      	itte	gt
   25588:	f003 031f 	andgt.w	r3, r3, #31
        return NRF_P1;
   2558c:	4652      	movgt	r2, sl
        return NRF_P0;
   2558e:	f04f 42a0 	movle.w	r2, #1342177280	; 0x50000000
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   25592:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
		WRITE_BIT(data->pin_int_en, curr_pin, flags & GPIO_INT);
   25596:	07b1      	lsls	r1, r6, #30
   25598:	f842 8023 	str.w	r8, [r2, r3, lsl #2]
   2559c:	68ab      	ldr	r3, [r5, #8]
   2559e:	fa0b f204 	lsl.w	r2, fp, r4
   255a2:	bf4c      	ite	mi
   255a4:	4313      	orrmi	r3, r2
   255a6:	4393      	bicpl	r3, r2
   255a8:	60ab      	str	r3, [r5, #8]
		WRITE_BIT(data->trig_edge, curr_pin, flags & GPIO_INT_EDGE);
   255aa:	696b      	ldr	r3, [r5, #20]
   255ac:	06b0      	lsls	r0, r6, #26
   255ae:	bf4c      	ite	mi
   255b0:	4313      	orrmi	r3, r2
   255b2:	4393      	bicpl	r3, r2
   255b4:	616b      	str	r3, [r5, #20]
		WRITE_BIT(data->double_edge, curr_pin,
   255b6:	69ab      	ldr	r3, [r5, #24]
   255b8:	0671      	lsls	r1, r6, #25
   255ba:	bf4c      	ite	mi
   255bc:	4313      	orrmi	r3, r2
   255be:	4393      	bicpl	r3, r2
   255c0:	61ab      	str	r3, [r5, #24]
		WRITE_BIT(data->active_level, curr_pin,
   255c2:	692b      	ldr	r3, [r5, #16]
   255c4:	0770      	lsls	r0, r6, #29
   255c6:	bf4c      	ite	mi
   255c8:	4313      	orrmi	r3, r2
   255ca:	4393      	bicpl	r3, r2
   255cc:	612b      	str	r3, [r5, #16]
		WRITE_BIT(data->inverted, curr_pin, flags & GPIO_POL_INV);
   255ce:	69eb      	ldr	r3, [r5, #28]
   255d0:	0631      	lsls	r1, r6, #24
   255d2:	bf4c      	ite	mi
   255d4:	431a      	orrmi	r2, r3
   255d6:	ea23 0202 	bicpl.w	r2, r3, r2
   255da:	61ea      	str	r2, [r5, #28]
		res = gpiote_pin_int_cfg(port, curr_pin);
   255dc:	4621      	mov	r1, r4
   255de:	4638      	mov	r0, r7
   255e0:	f7ff fece 	bl	25380 <gpiote_pin_int_cfg>
		if (res != 0) {
   255e4:	2800      	cmp	r0, #0
   255e6:	d1b8      	bne.n	2555a <gpio_nrfx_config+0x8e>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   255e8:	3401      	adds	r4, #1
   255ea:	b2e4      	uxtb	r4, r4
   255ec:	e7b2      	b.n	25554 <gpio_nrfx_config+0x88>
   255ee:	bf00      	nop
   255f0:	50000300 	.word	0x50000300

000255f4 <gpiote_event_handler>:
{
   255f4:	b5f0      	push	{r4, r5, r6, r7, lr}
	u32_t fired_triggers[GPIO_COUNT] = {0};
   255f6:	2600      	movs	r6, #0
{
   255f8:	b085      	sub	sp, #20
	u32_t fired_triggers[GPIO_COUNT] = {0};
   255fa:	e9cd 6602 	strd	r6, r6, [sp, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   255fe:	4d28      	ldr	r5, [pc, #160]	; (256a0 <gpiote_event_handler+0xac>)
   25600:	682c      	ldr	r4, [r5, #0]
	if (port_event) {
   25602:	b15c      	cbz	r4, 2561c <gpiote_event_handler+0x28>
			check_level_trigger_pins(DEVICE_GET(gpio_nrfx_p0));
   25604:	4827      	ldr	r0, [pc, #156]	; (256a4 <gpiote_event_handler+0xb0>)
   25606:	f007 fb86 	bl	2cd16 <check_level_trigger_pins>
		fired_triggers[0] =
   2560a:	9002      	str	r0, [sp, #8]
			check_level_trigger_pins(DEVICE_GET(gpio_nrfx_p1));
   2560c:	4826      	ldr	r0, [pc, #152]	; (256a8 <gpiote_event_handler+0xb4>)
   2560e:	f007 fb82 	bl	2cd16 <check_level_trigger_pins>
		fired_triggers[1] =
   25612:	9003      	str	r0, [sp, #12]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   25614:	602e      	str	r6, [r5, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
   25616:	682b      	ldr	r3, [r5, #0]
   25618:	9300      	str	r3, [sp, #0]
    (void)dummy;
   2561a:	9b00      	ldr	r3, [sp, #0]
    return p_reg->INTENSET & mask;
   2561c:	4d23      	ldr	r5, [pc, #140]	; (256ac <gpiote_event_handler+0xb8>)
{
   2561e:	2200      	movs	r2, #0
		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
   25620:	2601      	movs	r6, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   25622:	4694      	mov	ip, r2
    return p_reg->INTENSET & mask;
   25624:	f8d5 3304 	ldr.w	r3, [r5, #772]	; 0x304
   25628:	fa06 f102 	lsl.w	r1, r6, r2
   2562c:	4219      	tst	r1, r3
   2562e:	d01d      	beq.n	2566c <gpiote_event_handler+0x78>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   25630:	0091      	lsls	r1, r2, #2
   25632:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   25636:	f501 41c2 	add.w	r1, r1, #24832	; 0x6100
   2563a:	680b      	ldr	r3, [r1, #0]
   2563c:	b1b3      	cbz	r3, 2566c <gpiote_event_handler+0x78>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   2563e:	f502 73a2 	add.w	r3, r2, #324	; 0x144
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
   25642:	af04      	add	r7, sp, #16
   25644:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   25648:	f8c1 c000 	str.w	ip, [r1]
   2564c:	f3c3 3040 	ubfx	r0, r3, #13, #1
   25650:	eb07 0080 	add.w	r0, r7, r0, lsl #2
   25654:	f3c3 2304 	ubfx	r3, r3, #8, #5
   25658:	f850 7c08 	ldr.w	r7, [r0, #-8]
   2565c:	fa06 f303 	lsl.w	r3, r6, r3
   25660:	433b      	orrs	r3, r7
   25662:	f840 3c08 	str.w	r3, [r0, #-8]
    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event));
   25666:	680b      	ldr	r3, [r1, #0]
   25668:	9301      	str	r3, [sp, #4]
    (void)dummy;
   2566a:	9b01      	ldr	r3, [sp, #4]
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   2566c:	3201      	adds	r2, #1
   2566e:	2a08      	cmp	r2, #8
   25670:	d1d8      	bne.n	25624 <gpiote_event_handler+0x30>
	if (fired_triggers[0]) {
   25672:	9902      	ldr	r1, [sp, #8]
   25674:	b111      	cbz	r1, 2567c <gpiote_event_handler+0x88>
		fire_callbacks(DEVICE_GET(gpio_nrfx_p0), fired_triggers[0]);
   25676:	480b      	ldr	r0, [pc, #44]	; (256a4 <gpiote_event_handler+0xb0>)
   25678:	f007 fb38 	bl	2ccec <fire_callbacks>
	if (fired_triggers[1]) {
   2567c:	9903      	ldr	r1, [sp, #12]
   2567e:	b111      	cbz	r1, 25686 <gpiote_event_handler+0x92>
		fire_callbacks(DEVICE_GET(gpio_nrfx_p1), fired_triggers[1]);
   25680:	4809      	ldr	r0, [pc, #36]	; (256a8 <gpiote_event_handler+0xb4>)
   25682:	f007 fb33 	bl	2ccec <fire_callbacks>
	if (port_event) {
   25686:	b144      	cbz	r4, 2569a <gpiote_event_handler+0xa6>
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p0));
   25688:	4806      	ldr	r0, [pc, #24]	; (256a4 <gpiote_event_handler+0xb0>)
   2568a:	f007 fb93 	bl	2cdb4 <cfg_level_pins>
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p1));
   2568e:	4806      	ldr	r0, [pc, #24]	; (256a8 <gpiote_event_handler+0xb4>)
}
   25690:	b005      	add	sp, #20
   25692:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p1));
   25696:	f007 bb8d 	b.w	2cdb4 <cfg_level_pins>
}
   2569a:	b005      	add	sp, #20
   2569c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2569e:	bf00      	nop
   256a0:	4000617c 	.word	0x4000617c
   256a4:	2000ff5c 	.word	0x2000ff5c
   256a8:	2000ff68 	.word	0x2000ff68
   256ac:	40006000 	.word	0x40006000

000256b0 <nvmc_wait_ready>:

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrf_nvmc_ready_check(NRF_NVMC_Type const * p_reg)
{
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
   256b0:	4a02      	ldr	r2, [pc, #8]	; (256bc <nvmc_wait_ready+0xc>)
   256b2:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
	while (!nrfx_nvmc_write_done_check()) {
   256b6:	07db      	lsls	r3, r3, #31
   256b8:	d5fb      	bpl.n	256b2 <nvmc_wait_ready+0x2>
}
   256ba:	4770      	bx	lr
   256bc:	4001e000 	.word	0x4001e000

000256c0 <flash_nrf_write_protection>:
	write_protect = enable;
   256c0:	4b01      	ldr	r3, [pc, #4]	; (256c8 <flash_nrf_write_protection+0x8>)
}
   256c2:	2000      	movs	r0, #0
	write_protect = enable;
   256c4:	7019      	strb	r1, [r3, #0]
}
   256c6:	4770      	bx	lr
   256c8:	2000400b 	.word	0x2000400b

000256cc <flash_nrf_pages_layout>:
	*layout = &dev_layout;
   256cc:	4b02      	ldr	r3, [pc, #8]	; (256d8 <flash_nrf_pages_layout+0xc>)
   256ce:	600b      	str	r3, [r1, #0]
	*layout_size = 1;
   256d0:	2301      	movs	r3, #1
   256d2:	6013      	str	r3, [r2, #0]
}
   256d4:	4770      	bx	lr
   256d6:	bf00      	nop
   256d8:	200039b4 	.word	0x200039b4

000256dc <time_slot_callback_helper>:
{
   256dc:	b570      	push	{r4, r5, r6, lr}
   256de:	b08c      	sub	sp, #48	; 0x30
   256e0:	461d      	mov	r5, r3
   256e2:	4606      	mov	r6, r0
	ll_radio_state_abort();
   256e4:	f7f8 fe9a 	bl	1e41c <ll_radio_state_abort>
	ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
   256e8:	f10d 012f 	add.w	r1, sp, #47	; 0x2f
   256ec:	f10d 002e 	add.w	r0, sp, #46	; 0x2e
   256f0:	f006 fb6a 	bl	2bdc8 <ll_timeslice_ticker_id_get>
	err = ticker_start(instance_index, /* Radio instance ticker */
   256f4:	4b13      	ldr	r3, [pc, #76]	; (25744 <time_slot_callback_helper+0x68>)
   256f6:	9506      	str	r5, [sp, #24]
   256f8:	2400      	movs	r4, #0
   256fa:	e9cd 4304 	strd	r4, r3, [sp, #16]
   256fe:	2310      	movs	r3, #16
   25700:	9300      	str	r3, [sp, #0]
   25702:	e9cd 4407 	strd	r4, r4, [sp, #28]
   25706:	4633      	mov	r3, r6
   25708:	e9cd 4402 	strd	r4, r4, [sp, #8]
   2570c:	9401      	str	r4, [sp, #4]
   2570e:	4622      	mov	r2, r4
   25710:	4621      	mov	r1, r4
   25712:	f89d 002e 	ldrb.w	r0, [sp, #46]	; 0x2e
   25716:	f7f6 fccf 	bl	1c0b8 <ticker_start>
	if (err != TICKER_STATUS_SUCCESS && err != TICKER_STATUS_BUSY) {
   2571a:	f030 0302 	bics.w	r3, r0, #2
   2571e:	d00e      	beq.n	2573e <time_slot_callback_helper+0x62>
		((struct flash_op_desc *)context)->result = -ECANCELED;
   25720:	f06f 0347 	mvn.w	r3, #71	; 0x47
   25724:	60ab      	str	r3, [r5, #8]
		err = ticker_stop(instance_index, 0, ticker_id, NULL, NULL);
   25726:	9400      	str	r4, [sp, #0]
   25728:	4623      	mov	r3, r4
   2572a:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
   2572e:	f89d 002e 	ldrb.w	r0, [sp, #46]	; 0x2e
   25732:	4621      	mov	r1, r4
   25734:	f7f6 fd52 	bl	1c1dc <ticker_stop>
	z_impl_k_sem_give(sem);
   25738:	4803      	ldr	r0, [pc, #12]	; (25748 <time_slot_callback_helper+0x6c>)
   2573a:	f001 fce5 	bl	27108 <z_impl_k_sem_give>
}
   2573e:	b00c      	add	sp, #48	; 0x30
   25740:	bd70      	pop	{r4, r5, r6, pc}
   25742:	bf00      	nop
   25744:	0002578d 	.word	0x0002578d
   25748:	200039d4 	.word	0x200039d4

0002574c <nrf_flash_init>:
{
   2574c:	b510      	push	{r4, lr}
	z_impl_k_sem_init(sem, initial_count, limit);
   2574e:	2201      	movs	r2, #1
   25750:	4611      	mov	r1, r2
   25752:	480a      	ldr	r0, [pc, #40]	; (2577c <nrf_flash_init+0x30>)
   25754:	f007 fe57 	bl	2d406 <z_impl_k_sem_init>
   25758:	2201      	movs	r2, #1
   2575a:	2100      	movs	r1, #0
   2575c:	4808      	ldr	r0, [pc, #32]	; (25780 <nrf_flash_init+0x34>)
	dev_layout.pages_count = nrfx_nvmc_flash_page_count_get();
   2575e:	4c09      	ldr	r4, [pc, #36]	; (25784 <nrf_flash_init+0x38>)
   25760:	f007 fe51 	bl	2d406 <z_impl_k_sem_init>
   25764:	f007 fc0c 	bl	2cf80 <nrfx_nvmc_flash_page_count_get>
   25768:	6020      	str	r0, [r4, #0]
	dev_layout.pages_size = nrfx_nvmc_flash_page_size_get();
   2576a:	f007 fc05 	bl	2cf78 <nrfx_nvmc_flash_page_size_get>
	write_protect = true;
   2576e:	4b06      	ldr	r3, [pc, #24]	; (25788 <nrf_flash_init+0x3c>)
	dev_layout.pages_size = nrfx_nvmc_flash_page_size_get();
   25770:	6060      	str	r0, [r4, #4]
	write_protect = true;
   25772:	2201      	movs	r2, #1
   25774:	701a      	strb	r2, [r3, #0]
}
   25776:	2000      	movs	r0, #0
   25778:	bd10      	pop	{r4, pc}
   2577a:	bf00      	nop
   2577c:	200039bc 	.word	0x200039bc
   25780:	200039d4 	.word	0x200039d4
   25784:	200039b4 	.word	0x200039b4
   25788:	2000400b 	.word	0x2000400b

0002578c <time_slot_callback_work>:
{
   2578c:	b530      	push	{r4, r5, lr}
   2578e:	461d      	mov	r5, r3
   25790:	b085      	sub	sp, #20
	if (op_desc->handler(op_desc->context) == FLASH_OP_DONE) {
   25792:	e9d3 3000 	ldrd	r3, r0, [r3]
   25796:	4798      	blx	r3
   25798:	4604      	mov	r4, r0
   2579a:	b990      	cbnz	r0, 257c2 <time_slot_callback_work+0x36>
		ll_timeslice_ticker_id_get(&instance_index, &ticker_id);
   2579c:	f10d 010f 	add.w	r1, sp, #15
   257a0:	f10d 000e 	add.w	r0, sp, #14
   257a4:	f006 fb10 	bl	2bdc8 <ll_timeslice_ticker_id_get>
		result = ticker_stop(instance_index,
   257a8:	9400      	str	r4, [sp, #0]
   257aa:	4623      	mov	r3, r4
   257ac:	f89d 200f 	ldrb.w	r2, [sp, #15]
   257b0:	f89d 000e 	ldrb.w	r0, [sp, #14]
   257b4:	4621      	mov	r1, r4
   257b6:	f7f6 fd11 	bl	1c1dc <ticker_stop>
		((struct flash_op_desc *)context)->result = 0;
   257ba:	60ac      	str	r4, [r5, #8]
	z_impl_k_sem_give(sem);
   257bc:	4802      	ldr	r0, [pc, #8]	; (257c8 <time_slot_callback_work+0x3c>)
   257be:	f001 fca3 	bl	27108 <z_impl_k_sem_give>
}
   257c2:	b005      	add	sp, #20
   257c4:	bd30      	pop	{r4, r5, pc}
   257c6:	bf00      	nop
   257c8:	200039d4 	.word	0x200039d4

000257cc <flash_nrf_erase>:
{
   257cc:	b5f0      	push	{r4, r5, r6, r7, lr}
   257ce:	b08b      	sub	sp, #44	; 0x2c
   257d0:	460e      	mov	r6, r1
   257d2:	4615      	mov	r5, r2
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
   257d4:	f007 fbd0 	bl	2cf78 <nrfx_nvmc_flash_page_size_get>
	if (write_protect) {
   257d8:	4b26      	ldr	r3, [pc, #152]	; (25874 <flash_nrf_erase+0xa8>)
   257da:	781b      	ldrb	r3, [r3, #0]
	u32_t pg_size = nrfx_nvmc_flash_page_size_get();
   257dc:	4607      	mov	r7, r0
	if (write_protect) {
   257de:	2b00      	cmp	r3, #0
   257e0:	d141      	bne.n	25866 <flash_nrf_erase+0x9a>
	if (is_regular_addr_valid(addr, size)) {
   257e2:	4629      	mov	r1, r5
   257e4:	4630      	mov	r0, r6
   257e6:	f007 fb32 	bl	2ce4e <is_regular_addr_valid>
   257ea:	2800      	cmp	r0, #0
   257ec:	d03e      	beq.n	2586c <flash_nrf_erase+0xa0>
		if (((addr % pg_size) != 0) || ((size % pg_size) != 0)) {
   257ee:	fbb6 f3f7 	udiv	r3, r6, r7
   257f2:	fb07 6313 	mls	r3, r7, r3, r6
   257f6:	2b00      	cmp	r3, #0
   257f8:	d138      	bne.n	2586c <flash_nrf_erase+0xa0>
   257fa:	fbb5 f4f7 	udiv	r4, r5, r7
   257fe:	fb07 5414 	mls	r4, r7, r4, r5
   25802:	bb9c      	cbnz	r4, 2586c <flash_nrf_erase+0xa0>
		if (!n_pages) {
   25804:	42af      	cmp	r7, r5
   25806:	d822      	bhi.n	2584e <flash_nrf_erase+0x82>
	return z_impl_k_sem_take(sem, timeout);
   25808:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2580c:	481a      	ldr	r0, [pc, #104]	; (25878 <flash_nrf_erase+0xac>)
   2580e:	f001 fca7 	bl	27160 <z_impl_k_sem_take>
	if (ticker_is_initialized(0)) {
   25812:	4620      	mov	r0, r4
   25814:	f7f6 fc32 	bl	1c07c <ticker_is_initialized>
   25818:	ab04      	add	r3, sp, #16
   2581a:	4601      	mov	r1, r0
   2581c:	b1d0      	cbz	r0, 25854 <flash_nrf_erase+0x88>
	struct flash_context context = {
   2581e:	2210      	movs	r2, #16
   25820:	4621      	mov	r1, r4
   25822:	4618      	mov	r0, r3
   25824:	f004 fe3d 	bl	2a4a2 <memset>
   25828:	2201      	movs	r2, #1
   2582a:	f88d 201c 	strb.w	r2, [sp, #28]
   2582e:	4a13      	ldr	r2, [pc, #76]	; (2587c <flash_nrf_erase+0xb0>)
	struct flash_op_desc flash_op_desc = {
   25830:	9403      	str	r4, [sp, #12]
	struct flash_context context = {
   25832:	e9cd 2208 	strd	r2, r2, [sp, #32]
	struct flash_op_desc flash_op_desc = {
   25836:	4a12      	ldr	r2, [pc, #72]	; (25880 <flash_nrf_erase+0xb4>)
   25838:	e9cd 2001 	strd	r2, r0, [sp, #4]
	return work_in_time_slice(&flash_op_desc);
   2583c:	a801      	add	r0, sp, #4
	struct flash_context context = {
   2583e:	e9cd 6505 	strd	r6, r5, [sp, #20]
	return work_in_time_slice(&flash_op_desc);
   25842:	f7e9 f991 	bl	eb68 <work_in_time_slice>
#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
		.enable_time_limit = 0 /* disable time limit */
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */
	};

	return	erase_op(&context);
   25846:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
   25848:	480b      	ldr	r0, [pc, #44]	; (25878 <flash_nrf_erase+0xac>)
   2584a:	f001 fc5d 	bl	27108 <z_impl_k_sem_give>
}
   2584e:	4620      	mov	r0, r4
   25850:	b00b      	add	sp, #44	; 0x2c
   25852:	bdf0      	pop	{r4, r5, r6, r7, pc}
	struct flash_context context = {
   25854:	2218      	movs	r2, #24
   25856:	4618      	mov	r0, r3
   25858:	f004 fe23 	bl	2a4a2 <memset>
   2585c:	e9cd 6505 	strd	r6, r5, [sp, #20]
	return	erase_op(&context);
   25860:	f7e9 f93a 	bl	ead8 <erase_op>
   25864:	e7ef      	b.n	25846 <flash_nrf_erase+0x7a>
		return -EACCES;
   25866:	f06f 040c 	mvn.w	r4, #12
   2586a:	e7f0      	b.n	2584e <flash_nrf_erase+0x82>
		return -EINVAL;
   2586c:	f06f 0415 	mvn.w	r4, #21
   25870:	e7ed      	b.n	2584e <flash_nrf_erase+0x82>
   25872:	bf00      	nop
   25874:	2000400b 	.word	0x2000400b
   25878:	200039bc 	.word	0x200039bc
   2587c:	00015e64 	.word	0x00015e64
   25880:	0000ead9 	.word	0x0000ead9

00025884 <flash_nrf_write>:
{
   25884:	b5f0      	push	{r4, r5, r6, r7, lr}
   25886:	461c      	mov	r4, r3
	if (write_protect) {
   25888:	4b1e      	ldr	r3, [pc, #120]	; (25904 <flash_nrf_write+0x80>)
   2588a:	781e      	ldrb	r6, [r3, #0]
{
   2588c:	b08b      	sub	sp, #44	; 0x2c
   2588e:	460d      	mov	r5, r1
   25890:	4617      	mov	r7, r2
	if (write_protect) {
   25892:	bb8e      	cbnz	r6, 258f8 <flash_nrf_write+0x74>
	if (is_regular_addr_valid(addr, len)) {
   25894:	4621      	mov	r1, r4
   25896:	4628      	mov	r0, r5
   25898:	f007 fad9 	bl	2ce4e <is_regular_addr_valid>
   2589c:	b378      	cbz	r0, 258fe <flash_nrf_write+0x7a>
	if (!len) {
   2589e:	b1fc      	cbz	r4, 258e0 <flash_nrf_write+0x5c>
	return z_impl_k_sem_take(sem, timeout);
   258a0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   258a4:	4818      	ldr	r0, [pc, #96]	; (25908 <flash_nrf_write+0x84>)
   258a6:	f001 fc5b 	bl	27160 <z_impl_k_sem_take>
	if (ticker_is_initialized(0)) {
   258aa:	4630      	mov	r0, r6
   258ac:	f7f6 fbe6 	bl	1c07c <ticker_is_initialized>
   258b0:	4603      	mov	r3, r0
   258b2:	a804      	add	r0, sp, #16
   258b4:	b1bb      	cbz	r3, 258e6 <flash_nrf_write+0x62>
	struct flash_context context = {
   258b6:	2301      	movs	r3, #1
   258b8:	f88d 301c 	strb.w	r3, [sp, #28]
   258bc:	f641 534c 	movw	r3, #7500	; 0x1d4c
   258c0:	e9cd 3308 	strd	r3, r3, [sp, #32]
	struct flash_op_desc flash_op_desc = {
   258c4:	4b11      	ldr	r3, [pc, #68]	; (2590c <flash_nrf_write+0x88>)
	struct flash_context context = {
   258c6:	9406      	str	r4, [sp, #24]
	struct flash_op_desc flash_op_desc = {
   258c8:	e9cd 3001 	strd	r3, r0, [sp, #4]
	return  work_in_time_slice(&flash_op_desc);
   258cc:	a801      	add	r0, sp, #4
	struct flash_context context = {
   258ce:	e9cd 7504 	strd	r7, r5, [sp, #16]
	struct flash_op_desc flash_op_desc = {
   258d2:	9603      	str	r6, [sp, #12]
	return  work_in_time_slice(&flash_op_desc);
   258d4:	f7e9 f948 	bl	eb68 <work_in_time_slice>
#if defined(CONFIG_SOC_FLASH_NRF_RADIO_SYNC)
		.enable_time_limit = 0 /* disable time limit */
#endif /* CONFIG_SOC_FLASH_NRF_RADIO_SYNC */
	};

	return write_op(&context);
   258d8:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
   258da:	480b      	ldr	r0, [pc, #44]	; (25908 <flash_nrf_write+0x84>)
   258dc:	f001 fc14 	bl	27108 <z_impl_k_sem_give>
}
   258e0:	4620      	mov	r0, r4
   258e2:	b00b      	add	sp, #44	; 0x2c
   258e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	struct flash_context context = {
   258e6:	e9cd 3307 	strd	r3, r3, [sp, #28]
   258ea:	9309      	str	r3, [sp, #36]	; 0x24
   258ec:	e9cd 7504 	strd	r7, r5, [sp, #16]
   258f0:	9406      	str	r4, [sp, #24]
	return write_op(&context);
   258f2:	f7e9 f9ad 	bl	ec50 <write_op>
   258f6:	e7ef      	b.n	258d8 <flash_nrf_write+0x54>
		return -EACCES;
   258f8:	f06f 040c 	mvn.w	r4, #12
   258fc:	e7f0      	b.n	258e0 <flash_nrf_write+0x5c>
		return -EINVAL;
   258fe:	f06f 0415 	mvn.w	r4, #21
   25902:	e7ed      	b.n	258e0 <flash_nrf_write+0x5c>
   25904:	2000400b 	.word	0x2000400b
   25908:	200039bc 	.word	0x200039bc
   2590c:	0000ec51 	.word	0x0000ec51

00025910 <event_txdrdy_check>:
#endif
}

NRF_STATIC_INLINE bool nrf_uart_event_check(NRF_UART_Type const * p_reg, nrf_uart_event_t event)
{
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   25910:	4b05      	ldr	r3, [pc, #20]	; (25928 <event_txdrdy_check+0x18>)
   25912:	681b      	ldr	r3, [r3, #0]

static bool event_txdrdy_check(void)
{
	return (nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_TXDRDY)
#ifdef CONFIG_UART_0_INTERRUPT_DRIVEN
		|| uart_sw_event_txdrdy
   25914:	b92b      	cbnz	r3, 25922 <event_txdrdy_check+0x12>
   25916:	4b05      	ldr	r3, [pc, #20]	; (2592c <event_txdrdy_check+0x1c>)
   25918:	7818      	ldrb	r0, [r3, #0]
   2591a:	3000      	adds	r0, #0
   2591c:	bf18      	it	ne
   2591e:	2001      	movne	r0, #1
   25920:	4770      	bx	lr
   25922:	2001      	movs	r0, #1
#endif
	       );
}
   25924:	4770      	bx	lr
   25926:	bf00      	nop
   25928:	4000211c 	.word	0x4000211c
   2592c:	2000400c 	.word	0x2000400c

00025930 <uart_nrfx_err_check>:
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_uart_errorsrc_get_and_clear(NRF_UART_Type * p_reg)
{
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   25930:	4b02      	ldr	r3, [pc, #8]	; (2593c <uart_nrfx_err_check+0xc>)
   25932:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   25936:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
/** Console I/O function */
static int uart_nrfx_err_check(struct device *dev)
{
	/* register bitfields maps to the defines in uart.h */
	return nrf_uart_errorsrc_get_and_clear(uart0_addr);
}
   2593a:	4770      	bx	lr
   2593c:	40002000 	.word	0x40002000

00025940 <uart_nrfx_irq_rx_enable>:
    p_reg->INTENSET = mask;
   25940:	4b02      	ldr	r3, [pc, #8]	; (2594c <uart_nrfx_irq_rx_enable+0xc>)
   25942:	2204      	movs	r2, #4
   25944:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

/** Interrupt driven receiver enabling function */
static void uart_nrfx_irq_rx_enable(struct device *dev)
{
	nrf_uart_int_enable(uart0_addr, NRF_UART_INT_MASK_RXDRDY);
}
   25948:	4770      	bx	lr
   2594a:	bf00      	nop
   2594c:	40002000 	.word	0x40002000

00025950 <uart_nrfx_irq_rx_disable>:
    p_reg->INTENCLR = mask;
   25950:	4b02      	ldr	r3, [pc, #8]	; (2595c <uart_nrfx_irq_rx_disable+0xc>)
   25952:	2204      	movs	r2, #4
   25954:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

/** Interrupt driven receiver disabling function */
static void uart_nrfx_irq_rx_disable(struct device *dev)
{
	nrf_uart_int_disable(uart0_addr, NRF_UART_INT_MASK_RXDRDY);
}
   25958:	4770      	bx	lr
   2595a:	bf00      	nop
   2595c:	40002000 	.word	0x40002000

00025960 <uart_nrfx_irq_rx_ready>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   25960:	4b02      	ldr	r3, [pc, #8]	; (2596c <uart_nrfx_irq_rx_ready+0xc>)
   25962:	6818      	ldr	r0, [r3, #0]

/** Interrupt driven receiver ready function */
static int uart_nrfx_irq_rx_ready(struct device *dev)
{
	return nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_RXDRDY);
}
   25964:	3000      	adds	r0, #0
   25966:	bf18      	it	ne
   25968:	2001      	movne	r0, #1
   2596a:	4770      	bx	lr
   2596c:	40002108 	.word	0x40002108

00025970 <uart_nrfx_irq_err_enable>:
    p_reg->INTENSET = mask;
   25970:	4b02      	ldr	r3, [pc, #8]	; (2597c <uart_nrfx_irq_err_enable+0xc>)
   25972:	f44f 7200 	mov.w	r2, #512	; 0x200
   25976:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

/** Interrupt driven error enabling function */
static void uart_nrfx_irq_err_enable(struct device *dev)
{
	nrf_uart_int_enable(uart0_addr, NRF_UART_INT_MASK_ERROR);
}
   2597a:	4770      	bx	lr
   2597c:	40002000 	.word	0x40002000

00025980 <uart_nrfx_irq_err_disable>:
    p_reg->INTENCLR = mask;
   25980:	4b02      	ldr	r3, [pc, #8]	; (2598c <uart_nrfx_irq_err_disable+0xc>)
   25982:	f44f 7200 	mov.w	r2, #512	; 0x200
   25986:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

/** Interrupt driven error disabling function */
static void uart_nrfx_irq_err_disable(struct device *dev)
{
	nrf_uart_int_disable(uart0_addr, NRF_UART_INT_MASK_ERROR);
}
   2598a:	4770      	bx	lr
   2598c:	40002000 	.word	0x40002000

00025990 <uart_nrfx_irq_callback_set>:
static void uart_nrfx_irq_callback_set(struct device *dev,
				       uart_irq_callback_user_data_t cb,
				       void *cb_data)
{
	(void)dev;
	irq_callback = cb;
   25990:	4b02      	ldr	r3, [pc, #8]	; (2599c <uart_nrfx_irq_callback_set+0xc>)
   25992:	6019      	str	r1, [r3, #0]
	irq_cb_data = cb_data;
   25994:	4b02      	ldr	r3, [pc, #8]	; (259a0 <uart_nrfx_irq_callback_set+0x10>)
   25996:	601a      	str	r2, [r3, #0]
}
   25998:	4770      	bx	lr
   2599a:	bf00      	nop
   2599c:	200039ec 	.word	0x200039ec
   259a0:	200039f0 	.word	0x200039f0

000259a4 <uart_nrfx_irq_tx_disable>:
   259a4:	4b03      	ldr	r3, [pc, #12]	; (259b4 <uart_nrfx_irq_tx_disable+0x10>)
   259a6:	2280      	movs	r2, #128	; 0x80
   259a8:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    p_reg->TXD = txd;
}

NRF_STATIC_INLINE void nrf_uart_task_trigger(NRF_UART_Type * p_reg, nrf_uart_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   259ac:	2201      	movs	r2, #1
   259ae:	60da      	str	r2, [r3, #12]
	device_busy_clear(dev);
   259b0:	f007 baeb 	b.w	2cf8a <device_busy_clear>
   259b4:	40002000 	.word	0x40002000

000259b8 <uart_nrfx_irq_tx_enable>:
{
   259b8:	b508      	push	{r3, lr}
	device_busy_set(dev);
   259ba:	f007 fae5 	bl	2cf88 <device_busy_set>
   259be:	4b0d      	ldr	r3, [pc, #52]	; (259f4 <uart_nrfx_irq_tx_enable+0x3c>)
   259c0:	2201      	movs	r2, #1
   259c2:	601a      	str	r2, [r3, #0]
    p_reg->INTENSET = mask;
   259c4:	2280      	movs	r2, #128	; 0x80
   259c6:	f8c3 22fc 	str.w	r2, [r3, #764]	; 0x2fc
	__asm__ volatile(
   259ca:	f04f 0220 	mov.w	r2, #32
   259ce:	f3ef 8311 	mrs	r3, BASEPRI
   259d2:	f382 8811 	msr	BASEPRI, r2
   259d6:	f3bf 8f6f 	isb	sy
	if (uart_sw_event_txdrdy) {
   259da:	4a07      	ldr	r2, [pc, #28]	; (259f8 <uart_nrfx_irq_tx_enable+0x40>)
   259dc:	7812      	ldrb	r2, [r2, #0]
   259de:	b11a      	cbz	r2, 259e8 <uart_nrfx_irq_tx_enable+0x30>
   259e0:	4a06      	ldr	r2, [pc, #24]	; (259fc <uart_nrfx_irq_tx_enable+0x44>)
   259e2:	2104      	movs	r1, #4
   259e4:	f8c2 1100 	str.w	r1, [r2, #256]	; 0x100
	__asm__ volatile(
   259e8:	f383 8811 	msr	BASEPRI, r3
   259ec:	f3bf 8f6f 	isb	sy
}
   259f0:	bd08      	pop	{r3, pc}
   259f2:	bf00      	nop
   259f4:	40002008 	.word	0x40002008
   259f8:	2000400c 	.word	0x2000400c
   259fc:	e000e100 	.word	0xe000e100

00025a00 <uart_nrfx_irq_is_pending>:
{
   25a00:	b508      	push	{r3, lr}
    return p_reg->INTENSET & mask;
   25a02:	4b0c      	ldr	r3, [pc, #48]	; (25a34 <uart_nrfx_irq_is_pending+0x34>)
   25a04:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
		||
   25a08:	f012 0f80 	tst.w	r2, #128	; 0x80
   25a0c:	461a      	mov	r2, r3
   25a0e:	d105      	bne.n	25a1c <uart_nrfx_irq_is_pending+0x1c>
   25a10:	f8d2 0304 	ldr.w	r0, [r2, #772]	; 0x304
   25a14:	f010 0004 	ands.w	r0, r0, #4
   25a18:	d106      	bne.n	25a28 <uart_nrfx_irq_is_pending+0x28>
}
   25a1a:	bd08      	pop	{r3, pc}
		 event_txdrdy_check())
   25a1c:	f7ff ff78 	bl	25910 <event_txdrdy_check>
					   NRF_UART_INT_MASK_TXDRDY) &&
   25a20:	2800      	cmp	r0, #0
   25a22:	d0f5      	beq.n	25a10 <uart_nrfx_irq_is_pending+0x10>
		||
   25a24:	2001      	movs	r0, #1
   25a26:	e7f8      	b.n	25a1a <uart_nrfx_irq_is_pending+0x1a>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   25a28:	4b03      	ldr	r3, [pc, #12]	; (25a38 <uart_nrfx_irq_is_pending+0x38>)
   25a2a:	6818      	ldr	r0, [r3, #0]
					   NRF_UART_INT_MASK_RXDRDY) &&
   25a2c:	3000      	adds	r0, #0
   25a2e:	bf18      	it	ne
   25a30:	2001      	movne	r0, #1
   25a32:	e7f2      	b.n	25a1a <uart_nrfx_irq_is_pending+0x1a>
   25a34:	40002000 	.word	0x40002000
   25a38:	40002108 	.word	0x40002108

00025a3c <uart_nrfx_configure>:
{
   25a3c:	b570      	push	{r4, r5, r6, lr}
	switch (cfg->stop_bits) {
   25a3e:	794b      	ldrb	r3, [r1, #5]
   25a40:	2b01      	cmp	r3, #1
   25a42:	d026      	beq.n	25a92 <uart_nrfx_configure+0x56>
   25a44:	2b03      	cmp	r3, #3
   25a46:	d121      	bne.n	25a8c <uart_nrfx_configure+0x50>
		uart_cfg.stop = NRF_UART_STOP_TWO;
   25a48:	2610      	movs	r6, #16
	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
   25a4a:	798b      	ldrb	r3, [r1, #6]
   25a4c:	2b03      	cmp	r3, #3
   25a4e:	d11d      	bne.n	25a8c <uart_nrfx_configure+0x50>
	switch (cfg->flow_ctrl) {
   25a50:	79cc      	ldrb	r4, [r1, #7]
   25a52:	b12c      	cbz	r4, 25a60 <uart_nrfx_configure+0x24>
   25a54:	2c01      	cmp	r4, #1
   25a56:	d119      	bne.n	25a8c <uart_nrfx_configure+0x50>
	return dev->config->config_info;
   25a58:	6803      	ldr	r3, [r0, #0]
		if (get_dev_config(dev)->rts_cts_pins_set) {
   25a5a:	689b      	ldr	r3, [r3, #8]
   25a5c:	781b      	ldrb	r3, [r3, #0]
   25a5e:	b1ab      	cbz	r3, 25a8c <uart_nrfx_configure+0x50>
	switch (cfg->parity) {
   25a60:	790a      	ldrb	r2, [r1, #4]
   25a62:	b112      	cbz	r2, 25a6a <uart_nrfx_configure+0x2e>
   25a64:	2a02      	cmp	r2, #2
   25a66:	d111      	bne.n	25a8c <uart_nrfx_configure+0x50>
		uart_cfg.parity = NRF_UART_PARITY_INCLUDED;
   25a68:	220e      	movs	r2, #14
	if (baudrate_set(dev, cfg->baudrate) != 0) {
   25a6a:	680b      	ldr	r3, [r1, #0]
	switch (baudrate) {
   25a6c:	f647 2512 	movw	r5, #31250	; 0x7a12
   25a70:	42ab      	cmp	r3, r5
   25a72:	d062      	beq.n	25b3a <uart_nrfx_configure+0xfe>
   25a74:	d829      	bhi.n	25aca <uart_nrfx_configure+0x8e>
   25a76:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
   25a7a:	d061      	beq.n	25b40 <uart_nrfx_configure+0x104>
   25a7c:	d814      	bhi.n	25aa8 <uart_nrfx_configure+0x6c>
   25a7e:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
   25a82:	d05f      	beq.n	25b44 <uart_nrfx_configure+0x108>
   25a84:	d807      	bhi.n	25a96 <uart_nrfx_configure+0x5a>
   25a86:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
   25a8a:	d05e      	beq.n	25b4a <uart_nrfx_configure+0x10e>
		return -ENOTSUP;
   25a8c:	f06f 0022 	mvn.w	r0, #34	; 0x22
   25a90:	e052      	b.n	25b38 <uart_nrfx_configure+0xfc>
		uart_cfg.stop = NRF_UART_STOP_ONE;
   25a92:	2600      	movs	r6, #0
   25a94:	e7d9      	b.n	25a4a <uart_nrfx_configure+0xe>
	switch (baudrate) {
   25a96:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
   25a9a:	d059      	beq.n	25b50 <uart_nrfx_configure+0x114>
   25a9c:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
   25aa0:	d1f4      	bne.n	25a8c <uart_nrfx_configure+0x50>
		nrf_baudrate = NRF_UART_BAUDRATE_2400;
   25aa2:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
   25aa6:	e03b      	b.n	25b20 <uart_nrfx_configure+0xe4>
	switch (baudrate) {
   25aa8:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
   25aac:	d053      	beq.n	25b56 <uart_nrfx_configure+0x11a>
   25aae:	d804      	bhi.n	25aba <uart_nrfx_configure+0x7e>
   25ab0:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
   25ab4:	d1ea      	bne.n	25a8c <uart_nrfx_configure+0x50>
		nrf_baudrate = NRF_UART_BAUDRATE_9600;
   25ab6:	4b31      	ldr	r3, [pc, #196]	; (25b7c <uart_nrfx_configure+0x140>)
   25ab8:	e032      	b.n	25b20 <uart_nrfx_configure+0xe4>
	switch (baudrate) {
   25aba:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
   25abe:	d04d      	beq.n	25b5c <uart_nrfx_configure+0x120>
   25ac0:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
   25ac4:	d1e2      	bne.n	25a8c <uart_nrfx_configure+0x50>
		nrf_baudrate = NRF_UART_BAUDRATE_28800;
   25ac6:	4b2e      	ldr	r3, [pc, #184]	; (25b80 <uart_nrfx_configure+0x144>)
   25ac8:	e02a      	b.n	25b20 <uart_nrfx_configure+0xe4>
	switch (baudrate) {
   25aca:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
   25ace:	d047      	beq.n	25b60 <uart_nrfx_configure+0x124>
   25ad0:	d811      	bhi.n	25af6 <uart_nrfx_configure+0xba>
   25ad2:	f64d 25c0 	movw	r5, #56000	; 0xdac0
   25ad6:	42ab      	cmp	r3, r5
   25ad8:	d044      	beq.n	25b64 <uart_nrfx_configure+0x128>
   25ada:	d804      	bhi.n	25ae6 <uart_nrfx_configure+0xaa>
   25adc:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
   25ae0:	d1d4      	bne.n	25a8c <uart_nrfx_configure+0x50>
		nrf_baudrate = NRF_UART_BAUDRATE_38400;
   25ae2:	4b28      	ldr	r3, [pc, #160]	; (25b84 <uart_nrfx_configure+0x148>)
   25ae4:	e01c      	b.n	25b20 <uart_nrfx_configure+0xe4>
	switch (baudrate) {
   25ae6:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
   25aea:	d03e      	beq.n	25b6a <uart_nrfx_configure+0x12e>
   25aec:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
   25af0:	d1cc      	bne.n	25a8c <uart_nrfx_configure+0x50>
		nrf_baudrate = NRF_UART_BAUDRATE_76800;
   25af2:	4b25      	ldr	r3, [pc, #148]	; (25b88 <uart_nrfx_configure+0x14c>)
   25af4:	e014      	b.n	25b20 <uart_nrfx_configure+0xe4>
	switch (baudrate) {
   25af6:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
   25afa:	d038      	beq.n	25b6e <uart_nrfx_configure+0x132>
   25afc:	d808      	bhi.n	25b10 <uart_nrfx_configure+0xd4>
   25afe:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
   25b02:	d036      	beq.n	25b72 <uart_nrfx_configure+0x136>
   25b04:	4d21      	ldr	r5, [pc, #132]	; (25b8c <uart_nrfx_configure+0x150>)
   25b06:	42ab      	cmp	r3, r5
   25b08:	d1c0      	bne.n	25a8c <uart_nrfx_configure+0x50>
		nrf_baudrate = NRF_UART_BAUDRATE_250000;
   25b0a:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   25b0e:	e007      	b.n	25b20 <uart_nrfx_configure+0xe4>
	switch (baudrate) {
   25b10:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
   25b14:	d02f      	beq.n	25b76 <uart_nrfx_configure+0x13a>
   25b16:	4d1e      	ldr	r5, [pc, #120]	; (25b90 <uart_nrfx_configure+0x154>)
   25b18:	42ab      	cmp	r3, r5
   25b1a:	d1b7      	bne.n	25a8c <uart_nrfx_configure+0x50>
		nrf_baudrate = NRF_UART_BAUDRATE_1000000;
   25b1c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uart_baudrate_set(NRF_UART_Type * p_reg, nrf_uart_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
   25b20:	4d1c      	ldr	r5, [pc, #112]	; (25b94 <uart_nrfx_configure+0x158>)
                    | (uint32_t)p_cfg->hwfc;
   25b22:	4334      	orrs	r4, r6
   25b24:	4322      	orrs	r2, r4
    p_reg->BAUDRATE = baudrate;
   25b26:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
    p_reg->CONFIG = (uint32_t)p_cfg->parity
   25b2a:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
	get_dev_data(dev)->uart_config = *cfg;
   25b2e:	6883      	ldr	r3, [r0, #8]
   25b30:	c903      	ldmia	r1, {r0, r1}
   25b32:	e883 0003 	stmia.w	r3, {r0, r1}
	return 0;
   25b36:	2000      	movs	r0, #0
}
   25b38:	bd70      	pop	{r4, r5, r6, pc}
		nrf_baudrate = NRF_UART_BAUDRATE_31250;
   25b3a:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   25b3e:	e7ef      	b.n	25b20 <uart_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UART_BAUDRATE_4800;
   25b40:	4b15      	ldr	r3, [pc, #84]	; (25b98 <uart_nrfx_configure+0x15c>)
   25b42:	e7ed      	b.n	25b20 <uart_nrfx_configure+0xe4>
		nrf_baudrate = 0x00027000;
   25b44:	f44f 331c 	mov.w	r3, #159744	; 0x27000
   25b48:	e7ea      	b.n	25b20 <uart_nrfx_configure+0xe4>
		nrf_baudrate = 0x00014000;
   25b4a:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
   25b4e:	e7e7      	b.n	25b20 <uart_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UART_BAUDRATE_1200;
   25b50:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
   25b54:	e7e4      	b.n	25b20 <uart_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UART_BAUDRATE_14400;
   25b56:	f44f 136c 	mov.w	r3, #3866624	; 0x3b0000
   25b5a:	e7e1      	b.n	25b20 <uart_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UART_BAUDRATE_19200;
   25b5c:	4b0f      	ldr	r3, [pc, #60]	; (25b9c <uart_nrfx_configure+0x160>)
   25b5e:	e7df      	b.n	25b20 <uart_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UART_BAUDRATE_115200;
   25b60:	4b0f      	ldr	r3, [pc, #60]	; (25ba0 <uart_nrfx_configure+0x164>)
   25b62:	e7dd      	b.n	25b20 <uart_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UART_BAUDRATE_56000;
   25b64:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
   25b68:	e7da      	b.n	25b20 <uart_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UART_BAUDRATE_57600;
   25b6a:	4b0e      	ldr	r3, [pc, #56]	; (25ba4 <uart_nrfx_configure+0x168>)
   25b6c:	e7d8      	b.n	25b20 <uart_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UART_BAUDRATE_460800;
   25b6e:	4b0e      	ldr	r3, [pc, #56]	; (25ba8 <uart_nrfx_configure+0x16c>)
   25b70:	e7d6      	b.n	25b20 <uart_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UART_BAUDRATE_230400;
   25b72:	4b0e      	ldr	r3, [pc, #56]	; (25bac <uart_nrfx_configure+0x170>)
   25b74:	e7d4      	b.n	25b20 <uart_nrfx_configure+0xe4>
		nrf_baudrate = NRF_UART_BAUDRATE_921600;
   25b76:	4b0e      	ldr	r3, [pc, #56]	; (25bb0 <uart_nrfx_configure+0x174>)
   25b78:	e7d2      	b.n	25b20 <uart_nrfx_configure+0xe4>
   25b7a:	bf00      	nop
   25b7c:	00275000 	.word	0x00275000
   25b80:	0075f000 	.word	0x0075f000
   25b84:	009d5000 	.word	0x009d5000
   25b88:	013a9000 	.word	0x013a9000
   25b8c:	0003d090 	.word	0x0003d090
   25b90:	000f4240 	.word	0x000f4240
   25b94:	40002000 	.word	0x40002000
   25b98:	0013b000 	.word	0x0013b000
   25b9c:	004ea000 	.word	0x004ea000
   25ba0:	01d7e000 	.word	0x01d7e000
   25ba4:	00ebf000 	.word	0x00ebf000
   25ba8:	075f7000 	.word	0x075f7000
   25bac:	03afb000 	.word	0x03afb000
   25bb0:	0ebed000 	.word	0x0ebed000

00025bb4 <uart_nrfx_isr>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   25bb4:	4b08      	ldr	r3, [pc, #32]	; (25bd8 <uart_nrfx_isr+0x24>)
   25bb6:	681a      	ldr	r2, [r3, #0]
 * @param arg Argument to ISR.
 *
 * @return N/A
 */
static void uart_nrfx_isr(void *arg)
{
   25bb8:	b082      	sub	sp, #8
	ARG_UNUSED(arg);

	if (nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_ERROR)) {
   25bba:	b122      	cbz	r2, 25bc6 <uart_nrfx_isr+0x12>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25bbc:	2200      	movs	r2, #0
   25bbe:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   25bc0:	681b      	ldr	r3, [r3, #0]
   25bc2:	9301      	str	r3, [sp, #4]
    (void)dummy;
   25bc4:	9b01      	ldr	r3, [sp, #4]
		nrf_uart_event_clear(uart0_addr, NRF_UART_EVENT_ERROR);
	}

	if (irq_callback) {
   25bc6:	4b05      	ldr	r3, [pc, #20]	; (25bdc <uart_nrfx_isr+0x28>)
   25bc8:	681b      	ldr	r3, [r3, #0]
   25bca:	b11b      	cbz	r3, 25bd4 <uart_nrfx_isr+0x20>
		irq_callback(irq_cb_data);
   25bcc:	4a04      	ldr	r2, [pc, #16]	; (25be0 <uart_nrfx_isr+0x2c>)
   25bce:	6810      	ldr	r0, [r2, #0]
	}
}
   25bd0:	b002      	add	sp, #8
		irq_callback(irq_cb_data);
   25bd2:	4718      	bx	r3
}
   25bd4:	b002      	add	sp, #8
   25bd6:	4770      	bx	lr
   25bd8:	40002124 	.word	0x40002124
   25bdc:	200039ec 	.word	0x200039ec
   25be0:	200039f0 	.word	0x200039f0

00025be4 <uart_nrfx_fifo_read>:
{
   25be4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	while ((size - num_rx > 0) &&
   25be6:	2300      	movs	r3, #0
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   25be8:	4c09      	ldr	r4, [pc, #36]	; (25c10 <uart_nrfx_fifo_read+0x2c>)
    return p_reg->RXD;
   25bea:	4f0a      	ldr	r7, [pc, #40]	; (25c14 <uart_nrfx_fifo_read+0x30>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25bec:	461e      	mov	r6, r3
   25bee:	b2d8      	uxtb	r0, r3
   25bf0:	1a15      	subs	r5, r2, r0
   25bf2:	2d00      	cmp	r5, #0
   25bf4:	dd02      	ble.n	25bfc <uart_nrfx_fifo_read+0x18>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   25bf6:	6825      	ldr	r5, [r4, #0]
   25bf8:	3301      	adds	r3, #1
   25bfa:	b90d      	cbnz	r5, 25c00 <uart_nrfx_fifo_read+0x1c>
}
   25bfc:	b003      	add	sp, #12
   25bfe:	bdf0      	pop	{r4, r5, r6, r7, pc}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25c00:	6026      	str	r6, [r4, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   25c02:	6825      	ldr	r5, [r4, #0]
   25c04:	9501      	str	r5, [sp, #4]
    (void)dummy;
   25c06:	9d01      	ldr	r5, [sp, #4]
    return p_reg->RXD;
   25c08:	f8d7 5518 	ldr.w	r5, [r7, #1304]	; 0x518
   25c0c:	540d      	strb	r5, [r1, r0]
   25c0e:	e7ee      	b.n	25bee <uart_nrfx_fifo_read+0xa>
   25c10:	40002108 	.word	0x40002108
   25c14:	40002000 	.word	0x40002000

00025c18 <uart_nrfx_poll_out>:
{
   25c18:	b507      	push	{r0, r1, r2, lr}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25c1a:	4a0b      	ldr	r2, [pc, #44]	; (25c48 <uart_nrfx_poll_out+0x30>)
   25c1c:	2300      	movs	r3, #0
   25c1e:	6013      	str	r3, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   25c20:	6812      	ldr	r2, [r2, #0]
   25c22:	9201      	str	r2, [sp, #4]
    (void)dummy;
   25c24:	9a01      	ldr	r2, [sp, #4]
	uart_sw_event_txdrdy = 0U;
   25c26:	4a09      	ldr	r2, [pc, #36]	; (25c4c <uart_nrfx_poll_out+0x34>)
   25c28:	7013      	strb	r3, [r2, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   25c2a:	4b09      	ldr	r3, [pc, #36]	; (25c50 <uart_nrfx_poll_out+0x38>)
   25c2c:	2201      	movs	r2, #1
   25c2e:	601a      	str	r2, [r3, #0]
    p_reg->TXD = txd;
   25c30:	f8c3 1514 	str.w	r1, [r3, #1300]	; 0x514
	while (!event_txdrdy_check()) {
   25c34:	f7ff fe6c 	bl	25910 <event_txdrdy_check>
   25c38:	2800      	cmp	r0, #0
   25c3a:	d0fb      	beq.n	25c34 <uart_nrfx_poll_out+0x1c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   25c3c:	4b05      	ldr	r3, [pc, #20]	; (25c54 <uart_nrfx_poll_out+0x3c>)
   25c3e:	2201      	movs	r2, #1
   25c40:	601a      	str	r2, [r3, #0]
}
   25c42:	b003      	add	sp, #12
   25c44:	f85d fb04 	ldr.w	pc, [sp], #4
   25c48:	4000211c 	.word	0x4000211c
   25c4c:	2000400c 	.word	0x2000400c
   25c50:	40002008 	.word	0x40002008
   25c54:	4000200c 	.word	0x4000200c

00025c58 <uart_nrfx_poll_in>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   25c58:	4b08      	ldr	r3, [pc, #32]	; (25c7c <uart_nrfx_poll_in+0x24>)
   25c5a:	681a      	ldr	r2, [r3, #0]
{
   25c5c:	b082      	sub	sp, #8
	if (!nrf_uart_event_check(uart0_addr, NRF_UART_EVENT_RXDRDY)) {
   25c5e:	b152      	cbz	r2, 25c76 <uart_nrfx_poll_in+0x1e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25c60:	2000      	movs	r0, #0
   25c62:	6018      	str	r0, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   25c64:	681b      	ldr	r3, [r3, #0]
   25c66:	9301      	str	r3, [sp, #4]
    (void)dummy;
   25c68:	9b01      	ldr	r3, [sp, #4]
    return p_reg->RXD;
   25c6a:	4b05      	ldr	r3, [pc, #20]	; (25c80 <uart_nrfx_poll_in+0x28>)
   25c6c:	f8d3 3518 	ldr.w	r3, [r3, #1304]	; 0x518
   25c70:	700b      	strb	r3, [r1, #0]
}
   25c72:	b002      	add	sp, #8
   25c74:	4770      	bx	lr
		return -1;
   25c76:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   25c7a:	e7fa      	b.n	25c72 <uart_nrfx_poll_in+0x1a>
   25c7c:	40002108 	.word	0x40002108
   25c80:	40002000 	.word	0x40002000

00025c84 <uart_nrfx_fifo_fill>:
{
   25c84:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25c88:	4e0d      	ldr	r6, [pc, #52]	; (25cc0 <uart_nrfx_fifo_fill+0x3c>)
	uart_sw_event_txdrdy = 0U;
   25c8a:	4f0e      	ldr	r7, [pc, #56]	; (25cc4 <uart_nrfx_fifo_fill+0x40>)
    p_reg->TXD = txd;
   25c8c:	f8df 8038 	ldr.w	r8, [pc, #56]	; 25cc8 <uart_nrfx_fifo_fill+0x44>
	while ((len - num_tx > 0) &&
   25c90:	2400      	movs	r4, #0
   25c92:	b2e5      	uxtb	r5, r4
   25c94:	1b53      	subs	r3, r2, r5
   25c96:	2b00      	cmp	r3, #0
   25c98:	dd03      	ble.n	25ca2 <uart_nrfx_fifo_fill+0x1e>
	       event_txdrdy_check()) {
   25c9a:	f7ff fe39 	bl	25910 <event_txdrdy_check>
   25c9e:	3401      	adds	r4, #1
	while ((len - num_tx > 0) &&
   25ca0:	b918      	cbnz	r0, 25caa <uart_nrfx_fifo_fill+0x26>
}
   25ca2:	4628      	mov	r0, r5
   25ca4:	b002      	add	sp, #8
   25ca6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25caa:	2300      	movs	r3, #0
   25cac:	6033      	str	r3, [r6, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   25cae:	6830      	ldr	r0, [r6, #0]
   25cb0:	9001      	str	r0, [sp, #4]
    (void)dummy;
   25cb2:	9801      	ldr	r0, [sp, #4]
	uart_sw_event_txdrdy = 0U;
   25cb4:	703b      	strb	r3, [r7, #0]
    p_reg->TXD = txd;
   25cb6:	5d4b      	ldrb	r3, [r1, r5]
   25cb8:	f8c8 351c 	str.w	r3, [r8, #1308]	; 0x51c
   25cbc:	e7e9      	b.n	25c92 <uart_nrfx_fifo_fill+0xe>
   25cbe:	bf00      	nop
   25cc0:	4000211c 	.word	0x4000211c
   25cc4:	2000400c 	.word	0x2000400c
   25cc8:	40002000 	.word	0x40002000

00025ccc <uart_nrfx_init>:
}


NRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
   25ccc:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 * @param dev UART device struct
 *
 * @return 0 on success
 */
static int uart_nrfx_init(struct device *dev)
{
   25cd0:	b537      	push	{r0, r1, r2, r4, r5, lr}
    p_reg->PSEL.RXD = pselrxd;
   25cd2:	4c1c      	ldr	r4, [pc, #112]	; (25d44 <uart_nrfx_init+0x78>)
   25cd4:	2240      	movs	r2, #64	; 0x40
   25cd6:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   25cda:	2103      	movs	r1, #3
   25cdc:	2200      	movs	r2, #0
   25cde:	2508      	movs	r5, #8
   25ce0:	f8c3 1718 	str.w	r1, [r3, #1816]	; 0x718
   25ce4:	f8c3 2720 	str.w	r2, [r3, #1824]	; 0x720
   25ce8:	f8c4 5514 	str.w	r5, [r4, #1300]	; 0x514
    p_reg->PSEL.TXD = pseltxd;
   25cec:	2506      	movs	r5, #6
   25cee:	f8c4 550c 	str.w	r5, [r4, #1292]	; 0x50c
    p_reg->OUTSET = set_mask;
   25cf2:	2520      	movs	r5, #32
   25cf4:	f8c3 5508 	str.w	r5, [r3, #1288]	; 0x508
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   25cf8:	f8c3 1714 	str.w	r1, [r3, #1812]	; 0x714
   25cfc:	f8c3 271c 	str.w	r2, [r3, #1820]	; 0x71c
    p_reg->PSEL.RTS = pselrts;
   25d00:	2305      	movs	r3, #5
   25d02:	f8c4 3508 	str.w	r3, [r4, #1288]	; 0x508
    p_reg->PSEL.CTS = pselcts;
   25d06:	2307      	movs	r3, #7
   25d08:	f8c4 3510 	str.w	r3, [r4, #1296]	; 0x510
			       DT_NORDIC_NRF_UART_UART_0_RTS_PIN,
			       DT_NORDIC_NRF_UART_UART_0_CTS_PIN);
#endif

	/* Set initial configuration */
	err = uart_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
   25d0c:	6881      	ldr	r1, [r0, #8]
   25d0e:	f7ff fe95 	bl	25a3c <uart_nrfx_configure>
	if (err) {
   25d12:	4605      	mov	r5, r0
   25d14:	b990      	cbnz	r0, 25d3c <uart_nrfx_init+0x70>
    p_reg->ENABLE = UART_ENABLE_ENABLE_Enabled;
   25d16:	2304      	movs	r3, #4
   25d18:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   25d1c:	4b0a      	ldr	r3, [pc, #40]	; (25d48 <uart_nrfx_init+0x7c>)
   25d1e:	6018      	str	r0, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   25d20:	681b      	ldr	r3, [r3, #0]
   25d22:	9301      	str	r3, [sp, #4]
    (void)dummy;
   25d24:	9b01      	ldr	r3, [sp, #4]

#ifdef CONFIG_UART_0_INTERRUPT_DRIVEN
	/* Simulate that the TXDRDY event is set, so that the transmitter status
	 * is indicated correctly.
	 */
	uart_sw_event_txdrdy = 1U;
   25d26:	4b09      	ldr	r3, [pc, #36]	; (25d4c <uart_nrfx_init+0x80>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   25d28:	2101      	movs	r1, #1
   25d2a:	6021      	str	r1, [r4, #0]
#endif

#if defined(CONFIG_UART_0_ASYNC) || defined(CONFIG_UART_0_INTERRUPT_DRIVEN)

	IRQ_CONNECT(DT_NORDIC_NRF_UART_UART_0_IRQ_0,
   25d2c:	4602      	mov	r2, r0
   25d2e:	2002      	movs	r0, #2
	uart_sw_event_txdrdy = 1U;
   25d30:	7019      	strb	r1, [r3, #0]
	IRQ_CONNECT(DT_NORDIC_NRF_UART_UART_0_IRQ_0,
   25d32:	f7ed fef7 	bl	13b24 <z_arm_irq_priority_set>
		    DT_NORDIC_NRF_UART_UART_0_IRQ_0_PRIORITY,
		    uart_nrfx_isr,
		    DEVICE_GET(uart_nrfx_uart0),
		    0);
	irq_enable(DT_NORDIC_NRF_UART_UART_0_IRQ_0);
   25d36:	2002      	movs	r0, #2
   25d38:	f7ed fec2 	bl	13ac0 <arch_irq_enable>
	defined(DT_NORDIC_NRF_UART_UART_0_CTS_PIN)
	k_delayed_work_init(&uart0_cb.tx_timeout_work, tx_timeout);
#endif
#endif
	return 0;
}
   25d3c:	4628      	mov	r0, r5
   25d3e:	b003      	add	sp, #12
   25d40:	bd30      	pop	{r4, r5, pc}
   25d42:	bf00      	nop
   25d44:	40002000 	.word	0x40002000
   25d48:	40002108 	.word	0x40002108
   25d4c:	2000400c 	.word	0x2000400c

00025d50 <rng_pool_get>:
#pragma GCC push_options
#if defined(CONFIG_BT_CTLR_FAST_ENC)
#pragma GCC optimize ("Ofast")
#endif
static u16_t rng_pool_get(struct rng_pool *rngp, u8_t *buf, u16_t len)
{
   25d50:	b5f0      	push	{r4, r5, r6, r7, lr}
	u32_t last  = rngp->last;
   25d52:	7883      	ldrb	r3, [r0, #2]
	u32_t mask  = rngp->mask;
   25d54:	78c7      	ldrb	r7, [r0, #3]
	__asm__ volatile(
   25d56:	f04f 0420 	mov.w	r4, #32
   25d5a:	f3ef 8e11 	mrs	lr, BASEPRI
   25d5e:	f384 8811 	msr	BASEPRI, r4
   25d62:	f3bf 8f6f 	isb	sy
	u32_t first, available;
	u32_t other_read_in_progress;
	unsigned int key;

	key = irq_lock();
	first = rngp->first_alloc;
   25d66:	7806      	ldrb	r6, [r0, #0]
	/*
	 * The other_read_in_progress is non-zero if rngp->first_read != first,
	 * which means that lower-priority code (which was interrupted by this
	 * call) already allocated area for read.
	 */
	other_read_in_progress = (rngp->first_read ^ first);
   25d68:	f890 c001 	ldrb.w	ip, [r0, #1]

	available = (last - first) & mask;
   25d6c:	1b9b      	subs	r3, r3, r6
   25d6e:	403b      	ands	r3, r7
	if (available < len) {
   25d70:	429a      	cmp	r2, r3
		len = available;
   25d72:	bf88      	it	hi
   25d74:	b29a      	uxthhi	r2, r3

	/*
	 * Move alloc index forward to signal, that part of the buffer is
	 * now reserved for this call.
	 */
	rngp->first_alloc = (first + len) & mask;
   25d76:	18b4      	adds	r4, r6, r2
   25d78:	403c      	ands	r4, r7
	first = rngp->first_alloc;
   25d7a:	4635      	mov	r5, r6
	rngp->first_alloc = (first + len) & mask;
   25d7c:	7004      	strb	r4, [r0, #0]
	__asm__ volatile(
   25d7e:	f38e 8811 	msr	BASEPRI, lr
   25d82:	f3bf 8f6f 	isb	sy
   25d86:	440a      	add	r2, r1
	u8_t *dst   = buf;
   25d88:	460c      	mov	r4, r1
	irq_unlock(key);

	while (likely(len--)) {
   25d8a:	42a2      	cmp	r2, r4
   25d8c:	d11a      	bne.n	25dc4 <rng_pool_get+0x74>
	/*
	 * If this call is the last one accessing the pool, move read index
	 * to signal that all allocated regions are now read and could be
	 * overwritten.
	 */
	if (likely(!other_read_in_progress)) {
   25d8e:	4566      	cmp	r6, ip
   25d90:	d10d      	bne.n	25dae <rng_pool_get+0x5e>
	__asm__ volatile(
   25d92:	f04f 0520 	mov.w	r5, #32
   25d96:	f3ef 8211 	mrs	r2, BASEPRI
   25d9a:	f385 8811 	msr	BASEPRI, r5
   25d9e:	f3bf 8f6f 	isb	sy
		key = irq_lock();
		rngp->first_read = rngp->first_alloc;
   25da2:	7805      	ldrb	r5, [r0, #0]
   25da4:	7045      	strb	r5, [r0, #1]
	__asm__ volatile(
   25da6:	f382 8811 	msr	BASEPRI, r2
   25daa:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}

	len = dst - buf;
   25dae:	1a64      	subs	r4, r4, r1
   25db0:	b2a2      	uxth	r2, r4
	available = available - len;
	if (available <= rngp->threshold) {
   25db2:	7901      	ldrb	r1, [r0, #4]
	available = available - len;
   25db4:	1a9c      	subs	r4, r3, r2
	if (available <= rngp->threshold) {
   25db6:	42a1      	cmp	r1, r4
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)rng_task);
}

NRF_STATIC_INLINE void nrf_rng_task_trigger(NRF_RNG_Type * p_reg, nrf_rng_task_t rng_task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   25db8:	bf22      	ittt	cs
   25dba:	4b07      	ldrcs	r3, [pc, #28]	; (25dd8 <rng_pool_get+0x88>)
   25dbc:	2101      	movcs	r1, #1
   25dbe:	6019      	strcs	r1, [r3, #0]
		nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);
	}

	return len;
}
   25dc0:	4610      	mov	r0, r2
   25dc2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		*dst++ = rngp->buffer[first];
   25dc4:	eb00 0e05 	add.w	lr, r0, r5
		first = (first + 1) & mask;
   25dc8:	3501      	adds	r5, #1
		*dst++ = rngp->buffer[first];
   25dca:	f89e e005 	ldrb.w	lr, [lr, #5]
   25dce:	f804 eb01 	strb.w	lr, [r4], #1
		first = (first + 1) & mask;
   25dd2:	403d      	ands	r5, r7
   25dd4:	e7d9      	b.n	25d8a <rng_pool_get+0x3a>
   25dd6:	bf00      	nop
   25dd8:	4000d000 	.word	0x4000d000

00025ddc <entropy_nrf5_get_entropy>:
		k_sem_give(&entropy_nrf5_data.sem_sync);
	}
}

static int entropy_nrf5_get_entropy(struct device *device, u8_t *buf, u16_t len)
{
   25ddc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return z_impl_k_sem_take(sem, timeout);
   25de0:	4d11      	ldr	r5, [pc, #68]	; (25e28 <entropy_nrf5_get_entropy+0x4c>)
   25de2:	460e      	mov	r6, r1
   25de4:	4614      	mov	r4, r2

	while (len) {
		u16_t bytes;

		k_sem_take(&entropy_nrf5_data.sem_lock, K_FOREVER);
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
   25de6:	f105 0845 	add.w	r8, r5, #69	; 0x45
   25dea:	f105 0918 	add.w	r9, r5, #24
	while (len) {
   25dee:	b914      	cbnz	r4, 25df6 <entropy_nrf5_get_entropy+0x1a>
		len -= bytes;
		buf += bytes;
	}

	return 0;
}
   25df0:	4620      	mov	r0, r4
   25df2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   25df6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   25dfa:	4628      	mov	r0, r5
   25dfc:	f001 f9b0 	bl	27160 <z_impl_k_sem_take>
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
   25e00:	4622      	mov	r2, r4
   25e02:	4631      	mov	r1, r6
   25e04:	4640      	mov	r0, r8
   25e06:	f7ff ffa3 	bl	25d50 <rng_pool_get>
   25e0a:	4607      	mov	r7, r0
	z_impl_k_sem_give(sem);
   25e0c:	4628      	mov	r0, r5
   25e0e:	f001 f97b 	bl	27108 <z_impl_k_sem_give>
		if (bytes == 0U) {
   25e12:	b92f      	cbnz	r7, 25e20 <entropy_nrf5_get_entropy+0x44>
	return z_impl_k_sem_take(sem, timeout);
   25e14:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   25e18:	4648      	mov	r0, r9
   25e1a:	f001 f9a1 	bl	27160 <z_impl_k_sem_take>
   25e1e:	e7e6      	b.n	25dee <entropy_nrf5_get_entropy+0x12>
		len -= bytes;
   25e20:	1be4      	subs	r4, r4, r7
   25e22:	b2a4      	uxth	r4, r4
		buf += bytes;
   25e24:	443e      	add	r6, r7
   25e26:	e7e2      	b.n	25dee <entropy_nrf5_get_entropy+0x12>
   25e28:	200039f4 	.word	0x200039f4

00025e2c <random_byte_get>:
{
   25e2c:	b082      	sub	sp, #8
	__asm__ volatile(
   25e2e:	f04f 0320 	mov.w	r3, #32
   25e32:	f3ef 8211 	mrs	r2, BASEPRI
   25e36:	f383 8811 	msr	BASEPRI, r3
   25e3a:	f3bf 8f6f 	isb	sy
#endif
}

NRF_STATIC_INLINE bool nrf_rng_event_check(NRF_RNG_Type const * p_reg, nrf_rng_event_t rng_event)
{
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   25e3e:	4b0a      	ldr	r3, [pc, #40]	; (25e68 <random_byte_get+0x3c>)
   25e40:	6819      	ldr	r1, [r3, #0]
	if (nrf_rng_event_check(NRF_RNG, NRF_RNG_EVENT_VALRDY)) {
   25e42:	b171      	cbz	r1, 25e62 <random_byte_get+0x36>
     p_reg->SHORTS &= ~mask;
}

NRF_STATIC_INLINE uint8_t nrf_rng_random_value_get(NRF_RNG_Type const * p_reg)
{
    return (uint8_t)(p_reg->VALUE & RNG_VALUE_VALUE_Msk);
   25e44:	4909      	ldr	r1, [pc, #36]	; (25e6c <random_byte_get+0x40>)
   25e46:	f8d1 0508 	ldr.w	r0, [r1, #1288]	; 0x508
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   25e4a:	2100      	movs	r1, #0
   25e4c:	6019      	str	r1, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   25e4e:	681b      	ldr	r3, [r3, #0]
   25e50:	9301      	str	r3, [sp, #4]
    (void)dummy;
   25e52:	9b01      	ldr	r3, [sp, #4]
		retval = nrf_rng_random_value_get(NRF_RNG);
   25e54:	b2c0      	uxtb	r0, r0
	__asm__ volatile(
   25e56:	f382 8811 	msr	BASEPRI, r2
   25e5a:	f3bf 8f6f 	isb	sy
}
   25e5e:	b002      	add	sp, #8
   25e60:	4770      	bx	lr
	int retval = -EAGAIN;
   25e62:	f06f 000a 	mvn.w	r0, #10
   25e66:	e7f6      	b.n	25e56 <random_byte_get+0x2a>
   25e68:	4000d100 	.word	0x4000d100
   25e6c:	4000d000 	.word	0x4000d000

00025e70 <entropy_nrf5_get_entropy_isr>:
	u16_t cnt = len;

	/* Check if this API is called on correct driver instance. */
	__ASSERT_NO_MSG(&entropy_nrf5_data == DEV_DATA(dev));

	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
   25e70:	07db      	lsls	r3, r3, #31
{
   25e72:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   25e76:	4688      	mov	r8, r1
   25e78:	4614      	mov	r4, r2
	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
   25e7a:	d405      	bmi.n	25e88 <entropy_nrf5_get_entropy_isr+0x18>
		return rng_pool_get((struct rng_pool *)(entropy_nrf5_data.isr),
   25e7c:	4820      	ldr	r0, [pc, #128]	; (25f00 <entropy_nrf5_get_entropy_isr+0x90>)
   25e7e:	f7ff ff67 	bl	25d50 <rng_pool_get>
			irq_enable(RNG_IRQn);
		}
	}

	return cnt;
}
   25e82:	b002      	add	sp, #8
   25e84:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (len) {
   25e88:	2a00      	cmp	r2, #0
   25e8a:	d032      	beq.n	25ef2 <entropy_nrf5_get_entropy_isr+0x82>
	__asm__ volatile(
   25e8c:	f04f 0320 	mov.w	r3, #32
   25e90:	f3ef 8511 	mrs	r5, BASEPRI
   25e94:	f383 8811 	msr	BASEPRI, r3
   25e98:	f3bf 8f6f 	isb	sy
		irq_enabled = irq_is_enabled(RNG_IRQn);
   25e9c:	200d      	movs	r0, #13
   25e9e:	f7ed fe33 	bl	13b08 <arch_irq_is_enabled>
   25ea2:	4607      	mov	r7, r0
		irq_disable(RNG_IRQn);
   25ea4:	200d      	movs	r0, #13
   25ea6:	f7ed fe1b 	bl	13ae0 <arch_irq_disable>
	__asm__ volatile(
   25eaa:	f385 8811 	msr	BASEPRI, r5
   25eae:	f3bf 8f6f 	isb	sy
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   25eb2:	4e14      	ldr	r6, [pc, #80]	; (25f04 <entropy_nrf5_get_entropy_isr+0x94>)
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   25eb4:	f8df 9054 	ldr.w	r9, [pc, #84]	; 25f0c <entropy_nrf5_get_entropy_isr+0x9c>
   25eb8:	2200      	movs	r2, #0
   25eba:	6032      	str	r2, [r6, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   25ebc:	6832      	ldr	r2, [r6, #0]
   25ebe:	9201      	str	r2, [sp, #4]
    (void)dummy;
   25ec0:	9a01      	ldr	r2, [sp, #4]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   25ec2:	4a11      	ldr	r2, [pc, #68]	; (25f08 <entropy_nrf5_get_entropy_isr+0x98>)
   25ec4:	2101      	movs	r1, #1
   25ec6:	6011      	str	r1, [r2, #0]
   25ec8:	4625      	mov	r5, r4
   25eca:	f44f 5a00 	mov.w	sl, #8192	; 0x2000
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   25ece:	6833      	ldr	r3, [r6, #0]
			while (!nrf_rng_event_check(NRF_RNG,
   25ed0:	b18b      	cbz	r3, 25ef6 <entropy_nrf5_get_entropy_isr+0x86>
			byte = random_byte_get();
   25ed2:	f7ff ffab 	bl	25e2c <random_byte_get>
			if (byte < 0) {
   25ed6:	2800      	cmp	r0, #0
   25ed8:	f8c9 a180 	str.w	sl, [r9, #384]	; 0x180
   25edc:	dbf7      	blt.n	25ece <entropy_nrf5_get_entropy_isr+0x5e>
   25ede:	3d01      	subs	r5, #1
   25ee0:	b2ad      	uxth	r5, r5
			buf[--len] = byte;
   25ee2:	f808 0005 	strb.w	r0, [r8, r5]
		} while (len);
   25ee6:	2d00      	cmp	r5, #0
   25ee8:	d1f1      	bne.n	25ece <entropy_nrf5_get_entropy_isr+0x5e>
		if (irq_enabled) {
   25eea:	b117      	cbz	r7, 25ef2 <entropy_nrf5_get_entropy_isr+0x82>
			irq_enable(RNG_IRQn);
   25eec:	200d      	movs	r0, #13
   25eee:	f7ed fde7 	bl	13ac0 <arch_irq_enable>
	return cnt;
   25ef2:	4620      	mov	r0, r4
   25ef4:	e7c5      	b.n	25e82 <entropy_nrf5_get_entropy_isr+0x12>
				__WFE();
   25ef6:	bf20      	wfe
				__SEV();
   25ef8:	bf40      	sev
				__WFE();
   25efa:	bf20      	wfe
   25efc:	e7e7      	b.n	25ece <entropy_nrf5_get_entropy_isr+0x5e>
   25efe:	bf00      	nop
   25f00:	20003a24 	.word	0x20003a24
   25f04:	4000d100 	.word	0x4000d100
   25f08:	4000d000 	.word	0x4000d000
   25f0c:	e000e100 	.word	0xe000e100

00025f10 <entropy_nrf5_init>:
		    entropy_nrf5_init, &entropy_nrf5_data, NULL,
		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &entropy_nrf5_api_funcs);

static int entropy_nrf5_init(struct device *device)
{
   25f10:	b537      	push	{r0, r1, r2, r4, r5, lr}
	z_impl_k_sem_init(sem, initial_count, limit);
   25f12:	4c1b      	ldr	r4, [pc, #108]	; (25f80 <entropy_nrf5_init+0x70>)
   25f14:	2201      	movs	r2, #1
   25f16:	4611      	mov	r1, r2
   25f18:	4620      	mov	r0, r4
   25f1a:	f007 fa74 	bl	2d406 <z_impl_k_sem_init>
   25f1e:	2201      	movs	r2, #1
   25f20:	f104 0018 	add.w	r0, r4, #24
   25f24:	2100      	movs	r1, #0
   25f26:	f007 fa6e 	bl	2d406 <z_impl_k_sem_init>
	rngp->mask	  = size - 1;
   25f2a:	f240 4307 	movw	r3, #1031	; 0x407
   25f2e:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
	rngp->first_alloc = 0U;
   25f32:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
   25f36:	6323      	str	r3, [r4, #48]	; 0x30
	rngp->threshold	  = threshold;
   25f38:	230c      	movs	r3, #12
   25f3a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
	rngp->first_alloc = 0U;
   25f3e:	2500      	movs	r5, #0
}

NRF_STATIC_INLINE void nrf_rng_error_correction_enable(NRF_RNG_Type * p_reg)
{
    p_reg->CONFIG |= RNG_CONFIG_DERCEN_Msk;
   25f40:	4b10      	ldr	r3, [pc, #64]	; (25f84 <entropy_nrf5_init+0x74>)
   25f42:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
	rngp->first_read  = 0U;
   25f46:	f8a4 5046 	strh.w	r5, [r4, #70]	; 0x46
   25f4a:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
   25f4e:	f042 0201 	orr.w	r2, r2, #1
   25f52:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
   25f56:	4a0c      	ldr	r2, [pc, #48]	; (25f88 <entropy_nrf5_init+0x78>)
   25f58:	6015      	str	r5, [r2, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
   25f5a:	6812      	ldr	r2, [r2, #0]
   25f5c:	9201      	str	r2, [sp, #4]
    (void)dummy;
   25f5e:	9a01      	ldr	r2, [sp, #4]
    p_reg->INTENSET = mask;
   25f60:	2201      	movs	r2, #1
   25f62:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

	nrf_rng_event_clear(NRF_RNG, NRF_RNG_EVENT_VALRDY);
	nrf_rng_int_enable(NRF_RNG, NRF_RNG_INT_VALRDY_MASK);
	nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);

	IRQ_CONNECT(RNG_IRQn, CONFIG_ENTROPY_NRF5_PRI, isr,
   25f66:	2105      	movs	r1, #5
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
   25f68:	601a      	str	r2, [r3, #0]
   25f6a:	200d      	movs	r0, #13
   25f6c:	462a      	mov	r2, r5
   25f6e:	f7ed fdd9 	bl	13b24 <z_arm_irq_priority_set>
		    &entropy_nrf5_data, 0);
	irq_enable(RNG_IRQn);
   25f72:	200d      	movs	r0, #13
   25f74:	f7ed fda4 	bl	13ac0 <arch_irq_enable>

	return 0;
}
   25f78:	4628      	mov	r0, r5
   25f7a:	b003      	add	sp, #12
   25f7c:	bd30      	pop	{r4, r5, pc}
   25f7e:	bf00      	nop
   25f80:	200039f4 	.word	0x200039f4
   25f84:	4000d000 	.word	0x4000d000
   25f88:	4000d100 	.word	0x4000d100

00025f8c <isr>:
{
   25f8c:	b510      	push	{r4, lr}
	byte = random_byte_get();
   25f8e:	f7ff ff4d 	bl	25e2c <random_byte_get>
	if (byte < 0) {
   25f92:	2800      	cmp	r0, #0
   25f94:	db20      	blt.n	25fd8 <isr+0x4c>
	u8_t last  = rngp->last;
   25f96:	4b17      	ldr	r3, [pc, #92]	; (25ff4 <isr+0x68>)
   25f98:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
	if (((last - first) & mask) == mask) {
   25f9c:	f893 1031 	ldrb.w	r1, [r3, #49]	; 0x31
	u8_t mask  = rngp->mask;
   25fa0:	f893 4033 	ldrb.w	r4, [r3, #51]	; 0x33
	if (((last - first) & mask) == mask) {
   25fa4:	1a51      	subs	r1, r2, r1
   25fa6:	ea34 0101 	bics.w	r1, r4, r1
	ret = rng_pool_put((struct rng_pool *)(entropy_nrf5_data.isr), byte);
   25faa:	b2c0      	uxtb	r0, r0
	if (((last - first) & mask) == mask) {
   25fac:	d10d      	bne.n	25fca <isr+0x3e>
	u8_t last  = rngp->last;
   25fae:	f893 2047 	ldrb.w	r2, [r3, #71]	; 0x47
	if (((last - first) & mask) == mask) {
   25fb2:	f893 1046 	ldrb.w	r1, [r3, #70]	; 0x46
	u8_t mask  = rngp->mask;
   25fb6:	f893 4048 	ldrb.w	r4, [r3, #72]	; 0x48
	if (((last - first) & mask) == mask) {
   25fba:	1a51      	subs	r1, r2, r1
   25fbc:	ea34 0101 	bics.w	r1, r4, r1
   25fc0:	d10b      	bne.n	25fda <isr+0x4e>
   25fc2:	4b0d      	ldr	r3, [pc, #52]	; (25ff8 <isr+0x6c>)
   25fc4:	2201      	movs	r2, #1
   25fc6:	601a      	str	r2, [r3, #0]
   25fc8:	e00e      	b.n	25fe8 <isr+0x5c>
	rngp->buffer[last] = byte;
   25fca:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
   25fcc:	3201      	adds	r2, #1
   25fce:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
   25fd0:	f881 0035 	strb.w	r0, [r1, #53]	; 0x35
	rngp->last = (last + 1) & mask;
   25fd4:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
}
   25fd8:	bd10      	pop	{r4, pc}
	rngp->buffer[last] = byte;
   25fda:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
   25fdc:	3201      	adds	r2, #1
   25fde:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
   25fe0:	f881 004a 	strb.w	r0, [r1, #74]	; 0x4a
	rngp->last = (last + 1) & mask;
   25fe4:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
	z_impl_k_sem_give(sem);
   25fe8:	4804      	ldr	r0, [pc, #16]	; (25ffc <isr+0x70>)
}
   25fea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   25fee:	f001 b88b 	b.w	27108 <z_impl_k_sem_give>
   25ff2:	bf00      	nop
   25ff4:	200039f4 	.word	0x200039f4
   25ff8:	4000d004 	.word	0x4000d004
   25ffc:	20003a0c 	.word	0x20003a0c

00026000 <errata_103>:
    return false;
}

static bool errata_98(void)
{
    uint32_t var1 = *(uint32_t *)0x10000130ul;
   26000:	4b06      	ldr	r3, [pc, #24]	; (2601c <errata_103+0x1c>)
    uint32_t var2 = *(uint32_t *)0x10000134ul;

    switch(var1)
   26002:	681b      	ldr	r3, [r3, #0]
   26004:	2b08      	cmp	r3, #8
   26006:	d106      	bne.n	26016 <errata_103+0x16>
    uint32_t var2 = *(uint32_t *)0x10000134ul;
   26008:	4b05      	ldr	r3, [pc, #20]	; (26020 <errata_103+0x20>)
   2600a:	681b      	ldr	r3, [r3, #0]
    {
        case 0x08:
            switch(var2)
   2600c:	2b03      	cmp	r3, #3
   2600e:	d802      	bhi.n	26016 <errata_103+0x16>
   26010:	4a04      	ldr	r2, [pc, #16]	; (26024 <errata_103+0x24>)
   26012:	5cd0      	ldrb	r0, [r2, r3]
   26014:	4770      	bx	lr
            }
        break;

    }

    return false;
   26016:	2000      	movs	r0, #0
}
   26018:	4770      	bx	lr
   2601a:	bf00      	nop
   2601c:	10000130 	.word	0x10000130
   26020:	10000134 	.word	0x10000134
   26024:	000323e4 	.word	0x000323e4

00026028 <SystemInit>:
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
}

void SystemInit(void)
{
   26028:	b508      	push	{r3, lr}
    uint32_t var1 = *(uint32_t *)0x10000130ul;
   2602a:	4b61      	ldr	r3, [pc, #388]	; (261b0 <SystemInit+0x188>)
    switch(var1)
   2602c:	681b      	ldr	r3, [r3, #0]
   2602e:	2b08      	cmp	r3, #8
   26030:	d150      	bne.n	260d4 <SystemInit+0xac>
    #endif
    
    /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_36()){
        NRF_CLOCK->EVENTS_DONE = 0;
   26032:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   26036:	2200      	movs	r2, #0
   26038:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
        NRF_CLOCK->EVENTS_CTTO = 0;
   2603c:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
        NRF_CLOCK->CTIV = 0;
   26040:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    }
    
    /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_66()){
        NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
   26044:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   26048:	f503 4340 	add.w	r3, r3, #49152	; 0xc000
   2604c:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
   26050:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
        NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
   26054:	f8d2 1408 	ldr.w	r1, [r2, #1032]	; 0x408
   26058:	f8c3 1524 	str.w	r1, [r3, #1316]	; 0x524
        NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
   2605c:	f8d2 140c 	ldr.w	r1, [r2, #1036]	; 0x40c
   26060:	f8c3 1528 	str.w	r1, [r3, #1320]	; 0x528
        NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
   26064:	f8d2 1410 	ldr.w	r1, [r2, #1040]	; 0x410
   26068:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
        NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
   2606c:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
   26070:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
        NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
   26074:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
   26078:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
        NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
   2607c:	f8d2 141c 	ldr.w	r1, [r2, #1052]	; 0x41c
   26080:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
        NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
   26084:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
   26088:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
        NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
   2608c:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
   26090:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
        NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
   26094:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
   26098:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
        NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
   2609c:	f8d2 142c 	ldr.w	r1, [r2, #1068]	; 0x42c
   260a0:	f8c3 1550 	str.w	r1, [r3, #1360]	; 0x550
        NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
   260a4:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
   260a8:	f8c3 1554 	str.w	r1, [r3, #1364]	; 0x554
        NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
   260ac:	f8d2 1434 	ldr.w	r1, [r2, #1076]	; 0x434
   260b0:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
        NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
   260b4:	f8d2 1438 	ldr.w	r1, [r2, #1080]	; 0x438
   260b8:	f8c3 1564 	str.w	r1, [r3, #1380]	; 0x564
        NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
   260bc:	f8d2 143c 	ldr.w	r1, [r2, #1084]	; 0x43c
   260c0:	f8c3 1568 	str.w	r1, [r3, #1384]	; 0x568
        NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
   260c4:	f8d2 1440 	ldr.w	r1, [r2, #1088]	; 0x440
   260c8:	f8c3 156c 	str.w	r1, [r3, #1388]	; 0x56c
        NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
   260cc:	f8d2 2444 	ldr.w	r2, [r2, #1092]	; 0x444
   260d0:	f8c3 2570 	str.w	r2, [r3, #1392]	; 0x570
    }
    
    /* Workaround for Errata 98 "NFCT: Not able to communicate with the peer" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_98()){
   260d4:	f7ff ff94 	bl	26000 <errata_103>
   260d8:	b110      	cbz	r0, 260e0 <SystemInit+0xb8>
        *(volatile uint32_t *)0x4000568Cul = 0x00038148ul;
   260da:	4b36      	ldr	r3, [pc, #216]	; (261b4 <SystemInit+0x18c>)
   260dc:	4a36      	ldr	r2, [pc, #216]	; (261b8 <SystemInit+0x190>)
   260de:	601a      	str	r2, [r3, #0]
    }
    
    /* Workaround for Errata 103 "CCM: Wrong reset value of CCM MAXPACKETSIZE" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_103()){
   260e0:	f7ff ff8e 	bl	26000 <errata_103>
   260e4:	b118      	cbz	r0, 260ee <SystemInit+0xc6>
        NRF_CCM->MAXPACKETSIZE = 0xFBul;
   260e6:	4b35      	ldr	r3, [pc, #212]	; (261bc <SystemInit+0x194>)
   260e8:	22fb      	movs	r2, #251	; 0xfb
   260ea:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    }
    
    /* Workaround for Errata 115 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_115()){
   260ee:	f7ff ff87 	bl	26000 <errata_103>
   260f2:	b148      	cbz	r0, 26108 <SystemInit+0xe0>
        *(volatile uint32_t *)0x40000EE4ul = (*(volatile uint32_t *)0x40000EE4ul & 0xFFFFFFF0ul) | (*(uint32_t *)0x10000258ul & 0x0000000Ful);
   260f4:	4932      	ldr	r1, [pc, #200]	; (261c0 <SystemInit+0x198>)
   260f6:	4b33      	ldr	r3, [pc, #204]	; (261c4 <SystemInit+0x19c>)
   260f8:	680a      	ldr	r2, [r1, #0]
   260fa:	681b      	ldr	r3, [r3, #0]
   260fc:	f022 020f 	bic.w	r2, r2, #15
   26100:	f003 030f 	and.w	r3, r3, #15
   26104:	4313      	orrs	r3, r2
   26106:	600b      	str	r3, [r1, #0]
    }
    
    /* Workaround for Errata 120 "QSPI: Data read or written is corrupted" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_120()){
   26108:	f7ff ff7a 	bl	26000 <errata_103>
   2610c:	b118      	cbz	r0, 26116 <SystemInit+0xee>
        *(volatile uint32_t *)0x40029640ul = 0x200ul;
   2610e:	4b2e      	ldr	r3, [pc, #184]	; (261c8 <SystemInit+0x1a0>)
   26110:	f44f 7200 	mov.w	r2, #512	; 0x200
   26114:	601a      	str	r2, [r3, #0]
    uint32_t var1 = *(uint32_t *)0x10000130ul;
   26116:	4b26      	ldr	r3, [pc, #152]	; (261b0 <SystemInit+0x188>)
    switch(var1)
   26118:	681b      	ldr	r3, [r3, #0]
   2611a:	2b08      	cmp	r3, #8
   2611c:	d109      	bne.n	26132 <SystemInit+0x10a>
    }
    
    /* Workaround for Errata 136 "System: Bits in RESETREAS are set when they should not be" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (errata_136()){
        if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
   2611e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   26122:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
   26126:	07d2      	lsls	r2, r2, #31
            NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
   26128:	bf44      	itt	mi
   2612a:	f06f 0201 	mvnmi.w	r2, #1
   2612e:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400

    /* Configure GPIO pads as pPin Reset pin if Pin Reset capabilities desired. If CONFIG_GPIO_AS_PINRESET is not
      defined, pin reset will not be available. One GPIO (see Product Specification to see which one) will then be
      reserved for PinReset and not available as normal GPIO. */
    #if defined (CONFIG_GPIO_AS_PINRESET)
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
   26132:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
   26136:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   2613a:	2a00      	cmp	r2, #0
   2613c:	db03      	blt.n	26146 <SystemInit+0x11e>
            ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
   2613e:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
   26142:	2b00      	cmp	r3, #0
   26144:	da2f      	bge.n	261a6 <SystemInit+0x17e>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
   26146:	4b21      	ldr	r3, [pc, #132]	; (261cc <SystemInit+0x1a4>)
   26148:	2201      	movs	r2, #1
   2614a:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   2614e:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
   26152:	2a00      	cmp	r2, #0
   26154:	d0fb      	beq.n	2614e <SystemInit+0x126>
            NRF_UICR->PSELRESET[0] = 18;
   26156:	f04f 2210 	mov.w	r2, #268439552	; 0x10001000
   2615a:	2112      	movs	r1, #18
   2615c:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   26160:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
   26164:	2a00      	cmp	r2, #0
   26166:	d0fb      	beq.n	26160 <SystemInit+0x138>
            NRF_UICR->PSELRESET[1] = 18;
   26168:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
   2616c:	2212      	movs	r2, #18
   2616e:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   26172:	4b16      	ldr	r3, [pc, #88]	; (261cc <SystemInit+0x1a4>)
   26174:	461a      	mov	r2, r3
   26176:	f8d3 1400 	ldr.w	r1, [r3, #1024]	; 0x400
   2617a:	2900      	cmp	r1, #0
   2617c:	d0fb      	beq.n	26176 <SystemInit+0x14e>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
   2617e:	2100      	movs	r1, #0
   26180:	f8c3 1504 	str.w	r1, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
   26184:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
   26188:	2b00      	cmp	r3, #0
   2618a:	d0fb      	beq.n	26184 <SystemInit+0x15c>
   2618c:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   26190:	490f      	ldr	r1, [pc, #60]	; (261d0 <SystemInit+0x1a8>)
   26192:	4b10      	ldr	r3, [pc, #64]	; (261d4 <SystemInit+0x1ac>)
   26194:	68ca      	ldr	r2, [r1, #12]
   26196:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   2619a:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   2619c:	60cb      	str	r3, [r1, #12]
   2619e:	f3bf 8f4f 	dsb	sy
    __NOP();
   261a2:	bf00      	nop
   261a4:	e7fd      	b.n	261a2 <SystemInit+0x17a>
    SystemCoreClock = __SYSTEM_CLOCK_64M;
   261a6:	4b0c      	ldr	r3, [pc, #48]	; (261d8 <SystemInit+0x1b0>)
   261a8:	4a0c      	ldr	r2, [pc, #48]	; (261dc <SystemInit+0x1b4>)
   261aa:	601a      	str	r2, [r3, #0]
            NVIC_SystemReset();
        }
    #endif

    SystemCoreClockUpdate();
}
   261ac:	bd08      	pop	{r3, pc}
   261ae:	bf00      	nop
   261b0:	10000130 	.word	0x10000130
   261b4:	4000568c 	.word	0x4000568c
   261b8:	00038148 	.word	0x00038148
   261bc:	4000f000 	.word	0x4000f000
   261c0:	40000ee4 	.word	0x40000ee4
   261c4:	10000258 	.word	0x10000258
   261c8:	40029640 	.word	0x40029640
   261cc:	4001e000 	.word	0x4001e000
   261d0:	e000ed00 	.word	0xe000ed00
   261d4:	05fa0004 	.word	0x05fa0004
   261d8:	2000fdf8 	.word	0x2000fdf8
   261dc:	03d09000 	.word	0x03d09000

000261e0 <nvmc_word_write>:
   261e0:	4a04      	ldr	r2, [pc, #16]	; (261f4 <nvmc_word_write+0x14>)
   261e2:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
{
#if defined(NRF9160_XXAA)
    while (!nrf_nvmc_write_ready_check(NRF_NVMC))
    {}
#else
    while (!nrf_nvmc_ready_check(NRF_NVMC))
   261e6:	07db      	lsls	r3, r3, #31
   261e8:	d5fb      	bpl.n	261e2 <nvmc_word_write+0x2>
    {}
#endif

    *(volatile uint32_t *)addr = value;
   261ea:	6001      	str	r1, [r0, #0]
  __ASM volatile ("dmb 0xF":::"memory");
   261ec:	f3bf 8f5f 	dmb	sy
    __DMB();
}
   261f0:	4770      	bx	lr
   261f2:	bf00      	nop
   261f4:	4001e000 	.word	0x4001e000

000261f8 <nrfx_nvmc_page_erase>:
NRF_STATIC_INLINE uint32_t nrf_ficr_codepagesize_get(NRF_FICR_Type const * p_reg)
{
#if defined(FICR_INFO_CODEPAGESIZE_CODEPAGESIZE_Msk)
    return p_reg->INFO.CODEPAGESIZE;
#else
    return p_reg->CODEPAGESIZE;
   261f8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   261fc:	691a      	ldr	r2, [r3, #16]
    return !(addr % flash_page_size_get());
   261fe:	fbb0 f3f2 	udiv	r3, r0, r2
   26202:	fb02 0313 	mls	r3, r2, r3, r0

nrfx_err_t nrfx_nvmc_page_erase(uint32_t addr)
{
    NRFX_ASSERT(addr < flash_total_size_get());

    if (!is_page_aligned_check(addr))
   26206:	b973      	cbnz	r3, 26226 <nrfx_nvmc_page_erase+0x2e>
#endif

NRF_STATIC_INLINE void nrf_nvmc_mode_set(NRF_NVMC_Type * p_reg,
                                         nrf_nvmc_mode_t mode)
{
    p_reg->CONFIG = (uint32_t)mode;
   26208:	4b08      	ldr	r3, [pc, #32]	; (2622c <nrfx_nvmc_page_erase+0x34>)
   2620a:	2202      	movs	r2, #2
   2620c:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    else
    {
        p_reg->ERASEPCR1 = page_addr;
    }
#elif defined(NRF52_SERIES)
    p_reg->ERASEPAGE = page_addr;
   26210:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
   26214:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
        return NRFX_ERROR_INVALID_ADDR;
    }

    nvmc_erase_mode_set();
    nrf_nvmc_page_erase_start(NRF_NVMC, addr);
    while (!nrf_nvmc_ready_check(NRF_NVMC))
   26218:	07d2      	lsls	r2, r2, #31
   2621a:	d5fb      	bpl.n	26214 <nrfx_nvmc_page_erase+0x1c>
    p_reg->CONFIG = (uint32_t)mode;
   2621c:	2200      	movs	r2, #0
   2621e:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    {}
    nvmc_readonly_mode_set();

    return NRFX_SUCCESS;
   26222:	4803      	ldr	r0, [pc, #12]	; (26230 <nrfx_nvmc_page_erase+0x38>)
   26224:	4770      	bx	lr
        return NRFX_ERROR_INVALID_ADDR;
   26226:	4803      	ldr	r0, [pc, #12]	; (26234 <nrfx_nvmc_page_erase+0x3c>)
}
   26228:	4770      	bx	lr
   2622a:	bf00      	nop
   2622c:	4001e000 	.word	0x4001e000
   26230:	0bad0000 	.word	0x0bad0000
   26234:	0bad000a 	.word	0x0bad000a

00026238 <nrfx_nvmc_word_write>:

    nrfx_nvmc_word_write(aligned_addr, partial_word_create(addr, &value, 1));
}

void nrfx_nvmc_word_write(uint32_t addr, uint32_t value)
{
   26238:	b510      	push	{r4, lr}
   2623a:	4c05      	ldr	r4, [pc, #20]	; (26250 <nrfx_nvmc_word_write+0x18>)
   2623c:	2301      	movs	r3, #1
   2623e:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
    NRFX_ASSERT(addr < flash_total_size_get());
    NRFX_ASSERT(nrfx_is_word_aligned((void const *)addr));

    nvmc_write_mode_set();

    nvmc_word_write(addr, value);
   26242:	f7ff ffcd 	bl	261e0 <nvmc_word_write>
   26246:	2300      	movs	r3, #0
   26248:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504

    nvmc_readonly_mode_set();
}
   2624c:	bd10      	pop	{r4, pc}
   2624e:	bf00      	nop
   26250:	4001e000 	.word	0x4001e000

00026254 <nrfx_nvmc_bytes_write>:

void nrfx_nvmc_bytes_write(uint32_t addr, void const * src, uint32_t num_bytes)
{
   26254:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   26258:	4b1e      	ldr	r3, [pc, #120]	; (262d4 <nrfx_nvmc_bytes_write+0x80>)
   2625a:	4615      	mov	r5, r2
   2625c:	2201      	movs	r2, #1
   2625e:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    nvmc_write_mode_set();

    uint8_t const * bytes_src = (uint8_t const *)src;

    uint32_t unaligned_bytes = addr % NVMC_BYTES_IN_WORD;
    if (unaligned_bytes != 0)
   26262:	f010 0303 	ands.w	r3, r0, #3
{
   26266:	4604      	mov	r4, r0
   26268:	460e      	mov	r6, r1
    if (unaligned_bytes != 0)
   2626a:	d010      	beq.n	2628e <nrfx_nvmc_bytes_write+0x3a>
    {
        uint32_t leading_bytes = NVMC_BYTES_IN_WORD - unaligned_bytes;
   2626c:	f1c3 0704 	rsb	r7, r3, #4
        if (leading_bytes > num_bytes)
   26270:	42af      	cmp	r7, r5
   26272:	bf28      	it	cs
   26274:	462f      	movcs	r7, r5
        {
            leading_bytes = num_bytes;
        }

        nvmc_word_write(addr - unaligned_bytes,
   26276:	463a      	mov	r2, r7
   26278:	eba0 0803 	sub.w	r8, r0, r3
   2627c:	f006 fe63 	bl	2cf46 <partial_word_create>
   26280:	4601      	mov	r1, r0
   26282:	4640      	mov	r0, r8
   26284:	f7ff ffac 	bl	261e0 <nvmc_word_write>
                        partial_word_create(addr, bytes_src, leading_bytes));
        num_bytes -= leading_bytes;
   26288:	1bed      	subs	r5, r5, r7
        addr      += leading_bytes;
   2628a:	443c      	add	r4, r7
        bytes_src += leading_bytes;
   2628c:	443e      	add	r6, r7
    for (uint32_t i = 0; i < num_words; i++)
   2628e:	f025 0803 	bic.w	r8, r5, #3
   26292:	44b0      	add	r8, r6
        }
    }
    else
#endif
    {
        uint32_t word_count = num_bytes / NVMC_BYTES_IN_WORD;
   26294:	4637      	mov	r7, r6
   26296:	eba4 0906 	sub.w	r9, r4, r6
    for (uint32_t i = 0; i < num_words; i++)
   2629a:	45b8      	cmp	r8, r7
   2629c:	d113      	bne.n	262c6 <nrfx_nvmc_bytes_write+0x72>
        addr += word_count * NVMC_BYTES_IN_WORD;
        bytes_src += word_count * NVMC_BYTES_IN_WORD;
    }

    uint32_t trailing_bytes = num_bytes % NVMC_BYTES_IN_WORD;
    if (trailing_bytes != 0)
   2629e:	f015 0203 	ands.w	r2, r5, #3
   262a2:	d00a      	beq.n	262ba <nrfx_nvmc_bytes_write+0x66>
        addr += word_count * NVMC_BYTES_IN_WORD;
   262a4:	f025 0103 	bic.w	r1, r5, #3
   262a8:	440c      	add	r4, r1
    {
        nvmc_word_write(addr, partial_word_create(addr, bytes_src, trailing_bytes));
   262aa:	4620      	mov	r0, r4
   262ac:	4431      	add	r1, r6
   262ae:	f006 fe4a 	bl	2cf46 <partial_word_create>
   262b2:	4601      	mov	r1, r0
   262b4:	4620      	mov	r0, r4
   262b6:	f7ff ff93 	bl	261e0 <nvmc_word_write>
   262ba:	4b06      	ldr	r3, [pc, #24]	; (262d4 <nrfx_nvmc_bytes_write+0x80>)
   262bc:	2200      	movs	r2, #0
   262be:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    }

    nvmc_readonly_mode_set();
}
   262c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        nvmc_word_write(addr + (NVMC_BYTES_IN_WORD * i), ((uint32_t const *)src)[i]);
   262c6:	eb09 0007 	add.w	r0, r9, r7
   262ca:	f857 1b04 	ldr.w	r1, [r7], #4
   262ce:	f7ff ff87 	bl	261e0 <nvmc_word_write>
   262d2:	e7e2      	b.n	2629a <nrfx_nvmc_bytes_write+0x46>
   262d4:	4001e000 	.word	0x4001e000

000262d8 <z_sys_device_do_config_level>:
		__device_APPLICATION_start,
		/* End marker */
		__device_init_end,
	};

	for (info = config_levels[level]; info < config_levels[level+1];
   262d8:	4b09      	ldr	r3, [pc, #36]	; (26300 <z_sys_device_do_config_level+0x28>)
{
   262da:	b570      	push	{r4, r5, r6, lr}
	for (info = config_levels[level]; info < config_levels[level+1];
   262dc:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   262e0:	3001      	adds	r0, #1
		retval = device_conf->init(info);
		if (retval != 0) {
			/* Initialization failed. Clear the API struct so that
			 * device_get_binding() will not succeed for it.
			 */
			info->driver_api = NULL;
   262e2:	2600      	movs	r6, #0
	for (info = config_levels[level]; info < config_levels[level+1];
   262e4:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
   262e8:	42a5      	cmp	r5, r4
   262ea:	d800      	bhi.n	262ee <z_sys_device_do_config_level+0x16>
		} else {
			z_object_init(info);
		}
	}
}
   262ec:	bd70      	pop	{r4, r5, r6, pc}
		retval = device_conf->init(info);
   262ee:	6823      	ldr	r3, [r4, #0]
   262f0:	4620      	mov	r0, r4
   262f2:	685b      	ldr	r3, [r3, #4]
   262f4:	4798      	blx	r3
		if (retval != 0) {
   262f6:	b100      	cbz	r0, 262fa <z_sys_device_do_config_level+0x22>
			info->driver_api = NULL;
   262f8:	6066      	str	r6, [r4, #4]
								info++) {
   262fa:	340c      	adds	r4, #12
   262fc:	e7f4      	b.n	262e8 <z_sys_device_do_config_level+0x10>
   262fe:	bf00      	nop
   26300:	0002e81c 	.word	0x0002e81c

00026304 <z_impl_device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed.  Reserve string comparisons for a fallback.
	 */
	for (info = __device_init_start; info != __device_init_end; info++) {
   26304:	4b10      	ldr	r3, [pc, #64]	; (26348 <z_impl_device_get_binding+0x44>)
{
   26306:	b570      	push	{r4, r5, r6, lr}
	for (info = __device_init_start; info != __device_init_end; info++) {
   26308:	4c10      	ldr	r4, [pc, #64]	; (2634c <z_impl_device_get_binding+0x48>)
{
   2630a:	4605      	mov	r5, r0
   2630c:	461e      	mov	r6, r3
	for (info = __device_init_start; info != __device_init_end; info++) {
   2630e:	429c      	cmp	r4, r3
   26310:	d104      	bne.n	2631c <z_impl_device_get_binding+0x18>
		    (info->config->name == name)) {
			return info;
		}
	}

	for (info = __device_init_start; info != __device_init_end; info++) {
   26312:	4c0e      	ldr	r4, [pc, #56]	; (2634c <z_impl_device_get_binding+0x48>)
   26314:	42b4      	cmp	r4, r6
   26316:	d109      	bne.n	2632c <z_impl_device_get_binding+0x28>
		if (strcmp(name, info->config->name) == 0) {
			return info;
		}
	}

	return NULL;
   26318:	2400      	movs	r4, #0
   2631a:	e012      	b.n	26342 <z_impl_device_get_binding+0x3e>
		if ((info->driver_api != NULL) &&
   2631c:	6862      	ldr	r2, [r4, #4]
   2631e:	b11a      	cbz	r2, 26328 <z_impl_device_get_binding+0x24>
		    (info->config->name == name)) {
   26320:	6822      	ldr	r2, [r4, #0]
		if ((info->driver_api != NULL) &&
   26322:	6812      	ldr	r2, [r2, #0]
   26324:	42aa      	cmp	r2, r5
   26326:	d00c      	beq.n	26342 <z_impl_device_get_binding+0x3e>
	for (info = __device_init_start; info != __device_init_end; info++) {
   26328:	340c      	adds	r4, #12
   2632a:	e7f0      	b.n	2630e <z_impl_device_get_binding+0xa>
		if (info->driver_api == NULL) {
   2632c:	6863      	ldr	r3, [r4, #4]
   2632e:	b90b      	cbnz	r3, 26334 <z_impl_device_get_binding+0x30>
	for (info = __device_init_start; info != __device_init_end; info++) {
   26330:	340c      	adds	r4, #12
   26332:	e7ef      	b.n	26314 <z_impl_device_get_binding+0x10>
		if (strcmp(name, info->config->name) == 0) {
   26334:	6823      	ldr	r3, [r4, #0]
   26336:	4628      	mov	r0, r5
   26338:	6819      	ldr	r1, [r3, #0]
   2633a:	f004 f846 	bl	2a3ca <strcmp>
   2633e:	2800      	cmp	r0, #0
   26340:	d1f6      	bne.n	26330 <z_impl_device_get_binding+0x2c>
}
   26342:	4620      	mov	r0, r4
   26344:	bd70      	pop	{r4, r5, r6, pc}
   26346:	bf00      	nop
   26348:	2000ff98 	.word	0x2000ff98
   2634c:	2000fecc 	.word	0x2000fecc

00026350 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   26350:	4b01      	ldr	r3, [pc, #4]	; (26358 <z_impl_z_errno+0x8>)
   26352:	6898      	ldr	r0, [r3, #8]
}
   26354:	3054      	adds	r0, #84	; 0x54
   26356:	4770      	bx	lr
   26358:	20003b20 	.word	0x20003b20

0002635c <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
   2635c:	b510      	push	{r4, lr}
   2635e:	4604      	mov	r4, r0
	z_impl_log_panic();
   26360:	f7eb f86a 	bl	11438 <z_impl_log_panic>
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
   26364:	4b0a      	ldr	r3, [pc, #40]	; (26390 <k_sys_fatal_error_handler+0x34>)
   26366:	681b      	ldr	r3, [r3, #0]
   26368:	075b      	lsls	r3, r3, #29
   2636a:	d00d      	beq.n	26388 <k_sys_fatal_error_handler+0x2c>
   2636c:	2301      	movs	r3, #1
   2636e:	f04f 0100 	mov.w	r1, #0
   26372:	f363 0107 	bfi	r1, r3, #0, #8
   26376:	4a07      	ldr	r2, [pc, #28]	; (26394 <k_sys_fatal_error_handler+0x38>)
   26378:	4b07      	ldr	r3, [pc, #28]	; (26398 <k_sys_fatal_error_handler+0x3c>)
   2637a:	4808      	ldr	r0, [pc, #32]	; (2639c <k_sys_fatal_error_handler+0x40>)
   2637c:	1a9b      	subs	r3, r3, r2
   2637e:	08db      	lsrs	r3, r3, #3
   26380:	f363 118f 	bfi	r1, r3, #6, #10
   26384:	f002 fad9 	bl	2893a <log_0>
	arch_system_halt(reason);
   26388:	4620      	mov	r0, r4
   2638a:	f006 fdff 	bl	2cf8c <arch_system_halt>
   2638e:	bf00      	nop
   26390:	20010030 	.word	0x20010030
   26394:	0002db28 	.word	0x0002db28
   26398:	0002dc58 	.word	0x0002dc58
   2639c:	000323e8 	.word	0x000323e8

000263a0 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   263a0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   263a2:	4605      	mov	r5, r0
   263a4:	460f      	mov	r7, r1
	struct k_thread *thread = k_current_get();

	/* sanitycheck looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating sanitycheck
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   263a6:	4c30      	ldr	r4, [pc, #192]	; (26468 <z_fatal_error+0xc8>)
	return z_impl_k_current_get();
   263a8:	f000 fea8 	bl	270fc <z_impl_k_current_get>
   263ac:	6823      	ldr	r3, [r4, #0]
   263ae:	0759      	lsls	r1, r3, #29
   263b0:	4606      	mov	r6, r0
   263b2:	d018      	beq.n	263e6 <z_fatal_error+0x46>
   263b4:	2301      	movs	r3, #1
   263b6:	f04f 0100 	mov.w	r1, #0
   263ba:	4a2c      	ldr	r2, [pc, #176]	; (2646c <z_fatal_error+0xcc>)
   263bc:	482c      	ldr	r0, [pc, #176]	; (26470 <z_fatal_error+0xd0>)
   263be:	f363 0107 	bfi	r1, r3, #0, #8
   263c2:	4b2c      	ldr	r3, [pc, #176]	; (26474 <z_fatal_error+0xd4>)
   263c4:	1a9b      	subs	r3, r3, r2
   263c6:	08db      	lsrs	r3, r3, #3
   263c8:	2d04      	cmp	r5, #4
   263ca:	f363 118f 	bfi	r1, r3, #6, #10
	switch (reason) {
   263ce:	bf98      	it	ls
   263d0:	4b29      	ldrls	r3, [pc, #164]	; (26478 <z_fatal_error+0xd8>)
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   263d2:	f8ad 1000 	strh.w	r1, [sp]
   263d6:	bf94      	ite	ls
   263d8:	f853 2025 	ldrls.w	r2, [r3, r5, lsl #2]
   263dc:	4a27      	ldrhi	r2, [pc, #156]	; (2647c <z_fatal_error+0xdc>)
   263de:	2300      	movs	r3, #0
   263e0:	4629      	mov	r1, r5
   263e2:	f002 fae3 	bl	289ac <log_3>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
   263e6:	69fb      	ldr	r3, [r7, #28]
   263e8:	f3c3 0308 	ubfx	r3, r3, #0, #9
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if (arch_is_in_nested_exception(esf)) {
   263ec:	b183      	cbz	r3, 26410 <z_fatal_error+0x70>
		LOG_ERR("Fault during interrupt handling\n");
   263ee:	6823      	ldr	r3, [r4, #0]
   263f0:	075a      	lsls	r2, r3, #29
   263f2:	d02c      	beq.n	2644e <z_fatal_error+0xae>
   263f4:	2301      	movs	r3, #1
   263f6:	f04f 0100 	mov.w	r1, #0
   263fa:	f363 0107 	bfi	r1, r3, #0, #8
   263fe:	4a1b      	ldr	r2, [pc, #108]	; (2646c <z_fatal_error+0xcc>)
   26400:	4b1c      	ldr	r3, [pc, #112]	; (26474 <z_fatal_error+0xd4>)
   26402:	481f      	ldr	r0, [pc, #124]	; (26480 <z_fatal_error+0xe0>)
   26404:	1a9b      	subs	r3, r3, r2
   26406:	08db      	lsrs	r3, r3, #3
   26408:	f363 118f 	bfi	r1, r3, #6, #10
   2640c:	f002 fa95 	bl	2893a <log_0>
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
   26410:	6823      	ldr	r3, [r4, #0]
   26412:	075b      	lsls	r3, r3, #29
   26414:	d01b      	beq.n	2644e <z_fatal_error+0xae>
   26416:	2301      	movs	r3, #1
   26418:	f04f 0400 	mov.w	r4, #0
   2641c:	f363 0407 	bfi	r4, r3, #0, #8
   26420:	4a14      	ldr	r2, [pc, #80]	; (26474 <z_fatal_error+0xd4>)
   26422:	4b12      	ldr	r3, [pc, #72]	; (2646c <z_fatal_error+0xcc>)
   26424:	1ad2      	subs	r2, r2, r3
   26426:	08d2      	lsrs	r2, r2, #3
	const char *thread_name = k_thread_name_get(thread);
   26428:	4630      	mov	r0, r6
	LOG_ERR("Current thread: %p (%s)", thread,
   2642a:	f362 148f 	bfi	r4, r2, #6, #10
	const char *thread_name = k_thread_name_get(thread);
   2642e:	f007 f801 	bl	2d434 <k_thread_name_get>
	if (thread_name == NULL || thread_name[0] == '\0') {
   26432:	b1b0      	cbz	r0, 26462 <z_fatal_error+0xc2>
   26434:	7802      	ldrb	r2, [r0, #0]
		thread_name = "unknown";
   26436:	4b13      	ldr	r3, [pc, #76]	; (26484 <z_fatal_error+0xe4>)
   26438:	2a00      	cmp	r2, #0
   2643a:	bf08      	it	eq
   2643c:	4618      	moveq	r0, r3
	LOG_ERR("Current thread: %p (%s)", thread,
   2643e:	f7ea fe5d 	bl	110fc <log_strdup>
   26442:	4623      	mov	r3, r4
   26444:	4602      	mov	r2, r0
   26446:	4631      	mov	r1, r6
   26448:	480f      	ldr	r0, [pc, #60]	; (26488 <z_fatal_error+0xe8>)
   2644a:	f002 fa97 	bl	2897c <log_2>
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
   2644e:	4639      	mov	r1, r7
   26450:	4628      	mov	r0, r5
   26452:	f7ff ff83 	bl	2635c <k_sys_fatal_error_handler>
	z_impl_k_thread_abort(thread);
   26456:	4630      	mov	r0, r6
			}
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	k_thread_abort(thread);
}
   26458:	b003      	add	sp, #12
   2645a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   2645e:	f7ed bfeb 	b.w	14438 <z_impl_k_thread_abort>
		thread_name = "unknown";
   26462:	4808      	ldr	r0, [pc, #32]	; (26484 <z_fatal_error+0xe4>)
   26464:	e7eb      	b.n	2643e <z_fatal_error+0x9e>
   26466:	bf00      	nop
   26468:	20010030 	.word	0x20010030
   2646c:	0002db28 	.word	0x0002db28
   26470:	0003244f 	.word	0x0003244f
   26474:	0002dc58 	.word	0x0002dc58
   26478:	0002e834 	.word	0x0002e834
   2647c:	00032441 	.word	0x00032441
   26480:	00032477 	.word	0x00032477
   26484:	0002f1cd 	.word	0x0002f1cd
   26488:	00032498 	.word	0x00032498

0002648c <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
   2648c:	b508      	push	{r3, lr}
	_kernel.idle = ticks;
   2648e:	4d0b      	ldr	r5, [pc, #44]	; (264bc <idle+0x30>)
	__asm__ volatile(
   26490:	f04f 0220 	mov.w	r2, #32
   26494:	f3ef 8311 	mrs	r3, BASEPRI
   26498:	f382 8811 	msr	BASEPRI, r2
   2649c:	f3bf 8f6f 	isb	sy
	s32_t ticks = z_get_next_timeout_expiry();
   264a0:	f007 f88a 	bl	2d5b8 <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   264a4:	2101      	movs	r1, #1
   264a6:	2802      	cmp	r0, #2
	s32_t ticks = z_get_next_timeout_expiry();
   264a8:	4604      	mov	r4, r0
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   264aa:	bfd8      	it	le
   264ac:	4608      	movle	r0, r1
   264ae:	f007 f893 	bl	2d5d8 <z_set_timeout_expiry>
	_kernel.idle = ticks;
   264b2:	622c      	str	r4, [r5, #32]
	arch_cpu_idle();
   264b4:	f7ed fba2 	bl	13bfc <arch_cpu_idle>
   264b8:	e7ea      	b.n	26490 <idle+0x4>
   264ba:	bf00      	nop
   264bc:	20003b20 	.word	0x20003b20

000264c0 <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
   264c0:	4802      	ldr	r0, [pc, #8]	; (264cc <z_bss_zero+0xc>)
   264c2:	4a03      	ldr	r2, [pc, #12]	; (264d0 <z_bss_zero+0x10>)
   264c4:	2100      	movs	r1, #0
   264c6:	1a12      	subs	r2, r2, r0
   264c8:	f003 bfeb 	b.w	2a4a2 <memset>
   264cc:	20000000 	.word	0x20000000
   264d0:	20004010 	.word	0x20004010

000264d4 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
   264d4:	b508      	push	{r3, lr}
	(void)memcpy(&__data_ram_start, &__data_rom_start,
		 __data_ram_end - __data_ram_start);
   264d6:	4806      	ldr	r0, [pc, #24]	; (264f0 <z_data_copy+0x1c>)
	(void)memcpy(&__data_ram_start, &__data_rom_start,
   264d8:	4a06      	ldr	r2, [pc, #24]	; (264f4 <z_data_copy+0x20>)
   264da:	4907      	ldr	r1, [pc, #28]	; (264f8 <z_data_copy+0x24>)
   264dc:	1a12      	subs	r2, r2, r0
   264de:	f003 ffb6 	bl	2a44e <memcpy>
#ifdef CONFIG_ARCH_HAS_RAMFUNC_SUPPORT
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
   264e2:	4a06      	ldr	r2, [pc, #24]	; (264fc <z_data_copy+0x28>)
   264e4:	4906      	ldr	r1, [pc, #24]	; (26500 <z_data_copy+0x2c>)
   264e6:	4807      	ldr	r0, [pc, #28]	; (26504 <z_data_copy+0x30>)
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   264e8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
   264ec:	f003 bfaf 	b.w	2a44e <memcpy>
   264f0:	2000f720 	.word	0x2000f720
   264f4:	20010240 	.word	0x20010240
   264f8:	00032508 	.word	0x00032508
   264fc:	00000000 	.word	0x00000000
   26500:	00032508 	.word	0x00032508
   26504:	20000000 	.word	0x20000000

00026508 <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
   26508:	b508      	push	{r3, lr}
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_device_do_config_level(_SYS_INIT_LEVEL_POST_KERNEL);
   2650a:	2002      	movs	r0, #2
   2650c:	f7ff fee4 	bl	262d8 <z_sys_device_do_config_level>
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
   26510:	4a08      	ldr	r2, [pc, #32]	; (26534 <bg_thread_main+0x2c>)
   26512:	4909      	ldr	r1, [pc, #36]	; (26538 <bg_thread_main+0x30>)
   26514:	4809      	ldr	r0, [pc, #36]	; (2653c <bg_thread_main+0x34>)
   26516:	f001 fe15 	bl	28144 <printk>
			KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif

	/* Final init level before app starts */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
   2651a:	2003      	movs	r0, #3
   2651c:	f7ff fedc 	bl	262d8 <z_sys_device_do_config_level>
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	z_init_static_threads();
   26520:	f000 ff0a 	bl	27338 <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
   26524:	f7e8 fc16 	bl	ed54 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   26528:	4a05      	ldr	r2, [pc, #20]	; (26540 <bg_thread_main+0x38>)
   2652a:	7b13      	ldrb	r3, [r2, #12]
   2652c:	f023 0301 	bic.w	r3, r3, #1
   26530:	7313      	strb	r3, [r2, #12]

	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   26532:	bd08      	pop	{r3, pc}
   26534:	0002f979 	.word	0x0002f979
   26538:	000324b0 	.word	0x000324b0
   2653c:	000324be 	.word	0x000324be
   26540:	20003ab4 	.word	0x20003ab4

00026544 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
   26544:	b580      	push	{r7, lr}
   26546:	b0a2      	sub	sp, #136	; 0x88
#endif	/* CONFIG_STACK_CANARIES */

	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
   26548:	f7ea fc90 	bl	10e6c <log_core_init>
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	u32_t msp = (u32_t)(Z_THREAD_STACK_BUFFER(_interrupt_stack)) +
   2654c:	4b35      	ldr	r3, [pc, #212]	; (26624 <z_cstart+0xe0>)
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   2654e:	f383 8808 	msr	MSP, r3
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
   26552:	4c35      	ldr	r4, [pc, #212]	; (26628 <z_cstart+0xe4>)
	_kernel.ready_q.cache = &z_main_thread;
   26554:	4e35      	ldr	r6, [pc, #212]	; (2662c <z_cstart+0xe8>)
   26556:	6963      	ldr	r3, [r4, #20]
   26558:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   2655c:	6163      	str	r3, [r4, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2655e:	2500      	movs	r5, #0
   26560:	23e0      	movs	r3, #224	; 0xe0
   26562:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
   26566:	77e5      	strb	r5, [r4, #31]
   26568:	7625      	strb	r5, [r4, #24]
   2656a:	7665      	strb	r5, [r4, #25]
   2656c:	76a5      	strb	r5, [r4, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   2656e:	6a63      	ldr	r3, [r4, #36]	; 0x24
   26570:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   26574:	6263      	str	r3, [r4, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   26576:	f7ed ff4b 	bl	14410 <z_arm_fault_init>
	z_arm_cpu_idle_init();
   2657a:	f7ed fb39 	bl	13bf0 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   2657e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   26582:	62a3      	str	r3, [r4, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   26584:	62e3      	str	r3, [r4, #44]	; 0x2c

	/* perform any architecture-specific initialization */
	arch_kernel_init();

#ifdef CONFIG_MULTITHREADING
	struct k_thread dummy_thread = {
   26586:	ab07      	add	r3, sp, #28
   26588:	226c      	movs	r2, #108	; 0x6c
   2658a:	4629      	mov	r1, r5
   2658c:	4618      	mov	r0, r3
   2658e:	f003 ff88 	bl	2a4a2 <memset>
# ifdef CONFIG_SCHED_CPU_MASK
		 .base.cpu_mask = -1,
# endif
	};

	_current = &dummy_thread;
   26592:	4c27      	ldr	r4, [pc, #156]	; (26630 <z_cstart+0xec>)
	struct k_thread dummy_thread = {
   26594:	2701      	movs	r7, #1
	_current = &dummy_thread;
   26596:	60a0      	str	r0, [r4, #8]
#ifdef CONFIG_USERSPACE
	z_app_shmem_bss_zero();
#endif

	/* perform basic hardware initialization */
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   26598:	4628      	mov	r0, r5
	struct k_thread dummy_thread = {
   2659a:	f88d 7029 	strb.w	r7, [sp, #41]	; 0x29
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   2659e:	f7ff fe9b 	bl	262d8 <z_sys_device_do_config_level>
	z_sys_device_do_config_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   265a2:	4638      	mov	r0, r7
   265a4:	f7ff fe98 	bl	262d8 <z_sys_device_do_config_level>
	z_sched_init();
   265a8:	f000 fd28 	bl	26ffc <z_sched_init>
	z_setup_new_thread(&z_main_thread, z_main_stack,
   265ac:	4b21      	ldr	r3, [pc, #132]	; (26634 <z_cstart+0xf0>)
	_kernel.ready_q.cache = &z_main_thread;
   265ae:	6266      	str	r6, [r4, #36]	; 0x24
	z_setup_new_thread(&z_main_thread, z_main_stack,
   265b0:	f44f 6280 	mov.w	r2, #1024	; 0x400
   265b4:	e9cd 7304 	strd	r7, r3, [sp, #16]
   265b8:	e9cd 5502 	strd	r5, r5, [sp, #8]
   265bc:	4b1e      	ldr	r3, [pc, #120]	; (26638 <z_cstart+0xf4>)
   265be:	491f      	ldr	r1, [pc, #124]	; (2663c <z_cstart+0xf8>)
   265c0:	e9cd 5500 	strd	r5, r5, [sp]
   265c4:	4630      	mov	r0, r6
   265c6:	f000 fe2b 	bl	27220 <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   265ca:	7b73      	ldrb	r3, [r6, #13]
   265cc:	f023 0204 	bic.w	r2, r3, #4
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   265d0:	f013 0f1b 	tst.w	r3, #27
	thread->base.thread_state &= ~_THREAD_PRESTART;
   265d4:	7372      	strb	r2, [r6, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   265d6:	d104      	bne.n	265e2 <z_cstart+0x9e>
	return true;
}

static ALWAYS_INLINE void z_ready_thread(struct k_thread *thread)
{
	if (z_is_thread_ready(thread)) {
   265d8:	69b3      	ldr	r3, [r6, #24]
   265da:	b913      	cbnz	r3, 265e2 <z_cstart+0x9e>
		z_add_thread_to_ready_q(thread);
   265dc:	4630      	mov	r0, r6
   265de:	f000 fb4d 	bl	26c7c <z_add_thread_to_ready_q>
	z_setup_new_thread(thr, stack,
   265e2:	4b17      	ldr	r3, [pc, #92]	; (26640 <z_cstart+0xfc>)
   265e4:	4d17      	ldr	r5, [pc, #92]	; (26644 <z_cstart+0x100>)
   265e6:	9305      	str	r3, [sp, #20]
   265e8:	2201      	movs	r2, #1
   265ea:	230f      	movs	r3, #15
   265ec:	e9cd 3203 	strd	r3, r2, [sp, #12]
   265f0:	2300      	movs	r3, #0
   265f2:	e9cd 3301 	strd	r3, r3, [sp, #4]
   265f6:	9300      	str	r3, [sp, #0]
   265f8:	f44f 72a0 	mov.w	r2, #320	; 0x140
   265fc:	4b12      	ldr	r3, [pc, #72]	; (26648 <z_cstart+0x104>)
   265fe:	4913      	ldr	r1, [pc, #76]	; (2664c <z_cstart+0x108>)
   26600:	4628      	mov	r0, r5
   26602:	f000 fe0d 	bl	27220 <z_setup_new_thread>
	thread->base.thread_state &= ~_THREAD_PRESTART;
   26606:	7b6b      	ldrb	r3, [r5, #13]
	_kernel.cpus[0].idle_thread = &z_idle_thread;
   26608:	60e5      	str	r5, [r4, #12]
   2660a:	f023 0304 	bic.w	r3, r3, #4
   2660e:	736b      	strb	r3, [r5, #13]
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
   26610:	4b0f      	ldr	r3, [pc, #60]	; (26650 <z_cstart+0x10c>)
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
   26612:	490a      	ldr	r1, [pc, #40]	; (2663c <z_cstart+0xf8>)
   26614:	4805      	ldr	r0, [pc, #20]	; (2662c <z_cstart+0xe8>)
	list->tail = (sys_dnode_t *)list;
   26616:	e9c4 3306 	strd	r3, r3, [r4, #24]
   2661a:	f44f 6280 	mov.w	r2, #1024	; 0x400
   2661e:	4b06      	ldr	r3, [pc, #24]	; (26638 <z_cstart+0xf4>)
   26620:	f7ed fac8 	bl	13bb4 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   26624:	20008210 	.word	0x20008210
   26628:	e000ed00 	.word	0xe000ed00
   2662c:	20003ab4 	.word	0x20003ab4
   26630:	20003b20 	.word	0x20003b20
   26634:	000324e8 	.word	0x000324e8
   26638:	00026509 	.word	0x00026509
   2663c:	200074d0 	.word	0x200074d0
   26640:	000324ed 	.word	0x000324ed
   26644:	20003a48 	.word	0x20003a48
   26648:	0002648d 	.word	0x0002648d
   2664c:	200078d0 	.word	0x200078d0
   26650:	20003b38 	.word	0x20003b38

00026654 <init_mem_slab_module>:
 */
static int init_mem_slab_module(struct device *dev)
{
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   26654:	4b0b      	ldr	r3, [pc, #44]	; (26684 <init_mem_slab_module+0x30>)
   26656:	480c      	ldr	r0, [pc, #48]	; (26688 <init_mem_slab_module+0x34>)
{
   26658:	b570      	push	{r4, r5, r6, lr}
	slab->free_list = NULL;
   2665a:	2400      	movs	r4, #0
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   2665c:	4283      	cmp	r3, r0
   2665e:	d301      	bcc.n	26664 <init_mem_slab_module+0x10>
		create_free_list(slab);
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}
	return 0;
}
   26660:	2000      	movs	r0, #0
   26662:	bd70      	pop	{r4, r5, r6, pc}
	p = slab->buffer;
   26664:	691a      	ldr	r2, [r3, #16]
	for (j = 0U; j < slab->num_blocks; j++) {
   26666:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
   26668:	615c      	str	r4, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   2666a:	2100      	movs	r1, #0
   2666c:	42a9      	cmp	r1, r5
   2666e:	d101      	bne.n	26674 <init_mem_slab_module+0x20>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   26670:	331c      	adds	r3, #28
   26672:	e7f3      	b.n	2665c <init_mem_slab_module+0x8>
		*(char **)p = slab->free_list;
   26674:	695e      	ldr	r6, [r3, #20]
   26676:	6016      	str	r6, [r2, #0]
		p += slab->block_size;
   26678:	68de      	ldr	r6, [r3, #12]
		slab->free_list = p;
   2667a:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   2667c:	3101      	adds	r1, #1
		p += slab->block_size;
   2667e:	4432      	add	r2, r6
   26680:	e7f4      	b.n	2666c <init_mem_slab_module+0x18>
   26682:	bf00      	nop
   26684:	200100a4 	.word	0x200100a4
   26688:	200100a4 	.word	0x200100a4

0002668c <k_mem_slab_alloc>:

	z_object_init(slab);
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, s32_t timeout)
{
   2668c:	b510      	push	{r4, lr}
   2668e:	4613      	mov	r3, r2
   26690:	460c      	mov	r4, r1
   26692:	f04f 0220 	mov.w	r2, #32
   26696:	f3ef 8111 	mrs	r1, BASEPRI
   2669a:	f382 8811 	msr	BASEPRI, r2
   2669e:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
   266a2:	6942      	ldr	r2, [r0, #20]
   266a4:	b15a      	cbz	r2, 266be <k_mem_slab_alloc+0x32>
		/* take a free block */
		*mem = slab->free_list;
   266a6:	6022      	str	r2, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
   266a8:	6813      	ldr	r3, [r2, #0]
   266aa:	6143      	str	r3, [r0, #20]
		slab->num_used++;
   266ac:	6983      	ldr	r3, [r0, #24]
   266ae:	3301      	adds	r3, #1
   266b0:	6183      	str	r3, [r0, #24]
		result = 0;
   266b2:	2000      	movs	r0, #0
	__asm__ volatile(
   266b4:	f381 8811 	msr	BASEPRI, r1
   266b8:	f3bf 8f6f 	isb	sy
		return result;
	}

	k_spin_unlock(&lock, key);

	return result;
   266bc:	e00d      	b.n	266da <k_mem_slab_alloc+0x4e>
	} else if (timeout == K_NO_WAIT) {
   266be:	b91b      	cbnz	r3, 266c8 <k_mem_slab_alloc+0x3c>
		*mem = NULL;
   266c0:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
   266c2:	f06f 000b 	mvn.w	r0, #11
   266c6:	e7f5      	b.n	266b4 <k_mem_slab_alloc+0x28>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
   266c8:	4602      	mov	r2, r0
   266ca:	4804      	ldr	r0, [pc, #16]	; (266dc <k_mem_slab_alloc+0x50>)
   266cc:	f000 fc12 	bl	26ef4 <z_pend_curr>
		if (result == 0) {
   266d0:	b918      	cbnz	r0, 266da <k_mem_slab_alloc+0x4e>
			*mem = _current->base.swap_data;
   266d2:	4b03      	ldr	r3, [pc, #12]	; (266e0 <k_mem_slab_alloc+0x54>)
   266d4:	689b      	ldr	r3, [r3, #8]
   266d6:	695b      	ldr	r3, [r3, #20]
   266d8:	6023      	str	r3, [r4, #0]
}
   266da:	bd10      	pop	{r4, pc}
   266dc:	2000400d 	.word	0x2000400d
   266e0:	20003b20 	.word	0x20003b20

000266e4 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   266e4:	b570      	push	{r4, r5, r6, lr}
   266e6:	4604      	mov	r4, r0
   266e8:	460d      	mov	r5, r1
	__asm__ volatile(
   266ea:	f04f 0320 	mov.w	r3, #32
   266ee:	f3ef 8611 	mrs	r6, BASEPRI
   266f2:	f383 8811 	msr	BASEPRI, r3
   266f6:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   266fa:	f006 fe41 	bl	2d380 <z_unpend_first_thread>

	if (pending_thread != NULL) {
   266fe:	b180      	cbz	r0, 26722 <k_mem_slab_free+0x3e>
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   26700:	682a      	ldr	r2, [r5, #0]
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   26702:	6142      	str	r2, [r0, #20]
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   26704:	7b42      	ldrb	r2, [r0, #13]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   26706:	2100      	movs	r1, #0
   26708:	06d2      	lsls	r2, r2, #27
   2670a:	6681      	str	r1, [r0, #104]	; 0x68
   2670c:	d103      	bne.n	26716 <k_mem_slab_free+0x32>
	if (z_is_thread_ready(thread)) {
   2670e:	6983      	ldr	r3, [r0, #24]
   26710:	b90b      	cbnz	r3, 26716 <k_mem_slab_free+0x32>
		z_add_thread_to_ready_q(thread);
   26712:	f000 fab3 	bl	26c7c <z_add_thread_to_ready_q>
		z_ready_thread(pending_thread);
		z_reschedule(&lock, key);
   26716:	4631      	mov	r1, r6
   26718:	4808      	ldr	r0, [pc, #32]	; (2673c <k_mem_slab_free+0x58>)
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
   2671a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
   2671e:	f006 bdb9 	b.w	2d294 <z_reschedule>
		**(char ***)mem = slab->free_list;
   26722:	682b      	ldr	r3, [r5, #0]
   26724:	6962      	ldr	r2, [r4, #20]
   26726:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)mem;
   26728:	682b      	ldr	r3, [r5, #0]
   2672a:	6163      	str	r3, [r4, #20]
		slab->num_used--;
   2672c:	69a3      	ldr	r3, [r4, #24]
   2672e:	3b01      	subs	r3, #1
   26730:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
   26732:	f386 8811 	msr	BASEPRI, r6
   26736:	f3bf 8f6f 	isb	sy
}
   2673a:	bd70      	pop	{r4, r5, r6, pc}
   2673c:	2000400d 	.word	0x2000400d

00026740 <init_static_pools>:
	z_waitq_init(&p->wait_q);
	z_sys_mem_pool_base_init(&p->base);
}

int init_static_pools(struct device *unused)
{
   26740:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);

	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
   26742:	4c07      	ldr	r4, [pc, #28]	; (26760 <init_static_pools+0x20>)
   26744:	4d07      	ldr	r5, [pc, #28]	; (26764 <init_static_pools+0x24>)
   26746:	42ac      	cmp	r4, r5
   26748:	d301      	bcc.n	2674e <init_static_pools+0xe>
		k_mem_pool_init(p);
	}

	return 0;
}
   2674a:	2000      	movs	r0, #0
   2674c:	bd38      	pop	{r3, r4, r5, pc}
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   2674e:	f104 0314 	add.w	r3, r4, #20
	z_sys_mem_pool_base_init(&p->base);
   26752:	4620      	mov	r0, r4
   26754:	e9c4 3305 	strd	r3, r3, [r4, #20]
   26758:	f001 f9a5 	bl	27aa6 <z_sys_mem_pool_base_init>
	Z_STRUCT_SECTION_FOREACH(k_mem_pool, p) {
   2675c:	341c      	adds	r4, #28
   2675e:	e7f2      	b.n	26746 <init_static_pools+0x6>
   26760:	200100a4 	.word	0x200100a4
   26764:	200100a4 	.word	0x200100a4

00026768 <k_mem_pool_alloc>:

SYS_INIT(init_static_pools, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, s32_t timeout)
{
   26768:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int ret;
	s64_t end = 0;

	__ASSERT(!(arch_is_in_isr() && timeout != K_NO_WAIT), "");

	if (timeout > 0) {
   2676c:	1e1c      	subs	r4, r3, #0
{
   2676e:	b085      	sub	sp, #20
   26770:	4607      	mov	r7, r0
   26772:	460d      	mov	r5, r1
   26774:	4692      	mov	sl, r2
	if (timeout > 0) {
   26776:	dd3b      	ble.n	267f0 <k_mem_pool_alloc+0x88>
	return z_impl_k_uptime_get();
   26778:	f006 ff4c 	bl	2d614 <z_impl_k_uptime_get>
		end = k_uptime_get() + timeout;
   2677c:	eb10 0804 	adds.w	r8, r0, r4
	return pool - &_k_mem_pool_list_start[0];
   26780:	4b1d      	ldr	r3, [pc, #116]	; (267f8 <k_mem_pool_alloc+0x90>)
   26782:	4e1e      	ldr	r6, [pc, #120]	; (267fc <k_mem_pool_alloc+0x94>)
   26784:	1afb      	subs	r3, r7, r3
   26786:	109b      	asrs	r3, r3, #2
   26788:	435e      	muls	r6, r3
		u32_t level_num, block_num;

		ret = z_sys_mem_pool_block_alloc(&p->base, size,
						 &level_num, &block_num,
						 &block->data);
		block->id.pool = pool_id(p);
   2678a:	b2f6      	uxtb	r6, r6
		if (ret == 0 || timeout == K_NO_WAIT ||
		    ret != -ENOMEM) {
			return ret;
		}

		z_pend_curr_unlocked(&p->wait_q, timeout);
   2678c:	f107 0b14 	add.w	fp, r7, #20
		ret = z_sys_mem_pool_block_alloc(&p->base, size,
   26790:	ab03      	add	r3, sp, #12
   26792:	aa02      	add	r2, sp, #8
   26794:	9500      	str	r5, [sp, #0]
   26796:	4651      	mov	r1, sl
   26798:	4638      	mov	r0, r7
   2679a:	f001 f9ca 	bl	27b32 <z_sys_mem_pool_block_alloc>
		block->id.level = level_num;
   2679e:	796b      	ldrb	r3, [r5, #5]
   267a0:	9a02      	ldr	r2, [sp, #8]
		block->id.pool = pool_id(p);
   267a2:	712e      	strb	r6, [r5, #4]
		block->id.level = level_num;
   267a4:	f362 0303 	bfi	r3, r2, #0, #4
   267a8:	716b      	strb	r3, [r5, #5]
		block->id.block = block_num;
   267aa:	686b      	ldr	r3, [r5, #4]
   267ac:	9a03      	ldr	r2, [sp, #12]
   267ae:	f362 331f 	bfi	r3, r2, #12, #20
   267b2:	606b      	str	r3, [r5, #4]
		if (ret == 0 || timeout == K_NO_WAIT ||
   267b4:	b1c8      	cbz	r0, 267ea <k_mem_pool_alloc+0x82>
   267b6:	b1c4      	cbz	r4, 267ea <k_mem_pool_alloc+0x82>
   267b8:	f110 0f0c 	cmn.w	r0, #12
   267bc:	d115      	bne.n	267ea <k_mem_pool_alloc+0x82>
	__asm__ volatile(
   267be:	f04f 0320 	mov.w	r3, #32
   267c2:	f3ef 8011 	mrs	r0, BASEPRI
   267c6:	f383 8811 	msr	BASEPRI, r3
   267ca:	f3bf 8f6f 	isb	sy
	(void) z_pend_curr_irqlock(arch_irq_lock(), wait_q, timeout);
   267ce:	4622      	mov	r2, r4
   267d0:	4659      	mov	r1, fp
   267d2:	f000 fb6b 	bl	26eac <z_pend_curr_irqlock>

		if (timeout != K_FOREVER) {
   267d6:	1c63      	adds	r3, r4, #1
   267d8:	d0da      	beq.n	26790 <k_mem_pool_alloc+0x28>
   267da:	f006 ff1b 	bl	2d614 <z_impl_k_uptime_get>
			timeout = end - k_uptime_get();
   267de:	eba8 0400 	sub.w	r4, r8, r0
			if (timeout <= 0) {
   267e2:	2c00      	cmp	r4, #0
   267e4:	dcd4      	bgt.n	26790 <k_mem_pool_alloc+0x28>
				break;
			}
		}
	}

	return -EAGAIN;
   267e6:	f06f 000a 	mvn.w	r0, #10
}
   267ea:	b005      	add	sp, #20
   267ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	s64_t end = 0;
   267f0:	f04f 0800 	mov.w	r8, #0
   267f4:	e7c4      	b.n	26780 <k_mem_pool_alloc+0x18>
   267f6:	bf00      	nop
   267f8:	200100a4 	.word	0x200100a4
   267fc:	b6db6db7 	.word	0xb6db6db7

00026800 <k_mem_pool_free_id>:

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
   26800:	b570      	push	{r4, r5, r6, lr}
   26802:	7804      	ldrb	r4, [r0, #0]
	int need_sched = 0;
	struct k_mem_pool *p = get_pool(id->pool);

	z_sys_mem_pool_block_free(&p->base, id->level, id->block);
   26804:	6802      	ldr	r2, [r0, #0]
   26806:	7841      	ldrb	r1, [r0, #1]
   26808:	4e11      	ldr	r6, [pc, #68]	; (26850 <k_mem_pool_free_id+0x50>)
   2680a:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
   2680e:	00a4      	lsls	r4, r4, #2
   26810:	0b12      	lsrs	r2, r2, #12
   26812:	f001 010f 	and.w	r1, r1, #15
   26816:	1930      	adds	r0, r6, r4
   26818:	f001 fa3e 	bl	27c98 <z_sys_mem_pool_block_free>
   2681c:	f04f 0320 	mov.w	r3, #32
   26820:	f3ef 8511 	mrs	r5, BASEPRI
   26824:	f383 8811 	msr	BASEPRI, r3
   26828:	f3bf 8f6f 	isb	sy
	 * is unsynchronized.  Maybe we want to put the lock into the
	 * wait_q instead and make the API safe?)
	 */
	k_spinlock_key_t key = k_spin_lock(&lock);

	need_sched = z_unpend_all(&p->wait_q);
   2682c:	f104 0014 	add.w	r0, r4, #20
   26830:	4430      	add	r0, r6
   26832:	f006 fdd2 	bl	2d3da <z_unpend_all>

	if (need_sched != 0) {
   26836:	b128      	cbz	r0, 26844 <k_mem_pool_free_id+0x44>
		z_reschedule(&lock, key);
   26838:	4629      	mov	r1, r5
   2683a:	4806      	ldr	r0, [pc, #24]	; (26854 <k_mem_pool_free_id+0x54>)
	} else {
		k_spin_unlock(&lock, key);
	}
}
   2683c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
   26840:	f006 bd28 	b.w	2d294 <z_reschedule>
	__asm__ volatile(
   26844:	f385 8811 	msr	BASEPRI, r5
   26848:	f3bf 8f6f 	isb	sy
}
   2684c:	bd70      	pop	{r4, r5, r6, pc}
   2684e:	bf00      	nop
   26850:	200100a4 	.word	0x200100a4
   26854:	2000400d 	.word	0x2000400d

00026858 <z_thread_malloc>:

void *z_thread_malloc(size_t size)
{
	void *ret;

	if (_current->resource_pool != NULL) {
   26858:	4b03      	ldr	r3, [pc, #12]	; (26868 <z_thread_malloc+0x10>)
   2685a:	689b      	ldr	r3, [r3, #8]
{
   2685c:	4601      	mov	r1, r0
	if (_current->resource_pool != NULL) {
   2685e:	6e18      	ldr	r0, [r3, #96]	; 0x60
   26860:	b108      	cbz	r0, 26866 <z_thread_malloc+0xe>
		ret = k_mem_pool_malloc(_current->resource_pool, size);
   26862:	f006 bbb0 	b.w	2cfc6 <k_mem_pool_malloc>
	} else {
		ret = NULL;
	}

	return ret;
}
   26866:	4770      	bx	lr
   26868:	20003b20 	.word	0x20003b20

0002686c <z_impl_k_msgq_put>:
	}
}


int z_impl_k_msgq_put(struct k_msgq *msgq, void *data, s32_t timeout)
{
   2686c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   26870:	4613      	mov	r3, r2
   26872:	4604      	mov	r4, r0
   26874:	460f      	mov	r7, r1

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
   26876:	f100 0808 	add.w	r8, r0, #8
	__asm__ volatile(
   2687a:	f04f 0220 	mov.w	r2, #32
   2687e:	f3ef 8611 	mrs	r6, BASEPRI
   26882:	f382 8811 	msr	BASEPRI, r2
   26886:	f3bf 8f6f 	isb	sy

	if (msgq->used_msgs < msgq->max_msgs) {
   2688a:	6a01      	ldr	r1, [r0, #32]
   2688c:	68c2      	ldr	r2, [r0, #12]
   2688e:	4291      	cmp	r1, r2
   26890:	d22e      	bcs.n	268f0 <z_impl_k_msgq_put+0x84>
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   26892:	f006 fd75 	bl	2d380 <z_unpend_first_thread>
		if (pending_thread != NULL) {
			/* give message to waiting thread */
			(void)memcpy(pending_thread->base.swap_data, data,
   26896:	68a2      	ldr	r2, [r4, #8]
		if (pending_thread != NULL) {
   26898:	4605      	mov	r5, r0
			(void)memcpy(pending_thread->base.swap_data, data,
   2689a:	4639      	mov	r1, r7
		if (pending_thread != NULL) {
   2689c:	b198      	cbz	r0, 268c6 <z_impl_k_msgq_put+0x5a>
			(void)memcpy(pending_thread->base.swap_data, data,
   2689e:	6940      	ldr	r0, [r0, #20]
   268a0:	f003 fdd5 	bl	2a44e <memcpy>
   268a4:	2300      	movs	r3, #0
   268a6:	66ab      	str	r3, [r5, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   268a8:	7b6b      	ldrb	r3, [r5, #13]
   268aa:	06db      	lsls	r3, r3, #27
   268ac:	d104      	bne.n	268b8 <z_impl_k_msgq_put+0x4c>
	if (z_is_thread_ready(thread)) {
   268ae:	69ab      	ldr	r3, [r5, #24]
   268b0:	b913      	cbnz	r3, 268b8 <z_impl_k_msgq_put+0x4c>
		z_add_thread_to_ready_q(thread);
   268b2:	4628      	mov	r0, r5
   268b4:	f000 f9e2 	bl	26c7c <z_add_thread_to_ready_q>
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
   268b8:	4640      	mov	r0, r8
   268ba:	4631      	mov	r1, r6
   268bc:	f006 fcea 	bl	2d294 <z_reschedule>
			return 0;
   268c0:	2000      	movs	r0, #0
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   268c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			(void)memcpy(msgq->write_ptr, data, msgq->msg_size);
   268c6:	69e0      	ldr	r0, [r4, #28]
   268c8:	f003 fdc1 	bl	2a44e <memcpy>
			msgq->write_ptr += msgq->msg_size;
   268cc:	69e3      	ldr	r3, [r4, #28]
   268ce:	68a2      	ldr	r2, [r4, #8]
   268d0:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
   268d2:	6962      	ldr	r2, [r4, #20]
			msgq->write_ptr += msgq->msg_size;
   268d4:	61e3      	str	r3, [r4, #28]
			if (msgq->write_ptr == msgq->buffer_end) {
   268d6:	4293      	cmp	r3, r2
				msgq->write_ptr = msgq->buffer_start;
   268d8:	bf04      	itt	eq
   268da:	6923      	ldreq	r3, [r4, #16]
   268dc:	61e3      	streq	r3, [r4, #28]
			msgq->used_msgs++;
   268de:	6a23      	ldr	r3, [r4, #32]
   268e0:	3301      	adds	r3, #1
   268e2:	6223      	str	r3, [r4, #32]
		result = 0;
   268e4:	2000      	movs	r0, #0
	__asm__ volatile(
   268e6:	f386 8811 	msr	BASEPRI, r6
   268ea:	f3bf 8f6f 	isb	sy
	return result;
   268ee:	e7e8      	b.n	268c2 <z_impl_k_msgq_put+0x56>
	} else if (timeout == K_NO_WAIT) {
   268f0:	b14b      	cbz	r3, 26906 <z_impl_k_msgq_put+0x9a>
		_current->base.swap_data = data;
   268f2:	4a06      	ldr	r2, [pc, #24]	; (2690c <z_impl_k_msgq_put+0xa0>)
   268f4:	6892      	ldr	r2, [r2, #8]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   268f6:	4631      	mov	r1, r6
		_current->base.swap_data = data;
   268f8:	6157      	str	r7, [r2, #20]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   268fa:	4602      	mov	r2, r0
   268fc:	4640      	mov	r0, r8
}
   268fe:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   26902:	f000 baf7 	b.w	26ef4 <z_pend_curr>
		result = -ENOMSG;
   26906:	f06f 004f 	mvn.w	r0, #79	; 0x4f
   2690a:	e7ec      	b.n	268e6 <z_impl_k_msgq_put+0x7a>
   2690c:	20003b20 	.word	0x20003b20

00026910 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, s32_t timeout)
{
   26910:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   26914:	4604      	mov	r4, r0
   26916:	4613      	mov	r3, r2
   26918:	4608      	mov	r0, r1

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
   2691a:	f104 0708 	add.w	r7, r4, #8
	__asm__ volatile(
   2691e:	f04f 0220 	mov.w	r2, #32
   26922:	f3ef 8611 	mrs	r6, BASEPRI
   26926:	f382 8811 	msr	BASEPRI, r2
   2692a:	f3bf 8f6f 	isb	sy

	if (msgq->used_msgs > 0) {
   2692e:	6a22      	ldr	r2, [r4, #32]
   26930:	2a00      	cmp	r2, #0
   26932:	d037      	beq.n	269a4 <z_impl_k_msgq_get+0x94>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
   26934:	68a2      	ldr	r2, [r4, #8]
   26936:	69a1      	ldr	r1, [r4, #24]
   26938:	f003 fd89 	bl	2a44e <memcpy>
		msgq->read_ptr += msgq->msg_size;
   2693c:	69a3      	ldr	r3, [r4, #24]
   2693e:	68a2      	ldr	r2, [r4, #8]
   26940:	4413      	add	r3, r2
		if (msgq->read_ptr == msgq->buffer_end) {
   26942:	6962      	ldr	r2, [r4, #20]
		msgq->read_ptr += msgq->msg_size;
   26944:	61a3      	str	r3, [r4, #24]
		if (msgq->read_ptr == msgq->buffer_end) {
   26946:	4293      	cmp	r3, r2
			msgq->read_ptr = msgq->buffer_start;
   26948:	bf04      	itt	eq
   2694a:	6923      	ldreq	r3, [r4, #16]
   2694c:	61a3      	streq	r3, [r4, #24]
		}
		msgq->used_msgs--;
   2694e:	6a23      	ldr	r3, [r4, #32]
   26950:	3b01      	subs	r3, #1
   26952:	6223      	str	r3, [r4, #32]

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   26954:	4620      	mov	r0, r4
   26956:	f006 fd13 	bl	2d380 <z_unpend_first_thread>
		if (pending_thread != NULL) {
   2695a:	4605      	mov	r5, r0
   2695c:	2800      	cmp	r0, #0
   2695e:	d02e      	beq.n	269be <z_impl_k_msgq_get+0xae>
			/* add thread's message to queue */
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
   26960:	68a2      	ldr	r2, [r4, #8]
   26962:	6941      	ldr	r1, [r0, #20]
   26964:	69e0      	ldr	r0, [r4, #28]
   26966:	f003 fd72 	bl	2a44e <memcpy>
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
   2696a:	69e3      	ldr	r3, [r4, #28]
   2696c:	68a2      	ldr	r2, [r4, #8]
   2696e:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
   26970:	6962      	ldr	r2, [r4, #20]
			msgq->write_ptr += msgq->msg_size;
   26972:	61e3      	str	r3, [r4, #28]
			if (msgq->write_ptr == msgq->buffer_end) {
   26974:	4293      	cmp	r3, r2
				msgq->write_ptr = msgq->buffer_start;
   26976:	bf04      	itt	eq
   26978:	6923      	ldreq	r3, [r4, #16]
   2697a:	61e3      	streq	r3, [r4, #28]
			}
			msgq->used_msgs++;
   2697c:	6a23      	ldr	r3, [r4, #32]
   2697e:	3301      	adds	r3, #1
   26980:	6223      	str	r3, [r4, #32]
   26982:	2300      	movs	r3, #0
   26984:	66ab      	str	r3, [r5, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   26986:	7b6b      	ldrb	r3, [r5, #13]
   26988:	06db      	lsls	r3, r3, #27
   2698a:	d104      	bne.n	26996 <z_impl_k_msgq_get+0x86>
	if (z_is_thread_ready(thread)) {
   2698c:	69ab      	ldr	r3, [r5, #24]
   2698e:	b913      	cbnz	r3, 26996 <z_impl_k_msgq_get+0x86>
		z_add_thread_to_ready_q(thread);
   26990:	4628      	mov	r0, r5
   26992:	f000 f973 	bl	26c7c <z_add_thread_to_ready_q>

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
			z_reschedule(&msgq->lock, key);
   26996:	4638      	mov	r0, r7
   26998:	4631      	mov	r1, r6
   2699a:	f006 fc7b 	bl	2d294 <z_reschedule>
			return 0;
   2699e:	2000      	movs	r0, #0
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   269a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (timeout == K_NO_WAIT) {
   269a4:	b14b      	cbz	r3, 269ba <z_impl_k_msgq_get+0xaa>
		_current->base.swap_data = data;
   269a6:	4a08      	ldr	r2, [pc, #32]	; (269c8 <z_impl_k_msgq_get+0xb8>)
   269a8:	6892      	ldr	r2, [r2, #8]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   269aa:	4638      	mov	r0, r7
		_current->base.swap_data = data;
   269ac:	6151      	str	r1, [r2, #20]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   269ae:	4622      	mov	r2, r4
   269b0:	4631      	mov	r1, r6
}
   269b2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   269b6:	f000 ba9d 	b.w	26ef4 <z_pend_curr>
		result = -ENOMSG;
   269ba:	f06f 004f 	mvn.w	r0, #79	; 0x4f
	__asm__ volatile(
   269be:	f386 8811 	msr	BASEPRI, r6
   269c2:	f3bf 8f6f 	isb	sy
	return result;
   269c6:	e7eb      	b.n	269a0 <z_impl_k_msgq_get+0x90>
   269c8:	20003b20 	.word	0x20003b20

000269cc <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, s32_t timeout)
{
   269cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   269ce:	4604      	mov	r4, r0
   269d0:	460f      	mov	r7, r1
	__asm__ volatile(
   269d2:	f04f 0320 	mov.w	r3, #32
   269d6:	f3ef 8511 	mrs	r5, BASEPRI
   269da:	f383 8811 	msr	BASEPRI, r3
   269de:	f3bf 8f6f 	isb	sy
	bool resched = false;

	sys_trace_void(SYS_TRACE_ID_MUTEX_LOCK);
	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   269e2:	68c2      	ldr	r2, [r0, #12]
   269e4:	4930      	ldr	r1, [pc, #192]	; (26aa8 <z_impl_k_mutex_lock+0xdc>)
   269e6:	b15a      	cbz	r2, 26a00 <z_impl_k_mutex_lock+0x34>
   269e8:	6880      	ldr	r0, [r0, #8]
   269ea:	688e      	ldr	r6, [r1, #8]
   269ec:	42b0      	cmp	r0, r6
   269ee:	d015      	beq.n	26a1c <z_impl_k_mutex_lock+0x50>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
	}

	if (unlikely(timeout == (s32_t)K_NO_WAIT)) {
   269f0:	b9b7      	cbnz	r7, 26a20 <z_impl_k_mutex_lock+0x54>
	__asm__ volatile(
   269f2:	f385 8811 	msr	BASEPRI, r5
   269f6:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
   269fa:	f06f 000f 	mvn.w	r0, #15
   269fe:	e00c      	b.n	26a1a <z_impl_k_mutex_lock+0x4e>
					_current->base.prio :
   26a00:	688b      	ldr	r3, [r1, #8]
   26a02:	f993 300e 	ldrsb.w	r3, [r3, #14]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   26a06:	6123      	str	r3, [r4, #16]
		mutex->lock_count++;
   26a08:	3201      	adds	r2, #1
		mutex->owner = _current;
   26a0a:	688b      	ldr	r3, [r1, #8]
		mutex->lock_count++;
   26a0c:	60e2      	str	r2, [r4, #12]
		mutex->owner = _current;
   26a0e:	60a3      	str	r3, [r4, #8]
   26a10:	f385 8811 	msr	BASEPRI, r5
   26a14:	f3bf 8f6f 	isb	sy
		return 0;
   26a18:	2000      	movs	r0, #0
		k_spin_unlock(&lock, key);
	}

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
}
   26a1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					_current->base.prio :
   26a1c:	6923      	ldr	r3, [r4, #16]
   26a1e:	e7f2      	b.n	26a06 <z_impl_k_mutex_lock+0x3a>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   26a20:	f990 300e 	ldrsb.w	r3, [r0, #14]
   26a24:	f996 100e 	ldrsb.w	r1, [r6, #14]
   26a28:	4299      	cmp	r1, r3
   26a2a:	bfa8      	it	ge
   26a2c:	4619      	movge	r1, r3
   26a2e:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   26a32:	4299      	cmp	r1, r3
   26a34:	da2b      	bge.n	26a8e <z_impl_k_mutex_lock+0xc2>
		return z_set_prio(mutex->owner, new_prio);
   26a36:	f000 fa9f 	bl	26f78 <z_set_prio>
   26a3a:	4606      	mov	r6, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   26a3c:	463b      	mov	r3, r7
   26a3e:	4622      	mov	r2, r4
   26a40:	4629      	mov	r1, r5
   26a42:	481a      	ldr	r0, [pc, #104]	; (26aac <z_impl_k_mutex_lock+0xe0>)
   26a44:	f000 fa56 	bl	26ef4 <z_pend_curr>
	if (got_mutex == 0) {
   26a48:	2800      	cmp	r0, #0
   26a4a:	d0e6      	beq.n	26a1a <z_impl_k_mutex_lock+0x4e>
	__asm__ volatile(
   26a4c:	f04f 0320 	mov.w	r3, #32
   26a50:	f3ef 8511 	mrs	r5, BASEPRI
   26a54:	f383 8811 	msr	BASEPRI, r3
   26a58:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   26a5c:	6823      	ldr	r3, [r4, #0]
   26a5e:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
   26a60:	429c      	cmp	r4, r3
   26a62:	d007      	beq.n	26a74 <z_impl_k_mutex_lock+0xa8>
		new_prio_for_inheritance(waiter->base.prio, new_prio) :
   26a64:	b133      	cbz	r3, 26a74 <z_impl_k_mutex_lock+0xa8>
   26a66:	f993 300e 	ldrsb.w	r3, [r3, #14]
   26a6a:	4299      	cmp	r1, r3
   26a6c:	bfa8      	it	ge
   26a6e:	4619      	movge	r1, r3
   26a70:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   26a74:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
   26a76:	f990 300e 	ldrsb.w	r3, [r0, #14]
   26a7a:	4299      	cmp	r1, r3
   26a7c:	d109      	bne.n	26a92 <z_impl_k_mutex_lock+0xc6>
	if (resched) {
   26a7e:	b16e      	cbz	r6, 26a9c <z_impl_k_mutex_lock+0xd0>
		z_reschedule(&lock, key);
   26a80:	4629      	mov	r1, r5
   26a82:	480a      	ldr	r0, [pc, #40]	; (26aac <z_impl_k_mutex_lock+0xe0>)
   26a84:	f006 fc06 	bl	2d294 <z_reschedule>
	return -EAGAIN;
   26a88:	f06f 000a 	mvn.w	r0, #10
   26a8c:	e7c5      	b.n	26a1a <z_impl_k_mutex_lock+0x4e>
	bool resched = false;
   26a8e:	2600      	movs	r6, #0
   26a90:	e7d4      	b.n	26a3c <z_impl_k_mutex_lock+0x70>
		return z_set_prio(mutex->owner, new_prio);
   26a92:	f000 fa71 	bl	26f78 <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   26a96:	2800      	cmp	r0, #0
   26a98:	d1f2      	bne.n	26a80 <z_impl_k_mutex_lock+0xb4>
   26a9a:	e7f0      	b.n	26a7e <z_impl_k_mutex_lock+0xb2>
	__asm__ volatile(
   26a9c:	f385 8811 	msr	BASEPRI, r5
   26aa0:	f3bf 8f6f 	isb	sy
   26aa4:	e7f0      	b.n	26a88 <z_impl_k_mutex_lock+0xbc>
   26aa6:	bf00      	nop
   26aa8:	20003b20 	.word	0x20003b20
   26aac:	2000400d 	.word	0x2000400d

00026ab0 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

void z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   26ab0:	b538      	push	{r3, r4, r5, lr}
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
   26ab2:	4b1d      	ldr	r3, [pc, #116]	; (26b28 <z_impl_k_mutex_unlock+0x78>)
   26ab4:	689a      	ldr	r2, [r3, #8]
   26ab6:	7bd3      	ldrb	r3, [r2, #15]
   26ab8:	3b01      	subs	r3, #1
   26aba:	4604      	mov	r4, r0
   26abc:	73d3      	strb	r3, [r2, #15]
	sys_trace_void(SYS_TRACE_ID_MUTEX_UNLOCK);
	z_sched_lock();

	K_DEBUG("mutex %p lock_count: %d\n", mutex, mutex->lock_count);

	if (mutex->lock_count - 1U != 0U) {
   26abe:	68c3      	ldr	r3, [r0, #12]
   26ac0:	2b01      	cmp	r3, #1
   26ac2:	d005      	beq.n	26ad0 <z_impl_k_mutex_unlock+0x20>
		mutex->lock_count--;
   26ac4:	3b01      	subs	r3, #1
   26ac6:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	k_sched_unlock();
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_UNLOCK);
}
   26ac8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	k_sched_unlock();
   26acc:	f000 b8ba 	b.w	26c44 <k_sched_unlock>
	__asm__ volatile(
   26ad0:	f04f 0320 	mov.w	r3, #32
   26ad4:	f3ef 8511 	mrs	r5, BASEPRI
   26ad8:	f383 8811 	msr	BASEPRI, r3
   26adc:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   26ae0:	6901      	ldr	r1, [r0, #16]
   26ae2:	6880      	ldr	r0, [r0, #8]
	if (mutex->owner->base.prio != new_prio) {
   26ae4:	f990 300e 	ldrsb.w	r3, [r0, #14]
   26ae8:	4299      	cmp	r1, r3
   26aea:	d001      	beq.n	26af0 <z_impl_k_mutex_unlock+0x40>
		return z_set_prio(mutex->owner, new_prio);
   26aec:	f000 fa44 	bl	26f78 <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   26af0:	4620      	mov	r0, r4
   26af2:	f006 fc45 	bl	2d380 <z_unpend_first_thread>
	mutex->owner = new_owner;
   26af6:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   26af8:	b180      	cbz	r0, 26b1c <z_impl_k_mutex_unlock+0x6c>
		mutex->owner_orig_prio = new_owner->base.prio;
   26afa:	f990 200e 	ldrsb.w	r2, [r0, #14]
   26afe:	6122      	str	r2, [r4, #16]
   26b00:	2200      	movs	r2, #0
   26b02:	6682      	str	r2, [r0, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   26b04:	7b42      	ldrb	r2, [r0, #13]
   26b06:	06d2      	lsls	r2, r2, #27
   26b08:	d103      	bne.n	26b12 <z_impl_k_mutex_unlock+0x62>
	if (z_is_thread_ready(thread)) {
   26b0a:	6983      	ldr	r3, [r0, #24]
   26b0c:	b90b      	cbnz	r3, 26b12 <z_impl_k_mutex_unlock+0x62>
		z_add_thread_to_ready_q(thread);
   26b0e:	f000 f8b5 	bl	26c7c <z_add_thread_to_ready_q>
		z_reschedule(&lock, key);
   26b12:	4629      	mov	r1, r5
   26b14:	4805      	ldr	r0, [pc, #20]	; (26b2c <z_impl_k_mutex_unlock+0x7c>)
   26b16:	f006 fbbd 	bl	2d294 <z_reschedule>
   26b1a:	e7d5      	b.n	26ac8 <z_impl_k_mutex_unlock+0x18>
		mutex->lock_count = 0U;
   26b1c:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   26b1e:	f385 8811 	msr	BASEPRI, r5
   26b22:	f3bf 8f6f 	isb	sy
   26b26:	e7cf      	b.n	26ac8 <z_impl_k_mutex_unlock+0x18>
   26b28:	20003b20 	.word	0x20003b20
   26b2c:	2000400d 	.word	0x2000400d

00026b30 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
   26b30:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
   26b32:	4c08      	ldr	r4, [pc, #32]	; (26b54 <z_reset_time_slice+0x24>)
   26b34:	6823      	ldr	r3, [r4, #0]
   26b36:	b15b      	cbz	r3, 26b50 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
   26b38:	f7ec ff2c 	bl	13994 <z_clock_elapsed>
   26b3c:	6823      	ldr	r3, [r4, #0]
   26b3e:	4a06      	ldr	r2, [pc, #24]	; (26b58 <z_reset_time_slice+0x28>)
   26b40:	4418      	add	r0, r3
   26b42:	6110      	str	r0, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
   26b44:	2100      	movs	r1, #0
   26b46:	4618      	mov	r0, r3
	}
}
   26b48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_set_timeout_expiry(slice_time, false);
   26b4c:	f006 bd44 	b.w	2d5d8 <z_set_timeout_expiry>
}
   26b50:	bd10      	pop	{r4, pc}
   26b52:	bf00      	nop
   26b54:	20003b58 	.word	0x20003b58
   26b58:	20003b20 	.word	0x20003b20

00026b5c <k_sched_time_slice_set>:

void k_sched_time_slice_set(s32_t slice, int prio)
{
   26b5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   26b5e:	460d      	mov	r5, r1
	__asm__ volatile(
   26b60:	f04f 0320 	mov.w	r3, #32
   26b64:	f3ef 8411 	mrs	r4, BASEPRI
   26b68:	f383 8811 	msr	BASEPRI, r3
   26b6c:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
   26b70:	4b0d      	ldr	r3, [pc, #52]	; (26ba8 <k_sched_time_slice_set+0x4c>)
			return (u32_t)((t * to_hz + off) / from_hz);
   26b72:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   26b76:	f240 36e7 	movw	r6, #999	; 0x3e7
   26b7a:	2700      	movs	r7, #0
   26b7c:	fbe1 6700 	umlal	r6, r7, r1, r0
   26b80:	2200      	movs	r2, #0
   26b82:	611a      	str	r2, [r3, #16]
   26b84:	4630      	mov	r0, r6
   26b86:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   26b8a:	2300      	movs	r3, #0
   26b8c:	4639      	mov	r1, r7
   26b8e:	f7e5 fbb7 	bl	c300 <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
   26b92:	4b06      	ldr	r3, [pc, #24]	; (26bac <k_sched_time_slice_set+0x50>)
   26b94:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
   26b96:	4b06      	ldr	r3, [pc, #24]	; (26bb0 <k_sched_time_slice_set+0x54>)
   26b98:	601d      	str	r5, [r3, #0]
		z_reset_time_slice();
   26b9a:	f7ff ffc9 	bl	26b30 <z_reset_time_slice>
	__asm__ volatile(
   26b9e:	f384 8811 	msr	BASEPRI, r4
   26ba2:	f3bf 8f6f 	isb	sy
	}
}
   26ba6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   26ba8:	20003b20 	.word	0x20003b20
   26bac:	20003b58 	.word	0x20003b58
   26bb0:	20003b54 	.word	0x20003b54

00026bb4 <k_sched_lock>:
	__asm__ volatile(
   26bb4:	f04f 0320 	mov.w	r3, #32
   26bb8:	f3ef 8111 	mrs	r1, BASEPRI
   26bbc:	f383 8811 	msr	BASEPRI, r3
   26bc0:	f3bf 8f6f 	isb	sy
	--_current->base.sched_locked;
   26bc4:	4b04      	ldr	r3, [pc, #16]	; (26bd8 <k_sched_lock+0x24>)
   26bc6:	689a      	ldr	r2, [r3, #8]
   26bc8:	7bd3      	ldrb	r3, [r2, #15]
   26bca:	3b01      	subs	r3, #1
   26bcc:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
   26bce:	f381 8811 	msr	BASEPRI, r1
   26bd2:	f3bf 8f6f 	isb	sy
void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
   26bd6:	4770      	bx	lr
   26bd8:	20003b20 	.word	0x20003b20

00026bdc <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   26bdc:	4b09      	ldr	r3, [pc, #36]	; (26c04 <z_priq_dumb_remove+0x28>)
   26bde:	f103 0228 	add.w	r2, r3, #40	; 0x28
   26be2:	4282      	cmp	r2, r0
   26be4:	d105      	bne.n	26bf2 <z_priq_dumb_remove+0x16>
   26be6:	689b      	ldr	r3, [r3, #8]
   26be8:	428b      	cmp	r3, r1
   26bea:	d102      	bne.n	26bf2 <z_priq_dumb_remove+0x16>
   26bec:	7b4b      	ldrb	r3, [r1, #13]
   26bee:	06db      	lsls	r3, r3, #27
   26bf0:	d106      	bne.n	26c00 <z_priq_dumb_remove+0x24>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
   26bf2:	e9d1 3200 	ldrd	r3, r2, [r1]
   26bf6:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   26bf8:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   26bfa:	2300      	movs	r3, #0
	node->prev = NULL;
   26bfc:	e9c1 3300 	strd	r3, r3, [r1]
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
   26c00:	4770      	bx	lr
   26c02:	bf00      	nop
   26c04:	20003b20 	.word	0x20003b20

00026c08 <update_cache>:
{
   26c08:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
   26c0a:	4c0d      	ldr	r4, [pc, #52]	; (26c40 <update_cache+0x38>)
{
   26c0c:	4602      	mov	r2, r0
	struct k_thread *th = _priq_run_best(&_kernel.ready_q.runq);
   26c0e:	f104 0028 	add.w	r0, r4, #40	; 0x28
   26c12:	f006 fb7e 	bl	2d312 <z_priq_dumb_best>
	return th ? th : _current_cpu->idle_thread;
   26c16:	4605      	mov	r5, r0
   26c18:	b900      	cbnz	r0, 26c1c <update_cache+0x14>
   26c1a:	68e5      	ldr	r5, [r4, #12]
	if (preempt_ok != 0) {
   26c1c:	68a3      	ldr	r3, [r4, #8]
   26c1e:	b94a      	cbnz	r2, 26c34 <update_cache+0x2c>
	if (z_is_thread_prevented_from_running(_current)) {
   26c20:	7b5a      	ldrb	r2, [r3, #13]
   26c22:	06d2      	lsls	r2, r2, #27
   26c24:	d106      	bne.n	26c34 <update_cache+0x2c>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   26c26:	69aa      	ldr	r2, [r5, #24]
   26c28:	b922      	cbnz	r2, 26c34 <update_cache+0x2c>
	if (is_preempt(_current) || is_metairq(th)) {
   26c2a:	89da      	ldrh	r2, [r3, #14]
   26c2c:	2a7f      	cmp	r2, #127	; 0x7f
   26c2e:	d901      	bls.n	26c34 <update_cache+0x2c>
		_kernel.ready_q.cache = _current;
   26c30:	6263      	str	r3, [r4, #36]	; 0x24
}
   26c32:	bd38      	pop	{r3, r4, r5, pc}
		if (th != _current) {
   26c34:	429d      	cmp	r5, r3
   26c36:	d001      	beq.n	26c3c <update_cache+0x34>
			z_reset_time_slice();
   26c38:	f7ff ff7a 	bl	26b30 <z_reset_time_slice>
		_kernel.ready_q.cache = th;
   26c3c:	6265      	str	r5, [r4, #36]	; 0x24
}
   26c3e:	e7f8      	b.n	26c32 <update_cache+0x2a>
   26c40:	20003b20 	.word	0x20003b20

00026c44 <k_sched_unlock>:
{
   26c44:	b510      	push	{r4, lr}
	__asm__ volatile(
   26c46:	f04f 0320 	mov.w	r3, #32
   26c4a:	f3ef 8411 	mrs	r4, BASEPRI
   26c4e:	f383 8811 	msr	BASEPRI, r3
   26c52:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
   26c56:	4b08      	ldr	r3, [pc, #32]	; (26c78 <k_sched_unlock+0x34>)
   26c58:	689a      	ldr	r2, [r3, #8]
   26c5a:	7bd3      	ldrb	r3, [r2, #15]
   26c5c:	3301      	adds	r3, #1
   26c5e:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   26c60:	2000      	movs	r0, #0
   26c62:	f7ff ffd1 	bl	26c08 <update_cache>
	__asm__ volatile(
   26c66:	f384 8811 	msr	BASEPRI, r4
   26c6a:	f3bf 8f6f 	isb	sy
}
   26c6e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
   26c72:	f006 bb26 	b.w	2d2c2 <z_reschedule_unlocked>
   26c76:	bf00      	nop
   26c78:	20003b20 	.word	0x20003b20

00026c7c <z_add_thread_to_ready_q>:
{
   26c7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
   26c7e:	f04f 0320 	mov.w	r3, #32
   26c82:	f3ef 8411 	mrs	r4, BASEPRI
   26c86:	f383 8811 	msr	BASEPRI, r3
   26c8a:	f3bf 8f6f 	isb	sy
	return list->head == list;
   26c8e:	4a15      	ldr	r2, [pc, #84]	; (26ce4 <z_add_thread_to_ready_q+0x68>)
   26c90:	4611      	mov	r1, r2
   26c92:	f851 3f28 	ldr.w	r3, [r1, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   26c96:	428b      	cmp	r3, r1
   26c98:	d01d      	beq.n	26cd6 <z_add_thread_to_ready_q+0x5a>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   26c9a:	b1e3      	cbz	r3, 26cd6 <z_add_thread_to_ready_q+0x5a>
   26c9c:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
	if (t1->base.prio < t2->base.prio) {
   26c9e:	f990 500e 	ldrsb.w	r5, [r0, #14]
   26ca2:	f993 700e 	ldrsb.w	r7, [r3, #14]
   26ca6:	42af      	cmp	r7, r5
   26ca8:	dd10      	ble.n	26ccc <z_add_thread_to_ready_q+0x50>
	node->prev = successor->prev;
   26caa:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   26cac:	e9c0 3200 	strd	r3, r2, [r0]
	successor->prev->next = node;
   26cb0:	6010      	str	r0, [r2, #0]
	successor->prev = node;
   26cb2:	6058      	str	r0, [r3, #4]
	thread->base.thread_state |= states;
   26cb4:	7b43      	ldrb	r3, [r0, #13]
   26cb6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   26cba:	7343      	strb	r3, [r0, #13]
		update_cache(0);
   26cbc:	2000      	movs	r0, #0
   26cbe:	f7ff ffa3 	bl	26c08 <update_cache>
	__asm__ volatile(
   26cc2:	f384 8811 	msr	BASEPRI, r4
   26cc6:	f3bf 8f6f 	isb	sy
}
   26cca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   26ccc:	42b3      	cmp	r3, r6
   26cce:	d002      	beq.n	26cd6 <z_add_thread_to_ready_q+0x5a>
   26cd0:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   26cd2:	2b00      	cmp	r3, #0
   26cd4:	d1e5      	bne.n	26ca2 <z_add_thread_to_ready_q+0x26>
	node->prev = list->tail;
   26cd6:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   26cd8:	6043      	str	r3, [r0, #4]
	list->tail->next = node;
   26cda:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	node->next = list;
   26cdc:	6001      	str	r1, [r0, #0]
	list->tail->next = node;
   26cde:	6018      	str	r0, [r3, #0]
	list->tail = node;
   26ce0:	62d0      	str	r0, [r2, #44]	; 0x2c
   26ce2:	e7e7      	b.n	26cb4 <z_add_thread_to_ready_q+0x38>
   26ce4:	20003b20 	.word	0x20003b20

00026ce8 <z_move_thread_to_end_of_prio_q>:
{
   26ce8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   26cea:	4604      	mov	r4, r0
	__asm__ volatile(
   26cec:	f04f 0320 	mov.w	r3, #32
   26cf0:	f3ef 8511 	mrs	r5, BASEPRI
   26cf4:	f383 8811 	msr	BASEPRI, r3
   26cf8:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   26cfc:	7b43      	ldrb	r3, [r0, #13]
   26cfe:	065a      	lsls	r2, r3, #25
   26d00:	d503      	bpl.n	26d0a <z_move_thread_to_end_of_prio_q+0x22>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   26d02:	4601      	mov	r1, r0
   26d04:	4817      	ldr	r0, [pc, #92]	; (26d64 <z_move_thread_to_end_of_prio_q+0x7c>)
   26d06:	f7ff ff69 	bl	26bdc <z_priq_dumb_remove>
	return list->head == list;
   26d0a:	4a17      	ldr	r2, [pc, #92]	; (26d68 <z_move_thread_to_end_of_prio_q+0x80>)
   26d0c:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
   26d10:	f102 0128 	add.w	r1, r2, #40	; 0x28
   26d14:	428b      	cmp	r3, r1
   26d16:	d01f      	beq.n	26d58 <z_move_thread_to_end_of_prio_q+0x70>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   26d18:	b1f3      	cbz	r3, 26d58 <z_move_thread_to_end_of_prio_q+0x70>
	if (t1->base.prio < t2->base.prio) {
   26d1a:	f994 600e 	ldrsb.w	r6, [r4, #14]
   26d1e:	f993 700e 	ldrsb.w	r7, [r3, #14]
   26d22:	42b7      	cmp	r7, r6
   26d24:	dd13      	ble.n	26d4e <z_move_thread_to_end_of_prio_q+0x66>
	node->prev = successor->prev;
   26d26:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   26d28:	e9c4 3100 	strd	r3, r1, [r4]
	successor->prev->next = node;
   26d2c:	600c      	str	r4, [r1, #0]
	successor->prev = node;
   26d2e:	605c      	str	r4, [r3, #4]
   26d30:	7b63      	ldrb	r3, [r4, #13]
		update_cache(thread == _current);
   26d32:	6890      	ldr	r0, [r2, #8]
   26d34:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   26d38:	7363      	strb	r3, [r4, #13]
   26d3a:	1b03      	subs	r3, r0, r4
   26d3c:	4258      	negs	r0, r3
   26d3e:	4158      	adcs	r0, r3
   26d40:	f7ff ff62 	bl	26c08 <update_cache>
	__asm__ volatile(
   26d44:	f385 8811 	msr	BASEPRI, r5
   26d48:	f3bf 8f6f 	isb	sy
}
   26d4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   26d4e:	4283      	cmp	r3, r0
   26d50:	d002      	beq.n	26d58 <z_move_thread_to_end_of_prio_q+0x70>
   26d52:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   26d54:	2b00      	cmp	r3, #0
   26d56:	d1e2      	bne.n	26d1e <z_move_thread_to_end_of_prio_q+0x36>
	node->prev = list->tail;
   26d58:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
   26d5c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   26d5e:	601c      	str	r4, [r3, #0]
	list->tail = node;
   26d60:	62d4      	str	r4, [r2, #44]	; 0x2c
   26d62:	e7e5      	b.n	26d30 <z_move_thread_to_end_of_prio_q+0x48>
   26d64:	20003b48 	.word	0x20003b48
   26d68:	20003b20 	.word	0x20003b20

00026d6c <z_time_slice>:
	if (pending_current == _current) {
   26d6c:	4a15      	ldr	r2, [pc, #84]	; (26dc4 <z_time_slice+0x58>)
   26d6e:	4916      	ldr	r1, [pc, #88]	; (26dc8 <z_time_slice+0x5c>)
{
   26d70:	b538      	push	{r3, r4, r5, lr}
	if (pending_current == _current) {
   26d72:	680c      	ldr	r4, [r1, #0]
   26d74:	6893      	ldr	r3, [r2, #8]
   26d76:	42a3      	cmp	r3, r4
   26d78:	4614      	mov	r4, r2
   26d7a:	d103      	bne.n	26d84 <z_time_slice+0x18>
}
   26d7c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			z_reset_time_slice();
   26d80:	f7ff bed6 	b.w	26b30 <z_reset_time_slice>
	pending_current = NULL;
   26d84:	2500      	movs	r5, #0
   26d86:	600d      	str	r5, [r1, #0]
	if (slice_time && sliceable(_current)) {
   26d88:	4910      	ldr	r1, [pc, #64]	; (26dcc <z_time_slice+0x60>)
   26d8a:	6809      	ldr	r1, [r1, #0]
   26d8c:	b1b9      	cbz	r1, 26dbe <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(t);
   26d8e:	89d9      	ldrh	r1, [r3, #14]
   26d90:	297f      	cmp	r1, #127	; 0x7f
   26d92:	d814      	bhi.n	26dbe <z_time_slice+0x52>
		&& !z_is_prio_higher(t->base.prio, slice_max_prio)
   26d94:	490e      	ldr	r1, [pc, #56]	; (26dd0 <z_time_slice+0x64>)
   26d96:	f993 500e 	ldrsb.w	r5, [r3, #14]
   26d9a:	6809      	ldr	r1, [r1, #0]
   26d9c:	428d      	cmp	r5, r1
   26d9e:	db0e      	blt.n	26dbe <z_time_slice+0x52>
		&& !z_is_idle_thread_object(t)
   26da0:	490c      	ldr	r1, [pc, #48]	; (26dd4 <z_time_slice+0x68>)
   26da2:	428b      	cmp	r3, r1
   26da4:	d00b      	beq.n	26dbe <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(t);
   26da6:	6999      	ldr	r1, [r3, #24]
   26da8:	b949      	cbnz	r1, 26dbe <z_time_slice+0x52>
		if (ticks >= _current_cpu->slice_ticks) {
   26daa:	6911      	ldr	r1, [r2, #16]
   26dac:	4281      	cmp	r1, r0
   26dae:	dc03      	bgt.n	26db8 <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
   26db0:	4618      	mov	r0, r3
   26db2:	f7ff ff99 	bl	26ce8 <z_move_thread_to_end_of_prio_q>
   26db6:	e7e1      	b.n	26d7c <z_time_slice+0x10>
			_current_cpu->slice_ticks -= ticks;
   26db8:	1a09      	subs	r1, r1, r0
   26dba:	6111      	str	r1, [r2, #16]
}
   26dbc:	bd38      	pop	{r3, r4, r5, pc}
		_current_cpu->slice_ticks = 0;
   26dbe:	2300      	movs	r3, #0
   26dc0:	6123      	str	r3, [r4, #16]
   26dc2:	e7fb      	b.n	26dbc <z_time_slice+0x50>
   26dc4:	20003b20 	.word	0x20003b20
   26dc8:	20003b50 	.word	0x20003b50
   26dcc:	20003b58 	.word	0x20003b58
   26dd0:	20003b54 	.word	0x20003b54
   26dd4:	20003a48 	.word	0x20003a48

00026dd8 <z_remove_thread_from_ready_q>:
{
   26dd8:	b538      	push	{r3, r4, r5, lr}
   26dda:	4604      	mov	r4, r0
	__asm__ volatile(
   26ddc:	f04f 0320 	mov.w	r3, #32
   26de0:	f3ef 8511 	mrs	r5, BASEPRI
   26de4:	f383 8811 	msr	BASEPRI, r3
   26de8:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   26dec:	7b43      	ldrb	r3, [r0, #13]
   26dee:	065a      	lsls	r2, r3, #25
   26df0:	d507      	bpl.n	26e02 <z_remove_thread_from_ready_q+0x2a>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   26df2:	4601      	mov	r1, r0
   26df4:	4809      	ldr	r0, [pc, #36]	; (26e1c <z_remove_thread_from_ready_q+0x44>)
   26df6:	f7ff fef1 	bl	26bdc <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   26dfa:	7b63      	ldrb	r3, [r4, #13]
   26dfc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
   26e00:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
   26e02:	4b07      	ldr	r3, [pc, #28]	; (26e20 <z_remove_thread_from_ready_q+0x48>)
   26e04:	6898      	ldr	r0, [r3, #8]
   26e06:	1b03      	subs	r3, r0, r4
   26e08:	4258      	negs	r0, r3
   26e0a:	4158      	adcs	r0, r3
   26e0c:	f7ff fefc 	bl	26c08 <update_cache>
	__asm__ volatile(
   26e10:	f385 8811 	msr	BASEPRI, r5
   26e14:	f3bf 8f6f 	isb	sy
}
   26e18:	bd38      	pop	{r3, r4, r5, pc}
   26e1a:	bf00      	nop
   26e1c:	20003b48 	.word	0x20003b48
   26e20:	20003b20 	.word	0x20003b20

00026e24 <pend>:
{
   26e24:	b570      	push	{r4, r5, r6, lr}
   26e26:	4604      	mov	r4, r0
   26e28:	460d      	mov	r5, r1
   26e2a:	4616      	mov	r6, r2
	z_remove_thread_from_ready_q(thread);
   26e2c:	f7ff ffd4 	bl	26dd8 <z_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_PENDING;
   26e30:	7b63      	ldrb	r3, [r4, #13]
   26e32:	f043 0302 	orr.w	r3, r3, #2
   26e36:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   26e38:	b17d      	cbz	r5, 26e5a <pend+0x36>
	return list->head == list;
   26e3a:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
   26e3c:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   26e3e:	429d      	cmp	r5, r3
   26e40:	d029      	beq.n	26e96 <pend+0x72>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   26e42:	b343      	cbz	r3, 26e96 <pend+0x72>
	if (t1->base.prio < t2->base.prio) {
   26e44:	f994 200e 	ldrsb.w	r2, [r4, #14]
   26e48:	f993 100e 	ldrsb.w	r1, [r3, #14]
   26e4c:	4291      	cmp	r1, r2
   26e4e:	dd1c      	ble.n	26e8a <pend+0x66>
	node->prev = successor->prev;
   26e50:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   26e52:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   26e56:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   26e58:	605c      	str	r4, [r3, #4]
	if (timeout != K_FOREVER) {
   26e5a:	1c73      	adds	r3, r6, #1
   26e5c:	d022      	beq.n	26ea4 <pend+0x80>
   26e5e:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
   26e62:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   26e66:	f240 30e7 	movw	r0, #999	; 0x3e7
   26e6a:	2100      	movs	r1, #0
   26e6c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   26e70:	fbc5 0106 	smlal	r0, r1, r5, r6
   26e74:	2300      	movs	r3, #0
   26e76:	f7e5 fa43 	bl	c300 <__aeabi_uldivmod>

extern void z_thread_timeout(struct _timeout *to);

static inline void z_add_thread_timeout(struct k_thread *th, s32_t ticks)
{
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   26e7a:	490b      	ldr	r1, [pc, #44]	; (26ea8 <pend+0x84>)
   26e7c:	1c42      	adds	r2, r0, #1
   26e7e:	f104 0018 	add.w	r0, r4, #24
}
   26e82:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   26e86:	f000 bb57 	b.w	27538 <z_add_timeout>
	return (node == list->tail) ? NULL : node->next;
   26e8a:	6869      	ldr	r1, [r5, #4]
   26e8c:	428b      	cmp	r3, r1
   26e8e:	d002      	beq.n	26e96 <pend+0x72>
   26e90:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   26e92:	2b00      	cmp	r3, #0
   26e94:	d1d8      	bne.n	26e48 <pend+0x24>
	node->prev = list->tail;
   26e96:	686b      	ldr	r3, [r5, #4]
   26e98:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   26e9a:	686b      	ldr	r3, [r5, #4]
	node->next = list;
   26e9c:	6025      	str	r5, [r4, #0]
	list->tail->next = node;
   26e9e:	601c      	str	r4, [r3, #0]
	list->tail = node;
   26ea0:	606c      	str	r4, [r5, #4]
   26ea2:	e7da      	b.n	26e5a <pend+0x36>
}
   26ea4:	bd70      	pop	{r4, r5, r6, pc}
   26ea6:	bf00      	nop
   26ea8:	0002d31f 	.word	0x0002d31f

00026eac <z_pend_curr_irqlock>:
{
   26eac:	b570      	push	{r4, r5, r6, lr}
	pend(_current, wait_q, timeout);
   26eae:	4d0f      	ldr	r5, [pc, #60]	; (26eec <z_pend_curr_irqlock+0x40>)
	pending_current = _current;
   26eb0:	4c0f      	ldr	r4, [pc, #60]	; (26ef0 <z_pend_curr_irqlock+0x44>)
{
   26eb2:	4606      	mov	r6, r0
	pend(_current, wait_q, timeout);
   26eb4:	68a8      	ldr	r0, [r5, #8]
   26eb6:	f7ff ffb5 	bl	26e24 <pend>
	pending_current = _current;
   26eba:	68ab      	ldr	r3, [r5, #8]
   26ebc:	6023      	str	r3, [r4, #0]
   26ebe:	4630      	mov	r0, r6
   26ec0:	f7ec fdaa 	bl	13a18 <arch_swap>
	__asm__ volatile(
   26ec4:	f04f 0220 	mov.w	r2, #32
   26ec8:	f3ef 8311 	mrs	r3, BASEPRI
   26ecc:	f382 8811 	msr	BASEPRI, r2
   26ed0:	f3bf 8f6f 	isb	sy
		if (pending_current == _current) {
   26ed4:	6822      	ldr	r2, [r4, #0]
   26ed6:	68a9      	ldr	r1, [r5, #8]
   26ed8:	4291      	cmp	r1, r2
			pending_current = NULL;
   26eda:	bf04      	itt	eq
   26edc:	2200      	moveq	r2, #0
   26ede:	6022      	streq	r2, [r4, #0]
	__asm__ volatile(
   26ee0:	f383 8811 	msr	BASEPRI, r3
   26ee4:	f3bf 8f6f 	isb	sy
}
   26ee8:	bd70      	pop	{r4, r5, r6, pc}
   26eea:	bf00      	nop
   26eec:	20003b20 	.word	0x20003b20
   26ef0:	20003b50 	.word	0x20003b50

00026ef4 <z_pend_curr>:
{
   26ef4:	b510      	push	{r4, lr}
   26ef6:	460c      	mov	r4, r1
   26ef8:	4611      	mov	r1, r2
	pending_current = _current;
   26efa:	4a06      	ldr	r2, [pc, #24]	; (26f14 <z_pend_curr+0x20>)
   26efc:	6890      	ldr	r0, [r2, #8]
   26efe:	4a06      	ldr	r2, [pc, #24]	; (26f18 <z_pend_curr+0x24>)
   26f00:	6010      	str	r0, [r2, #0]
	pend(_current, wait_q, timeout);
   26f02:	461a      	mov	r2, r3
   26f04:	f7ff ff8e 	bl	26e24 <pend>
   26f08:	4620      	mov	r0, r4
}
   26f0a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   26f0e:	f7ec bd83 	b.w	13a18 <arch_swap>
   26f12:	bf00      	nop
   26f14:	20003b20 	.word	0x20003b20
   26f18:	20003b50 	.word	0x20003b50

00026f1c <z_tick_sleep.part.19>:
	z_impl_k_yield();
}
#include <syscalls/k_yield_mrsh.c>
#endif

static s32_t z_tick_sleep(s32_t ticks)
   26f1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (ticks == 0) {
		k_yield();
		return 0;
	}

	ticks += _TICK_ALIGN;
   26f1e:	1c46      	adds	r6, r0, #1
	expected_wakeup_time = ticks + z_tick_get_32();
   26f20:	f006 fb74 	bl	2d60c <z_tick_get_32>
   26f24:	1834      	adds	r4, r6, r0
	__asm__ volatile(
   26f26:	f04f 0320 	mov.w	r3, #32
   26f2a:	f3ef 8711 	mrs	r7, BASEPRI
   26f2e:	f383 8811 	msr	BASEPRI, r3
   26f32:	f3bf 8f6f 	isb	sy
	 */
	struct k_spinlock local_lock = {};
	k_spinlock_key_t key = k_spin_lock(&local_lock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
   26f36:	4d0d      	ldr	r5, [pc, #52]	; (26f6c <z_tick_sleep.part.19+0x50>)
   26f38:	4b0d      	ldr	r3, [pc, #52]	; (26f70 <z_tick_sleep.part.19+0x54>)
   26f3a:	68a8      	ldr	r0, [r5, #8]
   26f3c:	6018      	str	r0, [r3, #0]
#endif
	z_remove_thread_from_ready_q(_current);
   26f3e:	f7ff ff4b 	bl	26dd8 <z_remove_thread_from_ready_q>
   26f42:	68a8      	ldr	r0, [r5, #8]
   26f44:	490b      	ldr	r1, [pc, #44]	; (26f74 <z_tick_sleep.part.19+0x58>)
   26f46:	4632      	mov	r2, r6
   26f48:	3018      	adds	r0, #24
   26f4a:	f000 faf5 	bl	27538 <z_add_timeout>
	z_add_thread_timeout(_current, ticks);
	z_mark_thread_as_suspended(_current);
   26f4e:	68aa      	ldr	r2, [r5, #8]
	thread->base.thread_state |= _THREAD_SUSPENDED;
   26f50:	7b53      	ldrb	r3, [r2, #13]
   26f52:	f043 0310 	orr.w	r3, r3, #16
   26f56:	7353      	strb	r3, [r2, #13]
   26f58:	4638      	mov	r0, r7
   26f5a:	f7ec fd5d 	bl	13a18 <arch_swap>

	(void)z_swap(&local_lock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = expected_wakeup_time - z_tick_get_32();
   26f5e:	f006 fb55 	bl	2d60c <z_tick_get_32>
   26f62:	1a20      	subs	r0, r4, r0
		return ticks;
	}
#endif

	return 0;
}
   26f64:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   26f68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   26f6a:	bf00      	nop
   26f6c:	20003b20 	.word	0x20003b20
   26f70:	20003b50 	.word	0x20003b50
   26f74:	0002d31f 	.word	0x0002d31f

00026f78 <z_set_prio>:
{
   26f78:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   26f7c:	4604      	mov	r4, r0
   26f7e:	f04f 0320 	mov.w	r3, #32
   26f82:	f3ef 8911 	mrs	r9, BASEPRI
   26f86:	f383 8811 	msr	BASEPRI, r3
   26f8a:	f3bf 8f6f 	isb	sy
		need_sched = z_is_thread_ready(thread);
   26f8e:	f006 f946 	bl	2d21e <z_is_thread_ready>
		if (need_sched) {
   26f92:	b24e      	sxtb	r6, r1
   26f94:	4680      	mov	r8, r0
   26f96:	b360      	cbz	r0, 26ff2 <z_set_prio+0x7a>
				_priq_run_remove(&_kernel.ready_q.runq, thread);
   26f98:	4d17      	ldr	r5, [pc, #92]	; (26ff8 <z_set_prio+0x80>)
   26f9a:	f105 0728 	add.w	r7, r5, #40	; 0x28
   26f9e:	4621      	mov	r1, r4
   26fa0:	4638      	mov	r0, r7
   26fa2:	f7ff fe1b 	bl	26bdc <z_priq_dumb_remove>
	return list->head == list;
   26fa6:	6aab      	ldr	r3, [r5, #40]	; 0x28
				thread->base.prio = prio;
   26fa8:	73a6      	strb	r6, [r4, #14]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   26faa:	42bb      	cmp	r3, r7
   26fac:	462a      	mov	r2, r5
   26fae:	d019      	beq.n	26fe4 <z_set_prio+0x6c>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   26fb0:	b1c3      	cbz	r3, 26fe4 <z_set_prio+0x6c>
   26fb2:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
	if (t1->base.prio < t2->base.prio) {
   26fb4:	f993 000e 	ldrsb.w	r0, [r3, #14]
   26fb8:	42b0      	cmp	r0, r6
   26fba:	dd0e      	ble.n	26fda <z_set_prio+0x62>
	node->prev = successor->prev;
   26fbc:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   26fbe:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   26fc2:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   26fc4:	605c      	str	r4, [r3, #4]
			update_cache(1);
   26fc6:	2001      	movs	r0, #1
   26fc8:	f7ff fe1e 	bl	26c08 <update_cache>
	__asm__ volatile(
   26fcc:	f389 8811 	msr	BASEPRI, r9
   26fd0:	f3bf 8f6f 	isb	sy
}
   26fd4:	4640      	mov	r0, r8
   26fd6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return (node == list->tail) ? NULL : node->next;
   26fda:	4299      	cmp	r1, r3
   26fdc:	d002      	beq.n	26fe4 <z_set_prio+0x6c>
   26fde:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   26fe0:	2b00      	cmp	r3, #0
   26fe2:	d1e7      	bne.n	26fb4 <z_set_prio+0x3c>
	node->prev = list->tail;
   26fe4:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   26fe6:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   26fe8:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	node->next = list;
   26fea:	6027      	str	r7, [r4, #0]
	list->tail->next = node;
   26fec:	601c      	str	r4, [r3, #0]
	list->tail = node;
   26fee:	62d4      	str	r4, [r2, #44]	; 0x2c
   26ff0:	e7e9      	b.n	26fc6 <z_set_prio+0x4e>
			thread->base.prio = prio;
   26ff2:	73a6      	strb	r6, [r4, #14]
   26ff4:	e7ea      	b.n	26fcc <z_set_prio+0x54>
   26ff6:	bf00      	nop
   26ff8:	20003b20 	.word	0x20003b20

00026ffc <z_sched_init>:
	list->head = (sys_dnode_t *)list;
   26ffc:	4b04      	ldr	r3, [pc, #16]	; (27010 <z_sched_init+0x14>)
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   26ffe:	2100      	movs	r1, #0
   27000:	f103 0228 	add.w	r2, r3, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
   27004:	e9c3 220a 	strd	r2, r2, [r3, #40]	; 0x28
   27008:	4608      	mov	r0, r1
   2700a:	f7ff bda7 	b.w	26b5c <k_sched_time_slice_set>
   2700e:	bf00      	nop
   27010:	20003b20 	.word	0x20003b20

00027014 <z_impl_k_yield>:
{
   27014:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!z_is_idle_thread_object(_current)) {
   27016:	4c23      	ldr	r4, [pc, #140]	; (270a4 <_flash_used+0x7c>)
   27018:	4b23      	ldr	r3, [pc, #140]	; (270a8 <_flash_used+0x80>)
   2701a:	68a2      	ldr	r2, [r4, #8]
   2701c:	429a      	cmp	r2, r3
   2701e:	d029      	beq.n	27074 <_flash_used+0x4c>
	__asm__ volatile(
   27020:	f04f 0320 	mov.w	r3, #32
   27024:	f3ef 8611 	mrs	r6, BASEPRI
   27028:	f383 8811 	msr	BASEPRI, r3
   2702c:	f3bf 8f6f 	isb	sy
				_priq_run_remove(&_kernel.ready_q.runq,
   27030:	f104 0528 	add.w	r5, r4, #40	; 0x28
   27034:	68a1      	ldr	r1, [r4, #8]
   27036:	4628      	mov	r0, r5
   27038:	f7ff fdd0 	bl	26bdc <z_priq_dumb_remove>
	return list->head == list;
   2703c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
			_priq_run_add(&_kernel.ready_q.runq, _current);
   2703e:	68a3      	ldr	r3, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   27040:	42aa      	cmp	r2, r5
   27042:	d028      	beq.n	27096 <_flash_used+0x6e>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   27044:	b33a      	cbz	r2, 27096 <_flash_used+0x6e>
   27046:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
	if (t1->base.prio < t2->base.prio) {
   27048:	f993 100e 	ldrsb.w	r1, [r3, #14]
   2704c:	f992 700e 	ldrsb.w	r7, [r2, #14]
   27050:	428f      	cmp	r7, r1
   27052:	dd1b      	ble.n	2708c <_flash_used+0x64>
	node->prev = successor->prev;
   27054:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
   27056:	e9c3 2100 	strd	r2, r1, [r3]
	successor->prev->next = node;
   2705a:	600b      	str	r3, [r1, #0]
	successor->prev = node;
   2705c:	6053      	str	r3, [r2, #4]
	thread->base.thread_state |= states;
   2705e:	7b5a      	ldrb	r2, [r3, #13]
   27060:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   27064:	735a      	strb	r2, [r3, #13]
			update_cache(1);
   27066:	2001      	movs	r0, #1
   27068:	f7ff fdce 	bl	26c08 <update_cache>
	__asm__ volatile(
   2706c:	f386 8811 	msr	BASEPRI, r6
   27070:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   27074:	f04f 0320 	mov.w	r3, #32
   27078:	f3ef 8011 	mrs	r0, BASEPRI
   2707c:	f383 8811 	msr	BASEPRI, r3
   27080:	f3bf 8f6f 	isb	sy
}
   27084:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   27088:	f7ec bcc6 	b.w	13a18 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
   2708c:	4282      	cmp	r2, r0
   2708e:	d002      	beq.n	27096 <_flash_used+0x6e>
   27090:	6812      	ldr	r2, [r2, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   27092:	2a00      	cmp	r2, #0
   27094:	d1da      	bne.n	2704c <_flash_used+0x24>
	node->prev = list->tail;
   27096:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   27098:	605a      	str	r2, [r3, #4]
	list->tail->next = node;
   2709a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
	node->next = list;
   2709c:	601d      	str	r5, [r3, #0]
	list->tail->next = node;
   2709e:	6013      	str	r3, [r2, #0]
	list->tail = node;
   270a0:	62e3      	str	r3, [r4, #44]	; 0x2c
   270a2:	e7dc      	b.n	2705e <_flash_used+0x36>
   270a4:	20003b20 	.word	0x20003b20
   270a8:	20003a48 	.word	0x20003a48

000270ac <z_impl_k_sleep>:

s32_t z_impl_k_sleep(int ms)
{
   270ac:	b538      	push	{r3, r4, r5, lr}
	s32_t ticks;

	if (ms == K_FOREVER) {
   270ae:	1c43      	adds	r3, r0, #1
{
   270b0:	4604      	mov	r4, r0
	if (ms == K_FOREVER) {
   270b2:	d105      	bne.n	270c0 <z_impl_k_sleep+0x14>
		k_thread_suspend(_current);
   270b4:	4b10      	ldr	r3, [pc, #64]	; (270f8 <z_impl_k_sleep+0x4c>)
   270b6:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   270b8:	f000 f91e 	bl	272f8 <z_impl_k_thread_suspend>
	}

	ticks = k_ms_to_ticks_ceil32(ms);
	ticks = z_tick_sleep(ticks);
	return k_ticks_to_ms_floor64(ticks);
}
   270bc:	4620      	mov	r0, r4
   270be:	bd38      	pop	{r3, r4, r5, pc}
   270c0:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   270c4:	f240 30e7 	movw	r0, #999	; 0x3e7
   270c8:	2100      	movs	r1, #0
   270ca:	fbe5 0104 	umlal	r0, r1, r5, r4
   270ce:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   270d2:	2300      	movs	r3, #0
   270d4:	f7e5 f914 	bl	c300 <__aeabi_uldivmod>
	if (ticks == 0) {
   270d8:	4604      	mov	r4, r0
   270da:	b948      	cbnz	r0, 270f0 <z_impl_k_sleep+0x44>
	z_impl_k_yield();
   270dc:	f7ff ff9a 	bl	27014 <z_impl_k_yield>
			return (t * to_hz + off) / from_hz;
   270e0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   270e4:	fb84 0100 	smull	r0, r1, r4, r0
   270e8:	0bc4      	lsrs	r4, r0, #15
   270ea:	ea44 4441 	orr.w	r4, r4, r1, lsl #17
	return k_ticks_to_ms_floor64(ticks);
   270ee:	e7e5      	b.n	270bc <z_impl_k_sleep+0x10>
   270f0:	f7ff ff14 	bl	26f1c <z_tick_sleep.part.19>
   270f4:	4604      	mov	r4, r0
   270f6:	e7f3      	b.n	270e0 <z_impl_k_sleep+0x34>
   270f8:	20003b20 	.word	0x20003b20

000270fc <z_impl_k_current_get>:
#endif

k_tid_t z_impl_k_current_get(void)
{
	return _current;
}
   270fc:	4b01      	ldr	r3, [pc, #4]	; (27104 <z_impl_k_current_get+0x8>)
   270fe:	6898      	ldr	r0, [r3, #8]
   27100:	4770      	bx	lr
   27102:	bf00      	nop
   27104:	20003b20 	.word	0x20003b20

00027108 <z_impl_k_sem_give>:
		handle_poll_events(sem);
	}
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   27108:	b570      	push	{r4, r5, r6, lr}
   2710a:	4604      	mov	r4, r0
   2710c:	f04f 0320 	mov.w	r3, #32
   27110:	f3ef 8611 	mrs	r6, BASEPRI
   27114:	f383 8811 	msr	BASEPRI, r3
   27118:	f3bf 8f6f 	isb	sy
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
   2711c:	f006 f930 	bl	2d380 <z_unpend_first_thread>
	if (thread != NULL) {
   27120:	4605      	mov	r5, r0
   27122:	b170      	cbz	r0, 27142 <z_impl_k_sem_give+0x3a>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   27124:	7b43      	ldrb	r3, [r0, #13]
   27126:	06db      	lsls	r3, r3, #27
   27128:	d103      	bne.n	27132 <z_impl_k_sem_give+0x2a>
	if (z_is_thread_ready(thread)) {
   2712a:	6983      	ldr	r3, [r0, #24]
   2712c:	b90b      	cbnz	r3, 27132 <z_impl_k_sem_give+0x2a>
		z_add_thread_to_ready_q(thread);
   2712e:	f7ff fda5 	bl	26c7c <z_add_thread_to_ready_q>
   27132:	2300      	movs	r3, #0
   27134:	66ab      	str	r3, [r5, #104]	; 0x68
	k_spinlock_key_t key = k_spin_lock(&lock);

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);
	do_sem_give(sem);
	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
   27136:	4631      	mov	r1, r6
   27138:	4808      	ldr	r0, [pc, #32]	; (2715c <z_impl_k_sem_give+0x54>)
}
   2713a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&lock, key);
   2713e:	f006 b8a9 	b.w	2d294 <z_reschedule>
	sem->count += (sem->count != sem->limit) ? 1U : 0U;
   27142:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   27146:	429a      	cmp	r2, r3
   27148:	bf18      	it	ne
   2714a:	3301      	addne	r3, #1
   2714c:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   2714e:	2102      	movs	r1, #2
   27150:	f104 0010 	add.w	r0, r4, #16
   27154:	f006 fb91 	bl	2d87a <z_handle_obj_poll_events>
   27158:	e7ed      	b.n	27136 <z_impl_k_sem_give+0x2e>
   2715a:	bf00      	nop
   2715c:	2000400d 	.word	0x2000400d

00027160 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, s32_t timeout)
{
   27160:	b410      	push	{r4}
   27162:	4602      	mov	r2, r0
   27164:	460b      	mov	r3, r1
   27166:	f04f 0020 	mov.w	r0, #32
   2716a:	f3ef 8111 	mrs	r1, BASEPRI
   2716e:	f380 8811 	msr	BASEPRI, r0
   27172:	f3bf 8f6f 	isb	sy
	__ASSERT(((arch_is_in_isr() == false) || (timeout == K_NO_WAIT)), "");

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
   27176:	6894      	ldr	r4, [r2, #8]
   27178:	b144      	cbz	r4, 2718c <z_impl_k_sem_take+0x2c>
		sem->count--;
   2717a:	3c01      	subs	r4, #1
   2717c:	6094      	str	r4, [r2, #8]
	__asm__ volatile(
   2717e:	f381 8811 	msr	BASEPRI, r1
   27182:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
		return 0;
   27186:	2000      	movs	r0, #0

	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);

	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
	return ret;
}
   27188:	bc10      	pop	{r4}
   2718a:	4770      	bx	lr
	if (timeout == K_NO_WAIT) {
   2718c:	b933      	cbnz	r3, 2719c <z_impl_k_sem_take+0x3c>
   2718e:	f381 8811 	msr	BASEPRI, r1
   27192:	f3bf 8f6f 	isb	sy
		return -EBUSY;
   27196:	f06f 000f 	mvn.w	r0, #15
   2719a:	e7f5      	b.n	27188 <z_impl_k_sem_take+0x28>
	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   2719c:	4801      	ldr	r0, [pc, #4]	; (271a4 <z_impl_k_sem_take+0x44>)
}
   2719e:	bc10      	pop	{r4}
	int ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   271a0:	f7ff bea8 	b.w	26ef4 <z_pend_curr>
   271a4:	2000400d 	.word	0x2000400d

000271a8 <k_sys_work_q_init>:
K_THREAD_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(struct device *dev)
{
   271a8:	b510      	push	{r4, lr}
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
   271aa:	4c08      	ldr	r4, [pc, #32]	; (271cc <k_sys_work_q_init+0x24>)
   271ac:	4908      	ldr	r1, [pc, #32]	; (271d0 <k_sys_work_q_init+0x28>)
   271ae:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   271b2:	f44f 6280 	mov.w	r2, #1024	; 0x400
   271b6:	4620      	mov	r0, r4
   271b8:	f000 f91c 	bl	273f4 <k_work_q_start>
	return z_impl_k_thread_name_set(thread_id, value);
   271bc:	4905      	ldr	r1, [pc, #20]	; (271d4 <k_sys_work_q_init+0x2c>)
   271be:	f104 0010 	add.w	r0, r4, #16
   271c2:	f006 f934 	bl	2d42e <z_impl_k_thread_name_set>
		       K_THREAD_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);
	k_thread_name_set(&k_sys_work_q.thread, "sysworkq");

	return 0;
}
   271c6:	2000      	movs	r0, #0
   271c8:	bd10      	pop	{r4, pc}
   271ca:	bf00      	nop
   271cc:	20003b5c 	.word	0x20003b5c
   271d0:	20008210 	.word	0x20008210
   271d4:	000324f2 	.word	0x000324f2

000271d8 <z_impl_k_thread_start>:
}
#endif

#ifdef CONFIG_MULTITHREADING
void z_impl_k_thread_start(struct k_thread *thread)
{
   271d8:	b510      	push	{r4, lr}
   271da:	4602      	mov	r2, r0
	__asm__ volatile(
   271dc:	f04f 0320 	mov.w	r3, #32
   271e0:	f3ef 8411 	mrs	r4, BASEPRI
   271e4:	f383 8811 	msr	BASEPRI, r3
   271e8:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock); /* protect kernel queues */

	if (z_has_thread_started(thread)) {
   271ec:	7b43      	ldrb	r3, [r0, #13]
   271ee:	0759      	lsls	r1, r3, #29
   271f0:	d404      	bmi.n	271fc <z_impl_k_thread_start+0x24>
	__asm__ volatile(
   271f2:	f384 8811 	msr	BASEPRI, r4
   271f6:	f3bf 8f6f 	isb	sy
	}

	z_mark_thread_as_started(thread);
	z_ready_thread(thread);
	z_reschedule(&lock, key);
}
   271fa:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   271fc:	f023 0304 	bic.w	r3, r3, #4
   27200:	7343      	strb	r3, [r0, #13]
	if (z_is_thread_ready(thread)) {
   27202:	f006 f909 	bl	2d418 <z_is_thread_ready>
   27206:	b110      	cbz	r0, 2720e <z_impl_k_thread_start+0x36>
		z_add_thread_to_ready_q(thread);
   27208:	4610      	mov	r0, r2
   2720a:	f7ff fd37 	bl	26c7c <z_add_thread_to_ready_q>
	z_reschedule(&lock, key);
   2720e:	4621      	mov	r1, r4
   27210:	4802      	ldr	r0, [pc, #8]	; (2721c <z_impl_k_thread_start+0x44>)
}
   27212:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&lock, key);
   27216:	f006 b83d 	b.w	2d294 <z_reschedule>
   2721a:	bf00      	nop
   2721c:	2000400d 	.word	0x2000400d

00027220 <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
   27220:	b530      	push	{r4, r5, lr}
   27222:	b087      	sub	sp, #28
   27224:	4604      	mov	r4, r0
	stack_size = STACK_ROUND_DOWN(stack_size
			- sizeof(*new_thread->userspace_local_data));
#endif
#endif

	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   27226:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   27228:	9504      	str	r5, [sp, #16]
   2722a:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   2722c:	9503      	str	r5, [sp, #12]
   2722e:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   27230:	9502      	str	r5, [sp, #8]
   27232:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   27234:	9501      	str	r5, [sp, #4]
   27236:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   27238:	9500      	str	r5, [sp, #0]
   2723a:	f7ec fc99 	bl	13b70 <arch_new_thread>
#ifdef CONFIG_SCHED_CPU_MASK
	new_thread->base.cpu_mask = -1;
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
   2723e:	4b03      	ldr	r3, [pc, #12]	; (2724c <z_setup_new_thread+0x2c>)
   27240:	689b      	ldr	r3, [r3, #8]
   27242:	b103      	cbz	r3, 27246 <z_setup_new_thread+0x26>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
   27244:	6e1b      	ldr	r3, [r3, #96]	; 0x60
   27246:	6623      	str	r3, [r4, #96]	; 0x60
	sys_trace_thread_create(new_thread);
}
   27248:	b007      	add	sp, #28
   2724a:	bd30      	pop	{r4, r5, pc}
   2724c:	20003b20 	.word	0x20003b20

00027250 <z_impl_k_thread_create>:
k_tid_t z_impl_k_thread_create(struct k_thread *new_thread,
			      k_thread_stack_t *stack,
			      size_t stack_size, k_thread_entry_t entry,
			      void *p1, void *p2, void *p3,
			      int prio, u32_t options, s32_t delay)
{
   27250:	b570      	push	{r4, r5, r6, lr}
   27252:	b086      	sub	sp, #24
	__ASSERT((options & K_USER) == 0,
		 "Platform is capable of user mode, and test thread created with K_USER option,"
		 " but neither CONFIG_TEST_USERSPACE nor CONFIG_USERSPACE is set\n");
#endif

	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   27254:	2600      	movs	r6, #0
   27256:	9605      	str	r6, [sp, #20]
   27258:	9e0e      	ldr	r6, [sp, #56]	; 0x38
   2725a:	9604      	str	r6, [sp, #16]
   2725c:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   2725e:	9603      	str	r6, [sp, #12]
   27260:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   27262:	9602      	str	r6, [sp, #8]
   27264:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
{
   27266:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   27268:	9601      	str	r6, [sp, #4]
   2726a:	9e0a      	ldr	r6, [sp, #40]	; 0x28
   2726c:	9600      	str	r6, [sp, #0]
{
   2726e:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   27270:	f7ff ffd6 	bl	27220 <z_setup_new_thread>
			  prio, options, NULL);

	if (delay != K_FOREVER) {
   27274:	1c6b      	adds	r3, r5, #1
   27276:	d003      	beq.n	27280 <z_impl_k_thread_create+0x30>
	if (delay == 0) {
   27278:	b92d      	cbnz	r5, 27286 <z_impl_k_thread_create+0x36>
	z_impl_k_thread_start(thread);
   2727a:	4620      	mov	r0, r4
   2727c:	f7ff ffac 	bl	271d8 <z_impl_k_thread_start>
		schedule_new_thread(new_thread, delay);
	}

	return new_thread;
}
   27280:	4620      	mov	r0, r4
   27282:	b006      	add	sp, #24
   27284:	bd70      	pop	{r4, r5, r6, pc}
			return (u32_t)((t * to_hz + off) / from_hz);
   27286:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   2728a:	f240 30e7 	movw	r0, #999	; 0x3e7
   2728e:	2100      	movs	r1, #0
   27290:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   27294:	2300      	movs	r3, #0
   27296:	fbe6 0105 	umlal	r0, r1, r6, r5
   2729a:	f7e5 f831 	bl	c300 <__aeabi_uldivmod>
   2729e:	4903      	ldr	r1, [pc, #12]	; (272ac <z_impl_k_thread_create+0x5c>)
   272a0:	1c42      	adds	r2, r0, #1
   272a2:	f104 0018 	add.w	r0, r4, #24
   272a6:	f000 f947 	bl	27538 <z_add_timeout>
   272aa:	e7e9      	b.n	27280 <z_impl_k_thread_create+0x30>
   272ac:	0002d31f 	.word	0x0002d31f

000272b0 <z_thread_single_suspend>:
#include <syscalls/k_thread_create_mrsh.c>
#endif /* CONFIG_USERSPACE */
#endif /* CONFIG_MULTITHREADING */

void z_thread_single_suspend(struct k_thread *thread)
{
   272b0:	b510      	push	{r4, lr}
   272b2:	4604      	mov	r4, r0
	if (z_is_thread_ready(thread)) {
   272b4:	f006 f8b0 	bl	2d418 <z_is_thread_ready>
   272b8:	b110      	cbz	r0, 272c0 <z_thread_single_suspend+0x10>
		z_remove_thread_from_ready_q(thread);
   272ba:	4620      	mov	r0, r4
   272bc:	f7ff fd8c 	bl	26dd8 <z_remove_thread_from_ready_q>
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   272c0:	f104 0018 	add.w	r0, r4, #24
   272c4:	f006 f962 	bl	2d58c <z_abort_timeout>
	thread->base.thread_state |= _THREAD_SUSPENDED;
   272c8:	7b63      	ldrb	r3, [r4, #13]
   272ca:	f043 0310 	orr.w	r3, r3, #16
   272ce:	7363      	strb	r3, [r4, #13]

	(void)z_abort_thread_timeout(thread);

	z_mark_thread_as_suspended(thread);

	if (thread == _current) {
   272d0:	4b08      	ldr	r3, [pc, #32]	; (272f4 <z_thread_single_suspend+0x44>)
   272d2:	689b      	ldr	r3, [r3, #8]
   272d4:	42a3      	cmp	r3, r4
   272d6:	d10b      	bne.n	272f0 <z_thread_single_suspend+0x40>
	__asm__ volatile(
   272d8:	f04f 0320 	mov.w	r3, #32
   272dc:	f3ef 8011 	mrs	r0, BASEPRI
   272e0:	f383 8811 	msr	BASEPRI, r3
   272e4:	f3bf 8f6f 	isb	sy
		z_reschedule_unlocked();
	}
}
   272e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
   272ec:	f005 bfdd 	b.w	2d2aa <z_reschedule_irqlock>
   272f0:	bd10      	pop	{r4, pc}
   272f2:	bf00      	nop
   272f4:	20003b20 	.word	0x20003b20

000272f8 <z_impl_k_thread_suspend>:

void z_impl_k_thread_suspend(struct k_thread *thread)
{
   272f8:	b538      	push	{r3, r4, r5, lr}
   272fa:	4605      	mov	r5, r0
   272fc:	f04f 0320 	mov.w	r3, #32
   27300:	f3ef 8411 	mrs	r4, BASEPRI
   27304:	f383 8811 	msr	BASEPRI, r3
   27308:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);

	z_thread_single_suspend(thread);
   2730c:	f7ff ffd0 	bl	272b0 <z_thread_single_suspend>

	sys_trace_thread_suspend(thread);

	if (thread == _current) {
   27310:	4b07      	ldr	r3, [pc, #28]	; (27330 <z_impl_k_thread_suspend+0x38>)
   27312:	689b      	ldr	r3, [r3, #8]
   27314:	42ab      	cmp	r3, r5
   27316:	d105      	bne.n	27324 <z_impl_k_thread_suspend+0x2c>
		z_reschedule(&lock, key);
   27318:	4621      	mov	r1, r4
   2731a:	4806      	ldr	r0, [pc, #24]	; (27334 <z_impl_k_thread_suspend+0x3c>)
	} else {
		k_spin_unlock(&lock, key);
	}
}
   2731c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&lock, key);
   27320:	f005 bfb8 	b.w	2d294 <z_reschedule>
	__asm__ volatile(
   27324:	f384 8811 	msr	BASEPRI, r4
   27328:	f3bf 8f6f 	isb	sy
}
   2732c:	bd38      	pop	{r3, r4, r5, pc}
   2732e:	bf00      	nop
   27330:	20003b20 	.word	0x20003b20
   27334:	2000400d 	.word	0x2000400d

00027338 <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
   27338:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
   2733c:	4e28      	ldr	r6, [pc, #160]	; (273e0 <z_init_static_threads+0xa8>)
   2733e:	4d29      	ldr	r5, [pc, #164]	; (273e4 <z_init_static_threads+0xac>)
{
   27340:	b087      	sub	sp, #28
   27342:	46b0      	mov	r8, r6
	_FOREACH_STATIC_THREAD(thread_data) {
   27344:	42b5      	cmp	r5, r6
   27346:	f105 0430 	add.w	r4, r5, #48	; 0x30
   2734a:	d310      	bcc.n	2736e <z_init_static_threads+0x36>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
   2734c:	f7ff fc32 	bl	26bb4 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   27350:	4c24      	ldr	r4, [pc, #144]	; (273e4 <z_init_static_threads+0xac>)
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   27352:	f8df a094 	ldr.w	sl, [pc, #148]	; 273e8 <z_init_static_threads+0xb0>
   27356:	f44f 4900 	mov.w	r9, #32768	; 0x8000
   2735a:	f240 36e7 	movw	r6, #999	; 0x3e7
   2735e:	2700      	movs	r7, #0
   27360:	4544      	cmp	r4, r8
   27362:	d321      	bcc.n	273a8 <z_init_static_threads+0x70>
			schedule_new_thread(thread_data->init_thread,
					    thread_data->init_delay);
		}
	}
	k_sched_unlock();
}
   27364:	b007      	add	sp, #28
   27366:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	k_sched_unlock();
   2736a:	f7ff bc6b 	b.w	26c44 <k_sched_unlock>
		z_setup_new_thread(
   2736e:	f854 3c04 	ldr.w	r3, [r4, #-4]
   27372:	9305      	str	r3, [sp, #20]
   27374:	f854 3c10 	ldr.w	r3, [r4, #-16]
   27378:	9304      	str	r3, [sp, #16]
   2737a:	f854 3c14 	ldr.w	r3, [r4, #-20]
   2737e:	9303      	str	r3, [sp, #12]
   27380:	f854 3c18 	ldr.w	r3, [r4, #-24]
   27384:	9302      	str	r3, [sp, #8]
   27386:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   2738a:	9301      	str	r3, [sp, #4]
   2738c:	f854 3c20 	ldr.w	r3, [r4, #-32]
   27390:	9300      	str	r3, [sp, #0]
   27392:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
   27396:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
   2739a:	f7ff ff41 	bl	27220 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   2739e:	f854 3c30 	ldr.w	r3, [r4, #-48]
   273a2:	64dd      	str	r5, [r3, #76]	; 0x4c
   273a4:	4625      	mov	r5, r4
   273a6:	e7cd      	b.n	27344 <z_init_static_threads+0xc>
		if (thread_data->init_delay != K_FOREVER) {
   273a8:	6a61      	ldr	r1, [r4, #36]	; 0x24
   273aa:	1c4b      	adds	r3, r1, #1
   273ac:	d004      	beq.n	273b8 <z_init_static_threads+0x80>
			schedule_new_thread(thread_data->init_thread,
   273ae:	6825      	ldr	r5, [r4, #0]
	if (delay == 0) {
   273b0:	b921      	cbnz	r1, 273bc <z_init_static_threads+0x84>
   273b2:	4628      	mov	r0, r5
   273b4:	f7ff ff10 	bl	271d8 <z_impl_k_thread_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   273b8:	3430      	adds	r4, #48	; 0x30
   273ba:	e7d1      	b.n	27360 <z_init_static_threads+0x28>
   273bc:	46b3      	mov	fp, r6
   273be:	46bc      	mov	ip, r7
   273c0:	fbe9 bc01 	umlal	fp, ip, r9, r1
   273c4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   273c8:	2300      	movs	r3, #0
   273ca:	4658      	mov	r0, fp
   273cc:	4661      	mov	r1, ip
   273ce:	f7e4 ff97 	bl	c300 <__aeabi_uldivmod>
   273d2:	4651      	mov	r1, sl
   273d4:	1c42      	adds	r2, r0, #1
   273d6:	f105 0018 	add.w	r0, r5, #24
   273da:	f000 f8ad 	bl	27538 <z_add_timeout>
   273de:	e7eb      	b.n	273b8 <z_init_static_threads+0x80>
   273e0:	200100a4 	.word	0x200100a4
   273e4:	20010044 	.word	0x20010044
   273e8:	0002d31f 	.word	0x0002d31f

000273ec <sys_kernel_version_get>:
 * @return kernel version
 */
u32_t sys_kernel_version_get(void)
{
	return KERNELVERSION;
}
   273ec:	4800      	ldr	r0, [pc, #0]	; (273f0 <sys_kernel_version_get+0x4>)
   273ee:	4770      	bx	lr
   273f0:	02010000 	.word	0x02010000

000273f4 <k_work_q_start>:

extern void z_work_q_main(void *work_q_ptr, void *p2, void *p3);

void k_work_q_start(struct k_work_q *work_q, k_thread_stack_t *stack,
		    size_t stack_size, int prio)
{
   273f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   273f8:	4605      	mov	r5, r0
   273fa:	b086      	sub	sp, #24
   273fc:	460e      	mov	r6, r1
   273fe:	4617      	mov	r7, r2
   27400:	4698      	mov	r8, r3
	z_impl_k_queue_init(queue);
   27402:	f005 fe76 	bl	2d0f2 <z_impl_k_queue_init>
	k_queue_init(&work_q->queue);
	(void)k_thread_create(&work_q->thread, stack, stack_size, z_work_q_main,
   27406:	f105 0410 	add.w	r4, r5, #16
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   2740a:	2000      	movs	r0, #0
   2740c:	e9cd 0004 	strd	r0, r0, [sp, #16]
   27410:	e9cd 0802 	strd	r0, r8, [sp, #8]
   27414:	e9cd 5000 	strd	r5, r0, [sp]
   27418:	4b06      	ldr	r3, [pc, #24]	; (27434 <k_work_q_start+0x40>)
   2741a:	463a      	mov	r2, r7
   2741c:	4631      	mov	r1, r6
   2741e:	4620      	mov	r0, r4
   27420:	f7ff ff16 	bl	27250 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
   27424:	4904      	ldr	r1, [pc, #16]	; (27438 <k_work_q_start+0x44>)
   27426:	4620      	mov	r0, r4
			work_q, NULL, NULL, prio, 0, K_NO_WAIT);

	k_thread_name_set(&work_q->thread, WORKQUEUE_THREAD_NAME);
}
   27428:	b006      	add	sp, #24
   2742a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   2742e:	f005 bffe 	b.w	2d42e <z_impl_k_thread_name_set>
   27432:	bf00      	nop
   27434:	00027de1 	.word	0x00027de1
   27438:	000324fb 	.word	0x000324fb

0002743c <k_delayed_work_submit_to_queue>:
}

int k_delayed_work_submit_to_queue(struct k_work_q *work_q,
				   struct k_delayed_work *work,
				   s32_t delay)
{
   2743c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   27440:	4606      	mov	r6, r0
   27442:	460d      	mov	r5, r1
   27444:	4617      	mov	r7, r2
	__asm__ volatile(
   27446:	f04f 0320 	mov.w	r3, #32
   2744a:	f3ef 8811 	mrs	r8, BASEPRI
   2744e:	f383 8811 	msr	BASEPRI, r3
   27452:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int err = 0;

	/* Work cannot be active in multiple queues */
	if (work->work_q != NULL && work->work_q != work_q) {
   27456:	69cc      	ldr	r4, [r1, #28]
   27458:	b15c      	cbz	r4, 27472 <k_delayed_work_submit_to_queue+0x36>
   2745a:	4284      	cmp	r4, r0
   2745c:	d12c      	bne.n	274b8 <k_delayed_work_submit_to_queue+0x7c>
		goto done;
	}

	/* Cancel if work has been submitted */
	if (work->work_q == work_q) {
		err = work_cancel(work);
   2745e:	4628      	mov	r0, r5
   27460:	f006 f835 	bl	2d4ce <work_cancel>
		if (err < 0) {
   27464:	1e04      	subs	r4, r0, #0
   27466:	da06      	bge.n	27476 <k_delayed_work_submit_to_queue+0x3a>
	__asm__ volatile(
   27468:	f388 8811 	msr	BASEPRI, r8
   2746c:	f3bf 8f6f 	isb	sy
	z_add_timeout(&work->timeout, work_timeout,
		     _TICK_ALIGN + k_ms_to_ticks_ceil32(delay));

done:
	k_spin_unlock(&lock, key);
	return err;
   27470:	e00c      	b.n	2748c <k_delayed_work_submit_to_queue+0x50>
	if (work->work_q == work_q) {
   27472:	2800      	cmp	r0, #0
   27474:	d0f3      	beq.n	2745e <k_delayed_work_submit_to_queue+0x22>
	work->work_q = work_q;
   27476:	61ee      	str	r6, [r5, #28]
	if (delay == 0) {
   27478:	b95f      	cbnz	r7, 27492 <k_delayed_work_submit_to_queue+0x56>
   2747a:	f388 8811 	msr	BASEPRI, r8
   2747e:	f3bf 8f6f 	isb	sy
		k_work_submit_to_queue(work_q, &work->work);
   27482:	4629      	mov	r1, r5
   27484:	4630      	mov	r0, r6
   27486:	f006 f805 	bl	2d494 <k_work_submit_to_queue>
		return 0;
   2748a:	463c      	mov	r4, r7
}
   2748c:	4620      	mov	r0, r4
   2748e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   27492:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   27496:	f240 30e7 	movw	r0, #999	; 0x3e7
   2749a:	2100      	movs	r1, #0
   2749c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   274a0:	2300      	movs	r3, #0
   274a2:	fbe6 0107 	umlal	r0, r1, r6, r7
   274a6:	f7e4 ff2b 	bl	c300 <__aeabi_uldivmod>
	z_add_timeout(&work->timeout, work_timeout,
   274aa:	4905      	ldr	r1, [pc, #20]	; (274c0 <k_delayed_work_submit_to_queue+0x84>)
   274ac:	1c42      	adds	r2, r0, #1
   274ae:	f105 000c 	add.w	r0, r5, #12
   274b2:	f000 f841 	bl	27538 <z_add_timeout>
   274b6:	e7d7      	b.n	27468 <k_delayed_work_submit_to_queue+0x2c>
		err = -EADDRINUSE;
   274b8:	f06f 042f 	mvn.w	r4, #47	; 0x2f
   274bc:	e7d4      	b.n	27468 <k_delayed_work_submit_to_queue+0x2c>
   274be:	bf00      	nop
   274c0:	0002d4c5 	.word	0x0002d4c5

000274c4 <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
   274c4:	4b03      	ldr	r3, [pc, #12]	; (274d4 <elapsed+0x10>)
   274c6:	681b      	ldr	r3, [r3, #0]
   274c8:	b90b      	cbnz	r3, 274ce <elapsed+0xa>
   274ca:	f7ec ba63 	b.w	13994 <z_clock_elapsed>
}
   274ce:	2000      	movs	r0, #0
   274d0:	4770      	bx	lr
   274d2:	bf00      	nop
   274d4:	20003bd8 	.word	0x20003bd8

000274d8 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   274d8:	6803      	ldr	r3, [r0, #0]
   274da:	b140      	cbz	r0, 274ee <remove_timeout+0x16>
   274dc:	4a07      	ldr	r2, [pc, #28]	; (274fc <remove_timeout+0x24>)
	return (node == list->tail) ? NULL : node->next;
   274de:	6852      	ldr	r2, [r2, #4]
   274e0:	4290      	cmp	r0, r2
   274e2:	d004      	beq.n	274ee <remove_timeout+0x16>
	if (next(t) != NULL) {
   274e4:	b11b      	cbz	r3, 274ee <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
   274e6:	689a      	ldr	r2, [r3, #8]
   274e8:	6881      	ldr	r1, [r0, #8]
   274ea:	440a      	add	r2, r1
   274ec:	609a      	str	r2, [r3, #8]
	node->prev->next = node->next;
   274ee:	6842      	ldr	r2, [r0, #4]
   274f0:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   274f2:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   274f4:	2300      	movs	r3, #0
	node->prev = NULL;
   274f6:	e9c0 3300 	strd	r3, r3, [r0]
}
   274fa:	4770      	bx	lr
   274fc:	2000fdfc 	.word	0x2000fdfc

00027500 <next_timeout>:
	return list->head == list;
   27500:	4b0b      	ldr	r3, [pc, #44]	; (27530 <next_timeout+0x30>)

static s32_t next_timeout(void)
{
   27502:	b510      	push	{r4, lr}
   27504:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   27506:	429c      	cmp	r4, r3
   27508:	bf08      	it	eq
   2750a:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	s32_t ticks_elapsed = elapsed();
   2750c:	f7ff ffda 	bl	274c4 <elapsed>
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   27510:	b154      	cbz	r4, 27528 <next_timeout+0x28>
   27512:	68a3      	ldr	r3, [r4, #8]
   27514:	1a18      	subs	r0, r3, r0
   27516:	ea20 70e0 	bic.w	r0, r0, r0, asr #31

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   2751a:	4b06      	ldr	r3, [pc, #24]	; (27534 <next_timeout+0x34>)
   2751c:	691b      	ldr	r3, [r3, #16]
   2751e:	b113      	cbz	r3, 27526 <next_timeout+0x26>
   27520:	4298      	cmp	r0, r3
   27522:	bfa8      	it	ge
   27524:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   27526:	bd10      	pop	{r4, pc}
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   27528:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   2752c:	e7f5      	b.n	2751a <next_timeout+0x1a>
   2752e:	bf00      	nop
   27530:	2000fdfc 	.word	0x2000fdfc
   27534:	20003b20 	.word	0x20003b20

00027538 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn, s32_t ticks)
{
   27538:	b570      	push	{r4, r5, r6, lr}
   2753a:	4604      	mov	r4, r0
   2753c:	4616      	mov	r6, r2
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
   2753e:	60c1      	str	r1, [r0, #12]
	__asm__ volatile(
   27540:	f04f 0320 	mov.w	r3, #32
   27544:	f3ef 8511 	mrs	r5, BASEPRI
   27548:	f383 8811 	msr	BASEPRI, r3
   2754c:	f3bf 8f6f 	isb	sy
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
   27550:	f7ff ffb8 	bl	274c4 <elapsed>
	return list->head == list;
   27554:	4b18      	ldr	r3, [pc, #96]	; (275b8 <z_add_timeout+0x80>)
   27556:	681a      	ldr	r2, [r3, #0]
   27558:	2e01      	cmp	r6, #1
   2755a:	bfac      	ite	ge
   2755c:	1980      	addge	r0, r0, r6
   2755e:	3001      	addlt	r0, #1
	return sys_dlist_is_empty(list) ? NULL : list->head;
   27560:	429a      	cmp	r2, r3
   27562:	60a0      	str	r0, [r4, #8]
   27564:	d001      	beq.n	2756a <z_add_timeout+0x32>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   27566:	685e      	ldr	r6, [r3, #4]
		for (t = first(); t != NULL; t = next(t)) {
   27568:	b932      	cbnz	r2, 27578 <z_add_timeout+0x40>
	node->prev = list->tail;
   2756a:	685a      	ldr	r2, [r3, #4]
   2756c:	6062      	str	r2, [r4, #4]
	list->tail->next = node;
   2756e:	685a      	ldr	r2, [r3, #4]
	node->next = list;
   27570:	6023      	str	r3, [r4, #0]
	list->tail->next = node;
   27572:	6014      	str	r4, [r2, #0]
	list->tail = node;
   27574:	605c      	str	r4, [r3, #4]
   27576:	e00a      	b.n	2758e <z_add_timeout+0x56>
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
   27578:	6890      	ldr	r0, [r2, #8]
   2757a:	68a1      	ldr	r1, [r4, #8]
   2757c:	4288      	cmp	r0, r1
   2757e:	dd15      	ble.n	275ac <z_add_timeout+0x74>
				t->dticks -= to->dticks;
   27580:	1a41      	subs	r1, r0, r1
   27582:	6091      	str	r1, [r2, #8]
	node->prev = successor->prev;
   27584:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
   27586:	e9c4 2100 	strd	r2, r1, [r4]
	successor->prev->next = node;
   2758a:	600c      	str	r4, [r1, #0]
	successor->prev = node;
   2758c:	6054      	str	r4, [r2, #4]
	return list->head == list;
   2758e:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   27590:	429a      	cmp	r2, r3
   27592:	d006      	beq.n	275a2 <z_add_timeout+0x6a>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   27594:	4294      	cmp	r4, r2
   27596:	d104      	bne.n	275a2 <z_add_timeout+0x6a>
			z_clock_set_timeout(next_timeout(), false);
   27598:	f7ff ffb2 	bl	27500 <next_timeout>
   2759c:	2100      	movs	r1, #0
   2759e:	f7ec f9a3 	bl	138e8 <z_clock_set_timeout>
	__asm__ volatile(
   275a2:	f385 8811 	msr	BASEPRI, r5
   275a6:	f3bf 8f6f 	isb	sy
		}
	}
}
   275aa:	bd70      	pop	{r4, r5, r6, pc}
			to->dticks -= t->dticks;
   275ac:	1a09      	subs	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
   275ae:	42b2      	cmp	r2, r6
   275b0:	60a1      	str	r1, [r4, #8]
   275b2:	d0da      	beq.n	2756a <z_add_timeout+0x32>
   275b4:	6812      	ldr	r2, [r2, #0]
   275b6:	e7d7      	b.n	27568 <z_add_timeout+0x30>
   275b8:	2000fdfc 	.word	0x2000fdfc

000275bc <z_timeout_remaining>:

	return ret;
}

s32_t z_timeout_remaining(struct _timeout *timeout)
{
   275bc:	b538      	push	{r3, r4, r5, lr}
	s32_t ticks = 0;

	if (z_is_inactive_timeout(timeout)) {
   275be:	6804      	ldr	r4, [r0, #0]
   275c0:	b314      	cbz	r4, 27608 <z_timeout_remaining+0x4c>
	__asm__ volatile(
   275c2:	f04f 0320 	mov.w	r3, #32
   275c6:	f3ef 8111 	mrs	r1, BASEPRI
   275ca:	f383 8811 	msr	BASEPRI, r3
   275ce:	f3bf 8f6f 	isb	sy
	return list->head == list;
   275d2:	4a0e      	ldr	r2, [pc, #56]	; (2760c <z_timeout_remaining+0x50>)
   275d4:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   275d6:	4293      	cmp	r3, r2
   275d8:	d014      	beq.n	27604 <z_timeout_remaining+0x48>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   275da:	6852      	ldr	r2, [r2, #4]
   275dc:	2400      	movs	r4, #0
		return 0;
	}

	LOCKED(&timeout_lock) {
		for (struct _timeout *t = first(); t != NULL; t = next(t)) {
   275de:	b93b      	cbnz	r3, 275f0 <z_timeout_remaining+0x34>
	__asm__ volatile(
   275e0:	f381 8811 	msr	BASEPRI, r1
   275e4:	f3bf 8f6f 	isb	sy
				break;
			}
		}
	}

	return ticks - elapsed();
   275e8:	f7ff ff6c 	bl	274c4 <elapsed>
   275ec:	1a20      	subs	r0, r4, r0
}
   275ee:	bd38      	pop	{r3, r4, r5, pc}
			ticks += t->dticks;
   275f0:	689d      	ldr	r5, [r3, #8]
			if (timeout == t) {
   275f2:	4283      	cmp	r3, r0
			ticks += t->dticks;
   275f4:	442c      	add	r4, r5
			if (timeout == t) {
   275f6:	d0f3      	beq.n	275e0 <z_timeout_remaining+0x24>
   275f8:	2b00      	cmp	r3, #0
   275fa:	d0f1      	beq.n	275e0 <z_timeout_remaining+0x24>
	return (node == list->tail) ? NULL : node->next;
   275fc:	4293      	cmp	r3, r2
   275fe:	d0ef      	beq.n	275e0 <z_timeout_remaining+0x24>
   27600:	681b      	ldr	r3, [r3, #0]
   27602:	e7ec      	b.n	275de <z_timeout_remaining+0x22>
	return sys_dlist_is_empty(list) ? NULL : list->head;
   27604:	2400      	movs	r4, #0
   27606:	e7eb      	b.n	275e0 <z_timeout_remaining+0x24>
		return 0;
   27608:	4620      	mov	r0, r4
   2760a:	e7f0      	b.n	275ee <z_timeout_remaining+0x32>
   2760c:	2000fdfc 	.word	0x2000fdfc

00027610 <z_clock_announce>:
		}
	}
}

void z_clock_announce(s32_t ticks)
{
   27610:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
   27614:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   27616:	f7ff fba9 	bl	26d6c <z_time_slice>
	__asm__ volatile(
   2761a:	f04f 0320 	mov.w	r3, #32
   2761e:	f3ef 8511 	mrs	r5, BASEPRI
   27622:	f383 8811 	msr	BASEPRI, r3
   27626:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   2762a:	4e21      	ldr	r6, [pc, #132]	; (276b0 <z_clock_announce+0xa0>)
   2762c:	4f21      	ldr	r7, [pc, #132]	; (276b4 <z_clock_announce+0xa4>)
	return list->head == list;
   2762e:	f8df 9088 	ldr.w	r9, [pc, #136]	; 276b8 <z_clock_announce+0xa8>
   27632:	6034      	str	r4, [r6, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
   27634:	46b8      	mov	r8, r7
   27636:	f8d9 4000 	ldr.w	r4, [r9]
   2763a:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2763c:	454c      	cmp	r4, r9
   2763e:	e9d7 bc00 	ldrd	fp, ip, [r7]
   27642:	d005      	beq.n	27650 <z_clock_announce+0x40>
   27644:	b124      	cbz	r4, 27650 <z_clock_announce+0x40>
   27646:	68a3      	ldr	r3, [r4, #8]
   27648:	4293      	cmp	r3, r2
   2764a:	dd14      	ble.n	27676 <z_clock_announce+0x66>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   2764c:	1a9b      	subs	r3, r3, r2
   2764e:	60a3      	str	r3, [r4, #8]
	}

	curr_tick += announce_remaining;
   27650:	eb1b 0002 	adds.w	r0, fp, r2
   27654:	eb4c 71e2 	adc.w	r1, ip, r2, asr #31
	announce_remaining = 0;
   27658:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
   2765a:	e9c8 0100 	strd	r0, r1, [r8]
	announce_remaining = 0;
   2765e:	6034      	str	r4, [r6, #0]

	z_clock_set_timeout(next_timeout(), false);
   27660:	f7ff ff4e 	bl	27500 <next_timeout>
   27664:	4621      	mov	r1, r4
   27666:	f7ec f93f 	bl	138e8 <z_clock_set_timeout>
	__asm__ volatile(
   2766a:	f385 8811 	msr	BASEPRI, r5
   2766e:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   27672:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
		curr_tick += dt;
   27676:	eb1b 0003 	adds.w	r0, fp, r3
   2767a:	eb4c 71e3 	adc.w	r1, ip, r3, asr #31
		announce_remaining -= dt;
   2767e:	1ad3      	subs	r3, r2, r3
   27680:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
   27682:	2300      	movs	r3, #0
		curr_tick += dt;
   27684:	e9c7 0100 	strd	r0, r1, [r7]
		t->dticks = 0;
   27688:	60a3      	str	r3, [r4, #8]
		remove_timeout(t);
   2768a:	4620      	mov	r0, r4
   2768c:	f7ff ff24 	bl	274d8 <remove_timeout>
   27690:	f385 8811 	msr	BASEPRI, r5
   27694:	f3bf 8f6f 	isb	sy
		t->fn(t);
   27698:	68e3      	ldr	r3, [r4, #12]
   2769a:	4798      	blx	r3
	__asm__ volatile(
   2769c:	f04f 0320 	mov.w	r3, #32
   276a0:	f3ef 8511 	mrs	r5, BASEPRI
   276a4:	f383 8811 	msr	BASEPRI, r3
   276a8:	f3bf 8f6f 	isb	sy
#endif

#ifdef SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
   276ac:	e7c3      	b.n	27636 <z_clock_announce+0x26>
   276ae:	bf00      	nop
   276b0:	20003bd8 	.word	0x20003bd8
   276b4:	20000010 	.word	0x20000010
   276b8:	2000fdfc 	.word	0x2000fdfc

000276bc <z_tick_get>:

s64_t z_tick_get(void)
{
   276bc:	e92d 4818 	stmdb	sp!, {r3, r4, fp, lr}
   276c0:	f04f 0320 	mov.w	r3, #32
   276c4:	f3ef 8411 	mrs	r4, BASEPRI
   276c8:	f383 8811 	msr	BASEPRI, r3
   276cc:	f3bf 8f6f 	isb	sy
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
   276d0:	f7ec f960 	bl	13994 <z_clock_elapsed>
   276d4:	4b07      	ldr	r3, [pc, #28]	; (276f4 <z_tick_get+0x38>)
   276d6:	e9d3 2300 	ldrd	r2, r3, [r3]
   276da:	eb12 0b00 	adds.w	fp, r2, r0
   276de:	f143 0c00 	adc.w	ip, r3, #0
   276e2:	4658      	mov	r0, fp
   276e4:	4661      	mov	r1, ip
	__asm__ volatile(
   276e6:	f384 8811 	msr	BASEPRI, r4
   276ea:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   276ee:	e8bd 8818 	ldmia.w	sp!, {r3, r4, fp, pc}
   276f2:	bf00      	nop
   276f4:	20000010 	.word	0x20000010

000276f8 <z_timer_expiration_handler>:

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (timer->period > 0) {
   276f8:	6a02      	ldr	r2, [r0, #32]
   276fa:	2a00      	cmp	r2, #0
{
   276fc:	b538      	push	{r3, r4, r5, lr}
   276fe:	4604      	mov	r4, r0
	if (timer->period > 0) {
   27700:	dd02      	ble.n	27708 <z_timer_expiration_handler+0x10>
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   27702:	490e      	ldr	r1, [pc, #56]	; (2773c <z_timer_expiration_handler+0x44>)
   27704:	f7ff ff18 	bl	27538 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
   27708:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2770a:	3301      	adds	r3, #1
   2770c:	6263      	str	r3, [r4, #36]	; 0x24

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   2770e:	69a3      	ldr	r3, [r4, #24]
   27710:	b10b      	cbz	r3, 27716 <z_timer_expiration_handler+0x1e>
		timer->expiry_fn(timer);
   27712:	4620      	mov	r0, r4
   27714:	4798      	blx	r3
	return list->head == list;
   27716:	f854 5f10 	ldr.w	r5, [r4, #16]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2771a:	42a5      	cmp	r5, r4
   2771c:	d00d      	beq.n	2773a <z_timer_expiration_handler+0x42>
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   2771e:	b165      	cbz	r5, 2773a <z_timer_expiration_handler+0x42>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
   27720:	4628      	mov	r0, r5
   27722:	f005 fd9e 	bl	2d262 <z_unpend_thread_no_timeout>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   27726:	7b6b      	ldrb	r3, [r5, #13]
   27728:	06db      	lsls	r3, r3, #27
   2772a:	d104      	bne.n	27736 <z_timer_expiration_handler+0x3e>
	if (z_is_thread_ready(thread)) {
   2772c:	69ab      	ldr	r3, [r5, #24]
   2772e:	b913      	cbnz	r3, 27736 <z_timer_expiration_handler+0x3e>
		z_add_thread_to_ready_q(thread);
   27730:	4628      	mov	r0, r5
   27732:	f7ff faa3 	bl	26c7c <z_add_thread_to_ready_q>
   27736:	2300      	movs	r3, #0
   27738:	66ab      	str	r3, [r5, #104]	; 0x68

	z_ready_thread(thread);

	arch_thread_return_value_set(thread, 0);
}
   2773a:	bd38      	pop	{r3, r4, r5, pc}
   2773c:	000276f9 	.word	0x000276f9

00027740 <z_impl_k_timer_start>:
	z_object_init(timer);
}


void z_impl_k_timer_start(struct k_timer *timer, s32_t duration, s32_t period)
{
   27740:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   27744:	f240 36e7 	movw	r6, #999	; 0x3e7
   27748:	2700      	movs	r7, #0
   2774a:	4604      	mov	r4, r0
   2774c:	4688      	mov	r8, r1
   2774e:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   27752:	4630      	mov	r0, r6
   27754:	4639      	mov	r1, r7
   27756:	fbe5 0102 	umlal	r0, r1, r5, r2
   2775a:	2300      	movs	r3, #0
   2775c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   27760:	f7e4 fdce 	bl	c300 <__aeabi_uldivmod>
   27764:	4639      	mov	r1, r7
	__ASSERT(duration >= 0 && period >= 0 &&
		 (duration != 0 || period != 0), "invalid parameters\n");

	volatile s32_t period_in_ticks, duration_in_ticks;

	period_in_ticks = k_ms_to_ticks_ceil32(period);
   27766:	9000      	str	r0, [sp, #0]
   27768:	4630      	mov	r0, r6
   2776a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2776e:	2300      	movs	r3, #0
   27770:	fbe5 0108 	umlal	r0, r1, r5, r8
   27774:	f7e4 fdc4 	bl	c300 <__aeabi_uldivmod>
	duration_in_ticks = k_ms_to_ticks_ceil32(duration);
   27778:	9001      	str	r0, [sp, #4]

	(void)z_abort_timeout(&timer->timeout);
   2777a:	4620      	mov	r0, r4
   2777c:	f005 ff06 	bl	2d58c <z_abort_timeout>
	timer->period = period_in_ticks;
   27780:	9b00      	ldr	r3, [sp, #0]
	timer->status = 0U;
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   27782:	4905      	ldr	r1, [pc, #20]	; (27798 <z_impl_k_timer_start+0x58>)
   27784:	9a01      	ldr	r2, [sp, #4]
	timer->period = period_in_ticks;
   27786:	6223      	str	r3, [r4, #32]
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   27788:	4620      	mov	r0, r4
	timer->status = 0U;
   2778a:	2300      	movs	r3, #0
   2778c:	6263      	str	r3, [r4, #36]	; 0x24
		     duration_in_ticks);
}
   2778e:	b002      	add	sp, #8
   27790:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   27794:	f7ff bed0 	b.w	27538 <z_add_timeout>
   27798:	000276f9 	.word	0x000276f9

0002779c <k_poll_event_init>:
 */
static struct k_spinlock lock;

void k_poll_event_init(struct k_poll_event *event, u32_t type,
		       int mode, void *obj)
{
   2779c:	b510      	push	{r4, lr}
	__ASSERT(type < (BIT(_POLL_NUM_TYPES)), "invalid type\n");
	__ASSERT(obj != NULL, "must provide an object\n");

	event->poller = NULL;
	/* event->tag is left uninitialized: the user will set it if needed */
	event->type = type;
   2779e:	7b44      	ldrb	r4, [r0, #13]
   277a0:	f361 0403 	bfi	r4, r1, #0, #4
	event->state = K_POLL_STATE_NOT_READY;
	event->mode = mode;
   277a4:	7b81      	ldrb	r1, [r0, #14]
	event->type = type;
   277a6:	7344      	strb	r4, [r0, #13]
	event->mode = mode;
   277a8:	f362 0141 	bfi	r1, r2, #1, #1
   277ac:	7381      	strb	r1, [r0, #14]
	event->poller = NULL;
   277ae:	2200      	movs	r2, #0
	event->state = K_POLL_STATE_NOT_READY;
   277b0:	68c1      	ldr	r1, [r0, #12]
	event->poller = NULL;
   277b2:	6082      	str	r2, [r0, #8]
	event->state = K_POLL_STATE_NOT_READY;
   277b4:	4a02      	ldr	r2, [pc, #8]	; (277c0 <k_poll_event_init+0x24>)
   277b6:	400a      	ands	r2, r1
	event->unused = 0U;
	event->obj = obj;
   277b8:	e9c0 2303 	strd	r2, r3, [r0, #12]
}
   277bc:	bd10      	pop	{r4, pc}
   277be:	bf00      	nop
   277c0:	00020fff 	.word	0x00020fff

000277c4 <z_impl_k_poll>:

	return 0;
}

int z_impl_k_poll(struct k_poll_event *events, int num_events, s32_t timeout)
{
   277c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   277c8:	b086      	sub	sp, #24
	int events_registered;
	k_spinlock_key_t key;
	struct _poller poller = { .is_polling = true,
   277ca:	2301      	movs	r3, #1
   277cc:	f88d 300c 	strb.w	r3, [sp, #12]
				  .thread     = _current,
   277d0:	4b23      	ldr	r3, [pc, #140]	; (27860 <z_impl_k_poll+0x9c>)
	struct _poller poller = { .is_polling = true,
   277d2:	689b      	ldr	r3, [r3, #8]
   277d4:	9304      	str	r3, [sp, #16]
   277d6:	4b23      	ldr	r3, [pc, #140]	; (27864 <z_impl_k_poll+0xa0>)
   277d8:	9305      	str	r3, [sp, #20]

	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(events != NULL, "NULL events\n");
	__ASSERT(num_events > 0, "zero events\n");

	events_registered = register_events(events, num_events, &poller,
   277da:	fab2 f382 	clz	r3, r2
   277de:	4690      	mov	r8, r2
   277e0:	095b      	lsrs	r3, r3, #5
   277e2:	aa03      	add	r2, sp, #12
{
   277e4:	4606      	mov	r6, r0
	events_registered = register_events(events, num_events, &poller,
   277e6:	f005 ffee 	bl	2d7c6 <register_events>
   277ea:	4607      	mov	r7, r0
	__asm__ volatile(
   277ec:	f04f 0320 	mov.w	r3, #32
   277f0:	f3ef 8511 	mrs	r5, BASEPRI
   277f4:	f383 8811 	msr	BASEPRI, r3
   277f8:	f3bf 8f6f 	isb	sy
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller.is_polling) {
   277fc:	f89d 300c 	ldrb.w	r3, [sp, #12]
   27800:	f003 04ff 	and.w	r4, r3, #255	; 0xff
   27804:	b94b      	cbnz	r3, 2781a <z_impl_k_poll+0x56>
	 * we've already know the return code (-EAGAIN), and even if they are
	 * added to the list of events that occurred, the user has to check the
	 * return code first, which invalidates the whole list of event states.
	 */
	key = k_spin_lock(&lock);
	clear_event_registrations(events, events_registered, key);
   27806:	462a      	mov	r2, r5
   27808:	4639      	mov	r1, r7
   2780a:	4630      	mov	r0, r6
   2780c:	f005 ff43 	bl	2d696 <clear_event_registrations>
	__asm__ volatile(
   27810:	f385 8811 	msr	BASEPRI, r5
   27814:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	return swap_rc;
   27818:	e00b      	b.n	27832 <z_impl_k_poll+0x6e>
	poller.is_polling = false;
   2781a:	2300      	movs	r3, #0
   2781c:	f88d 300c 	strb.w	r3, [sp, #12]
	if (timeout == K_NO_WAIT) {
   27820:	f1b8 0f00 	cmp.w	r8, #0
   27824:	d109      	bne.n	2783a <z_impl_k_poll+0x76>
   27826:	f385 8811 	msr	BASEPRI, r5
   2782a:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
   2782e:	f06f 040a 	mvn.w	r4, #10
}
   27832:	4620      	mov	r0, r4
   27834:	b006      	add	sp, #24
   27836:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   2783a:	aa01      	add	r2, sp, #4
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   2783c:	4643      	mov	r3, r8
   2783e:	4629      	mov	r1, r5
   27840:	4809      	ldr	r0, [pc, #36]	; (27868 <z_impl_k_poll+0xa4>)
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   27842:	e9cd 2201 	strd	r2, r2, [sp, #4]
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   27846:	f7ff fb55 	bl	26ef4 <z_pend_curr>
   2784a:	4604      	mov	r4, r0
	__asm__ volatile(
   2784c:	f04f 0320 	mov.w	r3, #32
   27850:	f3ef 8511 	mrs	r5, BASEPRI
   27854:	f383 8811 	msr	BASEPRI, r3
   27858:	f3bf 8f6f 	isb	sy
   2785c:	e7d3      	b.n	27806 <z_impl_k_poll+0x42>
   2785e:	bf00      	nop
   27860:	20003b20 	.word	0x20003b20
   27864:	0002d727 	.word	0x0002d727
   27868:	2000400d 	.word	0x2000400d

0002786c <z_impl_k_poll_signal_raise>:
}
#include <syscalls/k_poll_signal_check_mrsh.c>
#endif

int z_impl_k_poll_signal_raise(struct k_poll_signal *signal, int result)
{
   2786c:	b538      	push	{r3, r4, r5, lr}
   2786e:	f04f 0320 	mov.w	r3, #32
   27872:	f3ef 8511 	mrs	r5, BASEPRI
   27876:	f383 8811 	msr	BASEPRI, r3
   2787a:	f3bf 8f6f 	isb	sy
	return list->head == list;
   2787e:	6803      	ldr	r3, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_poll_event *poll_event;

	signal->result = result;
   27880:	60c1      	str	r1, [r0, #12]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
   27882:	4298      	cmp	r0, r3
	signal->signaled = 1U;
   27884:	f04f 0101 	mov.w	r1, #1
   27888:	6081      	str	r1, [r0, #8]
   2788a:	d106      	bne.n	2789a <z_impl_k_poll_signal_raise+0x2e>
	__asm__ volatile(
   2788c:	f385 8811 	msr	BASEPRI, r5
   27890:	f3bf 8f6f 	isb	sy

	poll_event = (struct k_poll_event *)sys_dlist_get(&signal->poll_events);
	if (poll_event == NULL) {
		k_spin_unlock(&lock, key);
		return 0;
   27894:	2400      	movs	r4, #0

	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);

	z_reschedule(&lock, key);
	return rc;
}
   27896:	4620      	mov	r0, r4
   27898:	bd38      	pop	{r3, r4, r5, pc}
	node->prev->next = node->next;
   2789a:	e9d3 2000 	ldrd	r2, r0, [r3]
   2789e:	6002      	str	r2, [r0, #0]
	node->next->prev = node->prev;
   278a0:	6050      	str	r0, [r2, #4]
	node->next = NULL;
   278a2:	2200      	movs	r2, #0
	node->prev = NULL;
   278a4:	e9c3 2200 	strd	r2, r2, [r3]
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   278a8:	4618      	mov	r0, r3
   278aa:	f005 ff21 	bl	2d6f0 <signal_poll_event>
	z_reschedule(&lock, key);
   278ae:	4629      	mov	r1, r5
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
   278b0:	4604      	mov	r4, r0
	z_reschedule(&lock, key);
   278b2:	4802      	ldr	r0, [pc, #8]	; (278bc <z_impl_k_poll_signal_raise+0x50>)
   278b4:	f005 fcee 	bl	2d294 <z_reschedule>
	return rc;
   278b8:	e7ed      	b.n	27896 <z_impl_k_poll_signal_raise+0x2a>
   278ba:	bf00      	nop
   278bc:	2000400d 	.word	0x2000400d

000278c0 <data_cb>:
{
   278c0:	b508      	push	{r3, lr}
   278c2:	4603      	mov	r3, r0
   278c4:	4608      	mov	r0, r1
    switch (data->type) {
   278c6:	781a      	ldrb	r2, [r3, #0]
   278c8:	3a08      	subs	r2, #8
   278ca:	2a01      	cmp	r2, #1
   278cc:	d808      	bhi.n	278e0 <data_cb+0x20>
        memcpy(name, data->data, MIN(data->data_len, NAME_LEN - 1));
   278ce:	785a      	ldrb	r2, [r3, #1]
   278d0:	6859      	ldr	r1, [r3, #4]
   278d2:	2a1d      	cmp	r2, #29
   278d4:	bf28      	it	cs
   278d6:	221d      	movcs	r2, #29
   278d8:	f002 fdb9 	bl	2a44e <memcpy>
   278dc:	2000      	movs	r0, #0
}
   278de:	bd08      	pop	{r3, pc}
        return true;
   278e0:	2001      	movs	r0, #1
   278e2:	e7fc      	b.n	278de <data_cb+0x1e>

000278e4 <str2bt_addr>:
{
   278e4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   278e8:	4606      	mov	r6, r0
   278ea:	460f      	mov	r7, r1
    if (strlen(str) != ((size * 2U) + (size - 1))) {
   278ec:	f002 fd66 	bl	2a3bc <strlen>
   278f0:	2811      	cmp	r0, #17
   278f2:	d004      	beq.n	278fe <str2bt_addr+0x1a>
        return -EINVAL;
   278f4:	f06f 0015 	mvn.w	r0, #21
}
   278f8:	b002      	add	sp, #8
   278fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   278fe:	1e75      	subs	r5, r6, #1
    for (i = size - 1, j = 1; *str != '\0'; str++, j++) {
   27900:	2405      	movs	r4, #5
   27902:	f1c6 0602 	rsb	r6, r6, #2
        if (!(j % 3) && (*str != ':')) {
   27906:	f04f 0803 	mov.w	r8, #3
   2790a:	1972      	adds	r2, r6, r5
    for (i = size - 1, j = 1; *str != '\0'; str++, j++) {
   2790c:	f815 0f01 	ldrb.w	r0, [r5, #1]!
   27910:	2800      	cmp	r0, #0
   27912:	d0f1      	beq.n	278f8 <str2bt_addr+0x14>
        if (!(j % 3) && (*str != ':')) {
   27914:	fb92 f3f8 	sdiv	r3, r2, r8
   27918:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   2791c:	429a      	cmp	r2, r3
   2791e:	d103      	bne.n	27928 <str2bt_addr+0x44>
   27920:	283a      	cmp	r0, #58	; 0x3a
   27922:	d1e7      	bne.n	278f4 <str2bt_addr+0x10>
            i--;
   27924:	3c01      	subs	r4, #1
            continue;
   27926:	e7f0      	b.n	2790a <str2bt_addr+0x26>
        } else if (*str == ':') {
   27928:	283a      	cmp	r0, #58	; 0x3a
   2792a:	d0fb      	beq.n	27924 <str2bt_addr+0x40>
        array[i] = array[i] << 4;
   2792c:	5d3b      	ldrb	r3, [r7, r4]
   2792e:	011b      	lsls	r3, r3, #4
   27930:	553b      	strb	r3, [r7, r4]
        if (char2hex(*str, &tmp) < 0) {
   27932:	f10d 0107 	add.w	r1, sp, #7
   27936:	7828      	ldrb	r0, [r5, #0]
   27938:	f000 f876 	bl	27a28 <char2hex>
   2793c:	2800      	cmp	r0, #0
   2793e:	dbd9      	blt.n	278f4 <str2bt_addr+0x10>
        array[i] |= tmp;
   27940:	5d3b      	ldrb	r3, [r7, r4]
   27942:	f89d 2007 	ldrb.w	r2, [sp, #7]
   27946:	4313      	orrs	r3, r2
   27948:	553b      	strb	r3, [r7, r4]
   2794a:	e7de      	b.n	2790a <str2bt_addr+0x26>

0002794c <conn_addr_str>:
{
   2794c:	b570      	push	{r4, r5, r6, lr}
   2794e:	b088      	sub	sp, #32
   27950:	460c      	mov	r4, r1
    if (bt_conn_get_info(conn, &info) < 0) {
   27952:	a901      	add	r1, sp, #4
{
   27954:	4606      	mov	r6, r0
   27956:	4615      	mov	r5, r2
    if (bt_conn_get_info(conn, &info) < 0) {
   27958:	f7f0 fbf4 	bl	18144 <bt_conn_get_info>
   2795c:	2800      	cmp	r0, #0
   2795e:	da03      	bge.n	27968 <conn_addr_str+0x1c>
        addr[0] = '\0';
   27960:	2300      	movs	r3, #0
   27962:	7023      	strb	r3, [r4, #0]
}
   27964:	b008      	add	sp, #32
   27966:	bd70      	pop	{r4, r5, r6, pc}
    switch (info.type) {
   27968:	f89d 3004 	ldrb.w	r3, [sp, #4]
   2796c:	2b01      	cmp	r3, #1
   2796e:	d1f9      	bne.n	27964 <conn_addr_str+0x18>
        bt_addr_le_to_str(bt_conn_get_dst(conn), addr, len);
   27970:	4630      	mov	r0, r6
   27972:	f003 f84c 	bl	2aa0e <bt_conn_get_dst>
   27976:	462a      	mov	r2, r5
   27978:	4621      	mov	r1, r4
   2797a:	f7e7 fa45 	bl	ee08 <bt_addr_le_to_str>
        break;
   2797e:	e7f1      	b.n	27964 <conn_addr_str+0x18>

00027980 <k_sleep>:
	return z_impl_k_sleep(ms);
   27980:	f7ff bb94 	b.w	270ac <z_impl_k_sleep>

00027984 <k_msgq_put.constprop.6>:
	return z_impl_k_msgq_put(q, data, timeout);
   27984:	2200      	movs	r2, #0
   27986:	f7fe bf71 	b.w	2686c <z_impl_k_msgq_put>

0002798a <dfu_confirm_image>:
    return boot_write_img_confirmed();
   2798a:	f002 ba8b 	b.w	29ea4 <boot_write_img_confirmed>

0002798e <cmp_version>:
#include <flash_map.h>

LOG_MODULE_REGISTER(image, 4);

int cmp_version(struct image_version *v1, struct image_version *v2)
{
   2798e:	b5f0      	push	{r4, r5, r6, r7, lr}
    int major     = v1->iv_major - v2->iv_major;
   27990:	780f      	ldrb	r7, [r1, #0]
   27992:	7803      	ldrb	r3, [r0, #0]
    int minor     = v1->iv_minor - v2->iv_minor;
   27994:	7846      	ldrb	r6, [r0, #1]
    int revision  = v1->iv_revision - v2->iv_revision;
   27996:	8844      	ldrh	r4, [r0, #2]
    int build_num = v1->iv_build_num - v2->iv_build_num;
   27998:	f8d0 c004 	ldr.w	ip, [r0, #4]
    int minor     = v1->iv_minor - v2->iv_minor;
   2799c:	784d      	ldrb	r5, [r1, #1]
    int revision  = v1->iv_revision - v2->iv_revision;
   2799e:	884a      	ldrh	r2, [r1, #2]
    int build_num = v1->iv_build_num - v2->iv_build_num;
   279a0:	6849      	ldr	r1, [r1, #4]

    if (major) {
   279a2:	1bd8      	subs	r0, r3, r7
   279a4:	d105      	bne.n	279b2 <cmp_version+0x24>
        return major;
    }
    if (minor) {
   279a6:	1b70      	subs	r0, r6, r5
   279a8:	d103      	bne.n	279b2 <cmp_version+0x24>
        return minor;
    }
    if (revision) {
   279aa:	1aa0      	subs	r0, r4, r2
    int build_num = v1->iv_build_num - v2->iv_build_num;
   279ac:	bf08      	it	eq
   279ae:	ebac 0001 	subeq.w	r0, ip, r1
        return revision;
    }
    return build_num;
}
   279b2:	bdf0      	pop	{r4, r5, r6, r7, pc}

000279b4 <read_image_info>:

int read_image_info(int area_id, uint32_t *size, struct image_version *version)
{
   279b4:	b530      	push	{r4, r5, lr}
   279b6:	b08b      	sub	sp, #44	; 0x2c
   279b8:	460d      	mov	r5, r1
    const struct flash_area *fap;
    struct image_tlv_info info;
    struct image_header hdr;
    int rc = 0;

    rc = flash_area_open(area_id, &fap);
   279ba:	b2c0      	uxtb	r0, r0
   279bc:	4669      	mov	r1, sp
{
   279be:	4614      	mov	r4, r2
    rc = flash_area_open(area_id, &fap);
   279c0:	f7eb fea2 	bl	13708 <flash_area_open>
    if (rc != 0) {
   279c4:	4601      	mov	r1, r0
   279c6:	b138      	cbz	r0, 279d8 <read_image_info+0x24>
        rc = -1;
   279c8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        goto done;
    }
    *size = hdr.ih_hdr_size + hdr.ih_img_size + info.it_tlv_tot;

done:
    flash_area_close(fap);
   279cc:	9800      	ldr	r0, [sp, #0]
   279ce:	f002 fae0 	bl	29f92 <flash_area_close>
    return rc;
}
   279d2:	4620      	mov	r0, r4
   279d4:	b00b      	add	sp, #44	; 0x2c
   279d6:	bd30      	pop	{r4, r5, pc}
    rc = flash_area_read(fap, 0, &hdr, sizeof(hdr));
   279d8:	2320      	movs	r3, #32
   279da:	aa02      	add	r2, sp, #8
   279dc:	9800      	ldr	r0, [sp, #0]
   279de:	f002 fad9 	bl	29f94 <flash_area_read>
    if (rc != 0) {
   279e2:	2800      	cmp	r0, #0
   279e4:	d1f0      	bne.n	279c8 <read_image_info+0x14>
    memcpy(version, &hdr.ih_ver, sizeof hdr.ih_ver);
   279e6:	2208      	movs	r2, #8
   279e8:	a907      	add	r1, sp, #28
   279ea:	4620      	mov	r0, r4
   279ec:	f002 fd2f 	bl	2a44e <memcpy>
    rc = flash_area_read(fap, hdr.ih_hdr_size + hdr.ih_img_size, &info, sizeof(info));
   279f0:	f8bd 0010 	ldrh.w	r0, [sp, #16]
   279f4:	9905      	ldr	r1, [sp, #20]
   279f6:	2304      	movs	r3, #4
   279f8:	4401      	add	r1, r0
   279fa:	eb0d 0203 	add.w	r2, sp, r3
   279fe:	9800      	ldr	r0, [sp, #0]
   27a00:	f002 fac8 	bl	29f94 <flash_area_read>
    if (rc != 0) {
   27a04:	4604      	mov	r4, r0
   27a06:	2800      	cmp	r0, #0
   27a08:	d1de      	bne.n	279c8 <read_image_info+0x14>
    if (info.it_magic != IMAGE_TLV_INFO_MAGIC) {
   27a0a:	f8bd 2004 	ldrh.w	r2, [sp, #4]
   27a0e:	f646 1307 	movw	r3, #26887	; 0x6907
   27a12:	429a      	cmp	r2, r3
   27a14:	d1d8      	bne.n	279c8 <read_image_info+0x14>
    *size = hdr.ih_hdr_size + hdr.ih_img_size + info.it_tlv_tot;
   27a16:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   27a1a:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   27a1e:	4413      	add	r3, r2
   27a20:	9a05      	ldr	r2, [sp, #20]
   27a22:	4413      	add	r3, r2
   27a24:	602b      	str	r3, [r5, #0]
   27a26:	e7d1      	b.n	279cc <read_image_info+0x18>

00027a28 <char2hex>:
#include <errno.h>
#include <sys/util.h>

int char2hex(char c, u8_t *x)
{
	if (c >= '0' && c <= '9') {
   27a28:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
   27a2c:	b2db      	uxtb	r3, r3
   27a2e:	2b09      	cmp	r3, #9
   27a30:	d802      	bhi.n	27a38 <char2hex+0x10>
		*x = c - '0';
   27a32:	700b      	strb	r3, [r1, #0]
		*x = c - 'A' + 10;
	} else {
		return -EINVAL;
	}

	return 0;
   27a34:	2000      	movs	r0, #0
   27a36:	4770      	bx	lr
	} else if (c >= 'a' && c <= 'f') {
   27a38:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
   27a3c:	2b05      	cmp	r3, #5
   27a3e:	d802      	bhi.n	27a46 <char2hex+0x1e>
		*x = c - 'a' + 10;
   27a40:	3857      	subs	r0, #87	; 0x57
   27a42:	7008      	strb	r0, [r1, #0]
   27a44:	e7f6      	b.n	27a34 <char2hex+0xc>
	} else if (c >= 'A' && c <= 'F') {
   27a46:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
   27a4a:	2b05      	cmp	r3, #5
   27a4c:	d801      	bhi.n	27a52 <char2hex+0x2a>
		*x = c - 'A' + 10;
   27a4e:	3837      	subs	r0, #55	; 0x37
   27a50:	e7f7      	b.n	27a42 <char2hex+0x1a>
		return -EINVAL;
   27a52:	f06f 0015 	mvn.w	r0, #21
}
   27a56:	4770      	bx	lr

00027a58 <get_bit_ptr>:
/* Places a 32 bit output pointer in word, and an integer bit index
 * within that word as the return value
 */
static int get_bit_ptr(struct sys_mem_pool_base *p, int level, int bn,
		       u32_t **word)
{
   27a58:	b570      	push	{r4, r5, r6, lr}
   27a5a:	68c6      	ldr	r6, [r0, #12]
	u32_t *bitarray = level <= p->max_inline_level ?
   27a5c:	f990 000b 	ldrsb.w	r0, [r0, #11]
   27a60:	250c      	movs	r5, #12
   27a62:	434d      	muls	r5, r1
		p->levels[level].bits : p->levels[level].bits_p;
   27a64:	4288      	cmp	r0, r1
   27a66:	eb06 0405 	add.w	r4, r6, r5
   27a6a:	bfb8      	it	lt
   27a6c:	5974      	ldrlt	r4, [r6, r5]

	*word = &bitarray[bn / 32];
   27a6e:	2a00      	cmp	r2, #0
   27a70:	4610      	mov	r0, r2
   27a72:	bfb8      	it	lt
   27a74:	f102 001f 	addlt.w	r0, r2, #31
   27a78:	1140      	asrs	r0, r0, #5
   27a7a:	eb04 0180 	add.w	r1, r4, r0, lsl #2
   27a7e:	6019      	str	r1, [r3, #0]

	return bn & 0x1f;
}
   27a80:	f002 001f 	and.w	r0, r2, #31
   27a84:	bd70      	pop	{r4, r5, r6, pc}

00027a86 <pool_irq_lock.isra.2.part.3>:
	__asm__ volatile(
   27a86:	f04f 0320 	mov.w	r3, #32
   27a8a:	f3ef 8011 	mrs	r0, BASEPRI
   27a8e:	f383 8811 	msr	BASEPRI, r3
   27a92:	f3bf 8f6f 	isb	sy
	if (p->flags & SYS_MEM_POOL_KERNEL) {
		return irq_lock();
	} else {
		return 0;
	}
}
   27a96:	4770      	bx	lr

00027a98 <pool_irq_unlock.isra.4>:

static inline void pool_irq_unlock(struct sys_mem_pool_base *p, int key)
{
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   27a98:	07c3      	lsls	r3, r0, #31
   27a9a:	d503      	bpl.n	27aa4 <pool_irq_unlock.isra.4+0xc>
	__asm__ volatile(
   27a9c:	f381 8811 	msr	BASEPRI, r1
   27aa0:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}
}
   27aa4:	4770      	bx	lr

00027aa6 <z_sys_mem_pool_base_init>:
{
   27aa6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   27aaa:	6846      	ldr	r6, [r0, #4]
   27aac:	8907      	ldrh	r7, [r0, #8]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
   27aae:	6801      	ldr	r1, [r0, #0]
	for (i = 0; i < p->n_levels; i++) {
   27ab0:	f890 800a 	ldrb.w	r8, [r0, #10]
	p->max_inline_level = -1;
   27ab4:	23ff      	movs	r3, #255	; 0xff
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   27ab6:	fb06 fc07 	mul.w	ip, r6, r7
	p->max_inline_level = -1;
   27aba:	72c3      	strb	r3, [r0, #11]
	u32_t *bits = (u32_t *)((u8_t *)p->buf + buflen);
   27abc:	4461      	add	r1, ip
	size_t buflen = p->n_max * p->max_sz, sz = p->max_sz;
   27abe:	4632      	mov	r2, r6
	for (i = 0; i < p->n_levels; i++) {
   27ac0:	2300      	movs	r3, #0
		sys_dlist_init(&p->levels[i].free_list);
   27ac2:	f04f 090c 	mov.w	r9, #12
	for (i = 0; i < p->n_levels; i++) {
   27ac6:	4598      	cmp	r8, r3
   27ac8:	dc05      	bgt.n	27ad6 <z_sys_mem_pool_base_init+0x30>
   27aca:	2300      	movs	r3, #0
	for (i = 0; i < p->n_max; i++) {
   27acc:	4619      	mov	r1, r3
   27ace:	428f      	cmp	r7, r1
   27ad0:	dc20      	bgt.n	27b14 <z_sys_mem_pool_base_init+0x6e>
}
   27ad2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		sys_dlist_init(&p->levels[i].free_list);
   27ad6:	f8d0 a00c 	ldr.w	sl, [r0, #12]
		int nblocks = buflen / sz;
   27ada:	fbbc f5f2 	udiv	r5, ip, r2
		sys_dlist_init(&p->levels[i].free_list);
   27ade:	fb09 fe03 	mul.w	lr, r9, r3
   27ae2:	eb0a 040e 	add.w	r4, sl, lr
   27ae6:	f104 0b04 	add.w	fp, r4, #4
		if (nblocks <= sizeof(p->levels[i].bits)*8) {
   27aea:	2d20      	cmp	r5, #32
	list->tail = (sys_dnode_t *)list;
   27aec:	e9c4 bb01 	strd	fp, fp, [r4, #4]
   27af0:	d805      	bhi.n	27afe <z_sys_mem_pool_base_init+0x58>
			p->max_inline_level = i;
   27af2:	72c3      	strb	r3, [r0, #11]
		sz = WB_DN(sz / 4);
   27af4:	0892      	lsrs	r2, r2, #2
   27af6:	f022 0203 	bic.w	r2, r2, #3
	for (i = 0; i < p->n_levels; i++) {
   27afa:	3301      	adds	r3, #1
   27afc:	e7e3      	b.n	27ac6 <z_sys_mem_pool_base_init+0x20>
			bits += (nblocks + 31)/32;
   27afe:	f115 041f 	adds.w	r4, r5, #31
   27b02:	bf48      	it	mi
   27b04:	f105 043e 	addmi.w	r4, r5, #62	; 0x3e
   27b08:	1164      	asrs	r4, r4, #5
			p->levels[i].bits_p = bits;
   27b0a:	f84a 100e 	str.w	r1, [sl, lr]
			bits += (nblocks + 31)/32;
   27b0e:	eb01 0184 	add.w	r1, r1, r4, lsl #2
   27b12:	e7ef      	b.n	27af4 <z_sys_mem_pool_base_init+0x4e>
		sys_dlist_append(&p->levels[0].free_list, block);
   27b14:	68c2      	ldr	r2, [r0, #12]
	return (u8_t *)p->buf + lsz * block;
   27b16:	6805      	ldr	r5, [r0, #0]
		sys_dlist_append(&p->levels[0].free_list, block);
   27b18:	f102 0c04 	add.w	ip, r2, #4
	return (u8_t *)p->buf + lsz * block;
   27b1c:	18ec      	adds	r4, r5, r3
	node->next = list;
   27b1e:	f845 c003 	str.w	ip, [r5, r3]
	node->prev = list->tail;
   27b22:	6895      	ldr	r5, [r2, #8]
   27b24:	6065      	str	r5, [r4, #4]
	list->tail->next = node;
   27b26:	6895      	ldr	r5, [r2, #8]
	for (i = 0; i < p->n_max; i++) {
   27b28:	3101      	adds	r1, #1
   27b2a:	602c      	str	r4, [r5, #0]
	list->tail = node;
   27b2c:	4433      	add	r3, r6
   27b2e:	6094      	str	r4, [r2, #8]
   27b30:	e7cd      	b.n	27ace <z_sys_mem_pool_base_init+0x28>

00027b32 <z_sys_mem_pool_block_alloc>:
	return block;
}

int z_sys_mem_pool_block_alloc(struct sys_mem_pool_base *p, size_t size,
			      u32_t *level_p, u32_t *block_p, void **data_p)
{
   27b32:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   27b36:	b087      	sub	sp, #28
	int i, from_l, alloc_l = -1;
	unsigned int key;
	void *data = NULL;
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   27b38:	7a85      	ldrb	r5, [r0, #10]
{
   27b3a:	af00      	add	r7, sp, #0
   27b3c:	e9c7 3201 	strd	r3, r2, [r7, #4]
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   27b40:	00ab      	lsls	r3, r5, #2
   27b42:	3307      	adds	r3, #7
   27b44:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
   27b48:	ebad 0d03 	sub.w	sp, sp, r3
   27b4c:	46ea      	mov	sl, sp
	 * want to allocate and the smallest one with a free entry
	 * from which we can split an allocation if needed.  Along the
	 * way, we populate an array of sizes for each level so we
	 * don't need to waste RAM storing it.
	 */
	lsizes[0] = p->max_sz;
   27b4e:	4653      	mov	r3, sl
   27b50:	6842      	ldr	r2, [r0, #4]
   27b52:	f843 2904 	str.w	r2, [r3], #-4
{
   27b56:	4604      	mov	r4, r0
	for (i = 0; i < p->n_levels; i++) {
   27b58:	2200      	movs	r2, #0
   27b5a:	4295      	cmp	r5, r2
   27b5c:	f102 39ff 	add.w	r9, r2, #4294967295	; 0xffffffff
   27b60:	dd09      	ble.n	27b76 <z_sys_mem_pool_block_alloc+0x44>
		if (i > 0) {
   27b62:	b122      	cbz	r2, 27b6e <z_sys_mem_pool_block_alloc+0x3c>
			lsizes[i] = WB_DN(lsizes[i-1] / 4);
   27b64:	6818      	ldr	r0, [r3, #0]
   27b66:	0880      	lsrs	r0, r0, #2
   27b68:	f020 0003 	bic.w	r0, r0, #3
   27b6c:	6058      	str	r0, [r3, #4]
		}

		if (lsizes[i] < size) {
   27b6e:	f853 0f04 	ldr.w	r0, [r3, #4]!
   27b72:	4288      	cmp	r0, r1
   27b74:	d208      	bcs.n	27b88 <z_sys_mem_pool_block_alloc+0x56>
		}

		alloc_l = i;
	}

	if (alloc_l < 0) {
   27b76:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
   27b7a:	d107      	bne.n	27b8c <z_sys_mem_pool_block_alloc+0x5a>
		*data_p = NULL;
   27b7c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   27b7e:	2300      	movs	r3, #0
   27b80:	6013      	str	r3, [r2, #0]
	pool_irq_unlock(p, key);

	*data_p = data;

	if (data == NULL) {
		return -ENOMEM;
   27b82:	f06f 000b 	mvn.w	r0, #11
   27b86:	e044      	b.n	27c12 <z_sys_mem_pool_block_alloc+0xe0>
	for (i = 0; i < p->n_levels; i++) {
   27b88:	3201      	adds	r2, #1
   27b8a:	e7e6      	b.n	27b5a <z_sys_mem_pool_block_alloc+0x28>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   27b8c:	7c20      	ldrb	r0, [r4, #16]
   27b8e:	f010 0001 	ands.w	r0, r0, #1
   27b92:	d001      	beq.n	27b98 <z_sys_mem_pool_block_alloc+0x66>
   27b94:	f7ff ff77 	bl	27a86 <pool_irq_lock.isra.2.part.3>
   27b98:	68e2      	ldr	r2, [r4, #12]
   27b9a:	230c      	movs	r3, #12
	key = pool_irq_lock(p);
   27b9c:	4680      	mov	r8, r0
	for (i = alloc_l; i >= 0; i--) {
   27b9e:	fb03 2309 	mla	r3, r3, r9, r2
	block = sys_dlist_get(&p->levels[l].free_list);
   27ba2:	464e      	mov	r6, r9
	return list->head == list;
   27ba4:	461a      	mov	r2, r3
   27ba6:	f852 5f04 	ldr.w	r5, [r2, #4]!
	if (!sys_dlist_is_empty(list)) {
   27baa:	4295      	cmp	r5, r2
   27bac:	d06d      	beq.n	27c8a <z_sys_mem_pool_block_alloc+0x158>
	node->prev->next = node->next;
   27bae:	e9d5 3200 	ldrd	r3, r2, [r5]
   27bb2:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   27bb4:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   27bb6:	2300      	movs	r3, #0
	node->prev = NULL;
   27bb8:	e9c5 3300 	strd	r3, r3, [r5]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   27bbc:	6823      	ldr	r3, [r4, #0]
		data = block_alloc(p, i, lsizes[i]);
   27bbe:	f85a 1026 	ldr.w	r1, [sl, r6, lsl #2]
	int bit = get_bit_ptr(p, level, bn, &word);
   27bc2:	f107 0b14 	add.w	fp, r7, #20
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   27bc6:	1aea      	subs	r2, r5, r3
	int bit = get_bit_ptr(p, level, bn, &word);
   27bc8:	4620      	mov	r0, r4
   27bca:	fb92 f2f1 	sdiv	r2, r2, r1
   27bce:	465b      	mov	r3, fp
   27bd0:	4631      	mov	r1, r6
   27bd2:	f7ff ff41 	bl	27a58 <get_bit_ptr>
	*word |= (1<<bit);
   27bd6:	6979      	ldr	r1, [r7, #20]
   27bd8:	2201      	movs	r2, #1
   27bda:	680b      	ldr	r3, [r1, #0]
   27bdc:	603a      	str	r2, [r7, #0]
   27bde:	fa02 f000 	lsl.w	r0, r2, r0
   27be2:	4303      	orrs	r3, r0
   27be4:	600b      	str	r3, [r1, #0]
			for (from_l = i; from_l < alloc_l; from_l++) {
   27be6:	454e      	cmp	r6, r9
   27be8:	db17      	blt.n	27c1a <z_sys_mem_pool_block_alloc+0xe8>
	pool_irq_unlock(p, key);
   27bea:	4641      	mov	r1, r8
   27bec:	7c20      	ldrb	r0, [r4, #16]
   27bee:	f7ff ff53 	bl	27a98 <pool_irq_unlock.isra.4>
	*data_p = data;
   27bf2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   27bf4:	601d      	str	r5, [r3, #0]
	if (data == NULL) {
   27bf6:	2d00      	cmp	r5, #0
   27bf8:	d0c3      	beq.n	27b82 <z_sys_mem_pool_block_alloc+0x50>
	}

	*level_p = alloc_l;
   27bfa:	68bb      	ldr	r3, [r7, #8]
   27bfc:	f8c3 9000 	str.w	r9, [r3]
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   27c00:	6823      	ldr	r3, [r4, #0]
   27c02:	1aed      	subs	r5, r5, r3
   27c04:	f85a 3029 	ldr.w	r3, [sl, r9, lsl #2]
   27c08:	fb95 f5f3 	sdiv	r5, r5, r3
	*block_p = block_num(p, data, lsizes[alloc_l]);
   27c0c:	687b      	ldr	r3, [r7, #4]

	return 0;
   27c0e:	2000      	movs	r0, #0
	*block_p = block_num(p, data, lsizes[alloc_l]);
   27c10:	601d      	str	r5, [r3, #0]
}
   27c12:	371c      	adds	r7, #28
   27c14:	46bd      	mov	sp, r7
   27c16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   27c1a:	6822      	ldr	r2, [r4, #0]
   27c1c:	f85a 3026 	ldr.w	r3, [sl, r6, lsl #2]
	set_alloc_bit(p, l + 1, 4*bn);
   27c20:	3601      	adds	r6, #1
	int bit = get_bit_ptr(p, level, bn, &word);
   27c22:	4631      	mov	r1, r6
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   27c24:	1aaa      	subs	r2, r5, r2
	int bit = get_bit_ptr(p, level, bn, &word);
   27c26:	4620      	mov	r0, r4
	return ((u8_t *)block - (u8_t *)p->buf) / sz;
   27c28:	fb92 f2f3 	sdiv	r2, r2, r3
	int bit = get_bit_ptr(p, level, bn, &word);
   27c2c:	465b      	mov	r3, fp
   27c2e:	0092      	lsls	r2, r2, #2
   27c30:	f7ff ff12 	bl	27a58 <get_bit_ptr>
	*word |= (1<<bit);
   27c34:	697a      	ldr	r2, [r7, #20]
   27c36:	683b      	ldr	r3, [r7, #0]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
   27c38:	68e1      	ldr	r1, [r4, #12]
	*word |= (1<<bit);
   27c3a:	fa03 f000 	lsl.w	r0, r3, r0
   27c3e:	6813      	ldr	r3, [r2, #0]
   27c40:	4303      	orrs	r3, r0
   27c42:	6013      	str	r3, [r2, #0]
		int lsz = lsizes[l + 1];
   27c44:	f85a 0026 	ldr.w	r0, [sl, r6, lsl #2]
		sys_dlist_append(&p->levels[l + 1].free_list, block2);
   27c48:	230c      	movs	r3, #12
   27c4a:	fb03 1106 	mla	r1, r3, r6, r1
   27c4e:	2203      	movs	r2, #3
   27c50:	f101 0e04 	add.w	lr, r1, #4
   27c54:	182b      	adds	r3, r5, r0
   27c56:	60fa      	str	r2, [r7, #12]
	node->prev = list->tail;
   27c58:	688a      	ldr	r2, [r1, #8]
   27c5a:	605a      	str	r2, [r3, #4]
	list->tail->next = node;
   27c5c:	688a      	ldr	r2, [r1, #8]
	node->next = list;
   27c5e:	f8c3 e000 	str.w	lr, [r3]
	list->tail->next = node;
   27c62:	6013      	str	r3, [r2, #0]
	for (i = 1; i < 4; i++) {
   27c64:	68fa      	ldr	r2, [r7, #12]
	list->tail = node;
   27c66:	608b      	str	r3, [r1, #8]
   27c68:	3a01      	subs	r2, #1
   27c6a:	4403      	add	r3, r0
   27c6c:	60fa      	str	r2, [r7, #12]
   27c6e:	d1f3      	bne.n	27c58 <z_sys_mem_pool_block_alloc+0x126>
				pool_irq_unlock(p, key);
   27c70:	4641      	mov	r1, r8
   27c72:	7c20      	ldrb	r0, [r4, #16]
   27c74:	f7ff ff10 	bl	27a98 <pool_irq_unlock.isra.4>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   27c78:	7c23      	ldrb	r3, [r4, #16]
   27c7a:	07d9      	lsls	r1, r3, #31
   27c7c:	d503      	bpl.n	27c86 <z_sys_mem_pool_block_alloc+0x154>
   27c7e:	f7ff ff02 	bl	27a86 <pool_irq_lock.isra.2.part.3>
				key = pool_irq_lock(p);
   27c82:	4680      	mov	r8, r0
   27c84:	e7af      	b.n	27be6 <z_sys_mem_pool_block_alloc+0xb4>
		return 0;
   27c86:	68f8      	ldr	r0, [r7, #12]
   27c88:	e7fb      	b.n	27c82 <z_sys_mem_pool_block_alloc+0x150>
	for (i = alloc_l; i >= 0; i--) {
   27c8a:	3e01      	subs	r6, #1
   27c8c:	1c72      	adds	r2, r6, #1
   27c8e:	f1a3 030c 	sub.w	r3, r3, #12
   27c92:	d187      	bne.n	27ba4 <z_sys_mem_pool_block_alloc+0x72>
   27c94:	2500      	movs	r5, #0
   27c96:	e7a8      	b.n	27bea <z_sys_mem_pool_block_alloc+0xb8>

00027c98 <z_sys_mem_pool_block_free>:

void z_sys_mem_pool_block_free(struct sys_mem_pool_base *p, u32_t level,
			      u32_t block)
{
   27c98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   27c9c:	b085      	sub	sp, #20
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   27c9e:	7a83      	ldrb	r3, [r0, #10]
   27ca0:	009b      	lsls	r3, r3, #2
   27ca2:	3307      	adds	r3, #7
   27ca4:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
{
   27ca8:	af00      	add	r7, sp, #0
	size_t lsizes[LVL_ARRAY_SZ(p->n_levels)];
   27caa:	ebad 0d03 	sub.w	sp, sp, r3
   27cae:	46eb      	mov	fp, sp
	 * to avoid having to store it in precious RAM bytes.
	 * Overhead here is somewhat higher because block_free()
	 * doesn't inherently need to traverse all the larger
	 * sublevels.
	 */
	lsizes[0] = p->max_sz;
   27cb0:	6843      	ldr	r3, [r0, #4]
   27cb2:	f8cb 3000 	str.w	r3, [fp]
{
   27cb6:	4606      	mov	r6, r0
	for (i = 1; i <= level; i++) {
   27cb8:	465c      	mov	r4, fp
   27cba:	2001      	movs	r0, #1
   27cbc:	4281      	cmp	r1, r0
   27cbe:	d215      	bcs.n	27cec <z_sys_mem_pool_block_free+0x54>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   27cc0:	7c30      	ldrb	r0, [r6, #16]
   27cc2:	f010 0001 	ands.w	r0, r0, #1
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
	}

	block_free(p, level, lsizes, block);
   27cc6:	4688      	mov	r8, r1
   27cc8:	4615      	mov	r5, r2
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   27cca:	d001      	beq.n	27cd0 <z_sys_mem_pool_block_free+0x38>
   27ccc:	f7ff fedb 	bl	27a86 <pool_irq_lock.isra.2.part.3>
	unsigned int key = pool_irq_lock(p);
   27cd0:	4604      	mov	r4, r0
	while (level >= 0) {
   27cd2:	f1b8 0f00 	cmp.w	r8, #0
   27cd6:	da11      	bge.n	27cfc <z_sys_mem_pool_block_free+0x64>
	return -1;
   27cd8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
	pool_irq_unlock(p, key);
   27cdc:	4621      	mov	r1, r4
   27cde:	7c30      	ldrb	r0, [r6, #16]
   27ce0:	f7ff feda 	bl	27a98 <pool_irq_unlock.isra.4>
}
   27ce4:	3714      	adds	r7, #20
   27ce6:	46bd      	mov	sp, r7
   27ce8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		lsizes[i] = WB_DN(lsizes[i-1] / 4);
   27cec:	6823      	ldr	r3, [r4, #0]
   27cee:	089b      	lsrs	r3, r3, #2
   27cf0:	f023 0303 	bic.w	r3, r3, #3
   27cf4:	f844 3f04 	str.w	r3, [r4, #4]!
	for (i = 1; i <= level; i++) {
   27cf8:	3001      	adds	r0, #1
   27cfa:	e7df      	b.n	27cbc <z_sys_mem_pool_block_free+0x24>
		int i, lsz = lsizes[level];
   27cfc:	f85b 3028 	ldr.w	r3, [fp, r8, lsl #2]
   27d00:	607b      	str	r3, [r7, #4]
	return (u8_t *)p->buf + lsz * block;
   27d02:	fb03 fa05 	mul.w	sl, r3, r5
   27d06:	6833      	ldr	r3, [r6, #0]
   27d08:	603b      	str	r3, [r7, #0]
   27d0a:	eb03 090a 	add.w	r9, r3, sl
	int bit = get_bit_ptr(p, level, bn, &word);
   27d0e:	462a      	mov	r2, r5
   27d10:	f107 030c 	add.w	r3, r7, #12
   27d14:	4641      	mov	r1, r8
   27d16:	4630      	mov	r0, r6
   27d18:	f7ff fe9e 	bl	27a58 <get_bit_ptr>
	*word &= ~(1<<bit);
   27d1c:	68fa      	ldr	r2, [r7, #12]
	node->next = list;
   27d1e:	6839      	ldr	r1, [r7, #0]
   27d20:	2301      	movs	r3, #1
   27d22:	fa03 f000 	lsl.w	r0, r3, r0
   27d26:	6813      	ldr	r3, [r2, #0]
   27d28:	ea23 0300 	bic.w	r3, r3, r0
   27d2c:	6013      	str	r3, [r2, #0]
		sys_dlist_append(&p->levels[level].free_list, block);
   27d2e:	68f3      	ldr	r3, [r6, #12]
   27d30:	220c      	movs	r2, #12
   27d32:	fb02 3308 	mla	r3, r2, r8, r3
   27d36:	1d1a      	adds	r2, r3, #4
   27d38:	f841 200a 	str.w	r2, [r1, sl]
	node->prev = list->tail;
   27d3c:	689a      	ldr	r2, [r3, #8]
   27d3e:	f8c9 2004 	str.w	r2, [r9, #4]
	list->tail->next = node;
   27d42:	689a      	ldr	r2, [r3, #8]
   27d44:	f8c2 9000 	str.w	r9, [r2]
	list->tail = node;
   27d48:	f8c3 9008 	str.w	r9, [r3, #8]
		pool_irq_unlock(p, key);
   27d4c:	7c30      	ldrb	r0, [r6, #16]
   27d4e:	4621      	mov	r1, r4
   27d50:	f7ff fea2 	bl	27a98 <pool_irq_unlock.isra.4>
	if (p->flags & SYS_MEM_POOL_KERNEL) {
   27d54:	7c30      	ldrb	r0, [r6, #16]
   27d56:	f010 0001 	ands.w	r0, r0, #1
   27d5a:	d001      	beq.n	27d60 <z_sys_mem_pool_block_free+0xc8>
   27d5c:	f7ff fe93 	bl	27a86 <pool_irq_lock.isra.2.part.3>
		key = pool_irq_lock(p);
   27d60:	4604      	mov	r4, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
   27d62:	f1b8 0f00 	cmp.w	r8, #0
   27d66:	d0b9      	beq.n	27cdc <z_sys_mem_pool_block_free+0x44>
	int bit = get_bit_ptr(p, level, bn, &word);
   27d68:	f107 030c 	add.w	r3, r7, #12
   27d6c:	462a      	mov	r2, r5
   27d6e:	4641      	mov	r1, r8
   27d70:	4630      	mov	r0, r6
   27d72:	f7ff fe71 	bl	27a58 <get_bit_ptr>
	return (*word >> (4*(bit / 4))) & 0xf;
   27d76:	68fb      	ldr	r3, [r7, #12]
   27d78:	2800      	cmp	r0, #0
   27d7a:	bfb8      	it	lt
   27d7c:	3003      	addlt	r0, #3
   27d7e:	681b      	ldr	r3, [r3, #0]
   27d80:	f020 0003 	bic.w	r0, r0, #3
   27d84:	fa23 f000 	lsr.w	r0, r3, r0
		if (level == 0 || partner_alloc_bits(p, level, bn) != 0) {
   27d88:	f010 000f 	ands.w	r0, r0, #15
   27d8c:	d1a6      	bne.n	27cdc <z_sys_mem_pool_block_free+0x44>
			int b = (bn & ~3) + i;
   27d8e:	f025 0a03 	bic.w	sl, r5, #3
	node->next = NULL;
   27d92:	4684      	mov	ip, r0
	return (u8_t *)p->buf + lsz * block;
   27d94:	687a      	ldr	r2, [r7, #4]
			int b = (bn & ~3) + i;
   27d96:	eb0a 0300 	add.w	r3, sl, r0
	return (u8_t *)p->buf + lsz * block;
   27d9a:	4353      	muls	r3, r2
   27d9c:	6832      	ldr	r2, [r6, #0]
   27d9e:	18d1      	adds	r1, r2, r3
	node->prev->next = node->next;
   27da0:	f852 e003 	ldr.w	lr, [r2, r3]
   27da4:	f8d1 9004 	ldr.w	r9, [r1, #4]
		for (i = 0; i < 4; i++) {
   27da8:	3001      	adds	r0, #1
   27daa:	2804      	cmp	r0, #4
   27dac:	f8c9 e000 	str.w	lr, [r9]
	node->next->prev = node->prev;
   27db0:	f8ce 9004 	str.w	r9, [lr, #4]
	node->next = NULL;
   27db4:	f842 c003 	str.w	ip, [r2, r3]
	node->prev = NULL;
   27db8:	f8c1 c004 	str.w	ip, [r1, #4]
   27dbc:	d1ea      	bne.n	27d94 <z_sys_mem_pool_block_free+0xfc>
		bn = bn / 4;
   27dbe:	2d00      	cmp	r5, #0
   27dc0:	bfb8      	it	lt
   27dc2:	3503      	addlt	r5, #3
		level = level - 1;
   27dc4:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
		bn = bn / 4;
   27dc8:	10ad      	asrs	r5, r5, #2
   27dca:	e782      	b.n	27cd2 <z_sys_mem_pool_block_free+0x3a>

00027dcc <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   27dcc:	4604      	mov	r4, r0
   27dce:	b508      	push	{r3, lr}
   27dd0:	4608      	mov	r0, r1
   27dd2:	4611      	mov	r1, r2
	entry(p1, p2, p3);
   27dd4:	461a      	mov	r2, r3
   27dd6:	47a0      	blx	r4
	return z_impl_k_current_get();
   27dd8:	f7ff f990 	bl	270fc <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
   27ddc:	f7ec fb2c 	bl	14438 <z_impl_k_thread_abort>

00027de0 <z_work_q_main>:

#include <kernel.h>
#define WORKQUEUE_THREAD_NAME	"workqueue"

void z_work_q_main(void *work_q_ptr, void *p2, void *p3)
{
   27de0:	b510      	push	{r4, lr}
   27de2:	4604      	mov	r4, r0
	return z_impl_k_queue_get(queue, timeout);
   27de4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   27de8:	4620      	mov	r0, r4
   27dea:	f005 f9b3 	bl	2d154 <z_impl_k_queue_get>
	while (true) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_queue_get(&work_q->queue, K_FOREVER);
		if (work == NULL) {
   27dee:	4603      	mov	r3, r0
   27df0:	2800      	cmp	r0, #0
   27df2:	d0f7      	beq.n	27de4 <z_work_q_main+0x4>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   27df4:	3308      	adds	r3, #8
			continue;
		}

		handler = work->handler;
   27df6:	6842      	ldr	r2, [r0, #4]
   27df8:	f3bf 8f5b 	dmb	ish
   27dfc:	e853 1f00 	ldrex	r1, [r3]
   27e00:	f021 0c01 	bic.w	ip, r1, #1
   27e04:	e843 ce00 	strex	lr, ip, [r3]
   27e08:	f1be 0f00 	cmp.w	lr, #0
   27e0c:	d1f6      	bne.n	27dfc <z_work_q_main+0x1c>
   27e0e:	f3bf 8f5b 	dmb	ish

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
   27e12:	07cb      	lsls	r3, r1, #31
   27e14:	d500      	bpl.n	27e18 <z_work_q_main+0x38>
					      K_WORK_STATE_PENDING)) {
			handler(work);
   27e16:	4790      	blx	r2
	z_impl_k_yield();
   27e18:	f7ff f8fc 	bl	27014 <z_impl_k_yield>
   27e1c:	e7e2      	b.n	27de4 <z_work_q_main+0x4>

00027e1e <arch_printk_char_out>:
}
   27e1e:	2000      	movs	r0, #0
   27e20:	4770      	bx	lr

00027e22 <print_err>:
{
   27e22:	b570      	push	{r4, r5, r6, lr}
   27e24:	4604      	mov	r4, r0
   27e26:	460d      	mov	r5, r1
	out('E', ctx);
   27e28:	2045      	movs	r0, #69	; 0x45
   27e2a:	47a0      	blx	r4
	out('R', ctx);
   27e2c:	4629      	mov	r1, r5
   27e2e:	2052      	movs	r0, #82	; 0x52
   27e30:	47a0      	blx	r4
	out('R', ctx);
   27e32:	4629      	mov	r1, r5
   27e34:	4623      	mov	r3, r4
   27e36:	2052      	movs	r0, #82	; 0x52
}
   27e38:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	out('R', ctx);
   27e3c:	4718      	bx	r3

00027e3e <str_out>:
{
   27e3e:	b530      	push	{r4, r5, lr}
   27e40:	688a      	ldr	r2, [r1, #8]
	if (ctx->str == NULL || ctx->count >= ctx->max) {
   27e42:	680c      	ldr	r4, [r1, #0]
   27e44:	1c55      	adds	r5, r2, #1
   27e46:	b114      	cbz	r4, 27e4e <str_out+0x10>
   27e48:	684b      	ldr	r3, [r1, #4]
   27e4a:	4293      	cmp	r3, r2
   27e4c:	dc01      	bgt.n	27e52 <str_out+0x14>
		ctx->count++;
   27e4e:	608d      	str	r5, [r1, #8]
}
   27e50:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
   27e52:	3b01      	subs	r3, #1
   27e54:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
   27e56:	bf08      	it	eq
   27e58:	2200      	moveq	r2, #0
   27e5a:	608d      	str	r5, [r1, #8]
   27e5c:	bf0c      	ite	eq
   27e5e:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
   27e60:	54a0      	strbne	r0, [r4, r2]
   27e62:	e7f5      	b.n	27e50 <str_out+0x12>

00027e64 <z_vprintk>:
{
   27e64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   27e68:	b08b      	sub	sp, #44	; 0x2c
   27e6a:	461c      	mov	r4, r3
	char length_mod = 0;
   27e6c:	f04f 0800 	mov.w	r8, #0
   27e70:	1e53      	subs	r3, r2, #1
{
   27e72:	4606      	mov	r6, r0
   27e74:	460f      	mov	r7, r1
   27e76:	9302      	str	r3, [sp, #8]
	int min_width = -1;
   27e78:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
	enum pad_type padding = PAD_NONE;
   27e7c:	46c1      	mov	r9, r8
			might_format = 0;
   27e7e:	2500      	movs	r5, #0
					break;
   27e80:	e005      	b.n	27e8e <z_vprintk+0x2a>
		if (!might_format) {
   27e82:	b96d      	cbnz	r5, 27ea0 <z_vprintk+0x3c>
			if (*fmt != '%') {
   27e84:	2825      	cmp	r0, #37	; 0x25
   27e86:	f000 814f 	beq.w	28128 <z_vprintk+0x2c4>
				out((int)*fmt, ctx);
   27e8a:	4639      	mov	r1, r7
   27e8c:	47b0      	blx	r6
	while (*fmt) {
   27e8e:	9b02      	ldr	r3, [sp, #8]
   27e90:	f813 0f01 	ldrb.w	r0, [r3, #1]!
   27e94:	9302      	str	r3, [sp, #8]
   27e96:	2800      	cmp	r0, #0
   27e98:	d1f3      	bne.n	27e82 <z_vprintk+0x1e>
}
   27e9a:	b00b      	add	sp, #44	; 0x2c
   27e9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			switch (*fmt) {
   27ea0:	2864      	cmp	r0, #100	; 0x64
   27ea2:	d06e      	beq.n	27f82 <z_vprintk+0x11e>
   27ea4:	d81a      	bhi.n	27edc <z_vprintk+0x78>
   27ea6:	2839      	cmp	r0, #57	; 0x39
   27ea8:	d80a      	bhi.n	27ec0 <z_vprintk+0x5c>
   27eaa:	2831      	cmp	r0, #49	; 0x31
   27eac:	d260      	bcs.n	27f70 <z_vprintk+0x10c>
   27eae:	282d      	cmp	r0, #45	; 0x2d
   27eb0:	f000 8140 	beq.w	28134 <z_vprintk+0x2d0>
   27eb4:	2830      	cmp	r0, #48	; 0x30
   27eb6:	d04c      	beq.n	27f52 <z_vprintk+0xee>
   27eb8:	2825      	cmp	r0, #37	; 0x25
   27eba:	d107      	bne.n	27ecc <z_vprintk+0x68>
				out((int)'%', ctx);
   27ebc:	4639      	mov	r1, r7
   27ebe:	e00b      	b.n	27ed8 <z_vprintk+0x74>
			switch (*fmt) {
   27ec0:	2858      	cmp	r0, #88	; 0x58
   27ec2:	f000 80bb 	beq.w	2803c <z_vprintk+0x1d8>
   27ec6:	2863      	cmp	r0, #99	; 0x63
   27ec8:	f000 812a 	beq.w	28120 <z_vprintk+0x2bc>
					out((int)'%', ctx);
   27ecc:	4639      	mov	r1, r7
   27ece:	2025      	movs	r0, #37	; 0x25
   27ed0:	47b0      	blx	r6
					out((int)*fmt, ctx);
   27ed2:	9b02      	ldr	r3, [sp, #8]
   27ed4:	7818      	ldrb	r0, [r3, #0]
   27ed6:	4639      	mov	r1, r7
   27ed8:	47b0      	blx	r6
   27eda:	e7d0      	b.n	27e7e <z_vprintk+0x1a>
			switch (*fmt) {
   27edc:	2870      	cmp	r0, #112	; 0x70
   27ede:	f000 80a3 	beq.w	28028 <z_vprintk+0x1c4>
   27ee2:	d811      	bhi.n	27f08 <z_vprintk+0xa4>
   27ee4:	2869      	cmp	r0, #105	; 0x69
   27ee6:	d04c      	beq.n	27f82 <z_vprintk+0x11e>
   27ee8:	286c      	cmp	r0, #108	; 0x6c
   27eea:	d105      	bne.n	27ef8 <z_vprintk+0x94>
				} else if (*fmt == 'l' && length_mod == 'l') {
   27eec:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   27ef0:	d12a      	bne.n	27f48 <z_vprintk+0xe4>
					length_mod = 'L';
   27ef2:	f04f 084c 	mov.w	r8, #76	; 0x4c
   27ef6:	e7ca      	b.n	27e8e <z_vprintk+0x2a>
			switch (*fmt) {
   27ef8:	2868      	cmp	r0, #104	; 0x68
   27efa:	d1e7      	bne.n	27ecc <z_vprintk+0x68>
				if (*fmt == 'h' && length_mod == 'h') {
   27efc:	f1b8 0f68 	cmp.w	r8, #104	; 0x68
   27f00:	d122      	bne.n	27f48 <z_vprintk+0xe4>
					length_mod = 'H';
   27f02:	f04f 0848 	mov.w	r8, #72	; 0x48
   27f06:	e7c2      	b.n	27e8e <z_vprintk+0x2a>
			switch (*fmt) {
   27f08:	2875      	cmp	r0, #117	; 0x75
   27f0a:	d071      	beq.n	27ff0 <z_vprintk+0x18c>
   27f0c:	d818      	bhi.n	27f40 <z_vprintk+0xdc>
   27f0e:	2873      	cmp	r0, #115	; 0x73
   27f10:	d1dc      	bne.n	27ecc <z_vprintk+0x68>
				char *s = va_arg(ap, char *);
   27f12:	f854 5b04 	ldr.w	r5, [r4], #4
				while (*s) {
   27f16:	46ab      	mov	fp, r5
   27f18:	465b      	mov	r3, fp
   27f1a:	f81b 0b01 	ldrb.w	r0, [fp], #1
   27f1e:	2800      	cmp	r0, #0
   27f20:	f040 80fb 	bne.w	2811a <z_vprintk+0x2b6>
				if (padding == PAD_SPACE_AFTER) {
   27f24:	f1b9 0f03 	cmp.w	r9, #3
   27f28:	f040 810a 	bne.w	28140 <z_vprintk+0x2dc>
					int remaining = min_width - (s - start);
   27f2c:	1b5d      	subs	r5, r3, r5
   27f2e:	ebaa 0505 	sub.w	r5, sl, r5
					while (remaining-- > 0) {
   27f32:	2d00      	cmp	r5, #0
   27f34:	dda3      	ble.n	27e7e <z_vprintk+0x1a>
						out(' ', ctx);
   27f36:	4639      	mov	r1, r7
   27f38:	2020      	movs	r0, #32
   27f3a:	47b0      	blx	r6
   27f3c:	3d01      	subs	r5, #1
   27f3e:	e7f8      	b.n	27f32 <z_vprintk+0xce>
			switch (*fmt) {
   27f40:	2878      	cmp	r0, #120	; 0x78
   27f42:	d07b      	beq.n	2803c <z_vprintk+0x1d8>
   27f44:	287a      	cmp	r0, #122	; 0x7a
   27f46:	d1c1      	bne.n	27ecc <z_vprintk+0x68>
				} else if (length_mod == 0) {
   27f48:	f1b8 0f00 	cmp.w	r8, #0
   27f4c:	d1be      	bne.n	27ecc <z_vprintk+0x68>
   27f4e:	4680      	mov	r8, r0
   27f50:	e79d      	b.n	27e8e <z_vprintk+0x2a>
				if (min_width < 0 && padding == PAD_NONE) {
   27f52:	f1ba 0f00 	cmp.w	sl, #0
   27f56:	da0e      	bge.n	27f76 <z_vprintk+0x112>
   27f58:	f1b9 0f00 	cmp.w	r9, #0
   27f5c:	f000 80ed 	beq.w	2813a <z_vprintk+0x2d6>
					min_width = *fmt - '0';
   27f60:	f1a0 0a30 	sub.w	sl, r0, #48	; 0x30
					padding = PAD_SPACE_BEFORE;
   27f64:	f1b9 0f00 	cmp.w	r9, #0
   27f68:	bf08      	it	eq
   27f6a:	f04f 0902 	moveq.w	r9, #2
   27f6e:	e78e      	b.n	27e8e <z_vprintk+0x2a>
				if (min_width < 0) {
   27f70:	f1ba 0f00 	cmp.w	sl, #0
   27f74:	dbf4      	blt.n	27f60 <z_vprintk+0xfc>
					min_width = 10 * min_width + *fmt - '0';
   27f76:	230a      	movs	r3, #10
   27f78:	fb03 0a0a 	mla	sl, r3, sl, r0
   27f7c:	f1aa 0a30 	sub.w	sl, sl, #48	; 0x30
   27f80:	e7f0      	b.n	27f64 <z_vprintk+0x100>
				if (length_mod == 'z') {
   27f82:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
   27f86:	d102      	bne.n	27f8e <z_vprintk+0x12a>
					d = va_arg(ap, int);
   27f88:	f854 5b04 	ldr.w	r5, [r4], #4
   27f8c:	e01f      	b.n	27fce <z_vprintk+0x16a>
				} else if (length_mod == 'l') {
   27f8e:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   27f92:	d0f9      	beq.n	27f88 <z_vprintk+0x124>
				} else if (length_mod == 'L') {
   27f94:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   27f98:	d1f6      	bne.n	27f88 <z_vprintk+0x124>
					long long lld = va_arg(ap, long long);
   27f9a:	3407      	adds	r4, #7
   27f9c:	f024 0407 	bic.w	r4, r4, #7
   27fa0:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (lld > __LONG_MAX__ ||
   27fa4:	f112 4100 	adds.w	r1, r2, #2147483648	; 0x80000000
   27fa8:	9106      	str	r1, [sp, #24]
   27faa:	f143 0100 	adc.w	r1, r3, #0
   27fae:	9107      	str	r1, [sp, #28]
   27fb0:	e9dd bc06 	ldrd	fp, ip, [sp, #24]
   27fb4:	2100      	movs	r1, #0
   27fb6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   27fba:	4561      	cmp	r1, ip
   27fbc:	bf08      	it	eq
   27fbe:	4558      	cmpeq	r0, fp
   27fc0:	d204      	bcs.n	27fcc <z_vprintk+0x168>
						print_err(out, ctx);
   27fc2:	4639      	mov	r1, r7
   27fc4:	4630      	mov	r0, r6
   27fc6:	f7ff ff2c 	bl	27e22 <print_err>
						break;
   27fca:	e758      	b.n	27e7e <z_vprintk+0x1a>
					d = lld;
   27fcc:	4615      	mov	r5, r2
				if (d < 0) {
   27fce:	2d00      	cmp	r5, #0
   27fd0:	da05      	bge.n	27fde <z_vprintk+0x17a>
					out((int)'-', ctx);
   27fd2:	4639      	mov	r1, r7
   27fd4:	202d      	movs	r0, #45	; 0x2d
   27fd6:	47b0      	blx	r6
					d = -d;
   27fd8:	426d      	negs	r5, r5
					min_width--;
   27fda:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
				_printk_dec_ulong(out, ctx, d, padding,
   27fde:	f8cd a000 	str.w	sl, [sp]
   27fe2:	464b      	mov	r3, r9
   27fe4:	462a      	mov	r2, r5
				_printk_dec_ulong(out, ctx, u, padding,
   27fe6:	4639      	mov	r1, r7
   27fe8:	4630      	mov	r0, r6
   27fea:	f7e8 fddb 	bl	10ba4 <_printk_dec_ulong>
				break;
   27fee:	e746      	b.n	27e7e <z_vprintk+0x1a>
				if (length_mod == 'z') {
   27ff0:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
   27ff4:	d102      	bne.n	27ffc <z_vprintk+0x198>
					u = va_arg(ap, unsigned int);
   27ff6:	f854 2b04 	ldr.w	r2, [r4], #4
   27ffa:	e011      	b.n	28020 <z_vprintk+0x1bc>
				} else if (length_mod == 'l') {
   27ffc:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   28000:	d0f9      	beq.n	27ff6 <z_vprintk+0x192>
				} else if (length_mod == 'L') {
   28002:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   28006:	d1f6      	bne.n	27ff6 <z_vprintk+0x192>
					unsigned long long llu =
   28008:	3407      	adds	r4, #7
   2800a:	f024 0407 	bic.w	r4, r4, #7
   2800e:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (llu > ~0UL) {
   28012:	2100      	movs	r1, #0
   28014:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28018:	4299      	cmp	r1, r3
   2801a:	bf08      	it	eq
   2801c:	4290      	cmpeq	r0, r2
   2801e:	d3d0      	bcc.n	27fc2 <z_vprintk+0x15e>
				_printk_dec_ulong(out, ctx, u, padding,
   28020:	f8cd a000 	str.w	sl, [sp]
   28024:	464b      	mov	r3, r9
   28026:	e7de      	b.n	27fe6 <z_vprintk+0x182>
				out('0', ctx);
   28028:	4639      	mov	r1, r7
   2802a:	2030      	movs	r0, #48	; 0x30
   2802c:	47b0      	blx	r6
				out('x', ctx);
   2802e:	4639      	mov	r1, r7
   28030:	2078      	movs	r0, #120	; 0x78
   28032:	47b0      	blx	r6
					min_width = 8;
   28034:	f04f 0a08 	mov.w	sl, #8
				padding = PAD_ZERO_BEFORE;
   28038:	f04f 0901 	mov.w	r9, #1
				if (*fmt == 'p') {
   2803c:	9b02      	ldr	r3, [sp, #8]
   2803e:	781b      	ldrb	r3, [r3, #0]
   28040:	2b70      	cmp	r3, #112	; 0x70
   28042:	d104      	bne.n	2804e <z_vprintk+0x1ea>
					x = va_arg(ap, unsigned int);
   28044:	f854 3b04 	ldr.w	r3, [r4], #4
   28048:	9304      	str	r3, [sp, #16]
   2804a:	2300      	movs	r3, #0
   2804c:	e00d      	b.n	2806a <z_vprintk+0x206>
				} else if (length_mod == 'l') {
   2804e:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   28052:	d0f7      	beq.n	28044 <z_vprintk+0x1e0>
				} else if (length_mod == 'L') {
   28054:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   28058:	d1f4      	bne.n	28044 <z_vprintk+0x1e0>
					x = va_arg(ap, unsigned long long);
   2805a:	3407      	adds	r4, #7
   2805c:	f024 0307 	bic.w	r3, r4, #7
   28060:	461c      	mov	r4, r3
   28062:	685b      	ldr	r3, [r3, #4]
   28064:	f854 2b08 	ldr.w	r2, [r4], #8
   28068:	9204      	str	r2, [sp, #16]
	int digits = 0;
   2806a:	2100      	movs	r1, #0
	int remaining = 16; /* 16 digits max */
   2806c:	2210      	movs	r2, #16
	int digits = 0;
   2806e:	9103      	str	r1, [sp, #12]
	int found_largest_digit = 0;
   28070:	9105      	str	r1, [sp, #20]
	int shift = sizeof(num) * 8;
   28072:	f04f 0b40 	mov.w	fp, #64	; 0x40
		shift -= 4;
   28076:	f1ab 0b04 	sub.w	fp, fp, #4
		nibble = (num >> shift) & 0xf;
   2807a:	9804      	ldr	r0, [sp, #16]
   2807c:	f1cb 0c20 	rsb	ip, fp, #32
   28080:	f1ab 0120 	sub.w	r1, fp, #32
   28084:	fa20 f00b 	lsr.w	r0, r0, fp
   28088:	fa03 fc0c 	lsl.w	ip, r3, ip
   2808c:	ea40 000c 	orr.w	r0, r0, ip
   28090:	fa23 f101 	lsr.w	r1, r3, r1
   28094:	4308      	orrs	r0, r1
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
   28096:	f010 000f 	ands.w	r0, r0, #15
   2809a:	d108      	bne.n	280ae <z_vprintk+0x24a>
   2809c:	9905      	ldr	r1, [sp, #20]
   2809e:	b911      	cbnz	r1, 280a6 <z_vprintk+0x242>
   280a0:	f1bb 0f00 	cmp.w	fp, #0
   280a4:	d124      	bne.n	280f0 <z_vprintk+0x28c>
			nibble += nibble > 9 ? 87 : 48;
   280a6:	2130      	movs	r1, #48	; 0x30
   280a8:	e005      	b.n	280b6 <z_vprintk+0x252>
			found_largest_digit = 1;
   280aa:	9505      	str	r5, [sp, #20]
   280ac:	e7e3      	b.n	28076 <z_vprintk+0x212>
			nibble += nibble > 9 ? 87 : 48;
   280ae:	2809      	cmp	r0, #9
   280b0:	bf8c      	ite	hi
   280b2:	2157      	movhi	r1, #87	; 0x57
   280b4:	2130      	movls	r1, #48	; 0x30
   280b6:	4408      	add	r0, r1
			out((int)nibble, ctx);
   280b8:	b240      	sxtb	r0, r0
   280ba:	4639      	mov	r1, r7
   280bc:	9308      	str	r3, [sp, #32]
   280be:	9205      	str	r2, [sp, #20]
   280c0:	47b0      	blx	r6
			digits++;
   280c2:	9b03      	ldr	r3, [sp, #12]
	while (shift >= 4) {
   280c4:	9a05      	ldr	r2, [sp, #20]
			digits++;
   280c6:	3301      	adds	r3, #1
   280c8:	9303      	str	r3, [sp, #12]
	while (shift >= 4) {
   280ca:	9b08      	ldr	r3, [sp, #32]
   280cc:	f1bb 0f00 	cmp.w	fp, #0
   280d0:	d1eb      	bne.n	280aa <z_vprintk+0x246>
	if (padding == PAD_SPACE_AFTER) {
   280d2:	f1b9 0f03 	cmp.w	r9, #3
   280d6:	f47f aed2 	bne.w	27e7e <z_vprintk+0x1a>
		remaining = min_width * 2 - digits;
   280da:	9b03      	ldr	r3, [sp, #12]
   280dc:	ebc3 054a 	rsb	r5, r3, sl, lsl #1
		while (remaining-- > 0) {
   280e0:	2d00      	cmp	r5, #0
   280e2:	f77f aecc 	ble.w	27e7e <z_vprintk+0x1a>
			out(' ', ctx);
   280e6:	4639      	mov	r1, r7
   280e8:	2020      	movs	r0, #32
   280ea:	47b0      	blx	r6
   280ec:	3d01      	subs	r5, #1
   280ee:	e7f7      	b.n	280e0 <z_vprintk+0x27c>
		if (remaining-- <= min_width) {
   280f0:	1e51      	subs	r1, r2, #1
   280f2:	4592      	cmp	sl, r2
   280f4:	9108      	str	r1, [sp, #32]
   280f6:	db07      	blt.n	28108 <z_vprintk+0x2a4>
			if (padding == PAD_ZERO_BEFORE) {
   280f8:	f1b9 0f01 	cmp.w	r9, #1
   280fc:	d106      	bne.n	2810c <z_vprintk+0x2a8>
   280fe:	9309      	str	r3, [sp, #36]	; 0x24
				out('0', ctx);
   28100:	4639      	mov	r1, r7
   28102:	2030      	movs	r0, #48	; 0x30
				out(' ', ctx);
   28104:	47b0      	blx	r6
   28106:	9b09      	ldr	r3, [sp, #36]	; 0x24
					x = va_arg(ap, unsigned int);
   28108:	9a08      	ldr	r2, [sp, #32]
   2810a:	e7b4      	b.n	28076 <z_vprintk+0x212>
			} else if (padding == PAD_SPACE_BEFORE) {
   2810c:	f1b9 0f02 	cmp.w	r9, #2
   28110:	d1fa      	bne.n	28108 <z_vprintk+0x2a4>
   28112:	9309      	str	r3, [sp, #36]	; 0x24
				out(' ', ctx);
   28114:	4639      	mov	r1, r7
   28116:	2020      	movs	r0, #32
   28118:	e7f4      	b.n	28104 <z_vprintk+0x2a0>
					out((int)(*s++), ctx);
   2811a:	4639      	mov	r1, r7
   2811c:	47b0      	blx	r6
   2811e:	e6fb      	b.n	27f18 <z_vprintk+0xb4>
				out(c, ctx);
   28120:	4639      	mov	r1, r7
   28122:	f854 0b04 	ldr.w	r0, [r4], #4
   28126:	e6d7      	b.n	27ed8 <z_vprintk+0x74>
				length_mod = 0;
   28128:	46a8      	mov	r8, r5
				padding = PAD_NONE;
   2812a:	46a9      	mov	r9, r5
				min_width = -1;
   2812c:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
				might_format = 1;
   28130:	2501      	movs	r5, #1
   28132:	e6ac      	b.n	27e8e <z_vprintk+0x2a>
				padding = PAD_SPACE_AFTER;
   28134:	f04f 0903 	mov.w	r9, #3
   28138:	e6a9      	b.n	27e8e <z_vprintk+0x2a>
					padding = PAD_ZERO_BEFORE;
   2813a:	f04f 0901 	mov.w	r9, #1
   2813e:	e6a6      	b.n	27e8e <z_vprintk+0x2a>
			might_format = 0;
   28140:	4605      	mov	r5, r0
		++fmt;
   28142:	e6a4      	b.n	27e8e <z_vprintk+0x2a>

00028144 <printk>:
{
   28144:	b40f      	push	{r0, r1, r2, r3}
   28146:	b507      	push	{r0, r1, r2, lr}
   28148:	a904      	add	r1, sp, #16
   2814a:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   2814e:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
   28150:	f7e8 fd7a 	bl	10c48 <vprintk>
}
   28154:	b003      	add	sp, #12
   28156:	f85d eb04 	ldr.w	lr, [sp], #4
   2815a:	b004      	add	sp, #16
   2815c:	4770      	bx	lr

0002815e <snprintk>:
{
   2815e:	b40c      	push	{r2, r3}
   28160:	b507      	push	{r0, r1, r2, lr}
   28162:	ab04      	add	r3, sp, #16
   28164:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
   28168:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
   2816a:	f7e8 fd7b 	bl	10c64 <vsnprintk>
}
   2816e:	b003      	add	sp, #12
   28170:	f85d eb04 	ldr.w	lr, [sp], #4
   28174:	b002      	add	sp, #8
   28176:	4770      	bx	lr

00028178 <ring_buf_space_get>:
 *
 * @return Ring buffer free space (in 32-bit words or bytes).
 */
static inline u32_t ring_buf_space_get(struct ring_buf *buf)
{
	return z_ring_buf_custom_space_get(buf->size, buf->head, buf->tail);
   28178:	6903      	ldr	r3, [r0, #16]
   2817a:	e9d0 2000 	ldrd	r2, r0, [r0]
	if (tail < head) {
   2817e:	4282      	cmp	r2, r0
	return (size - tail) + head - 1;
   28180:	bf96      	itet	ls
   28182:	189b      	addls	r3, r3, r2
		return head - tail - 1;
   28184:	f102 33ff 	addhi.w	r3, r2, #4294967295	; 0xffffffff
	return (size - tail) + head - 1;
   28188:	f103 33ff 	addls.w	r3, r3, #4294967295	; 0xffffffff
   2818c:	1a18      	subs	r0, r3, r0
}
   2818e:	4770      	bx	lr

00028190 <ring_buf_put_claim>:

u32_t ring_buf_put_claim(struct ring_buf *buf, u8_t **data, u32_t size)
{
	u32_t space, trail_size, allocated;

	space = z_ring_buf_custom_space_get(buf->size, buf->head,
   28190:	6803      	ldr	r3, [r0, #0]
{
   28192:	b570      	push	{r4, r5, r6, lr}
	space = z_ring_buf_custom_space_get(buf->size, buf->head,
   28194:	6884      	ldr	r4, [r0, #8]
   28196:	6906      	ldr	r6, [r0, #16]
	if (tail < head) {
   28198:	42a3      	cmp	r3, r4
					    buf->misc.byte_mode.tmp_tail);

	/* Limit requested size to available size. */
	size = MIN(size, space);
	trail_size = buf->size - buf->misc.byte_mode.tmp_tail;
   2819a:	eba6 0504 	sub.w	r5, r6, r4
	return (size - tail) + head - 1;
   2819e:	bf98      	it	ls
   281a0:	199b      	addls	r3, r3, r6
   281a2:	3b01      	subs	r3, #1

	/* Limit allocated size to trail size. */
	allocated = MIN(trail_size, size);
   281a4:	4295      	cmp	r5, r2
   281a6:	eba3 0304 	sub.w	r3, r3, r4
   281aa:	bf28      	it	cs
   281ac:	4615      	movcs	r5, r2
   281ae:	42ab      	cmp	r3, r5

	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_tail];
   281b0:	6942      	ldr	r2, [r0, #20]
	allocated = MIN(trail_size, size);
   281b2:	bf28      	it	cs
   281b4:	462b      	movcs	r3, r5
	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_tail];
   281b6:	4422      	add	r2, r4
	buf->misc.byte_mode.tmp_tail =
		wrap(buf->misc.byte_mode.tmp_tail + allocated, buf->size);
   281b8:	441c      	add	r4, r3
	return val >= max ? (val - max) : val;
   281ba:	42a6      	cmp	r6, r4
   281bc:	bf98      	it	ls
   281be:	1ba4      	subls	r4, r4, r6
	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_tail];
   281c0:	600a      	str	r2, [r1, #0]
	buf->misc.byte_mode.tmp_tail =
   281c2:	6084      	str	r4, [r0, #8]

	return allocated;
}
   281c4:	4618      	mov	r0, r3
   281c6:	bd70      	pop	{r4, r5, r6, pc}

000281c8 <ring_buf_put_finish>:

int ring_buf_put_finish(struct ring_buf *buf, u32_t size)
{
   281c8:	b510      	push	{r4, lr}
   281ca:	4604      	mov	r4, r0
	if (size > ring_buf_space_get(buf)) {
   281cc:	f7ff ffd4 	bl	28178 <ring_buf_space_get>
   281d0:	4288      	cmp	r0, r1
   281d2:	d309      	bcc.n	281e8 <ring_buf_put_finish+0x20>
		return -EINVAL;
	}

	buf->tail = wrap(buf->tail + size, buf->size);
   281d4:	6863      	ldr	r3, [r4, #4]
   281d6:	4419      	add	r1, r3
   281d8:	6923      	ldr	r3, [r4, #16]
	return val >= max ? (val - max) : val;
   281da:	4299      	cmp	r1, r3
   281dc:	bf28      	it	cs
   281de:	1ac9      	subcs	r1, r1, r3
	buf->misc.byte_mode.tmp_tail = buf->tail;
   281e0:	e9c4 1101 	strd	r1, r1, [r4, #4]

	return 0;
   281e4:	2000      	movs	r0, #0
}
   281e6:	bd10      	pop	{r4, pc}
		return -EINVAL;
   281e8:	f06f 0015 	mvn.w	r0, #21
   281ec:	e7fb      	b.n	281e6 <ring_buf_put_finish+0x1e>

000281ee <ring_buf_put>:

u32_t ring_buf_put(struct ring_buf *buf, const u8_t *data, u32_t size)
{
   281ee:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   281f2:	4680      	mov	r8, r0
   281f4:	460f      	mov	r7, r1
   281f6:	4616      	mov	r6, r2
	u8_t *dst;
	u32_t partial_size;
	u32_t total_size = 0U;
   281f8:	2500      	movs	r5, #0
	int err;

	do {
		partial_size = ring_buf_put_claim(buf, &dst, size);
   281fa:	4632      	mov	r2, r6
   281fc:	a901      	add	r1, sp, #4
   281fe:	4640      	mov	r0, r8
   28200:	f7ff ffc6 	bl	28190 <ring_buf_put_claim>
		memcpy(dst, data, partial_size);
   28204:	4639      	mov	r1, r7
		partial_size = ring_buf_put_claim(buf, &dst, size);
   28206:	4604      	mov	r4, r0
		memcpy(dst, data, partial_size);
   28208:	4602      	mov	r2, r0
   2820a:	9801      	ldr	r0, [sp, #4]
   2820c:	f002 f91f 	bl	2a44e <memcpy>
		total_size += partial_size;
		size -= partial_size;
		data += partial_size;
	} while (size && partial_size);
   28210:	1b36      	subs	r6, r6, r4
		total_size += partial_size;
   28212:	4425      	add	r5, r4
		data += partial_size;
   28214:	4427      	add	r7, r4
	} while (size && partial_size);
   28216:	d001      	beq.n	2821c <ring_buf_put+0x2e>
   28218:	2c00      	cmp	r4, #0
   2821a:	d1ee      	bne.n	281fa <ring_buf_put+0xc>

	err = ring_buf_put_finish(buf, total_size);
   2821c:	4629      	mov	r1, r5
   2821e:	4640      	mov	r0, r8
   28220:	f7ff ffd2 	bl	281c8 <ring_buf_put_finish>
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
   28224:	4628      	mov	r0, r5
   28226:	b002      	add	sp, #8
   28228:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002822c <ring_buf_get_claim>:

u32_t ring_buf_get_claim(struct ring_buf *buf, u8_t **data, u32_t size)
{
   2822c:	b5f0      	push	{r4, r5, r6, r7, lr}
	u32_t space, granted_size, trail_size;

	space = (buf->size - 1) -
		z_ring_buf_custom_space_get(buf->size,
   2822e:	e9d0 3603 	ldrd	r3, r6, [r0, #12]
   28232:	6844      	ldr	r4, [r0, #4]
	if (tail < head) {
   28234:	42a3      	cmp	r3, r4
	return (size - tail) + head - 1;
   28236:	bf95      	itete	ls
   28238:	18f7      	addls	r7, r6, r3
		return head - tail - 1;
   2823a:	f103 35ff 	addhi.w	r5, r3, #4294967295	; 0xffffffff
	return (size - tail) + head - 1;
   2823e:	f107 37ff 	addls.w	r7, r7, #4294967295	; 0xffffffff
		return head - tail - 1;
   28242:	1b2d      	subhi	r5, r5, r4
	return (size - tail) + head - 1;
   28244:	bf98      	it	ls
   28246:	1b3d      	subls	r5, r7, r4
	space = (buf->size - 1) -
   28248:	1e74      	subs	r4, r6, #1
   2824a:	1b64      	subs	r4, r4, r5
					    buf->misc.byte_mode.tmp_head,
					    buf->tail);
	trail_size = buf->size - buf->misc.byte_mode.tmp_head;
   2824c:	1af5      	subs	r5, r6, r3

	/* Limit requested size to available size. */
	granted_size = MIN(size, space);

	/* Limit allocated size to trail size. */
	granted_size = MIN(trail_size, granted_size);
   2824e:	42aa      	cmp	r2, r5
   28250:	bf28      	it	cs
   28252:	462a      	movcs	r2, r5
   28254:	42a2      	cmp	r2, r4
   28256:	bf28      	it	cs
   28258:	4622      	movcs	r2, r4

	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_head];
   2825a:	6944      	ldr	r4, [r0, #20]
   2825c:	441c      	add	r4, r3
	buf->misc.byte_mode.tmp_head =
		wrap(buf->misc.byte_mode.tmp_head + granted_size, buf->size);
   2825e:	4413      	add	r3, r2
	return val >= max ? (val - max) : val;
   28260:	429e      	cmp	r6, r3
   28262:	bf98      	it	ls
   28264:	1b9b      	subls	r3, r3, r6
	*data = &buf->buf.buf8[buf->misc.byte_mode.tmp_head];
   28266:	600c      	str	r4, [r1, #0]
	buf->misc.byte_mode.tmp_head =
   28268:	60c3      	str	r3, [r0, #12]

	return granted_size;
}
   2826a:	4610      	mov	r0, r2
   2826c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0002826e <ring_buf_get_finish>:

int ring_buf_get_finish(struct ring_buf *buf, u32_t size)
{
   2826e:	b538      	push	{r3, r4, r5, lr}
	u32_t allocated = (buf->size - 1) - ring_buf_space_get(buf);
   28270:	6905      	ldr	r5, [r0, #16]
{
   28272:	4604      	mov	r4, r0
	u32_t allocated = (buf->size - 1) - ring_buf_space_get(buf);
   28274:	f7ff ff80 	bl	28178 <ring_buf_space_get>
   28278:	1e6b      	subs	r3, r5, #1
   2827a:	1a18      	subs	r0, r3, r0

	if (size > allocated) {
   2827c:	4288      	cmp	r0, r1
   2827e:	d308      	bcc.n	28292 <ring_buf_get_finish+0x24>
		return -EINVAL;
	}

	buf->head = wrap(buf->head + size, buf->size);
   28280:	6823      	ldr	r3, [r4, #0]
   28282:	4419      	add	r1, r3
	return val >= max ? (val - max) : val;
   28284:	428d      	cmp	r5, r1
   28286:	bf98      	it	ls
   28288:	1b49      	subls	r1, r1, r5
	buf->head = wrap(buf->head + size, buf->size);
   2828a:	6021      	str	r1, [r4, #0]
	buf->misc.byte_mode.tmp_head = buf->head;
   2828c:	60e1      	str	r1, [r4, #12]

	return 0;
   2828e:	2000      	movs	r0, #0
}
   28290:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   28292:	f06f 0015 	mvn.w	r0, #21
   28296:	e7fb      	b.n	28290 <ring_buf_get_finish+0x22>

00028298 <ring_buf_get>:

u32_t ring_buf_get(struct ring_buf *buf, u8_t *data, u32_t size)
{
   28298:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   2829c:	4680      	mov	r8, r0
   2829e:	460f      	mov	r7, r1
   282a0:	4616      	mov	r6, r2
	u8_t *src;
	u32_t partial_size;
	u32_t total_size = 0U;
   282a2:	2500      	movs	r5, #0
	int err;

	do {
		partial_size = ring_buf_get_claim(buf, &src, size);
   282a4:	4632      	mov	r2, r6
   282a6:	a901      	add	r1, sp, #4
   282a8:	4640      	mov	r0, r8
   282aa:	f7ff ffbf 	bl	2822c <ring_buf_get_claim>
		memcpy(data, src, partial_size);
   282ae:	9901      	ldr	r1, [sp, #4]
		partial_size = ring_buf_get_claim(buf, &src, size);
   282b0:	4604      	mov	r4, r0
		memcpy(data, src, partial_size);
   282b2:	4602      	mov	r2, r0
   282b4:	4638      	mov	r0, r7
   282b6:	f002 f8ca 	bl	2a44e <memcpy>
		total_size += partial_size;
		size -= partial_size;
		data += partial_size;
	} while (size && partial_size);
   282ba:	1b36      	subs	r6, r6, r4
		total_size += partial_size;
   282bc:	4425      	add	r5, r4
		data += partial_size;
   282be:	4427      	add	r7, r4
	} while (size && partial_size);
   282c0:	d001      	beq.n	282c6 <ring_buf_get+0x2e>
   282c2:	2c00      	cmp	r4, #0
   282c4:	d1ee      	bne.n	282a4 <ring_buf_get+0xc>

	err = ring_buf_get_finish(buf, total_size);
   282c6:	4629      	mov	r1, r5
   282c8:	4640      	mov	r0, r8
   282ca:	f7ff ffd0 	bl	2826e <ring_buf_get_finish>
	__ASSERT_NO_MSG(err == 0);

	return total_size;
}
   282ce:	4628      	mov	r0, r5
   282d0:	b002      	add	sp, #8
   282d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000282d6 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_BOOTLOADER_MCUBOOT, 1);
GEN_ABSOLUTE_SYM(CONFIG_REBOOT, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   282d6:	4770      	bx	lr

000282d8 <_copy>:
#define MASK_TWENTY_SEVEN 0x1b

unsigned int _copy(uint8_t *to, unsigned int to_len,
		   const uint8_t *from, unsigned int from_len)
{
	if (from_len <= to_len) {
   282d8:	428b      	cmp	r3, r1
{
   282da:	b538      	push	{r3, r4, r5, lr}
   282dc:	4615      	mov	r5, r2
   282de:	461c      	mov	r4, r3
	if (from_len <= to_len) {
   282e0:	d805      	bhi.n	282ee <_copy+0x16>
		(void)memcpy(to, from, from_len);
   282e2:	461a      	mov	r2, r3
   282e4:	4629      	mov	r1, r5
   282e6:	f002 f8b2 	bl	2a44e <memcpy>
		return from_len;
	} else {
		return TC_CRYPTO_FAIL;
	}
}
   282ea:	4620      	mov	r0, r4
   282ec:	bd38      	pop	{r3, r4, r5, pc}
		return TC_CRYPTO_FAIL;
   282ee:	2400      	movs	r4, #0
   282f0:	e7fb      	b.n	282ea <_copy+0x12>

000282f2 <_set>:

void _set(void *to, uint8_t val, unsigned int len)
{
	(void)memset(to, val, len);
   282f2:	f002 b8d6 	b.w	2a4a2 <memset>

000282f6 <_double_byte>:
/*
 * Doubles the value of a byte for values up to 127.
 */
uint8_t _double_byte(uint8_t a)
{
	return ((a<<1) ^ ((a>>7) * MASK_TWENTY_SEVEN));
   282f6:	09c3      	lsrs	r3, r0, #7
   282f8:	005a      	lsls	r2, r3, #1
   282fa:	4413      	add	r3, r2
   282fc:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
   28300:	ea83 0040 	eor.w	r0, r3, r0, lsl #1
}
   28304:	b2c0      	uxtb	r0, r0
   28306:	4770      	bx	lr

00028308 <add_round_key>:
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
   28308:	78cb      	ldrb	r3, [r1, #3]
   2830a:	7802      	ldrb	r2, [r0, #0]
   2830c:	4053      	eors	r3, r2
   2830e:	7003      	strb	r3, [r0, #0]
   28310:	884b      	ldrh	r3, [r1, #2]
   28312:	7842      	ldrb	r2, [r0, #1]
   28314:	4053      	eors	r3, r2
   28316:	7043      	strb	r3, [r0, #1]
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
   28318:	680a      	ldr	r2, [r1, #0]
   2831a:	7883      	ldrb	r3, [r0, #2]
   2831c:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   28320:	7083      	strb	r3, [r0, #2]
   28322:	680a      	ldr	r2, [r1, #0]
   28324:	78c3      	ldrb	r3, [r0, #3]
   28326:	4053      	eors	r3, r2
   28328:	70c3      	strb	r3, [r0, #3]
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
   2832a:	79cb      	ldrb	r3, [r1, #7]
   2832c:	7902      	ldrb	r2, [r0, #4]
   2832e:	4053      	eors	r3, r2
   28330:	7103      	strb	r3, [r0, #4]
   28332:	88cb      	ldrh	r3, [r1, #6]
   28334:	7942      	ldrb	r2, [r0, #5]
   28336:	4053      	eors	r3, r2
   28338:	7143      	strb	r3, [r0, #5]
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
   2833a:	684a      	ldr	r2, [r1, #4]
   2833c:	7983      	ldrb	r3, [r0, #6]
   2833e:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   28342:	7183      	strb	r3, [r0, #6]
   28344:	684a      	ldr	r2, [r1, #4]
   28346:	79c3      	ldrb	r3, [r0, #7]
   28348:	4053      	eors	r3, r2
   2834a:	71c3      	strb	r3, [r0, #7]
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
   2834c:	7acb      	ldrb	r3, [r1, #11]
   2834e:	7a02      	ldrb	r2, [r0, #8]
   28350:	4053      	eors	r3, r2
   28352:	7203      	strb	r3, [r0, #8]
   28354:	7a42      	ldrb	r2, [r0, #9]
   28356:	894b      	ldrh	r3, [r1, #10]
   28358:	4053      	eors	r3, r2
   2835a:	7243      	strb	r3, [r0, #9]
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
   2835c:	688a      	ldr	r2, [r1, #8]
   2835e:	7a83      	ldrb	r3, [r0, #10]
   28360:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   28364:	7283      	strb	r3, [r0, #10]
   28366:	688a      	ldr	r2, [r1, #8]
   28368:	7ac3      	ldrb	r3, [r0, #11]
   2836a:	4053      	eors	r3, r2
   2836c:	72c3      	strb	r3, [r0, #11]
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
   2836e:	7bcb      	ldrb	r3, [r1, #15]
   28370:	7b02      	ldrb	r2, [r0, #12]
   28372:	4053      	eors	r3, r2
   28374:	7303      	strb	r3, [r0, #12]
   28376:	89cb      	ldrh	r3, [r1, #14]
   28378:	7b42      	ldrb	r2, [r0, #13]
   2837a:	4053      	eors	r3, r2
   2837c:	7343      	strb	r3, [r0, #13]
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
   2837e:	68ca      	ldr	r2, [r1, #12]
   28380:	7b83      	ldrb	r3, [r0, #14]
   28382:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   28386:	7383      	strb	r3, [r0, #14]
   28388:	68ca      	ldr	r2, [r1, #12]
   2838a:	7bc3      	ldrb	r3, [r0, #15]
   2838c:	4053      	eors	r3, r2
   2838e:	73c3      	strb	r3, [r0, #15]
}
   28390:	4770      	bx	lr

00028392 <shift_rows>:
{
   28392:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
   28394:	7802      	ldrb	r2, [r0, #0]
   28396:	f88d 2000 	strb.w	r2, [sp]
   2839a:	7942      	ldrb	r2, [r0, #5]
   2839c:	f88d 2001 	strb.w	r2, [sp, #1]
   283a0:	7a82      	ldrb	r2, [r0, #10]
   283a2:	f88d 2002 	strb.w	r2, [sp, #2]
   283a6:	7bc2      	ldrb	r2, [r0, #15]
   283a8:	f88d 2003 	strb.w	r2, [sp, #3]
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
   283ac:	7902      	ldrb	r2, [r0, #4]
   283ae:	f88d 2004 	strb.w	r2, [sp, #4]
   283b2:	7a42      	ldrb	r2, [r0, #9]
   283b4:	f88d 2005 	strb.w	r2, [sp, #5]
   283b8:	7b82      	ldrb	r2, [r0, #14]
   283ba:	f88d 2006 	strb.w	r2, [sp, #6]
   283be:	78c2      	ldrb	r2, [r0, #3]
   283c0:	f88d 2007 	strb.w	r2, [sp, #7]
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
   283c4:	7a02      	ldrb	r2, [r0, #8]
   283c6:	f88d 2008 	strb.w	r2, [sp, #8]
   283ca:	7b42      	ldrb	r2, [r0, #13]
   283cc:	f88d 2009 	strb.w	r2, [sp, #9]
   283d0:	7882      	ldrb	r2, [r0, #2]
   283d2:	f88d 200a 	strb.w	r2, [sp, #10]
   283d6:	79c2      	ldrb	r2, [r0, #7]
   283d8:	f88d 200b 	strb.w	r2, [sp, #11]
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
   283dc:	7b02      	ldrb	r2, [r0, #12]
   283de:	f88d 200c 	strb.w	r2, [sp, #12]
   283e2:	7842      	ldrb	r2, [r0, #1]
   283e4:	f88d 200d 	strb.w	r2, [sp, #13]
   283e8:	7ac3      	ldrb	r3, [r0, #11]
   283ea:	7982      	ldrb	r2, [r0, #6]
   283ec:	f88d 200e 	strb.w	r2, [sp, #14]
   283f0:	f88d 300f 	strb.w	r3, [sp, #15]
	(void) _copy(s, sizeof(t), t, sizeof(t));
   283f4:	2310      	movs	r3, #16
   283f6:	466a      	mov	r2, sp
   283f8:	4619      	mov	r1, r3
   283fa:	f7ff ff6d 	bl	282d8 <_copy>
}
   283fe:	b005      	add	sp, #20
   28400:	f85d fb04 	ldr.w	pc, [sp], #4

00028404 <mult_row_column>:
{
   28404:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   28406:	4606      	mov	r6, r0
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   28408:	7808      	ldrb	r0, [r1, #0]
{
   2840a:	460c      	mov	r4, r1
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   2840c:	f7ff ff73 	bl	282f6 <_double_byte>
   28410:	4605      	mov	r5, r0
   28412:	7860      	ldrb	r0, [r4, #1]
   28414:	f7ff ff6f 	bl	282f6 <_double_byte>
   28418:	78a2      	ldrb	r2, [r4, #2]
   2841a:	7863      	ldrb	r3, [r4, #1]
   2841c:	4053      	eors	r3, r2
   2841e:	78e2      	ldrb	r2, [r4, #3]
   28420:	4053      	eors	r3, r2
   28422:	405d      	eors	r5, r3
   28424:	4045      	eors	r5, r0
   28426:	7035      	strb	r5, [r6, #0]
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
   28428:	7860      	ldrb	r0, [r4, #1]
   2842a:	7827      	ldrb	r7, [r4, #0]
   2842c:	f7ff ff63 	bl	282f6 <_double_byte>
   28430:	4605      	mov	r5, r0
   28432:	78a0      	ldrb	r0, [r4, #2]
   28434:	f7ff ff5f 	bl	282f6 <_double_byte>
   28438:	78a3      	ldrb	r3, [r4, #2]
   2843a:	405f      	eors	r7, r3
   2843c:	78e3      	ldrb	r3, [r4, #3]
   2843e:	405f      	eors	r7, r3
   28440:	407d      	eors	r5, r7
   28442:	4045      	eors	r5, r0
   28444:	7075      	strb	r5, [r6, #1]
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
   28446:	78a0      	ldrb	r0, [r4, #2]
   28448:	7865      	ldrb	r5, [r4, #1]
   2844a:	7827      	ldrb	r7, [r4, #0]
   2844c:	f7ff ff53 	bl	282f6 <_double_byte>
   28450:	406f      	eors	r7, r5
   28452:	4605      	mov	r5, r0
   28454:	78e0      	ldrb	r0, [r4, #3]
   28456:	f7ff ff4e 	bl	282f6 <_double_byte>
   2845a:	78e3      	ldrb	r3, [r4, #3]
   2845c:	405f      	eors	r7, r3
   2845e:	407d      	eors	r5, r7
   28460:	4045      	eors	r5, r0
   28462:	70b5      	strb	r5, [r6, #2]
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
   28464:	7820      	ldrb	r0, [r4, #0]
   28466:	f7ff ff46 	bl	282f6 <_double_byte>
   2846a:	7863      	ldrb	r3, [r4, #1]
   2846c:	7825      	ldrb	r5, [r4, #0]
   2846e:	405d      	eors	r5, r3
   28470:	78a3      	ldrb	r3, [r4, #2]
   28472:	405d      	eors	r5, r3
   28474:	4045      	eors	r5, r0
   28476:	78e0      	ldrb	r0, [r4, #3]
   28478:	f7ff ff3d 	bl	282f6 <_double_byte>
   2847c:	b2ed      	uxtb	r5, r5
   2847e:	4068      	eors	r0, r5
   28480:	70f0      	strb	r0, [r6, #3]
}
   28482:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00028484 <gf_double>:
 *           the in and out buffers do not overlap.
 *  effects: doubles the GF(2^n) value pointed to by "in" and places
 *           the result in the GF(2^n) value pointed to by "out."
 */
void gf_double(uint8_t *out, uint8_t *in)
{
   28484:	b510      	push	{r4, lr}

	/* start with low order byte */
	uint8_t *x = in + (TC_AES_BLOCK_SIZE - 1);

	/* if msb == 1, we need to add the gf_wrap value, otherwise add 0 */
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
   28486:	460a      	mov	r2, r1

	out += (TC_AES_BLOCK_SIZE - 1);
   28488:	300f      	adds	r0, #15
	uint8_t carry = (in[0] >> 7) ? gf_wrap : 0;
   2848a:	f912 3b10 	ldrsb.w	r3, [r2], #16
   2848e:	2b00      	cmp	r3, #0
   28490:	bfb4      	ite	lt
   28492:	2387      	movlt	r3, #135	; 0x87
   28494:	2300      	movge	r3, #0
	for (;;) {
		*out-- = (*x << 1) ^ carry;
   28496:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
   2849a:	ea83 0344 	eor.w	r3, r3, r4, lsl #1
		if (x == in) {
   2849e:	4291      	cmp	r1, r2
		*out-- = (*x << 1) ^ carry;
   284a0:	f800 3901 	strb.w	r3, [r0], #-1
		if (x == in) {
   284a4:	d002      	beq.n	284ac <gf_double+0x28>
			break;
		}
		carry = *x-- >> 7;
   284a6:	7813      	ldrb	r3, [r2, #0]
   284a8:	09db      	lsrs	r3, r3, #7
		*out-- = (*x << 1) ^ carry;
   284aa:	e7f4      	b.n	28496 <gf_double+0x12>
	}
}
   284ac:	bd10      	pop	{r4, pc}

000284ae <tc_cmac_erase>:

	return TC_CRYPTO_SUCCESS;
}

int tc_cmac_erase(TCCmacState_t s)
{
   284ae:	b508      	push	{r3, lr}
	if (s == (TCCmacState_t) 0) {
   284b0:	b120      	cbz	r0, 284bc <tc_cmac_erase+0xe>
		return TC_CRYPTO_FAIL;
	}

	/* destroy the current state */
	_set(s, 0, sizeof(*s));
   284b2:	2258      	movs	r2, #88	; 0x58
   284b4:	2100      	movs	r1, #0
   284b6:	f7ff ff1c 	bl	282f2 <_set>
   284ba:	2001      	movs	r0, #1

	return TC_CRYPTO_SUCCESS;
}
   284bc:	bd08      	pop	{r3, pc}

000284be <tc_cmac_init>:

int tc_cmac_init(TCCmacState_t s)
{
   284be:	b510      	push	{r4, lr}
	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
   284c0:	4604      	mov	r4, r0
   284c2:	b188      	cbz	r0, 284e8 <tc_cmac_init+0x2a>
		return TC_CRYPTO_FAIL;
	}

	/* CMAC starts with an all zero initialization vector */
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
   284c4:	2210      	movs	r2, #16
   284c6:	2100      	movs	r1, #0
   284c8:	f7ff ff13 	bl	282f2 <_set>

	/* and the leftover buffer is empty */
	_set(s->leftover, 0, TC_AES_BLOCK_SIZE);
   284cc:	2210      	movs	r2, #16
   284ce:	f104 0030 	add.w	r0, r4, #48	; 0x30
   284d2:	2100      	movs	r1, #0
   284d4:	f7ff ff0d 	bl	282f2 <_set>
	s->leftover_offset = 0;
   284d8:	2300      	movs	r3, #0
   284da:	6463      	str	r3, [r4, #68]	; 0x44

	/* Set countdown to max number of calls allowed before re-keying: */
	s->countdown = MAX_CALLS;
   284dc:	2200      	movs	r2, #0
   284de:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   284e2:	e9c4 2314 	strd	r2, r3, [r4, #80]	; 0x50
   284e6:	2001      	movs	r0, #1

	return TC_CRYPTO_SUCCESS;
}
   284e8:	bd10      	pop	{r4, pc}

000284ea <tc_cmac_setup>:
{
   284ea:	b570      	push	{r4, r5, r6, lr}
   284ec:	460d      	mov	r5, r1
   284ee:	4616      	mov	r6, r2
	if (s == (TCCmacState_t) 0 ||
   284f0:	4604      	mov	r4, r0
   284f2:	b310      	cbz	r0, 2853a <tc_cmac_setup+0x50>
   284f4:	b311      	cbz	r1, 2853c <tc_cmac_setup+0x52>
	_set(s, 0, sizeof(*s));
   284f6:	2258      	movs	r2, #88	; 0x58
   284f8:	2100      	movs	r1, #0
   284fa:	f7ff fefa 	bl	282f2 <_set>
	tc_aes128_set_encrypt_key(s->sched, key);
   284fe:	4629      	mov	r1, r5
	s->sched = sched;
   28500:	64a6      	str	r6, [r4, #72]	; 0x48
	tc_aes128_set_encrypt_key(s->sched, key);
   28502:	4630      	mov	r0, r6
   28504:	f7e8 fbc2 	bl	10c8c <tc_aes128_set_encrypt_key>
	_set(s->iv, 0, TC_AES_BLOCK_SIZE);
   28508:	2210      	movs	r2, #16
   2850a:	2100      	movs	r1, #0
   2850c:	4620      	mov	r0, r4
   2850e:	f7ff fef0 	bl	282f2 <_set>
	gf_double (s->K1, s->iv);
   28512:	f104 0510 	add.w	r5, r4, #16
	tc_aes_encrypt(s->iv, s->iv, s->sched);
   28516:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   28518:	4621      	mov	r1, r4
   2851a:	4620      	mov	r0, r4
   2851c:	f7e8 fc0c 	bl	10d38 <tc_aes_encrypt>
	gf_double (s->K1, s->iv);
   28520:	4621      	mov	r1, r4
   28522:	4628      	mov	r0, r5
   28524:	f7ff ffae 	bl	28484 <gf_double>
	gf_double (s->K2, s->K1);
   28528:	4629      	mov	r1, r5
   2852a:	f104 0020 	add.w	r0, r4, #32
   2852e:	f7ff ffa9 	bl	28484 <gf_double>
	tc_cmac_init(s);
   28532:	4620      	mov	r0, r4
   28534:	f7ff ffc3 	bl	284be <tc_cmac_init>
	return TC_CRYPTO_SUCCESS;
   28538:	2001      	movs	r0, #1
}
   2853a:	bd70      	pop	{r4, r5, r6, pc}
		return TC_CRYPTO_FAIL;
   2853c:	4608      	mov	r0, r1
   2853e:	e7fc      	b.n	2853a <tc_cmac_setup+0x50>

00028540 <tc_cmac_update>:

int tc_cmac_update(TCCmacState_t s, const uint8_t *data, size_t data_length)
{
   28540:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   28544:	460d      	mov	r5, r1
   28546:	4616      	mov	r6, r2
	unsigned int i;

	/* input sanity check: */
	if (s == (TCCmacState_t) 0) {
   28548:	4604      	mov	r4, r0
   2854a:	2800      	cmp	r0, #0
   2854c:	d061      	beq.n	28612 <tc_cmac_update+0xd2>
		return TC_CRYPTO_FAIL;
	}
	if (data_length == 0) {
   2854e:	b912      	cbnz	r2, 28556 <tc_cmac_update+0x16>
		/* save leftover data for next time */
		_copy(s->leftover, data_length, data, data_length);
		s->leftover_offset = data_length;
	}

	return TC_CRYPTO_SUCCESS;
   28550:	2001      	movs	r0, #1
}
   28552:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (data == (const uint8_t *) 0) {
   28556:	2900      	cmp	r1, #0
   28558:	d05b      	beq.n	28612 <tc_cmac_update+0xd2>
	if (s->countdown == 0) {
   2855a:	e9d0 0114 	ldrd	r0, r1, [r0, #80]	; 0x50
   2855e:	ea50 0301 	orrs.w	r3, r0, r1
   28562:	d056      	beq.n	28612 <tc_cmac_update+0xd2>
	s->countdown--;
   28564:	f110 32ff 	adds.w	r2, r0, #4294967295	; 0xffffffff
	if (s->leftover_offset > 0) {
   28568:	f8d4 8044 	ldr.w	r8, [r4, #68]	; 0x44
	s->countdown--;
   2856c:	f141 33ff 	adc.w	r3, r1, #4294967295	; 0xffffffff
   28570:	e9c4 2314 	strd	r2, r3, [r4, #80]	; 0x50
	if (s->leftover_offset > 0) {
   28574:	f1b8 0f00 	cmp.w	r8, #0
   28578:	d02a      	beq.n	285d0 <tc_cmac_update+0x90>
		size_t remaining_space = TC_AES_BLOCK_SIZE - s->leftover_offset;
   2857a:	f1c8 0710 	rsb	r7, r8, #16
		if (data_length < remaining_space) {
   2857e:	f108 0030 	add.w	r0, r8, #48	; 0x30
   28582:	42be      	cmp	r6, r7
   28584:	4420      	add	r0, r4
   28586:	d208      	bcs.n	2859a <tc_cmac_update+0x5a>
			_copy(&s->leftover[s->leftover_offset], data_length, data, data_length);
   28588:	4633      	mov	r3, r6
   2858a:	4631      	mov	r1, r6
   2858c:	462a      	mov	r2, r5
   2858e:	f7ff fea3 	bl	282d8 <_copy>
			s->leftover_offset += data_length;
   28592:	6c63      	ldr	r3, [r4, #68]	; 0x44
   28594:	441e      	add	r6, r3
		s->leftover_offset = data_length;
   28596:	6466      	str	r6, [r4, #68]	; 0x44
   28598:	e7da      	b.n	28550 <tc_cmac_update+0x10>
		_copy(&s->leftover[s->leftover_offset],
   2859a:	463b      	mov	r3, r7
   2859c:	462a      	mov	r2, r5
   2859e:	4639      	mov	r1, r7
   285a0:	f7ff fe9a 	bl	282d8 <_copy>
		data_length -= remaining_space;
   285a4:	3e10      	subs	r6, #16
		s->leftover_offset = 0;
   285a6:	2300      	movs	r3, #0
   285a8:	6463      	str	r3, [r4, #68]	; 0x44
		data_length -= remaining_space;
   285aa:	4446      	add	r6, r8
		data += remaining_space;
   285ac:	443d      	add	r5, r7
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   285ae:	1e63      	subs	r3, r4, #1
   285b0:	f104 010f 	add.w	r1, r4, #15
			s->iv[i] ^= s->leftover[i];
   285b4:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   285b8:	f893 0030 	ldrb.w	r0, [r3, #48]	; 0x30
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   285bc:	428b      	cmp	r3, r1
			s->iv[i] ^= s->leftover[i];
   285be:	ea82 0200 	eor.w	r2, r2, r0
   285c2:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   285c4:	d1f6      	bne.n	285b4 <tc_cmac_update+0x74>
		tc_aes_encrypt(s->iv, s->iv, s->sched);
   285c6:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   285c8:	4621      	mov	r1, r4
   285ca:	4620      	mov	r0, r4
   285cc:	f7e8 fbb4 	bl	10d38 <tc_aes_encrypt>
   285d0:	f104 070f 	add.w	r7, r4, #15
	while (data_length > TC_AES_BLOCK_SIZE) {
   285d4:	2e10      	cmp	r6, #16
   285d6:	d809      	bhi.n	285ec <tc_cmac_update+0xac>
	if (data_length > 0) {
   285d8:	2e00      	cmp	r6, #0
   285da:	d0b9      	beq.n	28550 <tc_cmac_update+0x10>
		_copy(s->leftover, data_length, data, data_length);
   285dc:	4633      	mov	r3, r6
   285de:	462a      	mov	r2, r5
   285e0:	4631      	mov	r1, r6
   285e2:	f104 0030 	add.w	r0, r4, #48	; 0x30
   285e6:	f7ff fe77 	bl	282d8 <_copy>
   285ea:	e7d4      	b.n	28596 <tc_cmac_update+0x56>
   285ec:	1e63      	subs	r3, r4, #1
   285ee:	1e69      	subs	r1, r5, #1
			s->iv[i] ^= data[i];
   285f0:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   285f4:	f811 0f01 	ldrb.w	r0, [r1, #1]!
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   285f8:	42bb      	cmp	r3, r7
			s->iv[i] ^= data[i];
   285fa:	ea82 0200 	eor.w	r2, r2, r0
   285fe:	701a      	strb	r2, [r3, #0]
		for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   28600:	d1f6      	bne.n	285f0 <tc_cmac_update+0xb0>
		tc_aes_encrypt(s->iv, s->iv, s->sched);
   28602:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   28604:	4621      	mov	r1, r4
   28606:	4620      	mov	r0, r4
   28608:	f7e8 fb96 	bl	10d38 <tc_aes_encrypt>
		data += TC_AES_BLOCK_SIZE;
   2860c:	3510      	adds	r5, #16
		data_length  -= TC_AES_BLOCK_SIZE;
   2860e:	3e10      	subs	r6, #16
   28610:	e7e0      	b.n	285d4 <tc_cmac_update+0x94>
		return TC_CRYPTO_FAIL;
   28612:	2000      	movs	r0, #0
   28614:	e79d      	b.n	28552 <tc_cmac_update+0x12>

00028616 <tc_cmac_final>:

int tc_cmac_final(uint8_t *tag, TCCmacState_t s)
{
   28616:	b570      	push	{r4, r5, r6, lr}
   28618:	460c      	mov	r4, r1
	uint8_t *k;
	unsigned int i;

	/* input sanity check: */
	if (tag == (uint8_t *) 0 ||
   2861a:	4605      	mov	r5, r0
   2861c:	b1e8      	cbz	r0, 2865a <tc_cmac_final+0x44>
   2861e:	b369      	cbz	r1, 2867c <tc_cmac_final+0x66>
	    s == (TCCmacState_t) 0) {
		return TC_CRYPTO_FAIL;
	}

	if (s->leftover_offset == TC_AES_BLOCK_SIZE) {
   28620:	6c4a      	ldr	r2, [r1, #68]	; 0x44
   28622:	2a10      	cmp	r2, #16
   28624:	d11a      	bne.n	2865c <tc_cmac_final+0x46>
		/* the last message block is a full-sized block */
		k = (uint8_t *) s->K1;
   28626:	3110      	adds	r1, #16

		_set(&s->leftover[s->leftover_offset], 0, remaining);
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
		k = (uint8_t *) s->K2;
	}
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   28628:	1e63      	subs	r3, r4, #1
   2862a:	3901      	subs	r1, #1
   2862c:	f104 000f 	add.w	r0, r4, #15
		s->iv[i] ^= s->leftover[i] ^ k[i];
   28630:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   28634:	f893 6030 	ldrb.w	r6, [r3, #48]	; 0x30
   28638:	4072      	eors	r2, r6
   2863a:	f811 6f01 	ldrb.w	r6, [r1, #1]!
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   2863e:	4298      	cmp	r0, r3
		s->iv[i] ^= s->leftover[i] ^ k[i];
   28640:	ea82 0206 	eor.w	r2, r2, r6
   28644:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < TC_AES_BLOCK_SIZE; ++i) {
   28646:	d1f3      	bne.n	28630 <tc_cmac_final+0x1a>
	}

	tc_aes_encrypt(tag, s->iv, s->sched);
   28648:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   2864a:	4621      	mov	r1, r4
   2864c:	4628      	mov	r0, r5
   2864e:	f7e8 fb73 	bl	10d38 <tc_aes_encrypt>

	/* erasing state: */
	tc_cmac_erase(s);
   28652:	4620      	mov	r0, r4
   28654:	f7ff ff2b 	bl	284ae <tc_cmac_erase>

	return TC_CRYPTO_SUCCESS;
   28658:	2001      	movs	r0, #1
}
   2865a:	bd70      	pop	{r4, r5, r6, pc}
		_set(&s->leftover[s->leftover_offset], 0, remaining);
   2865c:	f102 0030 	add.w	r0, r2, #48	; 0x30
   28660:	2100      	movs	r1, #0
   28662:	f1c2 0210 	rsb	r2, r2, #16
   28666:	4420      	add	r0, r4
   28668:	f7ff fe43 	bl	282f2 <_set>
		s->leftover[s->leftover_offset] = TC_CMAC_PADDING;
   2866c:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2866e:	4423      	add	r3, r4
   28670:	2280      	movs	r2, #128	; 0x80
   28672:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
		k = (uint8_t *) s->K2;
   28676:	f104 0120 	add.w	r1, r4, #32
   2867a:	e7d5      	b.n	28628 <tc_cmac_final+0x12>
		return TC_CRYPTO_FAIL;
   2867c:	4608      	mov	r0, r1
   2867e:	e7ec      	b.n	2865a <tc_cmac_final+0x44>

00028680 <foldcase>:
#define EOS    '\0'

static inline int foldcase(int ch, int flags)
{

    if ((flags & FNM_CASEFOLD) != 0 && isupper(ch))
   28680:	070b      	lsls	r3, r1, #28
   28682:	d504      	bpl.n	2868e <foldcase+0xe>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   28684:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
   28688:	2b19      	cmp	r3, #25
			((ua | 32U) - (unsigned)'a' < 6U));
}

static inline int tolower(int chr)
{
	return (chr >= (int)'A' && chr <= (int)'Z') ? (chr + 32) : (chr);
   2868a:	bf98      	it	ls
   2868c:	3020      	addls	r0, #32
        return tolower(ch);
    return ch;
}
   2868e:	4770      	bx	lr

00028690 <fnmatchx>:
    return ok == negate ? NULL : pattern;
}


static int fnmatchx(const char *pattern, const char *string, int flags, size_t recursion)
{
   28690:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   28694:	b087      	sub	sp, #28
   28696:	468a      	mov	sl, r1
   28698:	4614      	mov	r4, r2
   2869a:	9302      	str	r3, [sp, #8]
    const char *stringstart, *r;
    char c, test;

    if ((pattern == NULL) || (string == NULL))
   2869c:	4605      	mov	r5, r0
   2869e:	b918      	cbnz	r0, 286a8 <fnmatchx+0x18>
    {
        return FNM_NOMATCH;
   286a0:	2001      	movs	r0, #1
                return FNM_NOMATCH;
            break;
        }
    }
    /* NOTREACHED */
}
   286a2:	b007      	add	sp, #28
   286a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if ((pattern == NULL) || (string == NULL))
   286a8:	2900      	cmp	r1, #0
   286aa:	d0f9      	beq.n	286a0 <fnmatchx+0x10>
    if (recursion-- == 0)
   286ac:	9b02      	ldr	r3, [sp, #8]
   286ae:	2b00      	cmp	r3, #0
   286b0:	f000 8114 	beq.w	288dc <fnmatchx+0x24c>
            if (*string == '.' && (flags & FNM_PERIOD) &&
   286b4:	f004 0304 	and.w	r3, r4, #4
   286b8:	460a      	mov	r2, r1
   286ba:	9304      	str	r3, [sp, #16]
        switch (c = FOLDCASE(*pattern++, flags)) {
   286bc:	46a8      	mov	r8, r5
   286be:	4621      	mov	r1, r4
   286c0:	f818 0b01 	ldrb.w	r0, [r8], #1
   286c4:	f7ff ffdc 	bl	28680 <foldcase>
   286c8:	b2c0      	uxtb	r0, r0
   286ca:	283f      	cmp	r0, #63	; 0x3f
   286cc:	4606      	mov	r6, r0
   286ce:	7817      	ldrb	r7, [r2, #0]
   286d0:	d022      	beq.n	28718 <fnmatchx+0x88>
   286d2:	dc0a      	bgt.n	286ea <fnmatchx+0x5a>
   286d4:	b1c0      	cbz	r0, 28708 <fnmatchx+0x78>
   286d6:	282a      	cmp	r0, #42	; 0x2a
   286d8:	d035      	beq.n	28746 <fnmatchx+0xb6>
            if (c != FOLDCASE(*string++, flags))
   286da:	4621      	mov	r1, r4
   286dc:	4638      	mov	r0, r7
   286de:	3201      	adds	r2, #1
   286e0:	f7ff ffce 	bl	28680 <foldcase>
   286e4:	4286      	cmp	r6, r0
   286e6:	d01e      	beq.n	28726 <fnmatchx+0x96>
   286e8:	e7da      	b.n	286a0 <fnmatchx+0x10>
        switch (c = FOLDCASE(*pattern++, flags)) {
   286ea:	285b      	cmp	r0, #91	; 0x5b
   286ec:	d07a      	beq.n	287e4 <fnmatchx+0x154>
   286ee:	285c      	cmp	r0, #92	; 0x5c
   286f0:	d1f3      	bne.n	286da <fnmatchx+0x4a>
            if (!(flags & FNM_NOESCAPE)) {
   286f2:	07e3      	lsls	r3, r4, #31
   286f4:	d4f1      	bmi.n	286da <fnmatchx+0x4a>
                if ((c = FOLDCASE(*pattern++, flags)) == EOS) {
   286f6:	7868      	ldrb	r0, [r5, #1]
   286f8:	f7ff ffc2 	bl	28680 <foldcase>
   286fc:	b2c6      	uxtb	r6, r0
   286fe:	2e00      	cmp	r6, #0
   28700:	d0eb      	beq.n	286da <fnmatchx+0x4a>
   28702:	f105 0802 	add.w	r8, r5, #2
   28706:	e7e8      	b.n	286da <fnmatchx+0x4a>
            if ((flags & FNM_LEADING_DIR) && *string == '/')
   28708:	06e4      	lsls	r4, r4, #27
   2870a:	d501      	bpl.n	28710 <fnmatchx+0x80>
   2870c:	2f2f      	cmp	r7, #47	; 0x2f
   2870e:	d0c8      	beq.n	286a2 <fnmatchx+0x12>
            return *string == EOS ? 0 : FNM_NOMATCH;
   28710:	1c38      	adds	r0, r7, #0
                        0 : FNM_NOMATCH;
   28712:	bf18      	it	ne
   28714:	2001      	movne	r0, #1
   28716:	e7c4      	b.n	286a2 <fnmatchx+0x12>
            if (*string == EOS)
   28718:	2f00      	cmp	r7, #0
   2871a:	d0c1      	beq.n	286a0 <fnmatchx+0x10>
            if (*string == '/' && (flags & FNM_PATHNAME))
   2871c:	2f2f      	cmp	r7, #47	; 0x2f
   2871e:	d104      	bne.n	2872a <fnmatchx+0x9a>
   28720:	07a1      	lsls	r1, r4, #30
   28722:	d4bd      	bmi.n	286a0 <fnmatchx+0x10>
            ++string;
   28724:	3201      	adds	r2, #1
            break;
   28726:	4645      	mov	r5, r8
   28728:	e7c8      	b.n	286bc <fnmatchx+0x2c>
            if (*string == '.' && (flags & FNM_PERIOD) &&
   2872a:	2f2e      	cmp	r7, #46	; 0x2e
   2872c:	d1fa      	bne.n	28724 <fnmatchx+0x94>
   2872e:	9b04      	ldr	r3, [sp, #16]
   28730:	2b00      	cmp	r3, #0
   28732:	d0f7      	beq.n	28724 <fnmatchx+0x94>
   28734:	4552      	cmp	r2, sl
   28736:	d0b3      	beq.n	286a0 <fnmatchx+0x10>
                (string == stringstart ||
   28738:	07a3      	lsls	r3, r4, #30
   2873a:	d5f3      	bpl.n	28724 <fnmatchx+0x94>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
   2873c:	f812 3c01 	ldrb.w	r3, [r2, #-1]
   28740:	2b2f      	cmp	r3, #47	; 0x2f
   28742:	d1ef      	bne.n	28724 <fnmatchx+0x94>
   28744:	e7ac      	b.n	286a0 <fnmatchx+0x10>
            c = FOLDCASE(*pattern, flags);
   28746:	7868      	ldrb	r0, [r5, #1]
                c = FOLDCASE(*++pattern, flags);
   28748:	f7ff ff9a 	bl	28680 <foldcase>
   2874c:	b2c1      	uxtb	r1, r0
            while (c == '*')
   2874e:	292a      	cmp	r1, #42	; 0x2a
   28750:	d018      	beq.n	28784 <fnmatchx+0xf4>
            if (*string == '.' && (flags & FNM_PERIOD) &&
   28752:	2f2e      	cmp	r7, #46	; 0x2e
   28754:	d109      	bne.n	2876a <fnmatchx+0xda>
   28756:	9b04      	ldr	r3, [sp, #16]
   28758:	b13b      	cbz	r3, 2876a <fnmatchx+0xda>
   2875a:	4552      	cmp	r2, sl
   2875c:	d0a0      	beq.n	286a0 <fnmatchx+0x10>
                (string == stringstart ||
   2875e:	07a7      	lsls	r7, r4, #30
   28760:	d503      	bpl.n	2876a <fnmatchx+0xda>
                ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
   28762:	f812 3c01 	ldrb.w	r3, [r2, #-1]
   28766:	2b2f      	cmp	r3, #47	; 0x2f
   28768:	d09a      	beq.n	286a0 <fnmatchx+0x10>
            if (c == EOS) {
   2876a:	b979      	cbnz	r1, 2878c <fnmatchx+0xfc>
                if (flags & FNM_PATHNAME)
   2876c:	f014 0002 	ands.w	r0, r4, #2
   28770:	d097      	beq.n	286a2 <fnmatchx+0x12>
                        0 : FNM_NOMATCH;
   28772:	06e6      	lsls	r6, r4, #27
   28774:	f100 80b4 	bmi.w	288e0 <fnmatchx+0x250>
                        strchr(string, '/') == NULL ?
   28778:	212f      	movs	r1, #47	; 0x2f
   2877a:	4610      	mov	r0, r2
   2877c:	f001 fe10 	bl	2a3a0 <strchr>
                        0 : FNM_NOMATCH;
   28780:	3000      	adds	r0, #0
   28782:	e7c6      	b.n	28712 <fnmatchx+0x82>
                c = FOLDCASE(*++pattern, flags);
   28784:	4621      	mov	r1, r4
   28786:	f818 0f01 	ldrb.w	r0, [r8, #1]!
   2878a:	e7dd      	b.n	28748 <fnmatchx+0xb8>
            } else if (c == '/' && flags & FNM_PATHNAME) {
   2878c:	292f      	cmp	r1, #47	; 0x2f
   2878e:	d101      	bne.n	28794 <fnmatchx+0x104>
   28790:	07a5      	lsls	r5, r4, #30
   28792:	d420      	bmi.n	287d6 <fnmatchx+0x146>
    if (recursion-- == 0)
   28794:	9b02      	ldr	r3, [sp, #8]
   28796:	4615      	mov	r5, r2
   28798:	1e5f      	subs	r7, r3, #1
                switch ((e = fnmatchx(pattern, string,
   2879a:	f024 0904 	bic.w	r9, r4, #4
                if (test == '/' && flags & FNM_PATHNAME)
   2879e:	f004 0a02 	and.w	sl, r4, #2
   287a2:	46ab      	mov	fp, r5
            while ((test = FOLDCASE(*string, flags)) != EOS) {
   287a4:	4621      	mov	r1, r4
   287a6:	f89b 0000 	ldrb.w	r0, [fp]
   287aa:	f7ff ff69 	bl	28680 <foldcase>
   287ae:	b2c6      	uxtb	r6, r0
   287b0:	3501      	adds	r5, #1
   287b2:	2e00      	cmp	r6, #0
   287b4:	f43f af74 	beq.w	286a0 <fnmatchx+0x10>
                switch ((e = fnmatchx(pattern, string,
   287b8:	463b      	mov	r3, r7
   287ba:	464a      	mov	r2, r9
   287bc:	4659      	mov	r1, fp
   287be:	4640      	mov	r0, r8
   287c0:	f7ff ff66 	bl	28690 <fnmatchx>
   287c4:	2801      	cmp	r0, #1
   287c6:	f47f af6c 	bne.w	286a2 <fnmatchx+0x12>
                if (test == '/' && flags & FNM_PATHNAME)
   287ca:	2e2f      	cmp	r6, #47	; 0x2f
   287cc:	d1e9      	bne.n	287a2 <fnmatchx+0x112>
   287ce:	f1ba 0f00 	cmp.w	sl, #0
   287d2:	d0e6      	beq.n	287a2 <fnmatchx+0x112>
   287d4:	e764      	b.n	286a0 <fnmatchx+0x10>
                if ((string = strchr(string, '/')) == NULL)
   287d6:	4610      	mov	r0, r2
   287d8:	f001 fde2 	bl	2a3a0 <strchr>
   287dc:	4602      	mov	r2, r0
   287de:	2800      	cmp	r0, #0
   287e0:	d1a1      	bne.n	28726 <fnmatchx+0x96>
   287e2:	e75d      	b.n	286a0 <fnmatchx+0x10>
            if (*string == EOS)
   287e4:	2f00      	cmp	r7, #0
   287e6:	f43f af5b 	beq.w	286a0 <fnmatchx+0x10>
            if (*string == '/' && flags & FNM_PATHNAME)
   287ea:	2f2f      	cmp	r7, #47	; 0x2f
   287ec:	d102      	bne.n	287f4 <fnmatchx+0x164>
   287ee:	07a0      	lsls	r0, r4, #30
   287f0:	f53f af56 	bmi.w	286a0 <fnmatchx+0x10>
            if ((r = rangematch(pattern,
   287f4:	4621      	mov	r1, r4
   287f6:	4638      	mov	r0, r7
   287f8:	f7ff ff42 	bl	28680 <foldcase>
   287fc:	9000      	str	r0, [sp, #0]
    if (pattern == NULL)
   287fe:	f1b8 0f00 	cmp.w	r8, #0
   28802:	f43f af4d 	beq.w	286a0 <fnmatchx+0x10>
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
   28806:	786b      	ldrb	r3, [r5, #1]
   28808:	2b21      	cmp	r3, #33	; 0x21
   2880a:	d001      	beq.n	28810 <fnmatchx+0x180>
   2880c:	2b5e      	cmp	r3, #94	; 0x5e
   2880e:	d126      	bne.n	2885e <fnmatchx+0x1ce>
        ++pattern;
   28810:	3502      	adds	r5, #2
   28812:	2301      	movs	r3, #1
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
   28814:	9301      	str	r3, [sp, #4]
    need = 1;
   28816:	2301      	movs	r3, #1
        if (c == '\\' && !(flags & FNM_NOESCAPE))
   28818:	ea04 0103 	and.w	r1, r4, r3
    for (ok = 0; (c = FOLDCASE(*pattern++, flags)) != ']' || need;) {
   2881c:	f04f 0b00 	mov.w	fp, #0
        if (c == '\\' && !(flags & FNM_NOESCAPE))
   28820:	9103      	str	r1, [sp, #12]
    for (ok = 0; (c = FOLDCASE(*pattern++, flags)) != ']' || need;) {
   28822:	462e      	mov	r6, r5
   28824:	4621      	mov	r1, r4
   28826:	f816 0b01 	ldrb.w	r0, [r6], #1
   2882a:	9305      	str	r3, [sp, #20]
   2882c:	f7ff ff28 	bl	28680 <foldcase>
   28830:	fa5f f980 	uxtb.w	r9, r0
   28834:	f1b9 0f5d 	cmp.w	r9, #93	; 0x5d
   28838:	9b05      	ldr	r3, [sp, #20]
   2883a:	d113      	bne.n	28864 <fnmatchx+0x1d4>
   2883c:	bb2b      	cbnz	r3, 2888a <fnmatchx+0x1fa>
    return ok == negate ? NULL : pattern;
   2883e:	9b01      	ldr	r3, [sp, #4]
   28840:	455b      	cmp	r3, fp
   28842:	f43f af2d 	beq.w	286a0 <fnmatchx+0x10>
            if ((r = rangematch(pattern,
   28846:	2e00      	cmp	r6, #0
   28848:	f43f af2a 	beq.w	286a0 <fnmatchx+0x10>
            if (r == (void *)-1) {
   2884c:	1c71      	adds	r1, r6, #1
   2884e:	d103      	bne.n	28858 <fnmatchx+0x1c8>
                if (*string != '[')
   28850:	2f5b      	cmp	r7, #91	; 0x5b
   28852:	f47f af25 	bne.w	286a0 <fnmatchx+0x10>
   28856:	4646      	mov	r6, r8
            ++string;
   28858:	3201      	adds	r2, #1
            break;
   2885a:	46b0      	mov	r8, r6
   2885c:	e763      	b.n	28726 <fnmatchx+0x96>
    if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
   2885e:	4645      	mov	r5, r8
   28860:	2300      	movs	r3, #0
   28862:	e7d7      	b.n	28814 <fnmatchx+0x184>
        if (c == '/')
   28864:	f1b9 0f2f 	cmp.w	r9, #47	; 0x2f
   28868:	d0f2      	beq.n	28850 <fnmatchx+0x1c0>
        if (c == '\\' && !(flags & FNM_NOESCAPE))
   2886a:	f1b9 0f5c 	cmp.w	r9, #92	; 0x5c
   2886e:	d108      	bne.n	28882 <fnmatchx+0x1f2>
   28870:	9b03      	ldr	r3, [sp, #12]
   28872:	b953      	cbnz	r3, 2888a <fnmatchx+0x1fa>
            c = FOLDCASE(*pattern++, flags);
   28874:	4621      	mov	r1, r4
   28876:	7868      	ldrb	r0, [r5, #1]
   28878:	f7ff ff02 	bl	28680 <foldcase>
   2887c:	1cae      	adds	r6, r5, #2
   2887e:	fa5f f980 	uxtb.w	r9, r0
        if (c == EOS)
   28882:	f1b9 0f00 	cmp.w	r9, #0
   28886:	f43f af0b 	beq.w	286a0 <fnmatchx+0x10>
        if (*pattern == '-' 
   2888a:	7833      	ldrb	r3, [r6, #0]
   2888c:	2b2d      	cmp	r3, #45	; 0x2d
   2888e:	d11e      	bne.n	288ce <fnmatchx+0x23e>
            && (c2 = FOLDCASE(*(pattern + 1), flags)) != EOS &&
   28890:	4621      	mov	r1, r4
   28892:	7870      	ldrb	r0, [r6, #1]
   28894:	f7ff fef4 	bl	28680 <foldcase>
   28898:	b2c0      	uxtb	r0, r0
   2889a:	b1c0      	cbz	r0, 288ce <fnmatchx+0x23e>
   2889c:	285d      	cmp	r0, #93	; 0x5d
   2889e:	d016      	beq.n	288ce <fnmatchx+0x23e>
            if (c2 == '\\' && !(flags & FNM_NOESCAPE))
   288a0:	285c      	cmp	r0, #92	; 0x5c
            pattern += 2;
   288a2:	f106 0502 	add.w	r5, r6, #2
            if (c2 == '\\' && !(flags & FNM_NOESCAPE))
   288a6:	d109      	bne.n	288bc <fnmatchx+0x22c>
   288a8:	9b03      	ldr	r3, [sp, #12]
   288aa:	b93b      	cbnz	r3, 288bc <fnmatchx+0x22c>
                c2 = FOLDCASE(*pattern++, flags);
   288ac:	78b0      	ldrb	r0, [r6, #2]
   288ae:	f7ff fee7 	bl	28680 <foldcase>
   288b2:	b2c0      	uxtb	r0, r0
   288b4:	1cf5      	adds	r5, r6, #3
            if (c2 == EOS)
   288b6:	2800      	cmp	r0, #0
   288b8:	f43f aef2 	beq.w	286a0 <fnmatchx+0x10>
            if (c <= test && test <= c2)
   288bc:	9b00      	ldr	r3, [sp, #0]
   288be:	454b      	cmp	r3, r9
   288c0:	db03      	blt.n	288ca <fnmatchx+0x23a>
                ok = 1;
   288c2:	4283      	cmp	r3, r0
   288c4:	bfd8      	it	le
   288c6:	f04f 0b01 	movle.w	fp, #1
   288ca:	2300      	movs	r3, #0
   288cc:	e7a9      	b.n	28822 <fnmatchx+0x192>
        } else if (c == test)
   288ce:	9b00      	ldr	r3, [sp, #0]
   288d0:	4635      	mov	r5, r6
   288d2:	454b      	cmp	r3, r9
   288d4:	bf08      	it	eq
   288d6:	f04f 0b01 	moveq.w	fp, #1
   288da:	e7f6      	b.n	288ca <fnmatchx+0x23a>
        return FNM_NORES;
   288dc:	2003      	movs	r0, #3
   288de:	e6e0      	b.n	286a2 <fnmatchx+0x12>
                return 0;
   288e0:	4608      	mov	r0, r1
   288e2:	e6de      	b.n	286a2 <fnmatchx+0x12>

000288e4 <fnmatch>:

int fnmatch(const char *pattern, const char *string, int flags)
{
    return fnmatchx(pattern, string, flags, 64);
   288e4:	2340      	movs	r3, #64	; 0x40
   288e6:	f7ff bed3 	b.w	28690 <fnmatchx>

000288ea <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
   288ea:	2300      	movs	r3, #0
	list->head = NULL;
   288ec:	e9c0 3300 	strd	r3, r3, [r0]
}
   288f0:	4770      	bx	lr

000288f2 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
   288f2:	6803      	ldr	r3, [r0, #0]
   288f4:	b923      	cbnz	r3, 28900 <log_list_add_tail+0xe>
		list->head = msg;
   288f6:	6001      	str	r1, [r0, #0]
	} else {
		list->tail->next = msg;
	}

	list->tail = msg;
	msg->next = NULL;
   288f8:	2300      	movs	r3, #0
	list->tail = msg;
   288fa:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
   288fc:	600b      	str	r3, [r1, #0]
}
   288fe:	4770      	bx	lr
		list->tail->next = msg;
   28900:	6843      	ldr	r3, [r0, #4]
   28902:	6019      	str	r1, [r3, #0]
   28904:	e7f8      	b.n	288f8 <log_list_add_tail+0x6>

00028906 <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
   28906:	6800      	ldr	r0, [r0, #0]
   28908:	4770      	bx	lr

0002890a <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
	struct log_msg *msg = list->head;
   2890a:	6803      	ldr	r3, [r0, #0]

	if (list->head != NULL) {
   2890c:	b10b      	cbz	r3, 28912 <log_list_head_get+0x8>
		list->head = list->head->next;
   2890e:	681a      	ldr	r2, [r3, #0]
   28910:	6002      	str	r2, [r0, #0]
	}

	return msg;
}
   28912:	4618      	mov	r0, r3
   28914:	4770      	bx	lr

00028916 <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
   28916:	b508      	push	{r3, lr}
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
   28918:	f7e8 fdee 	bl	114f8 <log_msg_chunk_alloc>

	if (msg != NULL) {
   2891c:	b118      	cbz	r0, 28926 <z_log_msg_std_alloc+0x10>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
   2891e:	2301      	movs	r3, #1
   28920:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
   28922:	2300      	movs	r3, #0
   28924:	8103      	strh	r3, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
	}

	return msg;
}
   28926:	bd08      	pop	{r3, pc}

00028928 <k_cycle_get_32_wrapper>:
   28928:	f7eb b84e 	b.w	139c8 <z_timer_cycle_get_32>

0002892c <dummy_timestamp>:
   2892c:	2000      	movs	r0, #0
   2892e:	4770      	bx	lr

00028930 <log_backend_disable>:
	backend->cb->active = false;
   28930:	6843      	ldr	r3, [r0, #4]
   28932:	2100      	movs	r1, #0
   28934:	7159      	strb	r1, [r3, #5]
	backend_filter_set(backend, LOG_LEVEL_NONE);
   28936:	f7e8 bb69 	b.w	1100c <backend_filter_set>

0002893a <log_0>:
{
   2893a:	b538      	push	{r3, r4, r5, lr}
   2893c:	4605      	mov	r5, r0
   2893e:	460c      	mov	r4, r1
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
   28940:	f7ff ffe9 	bl	28916 <z_log_msg_std_alloc>

	if (msg != NULL) {
   28944:	b128      	cbz	r0, 28952 <log_0+0x18>
		msg->str = str;
   28946:	6105      	str	r5, [r0, #16]
		msg_finalize(msg, src_level);
   28948:	4621      	mov	r1, r4
}
   2894a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		msg_finalize(msg, src_level);
   2894e:	f7e8 bcf5 	b.w	1133c <msg_finalize>
}
   28952:	bd38      	pop	{r3, r4, r5, pc}

00028954 <log_1>:
{
   28954:	b570      	push	{r4, r5, r6, lr}
   28956:	4604      	mov	r4, r0
   28958:	460e      	mov	r6, r1
   2895a:	4615      	mov	r5, r2
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   2895c:	f7ff ffdb 	bl	28916 <z_log_msg_std_alloc>

	if (msg != NULL) {
   28960:	b158      	cbz	r0, 2897a <log_1+0x26>
		msg->str = str;
   28962:	6104      	str	r4, [r0, #16]
		msg->hdr.params.std.nargs = 1U;
   28964:	7a44      	ldrb	r4, [r0, #9]
		msg->payload.single.args[0] = arg1;
   28966:	6146      	str	r6, [r0, #20]
		msg->hdr.params.std.nargs = 1U;
   28968:	2201      	movs	r2, #1
   2896a:	f362 1407 	bfi	r4, r2, #4, #4
   2896e:	7244      	strb	r4, [r0, #9]
		msg_finalize(msg, src_level);
   28970:	4629      	mov	r1, r5
}
   28972:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		msg_finalize(msg, src_level);
   28976:	f7e8 bce1 	b.w	1133c <msg_finalize>
}
   2897a:	bd70      	pop	{r4, r5, r6, pc}

0002897c <log_2>:
{
   2897c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   28980:	4605      	mov	r5, r0
   28982:	4688      	mov	r8, r1
   28984:	4617      	mov	r7, r2
   28986:	461e      	mov	r6, r3
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   28988:	f7ff ffc5 	bl	28916 <z_log_msg_std_alloc>

	if (msg != NULL) {
   2898c:	b160      	cbz	r0, 289a8 <log_2+0x2c>
		msg->str = str;
   2898e:	6105      	str	r5, [r0, #16]
		msg->hdr.params.std.nargs = 2U;
   28990:	7a45      	ldrb	r5, [r0, #9]
   28992:	2302      	movs	r3, #2
   28994:	f363 1507 	bfi	r5, r3, #4, #4
   28998:	7245      	strb	r5, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
   2899a:	e9c0 8705 	strd	r8, r7, [r0, #20]
		msg_finalize(msg, src_level);
   2899e:	4631      	mov	r1, r6
}
   289a0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		msg_finalize(msg, src_level);
   289a4:	f7e8 bcca 	b.w	1133c <msg_finalize>
}
   289a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000289ac <log_3>:
{
   289ac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   289b0:	4605      	mov	r5, r0
   289b2:	4689      	mov	r9, r1
   289b4:	4690      	mov	r8, r2
   289b6:	461f      	mov	r7, r3
   289b8:	f8bd 6020 	ldrh.w	r6, [sp, #32]
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
   289bc:	f7ff ffab 	bl	28916 <z_log_msg_std_alloc>

	if (msg != NULL) {
   289c0:	b168      	cbz	r0, 289de <log_3+0x32>
		msg->str = str;
   289c2:	6105      	str	r5, [r0, #16]
		msg->hdr.params.std.nargs = 3U;
   289c4:	7a45      	ldrb	r5, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
		msg->payload.single.args[2] = arg3;
   289c6:	61c7      	str	r7, [r0, #28]
		msg->hdr.params.std.nargs = 3U;
   289c8:	2303      	movs	r3, #3
   289ca:	f363 1507 	bfi	r5, r3, #4, #4
   289ce:	7245      	strb	r5, [r0, #9]
		msg->payload.single.args[1] = arg2;
   289d0:	e9c0 9805 	strd	r9, r8, [r0, #20]
		msg_finalize(msg, src_level);
   289d4:	4631      	mov	r1, r6
}
   289d6:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		msg_finalize(msg, src_level);
   289da:	f7e8 bcaf 	b.w	1133c <msg_finalize>
}
   289de:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000289e2 <log_n>:
{
   289e2:	b510      	push	{r4, lr}
   289e4:	461c      	mov	r4, r3
		struct log_msg *msg = log_msg_create_n(str, args, narg);
   289e6:	f000 f89b 	bl	28b20 <log_msg_create_n>
		if (msg == NULL) {
   289ea:	b120      	cbz	r0, 289f6 <log_n+0x14>
		msg_finalize(msg, src_level);
   289ec:	4621      	mov	r1, r4
}
   289ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		msg_finalize(msg, src_level);
   289f2:	f7e8 bca3 	b.w	1133c <msg_finalize>
}
   289f6:	bd10      	pop	{r4, pc}

000289f8 <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    u8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
   289f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   289fc:	461c      	mov	r4, r3
	u32_t available_len = msg->hdr.params.hexdump.length;
   289fe:	8903      	ldrh	r3, [r0, #8]
{
   28a00:	f89d 7020 	ldrb.w	r7, [sp, #32]
	u32_t available_len = msg->hdr.params.hexdump.length;
   28a04:	089b      	lsrs	r3, r3, #2
	u8_t *head_data;
	u32_t chunk_len;
	u32_t req_len;
	u32_t cpy_len;

	if (offset >= available_len) {
   28a06:	42a3      	cmp	r3, r4
{
   28a08:	460e      	mov	r6, r1
	if (offset >= available_len) {
   28a0a:	d803      	bhi.n	28a14 <log_msg_hexdump_data_op+0x1c>
		*length = 0;
   28a0c:	2300      	movs	r3, #0
   28a0e:	6013      	str	r3, [r2, #0]
		offset = 0;
		cont = cont->next;
		req_len -= cpy_len;
		data += cpy_len;
	}
}
   28a10:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((offset + *length) > available_len) {
   28a14:	6811      	ldr	r1, [r2, #0]
   28a16:	4421      	add	r1, r4
   28a18:	4299      	cmp	r1, r3
		*length = available_len - offset;
   28a1a:	bf84      	itt	hi
   28a1c:	1b19      	subhi	r1, r3, r4
   28a1e:	6011      	strhi	r1, [r2, #0]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   28a20:	2b0c      	cmp	r3, #12
	req_len = *length;
   28a22:	f8d2 9000 	ldr.w	r9, [r2]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
   28a26:	d928      	bls.n	28a7a <log_msg_hexdump_data_op+0x82>
	if (offset < chunk_len) {
   28a28:	2c07      	cmp	r4, #7
		cont = msg->payload.ext.next;
   28a2a:	f8d0 8014 	ldr.w	r8, [r0, #20]
	if (offset < chunk_len) {
   28a2e:	d82b      	bhi.n	28a88 <log_msg_hexdump_data_op+0x90>
		head_data = msg->payload.ext.data.bytes;
   28a30:	3018      	adds	r0, #24
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
   28a32:	2308      	movs	r3, #8
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   28a34:	454b      	cmp	r3, r9
   28a36:	bf28      	it	cs
   28a38:	464b      	movcs	r3, r9
   28a3a:	461d      	mov	r5, r3
		if (put_op) {
   28a3c:	4420      	add	r0, r4
			(void)memcpy(&head_data[offset], data, cpy_len);
   28a3e:	461a      	mov	r2, r3
		if (put_op) {
   28a40:	b1ff      	cbz	r7, 28a82 <log_msg_hexdump_data_op+0x8a>
			(void)memcpy(&head_data[offset], data, cpy_len);
   28a42:	4631      	mov	r1, r6
			(void)memcpy(data, &head_data[offset], cpy_len);
   28a44:	f001 fd03 	bl	2a44e <memcpy>
		req_len -= cpy_len;
   28a48:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
   28a4c:	442e      	add	r6, r5
	while (req_len > 0) {
   28a4e:	f1b9 0f00 	cmp.w	r9, #0
   28a52:	d0dd      	beq.n	28a10 <log_msg_hexdump_data_op+0x18>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
   28a54:	f1c4 051c 	rsb	r5, r4, #28
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
   28a58:	454d      	cmp	r5, r9
   28a5a:	bf28      	it	cs
   28a5c:	464d      	movcs	r5, r9
		if (put_op) {
   28a5e:	1d20      	adds	r0, r4, #4
   28a60:	4440      	add	r0, r8
			(void)memcpy(&cont->payload.bytes[offset],
   28a62:	462a      	mov	r2, r5
		if (put_op) {
   28a64:	b1bf      	cbz	r7, 28a96 <log_msg_hexdump_data_op+0x9e>
			(void)memcpy(&cont->payload.bytes[offset],
   28a66:	4631      	mov	r1, r6
			(void)memcpy(data, &cont->payload.bytes[offset],
   28a68:	f001 fcf1 	bl	2a44e <memcpy>
		req_len -= cpy_len;
   28a6c:	eba9 0905 	sub.w	r9, r9, r5
		cont = cont->next;
   28a70:	f8d8 8000 	ldr.w	r8, [r8]
		data += cpy_len;
   28a74:	442e      	add	r6, r5
		offset = 0;
   28a76:	2400      	movs	r4, #0
   28a78:	e7e9      	b.n	28a4e <log_msg_hexdump_data_op+0x56>
		head_data = msg->payload.single.bytes;
   28a7a:	3014      	adds	r0, #20
	struct log_msg_cont *cont = NULL;
   28a7c:	f04f 0800 	mov.w	r8, #0
   28a80:	e7d8      	b.n	28a34 <log_msg_hexdump_data_op+0x3c>
			(void)memcpy(data, &head_data[offset], cpy_len);
   28a82:	4601      	mov	r1, r0
   28a84:	4630      	mov	r0, r6
   28a86:	e7dd      	b.n	28a44 <log_msg_hexdump_data_op+0x4c>
		offset -= chunk_len;
   28a88:	3c08      	subs	r4, #8
		while (offset >= chunk_len) {
   28a8a:	2c1b      	cmp	r4, #27
   28a8c:	d9df      	bls.n	28a4e <log_msg_hexdump_data_op+0x56>
			cont = cont->next;
   28a8e:	f8d8 8000 	ldr.w	r8, [r8]
			offset -= chunk_len;
   28a92:	3c1c      	subs	r4, #28
   28a94:	e7f9      	b.n	28a8a <log_msg_hexdump_data_op+0x92>
			(void)memcpy(data, &cont->payload.bytes[offset],
   28a96:	4601      	mov	r1, r0
   28a98:	4630      	mov	r0, r6
   28a9a:	e7e5      	b.n	28a68 <log_msg_hexdump_data_op+0x70>

00028a9c <log_msg_get>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   28a9c:	3004      	adds	r0, #4
   28a9e:	f3bf 8f5b 	dmb	ish
   28aa2:	e850 3f00 	ldrex	r3, [r0]
   28aa6:	3301      	adds	r3, #1
   28aa8:	e840 3200 	strex	r2, r3, [r0]
   28aac:	2a00      	cmp	r2, #0
   28aae:	d1f8      	bne.n	28aa2 <log_msg_get+0x6>
   28ab0:	f3bf 8f5b 	dmb	ish
}
   28ab4:	4770      	bx	lr

00028ab6 <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
   28ab6:	7a40      	ldrb	r0, [r0, #9]
}
   28ab8:	0900      	lsrs	r0, r0, #4
   28aba:	4770      	bx	lr

00028abc <log_msg_arg_get>:
	if (arg_idx >= msg->hdr.params.std.nargs) {
   28abc:	7a43      	ldrb	r3, [r0, #9]
   28abe:	091b      	lsrs	r3, r3, #4
   28ac0:	428b      	cmp	r3, r1
   28ac2:	d916      	bls.n	28af2 <log_msg_arg_get+0x36>
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
   28ac4:	2b03      	cmp	r3, #3
   28ac6:	d803      	bhi.n	28ad0 <log_msg_arg_get+0x14>
		arg = msg->payload.single.args[arg_idx];
   28ac8:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   28acc:	6948      	ldr	r0, [r1, #20]
   28ace:	4770      	bx	lr
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
   28ad0:	2901      	cmp	r1, #1
   28ad2:	d803      	bhi.n	28adc <log_msg_arg_get+0x20>
		return msg->payload.ext.data.args[arg_idx];
   28ad4:	eb00 0181 	add.w	r1, r0, r1, lsl #2
   28ad8:	6988      	ldr	r0, [r1, #24]
   28ada:	4770      	bx	lr
	cont = msg->payload.ext.next;
   28adc:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
   28ade:	3902      	subs	r1, #2
	while (arg_idx >= ARGS_CONT_MSG) {
   28ae0:	2906      	cmp	r1, #6
   28ae2:	d803      	bhi.n	28aec <log_msg_arg_get+0x30>
	return cont->payload.args[arg_idx];
   28ae4:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   28ae8:	6848      	ldr	r0, [r1, #4]
   28aea:	4770      	bx	lr
		arg_idx -= ARGS_CONT_MSG;
   28aec:	3907      	subs	r1, #7
		cont = cont->next;
   28aee:	681b      	ldr	r3, [r3, #0]
   28af0:	e7f6      	b.n	28ae0 <log_msg_arg_get+0x24>
		return 0;
   28af2:	2000      	movs	r0, #0
}
   28af4:	4770      	bx	lr

00028af6 <log_msg_put>:
{
   28af6:	4603      	mov	r3, r0
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   28af8:	1d02      	adds	r2, r0, #4
   28afa:	f3bf 8f5b 	dmb	ish
   28afe:	e852 1f00 	ldrex	r1, [r2]
   28b02:	3901      	subs	r1, #1
   28b04:	e842 1c00 	strex	ip, r1, [r2]
   28b08:	f1bc 0f00 	cmp.w	ip, #0
   28b0c:	d1f7      	bne.n	28afe <log_msg_put+0x8>
   28b0e:	f3bf 8f5b 	dmb	ish
	if (msg->hdr.ref_cnt == 0) {
   28b12:	685b      	ldr	r3, [r3, #4]
   28b14:	b90b      	cbnz	r3, 28b1a <log_msg_put+0x24>
		msg_free(msg);
   28b16:	f7e8 bd01 	b.w	1151c <msg_free>
}
   28b1a:	4770      	bx	lr

00028b1c <log_msg_str_get>:
}
   28b1c:	6900      	ldr	r0, [r0, #16]
   28b1e:	4770      	bx	lr

00028b20 <log_msg_create_n>:
{
   28b20:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   28b24:	4682      	mov	sl, r0
   28b26:	4688      	mov	r8, r1
   28b28:	4615      	mov	r5, r2
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
   28b2a:	f7e8 fce5 	bl	114f8 <log_msg_chunk_alloc>
	if (msg != NULL) {
   28b2e:	4604      	mov	r4, r0
   28b30:	b330      	cbz	r0, 28b80 <log_msg_create_n+0x60>
		msg->hdr.ref_cnt = 1;
   28b32:	2301      	movs	r3, #1
		msg->hdr.params.raw = 0U;
   28b34:	2600      	movs	r6, #0
	if ((msg == NULL) || nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
   28b36:	2d03      	cmp	r5, #3
		msg->hdr.ref_cnt = 1;
   28b38:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
   28b3a:	8106      	strh	r6, [r0, #8]
   28b3c:	d909      	bls.n	28b52 <log_msg_create_n+0x32>
	msg->hdr.params.generic.ext = 1;
   28b3e:	2202      	movs	r2, #2
   28b40:	8102      	strh	r2, [r0, #8]
	n -= LOG_MSG_NARGS_HEAD_CHUNK;
   28b42:	f1a5 0902 	sub.w	r9, r5, #2
	next = &msg->payload.ext.next;
   28b46:	f100 0b14 	add.w	fp, r0, #20
	*next = NULL;
   28b4a:	6146      	str	r6, [r0, #20]
	while (n > 0) {
   28b4c:	f1b9 0f00 	cmp.w	r9, #0
   28b50:	dc0e      	bgt.n	28b70 <log_msg_create_n+0x50>
		msg->hdr.params.std.nargs = nargs;
   28b52:	7a63      	ldrb	r3, [r4, #9]
		msg->str = str;
   28b54:	f8c4 a010 	str.w	sl, [r4, #16]
		msg->hdr.params.std.nargs = nargs;
   28b58:	f365 1307 	bfi	r3, r5, #4, #4
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
   28b5c:	2d03      	cmp	r5, #3
		msg->hdr.params.std.nargs = nargs;
   28b5e:	7263      	strb	r3, [r4, #9]
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
   28b60:	d818      	bhi.n	28b94 <log_msg_create_n+0x74>
		(void)memcpy(msg->payload.single.args, args,
   28b62:	00aa      	lsls	r2, r5, #2
   28b64:	4641      	mov	r1, r8
   28b66:	f104 0014 	add.w	r0, r4, #20
   28b6a:	f001 fc70 	bl	2a44e <memcpy>
		nargs  = 0U;
   28b6e:	e007      	b.n	28b80 <log_msg_create_n+0x60>
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
   28b70:	f7e8 fcc2 	bl	114f8 <log_msg_chunk_alloc>
		if (cont == NULL) {
   28b74:	4607      	mov	r7, r0
   28b76:	b930      	cbnz	r0, 28b86 <log_msg_create_n+0x66>
			msg_free(msg);
   28b78:	4620      	mov	r0, r4
   28b7a:	f7e8 fccf 	bl	1151c <msg_free>
			return NULL;
   28b7e:	463c      	mov	r4, r7
}
   28b80:	4620      	mov	r0, r4
   28b82:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		*next = cont;
   28b86:	f8cb 0000 	str.w	r0, [fp]
		cont->next = NULL;
   28b8a:	f1a9 0907 	sub.w	r9, r9, #7
   28b8e:	6006      	str	r6, [r0, #0]
		next = &cont->next;
   28b90:	4683      	mov	fp, r0
		n -= ARGS_CONT_MSG;
   28b92:	e7db      	b.n	28b4c <log_msg_create_n+0x2c>
		(void)memcpy(msg->payload.ext.data.args, args,
   28b94:	4641      	mov	r1, r8
   28b96:	2208      	movs	r2, #8
   28b98:	f104 0018 	add.w	r0, r4, #24
	struct log_msg_cont *cont = msg->payload.ext.next;
   28b9c:	6967      	ldr	r7, [r4, #20]
		(void)memcpy(msg->payload.ext.data.args, args,
   28b9e:	f001 fc56 	bl	2a44e <memcpy>
		nargs -= LOG_MSG_NARGS_HEAD_CHUNK;
   28ba2:	3d02      	subs	r5, #2
		args += LOG_MSG_NARGS_HEAD_CHUNK;
   28ba4:	f108 0808 	add.w	r8, r8, #8
		u32_t cpy_args = MIN(nargs, ARGS_CONT_MSG);
   28ba8:	2d07      	cmp	r5, #7
   28baa:	462e      	mov	r6, r5
   28bac:	bf28      	it	cs
   28bae:	2607      	movcs	r6, #7
		(void)memcpy(cont->payload.args, args,
   28bb0:	ea4f 0986 	mov.w	r9, r6, lsl #2
   28bb4:	4641      	mov	r1, r8
   28bb6:	1d38      	adds	r0, r7, #4
   28bb8:	464a      	mov	r2, r9
   28bba:	f001 fc48 	bl	2a44e <memcpy>
	while (nargs != 0U) {
   28bbe:	1bad      	subs	r5, r5, r6
		args += cpy_args;
   28bc0:	44c8      	add	r8, r9
		cont = cont->next;
   28bc2:	683f      	ldr	r7, [r7, #0]
	while (nargs != 0U) {
   28bc4:	d1f0      	bne.n	28ba8 <log_msg_create_n+0x88>
   28bc6:	e7db      	b.n	28b80 <log_msg_create_n+0x60>

00028bc8 <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      u8_t *data,
			      size_t *length,
			      size_t offset)
{
   28bc8:	b513      	push	{r0, r1, r4, lr}
	log_msg_hexdump_data_op(msg, data, length, offset, false);
   28bca:	2400      	movs	r4, #0
   28bcc:	9400      	str	r4, [sp, #0]
   28bce:	f7ff ff13 	bl	289f8 <log_msg_hexdump_data_op>
}
   28bd2:	b002      	add	sp, #8
   28bd4:	bd10      	pop	{r4, pc}

00028bd6 <buffer_write>:
{
   28bd6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   28bd8:	4606      	mov	r6, r0
   28bda:	460d      	mov	r5, r1
   28bdc:	4614      	mov	r4, r2
   28bde:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
   28be0:	4621      	mov	r1, r4
   28be2:	4628      	mov	r0, r5
   28be4:	463a      	mov	r2, r7
   28be6:	47b0      	blx	r6
	} while (len != 0);
   28be8:	1a24      	subs	r4, r4, r0
		buf += processed;
   28bea:	4405      	add	r5, r0
	} while (len != 0);
   28bec:	d1f8      	bne.n	28be0 <buffer_write+0xa>
}
   28bee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00028bf0 <std_print>:
{
   28bf0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   28bf4:	b08e      	sub	sp, #56	; 0x38
   28bf6:	af0e      	add	r7, sp, #56	; 0x38
   28bf8:	4681      	mov	r9, r0
   28bfa:	460d      	mov	r5, r1
	const char *str = log_msg_str_get(msg);
   28bfc:	f7ff ff8e 	bl	28b1c <log_msg_str_get>
   28c00:	4606      	mov	r6, r0
	u32_t nargs = log_msg_nargs_get(msg);
   28c02:	4648      	mov	r0, r9
   28c04:	f7ff ff57 	bl	28ab6 <log_msg_nargs_get>
	u32_t *args = alloca(sizeof(u32_t)*nargs);
   28c08:	0083      	lsls	r3, r0, #2
   28c0a:	3307      	adds	r3, #7
   28c0c:	f023 0307 	bic.w	r3, r3, #7
   28c10:	ebad 0d03 	sub.w	sp, sp, r3
	u32_t nargs = log_msg_nargs_get(msg);
   28c14:	4682      	mov	sl, r0
	u32_t *args = alloca(sizeof(u32_t)*nargs);
   28c16:	ac0e      	add	r4, sp, #56	; 0x38
	for (i = 0; i < nargs; i++) {
   28c18:	f04f 0800 	mov.w	r8, #0
   28c1c:	45d0      	cmp	r8, sl
   28c1e:	d116      	bne.n	28c4e <std_print+0x5e>
	switch (log_msg_nargs_get(msg)) {
   28c20:	4648      	mov	r0, r9
   28c22:	f7ff ff48 	bl	28ab6 <log_msg_nargs_get>
   28c26:	280f      	cmp	r0, #15
   28c28:	d81e      	bhi.n	28c68 <std_print+0x78>
   28c2a:	e8df f010 	tbh	[pc, r0, lsl #1]
   28c2e:	0019      	.short	0x0019
   28c30:	00260020 	.word	0x00260020
   28c34:	0036002d 	.word	0x0036002d
   28c38:	004e0041 	.word	0x004e0041
   28c3c:	006e005d 	.word	0x006e005d
   28c40:	00960081 	.word	0x00960081
   28c44:	00c600ad 	.word	0x00c600ad
   28c48:	00fe00e1 	.word	0x00fe00e1
   28c4c:	011d      	.short	0x011d
		args[i] = log_msg_arg_get(msg, i);
   28c4e:	4641      	mov	r1, r8
   28c50:	4648      	mov	r0, r9
   28c52:	f7ff ff33 	bl	28abc <log_msg_arg_get>
   28c56:	f844 0028 	str.w	r0, [r4, r8, lsl #2]
	for (i = 0; i < nargs; i++) {
   28c5a:	f108 0801 	add.w	r8, r8, #1
   28c5e:	e7dd      	b.n	28c1c <std_print+0x2c>
		print_formatted(log_output, str);
   28c60:	4631      	mov	r1, r6
   28c62:	4628      	mov	r0, r5
   28c64:	f7e8 fc8c 	bl	11580 <print_formatted>
}
   28c68:	46bd      	mov	sp, r7
   28c6a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(log_output, str, args[0]);
   28c6e:	6822      	ldr	r2, [r4, #0]
   28c70:	4631      	mov	r1, r6
   28c72:	4628      	mov	r0, r5
   28c74:	f7e8 fc84 	bl	11580 <print_formatted>
		break;
   28c78:	e7f6      	b.n	28c68 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1]);
   28c7a:	e9d4 2300 	ldrd	r2, r3, [r4]
   28c7e:	4631      	mov	r1, r6
   28c80:	4628      	mov	r0, r5
   28c82:	f7e8 fc7d 	bl	11580 <print_formatted>
		break;
   28c86:	e7ef      	b.n	28c68 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2]);
   28c88:	68a3      	ldr	r3, [r4, #8]
   28c8a:	9300      	str	r3, [sp, #0]
   28c8c:	e9d4 2300 	ldrd	r2, r3, [r4]
   28c90:	4631      	mov	r1, r6
   28c92:	4628      	mov	r0, r5
   28c94:	f7e8 fc74 	bl	11580 <print_formatted>
		break;
   28c98:	e7e6      	b.n	28c68 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   28c9a:	68e3      	ldr	r3, [r4, #12]
   28c9c:	9301      	str	r3, [sp, #4]
   28c9e:	68a3      	ldr	r3, [r4, #8]
   28ca0:	9300      	str	r3, [sp, #0]
   28ca2:	e9d4 2300 	ldrd	r2, r3, [r4]
   28ca6:	4631      	mov	r1, r6
   28ca8:	4628      	mov	r0, r5
   28caa:	f7e8 fc69 	bl	11580 <print_formatted>
		break;
   28cae:	e7db      	b.n	28c68 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   28cb0:	6923      	ldr	r3, [r4, #16]
   28cb2:	9302      	str	r3, [sp, #8]
   28cb4:	68e3      	ldr	r3, [r4, #12]
   28cb6:	9301      	str	r3, [sp, #4]
   28cb8:	68a3      	ldr	r3, [r4, #8]
   28cba:	9300      	str	r3, [sp, #0]
   28cbc:	e9d4 2300 	ldrd	r2, r3, [r4]
   28cc0:	4631      	mov	r1, r6
   28cc2:	4628      	mov	r0, r5
   28cc4:	f7e8 fc5c 	bl	11580 <print_formatted>
		break;
   28cc8:	e7ce      	b.n	28c68 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   28cca:	6963      	ldr	r3, [r4, #20]
   28ccc:	9303      	str	r3, [sp, #12]
   28cce:	6923      	ldr	r3, [r4, #16]
   28cd0:	9302      	str	r3, [sp, #8]
   28cd2:	68e3      	ldr	r3, [r4, #12]
   28cd4:	9301      	str	r3, [sp, #4]
   28cd6:	68a3      	ldr	r3, [r4, #8]
   28cd8:	9300      	str	r3, [sp, #0]
   28cda:	e9d4 2300 	ldrd	r2, r3, [r4]
   28cde:	4631      	mov	r1, r6
   28ce0:	4628      	mov	r0, r5
   28ce2:	f7e8 fc4d 	bl	11580 <print_formatted>
		break;
   28ce6:	e7bf      	b.n	28c68 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   28ce8:	69a3      	ldr	r3, [r4, #24]
   28cea:	9304      	str	r3, [sp, #16]
   28cec:	6963      	ldr	r3, [r4, #20]
   28cee:	9303      	str	r3, [sp, #12]
   28cf0:	6923      	ldr	r3, [r4, #16]
   28cf2:	9302      	str	r3, [sp, #8]
   28cf4:	68e3      	ldr	r3, [r4, #12]
   28cf6:	9301      	str	r3, [sp, #4]
   28cf8:	68a3      	ldr	r3, [r4, #8]
   28cfa:	9300      	str	r3, [sp, #0]
   28cfc:	e9d4 2300 	ldrd	r2, r3, [r4]
   28d00:	4631      	mov	r1, r6
   28d02:	4628      	mov	r0, r5
   28d04:	f7e8 fc3c 	bl	11580 <print_formatted>
		break;
   28d08:	e7ae      	b.n	28c68 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   28d0a:	69e3      	ldr	r3, [r4, #28]
   28d0c:	9305      	str	r3, [sp, #20]
   28d0e:	69a3      	ldr	r3, [r4, #24]
   28d10:	9304      	str	r3, [sp, #16]
   28d12:	6963      	ldr	r3, [r4, #20]
   28d14:	9303      	str	r3, [sp, #12]
   28d16:	6923      	ldr	r3, [r4, #16]
   28d18:	9302      	str	r3, [sp, #8]
   28d1a:	68e3      	ldr	r3, [r4, #12]
   28d1c:	9301      	str	r3, [sp, #4]
   28d1e:	68a3      	ldr	r3, [r4, #8]
   28d20:	9300      	str	r3, [sp, #0]
   28d22:	e9d4 2300 	ldrd	r2, r3, [r4]
   28d26:	4631      	mov	r1, r6
   28d28:	4628      	mov	r0, r5
   28d2a:	f7e8 fc29 	bl	11580 <print_formatted>
		break;
   28d2e:	e79b      	b.n	28c68 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   28d30:	6a23      	ldr	r3, [r4, #32]
   28d32:	9306      	str	r3, [sp, #24]
   28d34:	69e3      	ldr	r3, [r4, #28]
   28d36:	9305      	str	r3, [sp, #20]
   28d38:	69a3      	ldr	r3, [r4, #24]
   28d3a:	9304      	str	r3, [sp, #16]
   28d3c:	6963      	ldr	r3, [r4, #20]
   28d3e:	9303      	str	r3, [sp, #12]
   28d40:	6923      	ldr	r3, [r4, #16]
   28d42:	9302      	str	r3, [sp, #8]
   28d44:	68e3      	ldr	r3, [r4, #12]
   28d46:	9301      	str	r3, [sp, #4]
   28d48:	68a3      	ldr	r3, [r4, #8]
   28d4a:	9300      	str	r3, [sp, #0]
   28d4c:	e9d4 2300 	ldrd	r2, r3, [r4]
   28d50:	4631      	mov	r1, r6
   28d52:	4628      	mov	r0, r5
   28d54:	f7e8 fc14 	bl	11580 <print_formatted>
		break;
   28d58:	e786      	b.n	28c68 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   28d5a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   28d5c:	9307      	str	r3, [sp, #28]
   28d5e:	6a23      	ldr	r3, [r4, #32]
   28d60:	9306      	str	r3, [sp, #24]
   28d62:	69e3      	ldr	r3, [r4, #28]
   28d64:	9305      	str	r3, [sp, #20]
   28d66:	69a3      	ldr	r3, [r4, #24]
   28d68:	9304      	str	r3, [sp, #16]
   28d6a:	6963      	ldr	r3, [r4, #20]
   28d6c:	9303      	str	r3, [sp, #12]
   28d6e:	6923      	ldr	r3, [r4, #16]
   28d70:	9302      	str	r3, [sp, #8]
   28d72:	68e3      	ldr	r3, [r4, #12]
   28d74:	9301      	str	r3, [sp, #4]
   28d76:	68a3      	ldr	r3, [r4, #8]
   28d78:	9300      	str	r3, [sp, #0]
   28d7a:	e9d4 2300 	ldrd	r2, r3, [r4]
   28d7e:	4631      	mov	r1, r6
   28d80:	4628      	mov	r0, r5
   28d82:	f7e8 fbfd 	bl	11580 <print_formatted>
		break;
   28d86:	e76f      	b.n	28c68 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   28d88:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   28d8a:	9308      	str	r3, [sp, #32]
   28d8c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   28d8e:	9307      	str	r3, [sp, #28]
   28d90:	6a23      	ldr	r3, [r4, #32]
   28d92:	9306      	str	r3, [sp, #24]
   28d94:	69e3      	ldr	r3, [r4, #28]
   28d96:	9305      	str	r3, [sp, #20]
   28d98:	69a3      	ldr	r3, [r4, #24]
   28d9a:	9304      	str	r3, [sp, #16]
   28d9c:	6963      	ldr	r3, [r4, #20]
   28d9e:	9303      	str	r3, [sp, #12]
   28da0:	6923      	ldr	r3, [r4, #16]
   28da2:	9302      	str	r3, [sp, #8]
   28da4:	68e3      	ldr	r3, [r4, #12]
   28da6:	9301      	str	r3, [sp, #4]
   28da8:	68a3      	ldr	r3, [r4, #8]
   28daa:	9300      	str	r3, [sp, #0]
   28dac:	e9d4 2300 	ldrd	r2, r3, [r4]
   28db0:	4631      	mov	r1, r6
   28db2:	4628      	mov	r0, r5
   28db4:	f7e8 fbe4 	bl	11580 <print_formatted>
		break;
   28db8:	e756      	b.n	28c68 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   28dba:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   28dbc:	9309      	str	r3, [sp, #36]	; 0x24
   28dbe:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   28dc0:	9308      	str	r3, [sp, #32]
   28dc2:	6a63      	ldr	r3, [r4, #36]	; 0x24
   28dc4:	9307      	str	r3, [sp, #28]
   28dc6:	6a23      	ldr	r3, [r4, #32]
   28dc8:	9306      	str	r3, [sp, #24]
   28dca:	69e3      	ldr	r3, [r4, #28]
   28dcc:	9305      	str	r3, [sp, #20]
   28dce:	69a3      	ldr	r3, [r4, #24]
   28dd0:	9304      	str	r3, [sp, #16]
   28dd2:	6963      	ldr	r3, [r4, #20]
   28dd4:	9303      	str	r3, [sp, #12]
   28dd6:	6923      	ldr	r3, [r4, #16]
   28dd8:	9302      	str	r3, [sp, #8]
   28dda:	68e3      	ldr	r3, [r4, #12]
   28ddc:	9301      	str	r3, [sp, #4]
   28dde:	68a3      	ldr	r3, [r4, #8]
   28de0:	9300      	str	r3, [sp, #0]
   28de2:	e9d4 2300 	ldrd	r2, r3, [r4]
   28de6:	4631      	mov	r1, r6
   28de8:	4628      	mov	r0, r5
   28dea:	f7e8 fbc9 	bl	11580 <print_formatted>
		break;
   28dee:	e73b      	b.n	28c68 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   28df0:	6b23      	ldr	r3, [r4, #48]	; 0x30
   28df2:	930a      	str	r3, [sp, #40]	; 0x28
   28df4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   28df6:	9309      	str	r3, [sp, #36]	; 0x24
   28df8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   28dfa:	9308      	str	r3, [sp, #32]
   28dfc:	6a63      	ldr	r3, [r4, #36]	; 0x24
   28dfe:	9307      	str	r3, [sp, #28]
   28e00:	6a23      	ldr	r3, [r4, #32]
   28e02:	9306      	str	r3, [sp, #24]
   28e04:	69e3      	ldr	r3, [r4, #28]
   28e06:	9305      	str	r3, [sp, #20]
   28e08:	69a3      	ldr	r3, [r4, #24]
   28e0a:	9304      	str	r3, [sp, #16]
   28e0c:	6963      	ldr	r3, [r4, #20]
   28e0e:	9303      	str	r3, [sp, #12]
   28e10:	6923      	ldr	r3, [r4, #16]
   28e12:	9302      	str	r3, [sp, #8]
   28e14:	68e3      	ldr	r3, [r4, #12]
   28e16:	9301      	str	r3, [sp, #4]
   28e18:	68a3      	ldr	r3, [r4, #8]
   28e1a:	9300      	str	r3, [sp, #0]
   28e1c:	e9d4 2300 	ldrd	r2, r3, [r4]
   28e20:	4631      	mov	r1, r6
   28e22:	4628      	mov	r0, r5
   28e24:	f7e8 fbac 	bl	11580 <print_formatted>
		break;
   28e28:	e71e      	b.n	28c68 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   28e2a:	6b63      	ldr	r3, [r4, #52]	; 0x34
   28e2c:	930b      	str	r3, [sp, #44]	; 0x2c
   28e2e:	6b23      	ldr	r3, [r4, #48]	; 0x30
   28e30:	930a      	str	r3, [sp, #40]	; 0x28
   28e32:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   28e34:	9309      	str	r3, [sp, #36]	; 0x24
   28e36:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   28e38:	9308      	str	r3, [sp, #32]
   28e3a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   28e3c:	9307      	str	r3, [sp, #28]
   28e3e:	6a23      	ldr	r3, [r4, #32]
   28e40:	9306      	str	r3, [sp, #24]
   28e42:	69e3      	ldr	r3, [r4, #28]
   28e44:	9305      	str	r3, [sp, #20]
   28e46:	69a3      	ldr	r3, [r4, #24]
   28e48:	9304      	str	r3, [sp, #16]
   28e4a:	6963      	ldr	r3, [r4, #20]
   28e4c:	9303      	str	r3, [sp, #12]
   28e4e:	6923      	ldr	r3, [r4, #16]
   28e50:	9302      	str	r3, [sp, #8]
   28e52:	68e3      	ldr	r3, [r4, #12]
   28e54:	9301      	str	r3, [sp, #4]
   28e56:	68a3      	ldr	r3, [r4, #8]
   28e58:	9300      	str	r3, [sp, #0]
   28e5a:	e9d4 2300 	ldrd	r2, r3, [r4]
   28e5e:	4631      	mov	r1, r6
   28e60:	4628      	mov	r0, r5
   28e62:	f7e8 fb8d 	bl	11580 <print_formatted>
		break;
   28e66:	e6ff      	b.n	28c68 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
   28e68:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   28e6a:	930c      	str	r3, [sp, #48]	; 0x30
   28e6c:	6b63      	ldr	r3, [r4, #52]	; 0x34
   28e6e:	930b      	str	r3, [sp, #44]	; 0x2c
   28e70:	6b23      	ldr	r3, [r4, #48]	; 0x30
   28e72:	930a      	str	r3, [sp, #40]	; 0x28
   28e74:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   28e76:	9309      	str	r3, [sp, #36]	; 0x24
   28e78:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   28e7a:	9308      	str	r3, [sp, #32]
   28e7c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   28e7e:	9307      	str	r3, [sp, #28]
   28e80:	6a23      	ldr	r3, [r4, #32]
   28e82:	9306      	str	r3, [sp, #24]
   28e84:	69e3      	ldr	r3, [r4, #28]
   28e86:	9305      	str	r3, [sp, #20]
   28e88:	69a3      	ldr	r3, [r4, #24]
   28e8a:	9304      	str	r3, [sp, #16]
   28e8c:	6963      	ldr	r3, [r4, #20]
   28e8e:	9303      	str	r3, [sp, #12]
   28e90:	6923      	ldr	r3, [r4, #16]
   28e92:	9302      	str	r3, [sp, #8]
   28e94:	68e3      	ldr	r3, [r4, #12]
   28e96:	9301      	str	r3, [sp, #4]
   28e98:	68a3      	ldr	r3, [r4, #8]
   28e9a:	9300      	str	r3, [sp, #0]
   28e9c:	e9d4 2300 	ldrd	r2, r3, [r4]
   28ea0:	4631      	mov	r1, r6
   28ea2:	4628      	mov	r0, r5
   28ea4:	f7e8 fb6c 	bl	11580 <print_formatted>
}
   28ea8:	e6de      	b.n	28c68 <std_print+0x78>

00028eaa <log_output_flush>:
		     log_output->control_block->offset,
   28eaa:	6842      	ldr	r2, [r0, #4]
	buffer_write(log_output->func, log_output->buf,
   28eac:	6881      	ldr	r1, [r0, #8]
{
   28eae:	b510      	push	{r4, lr}
   28eb0:	4604      	mov	r4, r0
	buffer_write(log_output->func, log_output->buf,
   28eb2:	e9d2 2300 	ldrd	r2, r3, [r2]
   28eb6:	6800      	ldr	r0, [r0, #0]
   28eb8:	f7ff fe8d 	bl	28bd6 <buffer_write>
	log_output->control_block->offset = 0;
   28ebc:	6863      	ldr	r3, [r4, #4]
   28ebe:	2200      	movs	r2, #0
   28ec0:	601a      	str	r2, [r3, #0]
}
   28ec2:	bd10      	pop	{r4, pc}

00028ec4 <out_func>:
{
   28ec4:	b508      	push	{r3, lr}
	out_ctx->buf[out_ctx->control_block->offset] = (u8_t)c;
   28ec6:	e9d1 3201 	ldrd	r3, r2, [r1, #4]
   28eca:	681b      	ldr	r3, [r3, #0]
   28ecc:	54d0      	strb	r0, [r2, r3]
	out_ctx->control_block->offset++;
   28ece:	684a      	ldr	r2, [r1, #4]
   28ed0:	6813      	ldr	r3, [r2, #0]
   28ed2:	3301      	adds	r3, #1
   28ed4:	6013      	str	r3, [r2, #0]
	if (out_ctx->control_block->offset == out_ctx->size) {
   28ed6:	68ca      	ldr	r2, [r1, #12]
   28ed8:	4293      	cmp	r3, r2
   28eda:	d102      	bne.n	28ee2 <out_func+0x1e>
		log_output_flush(out_ctx);
   28edc:	4608      	mov	r0, r1
   28ede:	f7ff ffe4 	bl	28eaa <log_output_flush>
}
   28ee2:	2000      	movs	r0, #0
   28ee4:	bd08      	pop	{r3, pc}

00028ee6 <log_halt>:
   28ee6:	684b      	ldr	r3, [r1, #4]
   28ee8:	2000      	movs	r0, #0
   28eea:	7158      	strb	r0, [r3, #5]
}
   28eec:	4770      	bx	lr

00028eee <log_go>:
	backend->cb->active = true;
   28eee:	684b      	ldr	r3, [r1, #4]
   28ef0:	2201      	movs	r2, #1
   28ef2:	715a      	strb	r2, [r3, #5]
}
   28ef4:	2000      	movs	r0, #0
   28ef6:	4770      	bx	lr

00028ef8 <cmd_log_self_halt>:
{
   28ef8:	b510      	push	{r4, lr}
   28efa:	4604      	mov	r4, r0
	if (!shell_state_precheck(shell)) {
   28efc:	f7e8 fe40 	bl	11b80 <shell_state_precheck>
   28f00:	b120      	cbz	r0, 28f0c <cmd_log_self_halt+0x14>
	return log_halt(shell, shell->log_backend->backend, argc, argv);
   28f02:	69e3      	ldr	r3, [r4, #28]
	log_backend_deactivate(backend);
   28f04:	681b      	ldr	r3, [r3, #0]
	backend->cb->active = false;
   28f06:	685b      	ldr	r3, [r3, #4]
   28f08:	2200      	movs	r2, #0
   28f0a:	715a      	strb	r2, [r3, #5]
}
   28f0c:	2000      	movs	r0, #0
   28f0e:	bd10      	pop	{r4, pc}

00028f10 <cmd_log_self_go>:
{
   28f10:	b510      	push	{r4, lr}
   28f12:	4604      	mov	r4, r0
	if (!shell_state_precheck(shell)) {
   28f14:	f7e8 fe34 	bl	11b80 <shell_state_precheck>
   28f18:	b120      	cbz	r0, 28f24 <cmd_log_self_go+0x14>
	return log_go(shell, shell->log_backend->backend, argc, argv);
   28f1a:	69e3      	ldr	r3, [r4, #28]
	log_backend_activate(backend, backend->cb->ctx);
   28f1c:	681b      	ldr	r3, [r3, #0]
	backend->cb->active = true;
   28f1e:	685b      	ldr	r3, [r3, #4]
   28f20:	2201      	movs	r2, #1
   28f22:	715a      	strb	r2, [r3, #5]
}
   28f24:	2000      	movs	r0, #0
   28f26:	bd10      	pop	{r4, pc}

00028f28 <cmd_log_self_status>:
{
   28f28:	b570      	push	{r4, r5, r6, lr}
   28f2a:	4604      	mov	r4, r0
   28f2c:	460d      	mov	r5, r1
   28f2e:	4616      	mov	r6, r2
	if (!shell_state_precheck(shell)) {
   28f30:	f7e8 fe26 	bl	11b80 <shell_state_precheck>
   28f34:	b130      	cbz	r0, 28f44 <cmd_log_self_status+0x1c>
	log_status(shell, shell->log_backend->backend, argc, argv);
   28f36:	69e0      	ldr	r0, [r4, #28]
   28f38:	4633      	mov	r3, r6
   28f3a:	6801      	ldr	r1, [r0, #0]
   28f3c:	462a      	mov	r2, r5
   28f3e:	4620      	mov	r0, r4
   28f40:	f7e8 fd5a 	bl	119f8 <log_status>
}
   28f44:	2000      	movs	r0, #0
   28f46:	bd70      	pop	{r4, r5, r6, pc}

00028f48 <cmd_log_self_enable>:
{
   28f48:	b570      	push	{r4, r5, r6, lr}
   28f4a:	4604      	mov	r4, r0
   28f4c:	460d      	mov	r5, r1
   28f4e:	4616      	mov	r6, r2
	if (!shell_state_precheck(shell)) {
   28f50:	f7e8 fe16 	bl	11b80 <shell_state_precheck>
   28f54:	b140      	cbz	r0, 28f68 <cmd_log_self_enable+0x20>
	return log_enable(shell, shell->log_backend->backend, argc, argv);
   28f56:	69e0      	ldr	r0, [r4, #28]
   28f58:	4633      	mov	r3, r6
   28f5a:	462a      	mov	r2, r5
   28f5c:	6801      	ldr	r1, [r0, #0]
   28f5e:	4620      	mov	r0, r4
}
   28f60:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return log_enable(shell, shell->log_backend->backend, argc, argv);
   28f64:	f7e8 be84 	b.w	11c70 <log_enable>
}
   28f68:	bd70      	pop	{r4, r5, r6, pc}

00028f6a <log_disable>:
{
   28f6a:	b513      	push	{r0, r1, r4, lr}
	filters_set(shell, backend, argc - 1, &argv[1], LOG_LEVEL_NONE);
   28f6c:	2400      	movs	r4, #0
   28f6e:	9400      	str	r4, [sp, #0]
   28f70:	3304      	adds	r3, #4
   28f72:	3a01      	subs	r2, #1
   28f74:	f7e8 fe14 	bl	11ba0 <filters_set>
}
   28f78:	4620      	mov	r0, r4
   28f7a:	b002      	add	sp, #8
   28f7c:	bd10      	pop	{r4, pc}

00028f7e <cmd_log_self_disable>:
{
   28f7e:	b570      	push	{r4, r5, r6, lr}
   28f80:	4604      	mov	r4, r0
   28f82:	460d      	mov	r5, r1
   28f84:	4616      	mov	r6, r2
	if (!shell_state_precheck(shell)) {
   28f86:	f7e8 fdfb 	bl	11b80 <shell_state_precheck>
   28f8a:	b140      	cbz	r0, 28f9e <cmd_log_self_disable+0x20>
	return log_disable(shell, shell->log_backend->backend, argc, argv);
   28f8c:	69e0      	ldr	r0, [r4, #28]
   28f8e:	4633      	mov	r3, r6
   28f90:	462a      	mov	r2, r5
   28f92:	6801      	ldr	r1, [r0, #0]
   28f94:	4620      	mov	r0, r4
}
   28f96:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return log_disable(shell, shell->log_backend->backend, argc, argv);
   28f9a:	f7ff bfe6 	b.w	28f6a <log_disable>
}
   28f9e:	bd70      	pop	{r4, r5, r6, pc}

00028fa0 <cmd_kernel_reboot_warm>:
#endif

#if defined(CONFIG_REBOOT)
static int cmd_kernel_reboot_warm(const struct shell *shell,
				  size_t argc, char **argv)
{
   28fa0:	b508      	push	{r3, lr}
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);
	sys_reboot(SYS_REBOOT_WARM);
   28fa2:	2000      	movs	r0, #0
   28fa4:	f7ea fbc4 	bl	13730 <sys_reboot>
	return 0;
}
   28fa8:	2000      	movs	r0, #0
   28faa:	bd08      	pop	{r3, pc}

00028fac <cmd_kernel_reboot_cold>:

static int cmd_kernel_reboot_cold(const struct shell *shell,
				  size_t argc, char **argv)
{
   28fac:	b508      	push	{r3, lr}
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);
	sys_reboot(SYS_REBOOT_COLD);
   28fae:	2001      	movs	r0, #1
   28fb0:	f7ea fbbe 	bl	13730 <sys_reboot>
	return 0;
}
   28fb4:	2000      	movs	r0, #0
   28fb6:	bd08      	pop	{r3, pc}

00028fb8 <shell_signal_handle>:
{
   28fb8:	b573      	push	{r0, r1, r4, r5, r6, lr}
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
   28fba:	6884      	ldr	r4, [r0, #8]
   28fbc:	0109      	lsls	r1, r1, #4
   28fbe:	f501 7117 	add.w	r1, r1, #604	; 0x25c
{
   28fc2:	4605      	mov	r5, r0
   28fc4:	4616      	mov	r6, r2
	struct k_poll_signal *signal = &shell->ctx->signals[sig_idx];
   28fc6:	440c      	add	r4, r1
	z_impl_k_poll_signal_check(signal, signaled, result);
   28fc8:	aa01      	add	r2, sp, #4
   28fca:	4669      	mov	r1, sp
   28fcc:	4620      	mov	r0, r4
   28fce:	f004 fc67 	bl	2d8a0 <z_impl_k_poll_signal_check>
	if (set) {
   28fd2:	9b00      	ldr	r3, [sp, #0]
   28fd4:	b11b      	cbz	r3, 28fde <shell_signal_handle+0x26>
	signal->signaled = 0U;
   28fd6:	2300      	movs	r3, #0
   28fd8:	60a3      	str	r3, [r4, #8]
		handler(shell);
   28fda:	4628      	mov	r0, r5
   28fdc:	47b0      	blx	r6
}
   28fde:	b002      	add	sp, #8
   28fe0:	bd70      	pop	{r4, r5, r6, pc}

00028fe2 <kill_handler>:
{
   28fe2:	b538      	push	{r3, r4, r5, lr}
	if (flag_processing_get(shell)) {
   28fe4:	6883      	ldr	r3, [r0, #8]
	return shell->ctx->internal.flags.processing == 1 ? true : false;
   28fe6:	f8d3 3258 	ldr.w	r3, [r3, #600]	; 0x258
   28fea:	071b      	lsls	r3, r3, #28
{
   28fec:	4604      	mov	r4, r0
	if (flag_processing_get(shell)) {
   28fee:	d40d      	bmi.n	2900c <kill_handler+0x2a>
		shell_log_backend_disable(shell->log_backend);
   28ff0:	69c0      	ldr	r0, [r0, #28]
   28ff2:	f000 fe45 	bl	29c80 <shell_log_backend_disable>
	err = shell->iface->api->uninit(shell->iface);
   28ff6:	6860      	ldr	r0, [r4, #4]
   28ff8:	6803      	ldr	r3, [r0, #0]
   28ffa:	685b      	ldr	r3, [r3, #4]
   28ffc:	4798      	blx	r3
	if (err != 0) {
   28ffe:	4605      	mov	r5, r0
   29000:	b920      	cbnz	r0, 2900c <kill_handler+0x2a>
	shell_history_purge(shell->history);
   29002:	68e0      	ldr	r0, [r4, #12]
   29004:	f000 fd2a 	bl	29a5c <shell_history_purge>
	shell->ctx->state = SHELL_STATE_UNINITIALIZED;
   29008:	68a3      	ldr	r3, [r4, #8]
   2900a:	711d      	strb	r5, [r3, #4]
	return z_impl_k_current_get();
   2900c:	f7fe f876 	bl	270fc <z_impl_k_current_get>
}
   29010:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_thread_abort(thread);
   29014:	f7eb ba10 	b.w	14438 <z_impl_k_thread_abort>

00029018 <shell_strlen>:
{
   29018:	b508      	push	{r3, lr}
	return str == NULL ? 0U : (u16_t)strlen(str);
   2901a:	b110      	cbz	r0, 29022 <shell_strlen+0xa>
   2901c:	f001 f9ce 	bl	2a3bc <strlen>
   29020:	b280      	uxth	r0, r0
}
   29022:	bd08      	pop	{r3, pc}

00029024 <shell_raw_fprintf>:
{
   29024:	b40e      	push	{r1, r2, r3}
   29026:	b503      	push	{r0, r1, lr}
   29028:	aa03      	add	r2, sp, #12
   2902a:	f852 1b04 	ldr.w	r1, [r2], #4
	va_start(args, fmt);
   2902e:	9201      	str	r2, [sp, #4]
	shell_fprintf_fmt(ctx, fmt, args);
   29030:	f7e9 fca2 	bl	12978 <shell_fprintf_fmt>
}
   29034:	b002      	add	sp, #8
   29036:	f85d eb04 	ldr.w	lr, [sp], #4
   2903a:	b003      	add	sp, #12
   2903c:	4770      	bx	lr

0002903e <shell_internal_help_print>:
{
   2903e:	b510      	push	{r4, lr}
   29040:	4604      	mov	r4, r0
	shell_help_cmd_print(shell);
   29042:	f7ea f801 	bl	13048 <shell_help_cmd_print>
	shell_help_subcmd_print(shell);
   29046:	4620      	mov	r0, r4
}
   29048:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	shell_help_subcmd_print(shell);
   2904c:	f7e9 bf8c 	b.w	12f68 <shell_help_subcmd_print>

00029050 <state_set.constprop.31>:
	shell->ctx->state = state;
   29050:	6883      	ldr	r3, [r0, #8]
   29052:	2202      	movs	r2, #2
   29054:	711a      	strb	r2, [r3, #4]
	shell->ctx->cmd_buff[0] = '\0'; /* clear command buffer */
   29056:	2200      	movs	r2, #0
   29058:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
	shell->ctx->cmd_buff_pos = 0;
   2905c:	869a      	strh	r2, [r3, #52]	; 0x34
	shell->ctx->cmd_buff_len = 0;
   2905e:	865a      	strh	r2, [r3, #50]	; 0x32
		shell_print_prompt_and_cmd(shell);
   29060:	f7e9 be30 	b.w	12cc4 <shell_print_prompt_and_cmd>

00029064 <transport_evt_handler>:
	signal = (evt_type == SHELL_TRANSPORT_EVT_RX_RDY) ?
   29064:	688b      	ldr	r3, [r1, #8]
			&shell->ctx->signals[SHELL_SIGNAL_RXRDY] :
   29066:	b920      	cbnz	r0, 29072 <transport_evt_handler+0xe>
   29068:	f503 7017 	add.w	r0, r3, #604	; 0x25c
	return z_impl_k_poll_signal_raise(signal, result);
   2906c:	2100      	movs	r1, #0
   2906e:	f7fe bbfd 	b.w	2786c <z_impl_k_poll_signal_raise>
   29072:	f503 7023 	add.w	r0, r3, #652	; 0x28c
   29076:	e7f9      	b.n	2906c <transport_evt_handler+0x8>

00029078 <k_mutex_lock.constprop.35>:
	return z_impl_k_mutex_lock(mutex, timeout);
   29078:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2907c:	f7fd bca6 	b.w	269cc <z_impl_k_mutex_lock>

00029080 <shell_log_process>:
{
   29080:	b573      	push	{r0, r1, r4, r5, r6, lr}
	int signaled = 0;
   29082:	2300      	movs	r3, #0
{
   29084:	4604      	mov	r4, r0
	int signaled = 0;
   29086:	9300      	str	r3, [sp, #0]
			shell_cmd_line_erase(shell);
   29088:	4620      	mov	r0, r4
   2908a:	f000 fb1f 	bl	296cc <shell_cmd_line_erase>
			processed = shell_log_backend_process(shell->log_backend);
   2908e:	69e0      	ldr	r0, [r4, #28]
   29090:	f000 fe0b 	bl	29caa <shell_log_backend_process>
   29094:	4606      	mov	r6, r0
		shell_print_prompt_and_cmd(shell);
   29096:	4620      	mov	r0, r4
		struct k_poll_signal *signal =
   29098:	68a5      	ldr	r5, [r4, #8]
		shell_print_prompt_and_cmd(shell);
   2909a:	f7e9 fe13 	bl	12cc4 <shell_print_prompt_and_cmd>
		if (shell->ctx->cmd_buff_len) {
   2909e:	68a3      	ldr	r3, [r4, #8]
   290a0:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
		struct k_poll_signal *signal =
   290a2:	f505 7517 	add.w	r5, r5, #604	; 0x25c
		if (shell->ctx->cmd_buff_len) {
   290a6:	b113      	cbz	r3, 290ae <shell_log_process+0x2e>
	return z_impl_k_sleep(ms);
   290a8:	200f      	movs	r0, #15
   290aa:	f7fd ffff 	bl	270ac <z_impl_k_sleep>
	z_impl_k_poll_signal_check(signal, signaled, result);
   290ae:	aa01      	add	r2, sp, #4
   290b0:	4669      	mov	r1, sp
   290b2:	4628      	mov	r0, r5
   290b4:	f004 fbf4 	bl	2d8a0 <z_impl_k_poll_signal_check>
	} while (processed && !signaled);
   290b8:	b116      	cbz	r6, 290c0 <shell_log_process+0x40>
   290ba:	9b00      	ldr	r3, [sp, #0]
   290bc:	2b00      	cmp	r3, #0
   290be:	d0e3      	beq.n	29088 <shell_log_process+0x8>
}
   290c0:	b002      	add	sp, #8
   290c2:	bd70      	pop	{r4, r5, r6, pc}

000290c4 <shell_fprintf>:
/* This function mustn't be used from shell context to avoid deadlock.
 * However it can be used in shell command handlers.
 */
void shell_fprintf(const struct shell *shell, enum shell_vt100_color color,
		   const char *fmt, ...)
{
   290c4:	b40c      	push	{r2, r3}
   290c6:	b537      	push	{r0, r1, r2, r4, r5, lr}
   290c8:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(shell->fprintf_ctx);
	__ASSERT_NO_MSG(fmt);

	va_list args;

	k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
   290ca:	6880      	ldr	r0, [r0, #8]
   290cc:	f500 703b 	add.w	r0, r0, #748	; 0x2ec
{
   290d0:	460d      	mov	r5, r1
	k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
   290d2:	f7ff ffd1 	bl	29078 <k_mutex_lock.constprop.35>
	if (!flag_cmd_ctx_get(shell)) {
   290d6:	68a3      	ldr	r3, [r4, #8]
	return shell->ctx->internal.flags.cmd_ctx == 1 ? true : false;
   290d8:	f8d3 3258 	ldr.w	r3, [r3, #600]	; 0x258
   290dc:	061a      	lsls	r2, r3, #24
   290de:	d402      	bmi.n	290e6 <shell_fprintf+0x22>
		shell_cmd_line_erase(shell);
   290e0:	4620      	mov	r0, r4
   290e2:	f000 faf3 	bl	296cc <shell_cmd_line_erase>
	}

	va_start(args, fmt);
   290e6:	ab07      	add	r3, sp, #28
	shell_internal_vfprintf(shell, color, fmt, args);
   290e8:	9a06      	ldr	r2, [sp, #24]
	va_start(args, fmt);
   290ea:	9301      	str	r3, [sp, #4]
	shell_internal_vfprintf(shell, color, fmt, args);
   290ec:	4629      	mov	r1, r5
   290ee:	4620      	mov	r0, r4
   290f0:	f000 fb3b 	bl	2976a <shell_internal_vfprintf>
	va_end(args);

	if (!flag_cmd_ctx_get(shell)) {
   290f4:	68a3      	ldr	r3, [r4, #8]
   290f6:	f8d3 3258 	ldr.w	r3, [r3, #600]	; 0x258
   290fa:	061b      	lsls	r3, r3, #24
   290fc:	d402      	bmi.n	29104 <shell_fprintf+0x40>
		shell_print_prompt_and_cmd(shell);
   290fe:	4620      	mov	r0, r4
   29100:	f7e9 fde0 	bl	12cc4 <shell_print_prompt_and_cmd>
	shell_fprintf_buffer_flush(shell->fprintf_ctx);
   29104:	6960      	ldr	r0, [r4, #20]
   29106:	f000 f81b 	bl	29140 <shell_fprintf_buffer_flush>
	}
	transport_buffer_flush(shell);
	k_mutex_unlock(&shell->ctx->wr_mtx);
   2910a:	68a0      	ldr	r0, [r4, #8]
   2910c:	f500 703b 	add.w	r0, r0, #748	; 0x2ec
	z_impl_k_mutex_unlock(mutex);
   29110:	f7fd fcce 	bl	26ab0 <z_impl_k_mutex_unlock>
}
   29114:	b003      	add	sp, #12
   29116:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   2911a:	b002      	add	sp, #8
   2911c:	4770      	bx	lr

0002911e <shell_help>:

	return 0;
}

void shell_help(const struct shell *shell)
{
   2911e:	b510      	push	{r4, lr}
   29120:	4604      	mov	r4, r0
	k_mutex_lock(&shell->ctx->wr_mtx, K_FOREVER);
   29122:	6880      	ldr	r0, [r0, #8]
   29124:	f500 703b 	add.w	r0, r0, #748	; 0x2ec
   29128:	f7ff ffa6 	bl	29078 <k_mutex_lock.constprop.35>
	shell_internal_help_print(shell);
   2912c:	4620      	mov	r0, r4
   2912e:	f7ff ff86 	bl	2903e <shell_internal_help_print>
	k_mutex_unlock(&shell->ctx->wr_mtx);
   29132:	68a0      	ldr	r0, [r4, #8]
   29134:	f500 703b 	add.w	r0, r0, #748	; 0x2ec
}
   29138:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2913c:	f7fd bcb8 	b.w	26ab0 <z_impl_k_mutex_unlock>

00029140 <shell_fprintf_buffer_flush>:


void shell_fprintf_buffer_flush(const struct shell_fprintf *sh_fprintf)
{
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
   29140:	6902      	ldr	r2, [r0, #16]
   29142:	6883      	ldr	r3, [r0, #8]
   29144:	6812      	ldr	r2, [r2, #0]
   29146:	6801      	ldr	r1, [r0, #0]
{
   29148:	b510      	push	{r4, lr}
   2914a:	4604      	mov	r4, r0
	sh_fprintf->fwrite(sh_fprintf->user_ctx, sh_fprintf->buffer,
   2914c:	68c0      	ldr	r0, [r0, #12]
   2914e:	4798      	blx	r3
			   sh_fprintf->ctrl_blk->buffer_cnt);
	sh_fprintf->ctrl_blk->buffer_cnt = 0;
   29150:	6923      	ldr	r3, [r4, #16]
   29152:	2200      	movs	r2, #0
   29154:	601a      	str	r2, [r3, #0]
}
   29156:	bd10      	pop	{r4, pc}

00029158 <out_func>:
{
   29158:	b538      	push	{r3, r4, r5, lr}
	if ((shell->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
   2915a:	68cb      	ldr	r3, [r1, #12]
   2915c:	7c1b      	ldrb	r3, [r3, #16]
   2915e:	2b02      	cmp	r3, #2
{
   29160:	4605      	mov	r5, r0
   29162:	460c      	mov	r4, r1
	if ((shell->shell_flag == SHELL_FLAG_OLF_CRLF) && (c == '\n')) {
   29164:	d104      	bne.n	29170 <out_func+0x18>
   29166:	280a      	cmp	r0, #10
   29168:	d102      	bne.n	29170 <out_func+0x18>
		(void)out_func('\r', ctx);
   2916a:	200d      	movs	r0, #13
   2916c:	f7ff fff4 	bl	29158 <out_func>
	sh_fprintf->buffer[sh_fprintf->ctrl_blk->buffer_cnt] = (u8_t)c;
   29170:	6923      	ldr	r3, [r4, #16]
   29172:	6822      	ldr	r2, [r4, #0]
   29174:	681b      	ldr	r3, [r3, #0]
   29176:	54d5      	strb	r5, [r2, r3]
	sh_fprintf->ctrl_blk->buffer_cnt++;
   29178:	6922      	ldr	r2, [r4, #16]
   2917a:	6813      	ldr	r3, [r2, #0]
   2917c:	3301      	adds	r3, #1
   2917e:	6013      	str	r3, [r2, #0]
	if (sh_fprintf->ctrl_blk->buffer_cnt == sh_fprintf->buffer_size) {
   29180:	6862      	ldr	r2, [r4, #4]
   29182:	4293      	cmp	r3, r2
   29184:	d102      	bne.n	2918c <out_func+0x34>
		shell_fprintf_buffer_flush(sh_fprintf);
   29186:	4620      	mov	r0, r4
   29188:	f7ff ffda 	bl	29140 <shell_fprintf_buffer_flush>
}
   2918c:	2000      	movs	r0, #0
   2918e:	bd38      	pop	{r3, r4, r5, pc}

00029190 <isspace>:
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
   29190:	2820      	cmp	r0, #32
   29192:	d005      	beq.n	291a0 <isspace+0x10>
   29194:	3809      	subs	r0, #9
   29196:	2804      	cmp	r0, #4
   29198:	bf8c      	ite	hi
   2919a:	2000      	movhi	r0, #0
   2919c:	2001      	movls	r0, #1
   2919e:	4770      	bx	lr
   291a0:	2001      	movs	r0, #1
}
   291a2:	4770      	bx	lr

000291a4 <shell_strlen>:
{
   291a4:	b508      	push	{r3, lr}
	return str == NULL ? 0U : (u16_t)strlen(str);
   291a6:	b110      	cbz	r0, 291ae <shell_strlen+0xa>
   291a8:	f001 f908 	bl	2a3bc <strlen>
   291ac:	b280      	uxth	r0, r0
}
   291ae:	bd08      	pop	{r3, pc}

000291b0 <column_span_with_buffer_offsets_get>:
{
   291b0:	b510      	push	{r4, lr}
	return (1 + ((buffer_pos + cons->name_len) % cons->terminal_wid));
   291b2:	7b03      	ldrb	r3, [r0, #12]
   291b4:	8944      	ldrh	r4, [r0, #10]
   291b6:	441a      	add	r2, r3
   291b8:	4419      	add	r1, r3
   291ba:	fbb2 f0f4 	udiv	r0, r2, r4
   291be:	fbb1 f3f4 	udiv	r3, r1, r4
   291c2:	fb04 2010 	mls	r0, r4, r0, r2
   291c6:	fb04 1313 	mls	r3, r4, r3, r1
}
   291ca:	1ac0      	subs	r0, r0, r3
   291cc:	bd10      	pop	{r4, pc}

000291ce <row_span_with_buffer_offsets_get>:
{
   291ce:	b510      	push	{r4, lr}
	return ((buffer_pos + cons->name_len) / cons->terminal_wid);
   291d0:	7b03      	ldrb	r3, [r0, #12]
   291d2:	8944      	ldrh	r4, [r0, #10]
   291d4:	441a      	add	r2, r3
   291d6:	4419      	add	r1, r3
   291d8:	fbb2 f0f4 	udiv	r0, r2, r4
   291dc:	fbb1 f1f4 	udiv	r1, r1, r4
}
   291e0:	1a40      	subs	r0, r0, r1
   291e2:	bd10      	pop	{r4, pc}

000291e4 <shell_multiline_data_calc>:
{
   291e4:	b530      	push	{r4, r5, lr}
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
   291e6:	7b04      	ldrb	r4, [r0, #12]
   291e8:	8945      	ldrh	r5, [r0, #10]
   291ea:	4421      	add	r1, r4
   291ec:	fbb1 f3f5 	udiv	r3, r1, r5
   291f0:	fb05 1113 	mls	r1, r5, r3, r1
   291f4:	3101      	adds	r1, #1
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
   291f6:	3301      	adds	r3, #1
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
   291f8:	4422      	add	r2, r4
	cons->cur_x = (buff_pos + cons->name_len) % cons->terminal_wid + 1;
   291fa:	8001      	strh	r1, [r0, #0]
	cons->cur_y = (buff_pos + cons->name_len) / cons->terminal_wid + 1;
   291fc:	8083      	strh	r3, [r0, #4]
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
   291fe:	fbb2 f3f5 	udiv	r3, r2, r5
   29202:	1c59      	adds	r1, r3, #1
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
   29204:	fb05 2313 	mls	r3, r5, r3, r2
   29208:	3301      	adds	r3, #1
	cons->cur_y_end = (buff_len + cons->name_len) / cons->terminal_wid + 1;
   2920a:	80c1      	strh	r1, [r0, #6]
	cons->cur_x_end = (buff_len + cons->name_len) % cons->terminal_wid + 1;
   2920c:	8043      	strh	r3, [r0, #2]
}
   2920e:	bd30      	pop	{r4, r5, pc}

00029210 <shell_make_argv>:
{
   29210:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	*argc = 0;
   29214:	2500      	movs	r5, #0
{
   29216:	4606      	mov	r6, r0
   29218:	460f      	mov	r7, r1
   2921a:	4614      	mov	r4, r2
   2921c:	4698      	mov	r8, r3
	*argc = 0;
   2921e:	6005      	str	r5, [r0, #0]
		c = *cmd;
   29220:	7820      	ldrb	r0, [r4, #0]
		if (c == '\0') {
   29222:	b140      	cbz	r0, 29236 <shell_make_argv+0x26>
		if (isspace((int) c)) {
   29224:	f7ff ffb4 	bl	29190 <isspace>
   29228:	b160      	cbz	r0, 29244 <shell_make_argv+0x34>
			*cmd++ = '\0';
   2922a:	2300      	movs	r3, #0
   2922c:	f804 3b01 	strb.w	r3, [r4], #1
	} while (*argc < max_argc);
   29230:	6833      	ldr	r3, [r6, #0]
   29232:	4543      	cmp	r3, r8
   29234:	d3f4      	bcc.n	29220 <shell_make_argv+0x10>
	argv[*argc] = 0;
   29236:	6833      	ldr	r3, [r6, #0]
   29238:	2200      	movs	r2, #0
   2923a:	f847 2023 	str.w	r2, [r7, r3, lsl #2]
}
   2923e:	4628      	mov	r0, r5
   29240:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		argv[(*argc)++] = cmd;
   29244:	6833      	ldr	r3, [r6, #0]
   29246:	1c5a      	adds	r2, r3, #1
   29248:	6032      	str	r2, [r6, #0]
   2924a:	f847 4023 	str.w	r4, [r7, r3, lsl #2]
	char quote = 0;
   2924e:	4605      	mov	r5, r0
		c = *cmd;
   29250:	f894 9000 	ldrb.w	r9, [r4]
		if (c == '\0') {
   29254:	f1b9 0f00 	cmp.w	r9, #0
   29258:	d0ea      	beq.n	29230 <shell_make_argv+0x20>
		if (!quote) {
   2925a:	2d00      	cmp	r5, #0
   2925c:	f040 8089 	bne.w	29372 <shell_make_argv+0x162>
			switch (c) {
   29260:	f1b9 0f27 	cmp.w	r9, #39	; 0x27
   29264:	d006      	beq.n	29274 <shell_make_argv+0x64>
   29266:	f1b9 0f5c 	cmp.w	r9, #92	; 0x5c
   2926a:	f000 808a 	beq.w	29382 <shell_make_argv+0x172>
   2926e:	f1b9 0f22 	cmp.w	r9, #34	; 0x22
   29272:	d176      	bne.n	29362 <shell_make_argv+0x152>
						shell_strlen(cmd));
   29274:	4620      	mov	r0, r4
   29276:	f7ff ff95 	bl	291a4 <shell_strlen>
				memmove(cmd, cmd + 1,
   2927a:	1c61      	adds	r1, r4, #1
   2927c:	4602      	mov	r2, r0
   2927e:	4620      	mov	r0, r4
   29280:	f001 f8ce 	bl	2a420 <memmove>
   29284:	464d      	mov	r5, r9
   29286:	e7e3      	b.n	29250 <shell_make_argv+0x40>
			memmove(cmd, cmd + 1, shell_strlen(cmd));
   29288:	4620      	mov	r0, r4
   2928a:	f7ff ff8b 	bl	291a4 <shell_strlen>
   2928e:	1c61      	adds	r1, r4, #1
   29290:	4602      	mov	r2, r0
   29292:	4620      	mov	r0, r4
   29294:	f001 f8c4 	bl	2a420 <memmove>
			quote = 0;
   29298:	2500      	movs	r5, #0
   2929a:	e7d9      	b.n	29250 <shell_make_argv+0x40>
			if (t == '0') {
   2929c:	2930      	cmp	r1, #48	; 0x30
   2929e:	d125      	bne.n	292ec <shell_make_argv+0xdc>
   292a0:	2302      	movs	r3, #2
				u8_t v = 0U;
   292a2:	f04f 0a00 	mov.w	sl, #0
					t = *(cmd + i);
   292a6:	5ce1      	ldrb	r1, [r4, r3]
					if (t >= '0' && t <= '7') {
   292a8:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
   292ac:	b2d0      	uxtb	r0, r2
   292ae:	2807      	cmp	r0, #7
   292b0:	fa5f f983 	uxtb.w	r9, r3
   292b4:	d817      	bhi.n	292e6 <shell_make_argv+0xd6>
						v = (v << 3) | (t - '0');
   292b6:	3301      	adds	r3, #1
   292b8:	ea42 0aca 	orr.w	sl, r2, sl, lsl #3
				for (i = 2U; i < (2 + 3); i++) {
   292bc:	2b05      	cmp	r3, #5
						v = (v << 3) | (t - '0');
   292be:	fa5f fa8a 	uxtb.w	sl, sl
				for (i = 2U; i < (2 + 3); i++) {
   292c2:	d1f0      	bne.n	292a6 <shell_make_argv+0x96>
   292c4:	4699      	mov	r9, r3
						shell_strlen(cmd) - (i - 2));
   292c6:	4620      	mov	r0, r4
   292c8:	f7ff ff6c 	bl	291a4 <shell_strlen>
					memmove(cmd, cmd + (i - 1),
   292cc:	f109 3bff 	add.w	fp, r9, #4294967295	; 0xffffffff
   292d0:	44a3      	add	fp, r4
						shell_strlen(cmd) - (i - 2));
   292d2:	1c82      	adds	r2, r0, #2
					memmove(cmd, cmd + (i - 1),
   292d4:	eba2 0209 	sub.w	r2, r2, r9
   292d8:	4620      	mov	r0, r4
   292da:	4659      	mov	r1, fp
   292dc:	f001 f8a0 	bl	2a420 <memmove>
					*cmd++ = v;
   292e0:	f804 ab01 	strb.w	sl, [r4], #1
					continue;
   292e4:	e7b4      	b.n	29250 <shell_make_argv+0x40>
				if (i > 2) {
   292e6:	f1b9 0f02 	cmp.w	r9, #2
   292ea:	d1ec      	bne.n	292c6 <shell_make_argv+0xb6>
			if (t == 'x') {
   292ec:	2978      	cmp	r1, #120	; 0x78
   292ee:	d13e      	bne.n	2936e <shell_make_argv+0x15e>
   292f0:	2202      	movs	r2, #2
				u8_t v = 0U;
   292f2:	f04f 0900 	mov.w	r9, #0
					t = *(cmd + i);
   292f6:	5ca3      	ldrb	r3, [r4, r2]
					if (t >= '0' && t <= '9') {
   292f8:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
   292fc:	fa5f fc81 	uxtb.w	ip, r1
   29300:	f1bc 0f09 	cmp.w	ip, #9
   29304:	b2d0      	uxtb	r0, r2
   29306:	d819      	bhi.n	2933c <shell_make_argv+0x12c>
						v = (v << 4) | (t - '0');
   29308:	ea41 1309 	orr.w	r3, r1, r9, lsl #4
				for (i = 2U; i < (2 + 2); i++) {
   2930c:	2a03      	cmp	r2, #3
						v = (v << 4) | (t - 'A' + 10);
   2930e:	fa5f f983 	uxtb.w	r9, r3
				for (i = 2U; i < (2 + 2); i++) {
   29312:	d111      	bne.n	29338 <shell_make_argv+0x128>
   29314:	f04f 0b04 	mov.w	fp, #4
						shell_strlen(cmd) - (i - 2));
   29318:	4620      	mov	r0, r4
   2931a:	f7ff ff43 	bl	291a4 <shell_strlen>
					memmove(cmd, cmd + (i - 1),
   2931e:	f10b 3aff 	add.w	sl, fp, #4294967295	; 0xffffffff
   29322:	44a2      	add	sl, r4
						shell_strlen(cmd) - (i - 2));
   29324:	1c82      	adds	r2, r0, #2
					memmove(cmd, cmd + (i - 1),
   29326:	eba2 020b 	sub.w	r2, r2, fp
   2932a:	4620      	mov	r0, r4
   2932c:	4651      	mov	r1, sl
   2932e:	f001 f877 	bl	2a420 <memmove>
					*cmd++ = v;
   29332:	f804 9b01 	strb.w	r9, [r4], #1
					continue;
   29336:	e78b      	b.n	29250 <shell_make_argv+0x40>
				for (i = 2U; i < (2 + 2); i++) {
   29338:	2203      	movs	r2, #3
   2933a:	e7dc      	b.n	292f6 <shell_make_argv+0xe6>
					} else if ((t >= 'a') &&
   2933c:	f1a3 0161 	sub.w	r1, r3, #97	; 0x61
   29340:	2905      	cmp	r1, #5
   29342:	d803      	bhi.n	2934c <shell_make_argv+0x13c>
						v = (v << 4) | (t - 'a' + 10);
   29344:	3b57      	subs	r3, #87	; 0x57
						v = (v << 4) | (t - 'A' + 10);
   29346:	ea43 1309 	orr.w	r3, r3, r9, lsl #4
   2934a:	e7df      	b.n	2930c <shell_make_argv+0xfc>
					} else if ((t >= 'A') && (t <= 'F')) {
   2934c:	f1a3 0141 	sub.w	r1, r3, #65	; 0x41
   29350:	2905      	cmp	r1, #5
   29352:	d801      	bhi.n	29358 <shell_make_argv+0x148>
						v = (v << 4) | (t - 'A' + 10);
   29354:	3b37      	subs	r3, #55	; 0x37
   29356:	e7f6      	b.n	29346 <shell_make_argv+0x136>
				if (i > 2) {
   29358:	2802      	cmp	r0, #2
   2935a:	d008      	beq.n	2936e <shell_make_argv+0x15e>
   2935c:	f04f 0b03 	mov.w	fp, #3
   29360:	e7da      	b.n	29318 <shell_make_argv+0x108>
		if (!quote && isspace((int) c)) {
   29362:	4648      	mov	r0, r9
   29364:	f7ff ff14 	bl	29190 <isspace>
   29368:	2800      	cmp	r0, #0
   2936a:	f47f af61 	bne.w	29230 <shell_make_argv+0x20>
		cmd += 1;
   2936e:	3401      	adds	r4, #1
   29370:	e76e      	b.n	29250 <shell_make_argv+0x40>
		if (quote == c) {
   29372:	45a9      	cmp	r9, r5
   29374:	d088      	beq.n	29288 <shell_make_argv+0x78>
		if (quote && c == '\\') {
   29376:	f1b9 0f5c 	cmp.w	r9, #92	; 0x5c
   2937a:	d1f8      	bne.n	2936e <shell_make_argv+0x15e>
   2937c:	7861      	ldrb	r1, [r4, #1]
			if (t == quote) {
   2937e:	428d      	cmp	r5, r1
   29380:	d18c      	bne.n	2929c <shell_make_argv+0x8c>
						shell_strlen(cmd));
   29382:	4620      	mov	r0, r4
   29384:	f7ff ff0e 	bl	291a4 <shell_strlen>
				memmove(cmd, cmd + 1,
   29388:	f104 0901 	add.w	r9, r4, #1
   2938c:	4602      	mov	r2, r0
   2938e:	4649      	mov	r1, r9
   29390:	4620      	mov	r0, r4
   29392:	f001 f845 	bl	2a420 <memmove>
				cmd += 1;
   29396:	464c      	mov	r4, r9
   29398:	e75a      	b.n	29250 <shell_make_argv+0x40>

0002939a <shell_pattern_remove>:
{
   2939a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2939c:	460e      	mov	r6, r1
	char *pattern_addr = strstr(buff, pattern);
   2939e:	4611      	mov	r1, r2
{
   293a0:	4615      	mov	r5, r2
   293a2:	4607      	mov	r7, r0
	char *pattern_addr = strstr(buff, pattern);
   293a4:	f000 ffc2 	bl	2a32c <strstr>
   293a8:	4604      	mov	r4, r0
	u16_t pattern_len = shell_strlen(pattern);
   293aa:	4628      	mov	r0, r5
   293ac:	f7ff fefa 	bl	291a4 <shell_strlen>
   293b0:	4605      	mov	r5, r0
	if (!pattern_addr) {
   293b2:	b1c4      	cbz	r4, 293e6 <shell_pattern_remove+0x4c>
	if (pattern_addr > buff) {
   293b4:	42a7      	cmp	r7, r4
   293b6:	d207      	bcs.n	293c8 <shell_pattern_remove+0x2e>
		if (*(pattern_addr - 1) == ' ') {
   293b8:	f814 3c01 	ldrb.w	r3, [r4, #-1]
   293bc:	2b20      	cmp	r3, #32
			pattern_len++; /* space needs to be removed as well */
   293be:	bf02      	ittt	eq
   293c0:	3501      	addeq	r5, #1
   293c2:	b2ad      	uxtheq	r5, r5
			pattern_addr--; /* set pointer to space */
   293c4:	f104 34ff 	addeq.w	r4, r4, #4294967295	; 0xffffffff
	shift = shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
   293c8:	4620      	mov	r0, r4
   293ca:	f7ff feeb 	bl	291a4 <shell_strlen>
	*buff_len -= pattern_len;
   293ce:	8833      	ldrh	r3, [r6, #0]
	shift = shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
   293d0:	1b42      	subs	r2, r0, r5
	*buff_len -= pattern_len;
   293d2:	1b5b      	subs	r3, r3, r5
	shift = shell_strlen(pattern_addr) - pattern_len + 1; /* +1 for EOS */
   293d4:	3201      	adds	r2, #1
	*buff_len -= pattern_len;
   293d6:	8033      	strh	r3, [r6, #0]
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
   293d8:	1961      	adds	r1, r4, r5
   293da:	4620      	mov	r0, r4
   293dc:	b292      	uxth	r2, r2
}
   293de:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	memmove(pattern_addr, pattern_addr + pattern_len, shift);
   293e2:	f001 b81d 	b.w	2a420 <memmove>
}
   293e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000293e8 <shell_get_last_command>:
					     size_t argc,
					     char *argv[],
					     size_t *match_arg,
					     struct shell_static_entry *d_entry,
					     bool only_static)
{
   293e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   293ec:	b087      	sub	sp, #28
   293ee:	461d      	mov	r5, r3
	const struct shell_static_entry *prev_entry = NULL;
	const struct shell_static_entry *entry = NULL;
	const struct shell_cmd_entry *cmd = NULL;

	*match_arg = SHELL_CMD_ROOT_LVL;
   293f0:	2400      	movs	r4, #0
{
   293f2:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44
   293f6:	9303      	str	r3, [sp, #12]
   293f8:	4681      	mov	r9, r0
   293fa:	4688      	mov	r8, r1
   293fc:	4617      	mov	r7, r2
	*match_arg = SHELL_CMD_ROOT_LVL;
   293fe:	602c      	str	r4, [r5, #0]
	const struct shell_static_entry *entry = NULL;
   29400:	46a2      	mov	sl, r4

	while (*match_arg < argc) {
   29402:	682b      	ldr	r3, [r5, #0]
   29404:	4543      	cmp	r3, r8
   29406:	d303      	bcc.n	29410 <shell_get_last_command+0x28>
			return NULL;
		}
	}

	return entry;
}
   29408:	4650      	mov	r0, sl
   2940a:	b007      	add	sp, #28
   2940c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (shell_wildcard_character_exist(argv[*match_arg])) {
   29410:	f857 0023 	ldr.w	r0, [r7, r3, lsl #2]
   29414:	f000 fcbb 	bl	29d8e <shell_wildcard_character_exist>
   29418:	682e      	ldr	r6, [r5, #0]
   2941a:	b110      	cbz	r0, 29422 <shell_get_last_command+0x3a>
				(*match_arg)++;
   2941c:	3601      	adds	r6, #1
   2941e:	602e      	str	r6, [r5, #0]
				continue;
   29420:	e7ef      	b.n	29402 <shell_get_last_command+0x1a>
		entry = find_cmd(shell, cmd, *match_arg, argv[*match_arg],
   29422:	f857 b026 	ldr.w	fp, [r7, r6, lsl #2]
	const struct shell_static_entry *entry = NULL;
   29426:	9005      	str	r0, [sp, #20]
	size_t idx = 0;
   29428:	4603      	mov	r3, r0
		shell_cmd_get(shell, cmd, lvl, idx++, &entry, d_entry);
   2942a:	9a10      	ldr	r2, [sp, #64]	; 0x40
   2942c:	9201      	str	r2, [sp, #4]
   2942e:	aa05      	add	r2, sp, #20
   29430:	9200      	str	r2, [sp, #0]
   29432:	4621      	mov	r1, r4
   29434:	4632      	mov	r2, r6
   29436:	4648      	mov	r0, r9
   29438:	f103 0a01 	add.w	sl, r3, #1
   2943c:	f7e9 fab0 	bl	129a0 <shell_cmd_get>
		if (entry && (strcmp(cmd_str, entry->syntax) == 0)) {
   29440:	9b05      	ldr	r3, [sp, #20]
   29442:	b13b      	cbz	r3, 29454 <shell_get_last_command+0x6c>
   29444:	6819      	ldr	r1, [r3, #0]
   29446:	4658      	mov	r0, fp
   29448:	f000 ffbf 	bl	2a3ca <strcmp>
   2944c:	9a05      	ldr	r2, [sp, #20]
   2944e:	b920      	cbnz	r0, 2945a <shell_get_last_command+0x72>
		if (entry) {
   29450:	4692      	mov	sl, r2
   29452:	b932      	cbnz	r2, 29462 <shell_get_last_command+0x7a>
   29454:	f04f 0a00 	mov.w	sl, #0
   29458:	e7d6      	b.n	29408 <shell_get_last_command+0x20>
		shell_cmd_get(shell, cmd, lvl, idx++, &entry, d_entry);
   2945a:	4653      	mov	r3, sl
	} while (entry);
   2945c:	2a00      	cmp	r2, #0
   2945e:	d1e4      	bne.n	2942a <shell_get_last_command+0x42>
   29460:	e7f8      	b.n	29454 <shell_get_last_command+0x6c>
			(*match_arg)++;
   29462:	682b      	ldr	r3, [r5, #0]
			cmd = entry->subcmd;
   29464:	6894      	ldr	r4, [r2, #8]
			(*match_arg)++;
   29466:	1c5a      	adds	r2, r3, #1
   29468:	602a      	str	r2, [r5, #0]
		if (cmd == NULL) {
   2946a:	2c00      	cmp	r4, #0
   2946c:	d0f2      	beq.n	29454 <shell_get_last_command+0x6c>
		if (only_static && cmd->is_dynamic) {
   2946e:	9a03      	ldr	r2, [sp, #12]
   29470:	2a00      	cmp	r2, #0
   29472:	d0c6      	beq.n	29402 <shell_get_last_command+0x1a>
   29474:	7822      	ldrb	r2, [r4, #0]
   29476:	2a00      	cmp	r2, #0
   29478:	d0c3      	beq.n	29402 <shell_get_last_command+0x1a>
			(*match_arg)--;
   2947a:	602b      	str	r3, [r5, #0]
			return NULL;
   2947c:	e7ea      	b.n	29454 <shell_get_last_command+0x6c>

0002947e <shell_spaces_trim>:

	return 0;
}

void shell_spaces_trim(char *str)
{
   2947e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   29482:	4607      	mov	r7, r0
	u16_t len = shell_strlen(str);
   29484:	f7ff fe8e 	bl	291a4 <shell_strlen>
   29488:	4680      	mov	r8, r0
	u16_t shift = 0U;

	if (!str) {
   2948a:	bb4f      	cbnz	r7, 294e0 <shell_spaces_trim+0x62>

				break;
			}
		}
	}
}
   2948c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				if (shift > 0) {
   29490:	b15c      	cbz	r4, 294aa <shell_spaces_trim+0x2c>
						len - shift + 1);
   29492:	f108 0201 	add.w	r2, r8, #1
					memmove(&str[i + 1],
   29496:	1c68      	adds	r0, r5, #1
   29498:	1b12      	subs	r2, r2, r4
   2949a:	4438      	add	r0, r7
   2949c:	f000 ffc0 	bl	2a420 <memmove>
					len -= shift;
   294a0:	eba8 0404 	sub.w	r4, r8, r4
   294a4:	fa1f f884 	uxth.w	r8, r4
					shift = 0U;
   294a8:	464c      	mov	r4, r9
	for (u16_t i = 0; i < len - 1; i++) {
   294aa:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
   294ae:	429e      	cmp	r6, r3
   294b0:	daec      	bge.n	2948c <shell_spaces_trim+0xe>
		if (isspace((int)str[i])) {
   294b2:	5db8      	ldrb	r0, [r7, r6]
   294b4:	f7ff fe6c 	bl	29190 <isspace>
   294b8:	4635      	mov	r5, r6
   294ba:	3601      	adds	r6, #1
   294bc:	b2b6      	uxth	r6, r6
   294be:	2800      	cmp	r0, #0
   294c0:	d0f3      	beq.n	294aa <shell_spaces_trim+0x2c>
			for (u16_t j = i + 1; j < len; j++) {
   294c2:	4633      	mov	r3, r6
   294c4:	b29a      	uxth	r2, r3
   294c6:	4590      	cmp	r8, r2
   294c8:	d9ef      	bls.n	294aa <shell_spaces_trim+0x2c>
				if (isspace((int)str[j])) {
   294ca:	5cf8      	ldrb	r0, [r7, r3]
   294cc:	18f9      	adds	r1, r7, r3
   294ce:	f7ff fe5f 	bl	29190 <isspace>
   294d2:	3301      	adds	r3, #1
   294d4:	4681      	mov	r9, r0
   294d6:	2800      	cmp	r0, #0
   294d8:	d0da      	beq.n	29490 <shell_spaces_trim+0x12>
					shift++;
   294da:	3401      	adds	r4, #1
   294dc:	b2a4      	uxth	r4, r4
					continue;
   294de:	e7f1      	b.n	294c4 <shell_spaces_trim+0x46>
	for (u16_t i = 0; i < len - 1; i++) {
   294e0:	2600      	movs	r6, #0
	u16_t shift = 0U;
   294e2:	4634      	mov	r4, r6
   294e4:	e7e1      	b.n	294aa <shell_spaces_trim+0x2c>

000294e6 <shell_cmd_trim>:
		*buff_len = *buff_len - i;
	}
}

void shell_cmd_trim(const struct shell *shell)
{
   294e6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	buffer_trim(shell->ctx->cmd_buff, &shell->ctx->cmd_buff_len);
   294ea:	6884      	ldr	r4, [r0, #8]
	if (buff[0] == '\0') {
   294ec:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
{
   294f0:	4606      	mov	r6, r0
	if (buff[0] == '\0') {
   294f2:	b95b      	cbnz	r3, 2950c <shell_cmd_trim+0x26>
	shell->ctx->cmd_buff_pos = shell->ctx->cmd_buff_len;
   294f4:	68b3      	ldr	r3, [r6, #8]
   294f6:	8e5a      	ldrh	r2, [r3, #50]	; 0x32
   294f8:	869a      	strh	r2, [r3, #52]	; 0x34
}
   294fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		*buff_len -= 1U;
   294fe:	3b01      	subs	r3, #1
   29500:	b29b      	uxth	r3, r3
   29502:	8663      	strh	r3, [r4, #50]	; 0x32
		if (*buff_len == 0U) {
   29504:	b923      	cbnz	r3, 29510 <shell_cmd_trim+0x2a>
			buff[0] = '\0';
   29506:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
			return;
   2950a:	e7f3      	b.n	294f4 <shell_cmd_trim+0xe>
	buffer_trim(shell->ctx->cmd_buff, &shell->ctx->cmd_buff_len);
   2950c:	f104 0538 	add.w	r5, r4, #56	; 0x38
	while (isspace((int) buff[*buff_len - 1U])) {
   29510:	8e63      	ldrh	r3, [r4, #50]	; 0x32
   29512:	18ea      	adds	r2, r5, r3
   29514:	f812 0c01 	ldrb.w	r0, [r2, #-1]
   29518:	f7ff fe3a 	bl	29190 <isspace>
   2951c:	2800      	cmp	r0, #0
   2951e:	d1ee      	bne.n	294fe <shell_cmd_trim+0x18>
	buff[*buff_len] = '\0';
   29520:	54e8      	strb	r0, [r5, r3]
   29522:	4603      	mov	r3, r0
   29524:	fa1f f883 	uxth.w	r8, r3
	}
   29528:	4647      	mov	r7, r8
	while (isspace((int) buff[i++])) {
   2952a:	f815 0008 	ldrb.w	r0, [r5, r8]
   2952e:	19e9      	adds	r1, r5, r7
   29530:	f7ff fe2e 	bl	29190 <isspace>
   29534:	3301      	adds	r3, #1
   29536:	2800      	cmp	r0, #0
   29538:	d1f4      	bne.n	29524 <shell_cmd_trim+0x3e>
	if (--i > 0) {
   2953a:	f1b8 0f00 	cmp.w	r8, #0
   2953e:	d0d9      	beq.n	294f4 <shell_cmd_trim+0xe>
		memmove(buff, buff + i, (*buff_len + 1U) - i); /* +1 for '\0' */
   29540:	8e62      	ldrh	r2, [r4, #50]	; 0x32
   29542:	3201      	adds	r2, #1
   29544:	1bd2      	subs	r2, r2, r7
   29546:	4628      	mov	r0, r5
   29548:	f000 ff6a 	bl	2a420 <memmove>
		*buff_len = *buff_len - i;
   2954c:	8e63      	ldrh	r3, [r4, #50]	; 0x32
   2954e:	eba3 0308 	sub.w	r3, r3, r8
   29552:	8663      	strh	r3, [r4, #50]	; 0x32
   29554:	e7ce      	b.n	294f4 <shell_cmd_trim+0xe>

00029556 <shell_raw_fprintf>:
{
   29556:	b40e      	push	{r1, r2, r3}
   29558:	b503      	push	{r0, r1, lr}
   2955a:	aa03      	add	r2, sp, #12
   2955c:	f852 1b04 	ldr.w	r1, [r2], #4
	va_start(args, fmt);
   29560:	9201      	str	r2, [sp, #4]
	shell_fprintf_fmt(ctx, fmt, args);
   29562:	f7e9 fa09 	bl	12978 <shell_fprintf_fmt>
}
   29566:	b002      	add	sp, #8
   29568:	f85d eb04 	ldr.w	lr, [sp], #4
   2956c:	b003      	add	sp, #12
   2956e:	4770      	bx	lr

00029570 <full_line_cmd.isra.8>:
static inline bool full_line_cmd(const struct shell *shell)
   29570:	b538      	push	{r3, r4, r5, lr}
	return ((shell->ctx->cmd_buff_len + shell_strlen(shell->ctx->prompt))
   29572:	6803      	ldr	r3, [r0, #0]
static inline bool full_line_cmd(const struct shell *shell)
   29574:	4604      	mov	r4, r0
	return ((shell->ctx->cmd_buff_len + shell_strlen(shell->ctx->prompt))
   29576:	6818      	ldr	r0, [r3, #0]
   29578:	8e5d      	ldrh	r5, [r3, #50]	; 0x32
	return str == NULL ? 0U : (u16_t)strlen(str);
   2957a:	b110      	cbz	r0, 29582 <full_line_cmd.isra.8+0x12>
   2957c:	f000 ff1e 	bl	2a3bc <strlen>
   29580:	b280      	uxth	r0, r0
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
   29582:	6823      	ldr	r3, [r4, #0]
   29584:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a
	return ((shell->ctx->cmd_buff_len + shell_strlen(shell->ctx->prompt))
   29586:	4428      	add	r0, r5
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
   29588:	fbb0 f3f2 	udiv	r3, r0, r2
   2958c:	fb02 0013 	mls	r0, r2, r3, r0
}
   29590:	fab0 f080 	clz	r0, r0
   29594:	0940      	lsrs	r0, r0, #5
   29596:	bd38      	pop	{r3, r4, r5, pc}

00029598 <shell_cursor_in_empty_line>:
{
   29598:	b538      	push	{r3, r4, r5, lr}
	return ((shell->ctx->cmd_buff_pos + shell_strlen(shell->ctx->prompt))
   2959a:	6883      	ldr	r3, [r0, #8]
{
   2959c:	4604      	mov	r4, r0
	return ((shell->ctx->cmd_buff_pos + shell_strlen(shell->ctx->prompt))
   2959e:	6818      	ldr	r0, [r3, #0]
   295a0:	8e9d      	ldrh	r5, [r3, #52]	; 0x34
   295a2:	b110      	cbz	r0, 295aa <shell_cursor_in_empty_line+0x12>
   295a4:	f000 ff0a 	bl	2a3bc <strlen>
   295a8:	b280      	uxth	r0, r0
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
   295aa:	68a3      	ldr	r3, [r4, #8]
   295ac:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a
	return ((shell->ctx->cmd_buff_pos + shell_strlen(shell->ctx->prompt))
   295ae:	4428      	add	r0, r5
			% shell->ctx->vt100_ctx.cons.terminal_wid == 0U);
   295b0:	fbb0 f3f2 	udiv	r3, r0, r2
   295b4:	fb02 0013 	mls	r0, r2, r3, r0
}
   295b8:	fab0 f080 	clz	r0, r0
   295bc:	0940      	lsrs	r0, r0, #5
   295be:	bd38      	pop	{r3, r4, r5, pc}

000295c0 <shell_op_cursor_move>:
{
   295c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   295c2:	4604      	mov	r4, r0
	struct shell_multiline_cons *cons = &shell->ctx->vt100_ctx.cons;
   295c4:	6880      	ldr	r0, [r0, #8]
	u16_t new_pos = shell->ctx->cmd_buff_pos + val;
   295c6:	8e83      	ldrh	r3, [r0, #52]	; 0x34
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
   295c8:	8e42      	ldrh	r2, [r0, #50]	; 0x32
	u16_t new_pos = shell->ctx->cmd_buff_pos + val;
   295ca:	4419      	add	r1, r3
   295cc:	b28d      	uxth	r5, r1
	shell_multiline_data_calc(cons, shell->ctx->cmd_buff_pos,
   295ce:	3020      	adds	r0, #32
   295d0:	4619      	mov	r1, r3
   295d2:	f7ff fe07 	bl	291e4 <shell_multiline_data_calc>
	row_span = row_span_with_buffer_offsets_get(&shell->ctx->vt100_ctx.cons,
   295d6:	68a0      	ldr	r0, [r4, #8]
   295d8:	462a      	mov	r2, r5
   295da:	8e81      	ldrh	r1, [r0, #52]	; 0x34
   295dc:	3020      	adds	r0, #32
   295de:	f7ff fdf6 	bl	291ce <row_span_with_buffer_offsets_get>
   295e2:	4607      	mov	r7, r0
						    &shell->ctx->vt100_ctx.cons,
   295e4:	68a0      	ldr	r0, [r4, #8]
	col_span = column_span_with_buffer_offsets_get(
   295e6:	462a      	mov	r2, r5
   295e8:	8e81      	ldrh	r1, [r0, #52]	; 0x34
   295ea:	3020      	adds	r0, #32
   295ec:	f7ff fde0 	bl	291b0 <column_span_with_buffer_offsets_get>
	shell_op_cursor_vert_move(shell, -row_span);
   295f0:	4279      	negs	r1, r7
	col_span = column_span_with_buffer_offsets_get(
   295f2:	4606      	mov	r6, r0
	shell_op_cursor_vert_move(shell, -row_span);
   295f4:	4620      	mov	r0, r4
   295f6:	f7e9 fa05 	bl	12a04 <shell_op_cursor_vert_move>
	shell_op_cursor_horiz_move(shell, col_span);
   295fa:	4631      	mov	r1, r6
   295fc:	4620      	mov	r0, r4
   295fe:	f7e9 fa11 	bl	12a24 <shell_op_cursor_horiz_move>
	shell->ctx->cmd_buff_pos = new_pos;
   29602:	68a3      	ldr	r3, [r4, #8]
   29604:	869d      	strh	r5, [r3, #52]	; 0x34
}
   29606:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00029608 <shell_op_cursor_word_move>:
{
   29608:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	if (val < 0) {
   2960c:	1e0c      	subs	r4, r1, #0
{
   2960e:	4606      	mov	r6, r0
	if (val < 0) {
   29610:	da32      	bge.n	29678 <shell_op_cursor_word_move+0x70>
		val = -val;
   29612:	4264      	negs	r4, r4
   29614:	b224      	sxth	r4, r4
		sign = -1;
   29616:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   2961a:	b2af      	uxth	r7, r5
   2961c:	e022      	b.n	29664 <shell_op_cursor_word_move+0x5c>
		shift = shift_calc(shell->ctx->cmd_buff,
   2961e:	68b3      	ldr	r3, [r6, #8]
   29620:	f8b3 e034 	ldrh.w	lr, [r3, #52]	; 0x34
   29624:	f8b3 9032 	ldrh.w	r9, [r3, #50]	; 0x32
   29628:	f103 0838 	add.w	r8, r3, #56	; 0x38
	bool found = false;
   2962c:	2000      	movs	r0, #0
		shift = shift_calc(shell->ctx->cmd_buff,
   2962e:	4673      	mov	r3, lr
		idx = pos + ret * sign;
   29630:	eba3 010e 	sub.w	r1, r3, lr
   29634:	b209      	sxth	r1, r1
		if (((idx == 0U) && (sign < 0)) ||
   29636:	b90b      	cbnz	r3, 2963c <shell_op_cursor_word_move+0x34>
   29638:	1c6a      	adds	r2, r5, #1
   2963a:	d010      	beq.n	2965e <shell_op_cursor_word_move+0x56>
   2963c:	4599      	cmp	r9, r3
   2963e:	d101      	bne.n	29644 <shell_op_cursor_word_move+0x3c>
		    ((idx == len) && (sign > 0))) {
   29640:	2d01      	cmp	r5, #1
   29642:	d00c      	beq.n	2965e <shell_op_cursor_word_move+0x56>
		if (isalnum((int)str[idx]) != 0) {
   29644:	f818 2003 	ldrb.w	r2, [r8, r3]
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
   29648:	f042 0c20 	orr.w	ip, r2, #32
   2964c:	f1ac 0c61 	sub.w	ip, ip, #97	; 0x61
				(int)'z') ? (chr - 32) : (chr));
}

static inline int isalnum(int chr)
{
	return (int)(isalpha(chr) || isdigit(chr));
   29650:	f1bc 0f19 	cmp.w	ip, #25
   29654:	d90c      	bls.n	29670 <shell_op_cursor_word_move+0x68>
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   29656:	3a30      	subs	r2, #48	; 0x30
	return (int)(isalpha(chr) || isdigit(chr));
   29658:	2a09      	cmp	r2, #9
   2965a:	d909      	bls.n	29670 <shell_op_cursor_word_move+0x68>
			if (found) {
   2965c:	b148      	cbz	r0, 29672 <shell_op_cursor_word_move+0x6a>
		shell_op_cursor_move(shell, sign * shift);
   2965e:	4630      	mov	r0, r6
   29660:	f7ff ffae 	bl	295c0 <shell_op_cursor_move>
	while (val--) {
   29664:	3c01      	subs	r4, #1
   29666:	b224      	sxth	r4, r4
   29668:	1c63      	adds	r3, r4, #1
   2966a:	d1d8      	bne.n	2961e <shell_op_cursor_word_move+0x16>
}
   2966c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			found = true;
   29670:	2001      	movs	r0, #1
		ret++;
   29672:	443b      	add	r3, r7
   29674:	b29b      	uxth	r3, r3
   29676:	e7db      	b.n	29630 <shell_op_cursor_word_move+0x28>
		sign = 1;
   29678:	2501      	movs	r5, #1
   2967a:	e7ce      	b.n	2961a <shell_op_cursor_word_move+0x12>

0002967c <shell_op_cursor_home_move>:
	shell_op_cursor_move(shell, -shell->ctx->cmd_buff_pos);
   2967c:	6883      	ldr	r3, [r0, #8]
   2967e:	8e99      	ldrh	r1, [r3, #52]	; 0x34
   29680:	4249      	negs	r1, r1
   29682:	b209      	sxth	r1, r1
   29684:	f7ff bf9c 	b.w	295c0 <shell_op_cursor_move>

00029688 <shell_op_cursor_end_move>:
	shell_op_cursor_move(shell, shell->ctx->cmd_buff_len -
   29688:	6883      	ldr	r3, [r0, #8]
   2968a:	8e59      	ldrh	r1, [r3, #50]	; 0x32
   2968c:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
   2968e:	1ac9      	subs	r1, r1, r3
   29690:	b209      	sxth	r1, r1
   29692:	f7ff bf95 	b.w	295c0 <shell_op_cursor_move>

00029696 <shell_op_left_arrow>:
	if (shell->ctx->cmd_buff_pos > 0) {
   29696:	6883      	ldr	r3, [r0, #8]
   29698:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
   2969a:	b11b      	cbz	r3, 296a4 <shell_op_left_arrow+0xe>
		shell_op_cursor_move(shell, -1);
   2969c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   296a0:	f7ff bf8e 	b.w	295c0 <shell_op_cursor_move>
}
   296a4:	4770      	bx	lr

000296a6 <shell_op_right_arrow>:
	if (shell->ctx->cmd_buff_pos < shell->ctx->cmd_buff_len) {
   296a6:	6883      	ldr	r3, [r0, #8]
   296a8:	8e9a      	ldrh	r2, [r3, #52]	; 0x34
   296aa:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
   296ac:	429a      	cmp	r2, r3
   296ae:	d202      	bcs.n	296b6 <shell_op_right_arrow+0x10>
		shell_op_cursor_move(shell, 1);
   296b0:	2101      	movs	r1, #1
   296b2:	f7ff bf85 	b.w	295c0 <shell_op_cursor_move>
}
   296b6:	4770      	bx	lr

000296b8 <shell_op_delete_from_cursor>:
	shell->ctx->cmd_buff_len = shell->ctx->cmd_buff_pos;
   296b8:	6883      	ldr	r3, [r0, #8]
   296ba:	8e9a      	ldrh	r2, [r3, #52]	; 0x34
   296bc:	865a      	strh	r2, [r3, #50]	; 0x32
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos] = '\0';
   296be:	4413      	add	r3, r2
   296c0:	2200      	movs	r2, #0
   296c2:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
	clear_eos(shell);
   296c6:	6940      	ldr	r0, [r0, #20]
   296c8:	f7e9 b994 	b.w	129f4 <clear_eos.isra.6>

000296cc <shell_cmd_line_erase>:
{
   296cc:	b510      	push	{r4, lr}
   296ce:	4604      	mov	r4, r0
	shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
   296d0:	6880      	ldr	r0, [r0, #8]
   296d2:	8e42      	ldrh	r2, [r0, #50]	; 0x32
   296d4:	8e81      	ldrh	r1, [r0, #52]	; 0x34
   296d6:	3020      	adds	r0, #32
   296d8:	f7ff fd84 	bl	291e4 <shell_multiline_data_calc>
				   -(shell->ctx->vt100_ctx.cons.cur_x - 1));
   296dc:	68a3      	ldr	r3, [r4, #8]
   296de:	8c19      	ldrh	r1, [r3, #32]
	shell_op_cursor_horiz_move(shell,
   296e0:	4620      	mov	r0, r4
   296e2:	f1c1 0101 	rsb	r1, r1, #1
   296e6:	f7e9 f99d 	bl	12a24 <shell_op_cursor_horiz_move>
	shell_op_cursor_vert_move(shell, shell->ctx->vt100_ctx.cons.cur_y - 1);
   296ea:	68a3      	ldr	r3, [r4, #8]
   296ec:	8c99      	ldrh	r1, [r3, #36]	; 0x24
   296ee:	4620      	mov	r0, r4
   296f0:	3901      	subs	r1, #1
   296f2:	f7e9 f987 	bl	12a04 <shell_op_cursor_vert_move>
	clear_eos(shell);
   296f6:	6960      	ldr	r0, [r4, #20]
}
   296f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	clear_eos(shell);
   296fc:	f7e9 b97a 	b.w	129f4 <clear_eos.isra.6>

00029700 <shell_write>:
{
   29700:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   29704:	4607      	mov	r7, r0
   29706:	4688      	mov	r8, r1
   29708:	4614      	mov	r4, r2
	size_t offset = 0;
   2970a:	2600      	movs	r6, #0
	while (length) {
   2970c:	b914      	cbnz	r4, 29714 <shell_write+0x14>
}
   2970e:	b002      	add	sp, #8
   29710:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		int err = shell->iface->api->write(shell->iface,
   29714:	6878      	ldr	r0, [r7, #4]
   29716:	6803      	ldr	r3, [r0, #0]
   29718:	4622      	mov	r2, r4
   2971a:	68dd      	ldr	r5, [r3, #12]
   2971c:	eb08 0106 	add.w	r1, r8, r6
   29720:	ab01      	add	r3, sp, #4
   29722:	47a8      	blx	r5
		offset += tmp_cnt;
   29724:	9d01      	ldr	r5, [sp, #4]
   29726:	442e      	add	r6, r5
		length -= tmp_cnt;
   29728:	1b64      	subs	r4, r4, r5
		if (tmp_cnt == 0 &&
   2972a:	2d00      	cmp	r5, #0
   2972c:	d1ee      	bne.n	2970c <shell_write+0xc>
		    (shell->ctx->state != SHELL_STATE_PANIC_MODE_ACTIVE)) {
   2972e:	68b8      	ldr	r0, [r7, #8]
   29730:	7903      	ldrb	r3, [r0, #4]
		if (tmp_cnt == 0 &&
   29732:	2b03      	cmp	r3, #3
   29734:	d0ea      	beq.n	2970c <shell_write+0xc>
	if (IS_ENABLED(CONFIG_MULTITHREADING) &&
   29736:	2b02      	cmp	r3, #2
   29738:	d80a      	bhi.n	29750 <shell_write+0x50>
	return z_impl_k_poll(events, num_events, timeout);
   2973a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2973e:	2101      	movs	r1, #1
   29740:	f500 7036 	add.w	r0, r0, #728	; 0x2d8
   29744:	f7fe f83e 	bl	277c4 <z_impl_k_poll>
		k_poll_signal_reset(&shell->ctx->signals[SHELL_SIGNAL_TXDONE]);
   29748:	68bb      	ldr	r3, [r7, #8]
   2974a:	f8c3 5294 	str.w	r5, [r3, #660]	; 0x294
   2974e:	e7dd      	b.n	2970c <shell_write+0xc>
	return shell->ctx->internal.flags.tx_rdy == 1 ? true : false;
   29750:	f8d0 3258 	ldr.w	r3, [r0, #600]	; 0x258
		while (!flag_tx_rdy_get(shell)) {
   29754:	06db      	lsls	r3, r3, #27
   29756:	d5fb      	bpl.n	29750 <shell_write+0x50>
	shell->ctx->internal.flags.tx_rdy = val ? 1 : 0;
   29758:	f8b0 3258 	ldrh.w	r3, [r0, #600]	; 0x258
   2975c:	f36f 1304 	bfc	r3, #4, #1
   29760:	f8a0 3258 	strh.w	r3, [r0, #600]	; 0x258
   29764:	e7d2      	b.n	2970c <shell_write+0xc>

00029766 <shell_print_stream>:
	shell_write((const struct shell *) user_ctx, data, data_len);
   29766:	f7ff bfcb 	b.w	29700 <shell_write>

0002976a <shell_internal_vfprintf>:

void shell_internal_vfprintf(const struct shell *shell,
			     enum shell_vt100_color color, const char *fmt,
			     va_list args)
{
   2976a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2976c:	460f      	mov	r7, r1
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
	    shell->ctx->internal.flags.use_colors &&
   2976e:	6881      	ldr	r1, [r0, #8]
{
   29770:	461e      	mov	r6, r3
	    shell->ctx->internal.flags.use_colors &&
   29772:	f8d1 3258 	ldr.w	r3, [r1, #600]	; 0x258
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
   29776:	079b      	lsls	r3, r3, #30
{
   29778:	4604      	mov	r4, r0
   2977a:	4615      	mov	r5, r2
	if (IS_ENABLED(CONFIG_SHELL_VT100_COLORS) &&
   2977c:	d517      	bpl.n	297ae <shell_internal_vfprintf+0x44>
	    shell->ctx->internal.flags.use_colors &&
   2977e:	f891 302e 	ldrb.w	r3, [r1, #46]	; 0x2e
   29782:	42bb      	cmp	r3, r7
   29784:	d013      	beq.n	297ae <shell_internal_vfprintf+0x44>
			   enum shell_vt100_color color);

static inline void shell_vt100_colors_store(const struct shell *shell,
					    struct shell_vt100_colors *color)
{
	memcpy(color, &shell->ctx->vt100_ctx.col, sizeof(*color));
   29786:	2202      	movs	r2, #2
   29788:	312e      	adds	r1, #46	; 0x2e
   2978a:	a801      	add	r0, sp, #4
   2978c:	f000 fe5f 	bl	2a44e <memcpy>
	    (color != shell->ctx->vt100_ctx.col.col)) {
		struct shell_vt100_colors col;

		shell_vt100_colors_store(shell, &col);
		shell_vt100_color_set(shell, color);
   29790:	4639      	mov	r1, r7
   29792:	4620      	mov	r0, r4
   29794:	f7e9 f99c 	bl	12ad0 <shell_vt100_color_set>

		shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
   29798:	4629      	mov	r1, r5
   2979a:	6960      	ldr	r0, [r4, #20]
   2979c:	4632      	mov	r2, r6
   2979e:	f7e9 f8eb 	bl	12978 <shell_fprintf_fmt>

		shell_vt100_colors_restore(shell, &col);
   297a2:	a901      	add	r1, sp, #4
   297a4:	4620      	mov	r0, r4
   297a6:	f7e9 f9b7 	bl	12b18 <shell_vt100_colors_restore>
	} else {
		shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
	}
}
   297aa:	b003      	add	sp, #12
   297ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
		shell_fprintf_fmt(shell->fprintf_ctx, fmt, args);
   297ae:	4632      	mov	r2, r6
   297b0:	4629      	mov	r1, r5
   297b2:	6960      	ldr	r0, [r4, #20]
   297b4:	f7e9 f8e0 	bl	12978 <shell_fprintf_fmt>
}
   297b8:	e7f7      	b.n	297aa <shell_internal_vfprintf+0x40>

000297ba <shell_internal_fprintf>:

void shell_internal_fprintf(const struct shell *shell,
			    enum shell_vt100_color color,
			    const char *fmt, ...)
{
   297ba:	b40c      	push	{r2, r3}
   297bc:	b507      	push	{r0, r1, r2, lr}
   297be:	ab04      	add	r3, sp, #16
   297c0:	f853 2b04 	ldr.w	r2, [r3], #4
	__ASSERT_NO_MSG(shell->fprintf_ctx);
	__ASSERT_NO_MSG(fmt);

	va_list args;

	va_start(args, fmt);
   297c4:	9301      	str	r3, [sp, #4]
	shell_internal_vfprintf(shell, color, fmt, args);
   297c6:	f7ff ffd0 	bl	2976a <shell_internal_vfprintf>
	va_end(args);
}
   297ca:	b003      	add	sp, #12
   297cc:	f85d eb04 	ldr.w	lr, [sp], #4
   297d0:	b002      	add	sp, #8
   297d2:	4770      	bx	lr

000297d4 <data_insert>:
{
   297d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
   297d8:	6886      	ldr	r6, [r0, #8]
   297da:	8e74      	ldrh	r4, [r6, #50]	; 0x32
	if ((shell->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
   297dc:	18a3      	adds	r3, r4, r2
   297de:	2bff      	cmp	r3, #255	; 0xff
{
   297e0:	4607      	mov	r7, r0
   297e2:	4688      	mov	r8, r1
   297e4:	4615      	mov	r5, r2
	if ((shell->ctx->cmd_buff_len + len) >= CONFIG_SHELL_CMD_BUFF_SIZE) {
   297e6:	dc1f      	bgt.n	29828 <data_insert+0x54>
	u16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
   297e8:	8eb3      	ldrh	r3, [r6, #52]	; 0x34
   297ea:	1ae4      	subs	r4, r4, r3
	char *curr_pos = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
   297ec:	3338      	adds	r3, #56	; 0x38
   297ee:	441e      	add	r6, r3
	u16_t after = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
   297f0:	b2a4      	uxth	r4, r4
	memmove(curr_pos + len, curr_pos, after);
   297f2:	4622      	mov	r2, r4
   297f4:	4631      	mov	r1, r6
   297f6:	1970      	adds	r0, r6, r5
   297f8:	f000 fe12 	bl	2a420 <memmove>
	memcpy(curr_pos, data, len);
   297fc:	462a      	mov	r2, r5
   297fe:	4641      	mov	r1, r8
   29800:	4630      	mov	r0, r6
   29802:	f000 fe24 	bl	2a44e <memcpy>
	shell->ctx->cmd_buff_len += len;
   29806:	68ba      	ldr	r2, [r7, #8]
   29808:	8e53      	ldrh	r3, [r2, #50]	; 0x32
   2980a:	442b      	add	r3, r5
   2980c:	b29b      	uxth	r3, r3
   2980e:	8653      	strh	r3, [r2, #50]	; 0x32
	shell->ctx->cmd_buff[shell->ctx->cmd_buff_len] = '\0';
   29810:	4413      	add	r3, r2
   29812:	2200      	movs	r2, #0
   29814:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
	if (!flag_echo_get(shell)) {
   29818:	68bb      	ldr	r3, [r7, #8]
	return shell->ctx->internal.flags.echo == 1 ? true : false;
   2981a:	f8d3 1258 	ldr.w	r1, [r3, #600]	; 0x258
   2981e:	0749      	lsls	r1, r1, #29
   29820:	d404      	bmi.n	2982c <data_insert+0x58>
		shell->ctx->cmd_buff_pos += len;
   29822:	8e9a      	ldrh	r2, [r3, #52]	; 0x34
   29824:	4415      	add	r5, r2
   29826:	869d      	strh	r5, [r3, #52]	; 0x34
}
   29828:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	reprint_from_cursor(shell, after, false);
   2982c:	4621      	mov	r1, r4
   2982e:	4638      	mov	r0, r7
}
   29830:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	reprint_from_cursor(shell, after, false);
   29834:	f7e9 b9ea 	b.w	12c0c <reprint_from_cursor>

00029838 <shell_op_completion_insert>:
	data_insert(shell, compl, compl_len);
   29838:	f7ff bfcc 	b.w	297d4 <data_insert>

0002983c <shell_op_char_delete>:
{
   2983c:	b538      	push	{r3, r4, r5, lr}
   2983e:	4605      	mov	r5, r0
	u16_t diff = shell->ctx->cmd_buff_len - shell->ctx->cmd_buff_pos;
   29840:	6880      	ldr	r0, [r0, #8]
   29842:	8e83      	ldrh	r3, [r0, #52]	; 0x34
   29844:	8e44      	ldrh	r4, [r0, #50]	; 0x32
   29846:	1ae4      	subs	r4, r4, r3
   29848:	b2a4      	uxth	r4, r4
	if (diff == 0U) {
   2984a:	b18c      	cbz	r4, 29870 <shell_op_char_delete+0x34>
	char *str = &shell->ctx->cmd_buff[shell->ctx->cmd_buff_pos];
   2984c:	3338      	adds	r3, #56	; 0x38
   2984e:	4418      	add	r0, r3
	memmove(str, str + 1, diff);
   29850:	4622      	mov	r2, r4
   29852:	1c41      	adds	r1, r0, #1
   29854:	f000 fde4 	bl	2a420 <memmove>
	--shell->ctx->cmd_buff_len;
   29858:	68aa      	ldr	r2, [r5, #8]
   2985a:	8e53      	ldrh	r3, [r2, #50]	; 0x32
	reprint_from_cursor(shell, --diff, true);
   2985c:	1e61      	subs	r1, r4, #1
	--shell->ctx->cmd_buff_len;
   2985e:	3b01      	subs	r3, #1
   29860:	8653      	strh	r3, [r2, #50]	; 0x32
	reprint_from_cursor(shell, --diff, true);
   29862:	4628      	mov	r0, r5
   29864:	2201      	movs	r2, #1
   29866:	b289      	uxth	r1, r1
}
   29868:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	reprint_from_cursor(shell, --diff, true);
   2986c:	f7e9 b9ce 	b.w	12c0c <reprint_from_cursor>
}
   29870:	bd38      	pop	{r3, r4, r5, pc}

00029872 <shell_op_char_backspace>:
	if ((shell->ctx->cmd_buff_len == 0) ||
   29872:	6883      	ldr	r3, [r0, #8]
   29874:	8e5a      	ldrh	r2, [r3, #50]	; 0x32
{
   29876:	b510      	push	{r4, lr}
   29878:	4604      	mov	r4, r0
	if ((shell->ctx->cmd_buff_len == 0) ||
   2987a:	b152      	cbz	r2, 29892 <shell_op_char_backspace+0x20>
   2987c:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
   2987e:	b143      	cbz	r3, 29892 <shell_op_char_backspace+0x20>
	shell_op_cursor_move(shell, -1);
   29880:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   29884:	f7ff fe9c 	bl	295c0 <shell_op_cursor_move>
	shell_op_char_delete(shell);
   29888:	4620      	mov	r0, r4
}
   2988a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	shell_op_char_delete(shell);
   2988e:	f7ff bfd5 	b.w	2983c <shell_op_char_delete>
}
   29892:	bd10      	pop	{r4, pc}

00029894 <z_impl_uart_irq_tx_disable>:
	if (api->irq_tx_disable) {
   29894:	6843      	ldr	r3, [r0, #4]
   29896:	6a1b      	ldr	r3, [r3, #32]
   29898:	b103      	cbz	r3, 2989c <z_impl_uart_irq_tx_disable+0x8>
		api->irq_tx_disable(dev);
   2989a:	4718      	bx	r3
}
   2989c:	4770      	bx	lr

0002989e <uninit>:
}
   2989e:	2000      	movs	r0, #0
   298a0:	4770      	bx	lr

000298a2 <read>:
{
   298a2:	b510      	push	{r4, lr}
   298a4:	461c      	mov	r4, r3
	*cnt = ring_buf_get(sh_uart->rx_ringbuf, data, length);
   298a6:	6843      	ldr	r3, [r0, #4]
   298a8:	68d8      	ldr	r0, [r3, #12]
   298aa:	f7fe fcf5 	bl	28298 <ring_buf_get>
   298ae:	6020      	str	r0, [r4, #0]
}
   298b0:	2000      	movs	r0, #0
   298b2:	bd10      	pop	{r4, pc}

000298b4 <write>:
{
   298b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct shell_uart *sh_uart = (struct shell_uart *)transport->ctx;
   298b8:	6845      	ldr	r5, [r0, #4]
{
   298ba:	461e      	mov	r6, r3
		!sh_uart->ctrl_blk->blocking_tx) {
   298bc:	682b      	ldr	r3, [r5, #0]
	if (IS_ENABLED(CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN) &&
   298be:	7c1b      	ldrb	r3, [r3, #16]
{
   298c0:	460c      	mov	r4, r1
   298c2:	4617      	mov	r7, r2
	if (IS_ENABLED(CONFIG_SHELL_BACKEND_SERIAL_INTERRUPT_DRIVEN) &&
   298c4:	b153      	cbz	r3, 298dc <write+0x28>
   298c6:	eb01 0802 	add.w	r8, r1, r2
		for (size_t i = 0; i < length; i++) {
   298ca:	4544      	cmp	r4, r8
   298cc:	682b      	ldr	r3, [r5, #0]
   298ce:	d120      	bne.n	29912 <write+0x5e>
		*cnt = length;
   298d0:	6037      	str	r7, [r6, #0]
		sh_uart->ctrl_blk->handler(SHELL_TRANSPORT_EVT_TX_RDY,
   298d2:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
   298d6:	2001      	movs	r0, #1
   298d8:	4790      	blx	r2
   298da:	e017      	b.n	2990c <write+0x58>
	*cnt = ring_buf_put(sh_uart->tx_ringbuf, data, length);
   298dc:	68a8      	ldr	r0, [r5, #8]
   298de:	f7fe fc86 	bl	281ee <ring_buf_put>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   298e2:	682b      	ldr	r3, [r5, #0]
   298e4:	6030      	str	r0, [r6, #0]
   298e6:	330c      	adds	r3, #12
   298e8:	2101      	movs	r1, #1
   298ea:	f3bf 8f5b 	dmb	ish
   298ee:	e853 2f00 	ldrex	r2, [r3]
   298f2:	e843 1000 	strex	r0, r1, [r3]
   298f6:	2800      	cmp	r0, #0
   298f8:	d1f9      	bne.n	298ee <write+0x3a>
   298fa:	f3bf 8f5b 	dmb	ish
	if (atomic_set(&sh_uart->ctrl_blk->tx_busy, 1) == 0) {
   298fe:	b92a      	cbnz	r2, 2990c <write+0x58>
		uart_irq_tx_enable(sh_uart->ctrl_blk->dev);
   29900:	682b      	ldr	r3, [r5, #0]
   29902:	6818      	ldr	r0, [r3, #0]
	if (api->irq_tx_enable) {
   29904:	6843      	ldr	r3, [r0, #4]
   29906:	69db      	ldr	r3, [r3, #28]
   29908:	b103      	cbz	r3, 2990c <write+0x58>
		api->irq_tx_enable(dev);
   2990a:	4798      	blx	r3
}
   2990c:	2000      	movs	r0, #0
   2990e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			uart_poll_out(sh_uart->ctrl_blk->dev, data8[i]);
   29912:	6818      	ldr	r0, [r3, #0]
   29914:	f814 1b01 	ldrb.w	r1, [r4], #1
	api->poll_out(dev, out_char);
   29918:	6843      	ldr	r3, [r0, #4]
   2991a:	685b      	ldr	r3, [r3, #4]
   2991c:	4798      	blx	r3
   2991e:	e7d4      	b.n	298ca <write+0x16>

00029920 <enable>:
{
   29920:	b508      	push	{r3, lr}
	sh_uart->ctrl_blk->blocking_tx = blocking_tx;
   29922:	6843      	ldr	r3, [r0, #4]
   29924:	681b      	ldr	r3, [r3, #0]
   29926:	7419      	strb	r1, [r3, #16]
	if (blocking_tx) {
   29928:	b111      	cbz	r1, 29930 <enable+0x10>
		uart_irq_tx_disable(sh_uart->ctrl_blk->dev);
   2992a:	6818      	ldr	r0, [r3, #0]
   2992c:	f7ff ffb2 	bl	29894 <z_impl_uart_irq_tx_disable>
}
   29930:	2000      	movs	r0, #0
   29932:	bd08      	pop	{r3, pc}

00029934 <shell_raw_fprintf>:
{
   29934:	b40e      	push	{r1, r2, r3}
   29936:	b503      	push	{r0, r1, lr}
   29938:	aa03      	add	r2, sp, #12
   2993a:	f852 1b04 	ldr.w	r1, [r2], #4
	va_start(args, fmt);
   2993e:	9201      	str	r2, [sp, #4]
	shell_fprintf_fmt(ctx, fmt, args);
   29940:	f7e9 f81a 	bl	12978 <shell_fprintf_fmt>
}
   29944:	b002      	add	sp, #8
   29946:	f85d eb04 	ldr.w	lr, [sp], #4
   2994a:	b003      	add	sp, #12
   2994c:	4770      	bx	lr

0002994e <cmd_bacskpace_mode_backspace>:
	flag_mode_delete_set(shell, false);
   2994e:	6883      	ldr	r3, [r0, #8]
	shell->ctx->internal.flags.mode_delete = val ? 1 : 0;
   29950:	f8b3 2258 	ldrh.w	r2, [r3, #600]	; 0x258
   29954:	f36f 1245 	bfc	r2, #5, #1
   29958:	f8a3 2258 	strh.w	r2, [r3, #600]	; 0x258
}
   2995c:	2000      	movs	r0, #0
   2995e:	4770      	bx	lr

00029960 <cmd_bacskpace_mode_delete>:
	flag_mode_delete_set(shell, true);
   29960:	6882      	ldr	r2, [r0, #8]
   29962:	f8b2 3258 	ldrh.w	r3, [r2, #600]	; 0x258
   29966:	f043 0320 	orr.w	r3, r3, #32
   2996a:	f8a2 3258 	strh.w	r3, [r2, #600]	; 0x258
}
   2996e:	2000      	movs	r0, #0
   29970:	4770      	bx	lr

00029972 <cmd_colors_off>:
	flag_use_colors_set(shell, false);
   29972:	6883      	ldr	r3, [r0, #8]
	shell->ctx->internal.flags.use_colors = val ? 1 : 0;
   29974:	f8b3 2258 	ldrh.w	r2, [r3, #600]	; 0x258
   29978:	f36f 0241 	bfc	r2, #1, #1
   2997c:	f8a3 2258 	strh.w	r2, [r3, #600]	; 0x258
}
   29980:	2000      	movs	r0, #0
   29982:	4770      	bx	lr

00029984 <cmd_colors_on>:
	flag_use_colors_set(shell, true);
   29984:	6882      	ldr	r2, [r0, #8]
   29986:	f8b2 3258 	ldrh.w	r3, [r2, #600]	; 0x258
   2998a:	f043 0302 	orr.w	r3, r3, #2
   2998e:	f8a2 3258 	strh.w	r3, [r2, #600]	; 0x258
}
   29992:	2000      	movs	r0, #0
   29994:	4770      	bx	lr

00029996 <cmd_echo_off>:
	flag_echo_set(shell, false);
   29996:	6883      	ldr	r3, [r0, #8]
	shell->ctx->internal.flags.echo = val ? 1 : 0;
   29998:	f8b3 2258 	ldrh.w	r2, [r3, #600]	; 0x258
   2999c:	f36f 0282 	bfc	r2, #2, #1
   299a0:	f8a3 2258 	strh.w	r2, [r3, #600]	; 0x258
}
   299a4:	2000      	movs	r0, #0
   299a6:	4770      	bx	lr

000299a8 <cmd_echo_on>:
	flag_echo_set(shell, true);
   299a8:	6882      	ldr	r2, [r0, #8]
   299aa:	f8b2 3258 	ldrh.w	r3, [r2, #600]	; 0x258
   299ae:	f043 0304 	orr.w	r3, r3, #4
   299b2:	f8a2 3258 	strh.w	r3, [r2, #600]	; 0x258
}
   299b6:	2000      	movs	r0, #0
   299b8:	4770      	bx	lr

000299ba <cmd_shell_stats_reset>:
	shell->stats->log_lost_cnt = 0;
   299ba:	6983      	ldr	r3, [r0, #24]
   299bc:	2000      	movs	r0, #0
   299be:	6018      	str	r0, [r3, #0]
}
   299c0:	4770      	bx	lr

000299c2 <shell_raw_fprintf>:
{
   299c2:	b40e      	push	{r1, r2, r3}
   299c4:	b503      	push	{r0, r1, lr}
   299c6:	aa03      	add	r2, sp, #12
   299c8:	f852 1b04 	ldr.w	r1, [r2], #4
	va_start(args, fmt);
   299cc:	9201      	str	r2, [sp, #4]
	shell_fprintf_fmt(ctx, fmt, args);
   299ce:	f7e8 ffd3 	bl	12978 <shell_fprintf_fmt>
}
   299d2:	b002      	add	sp, #8
   299d4:	f85d eb04 	ldr.w	lr, [sp], #4
   299d8:	b003      	add	sp, #12
   299da:	4770      	bx	lr

000299dc <remove_from_tail.part.4>:
	memcpy(item->data, src, len);
	sys_dlist_prepend(&history->list, &item->dnode);
}

/* Returns true if element was removed. */
static bool remove_from_tail(struct shell_history *history)
   299dc:	b508      	push	{r3, lr}
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   299de:	6883      	ldr	r3, [r0, #8]

	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);

	total_len = offsetof(struct shell_history_item, data) +
			h_item->len + h_item->padding;
	ring_buf_get_finish(history->ring_buf, total_len);
   299e0:	6800      	ldr	r0, [r0, #0]
	node->prev->next = node->next;
   299e2:	e9d3 2100 	ldrd	r2, r1, [r3]
   299e6:	600a      	str	r2, [r1, #0]
	node->next->prev = node->prev;
   299e8:	6051      	str	r1, [r2, #4]
	node->next = NULL;
   299ea:	2200      	movs	r2, #0
	node->prev = NULL;
   299ec:	e9c3 2200 	strd	r2, r2, [r3]
			h_item->len + h_item->padding;
   299f0:	8919      	ldrh	r1, [r3, #8]
   299f2:	895b      	ldrh	r3, [r3, #10]
   299f4:	4419      	add	r1, r3
	ring_buf_get_finish(history->ring_buf, total_len);
   299f6:	310c      	adds	r1, #12
   299f8:	f7fe fc39 	bl	2826e <ring_buf_get_finish>

	return true;
}
   299fc:	2001      	movs	r0, #1
   299fe:	bd08      	pop	{r3, pc}

00029a00 <shell_history_mode_exit>:
	history->current = NULL;
   29a00:	2300      	movs	r3, #0
   29a02:	60c3      	str	r3, [r0, #12]
}
   29a04:	4770      	bx	lr

00029a06 <shell_history_get>:
{
   29a06:	b570      	push	{r4, r5, r6, lr}
   29a08:	4615      	mov	r5, r2
	return list->head == list;
   29a0a:	4602      	mov	r2, r0
   29a0c:	461e      	mov	r6, r3
   29a0e:	f852 4f04 	ldr.w	r4, [r2, #4]!
	if (sys_dlist_is_empty(&history->list)) {
   29a12:	4294      	cmp	r4, r2
   29a14:	d102      	bne.n	29a1c <shell_history_get+0x16>
		*len = 0U;
   29a16:	2000      	movs	r0, #0
   29a18:	8030      	strh	r0, [r6, #0]
}
   29a1a:	bd70      	pop	{r4, r5, r6, pc}
	if (!up) { /* button down */
   29a1c:	68c2      	ldr	r2, [r0, #12]
   29a1e:	b9b1      	cbnz	r1, 29a4e <shell_history_get+0x48>
		if (history->current == NULL) {
   29a20:	2a00      	cmp	r2, #0
   29a22:	d0f8      	beq.n	29a16 <shell_history_get+0x10>
	return (node == list->head) ? NULL : node->prev;
   29a24:	4294      	cmp	r4, r2
   29a26:	d102      	bne.n	29a2e <shell_history_get+0x28>
	history->current = l_item;
   29a28:	2300      	movs	r3, #0
   29a2a:	60c3      	str	r3, [r0, #12]
	if (l_item) {
   29a2c:	e7f3      	b.n	29a16 <shell_history_get+0x10>
   29a2e:	6854      	ldr	r4, [r2, #4]
	history->current = l_item;
   29a30:	60c4      	str	r4, [r0, #12]
	if (l_item) {
   29a32:	2c00      	cmp	r4, #0
   29a34:	d0ef      	beq.n	29a16 <shell_history_get+0x10>
		memcpy(dst, h_item->data, h_item->len);
   29a36:	8922      	ldrh	r2, [r4, #8]
   29a38:	f104 010c 	add.w	r1, r4, #12
   29a3c:	4628      	mov	r0, r5
   29a3e:	f000 fd06 	bl	2a44e <memcpy>
		*len = h_item->len;
   29a42:	8922      	ldrh	r2, [r4, #8]
   29a44:	8032      	strh	r2, [r6, #0]
		dst[*len] = '\0';
   29a46:	2300      	movs	r3, #0
   29a48:	54ab      	strb	r3, [r5, r2]
		return true;
   29a4a:	2001      	movs	r0, #1
   29a4c:	e7e5      	b.n	29a1a <shell_history_get+0x14>
		sys_dlist_peek_head_not_empty(&history->list) :
   29a4e:	2a00      	cmp	r2, #0
   29a50:	d0ee      	beq.n	29a30 <shell_history_get+0x2a>
	return (node == list->tail) ? NULL : node->next;
   29a52:	6883      	ldr	r3, [r0, #8]
   29a54:	4293      	cmp	r3, r2
   29a56:	d0e7      	beq.n	29a28 <shell_history_get+0x22>
   29a58:	6814      	ldr	r4, [r2, #0]
   29a5a:	e7e9      	b.n	29a30 <shell_history_get+0x2a>

00029a5c <shell_history_purge>:

void shell_history_purge(struct shell_history *history)
{
   29a5c:	b538      	push	{r3, r4, r5, lr}
   29a5e:	4604      	mov	r4, r0
	if (sys_dlist_is_empty(&history->list)) {
   29a60:	1d05      	adds	r5, r0, #4
   29a62:	6863      	ldr	r3, [r4, #4]
   29a64:	42ab      	cmp	r3, r5
   29a66:	d004      	beq.n	29a72 <shell_history_purge+0x16>
   29a68:	4620      	mov	r0, r4
   29a6a:	f7ff ffb7 	bl	299dc <remove_from_tail.part.4>
	while (remove_from_tail(history)) {
   29a6e:	2800      	cmp	r0, #0
   29a70:	d1f7      	bne.n	29a62 <shell_history_purge+0x6>
	}
}
   29a72:	bd38      	pop	{r3, r4, r5, pc}

00029a74 <shell_history_put>:
	u16_t padding = (~total_len + 1) & (sizeof(void *) - 1);

	/* align to word. */
	total_len += padding;

	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
   29a74:	6803      	ldr	r3, [r0, #0]
{
   29a76:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	u32_t total_len = len + offsetof(struct shell_history_item, data);
   29a7a:	f102 050c 	add.w	r5, r2, #12
	u16_t padding = (~total_len + 1) & (sizeof(void *) - 1);
   29a7e:	426f      	negs	r7, r5
 * @return Ring buffer capacity (in 32-bit words or bytes).
 */
static inline u32_t ring_buf_capacity_get(struct ring_buf *buf)
{
	/* One element is used to distinguish between empty and full state. */
	return buf->size - 1;
   29a80:	691b      	ldr	r3, [r3, #16]
   29a82:	f007 0703 	and.w	r7, r7, #3
	total_len += padding;
   29a86:	443d      	add	r5, r7
   29a88:	3b01      	subs	r3, #1
	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
   29a8a:	429d      	cmp	r5, r3
{
   29a8c:	4604      	mov	r4, r0
   29a8e:	468a      	mov	sl, r1
   29a90:	4690      	mov	r8, r2
	if (total_len > ring_buf_capacity_get(history->ring_buf)) {
   29a92:	d840      	bhi.n	29b16 <shell_history_put+0xa2>
	history->current = NULL;
   29a94:	2300      	movs	r3, #0
   29a96:	60c3      	str	r3, [r0, #12]
		return;
	}

	shell_history_mode_exit(history);

	if (len == 0) {
   29a98:	2a00      	cmp	r2, #0
   29a9a:	d03c      	beq.n	29b16 <shell_history_put+0xa2>
		return;
	}

	l_item = sys_dlist_peek_head(&history->list);
   29a9c:	f100 0904 	add.w	r9, r0, #4
	return list->head == list;
   29aa0:	6840      	ldr	r0, [r0, #4]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   29aa2:	4581      	cmp	r9, r0
   29aa4:	d12c      	bne.n	29b00 <shell_history_put+0x8c>
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
   29aa6:	9301      	str	r3, [sp, #4]
			add_to_head(history, h_item, line, len, padding);
			ring_buf_put_finish(history->ring_buf, claim_len);
			break;
		}

		ring_buf_put_finish(history->ring_buf, 0);
   29aa8:	f04f 0b00 	mov.w	fp, #0
		claim_len = ring_buf_put_claim(history->ring_buf,
   29aac:	462a      	mov	r2, r5
   29aae:	a901      	add	r1, sp, #4
   29ab0:	6820      	ldr	r0, [r4, #0]
   29ab2:	f7fe fb6d 	bl	28190 <ring_buf_put_claim>
		if (claim_len < total_len) {
   29ab6:	4285      	cmp	r5, r0
		claim_len = ring_buf_put_claim(history->ring_buf,
   29ab8:	4606      	mov	r6, r0
		if (claim_len < total_len) {
   29aba:	d92f      	bls.n	29b1c <shell_history_put+0xa8>
				ring_buf_put_claim(history->ring_buf,
   29abc:	462a      	mov	r2, r5
   29abe:	a901      	add	r1, sp, #4
   29ac0:	6820      	ldr	r0, [r4, #0]
   29ac2:	f7fe fb65 	bl	28190 <ring_buf_put_claim>
			if (claim2_len == total_len) {
   29ac6:	4285      	cmp	r5, r0
   29ac8:	d129      	bne.n	29b1e <shell_history_put+0xaa>
				ring_buf_put_finish(history->ring_buf,
   29aca:	4631      	mov	r1, r6
   29acc:	6820      	ldr	r0, [r4, #0]
   29ace:	f7fe fb7b 	bl	281c8 <ring_buf_put_finish>
				padding += claim_len;
   29ad2:	4437      	add	r7, r6
   29ad4:	b2bf      	uxth	r7, r7
   29ad6:	462e      	mov	r6, r5
			add_to_head(history, h_item, line, len, padding);
   29ad8:	9d01      	ldr	r5, [sp, #4]
	memcpy(item->data, src, len);
   29ada:	4651      	mov	r1, sl
	item->len = len;
   29adc:	f8a5 8008 	strh.w	r8, [r5, #8]
	item->padding = padding;
   29ae0:	816f      	strh	r7, [r5, #10]
	memcpy(item->data, src, len);
   29ae2:	4642      	mov	r2, r8
   29ae4:	f105 000c 	add.w	r0, r5, #12
   29ae8:	f000 fcb1 	bl	2a44e <memcpy>
	node->next = list->head;
   29aec:	6863      	ldr	r3, [r4, #4]
			ring_buf_put_finish(history->ring_buf, claim_len);
   29aee:	6820      	ldr	r0, [r4, #0]
	node->prev = list;
   29af0:	e9c5 3900 	strd	r3, r9, [r5]
   29af4:	4631      	mov	r1, r6
	list->head->prev = node;
   29af6:	605d      	str	r5, [r3, #4]
	list->head = node;
   29af8:	6065      	str	r5, [r4, #4]
   29afa:	f7fe fb65 	bl	281c8 <ring_buf_put_finish>
			break;
   29afe:	e00a      	b.n	29b16 <shell_history_put+0xa2>
	h_item = CONTAINER_OF(l_item, struct shell_history_item, dnode);
   29b00:	9001      	str	r0, [sp, #4]
	if (l_item &&
   29b02:	2800      	cmp	r0, #0
   29b04:	d0d0      	beq.n	29aa8 <shell_history_put+0x34>
	   (h_item->len == len) &&
   29b06:	8903      	ldrh	r3, [r0, #8]
	if (l_item &&
   29b08:	4293      	cmp	r3, r2
   29b0a:	d1cd      	bne.n	29aa8 <shell_history_put+0x34>
	   (memcmp(h_item->data, line, len) == 0)) {
   29b0c:	300c      	adds	r0, #12
   29b0e:	f000 fc77 	bl	2a400 <memcmp>
	   (h_item->len == len) &&
   29b12:	2800      	cmp	r0, #0
   29b14:	d1c8      	bne.n	29aa8 <shell_history_put+0x34>
			 * of ring buffer capacity length.
			 */
			ring_buf_reset(history->ring_buf);
		}
	} while (1);
}
   29b16:	b003      	add	sp, #12
   29b18:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (claim_len == total_len) {
   29b1c:	d0dc      	beq.n	29ad8 <shell_history_put+0x64>
		ring_buf_put_finish(history->ring_buf, 0);
   29b1e:	2100      	movs	r1, #0
   29b20:	6820      	ldr	r0, [r4, #0]
   29b22:	f7fe fb51 	bl	281c8 <ring_buf_put_finish>
	if (sys_dlist_is_empty(&history->list)) {
   29b26:	6863      	ldr	r3, [r4, #4]
   29b28:	4599      	cmp	r9, r3
   29b2a:	d108      	bne.n	29b3e <shell_history_put+0xca>
			ring_buf_reset(history->ring_buf);
   29b2c:	6820      	ldr	r0, [r4, #0]
	memset(&buf->misc, 0, sizeof(buf->misc));
   29b2e:	2208      	movs	r2, #8
	buf->tail = 0;
   29b30:	e9c0 bb00 	strd	fp, fp, [r0]
	memset(&buf->misc, 0, sizeof(buf->misc));
   29b34:	2100      	movs	r1, #0
   29b36:	4410      	add	r0, r2
   29b38:	f000 fcb3 	bl	2a4a2 <memset>
   29b3c:	e7b6      	b.n	29aac <shell_history_put+0x38>
   29b3e:	4620      	mov	r0, r4
   29b40:	f7ff ff4c 	bl	299dc <remove_from_tail.part.4>
		if (remove_from_tail(history) == false) {
   29b44:	2800      	cmp	r0, #0
   29b46:	d1b1      	bne.n	29aac <shell_history_put+0x38>
   29b48:	e7f0      	b.n	29b2c <shell_history_put+0xb8>

00029b4a <shell_history_init>:

void shell_history_init(struct shell_history *history)
{
	sys_dlist_init(&history->list);
   29b4a:	1d03      	adds	r3, r0, #4
	list->tail = (sys_dnode_t *)list;
   29b4c:	e9c0 3301 	strd	r3, r3, [r0, #4]
	history->current = NULL;
   29b50:	2300      	movs	r3, #0
   29b52:	60c3      	str	r3, [r0, #12]
}
   29b54:	4770      	bx	lr

00029b56 <dropped>:
	}
}

static void dropped(const struct log_backend *const backend, u32_t cnt)
{
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
   29b56:	6843      	ldr	r3, [r0, #4]
   29b58:	681b      	ldr	r3, [r3, #0]
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   29b5a:	e9d3 3206 	ldrd	r3, r2, [r3, #24]
   29b5e:	f3bf 8f5b 	dmb	ish
   29b62:	e853 0f00 	ldrex	r0, [r3]
   29b66:	4408      	add	r0, r1
   29b68:	e843 0c00 	strex	ip, r0, [r3]
   29b6c:	f1bc 0f00 	cmp.w	ip, #0
   29b70:	d1f7      	bne.n	29b62 <dropped+0xc>
   29b72:	f3bf 8f5b 	dmb	ish
   29b76:	68d3      	ldr	r3, [r2, #12]
   29b78:	f3bf 8f5b 	dmb	ish
   29b7c:	e853 2f00 	ldrex	r2, [r3]
   29b80:	440a      	add	r2, r1
   29b82:	e843 2000 	strex	r0, r2, [r3]
   29b86:	2800      	cmp	r0, #0
   29b88:	d1f8      	bne.n	29b7c <dropped+0x26>
   29b8a:	f3bf 8f5b 	dmb	ish
	const struct shell_log_backend *log_backend = shell->log_backend;

	atomic_add(&shell->stats->log_lost_cnt, cnt);
	atomic_add(&log_backend->control_block->dropped_cnt, cnt);
}
   29b8e:	4770      	bx	lr

00029b90 <put>:
{
   29b90:	b5f0      	push	{r4, r5, r6, r7, lr}
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
   29b92:	6843      	ldr	r3, [r0, #4]
   29b94:	681c      	ldr	r4, [r3, #0]
			shell->ctx->internal.flags.use_colors;
   29b96:	68a3      	ldr	r3, [r4, #8]
{
   29b98:	b087      	sub	sp, #28
	log_msg_get(msg);
   29b9a:	4608      	mov	r0, r1
			shell->ctx->internal.flags.use_colors;
   29b9c:	f8d3 6258 	ldr.w	r6, [r3, #600]	; 0x258
{
   29ba0:	460d      	mov	r5, r1
	log_msg_get(msg);
   29ba2:	f7fe ff7b 	bl	28a9c <log_msg_get>
	switch (shell->log_backend->control_block->state) {
   29ba6:	69e3      	ldr	r3, [r4, #28]
   29ba8:	68db      	ldr	r3, [r3, #12]
   29baa:	791b      	ldrb	r3, [r3, #4]
   29bac:	2b01      	cmp	r3, #1
			shell->ctx->internal.flags.use_colors;
   29bae:	f3c6 0640 	ubfx	r6, r6, #1, #1
	switch (shell->log_backend->control_block->state) {
   29bb2:	d005      	beq.n	29bc0 <put+0x30>
   29bb4:	2b03      	cmp	r3, #3
   29bb6:	d03d      	beq.n	29c34 <put+0xa4>
		log_msg_put(msg);
   29bb8:	4628      	mov	r0, r5
   29bba:	f7fe ff9c 	bl	28af6 <log_msg_put>
}
   29bbe:	e037      	b.n	29c30 <put+0xa0>
	struct shell_log_backend_msg t_msg = {
   29bc0:	e9cd 5501 	strd	r5, r5, [sp, #4]
	return z_impl_k_uptime_get();
   29bc4:	f003 fd26 	bl	2d614 <z_impl_k_uptime_get>
	err = k_msgq_put(shell->log_backend->msgq, &t_msg,
   29bc8:	69e3      	ldr	r3, [r4, #28]
	return (u32_t)k_uptime_get();
   29bca:	9003      	str	r0, [sp, #12]
   29bcc:	691a      	ldr	r2, [r3, #16]
   29bce:	6858      	ldr	r0, [r3, #4]
	return z_impl_k_msgq_put(q, data, timeout);
   29bd0:	a902      	add	r1, sp, #8
   29bd2:	f7fc fe4b 	bl	2686c <z_impl_k_msgq_put>
	switch (err) {
   29bd6:	f110 0f50 	cmn.w	r0, #80	; 0x50
   29bda:	d001      	beq.n	29be0 <put+0x50>
   29bdc:	300b      	adds	r0, #11
   29bde:	d121      	bne.n	29c24 <put+0x94>
	struct k_msgq *msgq = shell->log_backend->msgq;
   29be0:	69e3      	ldr	r3, [r4, #28]
   29be2:	685d      	ldr	r5, [r3, #4]
	u32_t timeout = shell->log_backend->timeout;
   29be4:	691e      	ldr	r6, [r3, #16]
	return z_impl_k_uptime_get();
   29be6:	f003 fd15 	bl	2d614 <z_impl_k_uptime_get>
   29bea:	4607      	mov	r7, r0
	return z_impl_k_msgq_peek(q, data);
   29bec:	a904      	add	r1, sp, #16
   29bee:	4628      	mov	r0, r5
   29bf0:	f003 fa02 	bl	2cff8 <z_impl_k_msgq_peek>
		if (err == 0 && ((now - msg.timestamp) > timeout)) {
   29bf4:	4602      	mov	r2, r0
   29bf6:	b978      	cbnz	r0, 29c18 <put+0x88>
   29bf8:	9b05      	ldr	r3, [sp, #20]
   29bfa:	1afb      	subs	r3, r7, r3
   29bfc:	429e      	cmp	r6, r3
   29bfe:	d20b      	bcs.n	29c18 <put+0x88>
	return z_impl_k_msgq_get(q, data, timeout);
   29c00:	a904      	add	r1, sp, #16
   29c02:	4628      	mov	r0, r5
   29c04:	f7fc fe84 	bl	26910 <z_impl_k_msgq_get>
			log_msg_put(msg.msg);
   29c08:	9804      	ldr	r0, [sp, #16]
   29c0a:	f7fe ff74 	bl	28af6 <log_msg_put>
				shell->stats->log_lost_cnt++;
   29c0e:	69a2      	ldr	r2, [r4, #24]
   29c10:	6813      	ldr	r3, [r2, #0]
   29c12:	3301      	adds	r3, #1
   29c14:	6013      	str	r3, [r2, #0]
   29c16:	e7e9      	b.n	29bec <put+0x5c>
		err = k_msgq_put(shell->log_backend->msgq, &msg, K_NO_WAIT);
   29c18:	69e3      	ldr	r3, [r4, #28]
   29c1a:	6858      	ldr	r0, [r3, #4]
	return z_impl_k_msgq_put(q, data, timeout);
   29c1c:	2200      	movs	r2, #0
   29c1e:	a901      	add	r1, sp, #4
   29c20:	f7fc fe24 	bl	2686c <z_impl_k_msgq_put>
			signal = &shell->ctx->signals[SHELL_SIGNAL_LOG_MSG];
   29c24:	68a0      	ldr	r0, [r4, #8]
   29c26:	f500 701b 	add.w	r0, r0, #620	; 0x26c
	return z_impl_k_poll_signal_raise(signal, result);
   29c2a:	2100      	movs	r1, #0
   29c2c:	f7fd fe1e 	bl	2786c <z_impl_k_poll_signal_raise>
}
   29c30:	b007      	add	sp, #28
   29c32:	bdf0      	pop	{r4, r5, r6, r7, pc}
		shell_cmd_line_erase(shell);
   29c34:	4620      	mov	r0, r4
   29c36:	f7ff fd49 	bl	296cc <shell_cmd_line_erase>
		msg_process(shell->log_backend->log_output, msg, colors);
   29c3a:	69e3      	ldr	r3, [r4, #28]
		flags |= LOG_OUTPUT_FLAG_COLORS;
   29c3c:	2e00      	cmp	r6, #0
	log_output_msg_process(log_output, msg, flags);
   29c3e:	bf0c      	ite	eq
   29c40:	220e      	moveq	r2, #14
   29c42:	220f      	movne	r2, #15
   29c44:	4629      	mov	r1, r5
   29c46:	6898      	ldr	r0, [r3, #8]
   29c48:	f7e7 fdc4 	bl	117d4 <log_output_msg_process>
	log_msg_put(msg);
   29c4c:	e7b4      	b.n	29bb8 <put+0x28>

00029c4e <shell_log_backend_output_func>:
{
   29c4e:	b510      	push	{r4, lr}
   29c50:	4613      	mov	r3, r2
   29c52:	460c      	mov	r4, r1
	shell_print_stream(ctx, data, length);
   29c54:	460a      	mov	r2, r1
   29c56:	4601      	mov	r1, r0
   29c58:	4618      	mov	r0, r3
   29c5a:	f7ff fd84 	bl	29766 <shell_print_stream>
}
   29c5e:	4620      	mov	r0, r4
   29c60:	bd10      	pop	{r4, pc}

00029c62 <shell_log_backend_enable>:
{
   29c62:	b538      	push	{r3, r4, r5, lr}
   29c64:	4604      	mov	r4, r0
		log_backend_enable(backend->backend, ctx, init_log_level);
   29c66:	6800      	ldr	r0, [r0, #0]
{
   29c68:	460d      	mov	r5, r1
		log_backend_enable(backend->backend, ctx, init_log_level);
   29c6a:	f7e7 f9e7 	bl	1103c <log_backend_enable>
		log_output_ctx_set(backend->log_output, ctx);
   29c6e:	68a3      	ldr	r3, [r4, #8]
   29c70:	685b      	ldr	r3, [r3, #4]
 * @param ctx		User context.
 */
static inline void log_output_ctx_set(const struct log_output *log_output,
				      void *ctx)
{
	log_output->control_block->ctx = ctx;
   29c72:	605d      	str	r5, [r3, #4]
	backend->control_block->dropped_cnt = 0;
   29c74:	68e3      	ldr	r3, [r4, #12]
   29c76:	2200      	movs	r2, #0
   29c78:	601a      	str	r2, [r3, #0]
		backend->control_block->state = SHELL_LOG_BACKEND_ENABLED;
   29c7a:	2201      	movs	r2, #1
   29c7c:	711a      	strb	r2, [r3, #4]
}
   29c7e:	bd38      	pop	{r3, r4, r5, pc}

00029c80 <shell_log_backend_disable>:
{
   29c80:	b513      	push	{r0, r1, r4, lr}
   29c82:	4604      	mov	r4, r0
	while ((msg = msg_from_fifo(backend)) != NULL) {
   29c84:	6860      	ldr	r0, [r4, #4]
	return z_impl_k_msgq_get(q, data, timeout);
   29c86:	2200      	movs	r2, #0
   29c88:	4669      	mov	r1, sp
   29c8a:	f7fc fe41 	bl	26910 <z_impl_k_msgq_get>
	return (err == 0) ? msg.msg : NULL;
   29c8e:	b908      	cbnz	r0, 29c94 <shell_log_backend_disable+0x14>
   29c90:	9800      	ldr	r0, [sp, #0]
	while ((msg = msg_from_fifo(backend)) != NULL) {
   29c92:	b938      	cbnz	r0, 29ca4 <shell_log_backend_disable+0x24>
	log_backend_disable(backend->backend);
   29c94:	6820      	ldr	r0, [r4, #0]
   29c96:	f7fe fe4b 	bl	28930 <log_backend_disable>
	backend->control_block->state = SHELL_LOG_BACKEND_DISABLED;
   29c9a:	68e3      	ldr	r3, [r4, #12]
   29c9c:	2202      	movs	r2, #2
   29c9e:	711a      	strb	r2, [r3, #4]
}
   29ca0:	b002      	add	sp, #8
   29ca2:	bd10      	pop	{r4, pc}
		log_msg_put(msg);
   29ca4:	f7fe ff27 	bl	28af6 <log_msg_put>
   29ca8:	e7ec      	b.n	29c84 <shell_log_backend_disable+0x4>

00029caa <shell_log_backend_process>:
			(const struct shell *)backend->backend->cb->ctx;
   29caa:	6803      	ldr	r3, [r0, #0]
	const struct shell *shell =
   29cac:	685b      	ldr	r3, [r3, #4]
{
   29cae:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	const struct shell *shell =
   29cb2:	681e      	ldr	r6, [r3, #0]
			shell->ctx->internal.flags.use_colors;
   29cb4:	68b3      	ldr	r3, [r6, #8]
   29cb6:	f8d3 5258 	ldr.w	r5, [r3, #600]	; 0x258
{
   29cba:	4607      	mov	r7, r0
			shell->ctx->internal.flags.use_colors;
   29cbc:	f3c5 0540 	ubfx	r5, r5, #1, #1
	struct log_msg *msg = msg_from_fifo(backend);
   29cc0:	6840      	ldr	r0, [r0, #4]
   29cc2:	2200      	movs	r2, #0
   29cc4:	4669      	mov	r1, sp
   29cc6:	f7fc fe23 	bl	26910 <z_impl_k_msgq_get>
	return (err == 0) ? msg.msg : NULL;
   29cca:	b118      	cbz	r0, 29cd4 <shell_log_backend_process+0x2a>
		return false;
   29ccc:	2000      	movs	r0, #0
}
   29cce:	b002      	add	sp, #8
   29cd0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return (err == 0) ? msg.msg : NULL;
   29cd4:	9c00      	ldr	r4, [sp, #0]
	if (!msg) {
   29cd6:	b37c      	cbz	r4, 29d38 <shell_log_backend_process+0x8e>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   29cd8:	68fb      	ldr	r3, [r7, #12]
   29cda:	f3bf 8f5b 	dmb	ish
   29cde:	e853 8f00 	ldrex	r8, [r3]
   29ce2:	e843 0200 	strex	r2, r0, [r3]
   29ce6:	2a00      	cmp	r2, #0
   29ce8:	d1f9      	bne.n	29cde <shell_log_backend_process+0x34>
   29cea:	f3bf 8f5b 	dmb	ish
	if (dropped) {
   29cee:	f1b8 0f00 	cmp.w	r8, #0
   29cf2:	d013      	beq.n	29d1c <shell_log_backend_process+0x72>
		if (colors) {
   29cf4:	b14d      	cbz	r5, 29d0a <shell_log_backend_process+0x60>
	memcpy(color, &shell->ctx->vt100_ctx.col, sizeof(*color));
   29cf6:	68b1      	ldr	r1, [r6, #8]
   29cf8:	2202      	movs	r2, #2
   29cfa:	312e      	adds	r1, #46	; 0x2e
   29cfc:	4668      	mov	r0, sp
   29cfe:	f000 fba6 	bl	2a44e <memcpy>
			shell_vt100_color_set(shell, SHELL_VT100_COLOR_RED);
   29d02:	2102      	movs	r1, #2
   29d04:	4630      	mov	r0, r6
   29d06:	f7e8 fee3 	bl	12ad0 <shell_vt100_color_set>
		log_output_dropped_process(backend->log_output, dropped);
   29d0a:	4641      	mov	r1, r8
   29d0c:	68b8      	ldr	r0, [r7, #8]
   29d0e:	f7e7 fdd7 	bl	118c0 <log_output_dropped_process>
		if (colors) {
   29d12:	b11d      	cbz	r5, 29d1c <shell_log_backend_process+0x72>
			shell_vt100_colors_restore(shell, &col);
   29d14:	4669      	mov	r1, sp
   29d16:	4630      	mov	r0, r6
   29d18:	f7e8 fefe 	bl	12b18 <shell_vt100_colors_restore>
	msg_process(shell->log_backend->log_output, msg, colors);
   29d1c:	69f3      	ldr	r3, [r6, #28]
		flags |= LOG_OUTPUT_FLAG_COLORS;
   29d1e:	2d00      	cmp	r5, #0
	log_output_msg_process(log_output, msg, flags);
   29d20:	6898      	ldr	r0, [r3, #8]
   29d22:	bf0c      	ite	eq
   29d24:	220e      	moveq	r2, #14
   29d26:	220f      	movne	r2, #15
   29d28:	4621      	mov	r1, r4
   29d2a:	f7e7 fd53 	bl	117d4 <log_output_msg_process>
	log_msg_put(msg);
   29d2e:	4620      	mov	r0, r4
   29d30:	f7fe fee1 	bl	28af6 <log_msg_put>
	return true;
   29d34:	2001      	movs	r0, #1
   29d36:	e7ca      	b.n	29cce <shell_log_backend_process+0x24>
		return false;
   29d38:	4620      	mov	r0, r4
   29d3a:	e7c8      	b.n	29cce <shell_log_backend_process+0x24>

00029d3c <panic>:
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
   29d3c:	6843      	ldr	r3, [r0, #4]
{
   29d3e:	b510      	push	{r4, lr}
	const struct shell *shell = (const struct shell *)backend->cb->ctx;
   29d40:	681c      	ldr	r4, [r3, #0]
	err = shell->iface->api->enable(shell->iface, true);
   29d42:	6860      	ldr	r0, [r4, #4]
   29d44:	6803      	ldr	r3, [r0, #0]
   29d46:	2101      	movs	r1, #1
   29d48:	689b      	ldr	r3, [r3, #8]
   29d4a:	4798      	blx	r3
	if (err == 0) {
   29d4c:	b9d0      	cbnz	r0, 29d84 <panic+0x48>
		shell->log_backend->control_block->state =
   29d4e:	69e3      	ldr	r3, [r4, #28]
		shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
   29d50:	68a0      	ldr	r0, [r4, #8]
		shell->log_backend->control_block->state =
   29d52:	68db      	ldr	r3, [r3, #12]
		shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
   29d54:	8e81      	ldrh	r1, [r0, #52]	; 0x34
		shell->log_backend->control_block->state =
   29d56:	2203      	movs	r2, #3
   29d58:	711a      	strb	r2, [r3, #4]
		shell_multiline_data_calc(&shell->ctx->vt100_ctx.cons,
   29d5a:	3020      	adds	r0, #32
   29d5c:	8a42      	ldrh	r2, [r0, #18]
   29d5e:	f7ff fa41 	bl	291e4 <shell_multiline_data_calc>
		shell_op_cursor_vert_move(shell, -1);
   29d62:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   29d66:	4620      	mov	r0, r4
   29d68:	f7e8 fe4c 	bl	12a04 <shell_op_cursor_vert_move>
					   -shell->ctx->vt100_ctx.cons.cur_x);
   29d6c:	68a3      	ldr	r3, [r4, #8]
   29d6e:	8c19      	ldrh	r1, [r3, #32]
		shell_op_cursor_horiz_move(shell,
   29d70:	4620      	mov	r0, r4
   29d72:	4249      	negs	r1, r1
   29d74:	f7e8 fe56 	bl	12a24 <shell_op_cursor_horiz_move>
		while (shell_log_backend_process(shell->log_backend)) {
   29d78:	69e0      	ldr	r0, [r4, #28]
   29d7a:	f7ff ff96 	bl	29caa <shell_log_backend_process>
   29d7e:	2800      	cmp	r0, #0
   29d80:	d1fa      	bne.n	29d78 <panic+0x3c>
}
   29d82:	bd10      	pop	{r4, pc}
		shell_log_backend_disable(shell->log_backend);
   29d84:	69e0      	ldr	r0, [r4, #28]
}
   29d86:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		shell_log_backend_disable(shell->log_backend);
   29d8a:	f7ff bf79 	b.w	29c80 <shell_log_backend_disable>

00029d8e <shell_wildcard_character_exist>:
{
   29d8e:	b510      	push	{r4, lr}
   29d90:	4604      	mov	r4, r0
   29d92:	b908      	cbnz	r0, 29d98 <shell_wildcard_character_exist+0xa>
	return false;
   29d94:	2000      	movs	r0, #0
}
   29d96:	bd10      	pop	{r4, pc}
   29d98:	f000 fb10 	bl	2a3bc <strlen>
	for (size_t i = 0; i < str_len; i++) {
   29d9c:	2300      	movs	r3, #0
   29d9e:	b280      	uxth	r0, r0
   29da0:	4283      	cmp	r3, r0
   29da2:	d2f7      	bcs.n	29d94 <shell_wildcard_character_exist+0x6>
		if ((str[i] == '?') || (str[i] == '*')) {
   29da4:	5ce2      	ldrb	r2, [r4, r3]
   29da6:	2a3f      	cmp	r2, #63	; 0x3f
   29da8:	d003      	beq.n	29db2 <shell_wildcard_character_exist+0x24>
   29daa:	2a2a      	cmp	r2, #42	; 0x2a
   29dac:	d001      	beq.n	29db2 <shell_wildcard_character_exist+0x24>
	for (size_t i = 0; i < str_len; i++) {
   29dae:	3301      	adds	r3, #1
   29db0:	e7f6      	b.n	29da0 <shell_wildcard_character_exist+0x12>
			return true;
   29db2:	2001      	movs	r0, #1
   29db4:	e7ef      	b.n	29d96 <shell_wildcard_character_exist+0x8>

00029db6 <shell_wildcard_prepare>:
{
   29db6:	b510      	push	{r4, lr}
   29db8:	4604      	mov	r4, r0
	memset(shell->ctx->temp_buff, 0, sizeof(shell->ctx->temp_buff));
   29dba:	6880      	ldr	r0, [r0, #8]
   29dbc:	f44f 7280 	mov.w	r2, #256	; 0x100
   29dc0:	2100      	movs	r1, #0
   29dc2:	f500 709c 	add.w	r0, r0, #312	; 0x138
   29dc6:	f000 fb6c 	bl	2a4a2 <memset>
	memcpy(shell->ctx->temp_buff,
   29dca:	68a0      	ldr	r0, [r4, #8]
   29dcc:	8e42      	ldrh	r2, [r0, #50]	; 0x32
   29dce:	f100 0138 	add.w	r1, r0, #56	; 0x38
   29dd2:	f500 709c 	add.w	r0, r0, #312	; 0x138
   29dd6:	f000 fb3a 	bl	2a44e <memcpy>
	shell_spaces_trim(shell->ctx->temp_buff);
   29dda:	68a0      	ldr	r0, [r4, #8]
   29ddc:	f500 709c 	add.w	r0, r0, #312	; 0x138
   29de0:	f7ff fb4d 	bl	2947e <shell_spaces_trim>
	shell->ctx->cmd_tmp_buff_len = shell_strlen(shell->ctx->temp_buff) + 1;
   29de4:	68a0      	ldr	r0, [r4, #8]
   29de6:	f510 709c 	adds.w	r0, r0, #312	; 0x138
   29dea:	d002      	beq.n	29df2 <shell_wildcard_prepare+0x3c>
   29dec:	f000 fae6 	bl	2a3bc <strlen>
   29df0:	b280      	uxth	r0, r0
   29df2:	68a3      	ldr	r3, [r4, #8]
   29df4:	3001      	adds	r0, #1
   29df6:	86d8      	strh	r0, [r3, #54]	; 0x36
}
   29df8:	bd10      	pop	{r4, pc}

00029dfa <shell_wildcard_finalize>:

void shell_wildcard_finalize(const struct shell *shell)
{
   29dfa:	b510      	push	{r4, lr}
   29dfc:	4604      	mov	r4, r0
	memcpy(shell->ctx->cmd_buff,
   29dfe:	6880      	ldr	r0, [r0, #8]
   29e00:	8ec2      	ldrh	r2, [r0, #54]	; 0x36
   29e02:	f500 719c 	add.w	r1, r0, #312	; 0x138
   29e06:	3038      	adds	r0, #56	; 0x38
   29e08:	f000 fb21 	bl	2a44e <memcpy>
	       shell->ctx->temp_buff,
	       shell->ctx->cmd_tmp_buff_len);
	shell->ctx->cmd_buff_len = shell->ctx->cmd_tmp_buff_len;
   29e0c:	68a3      	ldr	r3, [r4, #8]
   29e0e:	8eda      	ldrh	r2, [r3, #54]	; 0x36
   29e10:	865a      	strh	r2, [r3, #50]	; 0x32
}
   29e12:	bd10      	pop	{r4, pc}

00029e14 <boot_write_trailer_byte>:
{
   29e14:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   29e16:	460d      	mov	r5, r1
   29e18:	4617      	mov	r7, r2
   29e1a:	4604      	mov	r4, r0
	align = flash_area_align(fa);
   29e1c:	f000 f926 	bl	2a06c <flash_area_align>
	memset(buf, erased_val, BOOT_MAX_ALIGN);
   29e20:	2208      	movs	r2, #8
	align = flash_area_align(fa);
   29e22:	4606      	mov	r6, r0
	memset(buf, erased_val, BOOT_MAX_ALIGN);
   29e24:	21ff      	movs	r1, #255	; 0xff
   29e26:	4668      	mov	r0, sp
   29e28:	f000 fb3b 	bl	2a4a2 <memset>
	rc = flash_area_write(fa, off, buf, align);
   29e2c:	4633      	mov	r3, r6
   29e2e:	466a      	mov	r2, sp
   29e30:	4629      	mov	r1, r5
   29e32:	4620      	mov	r0, r4
	buf[0] = val;
   29e34:	f88d 7000 	strb.w	r7, [sp]
	rc = flash_area_write(fa, off, buf, align);
   29e38:	f000 f8c9 	bl	29fce <flash_area_write>
	if (rc != 0) {
   29e3c:	2800      	cmp	r0, #0
}
   29e3e:	bf18      	it	ne
   29e40:	f06f 0004 	mvnne.w	r0, #4
   29e44:	b003      	add	sp, #12
   29e46:	bdf0      	pop	{r4, r5, r6, r7, pc}

00029e48 <boot_flag_read.constprop.5>:
static int boot_flag_read(int flag, u8_t bank_id)
   29e48:	b507      	push	{r0, r1, r2, lr}
	rc = flash_area_open(bank_id, &fa);
   29e4a:	2001      	movs	r0, #1
   29e4c:	a901      	add	r1, sp, #4
   29e4e:	f7e9 fc5b 	bl	13708 <flash_area_open>
	if (rc) {
   29e52:	b950      	cbnz	r0, 29e6a <boot_flag_read.constprop.5+0x22>
	rc = boot_flag_offs(flag, fa, &offs);
   29e54:	9801      	ldr	r0, [sp, #4]
		*offs = IMAGE_OK_OFFS(fa);
   29e56:	6881      	ldr	r1, [r0, #8]
	rc = flash_area_read(fa, offs, &flag_val, sizeof(flag_val));
   29e58:	2301      	movs	r3, #1
   29e5a:	f10d 0203 	add.w	r2, sp, #3
   29e5e:	3918      	subs	r1, #24
   29e60:	f000 f898 	bl	29f94 <flash_area_read>
	if (rc != 0) {
   29e64:	b908      	cbnz	r0, 29e6a <boot_flag_read.constprop.5+0x22>
	return flag_val;
   29e66:	f89d 0003 	ldrb.w	r0, [sp, #3]
}
   29e6a:	b003      	add	sp, #12
   29e6c:	f85d fb04 	ldr.w	pc, [sp], #4

00029e70 <boot_flag_write.constprop.6>:
static int boot_flag_write(int flag, u8_t bank_id)
   29e70:	b513      	push	{r0, r1, r4, lr}
	rc = flash_area_open(bank_id, &fa);
   29e72:	a901      	add	r1, sp, #4
   29e74:	f7e9 fc48 	bl	13708 <flash_area_open>
	if (rc) {
   29e78:	4604      	mov	r4, r0
   29e7a:	b948      	cbnz	r0, 29e90 <boot_flag_write.constprop.6+0x20>
	rc = boot_flag_offs(flag, fa, &offs);
   29e7c:	9801      	ldr	r0, [sp, #4]
		*offs = IMAGE_OK_OFFS(fa);
   29e7e:	6881      	ldr	r1, [r0, #8]
	rc = boot_write_trailer_byte(fa, offs, BOOT_FLAG_SET);
   29e80:	2201      	movs	r2, #1
   29e82:	3918      	subs	r1, #24
   29e84:	f7ff ffc6 	bl	29e14 <boot_write_trailer_byte>
   29e88:	4604      	mov	r4, r0
	flash_area_close(fa);
   29e8a:	9801      	ldr	r0, [sp, #4]
   29e8c:	f000 f881 	bl	29f92 <flash_area_close>
}
   29e90:	4620      	mov	r0, r4
   29e92:	b002      	add	sp, #8
   29e94:	bd10      	pop	{r4, pc}

00029e96 <boot_is_img_confirmed>:

bool boot_is_img_confirmed(void)
{
   29e96:	b508      	push	{r3, lr}
	return boot_flag_read(BOOT_FLAG_IMAGE_OK, bank_id);
   29e98:	f7ff ffd6 	bl	29e48 <boot_flag_read.constprop.5>
	return boot_image_ok_read(FLASH_AREA_IMAGE_PRIMARY) == BOOT_FLAG_SET;
}
   29e9c:	1e43      	subs	r3, r0, #1
   29e9e:	4258      	negs	r0, r3
   29ea0:	4158      	adcs	r0, r3
   29ea2:	bd08      	pop	{r3, pc}

00029ea4 <boot_write_img_confirmed>:

int boot_write_img_confirmed(void)
{
   29ea4:	b513      	push	{r0, r1, r4, lr}
	return boot_flag_read(BOOT_FLAG_IMAGE_OK, bank_id);
   29ea6:	f7ff ffcf 	bl	29e48 <boot_flag_read.constprop.5>
	rc = flash_area_open(bank_id, &fa);
   29eaa:	a901      	add	r1, sp, #4
	return boot_flag_read(BOOT_FLAG_IMAGE_OK, bank_id);
   29eac:	4604      	mov	r4, r0
	rc = flash_area_open(bank_id, &fa);
   29eae:	2001      	movs	r0, #1
   29eb0:	f7e9 fc2a 	bl	13708 <flash_area_open>
	if (rc) {
   29eb4:	2800      	cmp	r0, #0
		return -EINVAL;
   29eb6:	bf0c      	ite	eq
   29eb8:	23ff      	moveq	r3, #255	; 0xff
   29eba:	f06f 0315 	mvnne.w	r3, #21
	int rc;

	if (boot_image_ok_read(FLASH_AREA_IMAGE_PRIMARY) !=
   29ebe:	42a3      	cmp	r3, r4
   29ec0:	d104      	bne.n	29ecc <boot_write_img_confirmed+0x28>
	return boot_flag_write(BOOT_FLAG_IMAGE_OK, bank_id);
   29ec2:	2001      	movs	r0, #1
   29ec4:	f7ff ffd4 	bl	29e70 <boot_flag_write.constprop.6>
	}

	rc = boot_image_ok_write(FLASH_AREA_IMAGE_PRIMARY);

	return rc;
}
   29ec8:	b002      	add	sp, #8
   29eca:	bd10      	pop	{r4, pc}
		return 0;
   29ecc:	2000      	movs	r0, #0
   29ece:	e7fb      	b.n	29ec8 <boot_write_img_confirmed+0x24>

00029ed0 <flash_img_buffered_write>:

int flash_img_buffered_write(struct flash_img_context *ctx, u8_t *data,
			     size_t len, bool flush)
{
   29ed0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   29ed4:	4604      	mov	r4, r0
   29ed6:	4689      	mov	r9, r1
   29ed8:	4616      	mov	r6, r2
   29eda:	4698      	mov	r8, r3
	int processed = 0;
   29edc:	2700      	movs	r7, #0
	while ((len - processed) >=
	       (buf_empty_bytes = CONFIG_IMG_BLOCK_BUF_SIZE - ctx->buf_bytes)) {
		memcpy(ctx->buf + ctx->buf_bytes, data + processed,
		       buf_empty_bytes);

		ctx->buf_bytes = CONFIG_IMG_BLOCK_BUF_SIZE;
   29ede:	f44f 7a00 	mov.w	sl, #512	; 0x200
	       (buf_empty_bytes = CONFIG_IMG_BLOCK_BUF_SIZE - ctx->buf_bytes)) {
   29ee2:	f8b4 0208 	ldrh.w	r0, [r4, #520]	; 0x208
	while ((len - processed) >=
   29ee6:	1bf2      	subs	r2, r6, r7
	       (buf_empty_bytes = CONFIG_IMG_BLOCK_BUF_SIZE - ctx->buf_bytes)) {
   29ee8:	f5c0 7b00 	rsb	fp, r0, #512	; 0x200
	while ((len - processed) >=
   29eec:	455a      	cmp	r2, fp
   29eee:	d222      	bcs.n	29f36 <flash_img_buffered_write+0x66>

		processed += buf_empty_bytes;
	}

	/* place rest of the data into ctx->buf */
	if (processed < len) {
   29ef0:	42b7      	cmp	r7, r6
   29ef2:	d20a      	bcs.n	29f0a <flash_img_buffered_write+0x3a>
		memcpy(ctx->buf + ctx->buf_bytes,
   29ef4:	eb09 0107 	add.w	r1, r9, r7
   29ef8:	4420      	add	r0, r4
   29efa:	f000 faa8 	bl	2a44e <memcpy>
		       data + processed, len - processed);
		ctx->buf_bytes += len - processed;
   29efe:	f8b4 3208 	ldrh.w	r3, [r4, #520]	; 0x208
   29f02:	441e      	add	r6, r3
   29f04:	1bf6      	subs	r6, r6, r7
   29f06:	f8a4 6208 	strh.w	r6, [r4, #520]	; 0x208
	}

	if (!flush) {
   29f0a:	f1b8 0f00 	cmp.w	r8, #0
   29f0e:	d02a      	beq.n	29f66 <flash_img_buffered_write+0x96>
		return rc;
	}

	if (ctx->buf_bytes > 0) {
   29f10:	f8b4 3208 	ldrh.w	r3, [r4, #520]	; 0x208
   29f14:	b9f3      	cbnz	r3, 29f54 <flash_img_buffered_write+0x84>
		}
	}
#ifdef CONFIG_IMG_ERASE_PROGRESSIVELY
	/* erase the image trailer area if it was not erased */
	rc = flash_progressive_erase(ctx,
				BOOT_TRAILER_IMG_STATUS_OFFS(ctx->flash_area));
   29f16:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
   29f1a:	6899      	ldr	r1, [r3, #8]
	rc = flash_progressive_erase(ctx,
   29f1c:	4620      	mov	r0, r4
   29f1e:	3920      	subs	r1, #32
   29f20:	f7e9 fabc 	bl	1349c <flash_progressive_erase>
	if (rc) {
   29f24:	4605      	mov	r5, r0
   29f26:	b9d8      	cbnz	r0, 29f60 <flash_img_buffered_write+0x90>
		return rc;
	}
#endif

	flash_area_close(ctx->flash_area);
   29f28:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
   29f2c:	f000 f831 	bl	29f92 <flash_area_close>
	ctx->flash_area = NULL;
   29f30:	f8c4 5200 	str.w	r5, [r4, #512]	; 0x200

	return rc;
   29f34:	e014      	b.n	29f60 <flash_img_buffered_write+0x90>
		memcpy(ctx->buf + ctx->buf_bytes, data + processed,
   29f36:	465a      	mov	r2, fp
   29f38:	eb09 0107 	add.w	r1, r9, r7
   29f3c:	4420      	add	r0, r4
   29f3e:	f000 fa86 	bl	2a44e <memcpy>
		ctx->buf_bytes = CONFIG_IMG_BLOCK_BUF_SIZE;
   29f42:	f8a4 a208 	strh.w	sl, [r4, #520]	; 0x208
		rc = flash_sync(ctx);
   29f46:	4620      	mov	r0, r4
   29f48:	f7e9 fb16 	bl	13578 <flash_sync>
		if (rc) {
   29f4c:	4605      	mov	r5, r0
   29f4e:	b938      	cbnz	r0, 29f60 <flash_img_buffered_write+0x90>
		processed += buf_empty_bytes;
   29f50:	445f      	add	r7, fp
   29f52:	e7c6      	b.n	29ee2 <flash_img_buffered_write+0x12>
		rc = flash_sync(ctx);
   29f54:	4620      	mov	r0, r4
   29f56:	f7e9 fb0f 	bl	13578 <flash_sync>
		if (rc) {
   29f5a:	4605      	mov	r5, r0
   29f5c:	2800      	cmp	r0, #0
   29f5e:	d0da      	beq.n	29f16 <flash_img_buffered_write+0x46>
}
   29f60:	4628      	mov	r0, r5
   29f62:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   29f66:	4645      	mov	r5, r8
   29f68:	e7fa      	b.n	29f60 <flash_img_buffered_write+0x90>

00029f6a <flash_img_bytes_written>:

size_t flash_img_bytes_written(struct flash_img_context *ctx)
{
	return ctx->bytes_written;
}
   29f6a:	f8d0 0204 	ldr.w	r0, [r0, #516]	; 0x204
   29f6e:	4770      	bx	lr

00029f70 <flash_img_init>:

int flash_img_init(struct flash_img_context *ctx)
{
	ctx->bytes_written = 0;
   29f70:	2300      	movs	r3, #0
   29f72:	f8c0 3204 	str.w	r3, [r0, #516]	; 0x204
	ctx->buf_bytes = 0U;
   29f76:	f8a0 3208 	strh.w	r3, [r0, #520]	; 0x208
#ifdef CONFIG_IMG_ERASE_PROGRESSIVELY
	ctx->off_last = -1;
   29f7a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   29f7e:	f8c0 320c 	str.w	r3, [r0, #524]	; 0x20c
#endif
	return flash_area_open(FLASH_AREA_IMAGE_SECONDARY,
   29f82:	f500 7100 	add.w	r1, r0, #512	; 0x200
   29f86:	2002      	movs	r0, #2
   29f88:	f7e9 bbbe 	b.w	13708 <flash_area_open>

00029f8c <z_impl_flash_write_protection_set>:
static inline int z_impl_flash_write_protection_set(struct device *dev,
						   bool enable)
{
	const struct flash_driver_api *api = dev->driver_api;

	return api->write_protection(dev, enable);
   29f8c:	6843      	ldr	r3, [r0, #4]
   29f8e:	68db      	ldr	r3, [r3, #12]
   29f90:	4718      	bx	r3

00029f92 <flash_area_close>:

void flash_area_close(const struct flash_area *fa)
{
	/* nothing to do for now */
}
   29f92:	4770      	bx	lr

00029f94 <flash_area_read>:
}
#endif /* CONFIG_FLASH_PAGE_LAYOUT */

int flash_area_read(const struct flash_area *fa, off_t off, void *dst,
		    size_t len)
{
   29f94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   29f98:	461e      	mov	r6, r3
	struct device *dev;

	if (!is_in_flash_area_bounds(fa, off, len)) {
   29f9a:	6883      	ldr	r3, [r0, #8]
	return (off <= fa->fa_size && off + len <= fa->fa_size);
   29f9c:	428b      	cmp	r3, r1
{
   29f9e:	4605      	mov	r5, r0
   29fa0:	460c      	mov	r4, r1
   29fa2:	4617      	mov	r7, r2
	return (off <= fa->fa_size && off + len <= fa->fa_size);
   29fa4:	d30f      	bcc.n	29fc6 <flash_area_read+0x32>
   29fa6:	1872      	adds	r2, r6, r1
   29fa8:	4293      	cmp	r3, r2
   29faa:	d30c      	bcc.n	29fc6 <flash_area_read+0x32>
		return -EINVAL;
	}

	dev = device_get_binding(fa->fa_dev_name);
   29fac:	68c0      	ldr	r0, [r0, #12]
   29fae:	f7fc f9a9 	bl	26304 <z_impl_device_get_binding>

	return flash_read(dev, fa->fa_off + off, dst, len);
   29fb2:	6869      	ldr	r1, [r5, #4]
   29fb4:	4421      	add	r1, r4
	return api->read(dev, offset, data, len);
   29fb6:	6843      	ldr	r3, [r0, #4]
   29fb8:	681c      	ldr	r4, [r3, #0]
   29fba:	463a      	mov	r2, r7
   29fbc:	4633      	mov	r3, r6
   29fbe:	46a4      	mov	ip, r4
}
   29fc0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   29fc4:	4760      	bx	ip
   29fc6:	f06f 0015 	mvn.w	r0, #21
   29fca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00029fce <flash_area_write>:

int flash_area_write(const struct flash_area *fa, off_t off, const void *src,
		     size_t len)
{
   29fce:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   29fd2:	4698      	mov	r8, r3
	struct device *flash_dev;
	int rc;

	if (!is_in_flash_area_bounds(fa, off, len)) {
   29fd4:	6883      	ldr	r3, [r0, #8]
	return (off <= fa->fa_size && off + len <= fa->fa_size);
   29fd6:	428b      	cmp	r3, r1
{
   29fd8:	4607      	mov	r7, r0
   29fda:	460d      	mov	r5, r1
   29fdc:	4691      	mov	r9, r2
	return (off <= fa->fa_size && off + len <= fa->fa_size);
   29fde:	d31c      	bcc.n	2a01a <flash_area_write+0x4c>
   29fe0:	eb08 0201 	add.w	r2, r8, r1
   29fe4:	4293      	cmp	r3, r2
   29fe6:	d318      	bcc.n	2a01a <flash_area_write+0x4c>
		return -EINVAL;
	}

	flash_dev = device_get_binding(fa->fa_dev_name);
   29fe8:	68c0      	ldr	r0, [r0, #12]
   29fea:	f7fc f98b 	bl	26304 <z_impl_device_get_binding>
   29fee:	4606      	mov	r6, r0
	return z_impl_flash_write_protection_set(dev, enable);
   29ff0:	2100      	movs	r1, #0
   29ff2:	f7ff ffcb 	bl	29f8c <z_impl_flash_write_protection_set>

	rc = flash_write_protection_set(flash_dev, false);
	if (rc) {
   29ff6:	4604      	mov	r4, r0
   29ff8:	b960      	cbnz	r0, 2a014 <flash_area_write+0x46>
		return rc;
	}

	rc = flash_write(flash_dev, fa->fa_off + off, (void *)src, len);
   29ffa:	6879      	ldr	r1, [r7, #4]
   29ffc:	4429      	add	r1, r5
	return api->write(dev, offset, data, len);
   29ffe:	6873      	ldr	r3, [r6, #4]
   2a000:	464a      	mov	r2, r9
   2a002:	685c      	ldr	r4, [r3, #4]
   2a004:	4630      	mov	r0, r6
   2a006:	4643      	mov	r3, r8
   2a008:	47a0      	blx	r4
   2a00a:	4604      	mov	r4, r0
   2a00c:	2101      	movs	r1, #1
   2a00e:	4630      	mov	r0, r6
   2a010:	f7ff ffbc 	bl	29f8c <z_impl_flash_write_protection_set>

	/* Ignore errors here - this does not affect write operation */
	(void) flash_write_protection_set(flash_dev, true);

	return rc;
}
   2a014:	4620      	mov	r0, r4
   2a016:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return -EINVAL;
   2a01a:	f06f 0415 	mvn.w	r4, #21
   2a01e:	e7f9      	b.n	2a014 <flash_area_write+0x46>

0002a020 <flash_area_erase>:
int flash_area_erase(const struct flash_area *fa, off_t off, size_t len)
{
	struct device *flash_dev;
	int rc;

	if (!is_in_flash_area_bounds(fa, off, len)) {
   2a020:	6883      	ldr	r3, [r0, #8]
	return (off <= fa->fa_size && off + len <= fa->fa_size);
   2a022:	428b      	cmp	r3, r1
{
   2a024:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2a028:	4607      	mov	r7, r0
   2a02a:	460d      	mov	r5, r1
   2a02c:	4690      	mov	r8, r2
	return (off <= fa->fa_size && off + len <= fa->fa_size);
   2a02e:	d31a      	bcc.n	2a066 <flash_area_erase+0x46>
   2a030:	440a      	add	r2, r1
   2a032:	4293      	cmp	r3, r2
   2a034:	d317      	bcc.n	2a066 <flash_area_erase+0x46>
		return -EINVAL;
	}

	flash_dev = device_get_binding(fa->fa_dev_name);
   2a036:	68c0      	ldr	r0, [r0, #12]
   2a038:	f7fc f964 	bl	26304 <z_impl_device_get_binding>
   2a03c:	4606      	mov	r6, r0
   2a03e:	2100      	movs	r1, #0
   2a040:	f7ff ffa4 	bl	29f8c <z_impl_flash_write_protection_set>

	rc = flash_write_protection_set(flash_dev, false);
	if (rc) {
   2a044:	4604      	mov	r4, r0
   2a046:	b958      	cbnz	r0, 2a060 <flash_area_erase+0x40>
		return rc;
	}

	rc = flash_erase(flash_dev, fa->fa_off + off, len);
   2a048:	6879      	ldr	r1, [r7, #4]
   2a04a:	4429      	add	r1, r5
	return api->erase(dev, offset, size);
   2a04c:	6873      	ldr	r3, [r6, #4]
   2a04e:	4642      	mov	r2, r8
   2a050:	689b      	ldr	r3, [r3, #8]
   2a052:	4630      	mov	r0, r6
   2a054:	4798      	blx	r3
   2a056:	4604      	mov	r4, r0
   2a058:	2101      	movs	r1, #1
   2a05a:	4630      	mov	r0, r6
   2a05c:	f7ff ff96 	bl	29f8c <z_impl_flash_write_protection_set>

	/* Ignore errors here - this does not affect write operation */
	(void) flash_write_protection_set(flash_dev, true);

	return rc;
}
   2a060:	4620      	mov	r0, r4
   2a062:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -EINVAL;
   2a066:	f06f 0415 	mvn.w	r4, #21
   2a06a:	e7f9      	b.n	2a060 <flash_area_erase+0x40>

0002a06c <flash_area_align>:

u8_t flash_area_align(const struct flash_area *fa)
{
   2a06c:	b508      	push	{r3, lr}
	struct device *dev;

	dev = device_get_binding(fa->fa_dev_name);
   2a06e:	68c0      	ldr	r0, [r0, #12]
   2a070:	f7fc f948 	bl	26304 <z_impl_device_get_binding>

static inline size_t z_impl_flash_get_write_block_size(struct device *dev)
{
	const struct flash_driver_api *api = dev->driver_api;

	return api->write_block_size;
   2a074:	6843      	ldr	r3, [r0, #4]

	return flash_get_write_block_size(dev);
}
   2a076:	7d18      	ldrb	r0, [r3, #20]
   2a078:	bd08      	pop	{r3, pc}

0002a07a <flash_area_get_device>:
	return 1;
}

struct device *flash_area_get_device(const struct flash_area *fa)
{
	return device_get_binding(fa->fa_dev_name);
   2a07a:	68c0      	ldr	r0, [r0, #12]
   2a07c:	f7fc b942 	b.w	26304 <z_impl_device_get_binding>

0002a080 <get_status>:
	struct nrf_clock_control *data = dev->driver_data;
   2a080:	6883      	ldr	r3, [r0, #8]
	if (data->started) {
   2a082:	7a5a      	ldrb	r2, [r3, #9]
   2a084:	b932      	cbnz	r2, 2a094 <get_status+0x14>
	if (data->ref > 0) {
   2a086:	f993 0008 	ldrsb.w	r0, [r3, #8]
		return CLOCK_CONTROL_STATUS_ON;
   2a08a:	2800      	cmp	r0, #0
   2a08c:	bfcc      	ite	gt
   2a08e:	2000      	movgt	r0, #0
   2a090:	2001      	movle	r0, #1
   2a092:	4770      	bx	lr
   2a094:	2002      	movs	r0, #2
}
   2a096:	4770      	bx	lr

0002a098 <clock_async_start>:
{
   2a098:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	const struct nrf_clock_control_config *config =
   2a09a:	6803      	ldr	r3, [r0, #0]
	struct nrf_clock_control *clk_data = dev->driver_data;
   2a09c:	6885      	ldr	r5, [r0, #8]
	const struct nrf_clock_control_config *config =
   2a09e:	689f      	ldr	r7, [r3, #8]
{
   2a0a0:	4606      	mov	r6, r0
   2a0a2:	4614      	mov	r4, r2
	__asm__ volatile(
   2a0a4:	f04f 0320 	mov.w	r3, #32
   2a0a8:	f3ef 8211 	mrs	r2, BASEPRI
   2a0ac:	f383 8811 	msr	BASEPRI, r3
   2a0b0:	f3bf 8f6f 	isb	sy
	ref = ++clk_data->ref;
   2a0b4:	7a2b      	ldrb	r3, [r5, #8]
   2a0b6:	3301      	adds	r3, #1
   2a0b8:	b25b      	sxtb	r3, r3
   2a0ba:	722b      	strb	r3, [r5, #8]
	__asm__ volatile(
   2a0bc:	f382 8811 	msr	BASEPRI, r2
   2a0c0:	f3bf 8f6f 	isb	sy
	if (clk_data->started) {
   2a0c4:	7a6a      	ldrb	r2, [r5, #9]
   2a0c6:	b132      	cbz	r2, 2a0d6 <clock_async_start+0x3e>
		if (data) {
   2a0c8:	b90c      	cbnz	r4, 2a0ce <clock_async_start+0x36>
	return 0;
   2a0ca:	2000      	movs	r0, #0
}
   2a0cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			data->cb(dev, data->user_data);
   2a0ce:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
   2a0d2:	4798      	blx	r3
   2a0d4:	e7f9      	b.n	2a0ca <clock_async_start+0x32>
		if (ref == 1) {
   2a0d6:	2b01      	cmp	r3, #1
   2a0d8:	d106      	bne.n	2a0e8 <clock_async_start+0x50>
			do_start =  (config->start_handler) ?
   2a0da:	683b      	ldr	r3, [r7, #0]
					config->start_handler(dev) : true;
   2a0dc:	b933      	cbnz	r3, 2a0ec <clock_async_start+0x54>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2a0de:	7abb      	ldrb	r3, [r7, #10]
   2a0e0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   2a0e4:	2201      	movs	r2, #1
   2a0e6:	601a      	str	r2, [r3, #0]
		if (data) {
   2a0e8:	b94c      	cbnz	r4, 2a0fe <clock_async_start+0x66>
   2a0ea:	e7ee      	b.n	2a0ca <clock_async_start+0x32>
					config->start_handler(dev) : true;
   2a0ec:	4798      	blx	r3
   2a0ee:	2800      	cmp	r0, #0
   2a0f0:	d1f5      	bne.n	2a0de <clock_async_start+0x46>
			} else if (data) {
   2a0f2:	2c00      	cmp	r4, #0
   2a0f4:	d0e9      	beq.n	2a0ca <clock_async_start+0x32>
				data->cb(dev, data->user_data);
   2a0f6:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
   2a0fa:	4630      	mov	r0, r6
   2a0fc:	4798      	blx	r3
	sys_snode_t *item = sys_slist_peek_head(list);
   2a0fe:	682b      	ldr	r3, [r5, #0]
		if (item == node) {
   2a100:	429c      	cmp	r4, r3
   2a102:	d00d      	beq.n	2a120 <clock_async_start+0x88>
Z_GENLIST_PEEK_NEXT(slist, snode)
   2a104:	b113      	cbz	r3, 2a10c <clock_async_start+0x74>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   2a106:	681b      	ldr	r3, [r3, #0]
	} while (item);
   2a108:	2b00      	cmp	r3, #0
   2a10a:	d1f9      	bne.n	2a100 <clock_async_start+0x68>
	parent->next = child;
   2a10c:	2000      	movs	r0, #0
   2a10e:	6020      	str	r0, [r4, #0]
Z_GENLIST_APPEND(slist, snode)
   2a110:	686b      	ldr	r3, [r5, #4]
   2a112:	b913      	cbnz	r3, 2a11a <clock_async_start+0x82>
	list->head = node;
   2a114:	e9c5 4400 	strd	r4, r4, [r5]
   2a118:	e7d7      	b.n	2a0ca <clock_async_start+0x32>
	parent->next = child;
   2a11a:	601c      	str	r4, [r3, #0]
	list->tail = node;
   2a11c:	606c      	str	r4, [r5, #4]
   2a11e:	e7d5      	b.n	2a0cc <clock_async_start+0x34>
				return -EALREADY;
   2a120:	f06f 0044 	mvn.w	r0, #68	; 0x44
   2a124:	e7d2      	b.n	2a0cc <clock_async_start+0x34>

0002a126 <clock_start>:
	return clock_async_start(dev, sub_system, NULL);
   2a126:	2200      	movs	r2, #0
   2a128:	f7ff bfb6 	b.w	2a098 <clock_async_start>

0002a12c <lfclk_init>:
	sys_slist_init(&((struct nrf_clock_control *)dev->driver_data)->list);
   2a12c:	6883      	ldr	r3, [r0, #8]
	list->head = NULL;
   2a12e:	2000      	movs	r0, #0
	list->tail = NULL;
   2a130:	e9c3 0000 	strd	r0, r0, [r3]
}
   2a134:	4770      	bx	lr

0002a136 <hfclk_init>:
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
   2a136:	2200      	movs	r2, #0
{
   2a138:	b510      	push	{r4, lr}
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
   2a13a:	2101      	movs	r1, #1
{
   2a13c:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0,
   2a13e:	4610      	mov	r0, r2
   2a140:	f7e9 fcf0 	bl	13b24 <z_arm_irq_priority_set>
	irq_enable(DT_INST_0_NORDIC_NRF_CLOCK_IRQ_0);
   2a144:	2000      	movs	r0, #0
   2a146:	f7e9 fcbb 	bl	13ac0 <arch_irq_enable>
}

NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
{
    p_reg->LFCLKSRC = (uint32_t)(source);
   2a14a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   2a14e:	2201      	movs	r2, #1
   2a150:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    p_reg->INTENSET = mask;
   2a154:	2203      	movs	r2, #3
   2a156:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	sys_slist_init(&((struct nrf_clock_control *)dev->driver_data)->list);
   2a15a:	68a3      	ldr	r3, [r4, #8]
	list->head = NULL;
   2a15c:	2000      	movs	r0, #0
	list->tail = NULL;
   2a15e:	e9c3 0000 	strd	r0, r0, [r3]
}
   2a162:	bd10      	pop	{r4, pc}

0002a164 <clock_stop>:
	const struct nrf_clock_control_config *config =
   2a164:	6802      	ldr	r2, [r0, #0]
{
   2a166:	b573      	push	{r0, r1, r4, r5, r6, lr}
	const struct nrf_clock_control_config *config =
   2a168:	6895      	ldr	r5, [r2, #8]
	struct nrf_clock_control *data = dev->driver_data;
   2a16a:	6884      	ldr	r4, [r0, #8]
	__asm__ volatile(
   2a16c:	f04f 0320 	mov.w	r3, #32
   2a170:	f3ef 8611 	mrs	r6, BASEPRI
   2a174:	f383 8811 	msr	BASEPRI, r3
   2a178:	f3bf 8f6f 	isb	sy
	data->ref--;
   2a17c:	7a23      	ldrb	r3, [r4, #8]
   2a17e:	3b01      	subs	r3, #1
   2a180:	b25b      	sxtb	r3, r3
	if (data->ref == 0) {
   2a182:	2b00      	cmp	r3, #0
	data->ref--;
   2a184:	7223      	strb	r3, [r4, #8]
	if (data->ref == 0) {
   2a186:	d11c      	bne.n	2a1c2 <clock_stop+0x5e>
   2a188:	e9c4 3300 	strd	r3, r3, [r4]
		do_stop =  (config->stop_handler) ?
   2a18c:	686b      	ldr	r3, [r5, #4]
				config->stop_handler(dev) : true;
   2a18e:	b9a3      	cbnz	r3, 2a1ba <clock_stop+0x56>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2a190:	7aeb      	ldrb	r3, [r5, #11]
   2a192:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   2a196:	2201      	movs	r2, #1
   2a198:	601a      	str	r2, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2a19a:	892b      	ldrh	r3, [r5, #8]
   2a19c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   2a1a0:	2200      	movs	r2, #0
   2a1a2:	601a      	str	r2, [r3, #0]
    volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   2a1a4:	681b      	ldr	r3, [r3, #0]
   2a1a6:	9301      	str	r3, [sp, #4]
    (void)dummy;
   2a1a8:	9b01      	ldr	r3, [sp, #4]
		data->started = false;
   2a1aa:	2000      	movs	r0, #0
   2a1ac:	7260      	strb	r0, [r4, #9]
	__asm__ volatile(
   2a1ae:	f386 8811 	msr	BASEPRI, r6
   2a1b2:	f3bf 8f6f 	isb	sy
}
   2a1b6:	b002      	add	sp, #8
   2a1b8:	bd70      	pop	{r4, r5, r6, pc}
				config->stop_handler(dev) : true;
   2a1ba:	4798      	blx	r3
   2a1bc:	2800      	cmp	r0, #0
   2a1be:	d1e7      	bne.n	2a190 <clock_stop+0x2c>
   2a1c0:	e7f3      	b.n	2a1aa <clock_stop+0x46>
	} else if (data->ref < 0) {
   2a1c2:	f04f 0000 	mov.w	r0, #0
		data->ref = 0;
   2a1c6:	bfbc      	itt	lt
   2a1c8:	7220      	strblt	r0, [r4, #8]
		err = -EALREADY;
   2a1ca:	f06f 0044 	mvnlt.w	r0, #68	; 0x44
   2a1ce:	e7ee      	b.n	2a1ae <clock_stop+0x4a>

0002a1d0 <clkstarted_handle>:
{
   2a1d0:	b538      	push	{r3, r4, r5, lr}
	struct nrf_clock_control *data = dev->driver_data;
   2a1d2:	6884      	ldr	r4, [r0, #8]
Z_GENLIST_IS_EMPTY(slist)
   2a1d4:	6823      	ldr	r3, [r4, #0]
{
   2a1d6:	4605      	mov	r5, r0
Z_GENLIST_GET(slist, snode)
   2a1d8:	b12b      	cbz	r3, 2a1e6 <clkstarted_handle+0x16>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2a1da:	6861      	ldr	r1, [r4, #4]
   2a1dc:	681a      	ldr	r2, [r3, #0]
	list->head = node;
   2a1de:	6022      	str	r2, [r4, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2a1e0:	428b      	cmp	r3, r1
	list->tail = node;
   2a1e2:	bf08      	it	eq
   2a1e4:	6062      	streq	r2, [r4, #4]
	data->started = true;
   2a1e6:	2201      	movs	r2, #1
   2a1e8:	7262      	strb	r2, [r4, #9]
	while (node != NULL) {
   2a1ea:	b903      	cbnz	r3, 2a1ee <clkstarted_handle+0x1e>
}
   2a1ec:	bd38      	pop	{r3, r4, r5, pc}
		async_data->cb(dev, async_data->user_data);
   2a1ee:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
   2a1f2:	4628      	mov	r0, r5
   2a1f4:	4790      	blx	r2
Z_GENLIST_IS_EMPTY(slist)
   2a1f6:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_GET(slist, snode)
   2a1f8:	2b00      	cmp	r3, #0
   2a1fa:	d0f7      	beq.n	2a1ec <clkstarted_handle+0x1c>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2a1fc:	6861      	ldr	r1, [r4, #4]
   2a1fe:	681a      	ldr	r2, [r3, #0]
	list->head = node;
   2a200:	6022      	str	r2, [r4, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2a202:	428b      	cmp	r3, r1
	list->tail = node;
   2a204:	bf08      	it	eq
   2a206:	6062      	streq	r2, [r4, #4]
   2a208:	e7ef      	b.n	2a1ea <clkstarted_handle+0x1a>

0002a20a <z_clock_isr>:
/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
	__ASSERT_NO_MSG(false);
}
   2a20a:	4770      	bx	lr

0002a20c <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
   2a20c:	4770      	bx	lr

0002a20e <sys_clock_disable>:
   2a20e:	4770      	bx	lr

0002a210 <z_irq_spurious>:
	z_arm_reserved();
   2a210:	f7e9 bcfa 	b.w	13c08 <z_arm_bus_fault>

0002a214 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   2a214:	4601      	mov	r1, r0
			reason = K_ERR_KERNEL_OOPS;
		}
	}

#endif /* CONFIG_USERSPACE */
	z_arm_fatal_error(reason, esf);
   2a216:	6800      	ldr	r0, [r0, #0]
   2a218:	f7e9 bd00 	b.w	13c1c <z_arm_fatal_error>

0002a21c <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
   2a21c:	b508      	push	{r3, lr}
	handler();
   2a21e:	f7e9 fd5d 	bl	13cdc <z_SysNmiOnReset>
	z_arm_exc_exit();
}
   2a222:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_exc_exit();
   2a226:	f7e9 bbe9 	b.w	139fc <z_arm_exc_exit>

0002a22a <z_arm_configure_dynamic_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_dynamic_mpu_regions(struct k_thread *thread)
{
   2a22a:	b507      	push	{r0, r1, r2, lr}

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(
   2a22c:	2100      	movs	r1, #0
   2a22e:	a801      	add	r0, sp, #4
   2a230:	f7ea fa02 	bl	14638 <arm_core_mpu_configure_dynamic_mpu_regions>
		(const struct k_mem_partition **)dynamic_regions,
		region_num);
}
   2a234:	b003      	add	sp, #12
   2a236:	f85d fb04 	ldr.w	pc, [sp], #4

0002a23a <strtoul>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
unsigned long strtoul(const char *nptr, char **endptr, register int base)
{
   2a23a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2a23e:	4684      	mov	ip, r0
   2a240:	460f      	mov	r7, r1
	register const char *s = nptr;
   2a242:	4605      	mov	r5, r0

	/*
	 * See strtol for comments as to the logic used.
	 */
	do {
		c = *s++;
   2a244:	462c      	mov	r4, r5
   2a246:	f814 3b01 	ldrb.w	r3, [r4], #1
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
   2a24a:	2b20      	cmp	r3, #32
   2a24c:	d035      	beq.n	2a2ba <strtoul+0x80>
   2a24e:	f1a3 0109 	sub.w	r1, r3, #9
   2a252:	2904      	cmp	r1, #4
   2a254:	d931      	bls.n	2a2ba <strtoul+0x80>
	} while (isspace(c));
	if (c == '-') {
   2a256:	2b2d      	cmp	r3, #45	; 0x2d
   2a258:	d131      	bne.n	2a2be <strtoul+0x84>
		neg = 1;
		c = *s++;
   2a25a:	786b      	ldrb	r3, [r5, #1]
   2a25c:	1cac      	adds	r4, r5, #2
		neg = 1;
   2a25e:	f04f 0e01 	mov.w	lr, #1
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
   2a262:	2a00      	cmp	r2, #0
   2a264:	d05e      	beq.n	2a324 <strtoul+0xea>
   2a266:	2a10      	cmp	r2, #16
   2a268:	d109      	bne.n	2a27e <strtoul+0x44>
   2a26a:	2b30      	cmp	r3, #48	; 0x30
   2a26c:	d107      	bne.n	2a27e <strtoul+0x44>
	    c == '0' && (*s == 'x' || *s == 'X')) {
   2a26e:	7823      	ldrb	r3, [r4, #0]
   2a270:	f003 03df 	and.w	r3, r3, #223	; 0xdf
   2a274:	2b58      	cmp	r3, #88	; 0x58
   2a276:	d150      	bne.n	2a31a <strtoul+0xe0>
		c = s[1];
   2a278:	7863      	ldrb	r3, [r4, #1]
		s += 2;
		base = 16;
   2a27a:	2210      	movs	r2, #16
		s += 2;
   2a27c:	3402      	adds	r4, #2

	if (base == 0) {
		base = c == '0' ? 8 : 10;
	}

	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
   2a27e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
   2a282:	2600      	movs	r6, #0
	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
   2a284:	fbb1 f1f2 	udiv	r1, r1, r2
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
   2a288:	fb02 f801 	mul.w	r8, r2, r1
   2a28c:	ea6f 0808 	mvn.w	r8, r8
	for (acc = 0, any = 0;; c = *s++) {
   2a290:	4630      	mov	r0, r6
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   2a292:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
		if (isdigit(c)) {
   2a296:	2d09      	cmp	r5, #9
   2a298:	d818      	bhi.n	2a2cc <strtoul+0x92>
			c -= '0';
   2a29a:	462b      	mov	r3, r5
		} else if (isalpha(c)) {
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
		} else {
			break;
		}
		if (c >= base) {
   2a29c:	429a      	cmp	r2, r3
   2a29e:	dd25      	ble.n	2a2ec <strtoul+0xb2>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
   2a2a0:	2e00      	cmp	r6, #0
   2a2a2:	db20      	blt.n	2a2e6 <strtoul+0xac>
   2a2a4:	4288      	cmp	r0, r1
   2a2a6:	d81e      	bhi.n	2a2e6 <strtoul+0xac>
   2a2a8:	d101      	bne.n	2a2ae <strtoul+0x74>
   2a2aa:	4543      	cmp	r3, r8
   2a2ac:	dc1b      	bgt.n	2a2e6 <strtoul+0xac>
			any = -1;
		} else {
			any = 1;
			acc *= base;
			acc += c;
   2a2ae:	fb00 3002 	mla	r0, r0, r2, r3
			any = 1;
   2a2b2:	2601      	movs	r6, #1
	for (acc = 0, any = 0;; c = *s++) {
   2a2b4:	f814 3b01 	ldrb.w	r3, [r4], #1
		if (isdigit(c)) {
   2a2b8:	e7eb      	b.n	2a292 <strtoul+0x58>
{
   2a2ba:	4625      	mov	r5, r4
   2a2bc:	e7c2      	b.n	2a244 <strtoul+0xa>
	} else if (c == '+') {
   2a2be:	2b2b      	cmp	r3, #43	; 0x2b
		c = *s++;
   2a2c0:	bf04      	itt	eq
   2a2c2:	1cac      	addeq	r4, r5, #2
   2a2c4:	786b      	ldrbeq	r3, [r5, #1]
	register int neg = 0, any, cutlim;
   2a2c6:	f04f 0e00 	mov.w	lr, #0
   2a2ca:	e7ca      	b.n	2a262 <strtoul+0x28>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
   2a2cc:	f043 0520 	orr.w	r5, r3, #32
   2a2d0:	3d61      	subs	r5, #97	; 0x61
		} else if (isalpha(c)) {
   2a2d2:	2d19      	cmp	r5, #25
   2a2d4:	d80a      	bhi.n	2a2ec <strtoul+0xb2>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   2a2d6:	f1a3 0541 	sub.w	r5, r3, #65	; 0x41
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
   2a2da:	2d1a      	cmp	r5, #26
   2a2dc:	bf34      	ite	cc
   2a2de:	2537      	movcc	r5, #55	; 0x37
   2a2e0:	2557      	movcs	r5, #87	; 0x57
   2a2e2:	1b5b      	subs	r3, r3, r5
   2a2e4:	e7da      	b.n	2a29c <strtoul+0x62>
			any = -1;
   2a2e6:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2a2ea:	e7e3      	b.n	2a2b4 <strtoul+0x7a>
		}
	}
	if (any < 0) {
   2a2ec:	2e00      	cmp	r6, #0
   2a2ee:	da08      	bge.n	2a302 <strtoul+0xc8>
	if (z_syscall_trap()) {
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
   2a2f0:	f7fc f82e 	bl	26350 <z_impl_z_errno>
		acc = ULONG_MAX;
		errno = ERANGE;
   2a2f4:	2326      	movs	r3, #38	; 0x26
   2a2f6:	6003      	str	r3, [r0, #0]
		acc = ULONG_MAX;
   2a2f8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	} else if (neg) {
		acc = -acc;
	}
	if (endptr != NULL) {
   2a2fc:	b947      	cbnz	r7, 2a310 <strtoul+0xd6>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
   2a2fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (neg) {
   2a302:	f1be 0f00 	cmp.w	lr, #0
   2a306:	d000      	beq.n	2a30a <strtoul+0xd0>
		acc = -acc;
   2a308:	4240      	negs	r0, r0
	if (endptr != NULL) {
   2a30a:	2f00      	cmp	r7, #0
   2a30c:	d0f7      	beq.n	2a2fe <strtoul+0xc4>
		*endptr = (char *)(any ? s - 1 : nptr);
   2a30e:	b10e      	cbz	r6, 2a314 <strtoul+0xda>
   2a310:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
   2a314:	f8c7 c000 	str.w	ip, [r7]
	return acc;
   2a318:	e7f1      	b.n	2a2fe <strtoul+0xc4>
	if (base == 0) {
   2a31a:	2330      	movs	r3, #48	; 0x30
   2a31c:	2a00      	cmp	r2, #0
   2a31e:	d1ae      	bne.n	2a27e <strtoul+0x44>
		base = c == '0' ? 8 : 10;
   2a320:	2208      	movs	r2, #8
   2a322:	e7ac      	b.n	2a27e <strtoul+0x44>
	if ((base == 0 || base == 16) &&
   2a324:	2b30      	cmp	r3, #48	; 0x30
   2a326:	d0a2      	beq.n	2a26e <strtoul+0x34>
		base = c == '0' ? 8 : 10;
   2a328:	220a      	movs	r2, #10
   2a32a:	e7a8      	b.n	2a27e <strtoul+0x44>

0002a32c <strstr>:
/*
 * Find the first occurrence of find in s.
 */
char *
strstr(const char *s, const char *find)
{
   2a32c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	char c, sc;
	size_t len;

	c = *find++;
   2a330:	780f      	ldrb	r7, [r1, #0]
{
   2a332:	4605      	mov	r5, r0
	if (c != 0) {
   2a334:	b187      	cbz	r7, 2a358 <strstr+0x2c>
	c = *find++;
   2a336:	1c4c      	adds	r4, r1, #1
		len = strlen(find);
   2a338:	4620      	mov	r0, r4
   2a33a:	f000 f83f 	bl	2a3bc <strlen>
   2a33e:	4680      	mov	r8, r0
		do {
			do {
				sc = *s++;
   2a340:	462e      	mov	r6, r5
   2a342:	f816 3b01 	ldrb.w	r3, [r6], #1
				if (sc == 0) {
   2a346:	b163      	cbz	r3, 2a362 <strstr+0x36>
					return NULL;
				}
			} while (sc != c);
   2a348:	429f      	cmp	r7, r3
   2a34a:	d108      	bne.n	2a35e <strstr+0x32>
		} while (strncmp(s, find, len) != 0);
   2a34c:	4642      	mov	r2, r8
   2a34e:	4621      	mov	r1, r4
   2a350:	4630      	mov	r0, r6
   2a352:	f000 f846 	bl	2a3e2 <strncmp>
   2a356:	b910      	cbnz	r0, 2a35e <strstr+0x32>
	s--;
	}
	return (char *)s;
}
   2a358:	4628      	mov	r0, r5
   2a35a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
   2a35e:	4635      	mov	r5, r6
   2a360:	e7ee      	b.n	2a340 <strstr+0x14>
					return NULL;
   2a362:	461d      	mov	r5, r3
   2a364:	e7f8      	b.n	2a358 <strstr+0x2c>

0002a366 <strcpy>:

char *strcpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
   2a366:	3901      	subs	r1, #1
   2a368:	4603      	mov	r3, r0
   2a36a:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   2a36e:	b90a      	cbnz	r2, 2a374 <strcpy+0xe>
		*d = *s;
		d++;
		s++;
	}

	*d = '\0';
   2a370:	701a      	strb	r2, [r3, #0]

	return dest;
}
   2a372:	4770      	bx	lr
		*d = *s;
   2a374:	f803 2b01 	strb.w	r2, [r3], #1
		s++;
   2a378:	e7f7      	b.n	2a36a <strcpy+0x4>

0002a37a <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s, size_t n)
{
   2a37a:	b570      	push	{r4, r5, r6, lr}
   2a37c:	3901      	subs	r1, #1
   2a37e:	4605      	mov	r5, r0
   2a380:	462c      	mov	r4, r5
	char *dest = d;

	while ((n > 0) && *s != '\0') {
   2a382:	b142      	cbz	r2, 2a396 <strncpy+0x1c>
   2a384:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   2a388:	1e56      	subs	r6, r2, #1
   2a38a:	b92b      	cbnz	r3, 2a398 <strncpy+0x1e>
   2a38c:	442a      	add	r2, r5
		d++;
		n--;
	}

	while (n > 0) {
		*d = '\0';
   2a38e:	f804 3b01 	strb.w	r3, [r4], #1
	while (n > 0) {
   2a392:	42a2      	cmp	r2, r4
   2a394:	d1fb      	bne.n	2a38e <strncpy+0x14>
		d++;
		n--;
	}

	return dest;
}
   2a396:	bd70      	pop	{r4, r5, r6, pc}
		*d = *s;
   2a398:	f805 3b01 	strb.w	r3, [r5], #1
		n--;
   2a39c:	4632      	mov	r2, r6
   2a39e:	e7ef      	b.n	2a380 <strncpy+0x6>

0002a3a0 <strchr>:
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
	char tmp = (char) c;
   2a3a0:	b2c9      	uxtb	r1, r1

	while ((*s != tmp) && (*s != '\0')) {
   2a3a2:	7802      	ldrb	r2, [r0, #0]
   2a3a4:	428a      	cmp	r2, r1
   2a3a6:	4603      	mov	r3, r0
   2a3a8:	f100 0001 	add.w	r0, r0, #1
   2a3ac:	d004      	beq.n	2a3b8 <strchr+0x18>
   2a3ae:	2a00      	cmp	r2, #0
   2a3b0:	d1f7      	bne.n	2a3a2 <strchr+0x2>
		s++;
	}

	return (*s == tmp) ? (char *) s : NULL;
   2a3b2:	2900      	cmp	r1, #0
   2a3b4:	bf18      	it	ne
   2a3b6:	2300      	movne	r3, #0
}
   2a3b8:	4618      	mov	r0, r3
   2a3ba:	4770      	bx	lr

0002a3bc <strlen>:
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
	size_t n = 0;
   2a3bc:	2300      	movs	r3, #0

	while (*s != '\0') {
   2a3be:	5cc2      	ldrb	r2, [r0, r3]
   2a3c0:	b90a      	cbnz	r2, 2a3c6 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
   2a3c2:	4618      	mov	r0, r3
   2a3c4:	4770      	bx	lr
		n++;
   2a3c6:	3301      	adds	r3, #1
   2a3c8:	e7f9      	b.n	2a3be <strlen+0x2>

0002a3ca <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
   2a3ca:	3801      	subs	r0, #1
   2a3cc:	3901      	subs	r1, #1
   2a3ce:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   2a3d2:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   2a3d6:	4293      	cmp	r3, r2
   2a3d8:	d101      	bne.n	2a3de <strcmp+0x14>
   2a3da:	2b00      	cmp	r3, #0
   2a3dc:	d1f7      	bne.n	2a3ce <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
   2a3de:	1a98      	subs	r0, r3, r2
   2a3e0:	4770      	bx	lr

0002a3e2 <strncmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
   2a3e2:	b530      	push	{r4, r5, lr}
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
   2a3e4:	2400      	movs	r4, #0
   2a3e6:	42a2      	cmp	r2, r4
   2a3e8:	d008      	beq.n	2a3fc <strncmp+0x1a>
   2a3ea:	5d03      	ldrb	r3, [r0, r4]
   2a3ec:	5d0d      	ldrb	r5, [r1, r4]
   2a3ee:	42ab      	cmp	r3, r5
   2a3f0:	d102      	bne.n	2a3f8 <strncmp+0x16>
   2a3f2:	3401      	adds	r4, #1
   2a3f4:	2b00      	cmp	r3, #0
   2a3f6:	d1f6      	bne.n	2a3e6 <strncmp+0x4>
		s1++;
		s2++;
		n--;
	}

	return (n == 0) ? 0 : (*s1 - *s2);
   2a3f8:	1b58      	subs	r0, r3, r5
   2a3fa:	e000      	b.n	2a3fe <strncmp+0x1c>
   2a3fc:	2000      	movs	r0, #0
}
   2a3fe:	bd30      	pop	{r4, r5, pc}

0002a400 <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
   2a400:	b510      	push	{r4, lr}
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
   2a402:	b15a      	cbz	r2, 2a41c <memcmp+0x1c>
   2a404:	3901      	subs	r1, #1
   2a406:	1884      	adds	r4, r0, r2
   2a408:	f810 2b01 	ldrb.w	r2, [r0], #1
   2a40c:	f811 3f01 	ldrb.w	r3, [r1, #1]!
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
   2a410:	42a0      	cmp	r0, r4
   2a412:	d001      	beq.n	2a418 <memcmp+0x18>
   2a414:	429a      	cmp	r2, r3
   2a416:	d0f7      	beq.n	2a408 <memcmp+0x8>
		c1++;
		c2++;
	}

	return *c1 - *c2;
   2a418:	1ad0      	subs	r0, r2, r3
}
   2a41a:	bd10      	pop	{r4, pc}
		return 0;
   2a41c:	4610      	mov	r0, r2
   2a41e:	e7fc      	b.n	2a41a <memcmp+0x1a>

0002a420 <memmove>:
void *memmove(void *d, const void *s, size_t n)
{
	char *dest = d;
	const char *src  = s;

	if ((size_t) (dest - src) < n) {
   2a420:	1a43      	subs	r3, r0, r1
   2a422:	4293      	cmp	r3, r2
{
   2a424:	b510      	push	{r4, lr}
   2a426:	eb00 0302 	add.w	r3, r0, r2
	if ((size_t) (dest - src) < n) {
   2a42a:	d308      	bcc.n	2a43e <memmove+0x1e>
   2a42c:	3901      	subs	r1, #1
	char *dest = d;
   2a42e:	4602      	mov	r2, r0
			n--;
			dest[n] = src[n];
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
   2a430:	429a      	cmp	r2, r3
   2a432:	d00b      	beq.n	2a44c <memmove+0x2c>
			*dest = *src;
   2a434:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   2a438:	f802 4b01 	strb.w	r4, [r2], #1
			dest++;
			src++;
			n--;
   2a43c:	e7f8      	b.n	2a430 <memmove+0x10>
   2a43e:	440a      	add	r2, r1
			dest[n] = src[n];
   2a440:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
   2a444:	f803 4d01 	strb.w	r4, [r3, #-1]!
		while (n > 0) {
   2a448:	428a      	cmp	r2, r1
   2a44a:	d1f9      	bne.n	2a440 <memmove+0x20>
		}
	}

	return d;
}
   2a44c:	bd10      	pop	{r4, pc}

0002a44e <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
   2a44e:	b5f0      	push	{r4, r5, r6, r7, lr}

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
   2a450:	ea81 0400 	eor.w	r4, r1, r0
   2a454:	07a5      	lsls	r5, r4, #30
   2a456:	4603      	mov	r3, r0
   2a458:	d00b      	beq.n	2a472 <memcpy+0x24>
   2a45a:	3b01      	subs	r3, #1
   2a45c:	440a      	add	r2, r1
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
   2a45e:	4291      	cmp	r1, r2
   2a460:	d11a      	bne.n	2a498 <memcpy+0x4a>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
   2a462:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (n == 0) {
   2a464:	2a00      	cmp	r2, #0
   2a466:	d0fc      	beq.n	2a462 <memcpy+0x14>
			*(d_byte++) = *(s_byte++);
   2a468:	f811 4b01 	ldrb.w	r4, [r1], #1
   2a46c:	f803 4b01 	strb.w	r4, [r3], #1
			n--;
   2a470:	3a01      	subs	r2, #1
		while (((uintptr_t)d_byte) & mask) {
   2a472:	079c      	lsls	r4, r3, #30
   2a474:	d1f6      	bne.n	2a464 <memcpy+0x16>
   2a476:	0895      	lsrs	r5, r2, #2
   2a478:	00ac      	lsls	r4, r5, #2
   2a47a:	1f1e      	subs	r6, r3, #4
   2a47c:	190f      	adds	r7, r1, r4
		while (n >= sizeof(mem_word_t)) {
   2a47e:	42b9      	cmp	r1, r7
   2a480:	d105      	bne.n	2a48e <memcpy+0x40>
   2a482:	f06f 0603 	mvn.w	r6, #3
   2a486:	fb06 2205 	mla	r2, r6, r5, r2
   2a48a:	4423      	add	r3, r4
   2a48c:	e7e5      	b.n	2a45a <memcpy+0xc>
			*(d_word++) = *(s_word++);
   2a48e:	f851 cb04 	ldr.w	ip, [r1], #4
   2a492:	f846 cf04 	str.w	ip, [r6, #4]!
			n -= sizeof(mem_word_t);
   2a496:	e7f2      	b.n	2a47e <memcpy+0x30>
		*(d_byte++) = *(s_byte++);
   2a498:	f811 4b01 	ldrb.w	r4, [r1], #1
   2a49c:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
   2a4a0:	e7dd      	b.n	2a45e <memcpy+0x10>

0002a4a2 <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
   2a4a2:	b570      	push	{r4, r5, r6, lr}
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
   2a4a4:	b2c9      	uxtb	r1, r1
	unsigned char *d_byte = (unsigned char *)buf;
   2a4a6:	4603      	mov	r3, r0

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
   2a4a8:	079c      	lsls	r4, r3, #30
   2a4aa:	d110      	bne.n	2a4ce <memset+0x2c>
	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;

	c_word |= c_word << 8;
   2a4ac:	ea41 2401 	orr.w	r4, r1, r1, lsl #8
	c_word |= c_word << 16;
   2a4b0:	ea44 4504 	orr.w	r5, r4, r4, lsl #16
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
   2a4b4:	0894      	lsrs	r4, r2, #2
   2a4b6:	eb03 0684 	add.w	r6, r3, r4, lsl #2
   2a4ba:	42b3      	cmp	r3, r6
   2a4bc:	d10d      	bne.n	2a4da <memset+0x38>
   2a4be:	f06f 0503 	mvn.w	r5, #3
   2a4c2:	fb05 2404 	mla	r4, r5, r4, r2
   2a4c6:	441c      	add	r4, r3

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
   2a4c8:	42a3      	cmp	r3, r4
   2a4ca:	d109      	bne.n	2a4e0 <memset+0x3e>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
   2a4cc:	bd70      	pop	{r4, r5, r6, pc}
		if (n == 0) {
   2a4ce:	2a00      	cmp	r2, #0
   2a4d0:	d0fc      	beq.n	2a4cc <memset+0x2a>
		*(d_byte++) = c_byte;
   2a4d2:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   2a4d6:	3a01      	subs	r2, #1
   2a4d8:	e7e6      	b.n	2a4a8 <memset+0x6>
		*(d_word++) = c_word;
   2a4da:	f843 5b04 	str.w	r5, [r3], #4
		n -= sizeof(mem_word_t);
   2a4de:	e7ec      	b.n	2a4ba <memset+0x18>
		*(d_byte++) = c_byte;
   2a4e0:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   2a4e4:	e7f0      	b.n	2a4c8 <memset+0x26>

0002a4e6 <_to_x>:
{
   2a4e6:	b5f0      	push	{r4, r5, r6, r7, lr}
   2a4e8:	4603      	mov	r3, r0
		unsigned int d = n % base;
   2a4ea:	fbb1 f7f2 	udiv	r7, r1, r2
   2a4ee:	fb02 1517 	mls	r5, r2, r7, r1
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
   2a4f2:	2d09      	cmp	r5, #9
   2a4f4:	bf8c      	ite	hi
   2a4f6:	2627      	movhi	r6, #39	; 0x27
   2a4f8:	2600      	movls	r6, #0
   2a4fa:	461c      	mov	r4, r3
   2a4fc:	3530      	adds	r5, #48	; 0x30
   2a4fe:	4435      	add	r5, r6
	} while (n);
   2a500:	4291      	cmp	r1, r2
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
   2a502:	f804 5b01 	strb.w	r5, [r4], #1
	} while (n);
   2a506:	d206      	bcs.n	2a516 <_to_x+0x30>
	*buf = 0;
   2a508:	2200      	movs	r2, #0
   2a50a:	7022      	strb	r2, [r4, #0]
	len = buf - start;
   2a50c:	1a24      	subs	r4, r4, r0
	for (buf--; buf > start; buf--, start++) {
   2a50e:	4283      	cmp	r3, r0
   2a510:	d804      	bhi.n	2a51c <_to_x+0x36>
}
   2a512:	4620      	mov	r0, r4
   2a514:	bdf0      	pop	{r4, r5, r6, r7, pc}
		n /= base;
   2a516:	4639      	mov	r1, r7
   2a518:	4623      	mov	r3, r4
   2a51a:	e7e6      	b.n	2a4ea <_to_x+0x4>
		char tmp = *buf;
   2a51c:	781a      	ldrb	r2, [r3, #0]
		*buf = *start;
   2a51e:	7801      	ldrb	r1, [r0, #0]
   2a520:	f803 1901 	strb.w	r1, [r3], #-1
		*start = tmp;
   2a524:	f800 2b01 	strb.w	r2, [r0], #1
   2a528:	e7f1      	b.n	2a50e <_to_x+0x28>

0002a52a <_rlrshift>:
{
   2a52a:	b570      	push	{r4, r5, r6, lr}
	*v = (*v & 1) + (*v >> 1);
   2a52c:	e9d0 6500 	ldrd	r6, r5, [r0]
   2a530:	0872      	lsrs	r2, r6, #1
   2a532:	f006 0301 	and.w	r3, r6, #1
   2a536:	ea42 72c5 	orr.w	r2, r2, r5, lsl #31
   2a53a:	189b      	adds	r3, r3, r2
   2a53c:	f04f 0100 	mov.w	r1, #0
   2a540:	ea4f 0455 	mov.w	r4, r5, lsr #1
   2a544:	eb44 0101 	adc.w	r1, r4, r1
   2a548:	e9c0 3100 	strd	r3, r1, [r0]
}
   2a54c:	bd70      	pop	{r4, r5, r6, pc}

0002a54e <_ldiv5>:
	uint64_t rem = *v, quot = 0U, q;
   2a54e:	e9d0 3200 	ldrd	r3, r2, [r0]
{
   2a552:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	rem += 2U;
   2a556:	3302      	adds	r3, #2
		q = (uint64_t)(hi / 5U) << shifts[i];
   2a558:	f04f 0705 	mov.w	r7, #5
   2a55c:	f04f 0c00 	mov.w	ip, #0
	rem += 2U;
   2a560:	f142 0200 	adc.w	r2, r2, #0
		rem -= q * 5U;
   2a564:	ebb3 060c 	subs.w	r6, r3, ip
		q = (uint64_t)(hi / 5U) << shifts[i];
   2a568:	fbb2 fef7 	udiv	lr, r2, r7
		rem -= q * 5U;
   2a56c:	fb07 f10e 	mul.w	r1, r7, lr
   2a570:	eb62 0101 	sbc.w	r1, r2, r1
		hi = rem >> shifts[i];
   2a574:	08f2      	lsrs	r2, r6, #3
   2a576:	ea42 7241 	orr.w	r2, r2, r1, lsl #29
		q = (uint64_t)(hi / 5U) << shifts[i];
   2a57a:	fbb2 f1f7 	udiv	r1, r2, r7
   2a57e:	00ca      	lsls	r2, r1, #3
		quot += q;
   2a580:	eb1c 0802 	adds.w	r8, ip, r2
		q = (uint64_t)(hi / 5U) << shifts[i];
   2a584:	ea4f 7351 	mov.w	r3, r1, lsr #29
		quot += q;
   2a588:	eb4e 0903 	adc.w	r9, lr, r3
		rem -= q * 5U;
   2a58c:	fba2 2307 	umull	r2, r3, r2, r7
   2a590:	1ab3      	subs	r3, r6, r2
		q = (uint64_t)(hi / 5U) << shifts[i];
   2a592:	fbb3 f3f7 	udiv	r3, r3, r7
		quot += q;
   2a596:	eb18 0403 	adds.w	r4, r8, r3
   2a59a:	f149 0500 	adc.w	r5, r9, #0
	*v = quot;
   2a59e:	e9c0 4500 	strd	r4, r5, [r0]
}
   2a5a2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0002a5a6 <_get_digit>:
	if (*digit_count > 0) {
   2a5a6:	680b      	ldr	r3, [r1, #0]
   2a5a8:	2b00      	cmp	r3, #0
{
   2a5aa:	b570      	push	{r4, r5, r6, lr}
	if (*digit_count > 0) {
   2a5ac:	dd10      	ble.n	2a5d0 <_get_digit+0x2a>
		*digit_count -= 1;
   2a5ae:	3b01      	subs	r3, #1
		*fr = *fr * 10U;
   2a5b0:	6802      	ldr	r2, [r0, #0]
		*digit_count -= 1;
   2a5b2:	600b      	str	r3, [r1, #0]
		*fr = *fr * 10U;
   2a5b4:	6844      	ldr	r4, [r0, #4]
   2a5b6:	210a      	movs	r1, #10
   2a5b8:	fba2 5601 	umull	r5, r6, r2, r1
   2a5bc:	fb01 6604 	mla	r6, r1, r4, r6
		*fr &= 0x0FFFFFFFFFFFFFFFull;
   2a5c0:	f026 4370 	bic.w	r3, r6, #4026531840	; 0xf0000000
   2a5c4:	e9c0 5300 	strd	r5, r3, [r0]
		rval = ((*fr >> 60) & 0xF) + '0';
   2a5c8:	0f31      	lsrs	r1, r6, #28
   2a5ca:	3130      	adds	r1, #48	; 0x30
}
   2a5cc:	4608      	mov	r0, r1
   2a5ce:	bd70      	pop	{r4, r5, r6, pc}
		rval = '0';
   2a5d0:	2130      	movs	r1, #48	; 0x30
   2a5d2:	e7fb      	b.n	2a5cc <_get_digit+0x26>

0002a5d4 <_stdout_hook_default>:
}
   2a5d4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a5d8:	4770      	bx	lr

0002a5da <sprintf_out>:
	if (p->len > 1) { /* need to reserve a byte for EOS */
   2a5da:	684b      	ldr	r3, [r1, #4]
   2a5dc:	2b01      	cmp	r3, #1
   2a5de:	dd07      	ble.n	2a5f0 <sprintf_out+0x16>
		*(p->ptr) = c;
   2a5e0:	680b      	ldr	r3, [r1, #0]
   2a5e2:	7018      	strb	r0, [r3, #0]
		p->ptr += 1;
   2a5e4:	680b      	ldr	r3, [r1, #0]
   2a5e6:	3301      	adds	r3, #1
   2a5e8:	600b      	str	r3, [r1, #0]
		p->len -= 1;
   2a5ea:	684b      	ldr	r3, [r1, #4]
   2a5ec:	3b01      	subs	r3, #1
   2a5ee:	604b      	str	r3, [r1, #4]
}
   2a5f0:	2000      	movs	r0, #0
   2a5f2:	4770      	bx	lr

0002a5f4 <z_platform_init>:

void z_platform_init(void)
{
	SystemInit();
   2a5f4:	f7fb bd18 	b.w	26028 <SystemInit>

0002a5f8 <ah>:
#define BT_DBG_ENABLED IS_ENABLED(CONFIG_BT_DEBUG_RPA)
#define LOG_MODULE_NAME bt_rpa
#include "common/log.h"

static int ah(const u8_t irk[16], const u8_t r[3], u8_t out[3])
{
   2a5f8:	b530      	push	{r4, r5, lr}
   2a5fa:	b085      	sub	sp, #20
   2a5fc:	4604      	mov	r4, r0
   2a5fe:	4615      	mov	r5, r2

	BT_DBG("irk %s", bt_hex(irk, 16));
	BT_DBG("r %s", bt_hex(r, 3));

	/* r' = padding || r */
	memcpy(res, r, 3);
   2a600:	4668      	mov	r0, sp
   2a602:	2203      	movs	r2, #3
   2a604:	f7ff ff23 	bl	2a44e <memcpy>
	(void)memset(res + 3, 0, 13);
   2a608:	220d      	movs	r2, #13
   2a60a:	2100      	movs	r1, #0
   2a60c:	f10d 0003 	add.w	r0, sp, #3
   2a610:	f7ff ff47 	bl	2a4a2 <memset>

	err = bt_encrypt_le(irk, res, res);
   2a614:	4620      	mov	r0, r4
   2a616:	466a      	mov	r2, sp
   2a618:	4669      	mov	r1, sp
   2a61a:	f001 fba6 	bl	2bd6a <bt_encrypt_le>
	if (err) {
   2a61e:	4604      	mov	r4, r0
   2a620:	b920      	cbnz	r0, 2a62c <ah+0x34>
	 *      ah(h, r) = e(k, r') mod 2^24
	 * The output of the security function e is then truncated to 24 bits
	 * by taking the least significant 24 bits of the output of e as the
	 * result of ah.
	 */
	memcpy(out, res, 3);
   2a622:	2203      	movs	r2, #3
   2a624:	4669      	mov	r1, sp
   2a626:	4628      	mov	r0, r5
   2a628:	f7ff ff11 	bl	2a44e <memcpy>

	return 0;
}
   2a62c:	4620      	mov	r0, r4
   2a62e:	b005      	add	sp, #20
   2a630:	bd30      	pop	{r4, r5, pc}

0002a632 <bt_rpa_irk_matches>:

#if defined(CONFIG_BT_SMP) || defined(CONFIG_BT_CTLR_PRIVACY)
bool bt_rpa_irk_matches(const u8_t irk[16], const bt_addr_t *addr)
{
   2a632:	b513      	push	{r0, r1, r4, lr}
   2a634:	460c      	mov	r4, r1
	u8_t hash[3];
	int err;

	BT_DBG("IRK %s bdaddr %s", bt_hex(irk, 16), bt_addr_str(addr));

	err = ah(irk, addr->val + 3, hash);
   2a636:	aa01      	add	r2, sp, #4
   2a638:	3103      	adds	r1, #3
   2a63a:	f7ff ffdd 	bl	2a5f8 <ah>
	if (err) {
   2a63e:	b948      	cbnz	r0, 2a654 <bt_rpa_irk_matches+0x22>
		return false;
	}

	return !memcmp(addr->val, hash, 3);
   2a640:	2203      	movs	r2, #3
   2a642:	a901      	add	r1, sp, #4
   2a644:	4620      	mov	r0, r4
   2a646:	f7ff fedb 	bl	2a400 <memcmp>
   2a64a:	fab0 f080 	clz	r0, r0
   2a64e:	0940      	lsrs	r0, r0, #5
}
   2a650:	b002      	add	sp, #8
   2a652:	bd10      	pop	{r4, pc}
		return false;
   2a654:	2000      	movs	r0, #0
   2a656:	e7fb      	b.n	2a650 <bt_rpa_irk_matches+0x1e>

0002a658 <bt_rpa_create>:
#endif

#if defined(CONFIG_BT_PRIVACY) || defined(CONFIG_BT_CTLR_PRIVACY)
int bt_rpa_create(const u8_t irk[16], bt_addr_t *rpa)
{
   2a658:	b570      	push	{r4, r5, r6, lr}
	int err;

	err = bt_rand(rpa->val + 3, 3);
   2a65a:	1ccd      	adds	r5, r1, #3
{
   2a65c:	4606      	mov	r6, r0
   2a65e:	460c      	mov	r4, r1
	err = bt_rand(rpa->val + 3, 3);
   2a660:	4628      	mov	r0, r5
   2a662:	2103      	movs	r1, #3
   2a664:	f7f3 fa06 	bl	1da74 <bt_rand>
	if (err) {
   2a668:	b960      	cbnz	r0, 2a684 <bt_rpa_create+0x2c>
		return err;
	}

	BT_ADDR_SET_RPA(rpa);
   2a66a:	7963      	ldrb	r3, [r4, #5]
   2a66c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   2a670:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   2a674:	7163      	strb	r3, [r4, #5]

	err = ah(irk, rpa->val + 3, rpa->val);
   2a676:	4622      	mov	r2, r4
   2a678:	4629      	mov	r1, r5
   2a67a:	4630      	mov	r0, r6
	}

	BT_DBG("Created RPA %s", bt_addr_str((bt_addr_t *)rpa->val));

	return 0;
}
   2a67c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	err = ah(irk, rpa->val + 3, rpa->val);
   2a680:	f7ff bfba 	b.w	2a5f8 <ah>
}
   2a684:	bd70      	pop	{r4, r5, r6, pc}

0002a686 <bt_uuid_cmp>:

	return memcmp(uuid1.val, uuid2.val, 16);
}

int bt_uuid_cmp(const struct bt_uuid *u1, const struct bt_uuid *u2)
{
   2a686:	b510      	push	{r4, lr}
   2a688:	460c      	mov	r4, r1
	/* Convert to 128 bit if types don't match */
	if (u1->type != u2->type) {
   2a68a:	7801      	ldrb	r1, [r0, #0]
   2a68c:	7822      	ldrb	r2, [r4, #0]
   2a68e:	428a      	cmp	r2, r1
{
   2a690:	b08a      	sub	sp, #40	; 0x28
	if (u1->type != u2->type) {
   2a692:	d00e      	beq.n	2a6b2 <bt_uuid_cmp+0x2c>
	uuid_to_uuid128(u1, &uuid1);
   2a694:	4669      	mov	r1, sp
   2a696:	f7ea fd53 	bl	15140 <uuid_to_uuid128>
	uuid_to_uuid128(u2, &uuid2);
   2a69a:	a905      	add	r1, sp, #20
   2a69c:	4620      	mov	r0, r4
   2a69e:	f7ea fd4f 	bl	15140 <uuid_to_uuid128>
	return memcmp(uuid1.val, uuid2.val, 16);
   2a6a2:	2210      	movs	r2, #16
   2a6a4:	f10d 0115 	add.w	r1, sp, #21
   2a6a8:	f10d 0001 	add.w	r0, sp, #1
	case BT_UUID_TYPE_16:
		return (int)BT_UUID_16(u1)->val - (int)BT_UUID_16(u2)->val;
	case BT_UUID_TYPE_32:
		return (int)BT_UUID_32(u1)->val - (int)BT_UUID_32(u2)->val;
	case BT_UUID_TYPE_128:
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
   2a6ac:	f7ff fea8 	bl	2a400 <memcmp>
   2a6b0:	e006      	b.n	2a6c0 <bt_uuid_cmp+0x3a>
	switch (u1->type) {
   2a6b2:	2a01      	cmp	r2, #1
   2a6b4:	d00a      	beq.n	2a6cc <bt_uuid_cmp+0x46>
   2a6b6:	b12a      	cbz	r2, 2a6c4 <bt_uuid_cmp+0x3e>
   2a6b8:	2a02      	cmp	r2, #2
   2a6ba:	d00a      	beq.n	2a6d2 <bt_uuid_cmp+0x4c>
	}

	return -EINVAL;
   2a6bc:	f06f 0015 	mvn.w	r0, #21
}
   2a6c0:	b00a      	add	sp, #40	; 0x28
   2a6c2:	bd10      	pop	{r4, pc}
		return (int)BT_UUID_16(u1)->val - (int)BT_UUID_16(u2)->val;
   2a6c4:	8840      	ldrh	r0, [r0, #2]
   2a6c6:	8863      	ldrh	r3, [r4, #2]
		return (int)BT_UUID_32(u1)->val - (int)BT_UUID_32(u2)->val;
   2a6c8:	1ac0      	subs	r0, r0, r3
   2a6ca:	e7f9      	b.n	2a6c0 <bt_uuid_cmp+0x3a>
   2a6cc:	6840      	ldr	r0, [r0, #4]
   2a6ce:	6863      	ldr	r3, [r4, #4]
   2a6d0:	e7fa      	b.n	2a6c8 <bt_uuid_cmp+0x42>
		return memcmp(BT_UUID_128(u1)->val, BT_UUID_128(u2)->val, 16);
   2a6d2:	2210      	movs	r2, #16
   2a6d4:	1c61      	adds	r1, r4, #1
   2a6d6:	3001      	adds	r0, #1
   2a6d8:	e7e8      	b.n	2a6ac <bt_uuid_cmp+0x26>

0002a6da <bt_uuid_create>:

bool bt_uuid_create(struct bt_uuid *uuid, const u8_t *data, u8_t data_len)
{
	/* Copy UUID from packet data/internal variable to internal bt_uuid */
	switch (data_len) {
   2a6da:	2a04      	cmp	r2, #4
{
   2a6dc:	b538      	push	{r3, r4, r5, lr}
   2a6de:	460c      	mov	r4, r1
	switch (data_len) {
   2a6e0:	d00d      	beq.n	2a6fe <bt_uuid_create+0x24>
   2a6e2:	2a10      	cmp	r2, #16
   2a6e4:	d019      	beq.n	2a71a <bt_uuid_create+0x40>
   2a6e6:	2a02      	cmp	r2, #2
   2a6e8:	f04f 0300 	mov.w	r3, #0
   2a6ec:	d11b      	bne.n	2a726 <bt_uuid_create+0x4c>
	case 2:
		uuid->type = BT_UUID_TYPE_16;
   2a6ee:	7003      	strb	r3, [r0, #0]
	return ((u16_t)src[1] << 8) | src[0];
   2a6f0:	784a      	ldrb	r2, [r1, #1]
   2a6f2:	780b      	ldrb	r3, [r1, #0]
   2a6f4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		BT_UUID_16(uuid)->val = sys_get_le16(data);
   2a6f8:	8043      	strh	r3, [r0, #2]
		memcpy(&BT_UUID_128(uuid)->val, data, 16);
		break;
	default:
		return false;
	}
	return true;
   2a6fa:	2001      	movs	r0, #1
}
   2a6fc:	bd38      	pop	{r3, r4, r5, pc}
		uuid->type = BT_UUID_TYPE_32;
   2a6fe:	2301      	movs	r3, #1
   2a700:	7003      	strb	r3, [r0, #0]
   2a702:	78a2      	ldrb	r2, [r4, #2]
   2a704:	78c9      	ldrb	r1, [r1, #3]
   2a706:	7865      	ldrb	r5, [r4, #1]
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
   2a708:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
	return ((u16_t)src[1] << 8) | src[0];
   2a70c:	7822      	ldrb	r2, [r4, #0]
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
   2a70e:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
   2a712:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
		BT_UUID_32(uuid)->val = sys_get_le32(data);
   2a716:	6042      	str	r2, [r0, #4]
		break;
   2a718:	e7ef      	b.n	2a6fa <bt_uuid_create+0x20>
		uuid->type = BT_UUID_TYPE_128;
   2a71a:	2302      	movs	r3, #2
   2a71c:	f800 3b01 	strb.w	r3, [r0], #1
		memcpy(&BT_UUID_128(uuid)->val, data, 16);
   2a720:	f7ff fe95 	bl	2a44e <memcpy>
		break;
   2a724:	e7e9      	b.n	2a6fa <bt_uuid_create+0x20>
		return false;
   2a726:	4618      	mov	r0, r3
   2a728:	e7e8      	b.n	2a6fc <bt_uuid_create+0x22>

0002a72a <bt_addr_le_copy>:
	memcpy(dst, src, sizeof(*dst));
   2a72a:	2207      	movs	r2, #7
   2a72c:	f7ff be8f 	b.w	2a44e <memcpy>

0002a730 <atomic_or>:
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2a730:	f3bf 8f5b 	dmb	ish
   2a734:	e850 3f00 	ldrex	r3, [r0]
   2a738:	ea43 0201 	orr.w	r2, r3, r1
   2a73c:	e840 2c00 	strex	ip, r2, [r0]
   2a740:	f1bc 0f00 	cmp.w	ip, #0
   2a744:	d1f6      	bne.n	2a734 <atomic_or+0x4>
   2a746:	f3bf 8f5b 	dmb	ish
}
   2a74a:	4618      	mov	r0, r3
   2a74c:	4770      	bx	lr

0002a74e <atomic_and>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2a74e:	f3bf 8f5b 	dmb	ish
   2a752:	e850 3f00 	ldrex	r3, [r0]
   2a756:	ea03 0201 	and.w	r2, r3, r1
   2a75a:	e840 2c00 	strex	ip, r2, [r0]
   2a75e:	f1bc 0f00 	cmp.w	ip, #0
   2a762:	d1f6      	bne.n	2a752 <atomic_and+0x4>
   2a764:	f3bf 8f5b 	dmb	ish
}
   2a768:	4618      	mov	r0, r3
   2a76a:	4770      	bx	lr

0002a76c <atomic_set_bit_to>:
 * @param val true for 1, false for 0.
 *
 * @return N/A
 */
static inline void atomic_set_bit_to(atomic_t *target, int bit, bool val)
{
   2a76c:	460b      	mov	r3, r1
   2a76e:	b410      	push	{r4}
   2a770:	095b      	lsrs	r3, r3, #5
	atomic_val_t mask = ATOMIC_MASK(bit);
   2a772:	f001 041f 	and.w	r4, r1, #31
   2a776:	2101      	movs	r1, #1
   2a778:	40a1      	lsls	r1, r4

	if (val) {
   2a77a:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   2a77e:	b112      	cbz	r2, 2a786 <atomic_set_bit_to+0x1a>
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
	} else {
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
	}
}
   2a780:	bc10      	pop	{r4}
		(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   2a782:	f7ff bfd5 	b.w	2a730 <atomic_or>
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   2a786:	43c9      	mvns	r1, r1
}
   2a788:	bc10      	pop	{r4}
		(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   2a78a:	f7ff bfe0 	b.w	2a74e <atomic_and>

0002a78e <find_pending_connect>:
{
   2a78e:	b510      	push	{r4, lr}
	conn = bt_conn_lookup_state_le(peer_addr, BT_CONN_CONNECT);
   2a790:	2103      	movs	r1, #3
{
   2a792:	4604      	mov	r4, r0
	conn = bt_conn_lookup_state_le(peer_addr, BT_CONN_CONNECT);
   2a794:	f7ed fcaa 	bl	180ec <bt_conn_lookup_state_le>
	if (conn) {
   2a798:	b928      	cbnz	r0, 2a7a6 <find_pending_connect+0x18>
	return bt_conn_lookup_state_le(peer_addr, BT_CONN_CONNECT_DIR_ADV);
   2a79a:	4620      	mov	r0, r4
   2a79c:	2102      	movs	r1, #2
}
   2a79e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return bt_conn_lookup_state_le(peer_addr, BT_CONN_CONNECT_DIR_ADV);
   2a7a2:	f7ed bca3 	b.w	180ec <bt_conn_lookup_state_le>
}
   2a7a6:	bd10      	pop	{r4, pc}

0002a7a8 <atomic_test_bit>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2a7a8:	f3bf 8f5b 	dmb	ish
   2a7ac:	6800      	ldr	r0, [r0, #0]
   2a7ae:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   2a7b2:	4108      	asrs	r0, r1
}
   2a7b4:	f000 0001 	and.w	r0, r0, #1
   2a7b8:	4770      	bx	lr

0002a7ba <le_set_private_addr.isra.22>:
static int le_set_private_addr(u8_t id)
   2a7ba:	b507      	push	{r0, r1, r2, lr}
	err = bt_rand(nrpa.val, sizeof(nrpa.val));
   2a7bc:	2106      	movs	r1, #6
   2a7be:	4668      	mov	r0, sp
   2a7c0:	f7f3 f958 	bl	1da74 <bt_rand>
	if (err) {
   2a7c4:	b940      	cbnz	r0, 2a7d8 <le_set_private_addr.isra.22+0x1e>
	nrpa.val[5] &= 0x3f;
   2a7c6:	f89d 3005 	ldrb.w	r3, [sp, #5]
	return set_random_address(&nrpa);
   2a7ca:	4668      	mov	r0, sp
	nrpa.val[5] &= 0x3f;
   2a7cc:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   2a7d0:	f88d 3005 	strb.w	r3, [sp, #5]
	return set_random_address(&nrpa);
   2a7d4:	f7eb f892 	bl	158fc <set_random_address>
}
   2a7d8:	b003      	add	sp, #12
   2a7da:	f85d fb04 	ldr.w	pc, [sp], #4

0002a7de <bt_lookup_id_addr>:
}
   2a7de:	4608      	mov	r0, r1
   2a7e0:	4770      	bx	lr

0002a7e2 <bt_le_conn_params_valid>:
	if (param->interval_min > param->interval_max ||
   2a7e2:	8802      	ldrh	r2, [r0, #0]
   2a7e4:	8843      	ldrh	r3, [r0, #2]
   2a7e6:	429a      	cmp	r2, r3
{
   2a7e8:	b510      	push	{r4, lr}
	if (param->interval_min > param->interval_max ||
   2a7ea:	d818      	bhi.n	2a81e <bt_le_conn_params_valid+0x3c>
   2a7ec:	2a05      	cmp	r2, #5
   2a7ee:	d916      	bls.n	2a81e <bt_le_conn_params_valid+0x3c>
	    param->interval_min < 6 || param->interval_max > 3200) {
   2a7f0:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
   2a7f4:	d813      	bhi.n	2a81e <bt_le_conn_params_valid+0x3c>
	if (param->latency > 499) {
   2a7f6:	8884      	ldrh	r4, [r0, #4]
   2a7f8:	f5b4 7ffa 	cmp.w	r4, #500	; 0x1f4
   2a7fc:	d20f      	bcs.n	2a81e <bt_le_conn_params_valid+0x3c>
	if (param->timeout < 10 || param->timeout > 3200 ||
   2a7fe:	88c1      	ldrh	r1, [r0, #6]
   2a800:	f1a1 020a 	sub.w	r2, r1, #10
   2a804:	b292      	uxth	r2, r2
   2a806:	f640 4076 	movw	r0, #3190	; 0xc76
   2a80a:	4282      	cmp	r2, r0
   2a80c:	d807      	bhi.n	2a81e <bt_le_conn_params_valid+0x3c>
	     ((1 + param->latency) * param->interval_max))) {
   2a80e:	fb04 3303 	mla	r3, r4, r3, r3
	if (param->timeout < 10 || param->timeout > 3200 ||
   2a812:	ebb3 0f81 	cmp.w	r3, r1, lsl #2
   2a816:	bf34      	ite	cc
   2a818:	2001      	movcc	r0, #1
   2a81a:	2000      	movcs	r0, #0
}
   2a81c:	bd10      	pop	{r4, pc}
		return false;
   2a81e:	2000      	movs	r0, #0
   2a820:	e7fc      	b.n	2a81c <bt_le_conn_params_valid+0x3a>

0002a822 <bt_addr_le_create_static>:
	addr->type = BT_ADDR_LE_RANDOM;
   2a822:	2301      	movs	r3, #1
{
   2a824:	b510      	push	{r4, lr}
	return bt_rand(addr->a.val, 6);
   2a826:	2106      	movs	r1, #6
{
   2a828:	4604      	mov	r4, r0
	addr->type = BT_ADDR_LE_RANDOM;
   2a82a:	f800 3b01 	strb.w	r3, [r0], #1
	return bt_rand(addr->a.val, 6);
   2a82e:	f7f3 f921 	bl	1da74 <bt_rand>
	if (err) {
   2a832:	b918      	cbnz	r0, 2a83c <bt_addr_le_create_static+0x1a>
	BT_ADDR_SET_STATIC(&addr->a);
   2a834:	79a3      	ldrb	r3, [r4, #6]
   2a836:	f063 033f 	orn	r3, r3, #63	; 0x3f
   2a83a:	71a3      	strb	r3, [r4, #6]
}
   2a83c:	bd10      	pop	{r4, pc}

0002a83e <hci_le_set_phy.isra.30>:
static int hci_le_set_phy(struct bt_conn *conn)
   2a83e:	b538      	push	{r3, r4, r5, lr}
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PHY, sizeof(*cp));
   2a840:	2107      	movs	r1, #7
static int hci_le_set_phy(struct bt_conn *conn)
   2a842:	4604      	mov	r4, r0
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_SET_PHY, sizeof(*cp));
   2a844:	f242 0032 	movw	r0, #8242	; 0x2032
   2a848:	f7ea ffa2 	bl	15790 <bt_hci_cmd_create>
	if (!buf) {
   2a84c:	4605      	mov	r5, r0
   2a84e:	b198      	cbz	r0, 2a878 <hci_le_set_phy.isra.30+0x3a>
	cp = net_buf_add(buf, sizeof(*cp));
   2a850:	2107      	movs	r1, #7
   2a852:	3008      	adds	r0, #8
   2a854:	f002 f994 	bl	2cb80 <net_buf_simple_add>
	cp->handle = sys_cpu_to_le16(conn->handle);
   2a858:	8823      	ldrh	r3, [r4, #0]
   2a85a:	8003      	strh	r3, [r0, #0]
	cp->all_phys = 0U;
   2a85c:	2400      	movs	r4, #0
	cp->tx_phys = BT_HCI_LE_PHY_PREFER_2M;
   2a85e:	2302      	movs	r3, #2
	cp->all_phys = 0U;
   2a860:	7084      	strb	r4, [r0, #2]
	cp->tx_phys = BT_HCI_LE_PHY_PREFER_2M;
   2a862:	70c3      	strb	r3, [r0, #3]
	cp->rx_phys = BT_HCI_LE_PHY_PREFER_2M;
   2a864:	7103      	strb	r3, [r0, #4]
	cp->phy_opts = BT_HCI_LE_PHY_CODED_ANY;
   2a866:	7144      	strb	r4, [r0, #5]
   2a868:	7184      	strb	r4, [r0, #6]
	bt_hci_cmd_send(BT_HCI_OP_LE_SET_PHY, buf);
   2a86a:	4629      	mov	r1, r5
   2a86c:	f242 0032 	movw	r0, #8242	; 0x2032
   2a870:	f7eb f9d8 	bl	15c24 <bt_hci_cmd_send>
	return 0;
   2a874:	4620      	mov	r0, r4
}
   2a876:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOBUFS;
   2a878:	f06f 0036 	mvn.w	r0, #54	; 0x36
   2a87c:	e7fb      	b.n	2a876 <hci_le_set_phy.isra.30+0x38>

0002a87e <le_enh_conn_complete>:
	enh_conn_complete((void *)buf->data);
   2a87e:	6880      	ldr	r0, [r0, #8]
   2a880:	f7eb bda0 	b.w	163c4 <enh_conn_complete>

0002a884 <le_legacy_conn_complete>:
{
   2a884:	b510      	push	{r4, lr}
	struct bt_hci_evt_le_conn_complete *evt = (void *)buf->data;
   2a886:	6881      	ldr	r1, [r0, #8]
{
   2a888:	b08c      	sub	sp, #48	; 0x30
	enh.status         = evt->status;
   2a88a:	780b      	ldrb	r3, [r1, #0]
   2a88c:	f88d 3010 	strb.w	r3, [sp, #16]
	enh.handle         = evt->handle;
   2a890:	f8b1 3001 	ldrh.w	r3, [r1, #1]
   2a894:	f8ad 3011 	strh.w	r3, [sp, #17]
	enh.role           = evt->role;
   2a898:	78cb      	ldrb	r3, [r1, #3]
   2a89a:	f88d 3013 	strb.w	r3, [sp, #19]
	enh.interval       = evt->interval;
   2a89e:	f8b1 300b 	ldrh.w	r3, [r1, #11]
   2a8a2:	f8ad 3027 	strh.w	r3, [sp, #39]	; 0x27
	enh.latency        = evt->latency;
   2a8a6:	f8b1 300d 	ldrh.w	r3, [r1, #13]
   2a8aa:	f8ad 3029 	strh.w	r3, [sp, #41]	; 0x29
	enh.supv_timeout   = evt->supv_timeout;
   2a8ae:	f8b1 300f 	ldrh.w	r3, [r1, #15]
   2a8b2:	f8ad 302b 	strh.w	r3, [sp, #43]	; 0x2b
	enh.clock_accuracy = evt->clock_accuracy;
   2a8b6:	7c4b      	ldrb	r3, [r1, #17]
   2a8b8:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
	bt_addr_le_copy(&enh.peer_addr, &evt->peer_addr);
   2a8bc:	a805      	add	r0, sp, #20
   2a8be:	3104      	adds	r1, #4
   2a8c0:	f7ff ff33 	bl	2a72a <bt_addr_le_copy>
		bt_addr_copy(&enh.local_rpa, BT_ADDR_ANY);
   2a8c4:	2400      	movs	r4, #0
	memcpy(dst, src, sizeof(*dst));
   2a8c6:	4669      	mov	r1, sp
   2a8c8:	2206      	movs	r2, #6
   2a8ca:	f10d 001b 	add.w	r0, sp, #27
   2a8ce:	9400      	str	r4, [sp, #0]
   2a8d0:	f8ad 4004 	strh.w	r4, [sp, #4]
   2a8d4:	f7ff fdbb 	bl	2a44e <memcpy>
   2a8d8:	2206      	movs	r2, #6
   2a8da:	a902      	add	r1, sp, #8
   2a8dc:	f10d 0021 	add.w	r0, sp, #33	; 0x21
		bt_addr_copy(&enh.peer_rpa, BT_ADDR_ANY);
   2a8e0:	9402      	str	r4, [sp, #8]
   2a8e2:	f8ad 400c 	strh.w	r4, [sp, #12]
   2a8e6:	f7ff fdb2 	bl	2a44e <memcpy>
	enh_conn_complete(&enh);
   2a8ea:	a804      	add	r0, sp, #16
   2a8ec:	f7eb fd6a 	bl	163c4 <enh_conn_complete>
}
   2a8f0:	b00c      	add	sp, #48	; 0x30
   2a8f2:	bd10      	pop	{r4, pc}

0002a8f4 <bt_addr_le_is_bonded>:
}
   2a8f4:	2000      	movs	r0, #0
   2a8f6:	4770      	bx	lr

0002a8f8 <bt_le_adv_start>:
{
   2a8f8:	b513      	push	{r0, r1, r4, lr}
	if (param->options & BT_LE_ADV_OPT_DIR_MODE_LOW_DUTY) {
   2a8fa:	7844      	ldrb	r4, [r0, #1]
   2a8fc:	f014 0410 	ands.w	r4, r4, #16
   2a900:	d106      	bne.n	2a910 <bt_le_adv_start+0x18>
	return bt_le_adv_start_internal(param, ad, ad_len, sd, sd_len, NULL);
   2a902:	9401      	str	r4, [sp, #4]
   2a904:	9c04      	ldr	r4, [sp, #16]
   2a906:	9400      	str	r4, [sp, #0]
   2a908:	f7ec fd90 	bl	1742c <bt_le_adv_start_internal>
}
   2a90c:	b002      	add	sp, #8
   2a90e:	bd10      	pop	{r4, pc}
		return -EINVAL;
   2a910:	f06f 0015 	mvn.w	r0, #21
   2a914:	e7fa      	b.n	2a90c <bt_le_adv_start+0x14>

0002a916 <atomic_get>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2a916:	f3bf 8f5b 	dmb	ish
   2a91a:	6800      	ldr	r0, [r0, #0]
   2a91c:	f3bf 8f5b 	dmb	ish
}
   2a920:	4770      	bx	lr

0002a922 <atomic_test_bit>:
{
   2a922:	b508      	push	{r3, lr}
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));
   2a924:	f7ff fff7 	bl	2a916 <atomic_get>
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   2a928:	4108      	asrs	r0, r1
}
   2a92a:	f000 0001 	and.w	r0, r0, #1
   2a92e:	bd08      	pop	{r3, pc}

0002a930 <bt_conn_reset_rx_state>:
	if (!conn->rx_len) {
   2a930:	8983      	ldrh	r3, [r0, #12]
{
   2a932:	b510      	push	{r4, lr}
   2a934:	4604      	mov	r4, r0
	if (!conn->rx_len) {
   2a936:	b12b      	cbz	r3, 2a944 <bt_conn_reset_rx_state+0x14>
	net_buf_unref(conn->rx);
   2a938:	6900      	ldr	r0, [r0, #16]
   2a93a:	f7fa fcc7 	bl	252cc <net_buf_unref>
	conn->rx = NULL;
   2a93e:	2300      	movs	r3, #0
   2a940:	6123      	str	r3, [r4, #16]
	conn->rx_len = 0U;
   2a942:	81a3      	strh	r3, [r4, #12]
}
   2a944:	bd10      	pop	{r4, pc}

0002a946 <atomic_dec>:
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   2a946:	f3bf 8f5b 	dmb	ish
   2a94a:	e850 3f00 	ldrex	r3, [r0]
   2a94e:	1e5a      	subs	r2, r3, #1
   2a950:	e840 2100 	strex	r1, r2, [r0]
   2a954:	2900      	cmp	r1, #0
   2a956:	d1f8      	bne.n	2a94a <atomic_dec+0x4>
   2a958:	f3bf 8f5b 	dmb	ish
}
   2a95c:	4618      	mov	r0, r3
   2a95e:	4770      	bx	lr

0002a960 <atomic_inc>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   2a960:	f3bf 8f5b 	dmb	ish
   2a964:	e850 3f00 	ldrex	r3, [r0]
   2a968:	1c5a      	adds	r2, r3, #1
   2a96a:	e840 2100 	strex	r1, r2, [r0]
   2a96e:	2900      	cmp	r1, #0
   2a970:	d1f8      	bne.n	2a964 <atomic_inc+0x4>
   2a972:	f3bf 8f5b 	dmb	ish
}
   2a976:	4618      	mov	r0, r3
   2a978:	4770      	bx	lr

0002a97a <tx_notify>:
{
   2a97a:	b570      	push	{r4, r5, r6, lr}
   2a97c:	4604      	mov	r4, r0
	__asm__ volatile(
   2a97e:	f04f 0220 	mov.w	r2, #32
   2a982:	f3ef 8311 	mrs	r3, BASEPRI
   2a986:	f382 8811 	msr	BASEPRI, r2
   2a98a:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
   2a98e:	6a20      	ldr	r0, [r4, #32]
		if (sys_slist_is_empty(&conn->tx_complete)) {
   2a990:	b920      	cbnz	r0, 2a99c <tx_notify+0x22>
	__asm__ volatile(
   2a992:	f383 8811 	msr	BASEPRI, r3
   2a996:	f3bf 8f6f 	isb	sy
}
   2a99a:	bd70      	pop	{r4, r5, r6, pc}
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2a99c:	6a61      	ldr	r1, [r4, #36]	; 0x24
   2a99e:	6802      	ldr	r2, [r0, #0]
	list->head = node;
   2a9a0:	6222      	str	r2, [r4, #32]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2a9a2:	4288      	cmp	r0, r1
	list->tail = node;
   2a9a4:	bf08      	it	eq
   2a9a6:	6262      	streq	r2, [r4, #36]	; 0x24
   2a9a8:	f383 8811 	msr	BASEPRI, r3
   2a9ac:	f3bf 8f6f 	isb	sy
		user_data = tx->user_data;
   2a9b0:	e9d0 5601 	ldrd	r5, r6, [r0, #4]
		tx_free(tx);
   2a9b4:	f7ec ff3e 	bl	17834 <tx_free>
		cb(conn, user_data);
   2a9b8:	4631      	mov	r1, r6
   2a9ba:	4620      	mov	r0, r4
   2a9bc:	47a8      	blx	r5
	while (1) {
   2a9be:	e7de      	b.n	2a97e <tx_notify+0x4>

0002a9c0 <tx_complete_work>:
	tx_notify(conn);
   2a9c0:	3828      	subs	r0, #40	; 0x28
   2a9c2:	f7ff bfda 	b.w	2a97a <tx_notify>

0002a9c6 <bt_conn_get_security>:
}
   2a9c6:	2001      	movs	r0, #1
   2a9c8:	4770      	bx	lr

0002a9ca <bt_conn_addr_le_cmp>:
{
   2a9ca:	b538      	push	{r3, r4, r5, lr}
   2a9cc:	460d      	mov	r5, r1
   2a9ce:	4604      	mov	r4, r0
	return memcmp(a, b, sizeof(*a));
   2a9d0:	f100 0170 	add.w	r1, r0, #112	; 0x70
   2a9d4:	2207      	movs	r2, #7
   2a9d6:	4628      	mov	r0, r5
   2a9d8:	f7ff fd12 	bl	2a400 <memcmp>
	if (!bt_addr_le_cmp(peer, &conn->le.dst)) {
   2a9dc:	b160      	cbz	r0, 2a9f8 <bt_conn_addr_le_cmp+0x2e>
	if (conn->role == BT_HCI_ROLE_MASTER) {
   2a9de:	78e3      	ldrb	r3, [r4, #3]
   2a9e0:	2207      	movs	r2, #7
   2a9e2:	b933      	cbnz	r3, 2a9f2 <bt_conn_addr_le_cmp+0x28>
   2a9e4:	f104 017e 	add.w	r1, r4, #126	; 0x7e
   2a9e8:	4628      	mov	r0, r5
}
   2a9ea:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   2a9ee:	f7ff bd07 	b.w	2a400 <memcmp>
   2a9f2:	f104 0177 	add.w	r1, r4, #119	; 0x77
   2a9f6:	e7f7      	b.n	2a9e8 <bt_conn_addr_le_cmp+0x1e>
   2a9f8:	bd38      	pop	{r3, r4, r5, pc}

0002a9fa <bt_conn_ref>:
{
   2a9fa:	b510      	push	{r4, lr}
   2a9fc:	4604      	mov	r4, r0
	atomic_inc(&conn->ref);
   2a9fe:	304c      	adds	r0, #76	; 0x4c
   2aa00:	f7ff ffae 	bl	2a960 <atomic_inc>
}
   2aa04:	4620      	mov	r0, r4
   2aa06:	bd10      	pop	{r4, pc}

0002aa08 <bt_conn_unref>:
	atomic_dec(&conn->ref);
   2aa08:	304c      	adds	r0, #76	; 0x4c
   2aa0a:	f7ff bf9c 	b.w	2a946 <atomic_dec>

0002aa0e <bt_conn_get_dst>:
}
   2aa0e:	3070      	adds	r0, #112	; 0x70
   2aa10:	4770      	bx	lr

0002aa12 <bt_conn_disconnect>:
{
   2aa12:	b570      	push	{r4, r5, r6, lr}
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   2aa14:	7883      	ldrb	r3, [r0, #2]
   2aa16:	2b01      	cmp	r3, #1
{
   2aa18:	4604      	mov	r4, r0
   2aa1a:	460e      	mov	r6, r1
	if (IS_ENABLED(CONFIG_BT_CENTRAL) &&
   2aa1c:	d103      	bne.n	2aa26 <bt_conn_disconnect+0x14>
		bt_le_set_auto_conn(&conn->le.dst, NULL);
   2aa1e:	2100      	movs	r1, #0
   2aa20:	3070      	adds	r0, #112	; 0x70
   2aa22:	f7ed fc41 	bl	182a8 <bt_le_set_auto_conn>
	switch (conn->state) {
   2aa26:	7aa3      	ldrb	r3, [r4, #10]
   2aa28:	3b01      	subs	r3, #1
   2aa2a:	2b04      	cmp	r3, #4
   2aa2c:	d804      	bhi.n	2aa38 <bt_conn_disconnect+0x26>
   2aa2e:	e8df f003 	tbb	[pc, r3]
   2aa32:	1107      	.short	0x1107
   2aa34:	251a      	.short	0x251a
   2aa36:	0f          	.byte	0x0f
   2aa37:	00          	.byte	0x00
		return -ENOTCONN;
   2aa38:	f06f 0538 	mvn.w	r5, #56	; 0x38
}
   2aa3c:	4628      	mov	r0, r5
   2aa3e:	bd70      	pop	{r4, r5, r6, pc}
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   2aa40:	4620      	mov	r0, r4
		conn->err = reason;
   2aa42:	7266      	strb	r6, [r4, #9]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   2aa44:	2100      	movs	r1, #0
   2aa46:	f7ed fa1b 	bl	17e80 <bt_conn_set_state>
			bt_le_scan_update(false);
   2aa4a:	2000      	movs	r0, #0
   2aa4c:	f7eb f97e 	bl	15d4c <bt_le_scan_update>
		return 0;
   2aa50:	2500      	movs	r5, #0
   2aa52:	e7f3      	b.n	2aa3c <bt_conn_disconnect+0x2a>
		conn->err = reason;
   2aa54:	7266      	strb	r6, [r4, #9]
		bt_conn_set_state(conn, BT_CONN_DISCONNECTED);
   2aa56:	4620      	mov	r0, r4
   2aa58:	2100      	movs	r1, #0
   2aa5a:	f7ed fa11 	bl	17e80 <bt_conn_set_state>
}
   2aa5e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			return bt_le_adv_stop();
   2aa62:	f7ec bdf5 	b.w	17650 <bt_le_adv_stop>
			k_delayed_work_cancel(&conn->update_work);
   2aa66:	f104 0050 	add.w	r0, r4, #80	; 0x50
   2aa6a:	f002 fd7a 	bl	2d562 <k_delayed_work_cancel>
			return bt_hci_cmd_send(BT_HCI_OP_LE_CREATE_CONN_CANCEL,
   2aa6e:	2100      	movs	r1, #0
   2aa70:	f242 000e 	movw	r0, #8206	; 0x200e
}
   2aa74:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			return bt_hci_cmd_send(BT_HCI_OP_LE_CREATE_CONN_CANCEL,
   2aa78:	f7eb b8d4 	b.w	15c24 <bt_hci_cmd_send>
	buf = bt_hci_cmd_create(BT_HCI_OP_DISCONNECT, sizeof(*disconn));
   2aa7c:	2103      	movs	r1, #3
   2aa7e:	f240 4006 	movw	r0, #1030	; 0x406
   2aa82:	f7ea fe85 	bl	15790 <bt_hci_cmd_create>
	if (!buf) {
   2aa86:	4605      	mov	r5, r0
   2aa88:	b198      	cbz	r0, 2aab2 <bt_conn_disconnect+0xa0>
	disconn = net_buf_add(buf, sizeof(*disconn));
   2aa8a:	2103      	movs	r1, #3
   2aa8c:	3008      	adds	r0, #8
   2aa8e:	f002 f877 	bl	2cb80 <net_buf_simple_add>
	disconn->handle = sys_cpu_to_le16(conn->handle);
   2aa92:	8823      	ldrh	r3, [r4, #0]
   2aa94:	8003      	strh	r3, [r0, #0]
	disconn->reason = reason;
   2aa96:	7086      	strb	r6, [r0, #2]
	err = bt_hci_cmd_send(BT_HCI_OP_DISCONNECT, buf);
   2aa98:	4629      	mov	r1, r5
   2aa9a:	f240 4006 	movw	r0, #1030	; 0x406
   2aa9e:	f7eb f8c1 	bl	15c24 <bt_hci_cmd_send>
	if (err) {
   2aaa2:	4605      	mov	r5, r0
   2aaa4:	2800      	cmp	r0, #0
   2aaa6:	d1c9      	bne.n	2aa3c <bt_conn_disconnect+0x2a>
	bt_conn_set_state(conn, BT_CONN_DISCONNECT);
   2aaa8:	2105      	movs	r1, #5
   2aaaa:	4620      	mov	r0, r4
   2aaac:	f7ed f9e8 	bl	17e80 <bt_conn_set_state>
	return 0;
   2aab0:	e7c4      	b.n	2aa3c <bt_conn_disconnect+0x2a>
		return -ENOBUFS;
   2aab2:	f06f 0536 	mvn.w	r5, #54	; 0x36
   2aab6:	e7c1      	b.n	2aa3c <bt_conn_disconnect+0x2a>

0002aab8 <bt_conn_le_conn_update>:
{
   2aab8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2aaba:	4607      	mov	r7, r0
   2aabc:	460d      	mov	r5, r1
	buf = bt_hci_cmd_create(BT_HCI_OP_LE_CONN_UPDATE,
   2aabe:	f242 0013 	movw	r0, #8211	; 0x2013
   2aac2:	210e      	movs	r1, #14
   2aac4:	f7ea fe64 	bl	15790 <bt_hci_cmd_create>
	if (!buf) {
   2aac8:	4606      	mov	r6, r0
   2aaca:	b1d0      	cbz	r0, 2ab02 <bt_conn_le_conn_update+0x4a>
	conn_update = net_buf_add(buf, sizeof(*conn_update));
   2aacc:	210e      	movs	r1, #14
   2aace:	3008      	adds	r0, #8
   2aad0:	f002 f856 	bl	2cb80 <net_buf_simple_add>
	(void)memset(conn_update, 0, sizeof(*conn_update));
   2aad4:	220e      	movs	r2, #14
	conn_update = net_buf_add(buf, sizeof(*conn_update));
   2aad6:	4604      	mov	r4, r0
	(void)memset(conn_update, 0, sizeof(*conn_update));
   2aad8:	2100      	movs	r1, #0
   2aada:	f7ff fce2 	bl	2a4a2 <memset>
	conn_update->handle = sys_cpu_to_le16(conn->handle);
   2aade:	883b      	ldrh	r3, [r7, #0]
   2aae0:	8023      	strh	r3, [r4, #0]
	conn_update->conn_interval_min = sys_cpu_to_le16(param->interval_min);
   2aae2:	882b      	ldrh	r3, [r5, #0]
   2aae4:	8063      	strh	r3, [r4, #2]
	conn_update->conn_interval_max = sys_cpu_to_le16(param->interval_max);
   2aae6:	886b      	ldrh	r3, [r5, #2]
   2aae8:	80a3      	strh	r3, [r4, #4]
	conn_update->conn_latency = sys_cpu_to_le16(param->latency);
   2aaea:	88ab      	ldrh	r3, [r5, #4]
   2aaec:	80e3      	strh	r3, [r4, #6]
	conn_update->supervision_timeout = sys_cpu_to_le16(param->timeout);
   2aaee:	88eb      	ldrh	r3, [r5, #6]
   2aaf0:	8123      	strh	r3, [r4, #8]
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   2aaf2:	4631      	mov	r1, r6
   2aaf4:	2200      	movs	r2, #0
   2aaf6:	f242 0013 	movw	r0, #8211	; 0x2013
}
   2aafa:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	return bt_hci_cmd_send_sync(BT_HCI_OP_LE_CONN_UPDATE, buf, NULL);
   2aafe:	f7ea be7d 	b.w	157fc <bt_hci_cmd_send_sync>
}
   2ab02:	f06f 0036 	mvn.w	r0, #54	; 0x36
   2ab06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002ab08 <l2cap_connected>:
}
   2ab08:	4770      	bx	lr

0002ab0a <l2cap_disconnected>:
   2ab0a:	4770      	bx	lr

0002ab0c <bt_l2cap_chan_remove>:
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   2ab0c:	6c43      	ldr	r3, [r0, #68]	; 0x44
{
   2ab0e:	b510      	push	{r4, lr}
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   2ab10:	b17b      	cbz	r3, 2ab32 <bt_l2cap_chan_remove+0x26>
   2ab12:	3b08      	subs	r3, #8
   2ab14:	2200      	movs	r2, #0
   2ab16:	b163      	cbz	r3, 2ab32 <bt_l2cap_chan_remove+0x26>
		if (chan == ch) {
   2ab18:	428b      	cmp	r3, r1
   2ab1a:	f103 0408 	add.w	r4, r3, #8
   2ab1e:	d10f      	bne.n	2ab40 <bt_l2cap_chan_remove+0x34>
Z_GENLIST_REMOVE(slist, snode)
   2ab20:	688b      	ldr	r3, [r1, #8]
   2ab22:	b93a      	cbnz	r2, 2ab34 <bt_l2cap_chan_remove+0x28>
   2ab24:	6c82      	ldr	r2, [r0, #72]	; 0x48
	list->head = node;
   2ab26:	6443      	str	r3, [r0, #68]	; 0x44
Z_GENLIST_REMOVE(slist, snode)
   2ab28:	4294      	cmp	r4, r2
   2ab2a:	d100      	bne.n	2ab2e <bt_l2cap_chan_remove+0x22>
	list->tail = node;
   2ab2c:	6483      	str	r3, [r0, #72]	; 0x48
	parent->next = child;
   2ab2e:	2300      	movs	r3, #0
   2ab30:	608b      	str	r3, [r1, #8]
}
   2ab32:	bd10      	pop	{r4, pc}
   2ab34:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   2ab36:	6c83      	ldr	r3, [r0, #72]	; 0x48
   2ab38:	429c      	cmp	r4, r3
	list->tail = node;
   2ab3a:	bf08      	it	eq
   2ab3c:	6482      	streq	r2, [r0, #72]	; 0x48
   2ab3e:	e7f6      	b.n	2ab2e <bt_l2cap_chan_remove+0x22>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   2ab40:	689b      	ldr	r3, [r3, #8]
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   2ab42:	2b00      	cmp	r3, #0
   2ab44:	d0f5      	beq.n	2ab32 <bt_l2cap_chan_remove+0x26>
   2ab46:	3b08      	subs	r3, #8
   2ab48:	4622      	mov	r2, r4
   2ab4a:	e7e4      	b.n	2ab16 <bt_l2cap_chan_remove+0xa>

0002ab4c <bt_l2cap_chan_del>:
	if (!chan->conn) {
   2ab4c:	6803      	ldr	r3, [r0, #0]
{
   2ab4e:	b510      	push	{r4, lr}
   2ab50:	4604      	mov	r4, r0
	if (!chan->conn) {
   2ab52:	b12b      	cbz	r3, 2ab60 <bt_l2cap_chan_del+0x14>
	if (chan->ops->disconnected) {
   2ab54:	6843      	ldr	r3, [r0, #4]
   2ab56:	685b      	ldr	r3, [r3, #4]
   2ab58:	b103      	cbz	r3, 2ab5c <bt_l2cap_chan_del+0x10>
		chan->ops->disconnected(chan);
   2ab5a:	4798      	blx	r3
	chan->conn = NULL;
   2ab5c:	2300      	movs	r3, #0
   2ab5e:	6023      	str	r3, [r4, #0]
	if (chan->destroy) {
   2ab60:	68e3      	ldr	r3, [r4, #12]
   2ab62:	b11b      	cbz	r3, 2ab6c <bt_l2cap_chan_del+0x20>
		chan->destroy(chan);
   2ab64:	4620      	mov	r0, r4
}
   2ab66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		chan->destroy(chan);
   2ab6a:	4718      	bx	r3
}
   2ab6c:	bd10      	pop	{r4, pc}

0002ab6e <bt_l2cap_disconnected>:
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   2ab6e:	6c43      	ldr	r3, [r0, #68]	; 0x44
{
   2ab70:	b510      	push	{r4, lr}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   2ab72:	b173      	cbz	r3, 2ab92 <bt_l2cap_disconnected+0x24>
   2ab74:	f1b3 0008 	subs.w	r0, r3, #8
   2ab78:	d00b      	beq.n	2ab92 <bt_l2cap_disconnected+0x24>
   2ab7a:	681c      	ldr	r4, [r3, #0]
   2ab7c:	b104      	cbz	r4, 2ab80 <bt_l2cap_disconnected+0x12>
   2ab7e:	3c08      	subs	r4, #8
		bt_l2cap_chan_del(chan);
   2ab80:	f7ff ffe4 	bl	2ab4c <bt_l2cap_chan_del>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&conn->channels, chan, next, node) {
   2ab84:	b12c      	cbz	r4, 2ab92 <bt_l2cap_disconnected+0x24>
   2ab86:	68a3      	ldr	r3, [r4, #8]
   2ab88:	b103      	cbz	r3, 2ab8c <bt_l2cap_disconnected+0x1e>
   2ab8a:	3b08      	subs	r3, #8
{
   2ab8c:	4620      	mov	r0, r4
   2ab8e:	461c      	mov	r4, r3
   2ab90:	e7f6      	b.n	2ab80 <bt_l2cap_disconnected+0x12>
}
   2ab92:	bd10      	pop	{r4, pc}

0002ab94 <bt_l2cap_create_pdu_timeout>:
	return bt_conn_create_pdu_timeout(pool,
   2ab94:	3104      	adds	r1, #4
   2ab96:	f7ed bc73 	b.w	18480 <bt_conn_create_pdu_timeout>

0002ab9a <bt_l2cap_send_cb>:
{
   2ab9a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2ab9e:	4614      	mov	r4, r2
   2aba0:	4605      	mov	r5, r0
   2aba2:	4688      	mov	r8, r1
	hdr = net_buf_push(buf, sizeof(*hdr));
   2aba4:	f102 0008 	add.w	r0, r2, #8
   2aba8:	2104      	movs	r1, #4
{
   2abaa:	461e      	mov	r6, r3
   2abac:	9f06      	ldr	r7, [sp, #24]
	hdr = net_buf_push(buf, sizeof(*hdr));
   2abae:	f002 f808 	bl	2cbc2 <net_buf_simple_push>
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   2abb2:	89a1      	ldrh	r1, [r4, #12]
	hdr->cid = sys_cpu_to_le16(cid);
   2abb4:	f8a0 8002 	strh.w	r8, [r0, #2]
	hdr->len = sys_cpu_to_le16(buf->len - sizeof(*hdr));
   2abb8:	3904      	subs	r1, #4
   2abba:	8001      	strh	r1, [r0, #0]
	return bt_conn_send_cb(conn, buf, cb, user_data);
   2abbc:	463b      	mov	r3, r7
   2abbe:	4632      	mov	r2, r6
   2abc0:	4621      	mov	r1, r4
   2abc2:	4628      	mov	r0, r5
}
   2abc4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return bt_conn_send_cb(conn, buf, cb, user_data);
   2abc8:	f7ed b840 	b.w	17c4c <bt_conn_send_cb>

0002abcc <l2cap_send_reject.constprop.14>:
static void l2cap_send_reject(struct bt_conn *conn, u8_t ident,
   2abcc:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2abce:	4605      	mov	r5, r0
	buf = l2cap_create_le_sig_pdu(NULL, BT_L2CAP_CMD_REJECT, ident,
   2abd0:	2202      	movs	r2, #2
   2abd2:	2001      	movs	r0, #1
   2abd4:	f7ed fd94 	bl	18700 <l2cap_create_le_sig_pdu.isra.8>
	if (!buf) {
   2abd8:	4604      	mov	r4, r0
   2abda:	b160      	cbz	r0, 2abf6 <l2cap_send_reject.constprop.14+0x2a>
	rej = net_buf_add(buf, sizeof(*rej));
   2abdc:	2102      	movs	r1, #2
   2abde:	3008      	adds	r0, #8
   2abe0:	f001 ffce 	bl	2cb80 <net_buf_simple_add>
	rej->reason = sys_cpu_to_le16(reason);
   2abe4:	2300      	movs	r3, #0
   2abe6:	7003      	strb	r3, [r0, #0]
   2abe8:	7043      	strb	r3, [r0, #1]
   2abea:	4622      	mov	r2, r4
   2abec:	9300      	str	r3, [sp, #0]
   2abee:	2105      	movs	r1, #5
   2abf0:	4628      	mov	r0, r5
   2abf2:	f7ff ffd2 	bl	2ab9a <bt_l2cap_send_cb>
}
   2abf6:	b003      	add	sp, #12
   2abf8:	bd30      	pop	{r4, r5, pc}

0002abfa <bt_l2cap_le_lookup_tx_cid>:
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   2abfa:	6c40      	ldr	r0, [r0, #68]	; 0x44
   2abfc:	b108      	cbz	r0, 2ac02 <bt_l2cap_le_lookup_tx_cid+0x8>
   2abfe:	3808      	subs	r0, #8
   2ac00:	b900      	cbnz	r0, 2ac04 <bt_l2cap_le_lookup_tx_cid+0xa>
}
   2ac02:	4770      	bx	lr
		if (BT_L2CAP_LE_CHAN(chan)->tx.cid == cid) {
   2ac04:	f8b0 3054 	ldrh.w	r3, [r0, #84]	; 0x54
   2ac08:	428b      	cmp	r3, r1
   2ac0a:	d0fa      	beq.n	2ac02 <bt_l2cap_le_lookup_tx_cid+0x8>
   2ac0c:	6880      	ldr	r0, [r0, #8]
   2ac0e:	e7f5      	b.n	2abfc <bt_l2cap_le_lookup_tx_cid+0x2>

0002ac10 <bt_l2cap_le_lookup_rx_cid>:
	SYS_SLIST_FOR_EACH_CONTAINER(&conn->channels, chan, node) {
   2ac10:	6c40      	ldr	r0, [r0, #68]	; 0x44
   2ac12:	b108      	cbz	r0, 2ac18 <bt_l2cap_le_lookup_rx_cid+0x8>
   2ac14:	3808      	subs	r0, #8
   2ac16:	b900      	cbnz	r0, 2ac1a <bt_l2cap_le_lookup_rx_cid+0xa>
}
   2ac18:	4770      	bx	lr
		if (BT_L2CAP_LE_CHAN(chan)->rx.cid == cid) {
   2ac1a:	8e83      	ldrh	r3, [r0, #52]	; 0x34
   2ac1c:	428b      	cmp	r3, r1
   2ac1e:	d0fb      	beq.n	2ac18 <bt_l2cap_le_lookup_rx_cid+0x8>
   2ac20:	6880      	ldr	r0, [r0, #8]
   2ac22:	e7f6      	b.n	2ac12 <bt_l2cap_le_lookup_rx_cid+0x2>

0002ac24 <bt_l2cap_init>:
void bt_l2cap_init(void)
{
	if (IS_ENABLED(CONFIG_BT_BREDR)) {
		bt_l2cap_br_init();
	}
}
   2ac24:	4770      	bx	lr

0002ac26 <att_prepare_write_req>:
}
   2ac26:	2006      	movs	r0, #6
   2ac28:	4770      	bx	lr

0002ac2a <att_op_get_type>:
	switch (op) {
   2ac2a:	280e      	cmp	r0, #14
   2ac2c:	d00a      	beq.n	2ac44 <att_op_get_type+0x1a>
   2ac2e:	d81e      	bhi.n	2ac6e <att_op_get_type+0x44>
   2ac30:	2807      	cmp	r0, #7
   2ac32:	d015      	beq.n	2ac60 <att_op_get_type+0x36>
   2ac34:	d80d      	bhi.n	2ac52 <att_op_get_type+0x28>
   2ac36:	2803      	cmp	r0, #3
   2ac38:	d012      	beq.n	2ac60 <att_op_get_type+0x36>
   2ac3a:	d805      	bhi.n	2ac48 <att_op_get_type+0x1e>
   2ac3c:	2801      	cmp	r0, #1
   2ac3e:	d00f      	beq.n	2ac60 <att_op_get_type+0x36>
   2ac40:	2802      	cmp	r0, #2
   2ac42:	d12b      	bne.n	2ac9c <att_op_get_type+0x72>
		return ATT_REQUEST;
   2ac44:	2001      	movs	r0, #1
   2ac46:	4770      	bx	lr
	switch (op) {
   2ac48:	2805      	cmp	r0, #5
		return ATT_REQUEST;
   2ac4a:	bf0c      	ite	eq
   2ac4c:	2002      	moveq	r0, #2
   2ac4e:	2001      	movne	r0, #1
   2ac50:	4770      	bx	lr
	switch (op) {
   2ac52:	280a      	cmp	r0, #10
   2ac54:	d0f6      	beq.n	2ac44 <att_op_get_type+0x1a>
   2ac56:	d805      	bhi.n	2ac64 <att_op_get_type+0x3a>
   2ac58:	2808      	cmp	r0, #8
   2ac5a:	d0f3      	beq.n	2ac44 <att_op_get_type+0x1a>
   2ac5c:	2809      	cmp	r0, #9
   2ac5e:	d11d      	bne.n	2ac9c <att_op_get_type+0x72>
		return ATT_RESPONSE;
   2ac60:	2002      	movs	r0, #2
   2ac62:	4770      	bx	lr
	switch (op) {
   2ac64:	280c      	cmp	r0, #12
		return ATT_RESPONSE;
   2ac66:	bf0c      	ite	eq
   2ac68:	2001      	moveq	r0, #1
   2ac6a:	2002      	movne	r0, #2
   2ac6c:	4770      	bx	lr
	switch (op) {
   2ac6e:	2817      	cmp	r0, #23
   2ac70:	d0f6      	beq.n	2ac60 <att_op_get_type+0x36>
   2ac72:	d80b      	bhi.n	2ac8c <att_op_get_type+0x62>
   2ac74:	2811      	cmp	r0, #17
   2ac76:	d0f3      	beq.n	2ac60 <att_op_get_type+0x36>
   2ac78:	d803      	bhi.n	2ac82 <att_op_get_type+0x58>
   2ac7a:	280f      	cmp	r0, #15
   2ac7c:	d0f0      	beq.n	2ac60 <att_op_get_type+0x36>
   2ac7e:	2810      	cmp	r0, #16
   2ac80:	e7df      	b.n	2ac42 <att_op_get_type+0x18>
   2ac82:	2813      	cmp	r0, #19
   2ac84:	d0ec      	beq.n	2ac60 <att_op_get_type+0x36>
   2ac86:	d3dd      	bcc.n	2ac44 <att_op_get_type+0x1a>
   2ac88:	2816      	cmp	r0, #22
   2ac8a:	e7da      	b.n	2ac42 <att_op_get_type+0x18>
   2ac8c:	281d      	cmp	r0, #29
   2ac8e:	d013      	beq.n	2acb8 <att_op_get_type+0x8e>
   2ac90:	d80a      	bhi.n	2aca8 <att_op_get_type+0x7e>
   2ac92:	2819      	cmp	r0, #25
   2ac94:	d0e4      	beq.n	2ac60 <att_op_get_type+0x36>
   2ac96:	d3d5      	bcc.n	2ac44 <att_op_get_type+0x1a>
   2ac98:	281b      	cmp	r0, #27
   2ac9a:	d00f      	beq.n	2acbc <att_op_get_type+0x92>
	if (op & ATT_CMD_MASK) {
   2ac9c:	f010 0f40 	tst.w	r0, #64	; 0x40
		return ATT_COMMAND;
   2aca0:	bf0c      	ite	eq
   2aca2:	2006      	moveq	r0, #6
   2aca4:	2000      	movne	r0, #0
   2aca6:	4770      	bx	lr
	switch (op) {
   2aca8:	2852      	cmp	r0, #82	; 0x52
   2acaa:	d009      	beq.n	2acc0 <att_op_get_type+0x96>
   2acac:	28d2      	cmp	r0, #210	; 0xd2
   2acae:	d007      	beq.n	2acc0 <att_op_get_type+0x96>
   2acb0:	281e      	cmp	r0, #30
   2acb2:	d1f3      	bne.n	2ac9c <att_op_get_type+0x72>
		return ATT_CONFIRMATION;
   2acb4:	2004      	movs	r0, #4
}
   2acb6:	4770      	bx	lr
		return ATT_INDICATION;
   2acb8:	2005      	movs	r0, #5
   2acba:	4770      	bx	lr
		return ATT_NOTIFICATION;
   2acbc:	2003      	movs	r0, #3
   2acbe:	4770      	bx	lr
		return ATT_COMMAND;
   2acc0:	2000      	movs	r0, #0
   2acc2:	4770      	bx	lr

0002acc4 <att_req_destroy>:
{
   2acc4:	b510      	push	{r4, lr}
   2acc6:	4604      	mov	r4, r0
	if (req->buf) {
   2acc8:	6900      	ldr	r0, [r0, #16]
   2acca:	b108      	cbz	r0, 2acd0 <att_req_destroy+0xc>
		net_buf_unref(req->buf);
   2accc:	f7fa fafe 	bl	252cc <net_buf_unref>
	if (req->destroy) {
   2acd0:	68a3      	ldr	r3, [r4, #8]
   2acd2:	b10b      	cbz	r3, 2acd8 <att_req_destroy+0x14>
		req->destroy(req);
   2acd4:	4620      	mov	r0, r4
   2acd6:	4798      	blx	r3
	(void)memset(req, 0, sizeof(*req));
   2acd8:	4620      	mov	r0, r4
   2acda:	2214      	movs	r2, #20
   2acdc:	2100      	movs	r1, #0
}
   2acde:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void)memset(req, 0, sizeof(*req));
   2ace2:	f7ff bbde 	b.w	2a4a2 <memset>

0002ace6 <att_notify>:
{
   2ace6:	b538      	push	{r3, r4, r5, lr}
	struct bt_conn *conn = att->chan.chan.conn;
   2ace8:	6805      	ldr	r5, [r0, #0]
	handle = net_buf_pull_le16(buf);
   2acea:	f101 0008 	add.w	r0, r1, #8
{
   2acee:	460c      	mov	r4, r1
	handle = net_buf_pull_le16(buf);
   2acf0:	f001 ff87 	bl	2cc02 <net_buf_simple_pull_le16>
	bt_gatt_notification(conn, handle, buf->data, buf->len);
   2acf4:	89a3      	ldrh	r3, [r4, #12]
   2acf6:	68a2      	ldr	r2, [r4, #8]
   2acf8:	4601      	mov	r1, r0
   2acfa:	4628      	mov	r0, r5
   2acfc:	f7f0 fbe4 	bl	1b4c8 <bt_gatt_notification>
}
   2ad00:	2000      	movs	r0, #0
   2ad02:	bd38      	pop	{r3, r4, r5, pc}

0002ad04 <bt_gatt_foreach_attr>:
 *  @param user_data Data to pass to the callback.
 */
static inline void bt_gatt_foreach_attr(u16_t start_handle, u16_t end_handle,
					bt_gatt_attr_func_t func,
					void *user_data)
{
   2ad04:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
   2ad06:	e9cd 2301 	strd	r2, r3, [sp, #4]
   2ad0a:	2300      	movs	r3, #0
   2ad0c:	9300      	str	r3, [sp, #0]
   2ad0e:	461a      	mov	r2, r3
   2ad10:	f7ef fab4 	bl	1a27c <bt_gatt_foreach_attr_type>
				  user_data);
}
   2ad14:	b005      	add	sp, #20
   2ad16:	f85d fb04 	ldr.w	pc, [sp], #4

0002ad1a <read_group_cb>:
{
   2ad1a:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	struct bt_att *att = data->att;
   2ad1e:	680c      	ldr	r4, [r1, #0]
{
   2ad20:	4606      	mov	r6, r0
   2ad22:	460d      	mov	r5, r1
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   2ad24:	f04f 0800 	mov.w	r8, #0
   2ad28:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   2ad2c:	a902      	add	r1, sp, #8
   2ad2e:	6800      	ldr	r0, [r0, #0]
	struct bt_conn *conn = att->chan.chan.conn;
   2ad30:	6827      	ldr	r7, [r4, #0]
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   2ad32:	f88d 8008 	strb.w	r8, [sp, #8]
   2ad36:	f8ad 300a 	strh.w	r3, [sp, #10]
   2ad3a:	f7ff fca4 	bl	2a686 <bt_uuid_cmp>
   2ad3e:	b198      	cbz	r0, 2ad68 <read_group_cb+0x4e>
	    bt_uuid_cmp(attr->uuid, BT_UUID_GATT_SECONDARY)) {
   2ad40:	f642 0301 	movw	r3, #10241	; 0x2801
   2ad44:	a903      	add	r1, sp, #12
   2ad46:	6830      	ldr	r0, [r6, #0]
   2ad48:	f88d 800c 	strb.w	r8, [sp, #12]
   2ad4c:	f8ad 300e 	strh.w	r3, [sp, #14]
   2ad50:	f7ff fc99 	bl	2a686 <bt_uuid_cmp>
	if (bt_uuid_cmp(attr->uuid, BT_UUID_GATT_PRIMARY) &&
   2ad54:	b140      	cbz	r0, 2ad68 <read_group_cb+0x4e>
		if (data->group &&
   2ad56:	692b      	ldr	r3, [r5, #16]
   2ad58:	b123      	cbz	r3, 2ad64 <read_group_cb+0x4a>
		    attr->handle > sys_le16_to_cpu(data->group->end_handle)) {
   2ad5a:	8a32      	ldrh	r2, [r6, #16]
		if (data->group &&
   2ad5c:	8859      	ldrh	r1, [r3, #2]
   2ad5e:	4291      	cmp	r1, r2
   2ad60:	d200      	bcs.n	2ad64 <read_group_cb+0x4a>
			data->group->end_handle = sys_cpu_to_le16(attr->handle);
   2ad62:	805a      	strh	r2, [r3, #2]
		return BT_GATT_ITER_CONTINUE;
   2ad64:	2001      	movs	r0, #1
   2ad66:	e012      	b.n	2ad8e <read_group_cb+0x74>
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   2ad68:	6869      	ldr	r1, [r5, #4]
   2ad6a:	6830      	ldr	r0, [r6, #0]
   2ad6c:	f7ff fc8b 	bl	2a686 <bt_uuid_cmp>
   2ad70:	b110      	cbz	r0, 2ad78 <read_group_cb+0x5e>
		data->group = NULL;
   2ad72:	2300      	movs	r3, #0
   2ad74:	612b      	str	r3, [r5, #16]
		return BT_GATT_ITER_CONTINUE;
   2ad76:	e7f5      	b.n	2ad64 <read_group_cb+0x4a>
	if (data->rsp->len &&
   2ad78:	68eb      	ldr	r3, [r5, #12]
   2ad7a:	68a8      	ldr	r0, [r5, #8]
   2ad7c:	781a      	ldrb	r2, [r3, #0]
   2ad7e:	b14a      	cbz	r2, 2ad94 <read_group_cb+0x7a>
	    att->chan.tx.mtu - data->buf->len < data->rsp->len) {
   2ad80:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
   2ad84:	8981      	ldrh	r1, [r0, #12]
   2ad86:	1a5b      	subs	r3, r3, r1
	if (data->rsp->len &&
   2ad88:	4293      	cmp	r3, r2
   2ad8a:	da03      	bge.n	2ad94 <read_group_cb+0x7a>
		return BT_GATT_ITER_STOP;
   2ad8c:	2000      	movs	r0, #0
}
   2ad8e:	b004      	add	sp, #16
   2ad90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	data->group = net_buf_add(data->buf, sizeof(*data->group));
   2ad94:	2104      	movs	r1, #4
   2ad96:	3008      	adds	r0, #8
   2ad98:	f001 fef2 	bl	2cb80 <net_buf_simple_add>
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   2ad9c:	68a9      	ldr	r1, [r5, #8]
	data->group->start_handle = sys_cpu_to_le16(attr->handle);
   2ad9e:	8a33      	ldrh	r3, [r6, #16]
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   2ada0:	898a      	ldrh	r2, [r1, #12]
	data->group = net_buf_add(data->buf, sizeof(*data->group));
   2ada2:	6128      	str	r0, [r5, #16]
	data->group->start_handle = sys_cpu_to_le16(attr->handle);
   2ada4:	8003      	strh	r3, [r0, #0]
	data->group->end_handle = sys_cpu_to_le16(attr->handle);
   2ada6:	8043      	strh	r3, [r0, #2]
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   2ada8:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
   2adac:	6889      	ldr	r1, [r1, #8]
   2adae:	2400      	movs	r4, #0
   2adb0:	1a9b      	subs	r3, r3, r2
   2adb2:	9400      	str	r4, [sp, #0]
   2adb4:	440a      	add	r2, r1
   2adb6:	f8d6 8004 	ldr.w	r8, [r6, #4]
   2adba:	4631      	mov	r1, r6
   2adbc:	b29b      	uxth	r3, r3
   2adbe:	4638      	mov	r0, r7
   2adc0:	47c0      	blx	r8
	if (read < 0) {
   2adc2:	1e01      	subs	r1, r0, #0
   2adc4:	dbe2      	blt.n	2ad8c <read_group_cb+0x72>
	if (!data->rsp->len) {
   2adc6:	68ee      	ldr	r6, [r5, #12]
   2adc8:	68ab      	ldr	r3, [r5, #8]
   2adca:	7830      	ldrb	r0, [r6, #0]
   2adcc:	1d0a      	adds	r2, r1, #4
   2adce:	b928      	cbnz	r0, 2addc <read_group_cb+0xc2>
		data->rsp->len = read + sizeof(*data->group);
   2add0:	7032      	strb	r2, [r6, #0]
	net_buf_add(data->buf, read);
   2add2:	f103 0008 	add.w	r0, r3, #8
   2add6:	f001 fed3 	bl	2cb80 <net_buf_simple_add>
	return BT_GATT_ITER_CONTINUE;
   2adda:	e7c3      	b.n	2ad64 <read_group_cb+0x4a>
	} else if (data->rsp->len != read + sizeof(*data->group)) {
   2addc:	4290      	cmp	r0, r2
   2adde:	d0f8      	beq.n	2add2 <read_group_cb+0xb8>
		data->buf->len -= sizeof(*data->group);
   2ade0:	899a      	ldrh	r2, [r3, #12]
   2ade2:	3a04      	subs	r2, #4
   2ade4:	819a      	strh	r2, [r3, #12]
		return false;
   2ade6:	e7d1      	b.n	2ad8c <read_group_cb+0x72>

0002ade8 <read_type_cb>:
{
   2ade8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
	struct bt_att *att = data->att;
   2adec:	680f      	ldr	r7, [r1, #0]
{
   2adee:	4605      	mov	r5, r0
   2adf0:	460e      	mov	r6, r1
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   2adf2:	6800      	ldr	r0, [r0, #0]
   2adf4:	6849      	ldr	r1, [r1, #4]
	struct bt_conn *conn = att->chan.chan.conn;
   2adf6:	f8d7 9000 	ldr.w	r9, [r7]
	if (bt_uuid_cmp(attr->uuid, data->uuid)) {
   2adfa:	f7ff fc44 	bl	2a686 <bt_uuid_cmp>
   2adfe:	4680      	mov	r8, r0
   2ae00:	2800      	cmp	r0, #0
   2ae02:	d14c      	bne.n	2ae9e <read_type_cb+0xb6>
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   2ae04:	2215      	movs	r2, #21
   2ae06:	4629      	mov	r1, r5
   2ae08:	4648      	mov	r0, r9
   2ae0a:	f000 fc8f 	bl	2b72c <bt_gatt_check_perm>
   2ae0e:	4604      	mov	r4, r0
   2ae10:	7530      	strb	r0, [r6, #20]
	if (data->err) {
   2ae12:	b148      	cbz	r0, 2ae28 <read_type_cb+0x40>
		if (data->rsp->len) {
   2ae14:	68f3      	ldr	r3, [r6, #12]
   2ae16:	781c      	ldrb	r4, [r3, #0]
   2ae18:	b114      	cbz	r4, 2ae20 <read_type_cb+0x38>
			data->err = 0x00;
   2ae1a:	f886 8014 	strb.w	r8, [r6, #20]
		return BT_GATT_ITER_STOP;
   2ae1e:	4644      	mov	r4, r8
}
   2ae20:	4620      	mov	r0, r4
   2ae22:	b003      	add	sp, #12
   2ae24:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	data->item = net_buf_add(data->buf, sizeof(*data->item));
   2ae28:	68b0      	ldr	r0, [r6, #8]
   2ae2a:	2102      	movs	r1, #2
   2ae2c:	3008      	adds	r0, #8
   2ae2e:	f001 fea7 	bl	2cb80 <net_buf_simple_add>
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   2ae32:	68b1      	ldr	r1, [r6, #8]
	data->item->handle = sys_cpu_to_le16(attr->handle);
   2ae34:	8a2b      	ldrh	r3, [r5, #16]
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   2ae36:	898a      	ldrh	r2, [r1, #12]
	data->item = net_buf_add(data->buf, sizeof(*data->item));
   2ae38:	6130      	str	r0, [r6, #16]
	data->item->handle = sys_cpu_to_le16(attr->handle);
   2ae3a:	8003      	strh	r3, [r0, #0]
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   2ae3c:	f8b7 3056 	ldrh.w	r3, [r7, #86]	; 0x56
   2ae40:	6889      	ldr	r1, [r1, #8]
   2ae42:	9400      	str	r4, [sp, #0]
   2ae44:	1a9b      	subs	r3, r3, r2
   2ae46:	f8d5 8004 	ldr.w	r8, [r5, #4]
   2ae4a:	440a      	add	r2, r1
   2ae4c:	b29b      	uxth	r3, r3
   2ae4e:	4629      	mov	r1, r5
   2ae50:	4648      	mov	r0, r9
   2ae52:	47c0      	blx	r8
	if (read < 0) {
   2ae54:	1e01      	subs	r1, r0, #0
   2ae56:	da07      	bge.n	2ae68 <read_type_cb+0x80>
	if (err < 0 && err >= -0xff) {
   2ae58:	f111 0fff 	cmn.w	r1, #255	; 0xff
		return -err;
   2ae5c:	bf26      	itte	cs
   2ae5e:	4249      	negcs	r1, r1
   2ae60:	b2c9      	uxtbcs	r1, r1
	return BT_ATT_ERR_UNLIKELY;
   2ae62:	210e      	movcc	r1, #14
		data->err = err_to_att(read);
   2ae64:	7531      	strb	r1, [r6, #20]
		return BT_GATT_ITER_STOP;
   2ae66:	e7db      	b.n	2ae20 <read_type_cb+0x38>
	if (!data->rsp->len) {
   2ae68:	68f5      	ldr	r5, [r6, #12]
   2ae6a:	68b0      	ldr	r0, [r6, #8]
   2ae6c:	782a      	ldrb	r2, [r5, #0]
   2ae6e:	1c8b      	adds	r3, r1, #2
   2ae70:	b97a      	cbnz	r2, 2ae92 <read_type_cb+0xaa>
		data->rsp->len = read + sizeof(*data->item);
   2ae72:	702b      	strb	r3, [r5, #0]
	net_buf_add(data->buf, read);
   2ae74:	3008      	adds	r0, #8
   2ae76:	f001 fe83 	bl	2cb80 <net_buf_simple_add>
	return att->chan.tx.mtu - data->buf->len > data->rsp->len ?
   2ae7a:	68b3      	ldr	r3, [r6, #8]
   2ae7c:	f8b7 4056 	ldrh.w	r4, [r7, #86]	; 0x56
   2ae80:	899b      	ldrh	r3, [r3, #12]
   2ae82:	1ae4      	subs	r4, r4, r3
   2ae84:	68f3      	ldr	r3, [r6, #12]
   2ae86:	781b      	ldrb	r3, [r3, #0]
	       BT_GATT_ITER_CONTINUE : BT_GATT_ITER_STOP;
   2ae88:	429c      	cmp	r4, r3
   2ae8a:	bfd4      	ite	le
   2ae8c:	2400      	movle	r4, #0
   2ae8e:	2401      	movgt	r4, #1
   2ae90:	e7c6      	b.n	2ae20 <read_type_cb+0x38>
	} else if (data->rsp->len != read + sizeof(*data->item)) {
   2ae92:	429a      	cmp	r2, r3
   2ae94:	d0ee      	beq.n	2ae74 <read_type_cb+0x8c>
		data->buf->len -= sizeof(*data->item);
   2ae96:	8983      	ldrh	r3, [r0, #12]
   2ae98:	3b02      	subs	r3, #2
   2ae9a:	8183      	strh	r3, [r0, #12]
		return BT_GATT_ITER_STOP;
   2ae9c:	e7c0      	b.n	2ae20 <read_type_cb+0x38>
		return BT_GATT_ITER_CONTINUE;
   2ae9e:	2401      	movs	r4, #1
   2aea0:	e7be      	b.n	2ae20 <read_type_cb+0x38>

0002aea2 <find_info_cb>:
	if (!data->rsp) {
   2aea2:	688b      	ldr	r3, [r1, #8]
{
   2aea4:	b570      	push	{r4, r5, r6, lr}
   2aea6:	4605      	mov	r5, r0
   2aea8:	460c      	mov	r4, r1
	struct bt_att *att = data->att;
   2aeaa:	680e      	ldr	r6, [r1, #0]
	if (!data->rsp) {
   2aeac:	b963      	cbnz	r3, 2aec8 <find_info_cb+0x26>
		data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   2aeae:	6848      	ldr	r0, [r1, #4]
   2aeb0:	2101      	movs	r1, #1
   2aeb2:	3008      	adds	r0, #8
   2aeb4:	f001 fe64 	bl	2cb80 <net_buf_simple_add>
		data->rsp->format = (attr->uuid->type == BT_UUID_TYPE_16) ?
   2aeb8:	682b      	ldr	r3, [r5, #0]
		data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   2aeba:	60a0      	str	r0, [r4, #8]
		data->rsp->format = (attr->uuid->type == BT_UUID_TYPE_16) ?
   2aebc:	781b      	ldrb	r3, [r3, #0]
   2aebe:	2b00      	cmp	r3, #0
   2aec0:	bf0c      	ite	eq
   2aec2:	2301      	moveq	r3, #1
   2aec4:	2302      	movne	r3, #2
   2aec6:	7003      	strb	r3, [r0, #0]
	switch (data->rsp->format) {
   2aec8:	68a3      	ldr	r3, [r4, #8]
   2aeca:	781b      	ldrb	r3, [r3, #0]
   2aecc:	2b01      	cmp	r3, #1
   2aece:	d003      	beq.n	2aed8 <find_info_cb+0x36>
   2aed0:	2b02      	cmp	r3, #2
   2aed2:	d01a      	beq.n	2af0a <find_info_cb+0x68>
			return BT_GATT_ITER_STOP;
   2aed4:	2000      	movs	r0, #0
   2aed6:	e017      	b.n	2af08 <find_info_cb+0x66>
		if (attr->uuid->type != BT_UUID_TYPE_16) {
   2aed8:	682b      	ldr	r3, [r5, #0]
   2aeda:	781b      	ldrb	r3, [r3, #0]
   2aedc:	2b00      	cmp	r3, #0
   2aede:	d1f9      	bne.n	2aed4 <find_info_cb+0x32>
		data->info16 = net_buf_add(data->buf, sizeof(*data->info16));
   2aee0:	6860      	ldr	r0, [r4, #4]
   2aee2:	2104      	movs	r1, #4
   2aee4:	3008      	adds	r0, #8
   2aee6:	f001 fe4b 	bl	2cb80 <net_buf_simple_add>
		data->info16->handle = sys_cpu_to_le16(attr->handle);
   2aeea:	8a2b      	ldrh	r3, [r5, #16]
		data->info16 = net_buf_add(data->buf, sizeof(*data->info16));
   2aeec:	60e0      	str	r0, [r4, #12]
		data->info16->handle = sys_cpu_to_le16(attr->handle);
   2aeee:	8003      	strh	r3, [r0, #0]
		data->info16->uuid = sys_cpu_to_le16(BT_UUID_16(attr->uuid)->val);
   2aef0:	682b      	ldr	r3, [r5, #0]
   2aef2:	885b      	ldrh	r3, [r3, #2]
   2aef4:	8043      	strh	r3, [r0, #2]
		if (att->chan.tx.mtu - data->buf->len >
   2aef6:	6863      	ldr	r3, [r4, #4]
   2aef8:	f8b6 0056 	ldrh.w	r0, [r6, #86]	; 0x56
   2aefc:	899b      	ldrh	r3, [r3, #12]
   2aefe:	1ac0      	subs	r0, r0, r3
			return BT_GATT_ITER_STOP;
   2af00:	2804      	cmp	r0, #4
   2af02:	bf94      	ite	ls
   2af04:	2000      	movls	r0, #0
   2af06:	2001      	movhi	r0, #1
}
   2af08:	bd70      	pop	{r4, r5, r6, pc}
		if (attr->uuid->type != BT_UUID_TYPE_128) {
   2af0a:	682b      	ldr	r3, [r5, #0]
   2af0c:	781b      	ldrb	r3, [r3, #0]
   2af0e:	2b02      	cmp	r3, #2
   2af10:	d1e0      	bne.n	2aed4 <find_info_cb+0x32>
		data->info128 = net_buf_add(data->buf, sizeof(*data->info128));
   2af12:	6860      	ldr	r0, [r4, #4]
   2af14:	2112      	movs	r1, #18
   2af16:	3008      	adds	r0, #8
   2af18:	f001 fe32 	bl	2cb80 <net_buf_simple_add>
		memcpy(data->info128->uuid, BT_UUID_128(attr->uuid)->val,
   2af1c:	6829      	ldr	r1, [r5, #0]
		data->info128->handle = sys_cpu_to_le16(attr->handle);
   2af1e:	8a2b      	ldrh	r3, [r5, #16]
		data->info128 = net_buf_add(data->buf, sizeof(*data->info128));
   2af20:	60e0      	str	r0, [r4, #12]
		memcpy(data->info128->uuid, BT_UUID_128(attr->uuid)->val,
   2af22:	2210      	movs	r2, #16
		data->info128->handle = sys_cpu_to_le16(attr->handle);
   2af24:	f820 3b02 	strh.w	r3, [r0], #2
		memcpy(data->info128->uuid, BT_UUID_128(attr->uuid)->val,
   2af28:	3101      	adds	r1, #1
   2af2a:	f7ff fa90 	bl	2a44e <memcpy>
		if (att->chan.tx.mtu - data->buf->len >
   2af2e:	6863      	ldr	r3, [r4, #4]
   2af30:	f8b6 0056 	ldrh.w	r0, [r6, #86]	; 0x56
   2af34:	899b      	ldrh	r3, [r3, #12]
   2af36:	1ac0      	subs	r0, r0, r3
			return BT_GATT_ITER_STOP;
   2af38:	2812      	cmp	r0, #18
   2af3a:	e7e2      	b.n	2af02 <find_info_cb+0x60>

0002af3c <att_exec_write_req>:
   2af3c:	2006      	movs	r0, #6
   2af3e:	4770      	bx	lr

0002af40 <att_pdu_sent>:
{
   2af40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   2af44:	2104      	movs	r1, #4
{
   2af46:	4680      	mov	r8, r0
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   2af48:	f7ff fe57 	bl	2abfa <bt_l2cap_le_lookup_tx_cid>
   2af4c:	4606      	mov	r6, r0
	while ((buf = net_buf_get(&att->tx_queue, K_NO_WAIT))) {
   2af4e:	f100 07f4 	add.w	r7, r0, #244	; 0xf4
   2af52:	2100      	movs	r1, #0
   2af54:	4638      	mov	r0, r7
   2af56:	f001 fde5 	bl	2cb24 <net_buf_get>
   2af5a:	4604      	mov	r4, r0
   2af5c:	b928      	cbnz	r0, 2af6a <att_pdu_sent+0x2a>
	z_impl_k_sem_give(sem);
   2af5e:	f106 00dc 	add.w	r0, r6, #220	; 0xdc
}
   2af62:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   2af66:	f7fc b8cf 	b.w	27108 <z_impl_k_sem_give>
		if (att->req && att->req->buf == buf) {
   2af6a:	f8d6 50b0 	ldr.w	r5, [r6, #176]	; 0xb0
   2af6e:	b14d      	cbz	r5, 2af84 <att_pdu_sent+0x44>
   2af70:	692b      	ldr	r3, [r5, #16]
   2af72:	429c      	cmp	r4, r3
   2af74:	d106      	bne.n	2af84 <att_pdu_sent+0x44>
	state->offset = net_buf_simple_headroom(buf);
   2af76:	f104 0008 	add.w	r0, r4, #8
   2af7a:	f001 fe4a 	bl	2cc12 <net_buf_simple_headroom>
	state->len = buf->len;
   2af7e:	89a3      	ldrh	r3, [r4, #12]
	state->offset = net_buf_simple_headroom(buf);
   2af80:	81a8      	strh	r0, [r5, #12]
	state->len = buf->len;
   2af82:	81eb      	strh	r3, [r5, #14]
		if (!att_send(conn, buf, NULL, NULL)) {
   2af84:	2300      	movs	r3, #0
   2af86:	461a      	mov	r2, r3
   2af88:	4621      	mov	r1, r4
   2af8a:	4640      	mov	r0, r8
   2af8c:	f7ed fe68 	bl	18c60 <att_send>
   2af90:	2800      	cmp	r0, #0
   2af92:	d1de      	bne.n	2af52 <att_pdu_sent+0x12>
}
   2af94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0002af98 <att_cfm_sent>:
{
   2af98:	b538      	push	{r3, r4, r5, lr}
   2af9a:	460d      	mov	r5, r1
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   2af9c:	2104      	movs	r1, #4
{
   2af9e:	4604      	mov	r4, r0
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   2afa0:	f7ff fe2b 	bl	2abfa <bt_l2cap_le_lookup_tx_cid>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2afa4:	f3bf 8f5b 	dmb	ish
   2afa8:	30ac      	adds	r0, #172	; 0xac
   2afaa:	e850 3f00 	ldrex	r3, [r0]
   2afae:	f023 0302 	bic.w	r3, r3, #2
   2afb2:	e840 3200 	strex	r2, r3, [r0]
   2afb6:	2a00      	cmp	r2, #0
   2afb8:	d1f7      	bne.n	2afaa <att_cfm_sent+0x12>
   2afba:	f3bf 8f5b 	dmb	ish
	att_pdu_sent(conn, user_data);
   2afbe:	4629      	mov	r1, r5
   2afc0:	4620      	mov	r0, r4
}
   2afc2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	att_pdu_sent(conn, user_data);
   2afc6:	f7ff bfbb 	b.w	2af40 <att_pdu_sent>

0002afca <att_rsp_sent>:
{
   2afca:	b538      	push	{r3, r4, r5, lr}
   2afcc:	460d      	mov	r5, r1
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   2afce:	2104      	movs	r1, #4
{
   2afd0:	4604      	mov	r4, r0
	chan = bt_l2cap_le_lookup_tx_cid(conn, BT_L2CAP_CID_ATT);
   2afd2:	f7ff fe12 	bl	2abfa <bt_l2cap_le_lookup_tx_cid>
   2afd6:	f3bf 8f5b 	dmb	ish
   2afda:	30ac      	adds	r0, #172	; 0xac
   2afdc:	e850 3f00 	ldrex	r3, [r0]
   2afe0:	f023 0301 	bic.w	r3, r3, #1
   2afe4:	e840 3200 	strex	r2, r3, [r0]
   2afe8:	2a00      	cmp	r2, #0
   2afea:	d1f7      	bne.n	2afdc <att_rsp_sent+0x12>
   2afec:	f3bf 8f5b 	dmb	ish
	att_pdu_sent(conn, user_data);
   2aff0:	4629      	mov	r1, r5
   2aff2:	4620      	mov	r0, r4
}
   2aff4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	att_pdu_sent(conn, user_data);
   2aff8:	f7ff bfa2 	b.w	2af40 <att_pdu_sent>

0002affc <write_cb>:
{
   2affc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2affe:	460c      	mov	r4, r1
   2b000:	4606      	mov	r6, r0
	data->err = bt_gatt_check_perm(data->conn, attr,
   2b002:	4601      	mov	r1, r0
   2b004:	222a      	movs	r2, #42	; 0x2a
   2b006:	6820      	ldr	r0, [r4, #0]
   2b008:	f000 fb90 	bl	2b72c <bt_gatt_check_perm>
   2b00c:	4605      	mov	r5, r0
   2b00e:	7520      	strb	r0, [r4, #20]
	if (data->err) {
   2b010:	bb00      	cbnz	r0, 2b054 <write_cb+0x58>
	if (!data->req) {
   2b012:	7a23      	ldrb	r3, [r4, #8]
	write = attr->write(data->conn, attr, data->value, data->len,
   2b014:	68b7      	ldr	r7, [r6, #8]
   2b016:	68e2      	ldr	r2, [r4, #12]
   2b018:	6820      	ldr	r0, [r4, #0]
	if (!data->req) {
   2b01a:	2b00      	cmp	r3, #0
		flags |= BT_GATT_WRITE_FLAG_CMD;
   2b01c:	bf14      	ite	ne
   2b01e:	2300      	movne	r3, #0
   2b020:	2302      	moveq	r3, #2
	write = attr->write(data->conn, attr, data->value, data->len,
   2b022:	9301      	str	r3, [sp, #4]
   2b024:	8a63      	ldrh	r3, [r4, #18]
   2b026:	9300      	str	r3, [sp, #0]
   2b028:	4631      	mov	r1, r6
   2b02a:	8a23      	ldrh	r3, [r4, #16]
   2b02c:	47b8      	blx	r7
	if (write < 0 || write != data->len) {
   2b02e:	2800      	cmp	r0, #0
   2b030:	db05      	blt.n	2b03e <write_cb+0x42>
   2b032:	8a23      	ldrh	r3, [r4, #16]
   2b034:	4298      	cmp	r0, r3
   2b036:	d10b      	bne.n	2b050 <write_cb+0x54>
	data->err = 0U;
   2b038:	7525      	strb	r5, [r4, #20]
	return BT_GATT_ITER_CONTINUE;
   2b03a:	2501      	movs	r5, #1
   2b03c:	e005      	b.n	2b04a <write_cb+0x4e>
	if (err < 0 && err >= -0xff) {
   2b03e:	f110 0fff 	cmn.w	r0, #255	; 0xff
   2b042:	d305      	bcc.n	2b050 <write_cb+0x54>
		return -err;
   2b044:	4240      	negs	r0, r0
   2b046:	b2c0      	uxtb	r0, r0
		data->err = err_to_att(write);
   2b048:	7520      	strb	r0, [r4, #20]
}
   2b04a:	4628      	mov	r0, r5
   2b04c:	b003      	add	sp, #12
   2b04e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return BT_ATT_ERR_UNLIKELY;
   2b050:	200e      	movs	r0, #14
   2b052:	e7f9      	b.n	2b048 <write_cb+0x4c>
		return BT_GATT_ITER_STOP;
   2b054:	2500      	movs	r5, #0
   2b056:	e7f8      	b.n	2b04a <write_cb+0x4e>

0002b058 <read_cb>:
{
   2b058:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   2b05c:	4606      	mov	r6, r0
	data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   2b05e:	6888      	ldr	r0, [r1, #8]
	struct bt_att *att = data->att;
   2b060:	f8d1 9000 	ldr.w	r9, [r1]
{
   2b064:	460c      	mov	r4, r1
	data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   2b066:	3008      	adds	r0, #8
   2b068:	2100      	movs	r1, #0
	struct bt_conn *conn = att->chan.chan.conn;
   2b06a:	f8d9 8000 	ldr.w	r8, [r9]
	data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   2b06e:	f001 fd87 	bl	2cb80 <net_buf_simple_add>
	data->err = 0x00;
   2b072:	2700      	movs	r7, #0
	data->rsp = net_buf_add(data->buf, sizeof(*data->rsp));
   2b074:	60e0      	str	r0, [r4, #12]
	data->err = 0x00;
   2b076:	7427      	strb	r7, [r4, #16]
	data->err = bt_gatt_check_perm(conn, attr, BT_GATT_PERM_READ_MASK);
   2b078:	2215      	movs	r2, #21
   2b07a:	4631      	mov	r1, r6
   2b07c:	4640      	mov	r0, r8
   2b07e:	f000 fb55 	bl	2b72c <bt_gatt_check_perm>
   2b082:	4605      	mov	r5, r0
   2b084:	7420      	strb	r0, [r4, #16]
	if (data->err) {
   2b086:	bb00      	cbnz	r0, 2b0ca <read_cb+0x72>
	read = attr->read(conn, attr, data->buf->data + data->buf->len,
   2b088:	68a1      	ldr	r1, [r4, #8]
   2b08a:	f8b9 3056 	ldrh.w	r3, [r9, #86]	; 0x56
   2b08e:	898a      	ldrh	r2, [r1, #12]
   2b090:	6889      	ldr	r1, [r1, #8]
   2b092:	88a0      	ldrh	r0, [r4, #4]
   2b094:	9000      	str	r0, [sp, #0]
   2b096:	1a9b      	subs	r3, r3, r2
   2b098:	6877      	ldr	r7, [r6, #4]
   2b09a:	440a      	add	r2, r1
   2b09c:	b29b      	uxth	r3, r3
   2b09e:	4631      	mov	r1, r6
   2b0a0:	4640      	mov	r0, r8
   2b0a2:	47b8      	blx	r7
	if (read < 0) {
   2b0a4:	1e01      	subs	r1, r0, #0
   2b0a6:	da0a      	bge.n	2b0be <read_cb+0x66>
	if (err < 0 && err >= -0xff) {
   2b0a8:	f111 0fff 	cmn.w	r1, #255	; 0xff
		return -err;
   2b0ac:	bf26      	itte	cs
   2b0ae:	4249      	negcs	r1, r1
   2b0b0:	b2c9      	uxtbcs	r1, r1
	return BT_ATT_ERR_UNLIKELY;
   2b0b2:	210e      	movcc	r1, #14
		data->err = err_to_att(read);
   2b0b4:	7421      	strb	r1, [r4, #16]
}
   2b0b6:	4628      	mov	r0, r5
   2b0b8:	b003      	add	sp, #12
   2b0ba:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	net_buf_add(data->buf, read);
   2b0be:	68a0      	ldr	r0, [r4, #8]
   2b0c0:	3008      	adds	r0, #8
   2b0c2:	f001 fd5d 	bl	2cb80 <net_buf_simple_add>
	return BT_GATT_ITER_CONTINUE;
   2b0c6:	2501      	movs	r5, #1
   2b0c8:	e7f5      	b.n	2b0b6 <read_cb+0x5e>
		return BT_GATT_ITER_STOP;
   2b0ca:	463d      	mov	r5, r7
   2b0cc:	e7f3      	b.n	2b0b6 <read_cb+0x5e>

0002b0ce <att_handle_find_info_rsp>:
	return att_handle_rsp(att, buf->data, buf->len, 0);
   2b0ce:	898a      	ldrh	r2, [r1, #12]
   2b0d0:	6889      	ldr	r1, [r1, #8]
   2b0d2:	2300      	movs	r3, #0
   2b0d4:	f7ed bf04 	b.w	18ee0 <att_handle_rsp>

0002b0d8 <att_handle_find_type_rsp>:
   2b0d8:	f7ff bff9 	b.w	2b0ce <att_handle_find_info_rsp>

0002b0dc <att_handle_read_type_rsp>:
   2b0dc:	f7ff bff7 	b.w	2b0ce <att_handle_find_info_rsp>

0002b0e0 <att_handle_read_rsp>:
   2b0e0:	f7ff bff5 	b.w	2b0ce <att_handle_find_info_rsp>

0002b0e4 <att_handle_read_blob_rsp>:
   2b0e4:	f7ff bff3 	b.w	2b0ce <att_handle_find_info_rsp>

0002b0e8 <att_handle_read_mult_rsp>:
   2b0e8:	f7ff bff1 	b.w	2b0ce <att_handle_find_info_rsp>

0002b0ec <att_handle_read_group_rsp>:
   2b0ec:	f7ff bfef 	b.w	2b0ce <att_handle_find_info_rsp>

0002b0f0 <att_handle_write_rsp>:
   2b0f0:	f7ff bfed 	b.w	2b0ce <att_handle_find_info_rsp>

0002b0f4 <att_handle_prepare_write_rsp>:
   2b0f4:	f7ff bfeb 	b.w	2b0ce <att_handle_find_info_rsp>

0002b0f8 <att_handle_exec_write_rsp>:
   2b0f8:	f7ff bfe9 	b.w	2b0ce <att_handle_find_info_rsp>

0002b0fc <att_confirm>:
   2b0fc:	f7ff bfe7 	b.w	2b0ce <att_handle_find_info_rsp>

0002b100 <att_mtu_rsp>:
{
   2b100:	b410      	push	{r4}
   2b102:	460a      	mov	r2, r1
	if (!att) {
   2b104:	b190      	cbz	r0, 2b12c <att_mtu_rsp+0x2c>
	rsp = (void *)buf->data;
   2b106:	6889      	ldr	r1, [r1, #8]
	mtu = sys_le16_to_cpu(rsp->mtu);
   2b108:	880b      	ldrh	r3, [r1, #0]
	if (mtu < BT_ATT_DEFAULT_LE_MTU) {
   2b10a:	2b16      	cmp	r3, #22
   2b10c:	d805      	bhi.n	2b11a <att_mtu_rsp+0x1a>
		return att_handle_rsp(att, NULL, 0, BT_ATT_ERR_INVALID_PDU);
   2b10e:	2200      	movs	r2, #0
   2b110:	2304      	movs	r3, #4
   2b112:	4611      	mov	r1, r2
}
   2b114:	bc10      	pop	{r4}
	return att_handle_rsp(att, rsp, buf->len, 0);
   2b116:	f7ed bee3 	b.w	18ee0 <att_handle_rsp>
	att->chan.rx.mtu = MIN(mtu, BT_ATT_MTU);
   2b11a:	2bfc      	cmp	r3, #252	; 0xfc
   2b11c:	bf28      	it	cs
   2b11e:	23fc      	movcs	r3, #252	; 0xfc
   2b120:	86c3      	strh	r3, [r0, #54]	; 0x36
	att->chan.tx.mtu = att->chan.rx.mtu;
   2b122:	f8a0 3056 	strh.w	r3, [r0, #86]	; 0x56
	return att_handle_rsp(att, rsp, buf->len, 0);
   2b126:	8992      	ldrh	r2, [r2, #12]
   2b128:	2300      	movs	r3, #0
   2b12a:	e7f3      	b.n	2b114 <att_mtu_rsp+0x14>
}
   2b12c:	bc10      	pop	{r4}
   2b12e:	4770      	bx	lr

0002b130 <att_reset>:
{
   2b130:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2b132:	4604      	mov	r4, r0
	while ((buf = k_fifo_get(&att->tx_queue, K_NO_WAIT))) {
   2b134:	f100 05f4 	add.w	r5, r0, #244	; 0xf4
	return z_impl_k_queue_get(queue, timeout);
   2b138:	2100      	movs	r1, #0
   2b13a:	4628      	mov	r0, r5
   2b13c:	f002 f80a 	bl	2d154 <z_impl_k_queue_get>
   2b140:	bb00      	cbnz	r0, 2b184 <att_reset+0x54>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2b142:	f3bf 8f5b 	dmb	ish
   2b146:	f104 03ac 	add.w	r3, r4, #172	; 0xac
   2b14a:	e853 2f00 	ldrex	r2, [r3]
   2b14e:	f042 0204 	orr.w	r2, r2, #4
   2b152:	e843 2100 	strex	r1, r2, [r3]
   2b156:	2900      	cmp	r1, #0
   2b158:	d1f7      	bne.n	2b14a <att_reset+0x1a>
   2b15a:	f3bf 8f5b 	dmb	ish
   2b15e:	2506      	movs	r5, #6
		k_sem_give(&att->tx_sem);
   2b160:	f104 06dc 	add.w	r6, r4, #220	; 0xdc
	z_impl_k_sem_give(sem);
   2b164:	4630      	mov	r0, r6
   2b166:	f7fb ffcf 	bl	27108 <z_impl_k_sem_give>
	for (i = 0; i < CONFIG_BT_ATT_TX_MAX; i++) {
   2b16a:	3d01      	subs	r5, #1
   2b16c:	d1fa      	bne.n	2b164 <att_reset+0x34>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->reqs, req, tmp, node) {
   2b16e:	f8d4 50b4 	ldr.w	r5, [r4, #180]	; 0xb4
   2b172:	b955      	cbnz	r5, 2b18a <att_reset+0x5a>
	if (!att->req) {
   2b174:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
	list->head = NULL;
   2b178:	2200      	movs	r2, #0
	list->tail = NULL;
   2b17a:	e9c4 222d 	strd	r2, r2, [r4, #180]	; 0xb4
   2b17e:	b9ab      	cbnz	r3, 2b1ac <att_reset+0x7c>
}
   2b180:	b003      	add	sp, #12
   2b182:	bdf0      	pop	{r4, r5, r6, r7, pc}
		net_buf_unref(buf);
   2b184:	f7fa f8a2 	bl	252cc <net_buf_unref>
   2b188:	e7d6      	b.n	2b138 <att_reset+0x8>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   2b18a:	682e      	ldr	r6, [r5, #0]
		if (req->func) {
   2b18c:	686f      	ldr	r7, [r5, #4]
   2b18e:	b12f      	cbz	r7, 2b19c <att_reset+0x6c>
			req->func(NULL, BT_ATT_ERR_UNLIKELY, NULL, 0, req);
   2b190:	2300      	movs	r3, #0
   2b192:	9500      	str	r5, [sp, #0]
   2b194:	461a      	mov	r2, r3
   2b196:	210e      	movs	r1, #14
   2b198:	4618      	mov	r0, r3
   2b19a:	47b8      	blx	r7
		att_req_destroy(req);
   2b19c:	4628      	mov	r0, r5
   2b19e:	f7ff fd91 	bl	2acc4 <att_req_destroy>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&att->reqs, req, tmp, node) {
   2b1a2:	2e00      	cmp	r6, #0
   2b1a4:	d0e6      	beq.n	2b174 <att_reset+0x44>
   2b1a6:	4635      	mov	r5, r6
   2b1a8:	6836      	ldr	r6, [r6, #0]
   2b1aa:	e7ef      	b.n	2b18c <att_reset+0x5c>
	att_handle_rsp(att, NULL, 0, BT_ATT_ERR_UNLIKELY);
   2b1ac:	230e      	movs	r3, #14
   2b1ae:	4611      	mov	r1, r2
   2b1b0:	4620      	mov	r0, r4
}
   2b1b2:	b003      	add	sp, #12
   2b1b4:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	att_handle_rsp(att, NULL, 0, BT_ATT_ERR_UNLIKELY);
   2b1b8:	f7ed be92 	b.w	18ee0 <att_handle_rsp>

0002b1bc <bt_att_disconnected>:
{
   2b1bc:	b510      	push	{r4, lr}
   2b1be:	4604      	mov	r4, r0
	att_reset(att);
   2b1c0:	f7ff ffb6 	bl	2b130 <att_reset>
	bt_gatt_disconnected(ch->chan.conn);
   2b1c4:	6820      	ldr	r0, [r4, #0]
}
   2b1c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	bt_gatt_disconnected(ch->chan.conn);
   2b1ca:	f7f0 ba03 	b.w	1b5d4 <bt_gatt_disconnected>

0002b1ce <att_read_blob_req>:
{
   2b1ce:	b507      	push	{r0, r1, r2, lr}
	req = (void *)buf->data;
   2b1d0:	688a      	ldr	r2, [r1, #8]
	return att_read_rsp(att, BT_ATT_OP_READ_BLOB_REQ,
   2b1d2:	8813      	ldrh	r3, [r2, #0]
   2b1d4:	8852      	ldrh	r2, [r2, #2]
   2b1d6:	9200      	str	r2, [sp, #0]
   2b1d8:	210c      	movs	r1, #12
   2b1da:	220d      	movs	r2, #13
   2b1dc:	f7ee f9ce 	bl	1957c <att_read_rsp>
}
   2b1e0:	b003      	add	sp, #12
   2b1e2:	f85d fb04 	ldr.w	pc, [sp], #4

0002b1e6 <att_read_req>:
{
   2b1e6:	b507      	push	{r0, r1, r2, lr}
	handle = sys_le16_to_cpu(req->handle);
   2b1e8:	688b      	ldr	r3, [r1, #8]
	return att_read_rsp(att, BT_ATT_OP_READ_REQ, BT_ATT_OP_READ_RSP,
   2b1ea:	2200      	movs	r2, #0
   2b1ec:	881b      	ldrh	r3, [r3, #0]
   2b1ee:	9200      	str	r2, [sp, #0]
   2b1f0:	210a      	movs	r1, #10
   2b1f2:	220b      	movs	r2, #11
   2b1f4:	f7ee f9c2 	bl	1957c <att_read_rsp>
}
   2b1f8:	b003      	add	sp, #12
   2b1fa:	f85d fb04 	ldr.w	pc, [sp], #4

0002b1fe <bt_att_init>:
	bt_gatt_init();
   2b1fe:	f7ee bfbf 	b.w	1a180 <bt_gatt_init>

0002b202 <bt_att_get_mtu>:
{
   2b202:	b508      	push	{r3, lr}
	att = att_chan_get(conn);
   2b204:	f7ed fdbc 	bl	18d80 <att_chan_get>
	if (!att) {
   2b208:	b108      	cbz	r0, 2b20e <bt_att_get_mtu+0xc>
	return att->chan.tx.mtu;
   2b20a:	f8b0 0056 	ldrh.w	r0, [r0, #86]	; 0x56
}
   2b20e:	bd08      	pop	{r3, pc}

0002b210 <bt_att_send>:
{
   2b210:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2b214:	4607      	mov	r7, r0
   2b216:	460d      	mov	r5, r1
   2b218:	4614      	mov	r4, r2
   2b21a:	4698      	mov	r8, r3
	att = att_chan_get(conn);
   2b21c:	f7ed fdb0 	bl	18d80 <att_chan_get>
	if (!att) {
   2b220:	4606      	mov	r6, r0
   2b222:	b938      	cbnz	r0, 2b234 <bt_att_send+0x24>
		net_buf_unref(buf);
   2b224:	4628      	mov	r0, r5
   2b226:	f7fa f851 	bl	252cc <net_buf_unref>
		return -ENOTCONN;
   2b22a:	f06f 0538 	mvn.w	r5, #56	; 0x38
}
   2b22e:	4628      	mov	r0, r5
   2b230:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!cb) {
   2b234:	b964      	cbnz	r4, 2b250 <bt_att_send+0x40>
	return z_impl_k_sem_take(sem, timeout);
   2b236:	4621      	mov	r1, r4
   2b238:	30dc      	adds	r0, #220	; 0xdc
   2b23a:	f7fb ff91 	bl	27160 <z_impl_k_sem_take>
		if (k_sem_take(&att->tx_sem, K_NO_WAIT) < 0) {
   2b23e:	2800      	cmp	r0, #0
   2b240:	da06      	bge.n	2b250 <bt_att_send+0x40>
			k_fifo_put(&att->tx_queue, buf);
   2b242:	4629      	mov	r1, r5
   2b244:	f106 00f4 	add.w	r0, r6, #244	; 0xf4
   2b248:	f001 ff5b 	bl	2d102 <k_queue_append>
			return 0;
   2b24c:	4625      	mov	r5, r4
   2b24e:	e7ee      	b.n	2b22e <bt_att_send+0x1e>
	err = att_send(conn, buf, cb, user_data);
   2b250:	4629      	mov	r1, r5
   2b252:	4643      	mov	r3, r8
   2b254:	4622      	mov	r2, r4
   2b256:	4638      	mov	r0, r7
   2b258:	f7ed fd02 	bl	18c60 <att_send>
	if (err) {
   2b25c:	4605      	mov	r5, r0
   2b25e:	2800      	cmp	r0, #0
   2b260:	d0e5      	beq.n	2b22e <bt_att_send+0x1e>
		if (!cb) {
   2b262:	2c00      	cmp	r4, #0
   2b264:	d1e3      	bne.n	2b22e <bt_att_send+0x1e>
	z_impl_k_sem_give(sem);
   2b266:	f106 00dc 	add.w	r0, r6, #220	; 0xdc
   2b26a:	f7fb ff4d 	bl	27108 <z_impl_k_sem_give>
   2b26e:	e7de      	b.n	2b22e <bt_att_send+0x1e>

0002b270 <bt_att_req_send>:
{
   2b270:	b538      	push	{r3, r4, r5, lr}
   2b272:	460c      	mov	r4, r1
	att = att_chan_get(conn);
   2b274:	f7ed fd84 	bl	18d80 <att_chan_get>
	if (!att) {
   2b278:	4605      	mov	r5, r0
   2b27a:	b930      	cbnz	r0, 2b28a <bt_att_req_send+0x1a>
		net_buf_unref(req->buf);
   2b27c:	6920      	ldr	r0, [r4, #16]
   2b27e:	f7fa f825 	bl	252cc <net_buf_unref>
		req->buf = NULL;
   2b282:	6125      	str	r5, [r4, #16]
		return -ENOTCONN;
   2b284:	f06f 0038 	mvn.w	r0, #56	; 0x38
}
   2b288:	bd38      	pop	{r3, r4, r5, pc}
	if (att->req) {
   2b28a:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
   2b28e:	b163      	cbz	r3, 2b2aa <bt_att_req_send+0x3a>
	parent->next = child;
   2b290:	2000      	movs	r0, #0
   2b292:	6020      	str	r0, [r4, #0]
Z_GENLIST_APPEND(slist, snode)
   2b294:	f8d5 30b8 	ldr.w	r3, [r5, #184]	; 0xb8
   2b298:	b91b      	cbnz	r3, 2b2a2 <bt_att_req_send+0x32>
	list->head = node;
   2b29a:	e9c5 442d 	strd	r4, r4, [r5, #180]	; 0xb4
		return 0;
   2b29e:	4618      	mov	r0, r3
   2b2a0:	e7f2      	b.n	2b288 <bt_att_req_send+0x18>
	parent->next = child;
   2b2a2:	601c      	str	r4, [r3, #0]
	list->tail = node;
   2b2a4:	f8c5 40b8 	str.w	r4, [r5, #184]	; 0xb8
   2b2a8:	e7ee      	b.n	2b288 <bt_att_req_send+0x18>
	return att_send_req(att, req);
   2b2aa:	4621      	mov	r1, r4
}
   2b2ac:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return att_send_req(att, req);
   2b2b0:	f7ed bdd6 	b.w	18e60 <att_send_req>

0002b2b4 <sys_slist_remove>:
Z_GENLIST_REMOVE(slist, snode)
   2b2b4:	6813      	ldr	r3, [r2, #0]
   2b2b6:	b939      	cbnz	r1, 2b2c8 <sys_slist_remove+0x14>
   2b2b8:	6841      	ldr	r1, [r0, #4]
	list->head = node;
   2b2ba:	6003      	str	r3, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   2b2bc:	428a      	cmp	r2, r1
   2b2be:	d100      	bne.n	2b2c2 <sys_slist_remove+0xe>
	list->tail = node;
   2b2c0:	6043      	str	r3, [r0, #4]
	parent->next = child;
   2b2c2:	2300      	movs	r3, #0
   2b2c4:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   2b2c6:	4770      	bx	lr
	parent->next = child;
   2b2c8:	600b      	str	r3, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
   2b2ca:	6843      	ldr	r3, [r0, #4]
   2b2cc:	429a      	cmp	r2, r3
	list->tail = node;
   2b2ce:	bf08      	it	eq
   2b2d0:	6041      	streq	r1, [r0, #4]
   2b2d2:	e7f6      	b.n	2b2c2 <sys_slist_remove+0xe>

0002b2d4 <found_attr>:
	*found = attr;
   2b2d4:	6008      	str	r0, [r1, #0]
}
   2b2d6:	2000      	movs	r0, #0
   2b2d8:	4770      	bx	lr

0002b2da <gatt_ccc_changed>:
		if (ccc->cfg[i].value > value) {
   2b2da:	8a4b      	ldrh	r3, [r1, #18]
{
   2b2dc:	460a      	mov	r2, r1
   2b2de:	8b89      	ldrh	r1, [r1, #28]
   2b2e0:	428b      	cmp	r3, r1
   2b2e2:	bf38      	it	cc
   2b2e4:	460b      	movcc	r3, r1
   2b2e6:	8cd1      	ldrh	r1, [r2, #38]	; 0x26
   2b2e8:	428b      	cmp	r3, r1
   2b2ea:	bf38      	it	cc
   2b2ec:	460b      	movcc	r3, r1
   2b2ee:	8e11      	ldrh	r1, [r2, #48]	; 0x30
   2b2f0:	428b      	cmp	r3, r1
   2b2f2:	bf38      	it	cc
   2b2f4:	460b      	movcc	r3, r1
   2b2f6:	8911      	ldrh	r1, [r2, #8]
   2b2f8:	4299      	cmp	r1, r3
   2b2fa:	bf38      	it	cc
   2b2fc:	4619      	movcc	r1, r3
	if (value != ccc->value) {
   2b2fe:	8e53      	ldrh	r3, [r2, #50]	; 0x32
   2b300:	428b      	cmp	r3, r1
   2b302:	d003      	beq.n	2b30c <gatt_ccc_changed+0x32>
		if (ccc->cfg_changed) {
   2b304:	6b53      	ldr	r3, [r2, #52]	; 0x34
		ccc->value = value;
   2b306:	8651      	strh	r1, [r2, #50]	; 0x32
		if (ccc->cfg_changed) {
   2b308:	b103      	cbz	r3, 2b30c <gatt_ccc_changed+0x32>
			ccc->cfg_changed(attr, value);
   2b30a:	4718      	bx	r3
}
   2b30c:	4770      	bx	lr

0002b30e <gatt_indicate_rsp>:
{
   2b30e:	b410      	push	{r4}
   2b310:	9b01      	ldr	r3, [sp, #4]
	params->func(conn, params->attr, err);
   2b312:	69dc      	ldr	r4, [r3, #28]
   2b314:	460a      	mov	r2, r1
   2b316:	6999      	ldr	r1, [r3, #24]
   2b318:	4623      	mov	r3, r4
}
   2b31a:	bc10      	pop	{r4}
	params->func(conn, params->attr, err);
   2b31c:	4718      	bx	r3

0002b31e <gatt_mtu_rsp>:
{
   2b31e:	9a00      	ldr	r2, [sp, #0]
	params->func(conn, err, params);
   2b320:	6953      	ldr	r3, [r2, #20]
   2b322:	4718      	bx	r3

0002b324 <gatt_write_rsp>:
{
   2b324:	9a00      	ldr	r2, [sp, #0]
	params->func(conn, err, params);
   2b326:	6953      	ldr	r3, [r2, #20]
   2b328:	4718      	bx	r3

0002b32a <gen_hash_m>:
{
   2b32a:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (attr->uuid->type != BT_UUID_TYPE_16)
   2b32c:	6807      	ldr	r7, [r0, #0]
   2b32e:	783d      	ldrb	r5, [r7, #0]
{
   2b330:	b089      	sub	sp, #36	; 0x24
   2b332:	4606      	mov	r6, r0
   2b334:	460c      	mov	r4, r1
	if (attr->uuid->type != BT_UUID_TYPE_16)
   2b336:	b10d      	cbz	r5, 2b33c <gen_hash_m+0x12>
		return BT_GATT_ITER_CONTINUE;
   2b338:	2501      	movs	r5, #1
   2b33a:	e015      	b.n	2b368 <gen_hash_m+0x3e>
	switch (u16->val) {
   2b33c:	887b      	ldrh	r3, [r7, #2]
   2b33e:	f5b3 5f24 	cmp.w	r3, #10496	; 0x2900
   2b342:	d004      	beq.n	2b34e <gen_hash_m+0x24>
   2b344:	d813      	bhi.n	2b36e <gen_hash_m+0x44>
   2b346:	f5a3 5320 	sub.w	r3, r3, #10240	; 0x2800
   2b34a:	2b03      	cmp	r3, #3
   2b34c:	d8f4      	bhi.n	2b338 <gen_hash_m+0xe>
		value = sys_cpu_to_le16(attr->handle);
   2b34e:	8a33      	ldrh	r3, [r6, #16]
   2b350:	f8ad 300e 	strh.w	r3, [sp, #14]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   2b354:	2202      	movs	r2, #2
   2b356:	f10d 010e 	add.w	r1, sp, #14
   2b35a:	4620      	mov	r0, r4
   2b35c:	f7fd f8f0 	bl	28540 <tc_cmac_update>
   2b360:	b9d8      	cbnz	r0, 2b39a <gen_hash_m+0x70>
			state->err = -EINVAL;
   2b362:	f06f 0315 	mvn.w	r3, #21
   2b366:	65a3      	str	r3, [r4, #88]	; 0x58
}
   2b368:	4628      	mov	r0, r5
   2b36a:	b009      	add	sp, #36	; 0x24
   2b36c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (u16->val) {
   2b36e:	f642 1205 	movw	r2, #10501	; 0x2905
   2b372:	4293      	cmp	r3, r2
   2b374:	d8e0      	bhi.n	2b338 <gen_hash_m+0xe>
		value = sys_cpu_to_le16(attr->handle);
   2b376:	8a03      	ldrh	r3, [r0, #16]
   2b378:	f8ad 300e 	strh.w	r3, [sp, #14]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   2b37c:	2202      	movs	r2, #2
   2b37e:	f10d 010e 	add.w	r1, sp, #14
   2b382:	4620      	mov	r0, r4
   2b384:	f7fd f8dc 	bl	28540 <tc_cmac_update>
   2b388:	2800      	cmp	r0, #0
   2b38a:	d0ea      	beq.n	2b362 <gen_hash_m+0x38>
		value = sys_cpu_to_le16(u16->val);
   2b38c:	887b      	ldrh	r3, [r7, #2]
   2b38e:	f8ad 300e 	strh.w	r3, [sp, #14]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   2b392:	2202      	movs	r2, #2
   2b394:	f10d 010e 	add.w	r1, sp, #14
   2b398:	e017      	b.n	2b3ca <gen_hash_m+0xa0>
		value = sys_cpu_to_le16(u16->val);
   2b39a:	887b      	ldrh	r3, [r7, #2]
   2b39c:	f8ad 300e 	strh.w	r3, [sp, #14]
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   2b3a0:	2202      	movs	r2, #2
   2b3a2:	f10d 010e 	add.w	r1, sp, #14
   2b3a6:	4620      	mov	r0, r4
   2b3a8:	f7fd f8ca 	bl	28540 <tc_cmac_update>
   2b3ac:	2800      	cmp	r0, #0
   2b3ae:	d0d8      	beq.n	2b362 <gen_hash_m+0x38>
		len = attr->read(NULL, attr, data, sizeof(data), 0);
   2b3b0:	2000      	movs	r0, #0
   2b3b2:	2310      	movs	r3, #16
   2b3b4:	eb0d 0203 	add.w	r2, sp, r3
   2b3b8:	9000      	str	r0, [sp, #0]
   2b3ba:	6877      	ldr	r7, [r6, #4]
   2b3bc:	4631      	mov	r1, r6
   2b3be:	47b8      	blx	r7
		if (len < 0) {
   2b3c0:	1e02      	subs	r2, r0, #0
   2b3c2:	da01      	bge.n	2b3c8 <gen_hash_m+0x9e>
			state->err = len;
   2b3c4:	65a2      	str	r2, [r4, #88]	; 0x58
			return BT_GATT_ITER_STOP;
   2b3c6:	e7cf      	b.n	2b368 <gen_hash_m+0x3e>
		if (tc_cmac_update(&state->state, data, len) ==
   2b3c8:	a904      	add	r1, sp, #16
		if (tc_cmac_update(&state->state, (uint8_t *)&value,
   2b3ca:	4620      	mov	r0, r4
   2b3cc:	f7fd f8b8 	bl	28540 <tc_cmac_update>
   2b3d0:	2800      	cmp	r0, #0
   2b3d2:	d1b1      	bne.n	2b338 <gen_hash_m+0xe>
   2b3d4:	e7c5      	b.n	2b362 <gen_hash_m+0x38>

0002b3d6 <bt_addr_le_copy>:
	memcpy(dst, src, sizeof(*dst));
   2b3d6:	2207      	movs	r2, #7
   2b3d8:	f7ff b839 	b.w	2a44e <memcpy>

0002b3dc <atomic_test_bit>:
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2b3dc:	f3bf 8f5b 	dmb	ish
   2b3e0:	6800      	ldr	r0, [r0, #0]
   2b3e2:	f3bf 8f5b 	dmb	ish
	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   2b3e6:	4108      	asrs	r0, r1
}
   2b3e8:	f000 0001 	and.w	r0, r0, #1
   2b3ec:	4770      	bx	lr

0002b3ee <atomic_and>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2b3ee:	f3bf 8f5b 	dmb	ish
   2b3f2:	e850 3f00 	ldrex	r3, [r0]
   2b3f6:	ea03 0201 	and.w	r2, r3, r1
   2b3fa:	e840 2c00 	strex	ip, r2, [r0]
   2b3fe:	f1bc 0f00 	cmp.w	ip, #0
   2b402:	d1f6      	bne.n	2b3f2 <atomic_and+0x4>
   2b404:	f3bf 8f5b 	dmb	ish
}
   2b408:	4618      	mov	r0, r3
   2b40a:	4770      	bx	lr

0002b40c <gatt_read_multiple_rsp>:
{
   2b40c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2b40e:	9c08      	ldr	r4, [sp, #32]
   2b410:	4606      	mov	r6, r0
   2b412:	6967      	ldr	r7, [r4, #20]
	if (err || !length) {
   2b414:	460d      	mov	r5, r1
   2b416:	b901      	cbnz	r1, 2b41a <gatt_read_multiple_rsp+0xe>
   2b418:	b94b      	cbnz	r3, 2b42e <gatt_read_multiple_rsp+0x22>
		params->func(conn, err, params, NULL, 0);
   2b41a:	2300      	movs	r3, #0
   2b41c:	9308      	str	r3, [sp, #32]
   2b41e:	4622      	mov	r2, r4
   2b420:	4629      	mov	r1, r5
	params->func(conn, 0, params, NULL, 0);
   2b422:	4630      	mov	r0, r6
   2b424:	46bc      	mov	ip, r7
}
   2b426:	b003      	add	sp, #12
   2b428:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	params->func(conn, 0, params, NULL, 0);
   2b42c:	4760      	bx	ip
	params->func(conn, 0, params, pdu, length);
   2b42e:	9300      	str	r3, [sp, #0]
   2b430:	4613      	mov	r3, r2
   2b432:	4622      	mov	r2, r4
   2b434:	47b8      	blx	r7
	params->func(conn, 0, params, NULL, 0);
   2b436:	9508      	str	r5, [sp, #32]
   2b438:	6967      	ldr	r7, [r4, #20]
   2b43a:	462b      	mov	r3, r5
   2b43c:	4622      	mov	r2, r4
   2b43e:	4629      	mov	r1, r5
   2b440:	e7ef      	b.n	2b422 <gatt_read_multiple_rsp+0x16>

0002b442 <match_uuid>:
   2b442:	6008      	str	r0, [r1, #0]
   2b444:	2000      	movs	r0, #0
   2b446:	4770      	bx	lr

0002b448 <sc_ccc_cfg_write>:
{
   2b448:	b508      	push	{r3, lr}
   2b44a:	4601      	mov	r1, r0
	if (value == BT_GATT_CCC_INDICATE) {
   2b44c:	2a02      	cmp	r2, #2
   2b44e:	7a00      	ldrb	r0, [r0, #8]
   2b450:	f101 0170 	add.w	r1, r1, #112	; 0x70
   2b454:	d105      	bne.n	2b462 <sc_ccc_cfg_write+0x1a>
		sc_save(conn->id, &conn->le.dst, 0, 0);
   2b456:	2300      	movs	r3, #0
   2b458:	461a      	mov	r2, r3
   2b45a:	f7ee fbf5 	bl	19c48 <sc_save>
}
   2b45e:	2001      	movs	r0, #1
   2b460:	bd08      	pop	{r3, pc}
		cfg = find_sc_cfg(conn->id, &conn->le.dst);
   2b462:	f7ee fbcf 	bl	19c04 <find_sc_cfg>
		if (cfg) {
   2b466:	2800      	cmp	r0, #0
   2b468:	d0f9      	beq.n	2b45e <sc_ccc_cfg_write+0x16>
	memset(cfg, 0, sizeof(*cfg));
   2b46a:	220c      	movs	r2, #12
   2b46c:	2100      	movs	r1, #0
   2b46e:	f7ff f818 	bl	2a4a2 <memset>
   2b472:	e7f4      	b.n	2b45e <sc_ccc_cfg_write+0x16>

0002b474 <atomic_set_bit>:
	atomic_val_t mask = ATOMIC_MASK(bit);
   2b474:	2301      	movs	r3, #1
   2b476:	fa03 f101 	lsl.w	r1, r3, r1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2b47a:	f3bf 8f5b 	dmb	ish
   2b47e:	e850 3f00 	ldrex	r3, [r0]
   2b482:	430b      	orrs	r3, r1
   2b484:	e840 3200 	strex	r2, r3, [r0]
   2b488:	2a00      	cmp	r2, #0
   2b48a:	d1f8      	bne.n	2b47e <atomic_set_bit+0xa>
   2b48c:	f3bf 8f5b 	dmb	ish
}
   2b490:	4770      	bx	lr

0002b492 <sc_restore_rsp>:
{
   2b492:	b508      	push	{r3, lr}
	cfg = find_cf_cfg(conn);
   2b494:	f7ee fc92 	bl	19dbc <find_cf_cfg>
	if (cfg && CF_ROBUST_CACHING(cfg)) {
   2b498:	b140      	cbz	r0, 2b4ac <sc_restore_rsp+0x1a>
   2b49a:	7a03      	ldrb	r3, [r0, #8]
   2b49c:	07db      	lsls	r3, r3, #31
   2b49e:	d505      	bpl.n	2b4ac <sc_restore_rsp+0x1a>
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   2b4a0:	2100      	movs	r1, #0
   2b4a2:	300c      	adds	r0, #12
}
   2b4a4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   2b4a8:	f7ff bfe4 	b.w	2b474 <atomic_set_bit>
}
   2b4ac:	bd08      	pop	{r3, pc}

0002b4ae <find_ccc_cfg>:
{
   2b4ae:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   2b4b2:	4606      	mov	r6, r0
   2b4b4:	460c      	mov	r4, r1
   2b4b6:	2501      	movs	r5, #1
			if (conn->id == ccc->cfg[i].id &&
   2b4b8:	1e4f      	subs	r7, r1, #1
		if (conn) {
   2b4ba:	b17e      	cbz	r6, 2b4dc <find_ccc_cfg+0x2e>
			if (conn->id == ccc->cfg[i].id &&
   2b4bc:	7a32      	ldrb	r2, [r6, #8]
   2b4be:	5d7b      	ldrb	r3, [r7, r5]
   2b4c0:	429a      	cmp	r2, r3
   2b4c2:	d116      	bne.n	2b4f2 <find_ccc_cfg+0x44>
			    !bt_conn_addr_le_cmp(conn, &ccc->cfg[i].peer)) {
   2b4c4:	1961      	adds	r1, r4, r5
   2b4c6:	4630      	mov	r0, r6
   2b4c8:	f105 38ff 	add.w	r8, r5, #4294967295	; 0xffffffff
   2b4cc:	f7ff fa7d 	bl	2a9ca <bt_conn_addr_le_cmp>
		} else if (!bt_addr_le_cmp(&ccc->cfg[i].peer, BT_ADDR_LE_ANY)) {
   2b4d0:	b978      	cbnz	r0, 2b4f2 <find_ccc_cfg+0x44>
			return &ccc->cfg[i];
   2b4d2:	eb04 0008 	add.w	r0, r4, r8
}
   2b4d6:	b002      	add	sp, #8
   2b4d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return memcmp(a, b, sizeof(*a));
   2b4dc:	2207      	movs	r2, #7
   2b4de:	4669      	mov	r1, sp
   2b4e0:	1960      	adds	r0, r4, r5
		} else if (!bt_addr_le_cmp(&ccc->cfg[i].peer, BT_ADDR_LE_ANY)) {
   2b4e2:	9600      	str	r6, [sp, #0]
   2b4e4:	f105 38ff 	add.w	r8, r5, #4294967295	; 0xffffffff
   2b4e8:	f8cd 6003 	str.w	r6, [sp, #3]
   2b4ec:	f7fe ff88 	bl	2a400 <memcmp>
   2b4f0:	e7ee      	b.n	2b4d0 <find_ccc_cfg+0x22>
   2b4f2:	350a      	adds	r5, #10
	for (size_t i = 0; i < ARRAY_SIZE(ccc->cfg); i++) {
   2b4f4:	2d33      	cmp	r5, #51	; 0x33
   2b4f6:	d1e0      	bne.n	2b4ba <find_ccc_cfg+0xc>
	return NULL;
   2b4f8:	2000      	movs	r0, #0
   2b4fa:	e7ec      	b.n	2b4d6 <find_ccc_cfg+0x28>

0002b4fc <read_appearance>:
{
   2b4fc:	b513      	push	{r0, r1, r4, lr}
   2b4fe:	f8bd 1010 	ldrh.w	r1, [sp, #16]
   2b502:	4610      	mov	r0, r2
	if (offset > value_len) {
   2b504:	2902      	cmp	r1, #2
	u16_t appearance = sys_cpu_to_le16(gap_appearance);
   2b506:	f04f 0200 	mov.w	r2, #0
   2b50a:	f8ad 2006 	strh.w	r2, [sp, #6]
	if (offset > value_len) {
   2b50e:	d80d      	bhi.n	2b52c <read_appearance+0x30>
	len = MIN(buf_len, value_len - offset);
   2b510:	f1c1 0402 	rsb	r4, r1, #2
   2b514:	429c      	cmp	r4, r3
   2b516:	bfa8      	it	ge
   2b518:	461c      	movge	r4, r3
	memcpy(buf, (u8_t *)value + offset, len);
   2b51a:	f10d 0306 	add.w	r3, sp, #6
   2b51e:	4622      	mov	r2, r4
   2b520:	4419      	add	r1, r3
   2b522:	f7fe ff94 	bl	2a44e <memcpy>
}
   2b526:	4620      	mov	r0, r4
   2b528:	b002      	add	sp, #8
   2b52a:	bd10      	pop	{r4, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   2b52c:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &appearance,
   2b530:	e7f9      	b.n	2b526 <read_appearance+0x2a>

0002b532 <read_ppcp>:
{
   2b532:	b513      	push	{r0, r1, r4, lr}
   2b534:	f8bd 1010 	ldrh.w	r1, [sp, #16]
   2b538:	4610      	mov	r0, r2
	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_SLAVE_LATENCY);
   2b53a:	f04f 1406 	mov.w	r4, #393222	; 0x60006
   2b53e:	f44f 1228 	mov.w	r2, #2752512	; 0x2a0000
	if (offset > value_len) {
   2b542:	2908      	cmp	r1, #8
	ppcp.latency = sys_cpu_to_le16(CONFIG_BT_PERIPHERAL_PREF_SLAVE_LATENCY);
   2b544:	e9cd 4200 	strd	r4, r2, [sp]
	if (offset > value_len) {
   2b548:	d80b      	bhi.n	2b562 <read_ppcp+0x30>
	len = MIN(buf_len, value_len - offset);
   2b54a:	f1c1 0408 	rsb	r4, r1, #8
   2b54e:	429c      	cmp	r4, r3
   2b550:	bfa8      	it	ge
   2b552:	461c      	movge	r4, r3
	memcpy(buf, (u8_t *)value + offset, len);
   2b554:	4622      	mov	r2, r4
   2b556:	4469      	add	r1, sp
   2b558:	f7fe ff79 	bl	2a44e <memcpy>
}
   2b55c:	4620      	mov	r0, r4
   2b55e:	b002      	add	sp, #8
   2b560:	bd10      	pop	{r4, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   2b562:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &ppcp,
   2b566:	e7f9      	b.n	2b55c <read_ppcp+0x2a>

0002b568 <read_name>:
{
   2b568:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2b56c:	4698      	mov	r8, r3
   2b56e:	4616      	mov	r6, r2
   2b570:	f8bd 5018 	ldrh.w	r5, [sp, #24]
	const char *name = bt_get_name();
   2b574:	f7eb fac6 	bl	16b04 <bt_get_name>
   2b578:	4607      	mov	r7, r0
				 strlen(name));
   2b57a:	f7fe ff1f 	bl	2a3bc <strlen>
	if (offset > value_len) {
   2b57e:	b283      	uxth	r3, r0
   2b580:	42ab      	cmp	r3, r5
   2b582:	d30c      	bcc.n	2b59e <read_name+0x36>
	len = MIN(buf_len, value_len - offset);
   2b584:	1b5c      	subs	r4, r3, r5
   2b586:	4544      	cmp	r4, r8
   2b588:	bfa8      	it	ge
   2b58a:	4644      	movge	r4, r8
   2b58c:	b2a4      	uxth	r4, r4
	memcpy(buf, (u8_t *)value + offset, len);
   2b58e:	4622      	mov	r2, r4
   2b590:	1979      	adds	r1, r7, r5
   2b592:	4630      	mov	r0, r6
   2b594:	f7fe ff5b 	bl	2a44e <memcpy>
}
   2b598:	4620      	mov	r0, r4
   2b59a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   2b59e:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, name,
   2b5a2:	e7f9      	b.n	2b598 <read_name+0x30>

0002b5a4 <bt_gatt_attr_read_ccc>:
{
   2b5a4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	cfg = find_ccc_cfg(conn, ccc);
   2b5a6:	68c9      	ldr	r1, [r1, #12]
{
   2b5a8:	f8bd 5020 	ldrh.w	r5, [sp, #32]
   2b5ac:	4616      	mov	r6, r2
   2b5ae:	461f      	mov	r7, r3
	cfg = find_ccc_cfg(conn, ccc);
   2b5b0:	f7ff ff7d 	bl	2b4ae <find_ccc_cfg>
	if (cfg) {
   2b5b4:	b100      	cbz	r0, 2b5b8 <bt_gatt_attr_read_ccc+0x14>
		value = sys_cpu_to_le16(cfg->value);
   2b5b6:	8900      	ldrh	r0, [r0, #8]
   2b5b8:	f8ad 0006 	strh.w	r0, [sp, #6]
	if (offset > value_len) {
   2b5bc:	2d02      	cmp	r5, #2
   2b5be:	d80e      	bhi.n	2b5de <bt_gatt_attr_read_ccc+0x3a>
	len = MIN(buf_len, value_len - offset);
   2b5c0:	f1c5 0402 	rsb	r4, r5, #2
   2b5c4:	42bc      	cmp	r4, r7
   2b5c6:	bfa8      	it	ge
   2b5c8:	463c      	movge	r4, r7
	memcpy(buf, (u8_t *)value + offset, len);
   2b5ca:	f10d 0306 	add.w	r3, sp, #6
   2b5ce:	4622      	mov	r2, r4
   2b5d0:	1959      	adds	r1, r3, r5
   2b5d2:	4630      	mov	r0, r6
   2b5d4:	f7fe ff3b 	bl	2a44e <memcpy>
}
   2b5d8:	4620      	mov	r0, r4
   2b5da:	b003      	add	sp, #12
   2b5dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   2b5de:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &value,
   2b5e2:	e7f9      	b.n	2b5d8 <bt_gatt_attr_read_ccc+0x34>

0002b5e4 <cf_read>:
{
   2b5e4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2b5e6:	461f      	mov	r7, r3
	u8_t data[1] = {};
   2b5e8:	2300      	movs	r3, #0
{
   2b5ea:	4616      	mov	r6, r2
   2b5ec:	f8bd 5020 	ldrh.w	r5, [sp, #32]
	u8_t data[1] = {};
   2b5f0:	f88d 3004 	strb.w	r3, [sp, #4]
	cfg = find_cf_cfg(conn);
   2b5f4:	f7ee fbe2 	bl	19dbc <find_cf_cfg>
	if (cfg) {
   2b5f8:	b128      	cbz	r0, 2b606 <cf_read+0x22>
		memcpy(data, cfg->data, sizeof(data));
   2b5fa:	f100 0108 	add.w	r1, r0, #8
   2b5fe:	2201      	movs	r2, #1
   2b600:	a801      	add	r0, sp, #4
   2b602:	f7fe ff24 	bl	2a44e <memcpy>
	if (offset > value_len) {
   2b606:	2d01      	cmp	r5, #1
   2b608:	d80d      	bhi.n	2b626 <cf_read+0x42>
	len = MIN(buf_len, value_len - offset);
   2b60a:	f1c5 0401 	rsb	r4, r5, #1
   2b60e:	42bc      	cmp	r4, r7
   2b610:	bfa8      	it	ge
   2b612:	463c      	movge	r4, r7
	memcpy(buf, (u8_t *)value + offset, len);
   2b614:	ab01      	add	r3, sp, #4
   2b616:	4622      	mov	r2, r4
   2b618:	1959      	adds	r1, r3, r5
   2b61a:	4630      	mov	r0, r6
   2b61c:	f7fe ff17 	bl	2a44e <memcpy>
}
   2b620:	4620      	mov	r0, r4
   2b622:	b003      	add	sp, #12
   2b624:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   2b626:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, data,
   2b62a:	e7f9      	b.n	2b620 <cf_read+0x3c>

0002b62c <bt_gatt_attr_read_service>:
{
   2b62c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct bt_uuid *uuid = attr->user_data;
   2b62e:	68c9      	ldr	r1, [r1, #12]
{
   2b630:	f8bd 5018 	ldrh.w	r5, [sp, #24]
   2b634:	4610      	mov	r0, r2
	if (uuid->type == BT_UUID_TYPE_16) {
   2b636:	780a      	ldrb	r2, [r1, #0]
   2b638:	b992      	cbnz	r2, 2b660 <bt_gatt_attr_read_service+0x34>
		u16_t uuid16 = sys_cpu_to_le16(BT_UUID_16(uuid)->val);
   2b63a:	884a      	ldrh	r2, [r1, #2]
   2b63c:	f8ad 2006 	strh.w	r2, [sp, #6]
	if (offset > value_len) {
   2b640:	2d02      	cmp	r5, #2
   2b642:	d819      	bhi.n	2b678 <bt_gatt_attr_read_service+0x4c>
	len = MIN(buf_len, value_len - offset);
   2b644:	f1c5 0402 	rsb	r4, r5, #2
   2b648:	429c      	cmp	r4, r3
   2b64a:	bfa8      	it	ge
   2b64c:	461c      	movge	r4, r3
	memcpy(buf, (u8_t *)value + offset, len);
   2b64e:	f10d 0306 	add.w	r3, sp, #6
   2b652:	4622      	mov	r2, r4
   2b654:	1959      	adds	r1, r3, r5
   2b656:	f7fe fefa 	bl	2a44e <memcpy>
}
   2b65a:	4620      	mov	r0, r4
   2b65c:	b003      	add	sp, #12
   2b65e:	bd30      	pop	{r4, r5, pc}
	if (offset > value_len) {
   2b660:	2d10      	cmp	r5, #16
				 BT_UUID_128(uuid)->val, 16);
   2b662:	f101 0101 	add.w	r1, r1, #1
	if (offset > value_len) {
   2b666:	d807      	bhi.n	2b678 <bt_gatt_attr_read_service+0x4c>
	len = MIN(buf_len, value_len - offset);
   2b668:	f1c5 0410 	rsb	r4, r5, #16
   2b66c:	429c      	cmp	r4, r3
   2b66e:	bfa8      	it	ge
   2b670:	461c      	movge	r4, r3
	memcpy(buf, (u8_t *)value + offset, len);
   2b672:	4622      	mov	r2, r4
   2b674:	4429      	add	r1, r5
   2b676:	e7ee      	b.n	2b656 <bt_gatt_attr_read_service+0x2a>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   2b678:	f06f 0406 	mvn.w	r4, #6
   2b67c:	e7ed      	b.n	2b65a <bt_gatt_attr_read_service+0x2e>

0002b67e <bt_gatt_attr_read>:
{
   2b67e:	b510      	push	{r4, lr}
   2b680:	4610      	mov	r0, r2
   2b682:	f8bd 1008 	ldrh.w	r1, [sp, #8]
   2b686:	f8bd 2010 	ldrh.w	r2, [sp, #16]
	if (offset > value_len) {
   2b68a:	4291      	cmp	r1, r2
   2b68c:	d80b      	bhi.n	2b6a6 <bt_gatt_attr_read+0x28>
	len = MIN(buf_len, value_len - offset);
   2b68e:	1a54      	subs	r4, r2, r1
   2b690:	429c      	cmp	r4, r3
   2b692:	bfa8      	it	ge
   2b694:	461c      	movge	r4, r3
	memcpy(buf, (u8_t *)value + offset, len);
   2b696:	9b03      	ldr	r3, [sp, #12]
   2b698:	b2a4      	uxth	r4, r4
   2b69a:	4622      	mov	r2, r4
   2b69c:	4419      	add	r1, r3
   2b69e:	f7fe fed6 	bl	2a44e <memcpy>
}
   2b6a2:	4620      	mov	r0, r4
   2b6a4:	bd10      	pop	{r4, pc}
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   2b6a6:	f06f 0406 	mvn.w	r4, #6
   2b6aa:	e7fa      	b.n	2b6a2 <bt_gatt_attr_read+0x24>

0002b6ac <bt_gatt_attr_read_chrc>:
{
   2b6ac:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct bt_gatt_chrc *chrc = attr->user_data;
   2b6ae:	68ce      	ldr	r6, [r1, #12]
{
   2b6b0:	b087      	sub	sp, #28
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
   2b6b2:	4608      	mov	r0, r1
{
   2b6b4:	461c      	mov	r4, r3
	pdu.properties = chrc->properties;
   2b6b6:	79b3      	ldrb	r3, [r6, #6]
   2b6b8:	f88d 3004 	strb.w	r3, [sp, #4]
{
   2b6bc:	4617      	mov	r7, r2
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
   2b6be:	f7ee fdc5 	bl	1a24c <bt_gatt_attr_value_handle>
	if (chrc->uuid->type == BT_UUID_TYPE_16) {
   2b6c2:	6831      	ldr	r1, [r6, #0]
	pdu.value_handle = sys_cpu_to_le16(bt_gatt_attr_value_handle(attr));
   2b6c4:	f8ad 0005 	strh.w	r0, [sp, #5]
	if (chrc->uuid->type == BT_UUID_TYPE_16) {
   2b6c8:	780b      	ldrb	r3, [r1, #0]
{
   2b6ca:	f8bd 5030 	ldrh.w	r5, [sp, #48]	; 0x30
	if (chrc->uuid->type == BT_UUID_TYPE_16) {
   2b6ce:	b99b      	cbnz	r3, 2b6f8 <bt_gatt_attr_read_chrc+0x4c>
		pdu.uuid16 = sys_cpu_to_le16(BT_UUID_16(chrc->uuid)->val);
   2b6d0:	884b      	ldrh	r3, [r1, #2]
   2b6d2:	f8ad 3007 	strh.w	r3, [sp, #7]
		value_len += 2U;
   2b6d6:	2305      	movs	r3, #5
	if (offset > value_len) {
   2b6d8:	42ab      	cmp	r3, r5
   2b6da:	d315      	bcc.n	2b708 <bt_gatt_attr_read_chrc+0x5c>
	len = MIN(buf_len, value_len - offset);
   2b6dc:	1b5b      	subs	r3, r3, r5
   2b6de:	42a3      	cmp	r3, r4
   2b6e0:	bfa8      	it	ge
   2b6e2:	4623      	movge	r3, r4
   2b6e4:	b29c      	uxth	r4, r3
	memcpy(buf, (u8_t *)value + offset, len);
   2b6e6:	ab01      	add	r3, sp, #4
   2b6e8:	4622      	mov	r2, r4
   2b6ea:	1959      	adds	r1, r3, r5
   2b6ec:	4638      	mov	r0, r7
   2b6ee:	f7fe feae 	bl	2a44e <memcpy>
}
   2b6f2:	4620      	mov	r0, r4
   2b6f4:	b007      	add	sp, #28
   2b6f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		memcpy(pdu.uuid, BT_UUID_128(chrc->uuid)->val, 16);
   2b6f8:	2210      	movs	r2, #16
   2b6fa:	3101      	adds	r1, #1
   2b6fc:	f10d 0007 	add.w	r0, sp, #7
   2b700:	f7fe fea5 	bl	2a44e <memcpy>
		value_len += 16U;
   2b704:	2313      	movs	r3, #19
   2b706:	e7e7      	b.n	2b6d8 <bt_gatt_attr_read_chrc+0x2c>
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
   2b708:	f06f 0406 	mvn.w	r4, #6
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &pdu, value_len);
   2b70c:	e7f1      	b.n	2b6f2 <bt_gatt_attr_read_chrc+0x46>

0002b70e <bt_gatt_foreach_attr>:
{
   2b70e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	bt_gatt_foreach_attr_type(start_handle, end_handle, NULL, NULL, 0, func,
   2b710:	e9cd 2301 	strd	r2, r3, [sp, #4]
   2b714:	2300      	movs	r3, #0
   2b716:	9300      	str	r3, [sp, #0]
   2b718:	461a      	mov	r2, r3
   2b71a:	f7ee fdaf 	bl	1a27c <bt_gatt_foreach_attr_type>
}
   2b71e:	b005      	add	sp, #20
   2b720:	f85d fb04 	ldr.w	pc, [sp], #4

0002b724 <db_hash_process>:
	db_hash_gen(true);
   2b724:	f7ee be4e 	b.w	1a3c4 <db_hash_gen.isra.19>

0002b728 <bt_gatt_get_mtu>:
	return bt_att_get_mtu(conn);
   2b728:	f7ff bd6b 	b.w	2b202 <bt_att_get_mtu>

0002b72c <bt_gatt_check_perm>:
	if ((mask & BT_GATT_PERM_READ) &&
   2b72c:	07d3      	lsls	r3, r2, #31
{
   2b72e:	b510      	push	{r4, lr}
   2b730:	7c8c      	ldrb	r4, [r1, #18]
	if ((mask & BT_GATT_PERM_READ) &&
   2b732:	d504      	bpl.n	2b73e <bt_gatt_check_perm+0x12>
   2b734:	f014 0f15 	tst.w	r4, #21
   2b738:	d017      	beq.n	2b76a <bt_gatt_check_perm+0x3e>
	    (!(attr->perm & BT_GATT_PERM_READ_MASK) || !attr->read)) {
   2b73a:	684b      	ldr	r3, [r1, #4]
   2b73c:	b1ab      	cbz	r3, 2b76a <bt_gatt_check_perm+0x3e>
	if ((mask & BT_GATT_PERM_WRITE) &&
   2b73e:	0793      	lsls	r3, r2, #30
   2b740:	d504      	bpl.n	2b74c <bt_gatt_check_perm+0x20>
   2b742:	f014 0f2a 	tst.w	r4, #42	; 0x2a
   2b746:	d012      	beq.n	2b76e <bt_gatt_check_perm+0x42>
	    (!(attr->perm & BT_GATT_PERM_WRITE_MASK) || !attr->write)) {
   2b748:	688b      	ldr	r3, [r1, #8]
   2b74a:	b183      	cbz	r3, 2b76e <bt_gatt_check_perm+0x42>
	mask &= attr->perm;
   2b74c:	4014      	ands	r4, r2
	if (mask & BT_GATT_PERM_AUTHEN_MASK) {
   2b74e:	f014 0f30 	tst.w	r4, #48	; 0x30
   2b752:	d104      	bne.n	2b75e <bt_gatt_check_perm+0x32>
		return BT_ATT_ERR_INSUFFICIENT_ENCRYPTION;
   2b754:	f014 000c 	ands.w	r0, r4, #12
   2b758:	bf18      	it	ne
   2b75a:	200f      	movne	r0, #15
}
   2b75c:	bd10      	pop	{r4, pc}
		if (bt_conn_get_security(conn) < BT_SECURITY_L3) {
   2b75e:	f7ff f932 	bl	2a9c6 <bt_conn_get_security>
   2b762:	2802      	cmp	r0, #2
   2b764:	d8f6      	bhi.n	2b754 <bt_gatt_check_perm+0x28>
			return BT_ATT_ERR_AUTHENTICATION;
   2b766:	2005      	movs	r0, #5
   2b768:	e7f8      	b.n	2b75c <bt_gatt_check_perm+0x30>
		return BT_ATT_ERR_READ_NOT_PERMITTED;
   2b76a:	2002      	movs	r0, #2
   2b76c:	e7f6      	b.n	2b75c <bt_gatt_check_perm+0x30>
		return BT_ATT_ERR_WRITE_NOT_PERMITTED;
   2b76e:	2003      	movs	r0, #3
   2b770:	e7f4      	b.n	2b75c <bt_gatt_check_perm+0x30>

0002b772 <gatt_discover_next>:
{
   2b772:	b570      	push	{r4, r5, r6, lr}
   2b774:	4605      	mov	r5, r0
   2b776:	4614      	mov	r4, r2
	if (!last_handle)
   2b778:	b929      	cbnz	r1, 2b786 <gatt_discover_next+0x14>
	if (!bt_gatt_discover(conn, params)) {
   2b77a:	4621      	mov	r1, r4
   2b77c:	4628      	mov	r0, r5
   2b77e:	f7ef f89d 	bl	1a8bc <bt_gatt_discover>
   2b782:	b928      	cbnz	r0, 2b790 <gatt_discover_next+0x1e>
}
   2b784:	bd70      	pop	{r4, r5, r6, pc}
	if (params->start_handle < UINT16_MAX) {
   2b786:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2b78a:	4299      	cmp	r1, r3
   2b78c:	d107      	bne.n	2b79e <gatt_discover_next+0x2c>
	params->start_handle = last_handle;
   2b78e:	8391      	strh	r1, [r2, #28]
	params->func(conn, NULL, params);
   2b790:	69a3      	ldr	r3, [r4, #24]
   2b792:	4622      	mov	r2, r4
   2b794:	4628      	mov	r0, r5
   2b796:	2100      	movs	r1, #0
}
   2b798:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	params->func(conn, NULL, params);
   2b79c:	4718      	bx	r3
		params->start_handle++;
   2b79e:	3101      	adds	r1, #1
	if (params->start_handle > params->end_handle) {
   2b7a0:	8c53      	ldrh	r3, [r2, #34]	; 0x22
		params->start_handle++;
   2b7a2:	b289      	uxth	r1, r1
	if (params->start_handle > params->end_handle) {
   2b7a4:	428b      	cmp	r3, r1
		params->start_handle++;
   2b7a6:	8391      	strh	r1, [r2, #28]
	if (params->start_handle > params->end_handle) {
   2b7a8:	d2e7      	bcs.n	2b77a <gatt_discover_next+0x8>
   2b7aa:	e7f1      	b.n	2b790 <gatt_discover_next+0x1e>

0002b7ac <gatt_find_type_rsp>:
{
   2b7ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2b7b0:	b08a      	sub	sp, #40	; 0x28
   2b7b2:	4607      	mov	r7, r0
   2b7b4:	4690      	mov	r8, r2
   2b7b6:	461e      	mov	r6, r3
   2b7b8:	9d12      	ldr	r5, [sp, #72]	; 0x48
	if (err) {
   2b7ba:	2900      	cmp	r1, #0
   2b7bc:	d140      	bne.n	2b840 <gatt_find_type_rsp+0x94>
   2b7be:	460c      	mov	r4, r1
	u16_t end_handle = 0U, start_handle;
   2b7c0:	468a      	mov	sl, r1
		struct bt_gatt_attr attr = {};
   2b7c2:	4689      	mov	r9, r1
	for (i = 0U; length >= sizeof(rsp->list[i]);
   2b7c4:	2e03      	cmp	r6, #3
   2b7c6:	d809      	bhi.n	2b7dc <gatt_find_type_rsp+0x30>
	if (length > 0) {
   2b7c8:	2e00      	cmp	r6, #0
   2b7ca:	d139      	bne.n	2b840 <gatt_find_type_rsp+0x94>
	gatt_discover_next(conn, end_handle, params);
   2b7cc:	462a      	mov	r2, r5
   2b7ce:	4651      	mov	r1, sl
   2b7d0:	4638      	mov	r0, r7
   2b7d2:	f7ff ffce 	bl	2b772 <gatt_discover_next>
}
   2b7d6:	b00a      	add	sp, #40	; 0x28
   2b7d8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		struct bt_gatt_attr attr = {};
   2b7dc:	2214      	movs	r2, #20
   2b7de:	eb0d 0002 	add.w	r0, sp, r2
   2b7e2:	2100      	movs	r1, #0
   2b7e4:	f7fe fe5d 	bl	2a4a2 <memset>
		start_handle = sys_le16_to_cpu(rsp->list[i].start_handle);
   2b7e8:	b2e3      	uxtb	r3, r4
   2b7ea:	eb08 0383 	add.w	r3, r8, r3, lsl #2
   2b7ee:	881a      	ldrh	r2, [r3, #0]
		end_handle = sys_le16_to_cpu(rsp->list[i].end_handle);
   2b7f0:	f8b3 a002 	ldrh.w	sl, [r3, #2]
		if (params->type == BT_GATT_DISCOVER_PRIMARY) {
   2b7f4:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
   2b7f8:	b9d3      	cbnz	r3, 2b830 <gatt_find_type_rsp+0x84>
			attr.uuid = BT_UUID_GATT_PRIMARY;
   2b7fa:	f88d 3004 	strb.w	r3, [sp, #4]
   2b7fe:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   2b802:	f8ad 3006 	strh.w	r3, [sp, #6]
   2b806:	ab01      	add	r3, sp, #4
			attr.uuid = BT_UUID_GATT_SECONDARY;
   2b808:	9305      	str	r3, [sp, #20]
		value.uuid = params->uuid;
   2b80a:	696b      	ldr	r3, [r5, #20]
   2b80c:	9303      	str	r3, [sp, #12]
		attr.user_data = &value;
   2b80e:	ab03      	add	r3, sp, #12
		attr.handle = start_handle;
   2b810:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
		attr.user_data = &value;
   2b814:	9308      	str	r3, [sp, #32]
		value.end_handle = end_handle;
   2b816:	f8ad a010 	strh.w	sl, [sp, #16]
		if (params->func(conn, &attr, params) == BT_GATT_ITER_STOP) {
   2b81a:	69ab      	ldr	r3, [r5, #24]
   2b81c:	462a      	mov	r2, r5
   2b81e:	a905      	add	r1, sp, #20
   2b820:	4638      	mov	r0, r7
   2b822:	4798      	blx	r3
   2b824:	3401      	adds	r4, #1
   2b826:	2800      	cmp	r0, #0
   2b828:	d0d5      	beq.n	2b7d6 <gatt_find_type_rsp+0x2a>
	     i++, length -=  sizeof(rsp->list[i])) {
   2b82a:	3e04      	subs	r6, #4
   2b82c:	b2b6      	uxth	r6, r6
   2b82e:	e7c9      	b.n	2b7c4 <gatt_find_type_rsp+0x18>
			attr.uuid = BT_UUID_GATT_SECONDARY;
   2b830:	f642 0301 	movw	r3, #10241	; 0x2801
   2b834:	f8ad 300a 	strh.w	r3, [sp, #10]
   2b838:	f88d 9008 	strb.w	r9, [sp, #8]
   2b83c:	ab02      	add	r3, sp, #8
   2b83e:	e7e3      	b.n	2b808 <gatt_find_type_rsp+0x5c>
	params->func(conn, NULL, params);
   2b840:	69ab      	ldr	r3, [r5, #24]
   2b842:	462a      	mov	r2, r5
   2b844:	2100      	movs	r1, #0
   2b846:	4638      	mov	r0, r7
   2b848:	4798      	blx	r3
   2b84a:	e7c4      	b.n	2b7d6 <gatt_find_type_rsp+0x2a>

0002b84c <bt_gatt_change_aware>:
{
   2b84c:	b570      	push	{r4, r5, r6, lr}
   2b84e:	460d      	mov	r5, r1
	cfg = find_cf_cfg(conn);
   2b850:	f7ee fab4 	bl	19dbc <find_cf_cfg>
	if (!cfg || !CF_ROBUST_CACHING(cfg)) {
   2b854:	b910      	cbnz	r0, 2b85c <bt_gatt_change_aware+0x10>
		return true;
   2b856:	2501      	movs	r5, #1
}
   2b858:	4628      	mov	r0, r5
   2b85a:	bd70      	pop	{r4, r5, r6, pc}
	if (!cfg || !CF_ROBUST_CACHING(cfg)) {
   2b85c:	7a03      	ldrb	r3, [r0, #8]
   2b85e:	07db      	lsls	r3, r3, #31
   2b860:	d5f9      	bpl.n	2b856 <bt_gatt_change_aware+0xa>
	if (atomic_test_bit(cfg->flags, CF_CHANGE_AWARE)) {
   2b862:	f100 040c 	add.w	r4, r0, #12
   2b866:	2100      	movs	r1, #0
   2b868:	4620      	mov	r0, r4
   2b86a:	f7ff fdb7 	bl	2b3dc <atomic_test_bit>
   2b86e:	4606      	mov	r6, r0
   2b870:	2800      	cmp	r0, #0
   2b872:	d1f0      	bne.n	2b856 <bt_gatt_change_aware+0xa>
	if (!req) {
   2b874:	2d00      	cmp	r5, #0
   2b876:	d0ef      	beq.n	2b858 <bt_gatt_change_aware+0xc>
	if (atomic_test_bit(cfg->flags, CF_OUT_OF_SYNC)) {
   2b878:	2101      	movs	r1, #1
   2b87a:	4620      	mov	r0, r4
   2b87c:	f7ff fdae 	bl	2b3dc <atomic_test_bit>
   2b880:	4605      	mov	r5, r0
   2b882:	b148      	cbz	r0, 2b898 <bt_gatt_change_aware+0x4c>
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   2b884:	f06f 0102 	mvn.w	r1, #2
   2b888:	4620      	mov	r0, r4
   2b88a:	f7ff fdb0 	bl	2b3ee <atomic_and>
		atomic_set_bit(cfg->flags, CF_CHANGE_AWARE);
   2b88e:	4631      	mov	r1, r6
	atomic_set_bit(cfg->flags, CF_OUT_OF_SYNC);
   2b890:	4620      	mov	r0, r4
   2b892:	f7ff fdef 	bl	2b474 <atomic_set_bit>
	return false;
   2b896:	e7df      	b.n	2b858 <bt_gatt_change_aware+0xc>
	atomic_set_bit(cfg->flags, CF_OUT_OF_SYNC);
   2b898:	2101      	movs	r1, #1
   2b89a:	e7f9      	b.n	2b890 <bt_gatt_change_aware+0x44>

0002b89c <bt_smp_recv>:
{
   2b89c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	buf = bt_l2cap_create_pdu(NULL, 0);
   2b89e:	2100      	movs	r1, #0
	struct bt_conn *conn = chan->conn;
   2b8a0:	6807      	ldr	r7, [r0, #0]
	buf = bt_l2cap_create_pdu(NULL, 0);
   2b8a2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2b8a6:	4608      	mov	r0, r1
   2b8a8:	f7ff f974 	bl	2ab94 <bt_l2cap_create_pdu_timeout>
	hdr = net_buf_add(buf, sizeof(*hdr));
   2b8ac:	f100 0608 	add.w	r6, r0, #8
	buf = bt_l2cap_create_pdu(NULL, 0);
   2b8b0:	4605      	mov	r5, r0
	hdr = net_buf_add(buf, sizeof(*hdr));
   2b8b2:	2101      	movs	r1, #1
   2b8b4:	4630      	mov	r0, r6
   2b8b6:	f001 f963 	bl	2cb80 <net_buf_simple_add>
	hdr->code = BT_SMP_CMD_PAIRING_FAIL;
   2b8ba:	2405      	movs	r4, #5
   2b8bc:	7004      	strb	r4, [r0, #0]
	rsp = net_buf_add(buf, sizeof(*rsp));
   2b8be:	2101      	movs	r1, #1
   2b8c0:	4630      	mov	r0, r6
   2b8c2:	f001 f95d 	bl	2cb80 <net_buf_simple_add>
	rsp->reason = BT_SMP_ERR_PAIRING_NOTSUPP;
   2b8c6:	7004      	strb	r4, [r0, #0]
   2b8c8:	2400      	movs	r4, #0
   2b8ca:	9400      	str	r4, [sp, #0]
   2b8cc:	4623      	mov	r3, r4
   2b8ce:	462a      	mov	r2, r5
   2b8d0:	2106      	movs	r1, #6
   2b8d2:	4638      	mov	r0, r7
   2b8d4:	f7ff f961 	bl	2ab9a <bt_l2cap_send_cb>
}
   2b8d8:	4620      	mov	r0, r4
   2b8da:	b003      	add	sp, #12
   2b8dc:	bdf0      	pop	{r4, r5, r6, r7, pc}

0002b8de <bt_smp_sign>:
   2b8de:	f06f 0022 	mvn.w	r0, #34	; 0x22
   2b8e2:	4770      	bx	lr

0002b8e4 <bt_smp_init>:
BT_L2CAP_CHANNEL_DEFINE(smp_fixed_chan, BT_L2CAP_CID_SMP, bt_smp_accept);

int bt_smp_init(void)
{
	return 0;
}
   2b8e4:	2000      	movs	r0, #0
   2b8e6:	4770      	bx	lr

0002b8e8 <mem_init>:

#include "mem.h"

void mem_init(void *mem_pool, u16_t mem_size, u16_t mem_count,
	      void **mem_head)
{
   2b8e8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	*mem_head = mem_pool;
   2b8ea:	6018      	str	r0, [r3, #0]

	/* Store free mem_count after the list's next pointer at an 32-bit
	 * aligned memory location to ensure atomic read/write (in ARM for now).
	 */
	*((u16_t *)MROUND((u8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
   2b8ec:	1dc3      	adds	r3, r0, #7
   2b8ee:	f023 0303 	bic.w	r3, r3, #3
{
   2b8f2:	460e      	mov	r6, r1
	*((u16_t *)MROUND((u8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
   2b8f4:	801a      	strh	r2, [r3, #0]

	/* Initialize next pointers to form a free list,
	 * next pointer is stored in the first 32-bit of each block
	 */
	(void)memset(((u8_t *)mem_pool + (mem_size * (--mem_count))), 0,
   2b8f6:	3a01      	subs	r2, #1
   2b8f8:	b294      	uxth	r4, r2
{
   2b8fa:	4605      	mov	r5, r0
	(void)memset(((u8_t *)mem_pool + (mem_size * (--mem_count))), 0,
   2b8fc:	2204      	movs	r2, #4
   2b8fe:	2100      	movs	r1, #0
   2b900:	fb06 0004 	mla	r0, r6, r4, r0
   2b904:	f7fe fdcd 	bl	2a4a2 <memset>
		     sizeof(mem_pool));
	while (mem_count--) {
   2b908:	f64f 77ff 	movw	r7, #65535	; 0xffff
   2b90c:	3c01      	subs	r4, #1
   2b90e:	b2a4      	uxth	r4, r4
   2b910:	42bc      	cmp	r4, r7
   2b912:	d101      	bne.n	2b918 <mem_init+0x30>
		next = (u32_t)((u8_t *) mem_pool +
			       (mem_size * (mem_count + 1)));
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
		       (void *)&next, sizeof(next));
	}
}
   2b914:	b003      	add	sp, #12
   2b916:	bdf0      	pop	{r4, r5, r6, r7, pc}
			       (mem_size * (mem_count + 1)));
   2b918:	fb04 6006 	mla	r0, r4, r6, r6
		next = (u32_t)((u8_t *) mem_pool +
   2b91c:	182b      	adds	r3, r5, r0
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
   2b91e:	2204      	movs	r2, #4
   2b920:	1b80      	subs	r0, r0, r6
   2b922:	eb0d 0102 	add.w	r1, sp, r2
   2b926:	4428      	add	r0, r5
		next = (u32_t)((u8_t *) mem_pool +
   2b928:	9301      	str	r3, [sp, #4]
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
   2b92a:	f7fe fd90 	bl	2a44e <memcpy>
   2b92e:	e7ed      	b.n	2b90c <mem_init+0x24>

0002b930 <mem_acquire>:

void *mem_acquire(void **mem_head)
{
   2b930:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (*mem_head) {
   2b932:	6804      	ldr	r4, [r0, #0]
{
   2b934:	4606      	mov	r6, r0
	if (*mem_head) {
   2b936:	b18c      	cbz	r4, 2b95c <mem_acquire+0x2c>
		u16_t free_count;
		void *head;
		void *mem;

		/* Get the free count from the list and decrement it */
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
   2b938:	1de3      	adds	r3, r4, #7
   2b93a:	f023 0303 	bic.w	r3, r3, #3
					       sizeof(mem_head)));
		free_count--;

		mem = *mem_head;
		memcpy(&head, mem, sizeof(head));
   2b93e:	2204      	movs	r2, #4
   2b940:	4621      	mov	r1, r4
   2b942:	eb0d 0002 	add.w	r0, sp, r2
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
   2b946:	881d      	ldrh	r5, [r3, #0]
		memcpy(&head, mem, sizeof(head));
   2b948:	f7fe fd81 	bl	2a44e <memcpy>

		/* Store free mem_count after the list's next pointer */
		if (head) {
   2b94c:	9b01      	ldr	r3, [sp, #4]
   2b94e:	b123      	cbz	r3, 2b95a <mem_acquire+0x2a>
			*((u16_t *)MROUND((u8_t *)head + sizeof(head))) =
   2b950:	1dda      	adds	r2, r3, #7
   2b952:	f022 0203 	bic.w	r2, r2, #3
		free_count--;
   2b956:	3d01      	subs	r5, #1
			*((u16_t *)MROUND((u8_t *)head + sizeof(head))) =
   2b958:	8015      	strh	r5, [r2, #0]
				free_count;
		}

		*mem_head = head;
   2b95a:	6033      	str	r3, [r6, #0]
		return mem;
	}

	return NULL;
}
   2b95c:	4620      	mov	r0, r4
   2b95e:	b002      	add	sp, #8
   2b960:	bd70      	pop	{r4, r5, r6, pc}

0002b962 <mem_release>:

void mem_release(void *mem, void **mem_head)
{
   2b962:	b570      	push	{r4, r5, r6, lr}
	u16_t free_count = 0U;

	/* Get the free count from the list and increment it */
	if (*mem_head) {
   2b964:	680c      	ldr	r4, [r1, #0]
{
   2b966:	4606      	mov	r6, r0
   2b968:	460d      	mov	r5, r1
	if (*mem_head) {
   2b96a:	b11c      	cbz	r4, 2b974 <mem_release+0x12>
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
   2b96c:	1de3      	adds	r3, r4, #7
   2b96e:	f023 0303 	bic.w	r3, r3, #3
   2b972:	881c      	ldrh	r4, [r3, #0]
					       sizeof(mem_head)));
	}
	free_count++;

	memcpy(mem, mem_head, sizeof(mem));
   2b974:	2204      	movs	r2, #4
   2b976:	4629      	mov	r1, r5
   2b978:	4630      	mov	r0, r6
   2b97a:	f7fe fd68 	bl	2a44e <memcpy>

	/* Store free mem_count after the list's next pointer */
	*((u16_t *)MROUND((u8_t *)mem + sizeof(mem))) = free_count;
   2b97e:	1df2      	adds	r2, r6, #7
   2b980:	f022 0203 	bic.w	r2, r2, #3
	free_count++;
   2b984:	1c63      	adds	r3, r4, #1
	*((u16_t *)MROUND((u8_t *)mem + sizeof(mem))) = free_count;
   2b986:	8013      	strh	r3, [r2, #0]

	*mem_head = mem;
   2b988:	602e      	str	r6, [r5, #0]
}
   2b98a:	bd70      	pop	{r4, r5, r6, pc}

0002b98c <mem_get>:
}

void *mem_get(void *mem_pool, u16_t mem_size, u16_t index)
{
	return ((void *)((u8_t *)mem_pool + (mem_size * index)));
}
   2b98c:	fb02 0001 	mla	r0, r2, r1, r0
   2b990:	4770      	bx	lr

0002b992 <mem_index_get>:

u16_t mem_index_get(void *mem, void *mem_pool, u16_t mem_size)
{
	return ((u16_t)((u8_t *)mem - (u8_t *)mem_pool) / mem_size);
   2b992:	1a40      	subs	r0, r0, r1
   2b994:	b280      	uxth	r0, r0
}
   2b996:	fbb0 f0f2 	udiv	r0, r0, r2
   2b99a:	4770      	bx	lr

0002b99c <mem_rcopy>:
/**
 * @brief  Copy bytes in reverse
 * @details Example: [ 0x11 0x22 0x33 ] -> [ 0x33 0x22 0x11 ]
 */
void mem_rcopy(u8_t *dst, u8_t const *src, u16_t len)
{
   2b99c:	b510      	push	{r4, lr}
	src += len;
   2b99e:	4411      	add	r1, r2
	while (len--) {
   2b9a0:	3801      	subs	r0, #1
   2b9a2:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2b9a6:	3a01      	subs	r2, #1
   2b9a8:	b292      	uxth	r2, r2
   2b9aa:	429a      	cmp	r2, r3
   2b9ac:	d100      	bne.n	2b9b0 <mem_rcopy+0x14>
		*dst++ = *--src;
	}
}
   2b9ae:	bd10      	pop	{r4, pc}
		*dst++ = *--src;
   2b9b0:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
   2b9b4:	f800 4f01 	strb.w	r4, [r0, #1]!
   2b9b8:	e7f5      	b.n	2b9a6 <mem_rcopy+0xa>

0002b9ba <mem_nz>:
 * @brief Determine if src[0..len-1] contains one or more non-zero bytes
 * @return 0 if all bytes are zero; otherwise 1
 */
u8_t mem_nz(u8_t *src, u16_t len)
{
	while (len--) {
   2b9ba:	4401      	add	r1, r0
   2b9bc:	4288      	cmp	r0, r1
   2b9be:	d101      	bne.n	2b9c4 <mem_nz+0xa>
		if (*src++) {
			return 1;
		}
	}

	return 0;
   2b9c0:	2000      	movs	r0, #0
   2b9c2:	4770      	bx	lr
		if (*src++) {
   2b9c4:	f810 3b01 	ldrb.w	r3, [r0], #1
   2b9c8:	2b00      	cmp	r3, #0
   2b9ca:	d0f7      	beq.n	2b9bc <mem_nz+0x2>
			return 1;
   2b9cc:	2001      	movs	r0, #1
}
   2b9ce:	4770      	bx	lr

0002b9d0 <memq_init>:
 * @return          Initial link-element
 */
memq_link_t *memq_init(memq_link_t *link, memq_link_t **head, memq_link_t **tail)
{
	/* Head and tail pointer to the initial link - forms an empty queue */
	*head = *tail = link;
   2b9d0:	6010      	str	r0, [r2, #0]
   2b9d2:	6008      	str	r0, [r1, #0]

	return link;
}
   2b9d4:	4770      	bx	lr

0002b9d6 <memq_deinit>:
memq_link_t *memq_deinit(memq_link_t **head, memq_link_t **tail)
{
	memq_link_t *old_head;

	/* If head and tail are not equal, then queue is not empty */
	if (*head != *tail) {
   2b9d6:	6803      	ldr	r3, [r0, #0]
   2b9d8:	680a      	ldr	r2, [r1, #0]
   2b9da:	4293      	cmp	r3, r2
   2b9dc:	f04f 0200 	mov.w	r2, #0
		return NULL;
   2b9e0:	bf12      	itee	ne
   2b9e2:	4613      	movne	r3, r2
	}

	old_head = *head;
	*head = *tail = NULL;
   2b9e4:	600a      	streq	r2, [r1, #0]
   2b9e6:	6002      	streq	r2, [r0, #0]

	return old_head;
}
   2b9e8:	4618      	mov	r0, r3
   2b9ea:	4770      	bx	lr

0002b9ec <memq_enqueue>:
 * @param mem[in]      The memory payload to be enqueued. Pointed to by old tail
 * @param tail[in,out] Tail of queue. Will be updated to point to link
 * @return             New tail. Note: Does not point to the new mem
 */
memq_link_t *memq_enqueue(memq_link_t *link, void *mem, memq_link_t **tail)
{
   2b9ec:	b510      	push	{r4, lr}
	/* Let the old tail element point to the new tail element */
	(*tail)->next = link;
   2b9ee:	6814      	ldr	r4, [r2, #0]
   2b9f0:	6020      	str	r0, [r4, #0]

	/* Let the old tail element point the the new memory */
	(*tail)->mem = mem;
   2b9f2:	6814      	ldr	r4, [r2, #0]
   2b9f4:	6061      	str	r1, [r4, #4]

	/* Update the tail-pointer to point to the new tail element.
	 * The new tail-element is not expected to point to anything sensible
	 */
	*tail = link;
   2b9f6:	6010      	str	r0, [r2, #0]

	return link;
}
   2b9f8:	bd10      	pop	{r4, pc}

0002b9fa <memq_peek>:
 * @return         head or NULL if queue is empty
 */
memq_link_t *memq_peek(memq_link_t *head, memq_link_t *tail, void **mem)
{
	/* If head and tail are equal, then queue empty */
	if (head == tail) {
   2b9fa:	4288      	cmp	r0, r1
   2b9fc:	d003      	beq.n	2ba06 <memq_peek+0xc>
		return NULL;
	}

	/* Extract the head link-element's memory */
	if (mem) {
   2b9fe:	b11a      	cbz	r2, 2ba08 <memq_peek+0xe>
		*mem = head->mem;
   2ba00:	6843      	ldr	r3, [r0, #4]
   2ba02:	6013      	str	r3, [r2, #0]
   2ba04:	4770      	bx	lr
		return NULL;
   2ba06:	2000      	movs	r0, #0
	}

	return head; /* queue was not empty */
}
   2ba08:	4770      	bx	lr

0002ba0a <memq_dequeue>:
memq_link_t *memq_dequeue(memq_link_t *tail, memq_link_t **head, void **mem)
{
	memq_link_t *old_head;

	/* Use memq peek to get the old head and its mem */
	old_head = memq_peek(*head, tail, mem);
   2ba0a:	680b      	ldr	r3, [r1, #0]
	if (head == tail) {
   2ba0c:	4283      	cmp	r3, r0
   2ba0e:	d009      	beq.n	2ba24 <memq_dequeue+0x1a>
	if (mem) {
   2ba10:	b122      	cbz	r2, 2ba1c <memq_dequeue+0x12>
		*mem = head->mem;
   2ba12:	6858      	ldr	r0, [r3, #4]
   2ba14:	6010      	str	r0, [r2, #0]
	if (old_head == NULL) {
		return NULL; /* queue is empty */
	}

	/* Update the head-pointer to point to the new head element */
	*head = old_head->next;
   2ba16:	681a      	ldr	r2, [r3, #0]
   2ba18:	600a      	str	r2, [r1, #0]

	return old_head;
   2ba1a:	e001      	b.n	2ba20 <memq_dequeue+0x16>
	if (old_head == NULL) {
   2ba1c:	2b00      	cmp	r3, #0
   2ba1e:	d1fa      	bne.n	2ba16 <memq_dequeue+0xc>
}
   2ba20:	4618      	mov	r0, r3
   2ba22:	4770      	bx	lr
		return NULL; /* queue is empty */
   2ba24:	2300      	movs	r3, #0
   2ba26:	e7fb      	b.n	2ba20 <memq_dequeue+0x16>

0002ba28 <util_ones_count_get>:
 * @param octets_len Must not be bigger than 255/8 = 31 bytes
 *
 * @return popcnt of 'octets'
 */
u8_t util_ones_count_get(u8_t *octets, u8_t octets_len)
{
   2ba28:	b510      	push	{r4, lr}
   2ba2a:	1e42      	subs	r2, r0, #1
	u8_t one_count = 0U;
   2ba2c:	2000      	movs	r0, #0

	while (octets_len--) {
   2ba2e:	3901      	subs	r1, #1
   2ba30:	b2c9      	uxtb	r1, r1
   2ba32:	29ff      	cmp	r1, #255	; 0xff
   2ba34:	d100      	bne.n	2ba38 <util_ones_count_get+0x10>
		}
		octets++;
	}

	return one_count;
}
   2ba36:	bd10      	pop	{r4, pc}
		bite = *octets;
   2ba38:	f812 3f01 	ldrb.w	r3, [r2, #1]!
		while (bite) {
   2ba3c:	2b00      	cmp	r3, #0
   2ba3e:	d0f6      	beq.n	2ba2e <util_ones_count_get+0x6>
			bite &= (bite - 1);
   2ba40:	b25b      	sxtb	r3, r3
   2ba42:	1e5c      	subs	r4, r3, #1
   2ba44:	4023      	ands	r3, r4
			one_count++;
   2ba46:	3001      	adds	r0, #1
			bite &= (bite - 1);
   2ba48:	b2db      	uxtb	r3, r3
			one_count++;
   2ba4a:	b2c0      	uxtb	r0, r0
   2ba4c:	e7f6      	b.n	2ba3c <util_ones_count_get+0x14>

0002ba4e <ticks_to_expire_prep>:
{
   2ba4e:	b530      	push	{r4, r5, lr}
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
   2ba50:	1a55      	subs	r5, r2, r1
   2ba52:	f415 0f00 	tst.w	r5, #8388608	; 0x800000
	u32_t ticks_to_expire = ticker->ticks_to_expire;
   2ba56:	6883      	ldr	r3, [r0, #8]
	u32_t ticks_to_expire_minus = ticker->ticks_to_expire_minus;
   2ba58:	6944      	ldr	r4, [r0, #20]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
   2ba5a:	d109      	bne.n	2ba70 <ticks_to_expire_prep+0x22>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   2ba5c:	f025 427f 	bic.w	r2, r5, #4278190080	; 0xff000000
		ticks_to_expire += ticker_ticks_diff_get(ticks_at_start,
   2ba60:	441a      	add	r2, r3
	if (ticks_to_expire > ticks_to_expire_minus) {
   2ba62:	42a2      	cmp	r2, r4
   2ba64:	d90e      	bls.n	2ba84 <ticks_to_expire_prep+0x36>
		ticks_to_expire -= ticks_to_expire_minus;
   2ba66:	1b12      	subs	r2, r2, r4
		ticks_to_expire_minus = 0U;
   2ba68:	2400      	movs	r4, #0
	ticker->ticks_to_expire = ticks_to_expire;
   2ba6a:	6082      	str	r2, [r0, #8]
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
   2ba6c:	6144      	str	r4, [r0, #20]
}
   2ba6e:	bd30      	pop	{r4, r5, pc}
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   2ba70:	1a8a      	subs	r2, r1, r2
   2ba72:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
		if (ticks_to_expire > delta_current_start) {
   2ba76:	4293      	cmp	r3, r2
   2ba78:	d901      	bls.n	2ba7e <ticks_to_expire_prep+0x30>
			ticks_to_expire -= delta_current_start;
   2ba7a:	1a9a      	subs	r2, r3, r2
   2ba7c:	e7f1      	b.n	2ba62 <ticks_to_expire_prep+0x14>
			ticks_to_expire_minus +=
   2ba7e:	4422      	add	r2, r4
   2ba80:	1ad4      	subs	r4, r2, r3
			ticks_to_expire = 0U;
   2ba82:	2200      	movs	r2, #0
		ticks_to_expire_minus -= ticks_to_expire;
   2ba84:	1aa4      	subs	r4, r4, r2
		ticks_to_expire = 0U;
   2ba86:	2200      	movs	r2, #0
   2ba88:	e7ef      	b.n	2ba6a <ticks_to_expire_prep+0x1c>

0002ba8a <ticker_job_op_cb>:
{
   2ba8a:	4603      	mov	r3, r0
	user_op->op = TICKER_USER_OP_TYPE_NONE;
   2ba8c:	2200      	movs	r2, #0
   2ba8e:	701a      	strb	r2, [r3, #0]
	if (user_op->fp_op_func) {
   2ba90:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	user_op->status = status;
   2ba92:	6259      	str	r1, [r3, #36]	; 0x24
{
   2ba94:	4608      	mov	r0, r1
	if (user_op->fp_op_func) {
   2ba96:	b10a      	cbz	r2, 2ba9c <ticker_job_op_cb+0x12>
		user_op->fp_op_func(user_op->status, user_op->op_context);
   2ba98:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
   2ba9a:	4710      	bx	r2
}
   2ba9c:	4770      	bx	lr

0002ba9e <ticker_worker>:
{
   2ba9e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (instance->job_guard) {
   2baa2:	7f86      	ldrb	r6, [r0, #30]
	instance->worker_trigger = 1U;
   2baa4:	2301      	movs	r3, #1
{
   2baa6:	b08b      	sub	sp, #44	; 0x2c
   2baa8:	4605      	mov	r5, r0
	instance->worker_trigger = 1U;
   2baaa:	77c3      	strb	r3, [r0, #31]
	if (instance->job_guard) {
   2baac:	b91e      	cbnz	r6, 2bab6 <ticker_worker+0x18>
	if (instance->ticker_id_head == TICKER_NULL) {
   2baae:	7f43      	ldrb	r3, [r0, #29]
   2bab0:	2bff      	cmp	r3, #255	; 0xff
   2bab2:	d103      	bne.n	2babc <ticker_worker+0x1e>
		instance->worker_trigger = 0U;
   2bab4:	77c6      	strb	r6, [r0, #31]
}
   2bab6:	b00b      	add	sp, #44	; 0x2c
   2bab8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	ticks_elapsed = ticker_ticks_diff_get(cntr_cnt_get(),
   2babc:	f7f8 fd7c 	bl	245b8 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   2bac0:	696b      	ldr	r3, [r5, #20]
	ticker_id_head = instance->ticker_id_head;
   2bac2:	f895 801d 	ldrb.w	r8, [r5, #29]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   2bac6:	1ac0      	subs	r0, r0, r3
	if (instance->ticker_id_slot_previous != TICKER_NULL) {
   2bac8:	7f2b      	ldrb	r3, [r5, #28]
   2baca:	2bff      	cmp	r3, #255	; 0xff
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   2bacc:	f020 497f 	bic.w	r9, r0, #4278190080	; 0xff000000
	if (instance->ticker_id_slot_previous != TICKER_NULL) {
   2bad0:	d027      	beq.n	2bb22 <ticker_worker+0x84>
		if (instance->ticks_slot_previous > ticks_elapsed) {
   2bad2:	69ae      	ldr	r6, [r5, #24]
	u8_t slot_reserved = 0;
   2bad4:	454e      	cmp	r6, r9
   2bad6:	bf94      	ite	ls
   2bad8:	2300      	movls	r3, #0
   2bada:	2301      	movhi	r3, #1
   2badc:	9301      	str	r3, [sp, #4]
	node = &instance->nodes[0];
   2bade:	f8d5 a000 	ldr.w	sl, [r5]
	ticks_expired = 0U;
   2bae2:	f04f 0b00 	mov.w	fp, #0
	while (ticker_id_head != TICKER_NULL) {
   2bae6:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
   2baea:	d11c      	bne.n	2bb26 <ticker_worker+0x88>
	if (instance->ticks_elapsed_first == instance->ticks_elapsed_last) {
   2baec:	7aea      	ldrb	r2, [r5, #11]
   2baee:	7aab      	ldrb	r3, [r5, #10]
   2baf0:	4293      	cmp	r3, r2
   2baf2:	d105      	bne.n	2bb00 <ticker_worker+0x62>
	u8_t idx = *ticks_elapsed_index + 1;
   2baf4:	3301      	adds	r3, #1
   2baf6:	b2db      	uxtb	r3, r3
		idx = 0U;
   2baf8:	2b02      	cmp	r3, #2
   2bafa:	bf08      	it	eq
   2bafc:	2300      	moveq	r3, #0
	*ticks_elapsed_index = idx;
   2bafe:	72eb      	strb	r3, [r5, #11]
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   2bb00:	7aeb      	ldrb	r3, [r5, #11]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   2bb02:	6a6c      	ldr	r4, [r5, #36]	; 0x24
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   2bb04:	eb05 0383 	add.w	r3, r5, r3, lsl #2
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   2bb08:	2201      	movs	r2, #1
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
   2bb0a:	f8c3 b00c 	str.w	fp, [r3, #12]
	instance->worker_trigger = 0U;
   2bb0e:	2300      	movs	r3, #0
   2bb10:	77eb      	strb	r3, [r5, #31]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   2bb12:	2104      	movs	r1, #4
   2bb14:	462b      	mov	r3, r5
   2bb16:	2003      	movs	r0, #3
   2bb18:	46a4      	mov	ip, r4
}
   2bb1a:	b00b      	add	sp, #44	; 0x2c
   2bb1c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
   2bb20:	4760      	bx	ip
	u8_t slot_reserved = 0;
   2bb22:	9601      	str	r6, [sp, #4]
   2bb24:	e7db      	b.n	2bade <ticker_worker+0x40>
		ticker = &node[ticker_id_head];
   2bb26:	232c      	movs	r3, #44	; 0x2c
   2bb28:	fb18 f803 	smulbb	r8, r8, r3
   2bb2c:	eb0a 0408 	add.w	r4, sl, r8
		ticks_to_expire = ticker->ticks_to_expire;
   2bb30:	68a3      	ldr	r3, [r4, #8]
		if (ticks_elapsed < ticks_to_expire) {
   2bb32:	4599      	cmp	r9, r3
   2bb34:	d3da      	bcc.n	2baec <ticker_worker+0x4e>
		if (ticker->ticks_slot != 0U &&
   2bb36:	69a7      	ldr	r7, [r4, #24]
		ticker_id_head = ticker->next;
   2bb38:	f81a 8008 	ldrb.w	r8, [sl, r8]
		ticks_elapsed -= ticks_to_expire;
   2bb3c:	eba9 0903 	sub.w	r9, r9, r3
		ticks_expired += ticks_to_expire;
   2bb40:	449b      	add	fp, r3
		if (ticker->ticks_slot != 0U &&
   2bb42:	b35f      	cbz	r7, 2bb9c <ticker_worker+0xfe>
   2bb44:	8be3      	ldrh	r3, [r4, #30]
   2bb46:	461e      	mov	r6, r3
   2bb48:	9b01      	ldr	r3, [sp, #4]
   2bb4a:	2b00      	cmp	r3, #0
   2bb4c:	f040 8083 	bne.w	2bc56 <ticker_worker+0x1b8>
	if (ticker->lazy_periodic > lazy_current) {
   2bb50:	8ba2      	ldrh	r2, [r4, #28]
   2bb52:	4296      	cmp	r6, r2
   2bb54:	d37f      	bcc.n	2bc56 <ticker_worker+0x1b8>
	} else if ((ticker->priority != TICKER_PRIORITY_CRITICAL) &&
   2bb56:	f994 3029 	ldrsb.w	r3, [r4, #41]	; 0x29
   2bb5a:	9302      	str	r3, [sp, #8]
   2bb5c:	3380      	adds	r3, #128	; 0x80
   2bb5e:	d01c      	beq.n	2bb9a <ticker_worker+0xfc>
   2bb60:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
   2bb64:	f000 8088 	beq.w	2bc78 <ticker_worker+0x1da>
		u32_t acc_ticks_to_expire = 0;
   2bb68:	9901      	ldr	r1, [sp, #4]
		u32_t current_age = ticker->ticks_periodic +
   2bb6a:	6863      	ldr	r3, [r4, #4]
		u32_t acc_ticks_to_expire = 0;
   2bb6c:	9104      	str	r1, [sp, #16]
				(lazy_current - ticker->priority);
   2bb6e:	9902      	ldr	r1, [sp, #8]
			lazy_current -= ticker->lazy_periodic;
   2bb70:	1ab2      	subs	r2, r6, r2
		u32_t current_age = ticker->ticks_periodic +
   2bb72:	fb02 3303 	mla	r3, r2, r3, r3
				(lazy_current - ticker->priority);
   2bb76:	1a52      	subs	r2, r2, r1
		u32_t current_age = ticker->ticks_periodic +
   2bb78:	9306      	str	r3, [sp, #24]
				(lazy_current - ticker->priority);
   2bb7a:	9209      	str	r2, [sp, #36]	; 0x24
		u32_t current_age = ticker->ticks_periodic +
   2bb7c:	4643      	mov	r3, r8
			struct ticker_node *ticker_next = &nodes[id_head];
   2bb7e:	222c      	movs	r2, #44	; 0x2c
   2bb80:	fb13 f302 	smulbb	r3, r3, r2
   2bb84:	eb0a 0e03 	add.w	lr, sl, r3
   2bb88:	9305      	str	r3, [sp, #20]
			if (ticker_next->ticks_slot == 0) {
   2bb8a:	f8de 3018 	ldr.w	r3, [lr, #24]
   2bb8e:	bb4b      	cbnz	r3, 2bbe4 <ticker_worker+0x146>
			id_head = ticker_next->next;
   2bb90:	9b05      	ldr	r3, [sp, #20]
   2bb92:	f81a 3003 	ldrb.w	r3, [sl, r3]
		while (id_head != TICKER_NULL) {
   2bb96:	2bff      	cmp	r3, #255	; 0xff
   2bb98:	d1f1      	bne.n	2bb7e <ticker_worker+0xe0>
		must_expire_skip = 0U;
   2bb9a:	2700      	movs	r7, #0
		if (((ticker->req - ticker->ack) & 0xff) != 1U) {
   2bb9c:	78a2      	ldrb	r2, [r4, #2]
   2bb9e:	7863      	ldrb	r3, [r4, #1]
   2bba0:	1a9b      	subs	r3, r3, r2
   2bba2:	b2db      	uxtb	r3, r3
   2bba4:	2b01      	cmp	r3, #1
   2bba6:	d19e      	bne.n	2bae6 <ticker_worker+0x48>
		if (ticker->timeout_func) {
   2bba8:	68e3      	ldr	r3, [r4, #12]
		ticker->ack--;
   2bbaa:	3a01      	subs	r2, #1
   2bbac:	70a2      	strb	r2, [r4, #2]
		if (ticker->timeout_func) {
   2bbae:	461e      	mov	r6, r3
   2bbb0:	2b00      	cmp	r3, #0
   2bbb2:	d098      	beq.n	2bae6 <ticker_worker+0x48>
					   ticks_expired -
   2bbb4:	6960      	ldr	r0, [r4, #20]
   2bbb6:	696b      	ldr	r3, [r5, #20]
			ticker->timeout_func(ticks_at_expire,
   2bbb8:	6a61      	ldr	r1, [r4, #36]	; 0x24
					   ticks_expired -
   2bbba:	ebab 0000 	sub.w	r0, fp, r0
   2bbbe:	4418      	add	r0, r3
			ticks_at_expire = (instance->ticks_current +
   2bbc0:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			ticker->timeout_func(ticks_at_expire,
   2bbc4:	2f00      	cmp	r7, #0
   2bbc6:	d159      	bne.n	2bc7c <ticker_worker+0x1de>
   2bbc8:	8be2      	ldrh	r2, [r4, #30]
   2bbca:	6923      	ldr	r3, [r4, #16]
   2bbcc:	47b0      	blx	r6
			if (must_expire_skip == 0U) {
   2bbce:	2f00      	cmp	r7, #0
   2bbd0:	d189      	bne.n	2bae6 <ticker_worker+0x48>
				if (ticker->ticks_slot != 0U) {
   2bbd2:	69a3      	ldr	r3, [r4, #24]
				ticker->lazy_current = 0U;
   2bbd4:	83e7      	strh	r7, [r4, #30]
					slot_reserved = 1U;
   2bbd6:	2b00      	cmp	r3, #0
   2bbd8:	9b01      	ldr	r3, [sp, #4]
				ticker->force = 0U;
   2bbda:	70e7      	strb	r7, [r4, #3]
					slot_reserved = 1U;
   2bbdc:	bf18      	it	ne
   2bbde:	2301      	movne	r3, #1
   2bbe0:	9301      	str	r3, [sp, #4]
   2bbe2:	e780      	b.n	2bae6 <ticker_worker+0x48>
			s32_t lazy_next = ticker_next->lazy_current;
   2bbe4:	f8be 001e 	ldrh.w	r0, [lr, #30]
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   2bbe8:	9a04      	ldr	r2, [sp, #16]
				ticker_next->lazy_periodic > lazy_next;
   2bbea:	f8be c01c 	ldrh.w	ip, [lr, #28]
				ticker_next->priority;
   2bbee:	f99e 1029 	ldrsb.w	r1, [lr, #41]	; 0x29
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   2bbf2:	f8de 3008 	ldr.w	r3, [lr, #8]
				ticker_next->priority;
   2bbf6:	9103      	str	r1, [sp, #12]
			u32_t next_age = (ticker_next->ticks_periodic == 0U ?
   2bbf8:	f8de 1004 	ldr.w	r1, [lr, #4]
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   2bbfc:	441a      	add	r2, r3
			if (!lazy_next_periodic_skip) {
   2bbfe:	4560      	cmp	r0, ip
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
   2bc00:	9204      	str	r2, [sp, #16]
			s32_t lazy_next = ticker_next->lazy_current;
   2bc02:	4602      	mov	r2, r0
				lazy_next -= ticker_next->lazy_periodic;
   2bc04:	bf28      	it	cs
   2bc06:	eba0 020c 	subcs.w	r2, r0, ip
					  0U :
   2bc0a:	2900      	cmp	r1, #0
   2bc0c:	d032      	beq.n	2bc74 <ticker_worker+0x1d6>
   2bc0e:	1acb      	subs	r3, r1, r3
   2bc10:	9307      	str	r3, [sp, #28]
			u8_t next_force = (ticker_next->force > ticker->force);
   2bc12:	f89e 3003 	ldrb.w	r3, [lr, #3]
   2bc16:	9308      	str	r3, [sp, #32]
			if (!lazy_next_periodic_skip &&
   2bc18:	4560      	cmp	r0, ip
			u8_t next_force = (ticker_next->force > ticker->force);
   2bc1a:	f894 e003 	ldrb.w	lr, [r4, #3]
			if (!lazy_next_periodic_skip &&
   2bc1e:	d3b7      	bcc.n	2bb90 <ticker_worker+0xf2>
   2bc20:	9b04      	ldr	r3, [sp, #16]
   2bc22:	429f      	cmp	r7, r3
   2bc24:	d9b4      	bls.n	2bb90 <ticker_worker+0xf2>
			    (acc_ticks_to_expire < ticker->ticks_slot) &&
   2bc26:	9b08      	ldr	r3, [sp, #32]
   2bc28:	4573      	cmp	r3, lr
   2bc2a:	d814      	bhi.n	2bc56 <ticker_worker+0x1b8>
			    (next_force ||
   2bc2c:	9b03      	ldr	r3, [sp, #12]
   2bc2e:	3380      	adds	r3, #128	; 0x80
   2bc30:	d011      	beq.n	2bc56 <ticker_worker+0x1b8>
			u32_t next_age = (ticker_next->ticks_periodic == 0U ?
   2bc32:	9b07      	ldr	r3, [sp, #28]
   2bc34:	fb01 3302 	mla	r3, r1, r2, r3
				(lazy_next - ticker_next->priority) >
   2bc38:	9903      	ldr	r1, [sp, #12]
   2bc3a:	1a52      	subs	r2, r2, r1
			     next_is_critical ||
   2bc3c:	9909      	ldr	r1, [sp, #36]	; 0x24
   2bc3e:	428a      	cmp	r2, r1
   2bc40:	dd02      	ble.n	2bc48 <ticker_worker+0x1aa>
			    (next_has_priority && !current_is_older) ||
   2bc42:	9a06      	ldr	r2, [sp, #24]
   2bc44:	429a      	cmp	r2, r3
   2bc46:	d906      	bls.n	2bc56 <ticker_worker+0x1b8>
   2bc48:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
   2bc4c:	428a      	cmp	r2, r1
   2bc4e:	d19f      	bne.n	2bb90 <ticker_worker+0xf2>
			    (equal_priority && next_is_older))) {
   2bc50:	9a06      	ldr	r2, [sp, #24]
   2bc52:	429a      	cmp	r2, r3
   2bc54:	d29c      	bcs.n	2bb90 <ticker_worker+0xf2>
			ticker->lazy_current++;
   2bc56:	4633      	mov	r3, r6
   2bc58:	3301      	adds	r3, #1
			if ((ticker->must_expire == 0U) ||
   2bc5a:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
			ticker->lazy_current++;
   2bc5e:	b29b      	uxth	r3, r3
   2bc60:	83e3      	strh	r3, [r4, #30]
			if ((ticker->must_expire == 0U) ||
   2bc62:	2a00      	cmp	r2, #0
   2bc64:	f43f af3f 	beq.w	2bae6 <ticker_worker+0x48>
   2bc68:	8ba2      	ldrh	r2, [r4, #28]
   2bc6a:	429a      	cmp	r2, r3
   2bc6c:	f4bf af3b 	bcs.w	2bae6 <ticker_worker+0x48>
			must_expire_skip = 1U;
   2bc70:	2701      	movs	r7, #1
   2bc72:	e793      	b.n	2bb9c <ticker_worker+0xfe>
					  0U :
   2bc74:	9107      	str	r1, [sp, #28]
   2bc76:	e7cc      	b.n	2bc12 <ticker_worker+0x174>
		must_expire_skip = 0U;
   2bc78:	9f01      	ldr	r7, [sp, #4]
   2bc7a:	e78f      	b.n	2bb9c <ticker_worker+0xfe>
			ticker->timeout_func(ticks_at_expire,
   2bc7c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2bc80:	e7a3      	b.n	2bbca <ticker_worker+0x12c>

0002bc82 <ticker_ticks_now_get>:
	return cntr_cnt_get();
   2bc82:	f7f8 bc99 	b.w	245b8 <cntr_cnt_get>

0002bc86 <ticker_ticks_diff_get>:
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
   2bc86:	1a40      	subs	r0, r0, r1
}
   2bc88:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   2bc8c:	4770      	bx	lr

0002bc8e <ll_tx_pwr_lvl_get>:
#include "lll_conn.h"
#include "ull_conn_internal.h"

#if defined(CONFIG_BT_LL_SW_SPLIT)
u8_t ll_tx_pwr_lvl_get(u16_t handle, u8_t type, s8_t *tx_pwr_lvl)
{
   2bc8e:	b510      	push	{r4, lr}
   2bc90:	4614      	mov	r4, r2
	struct ll_conn *conn;

	conn = ll_connected_get(handle);
   2bc92:	f000 fb7a 	bl	2c38a <ll_connected_get>
	if (!conn) {
   2bc96:	b118      	cbz	r0, 2bca0 <ll_tx_pwr_lvl_get+0x12>
	/* TODO: check type here for current or maximum */

	/* TODO: Support TX Power Level other than default when dynamic
	 *       updates is implemented.
	 */
	*tx_pwr_lvl = RADIO_TXP_DEFAULT;
   2bc98:	2308      	movs	r3, #8
   2bc9a:	7023      	strb	r3, [r4, #0]

	return 0;
   2bc9c:	2000      	movs	r0, #0
}
   2bc9e:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   2bca0:	2002      	movs	r0, #2
   2bca2:	e7fc      	b.n	2bc9e <ll_tx_pwr_lvl_get+0x10>

0002bca4 <ll_tx_pwr_get>:
void ll_tx_pwr_get(s8_t *min, s8_t *max)
{
	/* TODO: Support TX Power Level other than default when dynamic
	 *       updates is implemented.
	 */
	*min = RADIO_TXP_DEFAULT;
   2bca4:	2308      	movs	r3, #8
   2bca6:	7003      	strb	r3, [r0, #0]
	*max = RADIO_TXP_DEFAULT;
   2bca8:	700b      	strb	r3, [r1, #0]
}
   2bcaa:	4770      	bx	lr

0002bcac <sys_put_le32>:
	dst[1] = val >> 8;
   2bcac:	f3c0 2307 	ubfx	r3, r0, #8, #8
	dst[0] = val;
   2bcb0:	7008      	strb	r0, [r1, #0]
	sys_put_le16(val >> 16, &dst[2]);
   2bcb2:	0c00      	lsrs	r0, r0, #16
	dst[0] = val;
   2bcb4:	7088      	strb	r0, [r1, #2]
	dst[1] = val >> 8;
   2bcb6:	0a00      	lsrs	r0, r0, #8
   2bcb8:	704b      	strb	r3, [r1, #1]
   2bcba:	70c8      	strb	r0, [r1, #3]
}
   2bcbc:	4770      	bx	lr

0002bcbe <sys_get_le64>:
{
   2bcbe:	4603      	mov	r3, r0
}
   2bcc0:	6800      	ldr	r0, [r0, #0]
   2bcc2:	6859      	ldr	r1, [r3, #4]
   2bcc4:	4770      	bx	lr

0002bcc6 <hci_evt_create>:
{
   2bcc6:	b538      	push	{r3, r4, r5, lr}
	hdr = net_buf_add(buf, sizeof(*hdr));
   2bcc8:	3008      	adds	r0, #8
{
   2bcca:	460d      	mov	r5, r1
	hdr = net_buf_add(buf, sizeof(*hdr));
   2bccc:	2102      	movs	r1, #2
{
   2bcce:	4614      	mov	r4, r2
	hdr = net_buf_add(buf, sizeof(*hdr));
   2bcd0:	f000 ff56 	bl	2cb80 <net_buf_simple_add>
	hdr->evt = evt;
   2bcd4:	7005      	strb	r5, [r0, #0]
	hdr->len = len;
   2bcd6:	7044      	strb	r4, [r0, #1]
}
   2bcd8:	bd38      	pop	{r3, r4, r5, pc}

0002bcda <meta_evt>:
{
   2bcda:	b570      	push	{r4, r5, r6, lr}
   2bcdc:	4604      	mov	r4, r0
   2bcde:	4615      	mov	r5, r2
	hci_evt_create(buf, BT_HCI_EVT_LE_META_EVENT, sizeof(*me) + melen);
   2bce0:	3201      	adds	r2, #1
{
   2bce2:	460e      	mov	r6, r1
	me = net_buf_add(buf, sizeof(*me));
   2bce4:	3408      	adds	r4, #8
	hci_evt_create(buf, BT_HCI_EVT_LE_META_EVENT, sizeof(*me) + melen);
   2bce6:	b2d2      	uxtb	r2, r2
   2bce8:	213e      	movs	r1, #62	; 0x3e
   2bcea:	f7ff ffec 	bl	2bcc6 <hci_evt_create>
	me = net_buf_add(buf, sizeof(*me));
   2bcee:	2101      	movs	r1, #1
   2bcf0:	4620      	mov	r0, r4
   2bcf2:	f000 ff45 	bl	2cb80 <net_buf_simple_add>
	me->subevent = subevt;
   2bcf6:	7006      	strb	r6, [r0, #0]
	return net_buf_add(buf, melen);
   2bcf8:	4629      	mov	r1, r5
   2bcfa:	4620      	mov	r0, r4
}
   2bcfc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return net_buf_add(buf, melen);
   2bd00:	f000 bf3e 	b.w	2cb80 <net_buf_simple_add>

0002bd04 <hci_num_cmplt_encode>:
{
   2bd04:	b570      	push	{r4, r5, r6, lr}
   2bd06:	4606      	mov	r6, r0
   2bd08:	460d      	mov	r5, r1
   2bd0a:	4614      	mov	r4, r2
	hci_evt_create(buf, BT_HCI_EVT_NUM_COMPLETED_PACKETS, len);
   2bd0c:	2113      	movs	r1, #19
   2bd0e:	2205      	movs	r2, #5
   2bd10:	f7ff ffd9 	bl	2bcc6 <hci_evt_create>
	ep = net_buf_add(buf, len);
   2bd14:	2105      	movs	r1, #5
   2bd16:	f106 0008 	add.w	r0, r6, #8
   2bd1a:	f000 ff31 	bl	2cb80 <net_buf_simple_add>
	ep->num_handles = num_handles;
   2bd1e:	2301      	movs	r3, #1
   2bd20:	7003      	strb	r3, [r0, #0]
	hc->handle = sys_cpu_to_le16(handle);
   2bd22:	f8a0 5001 	strh.w	r5, [r0, #1]
	hc->count = sys_cpu_to_le16(num);
   2bd26:	f8a0 4003 	strh.w	r4, [r0, #3]
}
   2bd2a:	bd70      	pop	{r4, r5, r6, pc}

0002bd2c <hci_get_class>:
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
   2bd2c:	7903      	ldrb	r3, [r0, #4]
   2bd2e:	2b02      	cmp	r3, #2
   2bd30:	d010      	beq.n	2bd54 <hci_get_class+0x28>
		switch (node_rx->hdr.type) {
   2bd32:	3b04      	subs	r3, #4
   2bd34:	2b0a      	cmp	r3, #10
   2bd36:	d80b      	bhi.n	2bd50 <hci_get_class+0x24>
   2bd38:	e8df f003 	tbb	[pc, r3]
   2bd3c:	0a0a0a15 	.word	0x0a0a0a15
   2bd40:	08080806 	.word	0x08080806
   2bd44:	0808      	.short	0x0808
   2bd46:	08          	.byte	0x08
   2bd47:	00          	.byte	0x00
			return HCI_CLASS_EVT_REQUIRED;
   2bd48:	2001      	movs	r0, #1
   2bd4a:	4770      	bx	lr
			return HCI_CLASS_EVT_CONNECTION;
   2bd4c:	2003      	movs	r0, #3
   2bd4e:	4770      	bx	lr
			return HCI_CLASS_NONE;
   2bd50:	2000      	movs	r0, #0
   2bd52:	4770      	bx	lr
	} else if (pdu_data->ll_id == PDU_DATA_LLID_CTRL) {
   2bd54:	f890 3020 	ldrb.w	r3, [r0, #32]
   2bd58:	f003 0303 	and.w	r3, r3, #3
   2bd5c:	2b03      	cmp	r3, #3
		return HCI_CLASS_ACL_DATA;
   2bd5e:	bf0c      	ite	eq
   2bd60:	2004      	moveq	r0, #4
   2bd62:	2005      	movne	r0, #5
   2bd64:	4770      	bx	lr
			return HCI_CLASS_EVT_DISCARDABLE;
   2bd66:	2002      	movs	r0, #2
}
   2bd68:	4770      	bx	lr

0002bd6a <bt_encrypt_le>:

int bt_encrypt_le(const u8_t key[16], const u8_t plaintext[16],
		  u8_t enc_data[16])
{
   2bd6a:	b508      	push	{r3, lr}
	BT_DBG("key %s", bt_hex(key, 16));
	BT_DBG("plaintext %s", bt_hex(plaintext, 16));

	ecb_encrypt(key, plaintext, enc_data, NULL);
   2bd6c:	2300      	movs	r3, #0
   2bd6e:	f000 fe75 	bl	2ca5c <ecb_encrypt>

	BT_DBG("enc_data %s", bt_hex(enc_data, 16));

	return 0;
}
   2bd72:	2000      	movs	r0, #0
   2bd74:	bd08      	pop	{r3, pc}

0002bd76 <disabled_cb>:
   2bd76:	f7fb b9c7 	b.w	27108 <z_impl_k_sem_give>

0002bd7a <rx_demux_conn_tx_ack>:
{
   2bd7a:	b573      	push	{r0, r1, r4, r5, r6, lr}
   2bd7c:	4606      	mov	r6, r0
   2bd7e:	4614      	mov	r4, r2
   2bd80:	9300      	str	r3, [sp, #0]
   2bd82:	f8ad 1006 	strh.w	r1, [sp, #6]
		ull_conn_ack_dequeue();
   2bd86:	f7f6 fab9 	bl	222fc <ull_conn_ack_dequeue>
		conn = ull_conn_tx_ack(handle, link, node_tx);
   2bd8a:	9a00      	ldr	r2, [sp, #0]
   2bd8c:	f8bd 0006 	ldrh.w	r0, [sp, #6]
   2bd90:	4621      	mov	r1, r4
   2bd92:	f7f6 faef 	bl	22374 <ull_conn_tx_ack>
   2bd96:	4605      	mov	r5, r0
		ull_conn_link_tx_release(link);
   2bd98:	4620      	mov	r0, r4
   2bd9a:	f7f6 fa75 	bl	22288 <ull_conn_link_tx_release>
		ull_conn_tx_demux(1);
   2bd9e:	2001      	movs	r0, #1
   2bda0:	f7f5 ffd6 	bl	21d50 <ull_conn_tx_demux>
		if (conn) {
   2bda4:	b11d      	cbz	r5, 2bdae <rx_demux_conn_tx_ack+0x34>
			ull_conn_tx_lll_enqueue(conn, 1);
   2bda6:	2101      	movs	r1, #1
   2bda8:	4628      	mov	r0, r5
   2bdaa:	f7f6 f9bd 	bl	22128 <ull_conn_tx_lll_enqueue>
		link = ull_conn_ack_by_last_peek(ack_last, &handle, &node_tx);
   2bdae:	466a      	mov	r2, sp
   2bdb0:	f10d 0106 	add.w	r1, sp, #6
   2bdb4:	4630      	mov	r0, r6
   2bdb6:	f7f6 fa8b 	bl	222d0 <ull_conn_ack_by_last_peek>
	} while (link);
   2bdba:	4604      	mov	r4, r0
   2bdbc:	2800      	cmp	r0, #0
   2bdbe:	d1e2      	bne.n	2bd86 <rx_demux_conn_tx_ack+0xc>
			ll_rx_sched();
   2bdc0:	f7f2 fad2 	bl	1e368 <ll_rx_sched>
}
   2bdc4:	b002      	add	sp, #8
   2bdc6:	bd70      	pop	{r4, r5, r6, pc}

0002bdc8 <ll_timeslice_ticker_id_get>:
	*instance_index = TICKER_INSTANCE_ID_CTLR;
   2bdc8:	2300      	movs	r3, #0
   2bdca:	7003      	strb	r3, [r0, #0]
	*user_id = (TICKER_NODES - FLASH_TICKER_NODES);
   2bdcc:	230a      	movs	r3, #10
   2bdce:	700b      	strb	r3, [r1, #0]
}
   2bdd0:	4770      	bx	lr

0002bdd2 <chan_sel_remap>:
{
   2bdd2:	b530      	push	{r4, r5, lr}
   2bdd4:	1e42      	subs	r2, r0, #1
   2bdd6:	1d03      	adds	r3, r0, #4
	chan_next = 0U;
   2bdd8:	2000      	movs	r0, #0
	while (byte_count--) {
   2bdda:	4293      	cmp	r3, r2
   2bddc:	d100      	bne.n	2bde0 <chan_sel_remap+0xe>
}
   2bdde:	bd30      	pop	{r4, r5, pc}
		bite = *chan_map;
   2bde0:	f100 0408 	add.w	r4, r0, #8
   2bde4:	f812 5f01 	ldrb.w	r5, [r2, #1]!
		while (bit_count--) {
   2bde8:	b2e4      	uxtb	r4, r4
   2bdea:	4284      	cmp	r4, r0
   2bdec:	d0f5      	beq.n	2bdda <chan_sel_remap+0x8>
			if (bite & 0x01) {
   2bdee:	f015 0f01 	tst.w	r5, #1
   2bdf2:	d003      	beq.n	2bdfc <chan_sel_remap+0x2a>
				if (chan_index == 0U) {
   2bdf4:	2900      	cmp	r1, #0
   2bdf6:	d0f2      	beq.n	2bdde <chan_sel_remap+0xc>
				chan_index--;
   2bdf8:	3901      	subs	r1, #1
   2bdfa:	b2c9      	uxtb	r1, r1
			chan_next++;
   2bdfc:	3001      	adds	r0, #1
   2bdfe:	b2c0      	uxtb	r0, r0
			bite >>= 1;
   2be00:	086d      	lsrs	r5, r5, #1
   2be02:	e7f2      	b.n	2bdea <chan_sel_remap+0x18>

0002be04 <lll_chan_sel_1>:
{
   2be04:	b430      	push	{r4, r5}
	chan_next = ((*chan_use) + (hop * (1 + latency))) % 37;
   2be06:	fb02 1101 	mla	r1, r2, r1, r1
   2be0a:	7802      	ldrb	r2, [r0, #0]
{
   2be0c:	f89d 5008 	ldrb.w	r5, [sp, #8]
	chan_next = ((*chan_use) + (hop * (1 + latency))) % 37;
   2be10:	4411      	add	r1, r2
   2be12:	2425      	movs	r4, #37	; 0x25
   2be14:	fbb1 f2f4 	udiv	r2, r1, r4
   2be18:	fb04 1212 	mls	r2, r4, r2, r1
   2be1c:	b2d1      	uxtb	r1, r2
	*chan_use = chan_next;
   2be1e:	7001      	strb	r1, [r0, #0]
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
   2be20:	08c8      	lsrs	r0, r1, #3
   2be22:	f002 0207 	and.w	r2, r2, #7
   2be26:	5c1c      	ldrb	r4, [r3, r0]
   2be28:	fa44 f202 	asr.w	r2, r4, r2
   2be2c:	07d2      	lsls	r2, r2, #31
   2be2e:	d408      	bmi.n	2be42 <lll_chan_sel_1+0x3e>
		chan_index = chan_next % chan_count;
   2be30:	fbb1 f2f5 	udiv	r2, r1, r5
   2be34:	fb05 1112 	mls	r1, r5, r2, r1
		chan_next = chan_sel_remap(chan_map, chan_index);
   2be38:	b2c9      	uxtb	r1, r1
   2be3a:	4618      	mov	r0, r3
}
   2be3c:	bc30      	pop	{r4, r5}
		chan_next = chan_sel_remap(chan_map, chan_index);
   2be3e:	f7ff bfc8 	b.w	2bdd2 <chan_sel_remap>
}
   2be42:	4608      	mov	r0, r1
   2be44:	bc30      	pop	{r4, r5}
   2be46:	4770      	bx	lr

0002be48 <swi_lll_nrf5_isr>:
	mayfly_run(TICKER_USER_ID_LLL);
   2be48:	2000      	movs	r0, #0
   2be4a:	f7ef bd13 	b.w	1b874 <mayfly_run>

0002be4e <clock_control_on.constprop.4>:
	return api->on(dev, sys);
   2be4e:	6843      	ldr	r3, [r0, #4]
   2be50:	2100      	movs	r1, #0
   2be52:	681b      	ldr	r3, [r3, #0]
   2be54:	4718      	bx	r3

0002be56 <radio_nrf5_isr>:
ISR_DIRECT_DECLARE(radio_nrf5_isr)
   2be56:	4668      	mov	r0, sp
   2be58:	f020 0107 	bic.w	r1, r0, #7
   2be5c:	468d      	mov	sp, r1
   2be5e:	b501      	push	{r0, lr}
	isr_radio();
   2be60:	f7f8 fd06 	bl	24870 <isr_radio>
	ISR_DIRECT_PM();
   2be64:	f7e7 fe76 	bl	13b54 <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING
	sys_trace_isr_exit();
#endif
	if (maybe_swap) {
		z_arm_int_exit();
   2be68:	f7e7 fdc8 	bl	139fc <z_arm_exc_exit>
ISR_DIRECT_DECLARE(radio_nrf5_isr)
   2be6c:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   2be70:	4685      	mov	sp, r0
   2be72:	4770      	bx	lr

0002be74 <lll_reset>:
}
   2be74:	2000      	movs	r0, #0
   2be76:	4770      	bx	lr

0002be78 <lll_prepare>:
{
   2be78:	b513      	push	{r0, r1, r4, lr}
	return prepare(is_abort_cb, abort_cb, prepare_cb, prio, prepare_param,
   2be7a:	2400      	movs	r4, #0
   2be7c:	9401      	str	r4, [sp, #4]
   2be7e:	9c04      	ldr	r4, [sp, #16]
   2be80:	9400      	str	r4, [sp, #0]
   2be82:	f7f2 fdad 	bl	1e9e0 <prepare>
}
   2be86:	b002      	add	sp, #8
   2be88:	bd10      	pop	{r4, pc}

0002be8a <lll_prepare_done>:
}
   2be8a:	2000      	movs	r0, #0
   2be8c:	4770      	bx	lr

0002be8e <lll_evt_offset_get>:
	} else if (evt->ticks_xtal_to_start & XON_BITMASK) {
   2be8e:	e9d0 2300 	ldrd	r2, r3, [r0]
   2be92:	2a00      	cmp	r2, #0
   2be94:	da04      	bge.n	2bea0 <lll_evt_offset_get+0x12>
		return MAX(evt->ticks_active_to_start,
   2be96:	6880      	ldr	r0, [r0, #8]
   2be98:	4298      	cmp	r0, r3
   2be9a:	bf38      	it	cc
   2be9c:	4618      	movcc	r0, r3
   2be9e:	4770      	bx	lr
		return MAX(evt->ticks_active_to_start,
   2bea0:	429a      	cmp	r2, r3
   2bea2:	bf38      	it	cc
   2bea4:	461a      	movcc	r2, r3
   2bea6:	4610      	mov	r0, r2
}
   2bea8:	4770      	bx	lr

0002beaa <lll_preempt_calc>:
{
   2beaa:	b510      	push	{r4, lr}
   2beac:	4614      	mov	r4, r2
	u32_t ticks_now = ticker_ticks_now_get();
   2beae:	f7ff fee8 	bl	2bc82 <ticker_ticks_now_get>
	diff = ticker_ticks_diff_get(ticks_now, ticks_at_event);
   2beb2:	4621      	mov	r1, r4
   2beb4:	f7ff fee7 	bl	2bc86 <ticker_ticks_diff_get>
	diff += HAL_TICKER_CNTR_CMP_OFFSET_MIN;
   2beb8:	3003      	adds	r0, #3
	if (!(diff & BIT(HAL_TICKER_CNTR_MSBIT)) &&
   2beba:	0203      	lsls	r3, r0, #8
   2bebc:	d404      	bmi.n	2bec8 <lll_preempt_calc+0x1e>
   2bebe:	2809      	cmp	r0, #9
   2bec0:	bf94      	ite	ls
   2bec2:	2000      	movls	r0, #0
   2bec4:	2001      	movhi	r0, #1
}
   2bec6:	bd10      	pop	{r4, pc}
	return 0;
   2bec8:	2000      	movs	r0, #0
   2beca:	e7fc      	b.n	2bec6 <lll_preempt_calc+0x1c>

0002becc <ull_adv_init>:
}
   2becc:	2000      	movs	r0, #0
   2bece:	4770      	bx	lr

0002bed0 <ull_adv_reset>:
{
   2bed0:	b508      	push	{r3, lr}
		(void)disable(handle);
   2bed2:	f7f3 fa79 	bl	1f3c8 <disable.constprop.5>
}
   2bed6:	2000      	movs	r0, #0
   2bed8:	bd08      	pop	{r3, pc}

0002beda <ull_adv_is_enabled>:
{
   2beda:	b508      	push	{r3, lr}
	adv = ull_adv_is_enabled_get(handle);
   2bedc:	f7f3 fa66 	bl	1f3ac <ull_adv_is_enabled_get>
}
   2bee0:	3000      	adds	r0, #0
   2bee2:	bf18      	it	ne
   2bee4:	2001      	movne	r0, #1
   2bee6:	bd08      	pop	{r3, pc}

0002bee8 <ull_adv_filter_pol_get>:
{
   2bee8:	b508      	push	{r3, lr}
	adv = ull_adv_is_enabled_get(handle);
   2beea:	f7f3 fa5f 	bl	1f3ac <ull_adv_is_enabled_get>
	if (!adv) {
   2beee:	b118      	cbz	r0, 2bef8 <ull_adv_filter_pol_get+0x10>
	return adv->lll.filter_policy;
   2bef0:	f890 0029 	ldrb.w	r0, [r0, #41]	; 0x29
   2bef4:	f000 0003 	and.w	r0, r0, #3
}
   2bef8:	bd08      	pop	{r3, pc}

0002befa <isr_race>:
	radio_status_reset();
   2befa:	f7f8 bdcf 	b.w	24a9c <radio_status_reset>

0002befe <isr_abort>:
{
   2befe:	b510      	push	{r4, lr}
   2bf00:	4604      	mov	r4, r0
	radio_status_reset();
   2bf02:	f7f8 fdcb 	bl	24a9c <radio_status_reset>
	radio_tmr_status_reset();
   2bf06:	f7f8 fe99 	bl	24c3c <radio_tmr_status_reset>
	radio_filter_status_reset();
   2bf0a:	f7f8 fe73 	bl	24bf4 <radio_filter_status_reset>
	radio_ar_status_reset();
   2bf0e:	f7f9 f85f 	bl	24fd0 <radio_ar_status_reset>
	radio_rssi_status_reset();
   2bf12:	f7f8 fe37 	bl	24b84 <radio_rssi_status_reset>
	radio_filter_disable();
   2bf16:	f7f8 fe63 	bl	24be0 <radio_filter_disable>
	isr_cleanup(param);
   2bf1a:	4620      	mov	r0, r4
}
   2bf1c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
   2bf20:	f7f3 bace 	b.w	1f4c0 <isr_cleanup>

0002bf24 <isr_rx_ci_adva_check>:
		       BDADDR_SIZE);
}

static inline bool isr_rx_ci_adva_check(struct pdu_adv *adv,
					struct pdu_adv *ci)
{
   2bf24:	b570      	push	{r4, r5, r6, lr}
	return (adv->tx_addr == ci->rx_addr) &&
   2bf26:	7804      	ldrb	r4, [r0, #0]
   2bf28:	780a      	ldrb	r2, [r1, #0]
   2bf2a:	f3c4 1380 	ubfx	r3, r4, #6, #1
   2bf2e:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
   2bf32:	d119      	bne.n	2bf68 <isr_rx_ci_adva_check+0x44>
   2bf34:	f004 040f 	and.w	r4, r4, #15
   2bf38:	2c01      	cmp	r4, #1
   2bf3a:	f100 0502 	add.w	r5, r0, #2
   2bf3e:	f101 0608 	add.w	r6, r1, #8
   2bf42:	d008      	beq.n	2bf56 <isr_rx_ci_adva_check+0x32>
		(((adv->type == PDU_ADV_TYPE_DIRECT_IND) &&
		 !memcmp(adv->direct_ind.adv_addr, ci->connect_ind.adv_addr,
			 BDADDR_SIZE)) ||
		 (!memcmp(adv->adv_ind.addr, ci->connect_ind.adv_addr,
   2bf44:	2206      	movs	r2, #6
   2bf46:	4631      	mov	r1, r6
   2bf48:	4628      	mov	r0, r5
   2bf4a:	f7fe fa59 	bl	2a400 <memcmp>
			 BDADDR_SIZE)) ||
   2bf4e:	fab0 f080 	clz	r0, r0
   2bf52:	0940      	lsrs	r0, r0, #5
			  BDADDR_SIZE)));
}
   2bf54:	bd70      	pop	{r4, r5, r6, pc}
		 !memcmp(adv->direct_ind.adv_addr, ci->connect_ind.adv_addr,
   2bf56:	2206      	movs	r2, #6
   2bf58:	4631      	mov	r1, r6
   2bf5a:	4628      	mov	r0, r5
   2bf5c:	f7fe fa50 	bl	2a400 <memcmp>
		(((adv->type == PDU_ADV_TYPE_DIRECT_IND) &&
   2bf60:	2800      	cmp	r0, #0
   2bf62:	d1ef      	bne.n	2bf44 <isr_rx_ci_adva_check+0x20>
	return (adv->tx_addr == ci->rx_addr) &&
   2bf64:	4620      	mov	r0, r4
   2bf66:	e7f5      	b.n	2bf54 <isr_rx_ci_adva_check+0x30>
   2bf68:	2000      	movs	r0, #0
   2bf6a:	e7f3      	b.n	2bf54 <isr_rx_ci_adva_check+0x30>

0002bf6c <resume_prepare_cb>:
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
   2bf6c:	68c3      	ldr	r3, [r0, #12]
{
   2bf6e:	b570      	push	{r4, r5, r6, lr}
   2bf70:	4604      	mov	r4, r0
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
   2bf72:	681e      	ldr	r6, [r3, #0]
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
   2bf74:	f7ff fe85 	bl	2bc82 <ticker_ticks_now_get>
   2bf78:	4605      	mov	r5, r0
   2bf7a:	4630      	mov	r0, r6
   2bf7c:	f7ff ff87 	bl	2be8e <lll_evt_offset_get>
	p->remainder = 0;
   2bf80:	2300      	movs	r3, #0
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
   2bf82:	1a28      	subs	r0, r5, r0
   2bf84:	6020      	str	r0, [r4, #0]
	p->remainder = 0;
   2bf86:	6063      	str	r3, [r4, #4]
	p->lazy = 0;
   2bf88:	8123      	strh	r3, [r4, #8]
	return prepare_cb(p);
   2bf8a:	4620      	mov	r0, r4
}
   2bf8c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return prepare_cb(p);
   2bf90:	f7f3 bd22 	b.w	1f9d8 <prepare_cb>

0002bf94 <isr_done>:
{
   2bf94:	b510      	push	{r4, lr}
   2bf96:	4604      	mov	r4, r0
	radio_status_reset();
   2bf98:	f7f8 fd80 	bl	24a9c <radio_status_reset>
	radio_tmr_status_reset();
   2bf9c:	f7f8 fe4e 	bl	24c3c <radio_tmr_status_reset>
	radio_filter_status_reset();
   2bfa0:	f7f8 fe28 	bl	24bf4 <radio_filter_status_reset>
	radio_ar_status_reset();
   2bfa4:	f7f9 f814 	bl	24fd0 <radio_ar_status_reset>
	radio_rssi_status_reset();
   2bfa8:	f7f8 fdec 	bl	24b84 <radio_rssi_status_reset>
	if (!IS_ENABLED(CONFIG_BT_CTLR_LOW_LAT) && lll->is_hdcd &&
   2bfac:	7b23      	ldrb	r3, [r4, #12]
   2bfae:	f003 0271 	and.w	r2, r3, #113	; 0x71
   2bfb2:	2a01      	cmp	r2, #1
		lll->chan_map_curr = lll->chan_map;
   2bfb4:	bf02      	ittt	eq
   2bfb6:	f3c3 0242 	ubfxeq	r2, r3, #1, #3
   2bfba:	f362 1306 	bfieq	r3, r2, #4, #3
   2bfbe:	7323      	strbeq	r3, [r4, #12]
	if (lll->chan_map_curr) {
   2bfc0:	7b23      	ldrb	r3, [r4, #12]
   2bfc2:	f013 0f70 	tst.w	r3, #112	; 0x70
   2bfc6:	d008      	beq.n	2bfda <isr_done+0x46>
		chan_prepare(lll);
   2bfc8:	4620      	mov	r0, r4
   2bfca:	f7f3 fc8b 	bl	1f8e4 <chan_prepare>
		radio_tx_enable();
   2bfce:	f7f8 fd4d 	bl	24a6c <radio_tx_enable>
}
   2bfd2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_tmr_end_capture();
   2bfd6:	f7f8 bf19 	b.w	24e0c <radio_tmr_end_capture>
	radio_filter_disable();
   2bfda:	f7f8 fe01 	bl	24be0 <radio_filter_disable>
	isr_cleanup(param);
   2bfde:	4620      	mov	r0, r4
}
   2bfe0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
   2bfe4:	f7f3 ba6c 	b.w	1f4c0 <isr_cleanup>

0002bfe8 <lll_adv_init>:
}
   2bfe8:	2000      	movs	r0, #0
   2bfea:	4770      	bx	lr

0002bfec <lll_adv_reset>:
   2bfec:	2000      	movs	r0, #0
   2bfee:	4770      	bx	lr

0002bff0 <ull_scan_init>:
}
   2bff0:	2000      	movs	r0, #0
   2bff2:	4770      	bx	lr

0002bff4 <disable.constprop.2>:

static u8_t disable(u16_t handle)
   2bff4:	b538      	push	{r3, r4, r5, lr}
{
	struct ll_scan_set *scan;
	u8_t ret;

	scan = ull_scan_is_enabled_get(handle);
   2bff6:	2000      	movs	r0, #0
   2bff8:	f7f3 fe5a 	bl	1fcb0 <ull_scan_is_enabled_get>
	if (!scan) {
   2bffc:	4604      	mov	r4, r0
   2bffe:	b198      	cbz	r0, 2c028 <disable.constprop.2+0x34>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

#if defined(CONFIG_BT_CENTRAL)
	if (scan->lll.conn) {
   2c000:	6a40      	ldr	r0, [r0, #36]	; 0x24
   2c002:	b988      	cbnz	r0, 2c028 <disable.constprop.2+0x34>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}
#endif

	ret = ull_scan_disable(handle, scan);
   2c004:	4621      	mov	r1, r4
   2c006:	f7f3 fde9 	bl	1fbdc <ull_scan_disable>
	if (ret) {
   2c00a:	4605      	mov	r5, r0
   2c00c:	b950      	cbnz	r0, 2c024 <disable.constprop.2+0x30>
		return ret;
	}

	scan->is_enabled = 0U;
   2c00e:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
   2c012:	f360 0300 	bfi	r3, r0, #0, #1
   2c016:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48

#if defined(CONFIG_BT_CTLR_PRIVACY)
#if defined(CONFIG_BT_BROADCASTER)
	if (!ull_adv_is_enabled_get(0))
   2c01a:	f7f3 f9c7 	bl	1f3ac <ull_adv_is_enabled_get>
   2c01e:	b908      	cbnz	r0, 2c024 <disable.constprop.2+0x30>
#endif
	{
		ull_filter_adv_scan_state_cb(0);
   2c020:	f7f7 fcd8 	bl	239d4 <ull_filter_adv_scan_state_cb>
	}
#endif

	return 0;
}
   2c024:	4628      	mov	r0, r5
   2c026:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   2c028:	250c      	movs	r5, #12
   2c02a:	e7fb      	b.n	2c024 <disable.constprop.2+0x30>

0002c02c <ull_scan_reset>:
{
   2c02c:	b508      	push	{r3, lr}
		(void)disable(handle);
   2c02e:	f7ff ffe1 	bl	2bff4 <disable.constprop.2>
}
   2c032:	2000      	movs	r0, #0
   2c034:	bd08      	pop	{r3, pc}

0002c036 <ll_scan_enable>:
{
   2c036:	b510      	push	{r4, lr}
	if (!enable) {
   2c038:	b918      	cbnz	r0, 2c042 <ll_scan_enable+0xc>
}
   2c03a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return disable(0);
   2c03e:	f7ff bfd9 	b.w	2bff4 <disable.constprop.2>
	scan = ull_scan_is_disabled_get(0);
   2c042:	2000      	movs	r0, #0
   2c044:	f7f3 fe42 	bl	1fccc <ull_scan_is_disabled_get>
	if (!scan) {
   2c048:	4604      	mov	r4, r0
   2c04a:	b3a0      	cbz	r0, 2c0b6 <ll_scan_enable+0x80>
	if (scan->own_addr_type & 0x1) {
   2c04c:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
   2c050:	079a      	lsls	r2, r3, #30
   2c052:	d417      	bmi.n	2c084 <ll_scan_enable+0x4e>
	ull_filter_scan_update(lll->filter_policy);
   2c054:	f894 0032 	ldrb.w	r0, [r4, #50]	; 0x32
   2c058:	f3c0 00c1 	ubfx	r0, r0, #3, #2
   2c05c:	f7f7 fcec 	bl	23a38 <ull_filter_scan_update>
	lll->rl_idx = FILTER_IDX_NONE;
   2c060:	23ff      	movs	r3, #255	; 0xff
   2c062:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
	lll->rpa_gen = 0;
   2c066:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
   2c06a:	f36f 0300 	bfc	r3, #0, #1
   2c06e:	f884 3033 	strb.w	r3, [r4, #51]	; 0x33
	if ((lll->type & 0x1) &&
   2c072:	f894 3032 	ldrb.w	r3, [r4, #50]	; 0x32
   2c076:	09db      	lsrs	r3, r3, #7
   2c078:	d10f      	bne.n	2c09a <ll_scan_enable+0x64>
	return ull_scan_enable(scan);
   2c07a:	4620      	mov	r0, r4
}
   2c07c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return ull_scan_enable(scan);
   2c080:	f7e0 bd06 	b.w	ca90 <ull_scan_enable>
		if (!mem_nz(ll_addr_get(1, NULL), BDADDR_SIZE)) {
   2c084:	2100      	movs	r1, #0
   2c086:	2001      	movs	r0, #1
   2c088:	f7f0 f8e2 	bl	1c250 <ll_addr_get>
   2c08c:	2106      	movs	r1, #6
   2c08e:	f7ff fc94 	bl	2b9ba <mem_nz>
   2c092:	2800      	cmp	r0, #0
   2c094:	d1de      	bne.n	2c054 <ll_scan_enable+0x1e>
			return BT_HCI_ERR_INVALID_PARAM;
   2c096:	2012      	movs	r0, #18
   2c098:	e00e      	b.n	2c0b8 <ll_scan_enable+0x82>
	if ((lll->type & 0x1) &&
   2c09a:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
   2c09e:	075b      	lsls	r3, r3, #29
   2c0a0:	d5eb      	bpl.n	2c07a <ll_scan_enable+0x44>
		ull_filter_rpa_update(false);
   2c0a2:	2000      	movs	r0, #0
   2c0a4:	f7f7 ff76 	bl	23f94 <ull_filter_rpa_update>
		lll->rpa_gen = 1;
   2c0a8:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
   2c0ac:	f043 0301 	orr.w	r3, r3, #1
   2c0b0:	f884 3033 	strb.w	r3, [r4, #51]	; 0x33
   2c0b4:	e7e1      	b.n	2c07a <ll_scan_enable+0x44>
		return BT_HCI_ERR_CMD_DISALLOWED;
   2c0b6:	200c      	movs	r0, #12
}
   2c0b8:	bd10      	pop	{r4, pc}

0002c0ba <ull_scan_is_enabled>:
{
   2c0ba:	b508      	push	{r3, lr}
	scan = ull_scan_is_enabled_get(handle);
   2c0bc:	f7f3 fdf8 	bl	1fcb0 <ull_scan_is_enabled_get>
	if (!scan) {
   2c0c0:	b168      	cbz	r0, 2c0de <ull_scan_is_enabled+0x24>
	return (((u32_t)scan->is_enabled << scan->lll.type) |
   2c0c2:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
   2c0c6:	f890 2032 	ldrb.w	r2, [r0, #50]	; 0x32
   2c0ca:	f003 0301 	and.w	r3, r3, #1
   2c0ce:	09d2      	lsrs	r2, r2, #7
   2c0d0:	4093      	lsls	r3, r2
		(scan->lll.conn ? BIT(2) : 0) |
   2c0d2:	6a42      	ldr	r2, [r0, #36]	; 0x24
   2c0d4:	2a00      	cmp	r2, #0
   2c0d6:	bf14      	ite	ne
   2c0d8:	2004      	movne	r0, #4
   2c0da:	2000      	moveq	r0, #0
   2c0dc:	4318      	orrs	r0, r3
}
   2c0de:	bd08      	pop	{r3, pc}

0002c0e0 <ull_scan_filter_pol_get>:
{
   2c0e0:	b508      	push	{r3, lr}
	scan = ull_scan_is_enabled_get(handle);
   2c0e2:	f7f3 fde5 	bl	1fcb0 <ull_scan_is_enabled_get>
	if (!scan) {
   2c0e6:	b118      	cbz	r0, 2c0f0 <ull_scan_filter_pol_get+0x10>
	return scan->lll.filter_policy;
   2c0e8:	f890 0032 	ldrb.w	r0, [r0, #50]	; 0x32
   2c0ec:	f3c0 00c1 	ubfx	r0, r0, #3, #2
}
   2c0f0:	bd08      	pop	{r3, pc}

0002c0f2 <isr_race>:
	radio_status_reset();
   2c0f2:	f7f8 bcd3 	b.w	24a9c <radio_status_reset>

0002c0f6 <isr_done>:
{
   2c0f6:	b508      	push	{r3, lr}
	isr_common_done(param);
   2c0f8:	f7f3 fee2 	bl	1fec0 <isr_common_done>
	radio_rx_enable();
   2c0fc:	f7f8 fcb0 	bl	24a60 <radio_rx_enable>
}
   2c100:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_tmr_end_capture();
   2c104:	f7f8 be82 	b.w	24e0c <radio_tmr_end_capture>

0002c108 <isr_scan_tgta_check>:
{
   2c108:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
					   pdu->direct_ind.tgt_addr, rl_idx)) {
   2c10c:	4690      	mov	r8, r2
{
   2c10e:	4606      	mov	r6, r0
	if (ull_filter_lll_rl_addr_resolve(pdu->rx_addr,
   2c110:	f818 0b08 	ldrb.w	r0, [r8], #8
{
   2c114:	9f08      	ldr	r7, [sp, #32]
   2c116:	468a      	mov	sl, r1
   2c118:	4615      	mov	r5, r2
	if (ull_filter_lll_rl_addr_resolve(pdu->rx_addr,
   2c11a:	4641      	mov	r1, r8
   2c11c:	461a      	mov	r2, r3
   2c11e:	09c0      	lsrs	r0, r0, #7
{
   2c120:	4699      	mov	r9, r3
	if (ull_filter_lll_rl_addr_resolve(pdu->rx_addr,
   2c122:	f7f8 f9e7 	bl	244f4 <ull_filter_lll_rl_addr_resolve>
   2c126:	4604      	mov	r4, r0
   2c128:	b9d0      	cbnz	r0, 2c160 <isr_scan_tgta_check+0x58>
	} else if (init && lll->rpa_gen &&
   2c12a:	f1ba 0f00 	cmp.w	sl, #0
   2c12e:	d10f      	bne.n	2c150 <isr_scan_tgta_check+0x48>
	return (((lll->init_addr_type == pdu->rx_addr) &&
   2c130:	7db3      	ldrb	r3, [r6, #22]
   2c132:	782a      	ldrb	r2, [r5, #0]
			BDADDR_SIZE))) ||
   2c134:	f3c3 1380 	ubfx	r3, r3, #6, #1
   2c138:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
   2c13c:	d113      	bne.n	2c166 <isr_scan_tgta_check+0x5e>
		!memcmp(lll->init_addr, pdu->direct_ind.tgt_addr,
   2c13e:	2206      	movs	r2, #6
   2c140:	4641      	mov	r1, r8
   2c142:	f106 0019 	add.w	r0, r6, #25
   2c146:	f7fe f95b 	bl	2a400 <memcmp>
	return (((lll->init_addr_type == pdu->rx_addr) &&
   2c14a:	b960      	cbnz	r0, 2c166 <isr_scan_tgta_check+0x5e>
			BDADDR_SIZE))) ||
   2c14c:	2001      	movs	r0, #1
   2c14e:	e010      	b.n	2c172 <isr_scan_tgta_check+0x6a>
	} else if (init && lll->rpa_gen &&
   2c150:	7df3      	ldrb	r3, [r6, #23]
   2c152:	07db      	lsls	r3, r3, #31
   2c154:	d5ec      	bpl.n	2c130 <isr_scan_tgta_check+0x28>
		   ull_filter_lll_lrpa_get(rl_idx)) {
   2c156:	4648      	mov	r0, r9
   2c158:	f7f8 f89c 	bl	24294 <ull_filter_lll_lrpa_get>
	} else if (init && lll->rpa_gen &&
   2c15c:	2800      	cmp	r0, #0
   2c15e:	d0e7      	beq.n	2c130 <isr_scan_tgta_check+0x28>
}
   2c160:	4620      	mov	r0, r4
   2c162:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (((lll->filter_policy & 0x02) != 0U) &&
   2c166:	7db0      	ldrb	r0, [r6, #22]
   2c168:	f3c0 00c1 	ubfx	r0, r0, #3, #2
   2c16c:	f010 0002 	ands.w	r0, r0, #2
   2c170:	d101      	bne.n	2c176 <isr_scan_tgta_check+0x6e>
			BDADDR_SIZE))) ||
   2c172:	4604      	mov	r4, r0
   2c174:	e7f4      	b.n	2c160 <isr_scan_tgta_check+0x58>
	if (((lll->filter_policy & 0x02) != 0U) &&
   2c176:	f995 3000 	ldrsb.w	r3, [r5]
   2c17a:	2b00      	cmp	r3, #0
   2c17c:	da09      	bge.n	2c192 <isr_scan_tgta_check+0x8a>
	    (pdu->rx_addr != 0) &&
   2c17e:	7b6b      	ldrb	r3, [r5, #13]
   2c180:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   2c184:	2b40      	cmp	r3, #64	; 0x40
   2c186:	d104      	bne.n	2c192 <isr_scan_tgta_check+0x8a>
		if (dir_report) {
   2c188:	2f00      	cmp	r7, #0
   2c18a:	d0df      	beq.n	2c14c <isr_scan_tgta_check+0x44>
			*dir_report = true;
   2c18c:	2001      	movs	r0, #1
   2c18e:	7038      	strb	r0, [r7, #0]
   2c190:	e7ef      	b.n	2c172 <isr_scan_tgta_check+0x6a>
			BDADDR_SIZE))) ||
   2c192:	2000      	movs	r0, #0
   2c194:	e7ed      	b.n	2c172 <isr_scan_tgta_check+0x6a>

0002c196 <resume_prepare_cb>:
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
   2c196:	68c3      	ldr	r3, [r0, #12]
{
   2c198:	b570      	push	{r4, r5, r6, lr}
   2c19a:	4604      	mov	r4, r0
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
   2c19c:	681e      	ldr	r6, [r3, #0]
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
   2c19e:	f7ff fd70 	bl	2bc82 <ticker_ticks_now_get>
   2c1a2:	4605      	mov	r5, r0
   2c1a4:	4630      	mov	r0, r6
   2c1a6:	f7ff fe72 	bl	2be8e <lll_evt_offset_get>
	p->remainder = 0;
   2c1aa:	2300      	movs	r3, #0
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
   2c1ac:	1a28      	subs	r0, r5, r0
   2c1ae:	6020      	str	r0, [r4, #0]
	p->remainder = 0;
   2c1b0:	6063      	str	r3, [r4, #4]
	p->lazy = 0;
   2c1b2:	8123      	strh	r3, [r4, #8]
	return prepare_cb(p);
   2c1b4:	4620      	mov	r0, r4
}
   2c1b6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return prepare_cb(p);
   2c1ba:	f7f3 bda1 	b.w	1fd00 <prepare_cb>

0002c1be <isr_window>:
{
   2c1be:	b508      	push	{r3, lr}
	isr_common_done(param);
   2c1c0:	f7f3 fe7e 	bl	1fec0 <isr_common_done>
	ticks_at_start = ticker_ticks_now_get() +
   2c1c4:	f7ff fd5d 	bl	2bc82 <ticker_ticks_now_get>
	remainder_us = radio_tmr_start_tick(0, ticks_at_start);
   2c1c8:	1cc1      	adds	r1, r0, #3
   2c1ca:	2000      	movs	r0, #0
   2c1cc:	f7f8 fdae 	bl	24d2c <radio_tmr_start_tick>
}
   2c1d0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_tmr_end_capture();
   2c1d4:	f7f8 be1a 	b.w	24e0c <radio_tmr_end_capture>

0002c1d8 <isr_abort>:
{
   2c1d8:	b513      	push	{r0, r1, r4, lr}
   2c1da:	4604      	mov	r4, r0
	radio_status_reset();
   2c1dc:	f7f8 fc5e 	bl	24a9c <radio_status_reset>
	radio_tmr_status_reset();
   2c1e0:	f7f8 fd2c 	bl	24c3c <radio_tmr_status_reset>
	radio_filter_status_reset();
   2c1e4:	f7f8 fd06 	bl	24bf4 <radio_filter_status_reset>
	radio_ar_status_reset();
   2c1e8:	f7f8 fef2 	bl	24fd0 <radio_ar_status_reset>
	radio_rssi_status_reset();
   2c1ec:	f7f8 fcca 	bl	24b84 <radio_rssi_status_reset>
	ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_LLL,
   2c1f0:	2300      	movs	r3, #0
   2c1f2:	9300      	str	r3, [sp, #0]
   2c1f4:	2203      	movs	r2, #3
   2c1f6:	4619      	mov	r1, r3
   2c1f8:	4618      	mov	r0, r3
   2c1fa:	f7ef ffef 	bl	1c1dc <ticker_stop>
	radio_disable();
   2c1fe:	f7f8 fc3b 	bl	24a78 <radio_disable>
	isr_cleanup(param);
   2c202:	4620      	mov	r0, r4
}
   2c204:	b002      	add	sp, #8
   2c206:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
   2c20a:	f7f3 bf5d 	b.w	200c8 <isr_cleanup>

0002c20e <isr_rx_scan_report.isra.4>:
			&srsp->scan_rsp.addr[0], BDADDR_SIZE) == 0));
}

static u32_t isr_rx_scan_report(struct lll_scan *lll, u8_t rssi_ready,
   2c20e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2c210:	4607      	mov	r7, r0
				u8_t rl_idx, bool dir_report)
{
	struct node_rx_pdu *node_rx;
	struct pdu_adv *pdu_adv_rx;

	node_rx = ull_pdu_rx_alloc_peek(3);
   2c212:	2003      	movs	r0, #3
static u32_t isr_rx_scan_report(struct lll_scan *lll, u8_t rssi_ready,
   2c214:	460e      	mov	r6, r1
   2c216:	4615      	mov	r5, r2
	node_rx = ull_pdu_rx_alloc_peek(3);
   2c218:	f7f2 f990 	bl	1e53c <ull_pdu_rx_alloc_peek>
	if (!node_rx) {
   2c21c:	4604      	mov	r4, r0
   2c21e:	b1c0      	cbz	r0, 2c252 <isr_rx_scan_report.isra.4+0x44>
		return 1;
	}
	ull_pdu_rx_alloc();
   2c220:	f7f2 f9a4 	bl	1e56c <ull_pdu_rx_alloc>

	/* Prepare the report (adv or scan resp) */
	node_rx->hdr.handle = 0xffff;
   2c224:	f64f 73ff 	movw	r3, #65535	; 0xffff
   2c228:	80e3      	strh	r3, [r4, #6]
			LL_ASSERT(0);
			break;
		}
#endif /* CONFIG_BT_CTLR_ADV_EXT */
	} else {
		node_rx->hdr.type = NODE_RX_TYPE_REPORT;
   2c22a:	2304      	movs	r3, #4
   2c22c:	7123      	strb	r3, [r4, #4]
	}

	pdu_adv_rx = (void *)node_rx->pdu;

	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ?
   2c22e:	b177      	cbz	r7, 2c24e <isr_rx_scan_report.isra.4+0x40>
				   (radio_rssi_get() & 0x7f)
   2c230:	f7f8 fca2 	bl	24b78 <radio_rssi_get>
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ?
   2c234:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   2c238:	7720      	strb	r0, [r4, #28]
		node_rx->hdr.rx_ftr.chan = _radio.scanner.chan - 1;
		node_rx->hdr.rx_ftr.ticks_anchor = _radio.ticks_anchor;
	}
#endif /* CONFIG_BT_CTLR_EXT_SCAN_FP */

	ull_rx_put(node_rx->hdr.link, node_rx);
   2c23a:	4621      	mov	r1, r4
   2c23c:	6820      	ldr	r0, [r4, #0]
	node_rx->hdr.rx_ftr.rl_idx = rl_idx;
   2c23e:	7766      	strb	r6, [r4, #29]
	node_rx->hdr.rx_ftr.direct = dir_report;
   2c240:	77a5      	strb	r5, [r4, #30]
	ull_rx_put(node_rx->hdr.link, node_rx);
   2c242:	f7f2 f9a9 	bl	1e598 <ull_rx_put>
	ull_rx_sched();
   2c246:	f7f2 f9b7 	bl	1e5b8 <ull_rx_sched>

	return 0;
   2c24a:	2000      	movs	r0, #0
}
   2c24c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ?
   2c24e:	207f      	movs	r0, #127	; 0x7f
   2c250:	e7f2      	b.n	2c238 <isr_rx_scan_report.isra.4+0x2a>
		return 1;
   2c252:	2001      	movs	r0, #1
   2c254:	e7fa      	b.n	2c24c <isr_rx_scan_report.isra.4+0x3e>

0002c256 <lll_scan_init>:
}
   2c256:	2000      	movs	r0, #0
   2c258:	4770      	bx	lr

0002c25a <lll_scan_reset>:
   2c25a:	2000      	movs	r0, #0
   2c25c:	4770      	bx	lr

0002c25e <tx_ull_dequeue>:
{
   2c25e:	4603      	mov	r3, r0
	if (!conn->tx_ctrl && (conn->tx_head != conn->tx_data)) {
   2c260:	e9d0 206c 	ldrd	r2, r0, [r0, #432]	; 0x1b0
{
   2c264:	b510      	push	{r4, lr}
	if (!conn->tx_ctrl && (conn->tx_head != conn->tx_data)) {
   2c266:	b978      	cbnz	r0, 2c288 <tx_ull_dequeue+0x2a>
   2c268:	f8d3 01bc 	ldr.w	r0, [r3, #444]	; 0x1bc
   2c26c:	4290      	cmp	r0, r2
   2c26e:	d00b      	beq.n	2c288 <tx_ull_dequeue+0x2a>
		if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   2c270:	7910      	ldrb	r0, [r2, #4]
   2c272:	f000 0003 	and.w	r0, r0, #3
   2c276:	2803      	cmp	r0, #3
   2c278:	d104      	bne.n	2c284 <tx_ull_dequeue+0x26>
		    ((pdu_data_tx->llctrl.opcode !=
   2c27a:	79d0      	ldrb	r0, [r2, #7]
		if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
   2c27c:	2803      	cmp	r0, #3
   2c27e:	d003      	beq.n	2c288 <tx_ull_dequeue+0x2a>
		      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
   2c280:	280a      	cmp	r0, #10
   2c282:	d001      	beq.n	2c288 <tx_ull_dequeue+0x2a>
			conn->tx_ctrl = conn->tx_ctrl_last = conn->tx_head;
   2c284:	e9c3 226d 	strd	r2, r2, [r3, #436]	; 0x1b4
	if (conn->tx_head == conn->tx_ctrl) {
   2c288:	f8d3 41b4 	ldr.w	r4, [r3, #436]	; 0x1b4
   2c28c:	6810      	ldr	r0, [r2, #0]
   2c28e:	4294      	cmp	r4, r2
   2c290:	d10d      	bne.n	2c2ae <tx_ull_dequeue+0x50>
		if (conn->tx_ctrl == conn->tx_ctrl_last) {
   2c292:	f8d3 41b8 	ldr.w	r4, [r3, #440]	; 0x1b8
		conn->tx_head = conn->tx_head->next;
   2c296:	f8c3 01b0 	str.w	r0, [r3, #432]	; 0x1b0
		if (conn->tx_ctrl == conn->tx_ctrl_last) {
   2c29a:	42a2      	cmp	r2, r4
			conn->tx_ctrl = NULL;
   2c29c:	bf06      	itte	eq
   2c29e:	2200      	moveq	r2, #0
			conn->tx_ctrl_last = NULL;
   2c2a0:	e9c3 226d 	strdeq	r2, r2, [r3, #436]	; 0x1b4
			conn->tx_ctrl = conn->tx_head;
   2c2a4:	f8c3 01b4 	strne.w	r0, [r3, #436]	; 0x1b4
		tx->next = tx;
   2c2a8:	6009      	str	r1, [r1, #0]
}
   2c2aa:	4608      	mov	r0, r1
   2c2ac:	bd10      	pop	{r4, pc}
		if (conn->tx_head == conn->tx_data) {
   2c2ae:	f8d3 41bc 	ldr.w	r4, [r3, #444]	; 0x1bc
		conn->tx_head = conn->tx_head->next;
   2c2b2:	f8c3 01b0 	str.w	r0, [r3, #432]	; 0x1b0
		if (conn->tx_head == conn->tx_data) {
   2c2b6:	4294      	cmp	r4, r2
			conn->tx_data = conn->tx_data->next;
   2c2b8:	bf08      	it	eq
   2c2ba:	f8c3 01bc 	streq.w	r0, [r3, #444]	; 0x1bc
		tx->next = NULL;
   2c2be:	2300      	movs	r3, #0
   2c2c0:	600b      	str	r3, [r1, #0]
   2c2c2:	e7f2      	b.n	2c2aa <tx_ull_dequeue+0x4c>

0002c2c4 <calc_eff_time>:
{
   2c2c4:	b510      	push	{r4, lr}
	u16_t time = PKT_US(max_octets, phy);
   2c2c6:	f011 0404 	ands.w	r4, r1, #4
   2c2ca:	d010      	beq.n	2c2ee <calc_eff_time+0x2a>
   2c2cc:	0180      	lsls	r0, r0, #6
   2c2ce:	f500 7074 	add.w	r0, r0, #976	; 0x3d0
		eff_time = MIN(time, default_time);
   2c2d2:	4282      	cmp	r2, r0
   2c2d4:	bf28      	it	cs
   2c2d6:	4602      	movcs	r2, r0
		eff_time = MAX(eff_time, PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, phy));
   2c2d8:	b9b4      	cbnz	r4, 2c308 <calc_eff_time+0x44>
   2c2da:	f3c1 0140 	ubfx	r1, r1, #1, #1
   2c2de:	f44f 70a4 	mov.w	r0, #328	; 0x148
   2c2e2:	40c8      	lsrs	r0, r1
   2c2e4:	4282      	cmp	r2, r0
   2c2e6:	bf38      	it	cc
   2c2e8:	4602      	movcc	r2, r0
   2c2ea:	b290      	uxth	r0, r2
}
   2c2ec:	bd10      	pop	{r4, pc}
	u16_t time = PKT_US(max_octets, phy);
   2c2ee:	f100 030e 	add.w	r3, r0, #14
   2c2f2:	00db      	lsls	r3, r3, #3
   2c2f4:	f3c1 0040 	ubfx	r0, r1, #1, #1
   2c2f8:	40c3      	lsrs	r3, r0
	if (time >= PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0)) {
   2c2fa:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
	u16_t time = PKT_US(max_octets, phy);
   2c2fe:	b298      	uxth	r0, r3
	if (time >= PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0)) {
   2c300:	d2e7      	bcs.n	2c2d2 <calc_eff_time+0xe>
		eff_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, 0);
   2c302:	f44f 70a4 	mov.w	r0, #328	; 0x148
   2c306:	e7f1      	b.n	2c2ec <calc_eff_time+0x28>
		eff_time = MAX(eff_time, PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, phy));
   2c308:	f44f 6029 	mov.w	r0, #2704	; 0xa90
   2c30c:	e7ea      	b.n	2c2e4 <calc_eff_time+0x20>

0002c30e <ctrl_tx_sec_enqueue>:
	if (conn->llcp_enc.pause_tx) {
   2c30e:	f890 2152 	ldrb.w	r2, [r0, #338]	; 0x152
   2c312:	f012 0202 	ands.w	r2, r2, #2
{
   2c316:	b410      	push	{r4}
	if (conn->llcp_enc.pause_tx) {
   2c318:	d013      	beq.n	2c342 <ctrl_tx_sec_enqueue+0x34>
		if (!conn->tx_ctrl) {
   2c31a:	f8d0 31b4 	ldr.w	r3, [r0, #436]	; 0x1b4
   2c31e:	b953      	cbnz	r3, 2c336 <ctrl_tx_sec_enqueue+0x28>
			tx->next = conn->tx_head;
   2c320:	f8d0 31b0 	ldr.w	r3, [r0, #432]	; 0x1b0
   2c324:	600b      	str	r3, [r1, #0]
			conn->tx_head = tx;
   2c326:	f8c0 11b0 	str.w	r1, [r0, #432]	; 0x1b0
		if (!tx->next) {
   2c32a:	680b      	ldr	r3, [r1, #0]
   2c32c:	b90b      	cbnz	r3, 2c332 <ctrl_tx_sec_enqueue+0x24>
			conn->tx_data_last = tx;
   2c32e:	f8c0 11c0 	str.w	r1, [r0, #448]	; 0x1c0
}
   2c332:	bc10      	pop	{r4}
   2c334:	4770      	bx	lr
			tx->next = conn->tx_ctrl_last->next;
   2c336:	f8d0 31b8 	ldr.w	r3, [r0, #440]	; 0x1b8
   2c33a:	681a      	ldr	r2, [r3, #0]
   2c33c:	600a      	str	r2, [r1, #0]
			conn->tx_ctrl_last->next = tx;
   2c33e:	6019      	str	r1, [r3, #0]
   2c340:	e7f3      	b.n	2c32a <ctrl_tx_sec_enqueue+0x1c>
		if (conn->tx_head) {
   2c342:	f8d0 31b0 	ldr.w	r3, [r0, #432]	; 0x1b0
   2c346:	b15b      	cbz	r3, 2c360 <ctrl_tx_sec_enqueue+0x52>
			if ((pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
   2c348:	791c      	ldrb	r4, [r3, #4]
   2c34a:	f004 0403 	and.w	r4, r4, #3
   2c34e:	2c03      	cmp	r4, #3
   2c350:	d103      	bne.n	2c35a <ctrl_tx_sec_enqueue+0x4c>
   2c352:	79da      	ldrb	r2, [r3, #7]
   2c354:	1ed3      	subs	r3, r2, #3
   2c356:	425a      	negs	r2, r3
   2c358:	415a      	adcs	r2, r3
}
   2c35a:	bc10      	pop	{r4}
		ctrl_tx_pause_enqueue(conn, tx, pause);
   2c35c:	f7f4 b862 	b.w	20424 <ctrl_tx_pause_enqueue>
	bool pause = false;
   2c360:	461a      	mov	r2, r3
   2c362:	e7fa      	b.n	2c35a <ctrl_tx_sec_enqueue+0x4c>

0002c364 <ctrl_tx_enqueue>:
	ctrl_tx_pause_enqueue(conn, tx, false);
   2c364:	2200      	movs	r2, #0
   2c366:	f7f4 b85d 	b.w	20424 <ctrl_tx_pause_enqueue>

0002c36a <start_enc_rsp_send>:
	conn->lll.enc_tx = 1;
   2c36a:	f890 307e 	ldrb.w	r3, [r0, #126]	; 0x7e
   2c36e:	f043 0310 	orr.w	r3, r3, #16
   2c372:	f880 307e 	strb.w	r3, [r0, #126]	; 0x7e
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
   2c376:	780b      	ldrb	r3, [r1, #0]
   2c378:	f043 0303 	orr.w	r3, r3, #3
   2c37c:	700b      	strb	r3, [r1, #0]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
   2c37e:	2301      	movs	r3, #1
   2c380:	704b      	strb	r3, [r1, #1]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_START_ENC_RSP;
   2c382:	2306      	movs	r3, #6
   2c384:	70cb      	strb	r3, [r1, #3]
}
   2c386:	2000      	movs	r0, #0
   2c388:	4770      	bx	lr

0002c38a <ll_connected_get>:
	if (handle >= CONFIG_BT_MAX_CONN) {
   2c38a:	2804      	cmp	r0, #4
{
   2c38c:	b510      	push	{r4, lr}
   2c38e:	4604      	mov	r4, r0
	if (handle >= CONFIG_BT_MAX_CONN) {
   2c390:	d804      	bhi.n	2c39c <ll_connected_get+0x12>
	conn = ll_conn_get(handle);
   2c392:	f7f4 f8fd 	bl	20590 <ll_conn_get>
	if (conn->lll.handle != handle) {
   2c396:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
   2c398:	42a3      	cmp	r3, r4
   2c39a:	d000      	beq.n	2c39e <ll_connected_get+0x14>
		return NULL;
   2c39c:	2000      	movs	r0, #0
}
   2c39e:	bd10      	pop	{r4, pc}

0002c3a0 <ll_conn_update>:
{
   2c3a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2c3a4:	460d      	mov	r5, r1
   2c3a6:	4690      	mov	r8, r2
   2c3a8:	469a      	mov	sl, r3
   2c3aa:	f8bd 9020 	ldrh.w	r9, [sp, #32]
   2c3ae:	f8bd 7024 	ldrh.w	r7, [sp, #36]	; 0x24
   2c3b2:	f8bd 6028 	ldrh.w	r6, [sp, #40]	; 0x28
	conn = ll_connected_get(handle);
   2c3b6:	f7ff ffe8 	bl	2c38a <ll_connected_get>
	if (!conn) {
   2c3ba:	4604      	mov	r4, r0
   2c3bc:	2800      	cmp	r0, #0
   2c3be:	d065      	beq.n	2c48c <ll_conn_update+0xec>
	if (!cmd) {
   2c3c0:	bb7d      	cbnz	r5, 2c422 <ll_conn_update+0x82>
		if (!conn->llcp_conn_param.disabled &&
   2c3c2:	f890 3172 	ldrb.w	r3, [r0, #370]	; 0x172
   2c3c6:	06da      	lsls	r2, r3, #27
   2c3c8:	d408      	bmi.n	2c3dc <ll_conn_update+0x3c>
		    (!conn->common.fex_valid ||
   2c3ca:	f890 10dc 	ldrb.w	r1, [r0, #220]	; 0xdc
		if (!conn->llcp_conn_param.disabled &&
   2c3ce:	f011 0101 	ands.w	r1, r1, #1
   2c3d2:	d041      	beq.n	2c458 <ll_conn_update+0xb8>
		     (conn->llcp_feature.features &
   2c3d4:	f8d0 311c 	ldr.w	r3, [r0, #284]	; 0x11c
		    (!conn->common.fex_valid ||
   2c3d8:	079b      	lsls	r3, r3, #30
   2c3da:	d423      	bmi.n	2c424 <ll_conn_update+0x84>
		} else if (conn->lll.role) {
   2c3dc:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   2c3e0:	2b00      	cmp	r3, #0
   2c3e2:	db51      	blt.n	2c488 <ll_conn_update+0xe8>
		if (conn->llcp_cu.req != conn->llcp_cu.ack) {
   2c3e4:	f894 3104 	ldrb.w	r3, [r4, #260]	; 0x104
   2c3e8:	f894 2105 	ldrb.w	r2, [r4, #261]	; 0x105
   2c3ec:	429a      	cmp	r2, r3
   2c3ee:	d14d      	bne.n	2c48c <ll_conn_update+0xec>
		conn->llcp_cu.win_size = 1U;
   2c3f0:	2301      	movs	r3, #1
   2c3f2:	f884 3114 	strb.w	r3, [r4, #276]	; 0x114
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   2c3f6:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
		conn->llcp_cu.interval = interval_max;
   2c3fa:	f8a4 9108 	strh.w	r9, [r4, #264]	; 0x108
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   2c3fe:	f023 0307 	bic.w	r3, r3, #7
		conn->llcp_cu.win_offset_us = 0U;
   2c402:	2000      	movs	r0, #0
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   2c404:	f043 0305 	orr.w	r3, r3, #5
		conn->llcp_cu.req++;
   2c408:	3201      	adds	r2, #1
		conn->llcp_cu.win_offset_us = 0U;
   2c40a:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
		conn->llcp_cu.latency = latency;
   2c40e:	f8a4 710a 	strh.w	r7, [r4, #266]	; 0x10a
		conn->llcp_cu.timeout = timeout;
   2c412:	f8a4 610c 	strh.w	r6, [r4, #268]	; 0x10c
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
   2c416:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
		conn->llcp_cu.req++;
   2c41a:	f884 2104 	strb.w	r2, [r4, #260]	; 0x104
}
   2c41e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2c422:	4629      	mov	r1, r5
		cmd--;
   2c424:	1e48      	subs	r0, r1, #1
		if (cmd) {
   2c426:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
   2c42a:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
   2c42e:	f894 2171 	ldrb.w	r2, [r4, #369]	; 0x171
   2c432:	d013      	beq.n	2c45c <ll_conn_update+0xbc>
			if ((conn->llcp_conn_param.req ==
   2c434:	4293      	cmp	r3, r2
   2c436:	d029      	beq.n	2c48c <ll_conn_update+0xec>
			    (conn->llcp_conn_param.state !=
   2c438:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
			     conn->llcp_conn_param.ack) ||
   2c43c:	f003 0207 	and.w	r2, r3, #7
   2c440:	2a03      	cmp	r2, #3
   2c442:	d123      	bne.n	2c48c <ll_conn_update+0xec>
			conn->llcp_conn_param.state = cmd;
   2c444:	f360 0302 	bfi	r3, r0, #0, #3
			conn->llcp_conn_param.cmd = 1U;
   2c448:	f043 0308 	orr.w	r3, r3, #8
			conn->llcp_conn_param.status = status;
   2c44c:	f884 8173 	strb.w	r8, [r4, #371]	; 0x173
			conn->llcp_conn_param.cmd = 1U;
   2c450:	f884 3172 	strb.w	r3, [r4, #370]	; 0x172
	return 0;
   2c454:	2000      	movs	r0, #0
   2c456:	e7e2      	b.n	2c41e <ll_conn_update+0x7e>
			cmd++;
   2c458:	2101      	movs	r1, #1
   2c45a:	e7e3      	b.n	2c424 <ll_conn_update+0x84>
			if (conn->llcp_conn_param.req !=
   2c45c:	4293      	cmp	r3, r2
   2c45e:	d115      	bne.n	2c48c <ll_conn_update+0xec>
			conn->llcp_conn_param.state = cmd;
   2c460:	f8b4 2172 	ldrh.w	r2, [r4, #370]	; 0x172
			conn->llcp_conn_param.interval_min = interval_min;
   2c464:	f8a4 a174 	strh.w	sl, [r4, #372]	; 0x174
			conn->llcp_conn_param.state = cmd;
   2c468:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
   2c46c:	f042 0208 	orr.w	r2, r2, #8
			conn->llcp_conn_param.req++;
   2c470:	3301      	adds	r3, #1
			conn->llcp_conn_param.interval_max = interval_max;
   2c472:	f8a4 9176 	strh.w	r9, [r4, #374]	; 0x176
			conn->llcp_conn_param.latency = latency;
   2c476:	f8a4 7178 	strh.w	r7, [r4, #376]	; 0x178
			conn->llcp_conn_param.timeout = timeout;
   2c47a:	f8a4 617a 	strh.w	r6, [r4, #378]	; 0x17a
			conn->llcp_conn_param.state = cmd;
   2c47e:	f8a4 2172 	strh.w	r2, [r4, #370]	; 0x172
			conn->llcp_conn_param.req++;
   2c482:	f884 3170 	strb.w	r3, [r4, #368]	; 0x170
   2c486:	e7ca      	b.n	2c41e <ll_conn_update+0x7e>
			return BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
   2c488:	201a      	movs	r0, #26
   2c48a:	e7c8      	b.n	2c41e <ll_conn_update+0x7e>
		return BT_HCI_ERR_CMD_DISALLOWED;
   2c48c:	200c      	movs	r0, #12
   2c48e:	e7c6      	b.n	2c41e <ll_conn_update+0x7e>

0002c490 <ll_chm_get>:
{
   2c490:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2c492:	460d      	mov	r5, r1
	conn = ll_connected_get(handle);
   2c494:	f7ff ff79 	bl	2c38a <ll_connected_get>
	if (!conn) {
   2c498:	4604      	mov	r4, r0
   2c49a:	b170      	cbz	r0, 2c4ba <ll_chm_get+0x2a>
		conn->chm_updated = 0U;
   2c49c:	2700      	movs	r7, #0
		memcpy(chm, conn->lll.data_chan_map,
   2c49e:	f100 0638 	add.w	r6, r0, #56	; 0x38
		conn->chm_updated = 0U;
   2c4a2:	f884 71c4 	strb.w	r7, [r4, #452]	; 0x1c4
		memcpy(chm, conn->lll.data_chan_map,
   2c4a6:	2205      	movs	r2, #5
   2c4a8:	4631      	mov	r1, r6
   2c4aa:	4628      	mov	r0, r5
   2c4ac:	f7fd ffcf 	bl	2a44e <memcpy>
	} while (conn->chm_updated);
   2c4b0:	f894 01c4 	ldrb.w	r0, [r4, #452]	; 0x1c4
   2c4b4:	2800      	cmp	r0, #0
   2c4b6:	d1f4      	bne.n	2c4a2 <ll_chm_get+0x12>
}
   2c4b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   2c4ba:	200c      	movs	r0, #12
   2c4bc:	e7fc      	b.n	2c4b8 <ll_chm_get+0x28>

0002c4be <ll_terminate_ind_send>:
{
   2c4be:	b510      	push	{r4, lr}
   2c4c0:	460c      	mov	r4, r1
	conn = ll_connected_get(handle);
   2c4c2:	f7ff ff62 	bl	2c38a <ll_connected_get>
	if (!conn) {
   2c4c6:	b140      	cbz	r0, 2c4da <ll_terminate_ind_send+0x1c>
	conn->llcp_terminate.req++;
   2c4c8:	f890 3128 	ldrb.w	r3, [r0, #296]	; 0x128
	conn->llcp_terminate.reason_own = reason;
   2c4cc:	f880 412a 	strb.w	r4, [r0, #298]	; 0x12a
	conn->llcp_terminate.req++;
   2c4d0:	3301      	adds	r3, #1
   2c4d2:	f880 3128 	strb.w	r3, [r0, #296]	; 0x128
	return 0;
   2c4d6:	2000      	movs	r0, #0
}
   2c4d8:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   2c4da:	200c      	movs	r0, #12
   2c4dc:	e7fc      	b.n	2c4d8 <ll_terminate_ind_send+0x1a>

0002c4de <ll_feature_req_send>:
{
   2c4de:	b508      	push	{r3, lr}
	conn = ll_connected_get(handle);
   2c4e0:	f7ff ff53 	bl	2c38a <ll_connected_get>
	if (!conn) {
   2c4e4:	b150      	cbz	r0, 2c4fc <ll_feature_req_send+0x1e>
	if (conn->llcp_feature.req != conn->llcp_feature.ack) {
   2c4e6:	f890 2118 	ldrb.w	r2, [r0, #280]	; 0x118
   2c4ea:	f890 3119 	ldrb.w	r3, [r0, #281]	; 0x119
   2c4ee:	4293      	cmp	r3, r2
   2c4f0:	d104      	bne.n	2c4fc <ll_feature_req_send+0x1e>
	conn->llcp_feature.req++;
   2c4f2:	3301      	adds	r3, #1
   2c4f4:	f880 3118 	strb.w	r3, [r0, #280]	; 0x118
	return 0;
   2c4f8:	2000      	movs	r0, #0
}
   2c4fa:	bd08      	pop	{r3, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   2c4fc:	200c      	movs	r0, #12
   2c4fe:	e7fc      	b.n	2c4fa <ll_feature_req_send+0x1c>

0002c500 <ll_version_ind_send>:
{
   2c500:	b508      	push	{r3, lr}
	conn = ll_connected_get(handle);
   2c502:	f7ff ff42 	bl	2c38a <ll_connected_get>
	if (!conn) {
   2c506:	b150      	cbz	r0, 2c51e <ll_version_ind_send+0x1e>
	if (conn->llcp_version.req != conn->llcp_version.ack) {
   2c508:	f890 2120 	ldrb.w	r2, [r0, #288]	; 0x120
   2c50c:	f890 3121 	ldrb.w	r3, [r0, #289]	; 0x121
   2c510:	4293      	cmp	r3, r2
   2c512:	d104      	bne.n	2c51e <ll_version_ind_send+0x1e>
	conn->llcp_version.req++;
   2c514:	3301      	adds	r3, #1
   2c516:	f880 3120 	strb.w	r3, [r0, #288]	; 0x120
	return 0;
   2c51a:	2000      	movs	r0, #0
}
   2c51c:	bd08      	pop	{r3, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
   2c51e:	200c      	movs	r0, #12
   2c520:	e7fc      	b.n	2c51c <ll_version_ind_send+0x1c>

0002c522 <ll_length_req_send>:
{
   2c522:	b570      	push	{r4, r5, r6, lr}
   2c524:	460e      	mov	r6, r1
   2c526:	4615      	mov	r5, r2
	conn = ll_connected_get(handle);
   2c528:	f7ff ff2f 	bl	2c38a <ll_connected_get>
	if (!conn) {
   2c52c:	b340      	cbz	r0, 2c580 <ll_length_req_send+0x5e>
	if (conn->llcp_length.req != conn->llcp_length.ack) {
   2c52e:	f890 2198 	ldrb.w	r2, [r0, #408]	; 0x198
   2c532:	f890 3199 	ldrb.w	r3, [r0, #409]	; 0x199
   2c536:	4293      	cmp	r3, r2
   2c538:	d014      	beq.n	2c564 <ll_length_req_send+0x42>
		switch (conn->llcp_length.state) {
   2c53a:	f890 319a 	ldrb.w	r3, [r0, #410]	; 0x19a
   2c53e:	f003 0307 	and.w	r3, r3, #7
   2c542:	2b07      	cmp	r3, #7
   2c544:	d01e      	beq.n	2c584 <ll_length_req_send+0x62>
   2c546:	2401      	movs	r4, #1
   2c548:	fa04 f303 	lsl.w	r3, r4, r3
   2c54c:	f013 0f68 	tst.w	r3, #104	; 0x68
   2c550:	d018      	beq.n	2c584 <ll_length_req_send+0x62>
			if (!conn->llcp_length.cache.tx_octets) {
   2c552:	f8b0 31a4 	ldrh.w	r3, [r0, #420]	; 0x1a4
   2c556:	b9ab      	cbnz	r3, 2c584 <ll_length_req_send+0x62>
				conn->llcp_length.cache.tx_octets = tx_octets;
   2c558:	f8a0 61a4 	strh.w	r6, [r0, #420]	; 0x1a4
				conn->llcp_length.cache.tx_time = tx_time;
   2c55c:	f8a0 51a6 	strh.w	r5, [r0, #422]	; 0x1a6
	return 0;
   2c560:	2000      	movs	r0, #0
}
   2c562:	bd70      	pop	{r4, r5, r6, pc}
	conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
   2c564:	f890 219a 	ldrb.w	r2, [r0, #410]	; 0x19a
	conn->llcp_length.tx_octets = tx_octets;
   2c568:	f8a0 619e 	strh.w	r6, [r0, #414]	; 0x19e
	conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
   2c56c:	f36f 0202 	bfc	r2, #0, #3
	conn->llcp_length.req++;
   2c570:	3301      	adds	r3, #1
	conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
   2c572:	f880 219a 	strb.w	r2, [r0, #410]	; 0x19a
	conn->llcp_length.tx_time = tx_time;
   2c576:	f8a0 51a2 	strh.w	r5, [r0, #418]	; 0x1a2
	conn->llcp_length.req++;
   2c57a:	f880 3198 	strb.w	r3, [r0, #408]	; 0x198
   2c57e:	e7ef      	b.n	2c560 <ll_length_req_send+0x3e>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   2c580:	2002      	movs	r0, #2
   2c582:	e7ee      	b.n	2c562 <ll_length_req_send+0x40>
			return BT_HCI_ERR_CMD_DISALLOWED;
   2c584:	200c      	movs	r0, #12
   2c586:	e7ec      	b.n	2c562 <ll_length_req_send+0x40>

0002c588 <ll_length_max_get>:
{
   2c588:	b510      	push	{r4, lr}
	*max_tx_octets = LL_LENGTH_OCTETS_RX_MAX;
   2c58a:	241b      	movs	r4, #27
   2c58c:	8004      	strh	r4, [r0, #0]
	*max_rx_octets = LL_LENGTH_OCTETS_RX_MAX;
   2c58e:	8014      	strh	r4, [r2, #0]
	*max_tx_time = PKT_US(LL_LENGTH_OCTETS_RX_MAX, BIT(2));
   2c590:	f44f 6229 	mov.w	r2, #2704	; 0xa90
   2c594:	800a      	strh	r2, [r1, #0]
	*max_rx_time = PKT_US(LL_LENGTH_OCTETS_RX_MAX, BIT(2));
   2c596:	801a      	strh	r2, [r3, #0]
}
   2c598:	bd10      	pop	{r4, pc}

0002c59a <ll_phy_get>:
{
   2c59a:	b538      	push	{r3, r4, r5, lr}
   2c59c:	460d      	mov	r5, r1
   2c59e:	4614      	mov	r4, r2
	conn = ll_connected_get(handle);
   2c5a0:	f7ff fef3 	bl	2c38a <ll_connected_get>
	if (!conn) {
   2c5a4:	b158      	cbz	r0, 2c5be <ll_phy_get+0x24>
	*tx = conn->lll.phy_tx;
   2c5a6:	f890 3064 	ldrb.w	r3, [r0, #100]	; 0x64
   2c5aa:	f3c3 0302 	ubfx	r3, r3, #0, #3
   2c5ae:	702b      	strb	r3, [r5, #0]
	*rx = conn->lll.phy_rx;
   2c5b0:	f890 3065 	ldrb.w	r3, [r0, #101]	; 0x65
   2c5b4:	f3c3 0302 	ubfx	r3, r3, #0, #3
   2c5b8:	7023      	strb	r3, [r4, #0]
	return 0;
   2c5ba:	2000      	movs	r0, #0
}
   2c5bc:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   2c5be:	2002      	movs	r0, #2
   2c5c0:	e7fc      	b.n	2c5bc <ll_phy_get+0x22>

0002c5c2 <ll_phy_req_send>:
{
   2c5c2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2c5c6:	4689      	mov	r9, r1
   2c5c8:	4690      	mov	r8, r2
   2c5ca:	461f      	mov	r7, r3
	conn = ll_connected_get(handle);
   2c5cc:	f7ff fedd 	bl	2c38a <ll_connected_get>
	if (!conn) {
   2c5d0:	b330      	cbz	r0, 2c620 <ll_phy_req_send+0x5e>
	if ((conn->llcp_req != conn->llcp_ack) ||
   2c5d2:	f890 20e8 	ldrb.w	r2, [r0, #232]	; 0xe8
   2c5d6:	f890 30e9 	ldrb.w	r3, [r0, #233]	; 0xe9
   2c5da:	429a      	cmp	r2, r3
   2c5dc:	d122      	bne.n	2c624 <ll_phy_req_send+0x62>
	    (conn->llcp_phy.req != conn->llcp_phy.ack)) {
   2c5de:	f890 31a8 	ldrb.w	r3, [r0, #424]	; 0x1a8
	if ((conn->llcp_req != conn->llcp_ack) ||
   2c5e2:	f890 61a9 	ldrb.w	r6, [r0, #425]	; 0x1a9
   2c5e6:	429e      	cmp	r6, r3
   2c5e8:	d11c      	bne.n	2c624 <ll_phy_req_send+0x62>
	conn->llcp_phy.state = LLCP_PHY_STATE_REQ;
   2c5ea:	f8b0 41aa 	ldrh.w	r4, [r0, #426]	; 0x1aa
   2c5ee:	f424 6480 	bic.w	r4, r4, #1024	; 0x400
   2c5f2:	f024 0403 	bic.w	r4, r4, #3
   2c5f6:	f444 6480 	orr.w	r4, r4, #1024	; 0x400
	conn->llcp_phy.tx = tx;
   2c5fa:	4625      	mov	r5, r4
   2c5fc:	f369 0584 	bfi	r5, r9, #2, #3
	conn->llcp_phy.flags = flags;
   2c600:	f3c4 2407 	ubfx	r4, r4, #8, #8
   2c604:	f368 0441 	bfi	r4, r8, #1, #1
	conn->llcp_phy.rx = rx;
   2c608:	f367 1547 	bfi	r5, r7, #5, #3
	conn->llcp_phy.req++;
   2c60c:	3601      	adds	r6, #1
	conn->llcp_phy.flags = flags;
   2c60e:	f880 41ab 	strb.w	r4, [r0, #427]	; 0x1ab
	conn->llcp_phy.rx = rx;
   2c612:	f880 51aa 	strb.w	r5, [r0, #426]	; 0x1aa
	conn->llcp_phy.req++;
   2c616:	f880 61a8 	strb.w	r6, [r0, #424]	; 0x1a8
	return 0;
   2c61a:	2000      	movs	r0, #0
}
   2c61c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   2c620:	2002      	movs	r0, #2
   2c622:	e7fb      	b.n	2c61c <ll_phy_req_send+0x5a>
		return BT_HCI_ERR_CMD_DISALLOWED;
   2c624:	200c      	movs	r0, #12
   2c626:	e7f9      	b.n	2c61c <ll_phy_req_send+0x5a>

0002c628 <ll_apto_get>:
{
   2c628:	b510      	push	{r4, lr}
   2c62a:	460c      	mov	r4, r1
	conn = ll_connected_get(handle);
   2c62c:	f7ff fead 	bl	2c38a <ll_connected_get>
	if (!conn) {
   2c630:	b160      	cbz	r0, 2c64c <ll_apto_get+0x24>
	*apto = conn->apto_reload * conn->lll.interval * 125U / 1000;
   2c632:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
   2c634:	f8b0 20d2 	ldrh.w	r2, [r0, #210]	; 0xd2
   2c638:	435a      	muls	r2, r3
   2c63a:	237d      	movs	r3, #125	; 0x7d
   2c63c:	4353      	muls	r3, r2
	return 0;
   2c63e:	2000      	movs	r0, #0
	*apto = conn->apto_reload * conn->lll.interval * 125U / 1000;
   2c640:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2c644:	fbb3 f3f2 	udiv	r3, r3, r2
   2c648:	8023      	strh	r3, [r4, #0]
}
   2c64a:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   2c64c:	2002      	movs	r0, #2
   2c64e:	e7fc      	b.n	2c64a <ll_apto_get+0x22>

0002c650 <ll_apto_set>:
{
   2c650:	b510      	push	{r4, lr}
   2c652:	460c      	mov	r4, r1
	conn = ll_connected_get(handle);
   2c654:	f7ff fe99 	bl	2c38a <ll_connected_get>
	if (!conn) {
   2c658:	b170      	cbz	r0, 2c678 <ll_apto_set+0x28>
	conn->apto_reload = RADIO_CONN_EVENTS(apto * 10U * 1000U,
   2c65a:	8dc2      	ldrh	r2, [r0, #46]	; 0x2e
   2c65c:	f240 43e2 	movw	r3, #1250	; 0x4e2
   2c660:	4353      	muls	r3, r2
   2c662:	f242 7110 	movw	r1, #10000	; 0x2710
   2c666:	fb01 3404 	mla	r4, r1, r4, r3
   2c66a:	3c01      	subs	r4, #1
   2c66c:	fbb4 f4f3 	udiv	r4, r4, r3
   2c670:	f8a0 40d2 	strh.w	r4, [r0, #210]	; 0xd2
	return 0;
   2c674:	2000      	movs	r0, #0
}
   2c676:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   2c678:	2002      	movs	r0, #2
   2c67a:	e7fc      	b.n	2c676 <ll_apto_set+0x26>

0002c67c <ull_conn_llcp_req>:
	if (conn_hdr->llcp_req != conn_hdr->llcp_ack) {
   2c67c:	f890 30e9 	ldrb.w	r3, [r0, #233]	; 0xe9
   2c680:	f890 20e8 	ldrb.w	r2, [r0, #232]	; 0xe8
   2c684:	4293      	cmp	r3, r2
	conn_hdr->llcp_req++;
   2c686:	bf03      	ittte	eq
   2c688:	3301      	addeq	r3, #1
   2c68a:	f880 30e8 	strbeq.w	r3, [r0, #232]	; 0xe8
	return 0;
   2c68e:	2000      	moveq	r0, #0
		return BT_HCI_ERR_CMD_DISALLOWED;
   2c690:	200c      	movne	r0, #12
}
   2c692:	4770      	bx	lr

0002c694 <ull_conn_lll_max_tx_octets_get>:
	switch (lll->phy_tx_time) {
   2c694:	f890 2048 	ldrb.w	r2, [r0, #72]	; 0x48
   2c698:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
   2c69c:	f3c2 1102 	ubfx	r1, r2, #4, #3
   2c6a0:	2902      	cmp	r1, #2
   2c6a2:	d010      	beq.n	2c6c6 <ull_conn_lll_max_tx_octets_get+0x32>
   2c6a4:	2904      	cmp	r1, #4
   2c6a6:	d011      	beq.n	2c6cc <ull_conn_lll_max_tx_octets_get+0x38>
		max_tx_octets = (lll->max_tx_time >> 3) - 10;
   2c6a8:	08db      	lsrs	r3, r3, #3
   2c6aa:	3b0a      	subs	r3, #10
	if (lll->enc_tx) {
   2c6ac:	f890 2062 	ldrb.w	r2, [r0, #98]	; 0x62
	return max_tx_octets;
   2c6b0:	f8b0 0040 	ldrh.w	r0, [r0, #64]	; 0x40
			max_tx_octets = ((lll->max_tx_time - 430) >>
   2c6b4:	b29b      	uxth	r3, r3
	if (lll->enc_tx) {
   2c6b6:	06d2      	lsls	r2, r2, #27
		max_tx_octets -= 4U;
   2c6b8:	bf44      	itt	mi
   2c6ba:	3b04      	submi	r3, #4
   2c6bc:	b29b      	uxthmi	r3, r3
}
   2c6be:	4298      	cmp	r0, r3
   2c6c0:	bf28      	it	cs
   2c6c2:	4618      	movcs	r0, r3
   2c6c4:	4770      	bx	lr
		max_tx_octets = (lll->max_tx_time >> 2) - 11;
   2c6c6:	089b      	lsrs	r3, r3, #2
   2c6c8:	3b0b      	subs	r3, #11
   2c6ca:	e7ef      	b.n	2c6ac <ull_conn_lll_max_tx_octets_get+0x18>
		if (lll->phy_flags & 0x01) {
   2c6cc:	0711      	lsls	r1, r2, #28
			max_tx_octets = ((lll->max_tx_time - 592) >>
   2c6ce:	bf4b      	itete	mi
   2c6d0:	f5a3 7314 	submi.w	r3, r3, #592	; 0x250
			max_tx_octets = ((lll->max_tx_time - 430) >>
   2c6d4:	f5a3 73d7 	subpl.w	r3, r3, #430	; 0x1ae
			max_tx_octets = ((lll->max_tx_time - 592) >>
   2c6d8:	119b      	asrmi	r3, r3, #6
			max_tx_octets = ((lll->max_tx_time - 430) >>
   2c6da:	111b      	asrpl	r3, r3, #4
					  4) - 2;
   2c6dc:	3b02      	subs	r3, #2
   2c6de:	e7e5      	b.n	2c6ac <ull_conn_lll_max_tx_octets_get+0x18>

0002c6e0 <isr_race>:
	radio_status_reset();
   2c6e0:	f7f8 b9dc 	b.w	24a9c <radio_status_reset>

0002c6e4 <empty_tx_enqueue>:

	return 0;
}

static struct pdu_data *empty_tx_enqueue(struct lll_conn *lll)
{
   2c6e4:	b538      	push	{r3, r4, r5, lr}
	struct pdu_data *p;

	lll->empty = 1;
   2c6e6:	f890 3062 	ldrb.w	r3, [r0, #98]	; 0x62
   2c6ea:	f043 0304 	orr.w	r3, r3, #4
   2c6ee:	f880 3062 	strb.w	r3, [r0, #98]	; 0x62
{
   2c6f2:	4605      	mov	r5, r0

	p = (void *)radio_pkt_empty_get();
   2c6f4:	f7f8 fa08 	bl	24b08 <radio_pkt_empty_get>
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   2c6f8:	7803      	ldrb	r3, [r0, #0]
   2c6fa:	2201      	movs	r2, #1
   2c6fc:	f362 0301 	bfi	r3, r2, #0, #2
	p->len = 0;
   2c700:	2200      	movs	r2, #0
   2c702:	7042      	strb	r2, [r0, #1]
	p = (void *)radio_pkt_empty_get();
   2c704:	4604      	mov	r4, r0
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   2c706:	7003      	strb	r3, [r0, #0]
	if (memq_peek(lll->memq_tx.head, lll->memq_tx.tail, NULL)) {
   2c708:	e9d5 0113 	ldrd	r0, r1, [r5, #76]	; 0x4c
   2c70c:	f7ff f975 	bl	2b9fa <memq_peek>
   2c710:	7823      	ldrb	r3, [r4, #0]
   2c712:	3000      	adds	r0, #0
   2c714:	bf18      	it	ne
   2c716:	2001      	movne	r0, #1
   2c718:	f360 1304 	bfi	r3, r0, #4, #1
   2c71c:	7023      	strb	r3, [r4, #0]
	} else {
		p->md = 0;
	}

	return p;
}
   2c71e:	4620      	mov	r0, r4
   2c720:	bd38      	pop	{r3, r4, r5, pc}

0002c722 <lll_conn_init>:
}
   2c722:	2000      	movs	r0, #0
   2c724:	4770      	bx	lr

0002c726 <lll_conn_reset>:
   2c726:	2000      	movs	r0, #0
   2c728:	4770      	bx	lr

0002c72a <lll_conn_sca_local_get>:
}
   2c72a:	2007      	movs	r0, #7
   2c72c:	4770      	bx	lr

0002c72e <lll_conn_ppm_local_get>:
}
   2c72e:	2014      	movs	r0, #20
   2c730:	4770      	bx	lr

0002c732 <lll_conn_is_abort_cb>:
}
   2c732:	f06f 0047 	mvn.w	r0, #71	; 0x47
   2c736:	4770      	bx	lr

0002c738 <lll_conn_isr_abort>:
{
   2c738:	b510      	push	{r4, lr}
   2c73a:	4604      	mov	r4, r0
	radio_status_reset();
   2c73c:	f7f8 f9ae 	bl	24a9c <radio_status_reset>
	radio_tmr_status_reset();
   2c740:	f7f8 fa7c 	bl	24c3c <radio_tmr_status_reset>
	radio_filter_status_reset();
   2c744:	f7f8 fa56 	bl	24bf4 <radio_filter_status_reset>
	radio_ar_status_reset();
   2c748:	f7f8 fc42 	bl	24fd0 <radio_ar_status_reset>
	radio_rssi_status_reset();
   2c74c:	f7f8 fa1a 	bl	24b84 <radio_rssi_status_reset>
	isr_cleanup(param);
   2c750:	4620      	mov	r0, r4
}
   2c752:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
   2c756:	f7f5 bf7d 	b.w	22654 <isr_cleanup>

0002c75a <lll_conn_tx_pkt_set>:
{
   2c75a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2c75c:	460f      	mov	r7, r1
	phy = lll->phy_tx;
   2c75e:	f890 1048 	ldrb.w	r1, [r0, #72]	; 0x48
	max_tx_octets = lll->max_tx_octets;
   2c762:	f8b0 5040 	ldrh.w	r5, [r0, #64]	; 0x40
	phy = lll->phy_tx;
   2c766:	f001 0407 	and.w	r4, r1, #7
{
   2c76a:	4606      	mov	r6, r0
	radio_phy_set(phy, flags);
   2c76c:	f3c1 01c0 	ubfx	r1, r1, #3, #1
   2c770:	4620      	mov	r0, r4
   2c772:	f7f8 f8d3 	bl	2491c <radio_phy_set>
	} else if (lll->enc_tx) {
   2c776:	f896 3062 	ldrb.w	r3, [r6, #98]	; 0x62
   2c77a:	0062      	lsls	r2, r4, #1
   2c77c:	06db      	lsls	r3, r3, #27
   2c77e:	b2e9      	uxtb	r1, r5
   2c780:	f042 0201 	orr.w	r2, r2, #1
   2c784:	d50d      	bpl.n	2c7a2 <lll_conn_tx_pkt_set+0x48>
		radio_pkt_configure(8, (max_tx_octets + 4U),
   2c786:	3104      	adds	r1, #4
   2c788:	b2c9      	uxtb	r1, r1
   2c78a:	2008      	movs	r0, #8
   2c78c:	f7f8 f92a 	bl	249e4 <radio_pkt_configure>
		radio_pkt_tx_set(radio_ccm_tx_pkt_set(&lll->ccm_tx,
   2c790:	4639      	mov	r1, r7
   2c792:	f106 0084 	add.w	r0, r6, #132	; 0x84
   2c796:	f7f8 fb9b 	bl	24ed0 <radio_ccm_tx_pkt_set>
}
   2c79a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_tx_set(pdu_data_tx);
   2c79e:	f7f8 b959 	b.w	24a54 <radio_pkt_tx_set>
		radio_pkt_configure(8, max_tx_octets, (phy << 1) | 0x01);
   2c7a2:	2008      	movs	r0, #8
   2c7a4:	f7f8 f91e 	bl	249e4 <radio_pkt_configure>
		radio_pkt_tx_set(pdu_data_tx);
   2c7a8:	4638      	mov	r0, r7
   2c7aa:	e7f6      	b.n	2c79a <lll_conn_tx_pkt_set+0x40>

0002c7ac <lll_conn_pdu_tx_prep>:
	if (lll->empty) {
   2c7ac:	f890 3062 	ldrb.w	r3, [r0, #98]	; 0x62
   2c7b0:	075b      	lsls	r3, r3, #29
{
   2c7b2:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   2c7b6:	4606      	mov	r6, r0
   2c7b8:	4688      	mov	r8, r1
	if (lll->empty) {
   2c7ba:	d506      	bpl.n	2c7ca <lll_conn_pdu_tx_prep+0x1e>
		*pdu_data_tx = empty_tx_enqueue(lll);
   2c7bc:	f7ff ff92 	bl	2c6e4 <empty_tx_enqueue>
   2c7c0:	f8c8 0000 	str.w	r0, [r8]
}
   2c7c4:	b003      	add	sp, #12
   2c7c6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail, (void **)&tx);
   2c7ca:	aa01      	add	r2, sp, #4
   2c7cc:	e9d0 0113 	ldrd	r0, r1, [r0, #76]	; 0x4c
   2c7d0:	f7ff f913 	bl	2b9fa <memq_peek>
	if (!link) {
   2c7d4:	4681      	mov	r9, r0
   2c7d6:	b960      	cbnz	r0, 2c7f2 <lll_conn_pdu_tx_prep+0x46>
		p = empty_tx_enqueue(lll);
   2c7d8:	4630      	mov	r0, r6
   2c7da:	f7ff ff83 	bl	2c6e4 <empty_tx_enqueue>
   2c7de:	4607      	mov	r7, r0
	p->rfu = 0U;
   2c7e0:	783b      	ldrb	r3, [r7, #0]
   2c7e2:	f36f 1347 	bfc	r3, #5, #3
   2c7e6:	703b      	strb	r3, [r7, #0]
	p->resv = 0U;
   2c7e8:	2300      	movs	r3, #0
   2c7ea:	70bb      	strb	r3, [r7, #2]
	*pdu_data_tx = p;
   2c7ec:	f8c8 7000 	str.w	r7, [r8]
   2c7f0:	e7e8      	b.n	2c7c4 <lll_conn_pdu_tx_prep+0x18>
		p = (void *)(tx->pdu + lll->packet_tx_head_offset);
   2c7f2:	9d01      	ldr	r5, [sp, #4]
   2c7f4:	f896 4061 	ldrb.w	r4, [r6, #97]	; 0x61
		if (!lll->packet_tx_head_len) {
   2c7f8:	f896 3060 	ldrb.w	r3, [r6, #96]	; 0x60
		p = (void *)(tx->pdu + lll->packet_tx_head_offset);
   2c7fc:	3504      	adds	r5, #4
   2c7fe:	192f      	adds	r7, r5, r4
		if (!lll->packet_tx_head_len) {
   2c800:	b913      	cbnz	r3, 2c808 <lll_conn_pdu_tx_prep+0x5c>
			lll->packet_tx_head_len = p->len;
   2c802:	787b      	ldrb	r3, [r7, #1]
   2c804:	f886 3060 	strb.w	r3, [r6, #96]	; 0x60
		if (lll->packet_tx_head_offset) {
   2c808:	b124      	cbz	r4, 2c814 <lll_conn_pdu_tx_prep+0x68>
			p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
   2c80a:	5d2b      	ldrb	r3, [r5, r4]
   2c80c:	2201      	movs	r2, #1
   2c80e:	f362 0301 	bfi	r3, r2, #0, #2
   2c812:	552b      	strb	r3, [r5, r4]
		p->len = lll->packet_tx_head_len - lll->packet_tx_head_offset;
   2c814:	f896 3060 	ldrb.w	r3, [r6, #96]	; 0x60
   2c818:	1b1b      	subs	r3, r3, r4
   2c81a:	707b      	strb	r3, [r7, #1]
		p->md = 0;
   2c81c:	5d2b      	ldrb	r3, [r5, r4]
   2c81e:	f36f 1304 	bfc	r3, #4, #1
   2c822:	552b      	strb	r3, [r5, r4]
		max_tx_octets = ull_conn_lll_max_tx_octets_get(lll);
   2c824:	4630      	mov	r0, r6
   2c826:	f7ff ff35 	bl	2c694 <ull_conn_lll_max_tx_octets_get>
		if (p->len > max_tx_octets) {
   2c82a:	787b      	ldrb	r3, [r7, #1]
   2c82c:	4283      	cmp	r3, r0
			p->len = max_tx_octets;
   2c82e:	bf84      	itt	hi
   2c830:	7078      	strbhi	r0, [r7, #1]
			p->md = 1;
   2c832:	5d2b      	ldrbhi	r3, [r5, r4]
		if (link->next != lll->memq_tx.tail) {
   2c834:	f8d9 2000 	ldr.w	r2, [r9]
			p->md = 1;
   2c838:	bf84      	itt	hi
   2c83a:	f043 0310 	orrhi.w	r3, r3, #16
   2c83e:	552b      	strbhi	r3, [r5, r4]
		if (link->next != lll->memq_tx.tail) {
   2c840:	6d33      	ldr	r3, [r6, #80]	; 0x50
   2c842:	429a      	cmp	r2, r3
			p->md = 1;
   2c844:	bf1e      	ittt	ne
   2c846:	5d2b      	ldrbne	r3, [r5, r4]
   2c848:	f043 0310 	orrne.w	r3, r3, #16
   2c84c:	552b      	strbne	r3, [r5, r4]
   2c84e:	e7c7      	b.n	2c7e0 <lll_conn_pdu_tx_prep+0x34>

0002c850 <lll_conn_flush>:

void lll_conn_flush(struct lll_conn *lll)
{
	/* Nothing to be flushed */
}
   2c850:	4770      	bx	lr

0002c852 <ll_start_enc_req_send>:
{
   2c852:	b570      	push	{r4, r5, r6, lr}
   2c854:	460d      	mov	r5, r1
   2c856:	4616      	mov	r6, r2
	conn = ll_connected_get(handle);
   2c858:	f7ff fd97 	bl	2c38a <ll_connected_get>
	if (!conn) {
   2c85c:	4604      	mov	r4, r0
   2c85e:	b3e0      	cbz	r0, 2c8da <ll_start_enc_req_send+0x88>
	if (error_code) {
   2c860:	b325      	cbz	r5, 2c8ac <ll_start_enc_req_send+0x5a>
		if (conn->llcp_enc.refresh == 0U) {
   2c862:	f890 0152 	ldrb.w	r0, [r0, #338]	; 0x152
   2c866:	f010 0004 	ands.w	r0, r0, #4
   2c86a:	d112      	bne.n	2c892 <ll_start_enc_req_send+0x40>
			if ((conn->llcp_req == conn->llcp_ack) ||
   2c86c:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
   2c870:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
   2c874:	429a      	cmp	r2, r3
   2c876:	d032      	beq.n	2c8de <ll_start_enc_req_send+0x8c>
   2c878:	f894 30ea 	ldrb.w	r3, [r4, #234]	; 0xea
   2c87c:	2b03      	cmp	r3, #3
   2c87e:	d12e      	bne.n	2c8de <ll_start_enc_req_send+0x8c>
			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   2c880:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
			conn->llcp.encryption.error_code = error_code;
   2c884:	f884 50ed 	strb.w	r5, [r4, #237]	; 0xed
			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   2c888:	f360 0301 	bfi	r3, r0, #0, #2
   2c88c:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
}
   2c890:	bd70      	pop	{r4, r5, r6, pc}
			    conn->llcp_terminate.req) {
   2c892:	f894 2128 	ldrb.w	r2, [r4, #296]	; 0x128
			if (conn->llcp_terminate.ack !=
   2c896:	f894 3129 	ldrb.w	r3, [r4, #297]	; 0x129
   2c89a:	4293      	cmp	r3, r2
   2c89c:	d11f      	bne.n	2c8de <ll_start_enc_req_send+0x8c>
			conn->llcp_terminate.req++;
   2c89e:	3301      	adds	r3, #1
			conn->llcp_terminate.reason_own = error_code;
   2c8a0:	f884 512a 	strb.w	r5, [r4, #298]	; 0x12a
			conn->llcp_terminate.req++;
   2c8a4:	f884 3128 	strb.w	r3, [r4, #296]	; 0x128
	return 0;
   2c8a8:	2000      	movs	r0, #0
   2c8aa:	e7f1      	b.n	2c890 <ll_start_enc_req_send+0x3e>
		if ((conn->llcp_req == conn->llcp_ack) ||
   2c8ac:	f890 20e8 	ldrb.w	r2, [r0, #232]	; 0xe8
   2c8b0:	f890 30e9 	ldrb.w	r3, [r0, #233]	; 0xe9
   2c8b4:	429a      	cmp	r2, r3
   2c8b6:	d012      	beq.n	2c8de <ll_start_enc_req_send+0x8c>
   2c8b8:	f890 30ea 	ldrb.w	r3, [r0, #234]	; 0xea
   2c8bc:	2b03      	cmp	r3, #3
   2c8be:	d10e      	bne.n	2c8de <ll_start_enc_req_send+0x8c>
		memcpy(&conn->llcp_enc.ltk[0], ltk,
   2c8c0:	2210      	movs	r2, #16
   2c8c2:	4631      	mov	r1, r6
   2c8c4:	f200 105d 	addw	r0, r0, #349	; 0x15d
   2c8c8:	f7fd fdc1 	bl	2a44e <memcpy>
		conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
   2c8cc:	f8b4 30ec 	ldrh.w	r3, [r4, #236]	; 0xec
   2c8d0:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
   2c8d4:	f8a4 30ec 	strh.w	r3, [r4, #236]	; 0xec
   2c8d8:	e7e6      	b.n	2c8a8 <ll_start_enc_req_send+0x56>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   2c8da:	2002      	movs	r0, #2
   2c8dc:	e7d8      	b.n	2c890 <ll_start_enc_req_send+0x3e>
				return BT_HCI_ERR_CMD_DISALLOWED;
   2c8de:	200c      	movs	r0, #12
   2c8e0:	e7d6      	b.n	2c890 <ll_start_enc_req_send+0x3e>

0002c8e2 <ticker_op_stop_scan_cb>:
}
   2c8e2:	4770      	bx	lr

0002c8e4 <ll_chm_update>:
{
   2c8e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2c8e8:	4607      	mov	r7, r0
	ull_conn_chan_map_set(chm);
   2c8ea:	f7f3 ff6f 	bl	207cc <ull_conn_chan_map_set>
	handle = CONFIG_BT_MAX_CONN;
   2c8ee:	2505      	movs	r5, #5
	while (handle--) {
   2c8f0:	f64f 76ff 	movw	r6, #65535	; 0xffff
		conn->llcp_type = LLCP_CHAN_MAP;
   2c8f4:	f04f 0802 	mov.w	r8, #2
	while (handle--) {
   2c8f8:	3d01      	subs	r5, #1
   2c8fa:	b2ad      	uxth	r5, r5
   2c8fc:	42b5      	cmp	r5, r6
   2c8fe:	d102      	bne.n	2c906 <ll_chm_update+0x22>
	return 0;
   2c900:	2000      	movs	r0, #0
}
   2c902:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		conn = ll_connected_get(handle);
   2c906:	4628      	mov	r0, r5
   2c908:	f7ff fd3f 	bl	2c38a <ll_connected_get>
		if (!conn || conn->lll.role) {
   2c90c:	4604      	mov	r4, r0
   2c90e:	2800      	cmp	r0, #0
   2c910:	d0f2      	beq.n	2c8f8 <ll_chm_update+0x14>
   2c912:	f990 303d 	ldrsb.w	r3, [r0, #61]	; 0x3d
   2c916:	2b00      	cmp	r3, #0
   2c918:	dbee      	blt.n	2c8f8 <ll_chm_update+0x14>
		ret = ull_conn_llcp_req(conn);
   2c91a:	f7ff feaf 	bl	2c67c <ull_conn_llcp_req>
		if (ret) {
   2c91e:	2800      	cmp	r0, #0
   2c920:	d1ef      	bne.n	2c902 <ll_chm_update+0x1e>
		memcpy(conn->llcp.chan_map.chm, chm,
   2c922:	2205      	movs	r2, #5
   2c924:	4639      	mov	r1, r7
   2c926:	f104 00ed 	add.w	r0, r4, #237	; 0xed
   2c92a:	f7fd fd90 	bl	2a44e <memcpy>
		conn->llcp.chan_map.initiate = 1U;
   2c92e:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
		conn->llcp_type = LLCP_CHAN_MAP;
   2c932:	f884 80ea 	strb.w	r8, [r4, #234]	; 0xea
		conn->llcp.chan_map.initiate = 1U;
   2c936:	f043 0301 	orr.w	r3, r3, #1
   2c93a:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
		conn->llcp_req++;
   2c93e:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
   2c942:	3301      	adds	r3, #1
   2c944:	f884 30e8 	strb.w	r3, [r4, #232]	; 0xe8
   2c948:	e7d6      	b.n	2c8f8 <ll_chm_update+0x14>

0002c94a <ll_enc_req_send>:
{
   2c94a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2c94e:	4607      	mov	r7, r0
   2c950:	4688      	mov	r8, r1
   2c952:	4616      	mov	r6, r2
   2c954:	4699      	mov	r9, r3
	conn = ll_connected_get(handle);
   2c956:	f7ff fd18 	bl	2c38a <ll_connected_get>
	if (!conn) {
   2c95a:	4605      	mov	r5, r0
   2c95c:	2800      	cmp	r0, #0
   2c95e:	d063      	beq.n	2ca28 <ll_enc_req_send+0xde>
	if ((conn->llcp_enc.req != conn->llcp_enc.ack) ||
   2c960:	f890 2150 	ldrb.w	r2, [r0, #336]	; 0x150
   2c964:	f890 3151 	ldrb.w	r3, [r0, #337]	; 0x151
   2c968:	429a      	cmp	r2, r3
   2c96a:	d002      	beq.n	2c972 <ll_enc_req_send+0x28>
			return BT_HCI_ERR_CMD_DISALLOWED;
   2c96c:	200c      	movs	r0, #12
}
   2c96e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((conn->llcp_enc.req != conn->llcp_enc.ack) ||
   2c972:	f890 20e8 	ldrb.w	r2, [r0, #232]	; 0xe8
   2c976:	f890 30e9 	ldrb.w	r3, [r0, #233]	; 0xe9
   2c97a:	429a      	cmp	r2, r3
   2c97c:	d003      	beq.n	2c986 <ll_enc_req_send+0x3c>
	    ((conn->llcp_req != conn->llcp_ack) &&
   2c97e:	f890 30ea 	ldrb.w	r3, [r0, #234]	; 0xea
   2c982:	2b03      	cmp	r3, #3
   2c984:	d0f2      	beq.n	2c96c <ll_enc_req_send+0x22>
	tx = ll_tx_mem_acquire();
   2c986:	f7f3 fe0b 	bl	205a0 <ll_tx_mem_acquire>
	if (tx) {
   2c98a:	4604      	mov	r4, r0
   2c98c:	2800      	cmp	r0, #0
   2c98e:	d0ed      	beq.n	2c96c <ll_enc_req_send+0x22>
		memcpy(&conn->llcp_enc.ltk[0], ltk, sizeof(conn->llcp_enc.ltk));
   2c990:	2210      	movs	r2, #16
   2c992:	4649      	mov	r1, r9
   2c994:	f205 105d 	addw	r0, r5, #349	; 0x15d
   2c998:	f7fd fd59 	bl	2a44e <memcpy>
		if (!conn->lll.enc_rx && !conn->lll.enc_tx) {
   2c99c:	f895 307e 	ldrb.w	r3, [r5, #126]	; 0x7e
   2c9a0:	f013 0318 	ands.w	r3, r3, #24
   2c9a4:	d123      	bne.n	2c9ee <ll_enc_req_send+0xa4>
			pdu_data_tx->ll_id = PDU_DATA_LLID_CTRL;
   2c9a6:	7923      	ldrb	r3, [r4, #4]
   2c9a8:	f043 0303 	orr.w	r3, r3, #3
   2c9ac:	7123      	strb	r3, [r4, #4]
			pdu_data_tx->len =
   2c9ae:	2317      	movs	r3, #23
			memcpy(enc_req->rand, rand, sizeof(enc_req->rand));
   2c9b0:	2208      	movs	r2, #8
			pdu_data_tx->len =
   2c9b2:	7163      	strb	r3, [r4, #5]
			pdu_data_tx->llctrl.opcode =
   2c9b4:	2303      	movs	r3, #3
   2c9b6:	71e3      	strb	r3, [r4, #7]
			memcpy(enc_req->rand, rand, sizeof(enc_req->rand));
   2c9b8:	4641      	mov	r1, r8
   2c9ba:	18a0      	adds	r0, r4, r2
   2c9bc:	f7fd fd47 	bl	2a44e <memcpy>
			enc_req->ediv[0] = ediv[0];
   2c9c0:	7833      	ldrb	r3, [r6, #0]
   2c9c2:	7423      	strb	r3, [r4, #16]
			enc_req->ediv[1] = ediv[1];
   2c9c4:	7873      	ldrb	r3, [r6, #1]
   2c9c6:	7463      	strb	r3, [r4, #17]
			bt_rand(enc_req->skdm, sizeof(enc_req->skdm));
   2c9c8:	2108      	movs	r1, #8
   2c9ca:	f104 0012 	add.w	r0, r4, #18
   2c9ce:	f7f1 f851 	bl	1da74 <bt_rand>
			bt_rand(enc_req->ivm, sizeof(enc_req->ivm));
   2c9d2:	2104      	movs	r1, #4
   2c9d4:	f104 001a 	add.w	r0, r4, #26
   2c9d8:	f7f1 f84c 	bl	1da74 <bt_rand>
		if (ll_tx_mem_enqueue(handle, tx)) {
   2c9dc:	4621      	mov	r1, r4
   2c9de:	4638      	mov	r0, r7
   2c9e0:	f7f3 fdea 	bl	205b8 <ll_tx_mem_enqueue>
   2c9e4:	b1d0      	cbz	r0, 2ca1c <ll_enc_req_send+0xd2>
			ll_tx_mem_release(tx);
   2c9e6:	4620      	mov	r0, r4
   2c9e8:	f7f3 fde0 	bl	205ac <ll_tx_mem_release>
   2c9ec:	e7be      	b.n	2c96c <ll_enc_req_send+0x22>
		} else if (conn->lll.enc_rx && conn->lll.enc_tx) {
   2c9ee:	2b18      	cmp	r3, #24
   2c9f0:	d1f9      	bne.n	2c9e6 <ll_enc_req_send+0x9c>
			memcpy(&conn->llcp_enc.rand[0], rand,
   2c9f2:	2208      	movs	r2, #8
   2c9f4:	4641      	mov	r1, r8
   2c9f6:	f205 1055 	addw	r0, r5, #341	; 0x155
   2c9fa:	f7fd fd28 	bl	2a44e <memcpy>
			conn->llcp_enc.ediv[0] = ediv[0];
   2c9fe:	7833      	ldrb	r3, [r6, #0]
   2ca00:	f885 3153 	strb.w	r3, [r5, #339]	; 0x153
			conn->llcp_enc.ediv[1] = ediv[1];
   2ca04:	7873      	ldrb	r3, [r6, #1]
   2ca06:	f885 3154 	strb.w	r3, [r5, #340]	; 0x154
			pdu_data_tx->ll_id = PDU_DATA_LLID_CTRL;
   2ca0a:	7923      	ldrb	r3, [r4, #4]
   2ca0c:	f043 0303 	orr.w	r3, r3, #3
   2ca10:	7123      	strb	r3, [r4, #4]
			pdu_data_tx->len = offsetof(struct pdu_data_llctrl,
   2ca12:	2301      	movs	r3, #1
   2ca14:	7163      	strb	r3, [r4, #5]
			pdu_data_tx->llctrl.opcode =
   2ca16:	230a      	movs	r3, #10
   2ca18:	71e3      	strb	r3, [r4, #7]
   2ca1a:	e7df      	b.n	2c9dc <ll_enc_req_send+0x92>
		conn->llcp_enc.req++;
   2ca1c:	f895 3150 	ldrb.w	r3, [r5, #336]	; 0x150
   2ca20:	3301      	adds	r3, #1
   2ca22:	f885 3150 	strb.w	r3, [r5, #336]	; 0x150
		return 0;
   2ca26:	e7a2      	b.n	2c96e <ll_enc_req_send+0x24>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
   2ca28:	2002      	movs	r0, #2
   2ca2a:	e7a0      	b.n	2c96e <ll_enc_req_send+0x24>

0002ca2c <ull_sched_after_mstr_slot_get>:

void ull_sched_after_mstr_slot_get(u8_t user_id, u32_t ticks_slot_abs,
				   u32_t *ticks_anchor, u32_t *us_offset)
{
	/* TODO: */
}
   2ca2c:	4770      	bx	lr

0002ca2e <ull_sched_mfy_after_mstr_offset_get>:
void ull_sched_mfy_after_mstr_offset_get(void *param)
{
	struct ll_scan_set *scan = param;

	/* TODO: */
	scan->lll.conn_win_offset_us = 0;
   2ca2e:	2300      	movs	r3, #0
   2ca30:	62c3      	str	r3, [r0, #44]	; 0x2c
}
   2ca32:	4770      	bx	lr

0002ca34 <ull_sched_mfy_free_win_offset_calc>:

void ull_sched_mfy_free_win_offset_calc(void *param)
{
	/* TODO: */
}
   2ca34:	4770      	bx	lr

0002ca36 <ull_sched_mfy_win_offset_use>:
   2ca36:	4770      	bx	lr

0002ca38 <ull_sched_mfy_win_offset_select>:
   2ca38:	4770      	bx	lr

0002ca3a <rl_access_check.constprop.2>:
static int rl_access_check(bool check_ar)
   2ca3a:	b508      	push	{r3, lr}
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
   2ca3c:	2000      	movs	r0, #0
   2ca3e:	f7ff fa4c 	bl	2beda <ull_adv_is_enabled>
		? 0 : 1;
   2ca42:	b928      	cbnz	r0, 2ca50 <rl_access_check.constprop.2+0x16>
		(IS_ENABLED(CONFIG_BT_OBSERVER) && ull_scan_is_enabled(0)))
   2ca44:	f7ff fb39 	bl	2c0ba <ull_scan_is_enabled>
		? 0 : 1;
   2ca48:	fab0 f080 	clz	r0, r0
   2ca4c:	0940      	lsrs	r0, r0, #5
}
   2ca4e:	bd08      	pop	{r3, pc}
		? 0 : 1;
   2ca50:	2000      	movs	r0, #0
   2ca52:	e7fc      	b.n	2ca4e <rl_access_check.constprop.2+0x14>

0002ca54 <ll_wl_size_get>:
}
   2ca54:	2008      	movs	r0, #8
   2ca56:	4770      	bx	lr

0002ca58 <ll_rl_size_get>:
   2ca58:	2008      	movs	r0, #8
   2ca5a:	4770      	bx	lr

0002ca5c <ecb_encrypt>:
	memcpy(cipher_text_be, &ecb.cipher_text[0], sizeof(ecb.cipher_text));
}

void ecb_encrypt(u8_t const *const key_le, u8_t const *const clear_text_le,
		 u8_t * const cipher_text_le, u8_t * const cipher_text_be)
{
   2ca5c:	b570      	push	{r4, r5, r6, lr}
   2ca5e:	b08c      	sub	sp, #48	; 0x30
   2ca60:	460e      	mov	r6, r1
   2ca62:	4615      	mov	r5, r2
	struct ecb_param ecb;

	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
   2ca64:	4601      	mov	r1, r0
   2ca66:	2210      	movs	r2, #16
   2ca68:	4668      	mov	r0, sp
{
   2ca6a:	461c      	mov	r4, r3
	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
   2ca6c:	f7fe ff96 	bl	2b99c <mem_rcopy>
	mem_rcopy(&ecb.clear_text[0], clear_text_le, sizeof(ecb.clear_text));
   2ca70:	2210      	movs	r2, #16
   2ca72:	eb0d 0002 	add.w	r0, sp, r2
   2ca76:	4631      	mov	r1, r6
   2ca78:	f7fe ff90 	bl	2b99c <mem_rcopy>

	do_ecb(&ecb);
   2ca7c:	4668      	mov	r0, sp
   2ca7e:	f7f7 fda9 	bl	245d4 <do_ecb>

	if (cipher_text_le) {
   2ca82:	b125      	cbz	r5, 2ca8e <ecb_encrypt+0x32>
		mem_rcopy(cipher_text_le, &ecb.cipher_text[0],
   2ca84:	2210      	movs	r2, #16
   2ca86:	a908      	add	r1, sp, #32
   2ca88:	4628      	mov	r0, r5
   2ca8a:	f7fe ff87 	bl	2b99c <mem_rcopy>
			  sizeof(ecb.cipher_text));
	}

	if (cipher_text_be) {
   2ca8e:	b124      	cbz	r4, 2ca9a <ecb_encrypt+0x3e>
		memcpy(cipher_text_be, &ecb.cipher_text[0],
   2ca90:	2210      	movs	r2, #16
   2ca92:	a908      	add	r1, sp, #32
   2ca94:	4620      	mov	r0, r4
   2ca96:	f7fd fcda 	bl	2a44e <memcpy>
			 sizeof(ecb.cipher_text));
	}
}
   2ca9a:	b00c      	add	sp, #48	; 0x30
   2ca9c:	bd70      	pop	{r4, r5, r6, pc}

0002ca9e <radio_tx_ready_delay_get>:
	switch (phy) {
   2ca9e:	2802      	cmp	r0, #2
   2caa0:	d004      	beq.n	2caac <radio_tx_ready_delay_get+0xe>
   2caa2:	2804      	cmp	r0, #4
		return HAL_RADIO_NRF52840_TXEN_TXIDLE_TX_1M_US;
   2caa4:	bf0c      	ite	eq
   2caa6:	202a      	moveq	r0, #42	; 0x2a
   2caa8:	2029      	movne	r0, #41	; 0x29
   2caaa:	4770      	bx	lr
		return HAL_RADIO_NRF52840_TXEN_TXIDLE_TX_2M_US;
   2caac:	2028      	movs	r0, #40	; 0x28
}
   2caae:	4770      	bx	lr

0002cab0 <radio_tx_chain_delay_get>:
}
   2cab0:	2001      	movs	r0, #1
   2cab2:	4770      	bx	lr

0002cab4 <radio_rx_ready_delay_get>:
}
   2cab4:	2029      	movs	r0, #41	; 0x29
   2cab6:	4770      	bx	lr

0002cab8 <radio_rx_chain_delay_get>:
	switch (phy) {
   2cab8:	2802      	cmp	r0, #2
   2caba:	d007      	beq.n	2cacc <radio_rx_chain_delay_get+0x14>
   2cabc:	2804      	cmp	r0, #4
   2cabe:	d107      	bne.n	2cad0 <radio_rx_chain_delay_get+0x18>
		if (flags & 0x01) {
   2cac0:	f011 0f01 	tst.w	r1, #1
			return HAL_RADIO_NRF52840_RX_CHAIN_DELAY_S2_US;
   2cac4:	bf14      	ite	ne
   2cac6:	201e      	movne	r0, #30
   2cac8:	2019      	moveq	r0, #25
   2caca:	4770      	bx	lr
		return HAL_RADIO_NRF52840_RX_CHAIN_DELAY_2M_US;
   2cacc:	2005      	movs	r0, #5
   2cace:	4770      	bx	lr
		return HAL_RADIO_NRF52840_RX_CHAIN_DELAY_1M_US;
   2cad0:	200a      	movs	r0, #10
}
   2cad2:	4770      	bx	lr

0002cad4 <mayfly_prio_is_equal>:
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   2cad4:	4288      	cmp	r0, r1
   2cad6:	d00c      	beq.n	2caf2 <mayfly_prio_is_equal+0x1e>
	return (caller_id == callee_id) ||
   2cad8:	b978      	cbnz	r0, 2cafa <mayfly_prio_is_equal+0x26>
	       ((caller_id == MAYFLY_CALL_ID_LLL) &&
   2cada:	1e48      	subs	r0, r1, #1
   2cadc:	2801      	cmp	r0, #1
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
   2cade:	bf8c      	ite	hi
   2cae0:	2000      	movhi	r0, #0
   2cae2:	2001      	movls	r0, #1
   2cae4:	4770      	bx	lr
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
   2cae6:	f011 0ffd 	tst.w	r1, #253	; 0xfd
   2caea:	bf0c      	ite	eq
   2caec:	2001      	moveq	r0, #1
   2caee:	2000      	movne	r0, #0
   2caf0:	4770      	bx	lr
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   2caf2:	2001      	movs	r0, #1
   2caf4:	4770      	bx	lr
   2caf6:	2000      	movs	r0, #0
}
   2caf8:	4770      	bx	lr
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
   2cafa:	2801      	cmp	r0, #1
   2cafc:	d0f3      	beq.n	2cae6 <mayfly_prio_is_equal+0x12>
		(callee_id == MAYFLY_CALL_ID_JOB)) ||
   2cafe:	2802      	cmp	r0, #2
   2cb00:	d1f9      	bne.n	2caf6 <mayfly_prio_is_equal+0x22>
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
   2cb02:	2901      	cmp	r1, #1
   2cb04:	e7eb      	b.n	2cade <mayfly_prio_is_equal+0xa>

0002cb06 <hal_ticker_instance0_trigger_set>:

void hal_ticker_instance0_trigger_set(u32_t value)
{
	cntr_cmp_set(0, value);
   2cb06:	4601      	mov	r1, r0
   2cb08:	2000      	movs	r0, #0
   2cb0a:	f7f7 bd5b 	b.w	245c4 <cntr_cmp_set>

0002cb0e <fixed_data_unref>:
}
   2cb0e:	4770      	bx	lr

0002cb10 <k_uptime_get_32>:
{
   2cb10:	b508      	push	{r3, lr}
	return z_impl_k_uptime_get();
   2cb12:	f000 fd7f 	bl	2d614 <z_impl_k_uptime_get>
}
   2cb16:	bd08      	pop	{r3, pc}

0002cb18 <net_buf_alloc_fixed>:
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   2cb18:	6983      	ldr	r3, [r0, #24]
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
   2cb1a:	685b      	ldr	r3, [r3, #4]
   2cb1c:	460a      	mov	r2, r1
   2cb1e:	6819      	ldr	r1, [r3, #0]
   2cb20:	f7f8 bb62 	b.w	251e8 <net_buf_alloc_len>

0002cb24 <net_buf_get>:
{
   2cb24:	b570      	push	{r4, r5, r6, lr}
   2cb26:	4606      	mov	r6, r0
	return z_impl_k_queue_get(queue, timeout);
   2cb28:	f000 fb14 	bl	2d154 <z_impl_k_queue_get>
	if (!buf) {
   2cb2c:	4605      	mov	r5, r0
   2cb2e:	b128      	cbz	r0, 2cb3c <net_buf_get+0x18>
   2cb30:	4604      	mov	r4, r0
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   2cb32:	7963      	ldrb	r3, [r4, #5]
   2cb34:	f013 0301 	ands.w	r3, r3, #1
   2cb38:	d102      	bne.n	2cb40 <net_buf_get+0x1c>
	frag->frags = NULL;
   2cb3a:	6023      	str	r3, [r4, #0]
}
   2cb3c:	4628      	mov	r0, r5
   2cb3e:	bd70      	pop	{r4, r5, r6, pc}
   2cb40:	2100      	movs	r1, #0
   2cb42:	4630      	mov	r0, r6
   2cb44:	f000 fb06 	bl	2d154 <z_impl_k_queue_get>
		frag->flags &= ~NET_BUF_FRAGS;
   2cb48:	7963      	ldrb	r3, [r4, #5]
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
   2cb4a:	6020      	str	r0, [r4, #0]
		frag->flags &= ~NET_BUF_FRAGS;
   2cb4c:	f023 0301 	bic.w	r3, r3, #1
   2cb50:	7163      	strb	r3, [r4, #5]
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
   2cb52:	4604      	mov	r4, r0
   2cb54:	e7ed      	b.n	2cb32 <net_buf_get+0xe>

0002cb56 <net_buf_simple_reserve>:
	buf->data = buf->__buf + reserve;
   2cb56:	6883      	ldr	r3, [r0, #8]
   2cb58:	4419      	add	r1, r3
   2cb5a:	6001      	str	r1, [r0, #0]
}
   2cb5c:	4770      	bx	lr

0002cb5e <net_buf_put>:
{
   2cb5e:	b410      	push	{r4}
	for (tail = buf; tail->frags; tail = tail->frags) {
   2cb60:	460a      	mov	r2, r1
   2cb62:	6814      	ldr	r4, [r2, #0]
   2cb64:	b914      	cbnz	r4, 2cb6c <net_buf_put+0xe>
}
   2cb66:	bc10      	pop	{r4}
	k_fifo_put_list(fifo, buf, tail);
   2cb68:	f000 bad5 	b.w	2d116 <k_queue_append_list>
		tail->flags |= NET_BUF_FRAGS;
   2cb6c:	7953      	ldrb	r3, [r2, #5]
   2cb6e:	f043 0301 	orr.w	r3, r3, #1
   2cb72:	7153      	strb	r3, [r2, #5]
   2cb74:	4622      	mov	r2, r4
   2cb76:	e7f4      	b.n	2cb62 <net_buf_put+0x4>

0002cb78 <net_buf_ref>:
{
	NET_BUF_ASSERT(buf);

	NET_BUF_DBG("buf %p (old) ref %u pool_id %u",
		    buf, buf->ref, buf->pool_id);
	buf->ref++;
   2cb78:	7903      	ldrb	r3, [r0, #4]
   2cb7a:	3301      	adds	r3, #1
   2cb7c:	7103      	strb	r3, [r0, #4]
	return buf;
}
   2cb7e:	4770      	bx	lr

0002cb80 <net_buf_simple_add>:
	return buf->data + buf->len;
   2cb80:	8883      	ldrh	r3, [r0, #4]
   2cb82:	6802      	ldr	r2, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	NET_BUF_SIMPLE_ASSERT(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
   2cb84:	4419      	add	r1, r3
   2cb86:	8081      	strh	r1, [r0, #4]
	return tail;
}
   2cb88:	18d0      	adds	r0, r2, r3
   2cb8a:	4770      	bx	lr

0002cb8c <net_buf_simple_add_mem>:

void *net_buf_simple_add_mem(struct net_buf_simple *buf, const void *mem,
			     size_t len)
{
   2cb8c:	b430      	push	{r4, r5}
   2cb8e:	8883      	ldrh	r3, [r0, #4]
   2cb90:	6804      	ldr	r4, [r0, #0]
	buf->len += len;
   2cb92:	189d      	adds	r5, r3, r2
   2cb94:	8085      	strh	r5, [r0, #4]
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	return memcpy(net_buf_simple_add(buf, len), mem, len);
   2cb96:	18e0      	adds	r0, r4, r3
}
   2cb98:	bc30      	pop	{r4, r5}
	return memcpy(net_buf_simple_add(buf, len), mem, len);
   2cb9a:	f7fd bc58 	b.w	2a44e <memcpy>

0002cb9e <net_buf_simple_add_u8>:
   2cb9e:	8883      	ldrh	r3, [r0, #4]
   2cba0:	6802      	ldr	r2, [r0, #0]

u8_t *net_buf_simple_add_u8(struct net_buf_simple *buf, u8_t val)
{
   2cba2:	b510      	push	{r4, lr}
	buf->len += len;
   2cba4:	1c5c      	adds	r4, r3, #1
   2cba6:	8084      	strh	r4, [r0, #4]
	u8_t *u8;

	NET_BUF_SIMPLE_DBG("buf %p val 0x%02x", buf, val);

	u8 = net_buf_simple_add(buf, 1);
	*u8 = val;
   2cba8:	54d1      	strb	r1, [r2, r3]

	return u8;
}
   2cbaa:	18d0      	adds	r0, r2, r3
   2cbac:	bd10      	pop	{r4, pc}

0002cbae <net_buf_simple_add_le16>:
   2cbae:	8883      	ldrh	r3, [r0, #4]
   2cbb0:	6802      	ldr	r2, [r0, #0]

void net_buf_simple_add_le16(struct net_buf_simple *buf, u16_t val)
{
   2cbb2:	b530      	push	{r4, r5, lr}
   2cbb4:	18d4      	adds	r4, r2, r3
	buf->len += len;
   2cbb6:	1c9d      	adds	r5, r3, #2
   2cbb8:	8085      	strh	r5, [r0, #4]
	dst[0] = val;
   2cbba:	54d1      	strb	r1, [r2, r3]
	dst[1] = val >> 8;
   2cbbc:	0a09      	lsrs	r1, r1, #8
   2cbbe:	7061      	strb	r1, [r4, #1]
	NET_BUF_SIMPLE_DBG("buf %p val %u", buf, val);

	sys_put_le16(val, net_buf_simple_add(buf, sizeof(val)));
}
   2cbc0:	bd30      	pop	{r4, r5, pc}

0002cbc2 <net_buf_simple_push>:
{
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	NET_BUF_SIMPLE_ASSERT(net_buf_simple_headroom(buf) >= len);

	buf->data -= len;
   2cbc2:	6803      	ldr	r3, [r0, #0]
	buf->len += len;
   2cbc4:	8882      	ldrh	r2, [r0, #4]
	buf->data -= len;
   2cbc6:	1a5b      	subs	r3, r3, r1
	buf->len += len;
   2cbc8:	4411      	add	r1, r2
	buf->data -= len;
   2cbca:	6003      	str	r3, [r0, #0]
	buf->len += len;
   2cbcc:	8081      	strh	r1, [r0, #4]
	return buf->data;
}
   2cbce:	4618      	mov	r0, r3
   2cbd0:	4770      	bx	lr

0002cbd2 <net_buf_simple_pull>:
{
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	NET_BUF_SIMPLE_ASSERT(buf->len >= len);

	buf->len -= len;
   2cbd2:	8883      	ldrh	r3, [r0, #4]
   2cbd4:	1a5b      	subs	r3, r3, r1
   2cbd6:	8083      	strh	r3, [r0, #4]
	return buf->data += len;
   2cbd8:	6803      	ldr	r3, [r0, #0]
   2cbda:	4419      	add	r1, r3
   2cbdc:	6001      	str	r1, [r0, #0]
}
   2cbde:	4608      	mov	r0, r1
   2cbe0:	4770      	bx	lr

0002cbe2 <net_buf_simple_pull_mem>:

void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)
{
   2cbe2:	4603      	mov	r3, r0
	void *data = buf->data;
   2cbe4:	6800      	ldr	r0, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	NET_BUF_SIMPLE_ASSERT(buf->len >= len);

	buf->len -= len;
   2cbe6:	889a      	ldrh	r2, [r3, #4]
   2cbe8:	1a52      	subs	r2, r2, r1
	buf->data += len;
   2cbea:	4401      	add	r1, r0
	buf->len -= len;
   2cbec:	809a      	strh	r2, [r3, #4]
	buf->data += len;
   2cbee:	6019      	str	r1, [r3, #0]

	return data;
}
   2cbf0:	4770      	bx	lr

0002cbf2 <net_buf_simple_pull_u8>:

u8_t net_buf_simple_pull_u8(struct net_buf_simple *buf)
{
   2cbf2:	b508      	push	{r3, lr}
	u8_t val;

	val = buf->data[0];
   2cbf4:	6803      	ldr	r3, [r0, #0]
	net_buf_simple_pull(buf, 1);
   2cbf6:	2101      	movs	r1, #1
	val = buf->data[0];
   2cbf8:	781a      	ldrb	r2, [r3, #0]
	net_buf_simple_pull(buf, 1);
   2cbfa:	f7ff ffea 	bl	2cbd2 <net_buf_simple_pull>

	return val;
}
   2cbfe:	4610      	mov	r0, r2
   2cc00:	bd08      	pop	{r3, pc}

0002cc02 <net_buf_simple_pull_le16>:

u16_t net_buf_simple_pull_le16(struct net_buf_simple *buf)
{
   2cc02:	b508      	push	{r3, lr}
	u16_t val;

	val = UNALIGNED_GET((u16_t *)buf->data);
   2cc04:	6803      	ldr	r3, [r0, #0]
	net_buf_simple_pull(buf, sizeof(val));
   2cc06:	2102      	movs	r1, #2
	val = UNALIGNED_GET((u16_t *)buf->data);
   2cc08:	881a      	ldrh	r2, [r3, #0]
	net_buf_simple_pull(buf, sizeof(val));
   2cc0a:	f7ff ffe2 	bl	2cbd2 <net_buf_simple_pull>

	return sys_le16_to_cpu(val);
}
   2cc0e:	4610      	mov	r0, r2
   2cc10:	bd08      	pop	{r3, pc}

0002cc12 <net_buf_simple_headroom>:
	return sys_be32_to_cpu(val);
}

size_t net_buf_simple_headroom(struct net_buf_simple *buf)
{
	return buf->data - buf->__buf;
   2cc12:	6802      	ldr	r2, [r0, #0]
   2cc14:	6880      	ldr	r0, [r0, #8]
}
   2cc16:	1a10      	subs	r0, r2, r0
   2cc18:	4770      	bx	lr

0002cc1a <net_buf_simple_tailroom>:

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
   2cc1a:	8883      	ldrh	r3, [r0, #4]
   2cc1c:	88c2      	ldrh	r2, [r0, #6]
   2cc1e:	1ad2      	subs	r2, r2, r3
	return buf->data - buf->__buf;
   2cc20:	6803      	ldr	r3, [r0, #0]
   2cc22:	6880      	ldr	r0, [r0, #8]
   2cc24:	1a18      	subs	r0, r3, r0
}
   2cc26:	1a10      	subs	r0, r2, r0
   2cc28:	4770      	bx	lr

0002cc2a <gpio_nrfx_write>:
{
   2cc2a:	b510      	push	{r4, lr}
	return port->config->config_info;
   2cc2c:	6804      	ldr	r4, [r0, #0]
   2cc2e:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2cc30:	68a4      	ldr	r4, [r4, #8]
   2cc32:	69c0      	ldr	r0, [r0, #28]
   2cc34:	6824      	ldr	r4, [r4, #0]
	if (access_op == GPIO_ACCESS_BY_PORT) {
   2cc36:	2901      	cmp	r1, #1
   2cc38:	d104      	bne.n	2cc44 <gpio_nrfx_write+0x1a>
		nrf_gpio_port_out_write(reg, value ^ data->inverted);
   2cc3a:	4058      	eors	r0, r3
    p_reg->OUT = value;
   2cc3c:	f8c4 0504 	str.w	r0, [r4, #1284]	; 0x504
}
   2cc40:	2000      	movs	r0, #0
   2cc42:	bd10      	pop	{r4, pc}
		if ((value > 0) ^ ((BIT(pin) & data->inverted) != 0)) {
   2cc44:	3300      	adds	r3, #0
   2cc46:	fa20 f002 	lsr.w	r0, r0, r2
   2cc4a:	f04f 0101 	mov.w	r1, #1
   2cc4e:	bf18      	it	ne
   2cc50:	2301      	movne	r3, #1
   2cc52:	f000 0001 	and.w	r0, r0, #1
   2cc56:	4091      	lsls	r1, r2
   2cc58:	4283      	cmp	r3, r0
    p_reg->OUTSET = set_mask;
   2cc5a:	bf14      	ite	ne
   2cc5c:	f8c4 1508 	strne.w	r1, [r4, #1288]	; 0x508
}


NRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
    p_reg->OUTCLR = clr_mask;
   2cc60:	f8c4 150c 	streq.w	r1, [r4, #1292]	; 0x50c
   2cc64:	e7ec      	b.n	2cc40 <gpio_nrfx_write+0x16>

0002cc66 <gpio_nrfx_read>:
{
   2cc66:	b570      	push	{r4, r5, r6, lr}
	return port->config->config_info;
   2cc68:	6804      	ldr	r4, [r0, #0]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   2cc6a:	6880      	ldr	r0, [r0, #8]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2cc6c:	68a4      	ldr	r4, [r4, #8]
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   2cc6e:	69c0      	ldr	r0, [r0, #28]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2cc70:	6825      	ldr	r5, [r4, #0]
    return p_reg->DIR;
   2cc72:	f8d5 6514 	ldr.w	r6, [r5, #1300]	; 0x514
    return p_reg->IN;
   2cc76:	f8d5 4510 	ldr.w	r4, [r5, #1296]	; 0x510
    return p_reg->OUT;
   2cc7a:	f8d5 5504 	ldr.w	r5, [r5, #1284]	; 0x504
	u32_t port_val = (port_in | port_out) ^ data->inverted;
   2cc7e:	4060      	eors	r0, r4
   2cc80:	406c      	eors	r4, r5
   2cc82:	4034      	ands	r4, r6
   2cc84:	4060      	eors	r0, r4
	if (access_op == GPIO_ACCESS_BY_PORT) {
   2cc86:	2901      	cmp	r1, #1
		*value = (port_val & BIT(pin)) ? 1 : 0;
   2cc88:	bf1c      	itt	ne
   2cc8a:	40d0      	lsrne	r0, r2
   2cc8c:	f000 0001 	andne.w	r0, r0, #1
   2cc90:	6018      	str	r0, [r3, #0]
}
   2cc92:	2000      	movs	r0, #0
   2cc94:	bd70      	pop	{r4, r5, r6, pc}

0002cc96 <gpio_nrfx_manage_callback>:
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   2cc96:	6883      	ldr	r3, [r0, #8]
Z_GENLIST_IS_EMPTY(slist)
   2cc98:	6818      	ldr	r0, [r3, #0]
{
   2cc9a:	b530      	push	{r4, r5, lr}
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
   2cc9c:	b158      	cbz	r0, 2ccb6 <gpio_nrfx_manage_callback+0x20>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   2cc9e:	2400      	movs	r4, #0
   2cca0:	4281      	cmp	r1, r0
   2cca2:	d113      	bne.n	2cccc <gpio_nrfx_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
   2cca4:	6808      	ldr	r0, [r1, #0]
   2cca6:	b95c      	cbnz	r4, 2ccc0 <gpio_nrfx_manage_callback+0x2a>
   2cca8:	685c      	ldr	r4, [r3, #4]
	list->head = node;
   2ccaa:	6018      	str	r0, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   2ccac:	42a1      	cmp	r1, r4
   2ccae:	d100      	bne.n	2ccb2 <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
   2ccb0:	6058      	str	r0, [r3, #4]
	parent->next = child;
   2ccb2:	2000      	movs	r0, #0
   2ccb4:	6008      	str	r0, [r1, #0]
				return -EINVAL;
			}
		}
	}

	if (set) {
   2ccb6:	b972      	cbnz	r2, 2ccd6 <gpio_nrfx_manage_callback+0x40>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
   2ccb8:	2000      	movs	r0, #0
}
   2ccba:	bd30      	pop	{r4, r5, pc}
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   2ccbc:	4628      	mov	r0, r5
   2ccbe:	e7ef      	b.n	2cca0 <gpio_nrfx_manage_callback+0xa>
	parent->next = child;
   2ccc0:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   2ccc2:	6858      	ldr	r0, [r3, #4]
   2ccc4:	4281      	cmp	r1, r0
	list->tail = node;
   2ccc6:	bf08      	it	eq
   2ccc8:	605c      	streq	r4, [r3, #4]
   2ccca:	e7f2      	b.n	2ccb2 <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   2cccc:	6805      	ldr	r5, [r0, #0]
	return node->next;
   2ccce:	4604      	mov	r4, r0
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   2ccd0:	2d00      	cmp	r5, #0
   2ccd2:	d1f3      	bne.n	2ccbc <gpio_nrfx_manage_callback+0x26>
			if (!set) {
   2ccd4:	b13a      	cbz	r2, 2cce6 <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
   2ccd6:	681a      	ldr	r2, [r3, #0]
	parent->next = child;
   2ccd8:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
   2ccda:	6858      	ldr	r0, [r3, #4]
	list->head = node;
   2ccdc:	6019      	str	r1, [r3, #0]
Z_GENLIST_PREPEND(slist, snode)
   2ccde:	2800      	cmp	r0, #0
   2cce0:	d1ea      	bne.n	2ccb8 <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
   2cce2:	6059      	str	r1, [r3, #4]
   2cce4:	e7e9      	b.n	2ccba <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
   2cce6:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   2ccea:	e7e6      	b.n	2ccba <gpio_nrfx_manage_callback+0x24>

0002ccec <fire_callbacks>:
{
   2ccec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct gpio_nrfx_data *data = get_port_data(port);
   2ccee:	6885      	ldr	r5, [r0, #8]
{
   2ccf0:	460f      	mov	r7, r1
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   2ccf2:	6829      	ldr	r1, [r5, #0]
{
   2ccf4:	4606      	mov	r6, r0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   2ccf6:	b169      	cbz	r1, 2cd14 <fire_callbacks+0x28>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   2ccf8:	680c      	ldr	r4, [r1, #0]
		if ((cb->pin_mask & pins) & data->int_en) {
   2ccfa:	68eb      	ldr	r3, [r5, #12]
   2ccfc:	688a      	ldr	r2, [r1, #8]
   2ccfe:	403b      	ands	r3, r7
   2cd00:	4213      	tst	r3, r2
   2cd02:	d003      	beq.n	2cd0c <fire_callbacks+0x20>
			cb->handler(port, cb, pins);
   2cd04:	684b      	ldr	r3, [r1, #4]
   2cd06:	463a      	mov	r2, r7
   2cd08:	4630      	mov	r0, r6
   2cd0a:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   2cd0c:	b114      	cbz	r4, 2cd14 <fire_callbacks+0x28>
   2cd0e:	4621      	mov	r1, r4
   2cd10:	6824      	ldr	r4, [r4, #0]
   2cd12:	e7f2      	b.n	2ccfa <fire_callbacks+0xe>
}
   2cd14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0002cd16 <check_level_trigger_pins>:
	struct gpio_nrfx_data *data = get_port_data(port);
   2cd16:	6883      	ldr	r3, [r0, #8]
	return port->config->config_info;
   2cd18:	6802      	ldr	r2, [r0, #0]
{
   2cd1a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return port->config->config_info;
   2cd1e:	f8d2 8008 	ldr.w	r8, [r2, #8]
	u32_t pin_states = ~(port_in ^ data->inverted ^ data->active_level);
   2cd22:	69dd      	ldr	r5, [r3, #28]
	u32_t out = data->int_en & data->pin_int_en;
   2cd24:	e9d3 2402 	ldrd	r2, r4, [r3, #8]
   2cd28:	4014      	ands	r4, r2
	out &= ~data->trig_edge & ~data->double_edge;
   2cd2a:	e9d3 2105 	ldrd	r2, r1, [r3, #20]
   2cd2e:	430a      	orrs	r2, r1
   2cd30:	ea24 0402 	bic.w	r4, r4, r2
	u32_t port_in = nrf_gpio_port_in_read(cfg->port);
   2cd34:	f8d8 2000 	ldr.w	r2, [r8]
	u32_t pin_states = ~(port_in ^ data->inverted ^ data->active_level);
   2cd38:	691b      	ldr	r3, [r3, #16]
    return p_reg->IN;
   2cd3a:	f8d2 2510 	ldr.w	r2, [r2, #1296]	; 0x510
   2cd3e:	405d      	eors	r5, r3
   2cd40:	4055      	eors	r5, r2
	u32_t out = pin_states & level_pins;
   2cd42:	ea24 0505 	bic.w	r5, r4, r5
	u32_t bit = 1U << pin;
   2cd46:	2601      	movs	r6, #1
	u32_t pin = 0U;
   2cd48:	2700      	movs	r7, #0
	while (level_pins) {
   2cd4a:	b914      	cbnz	r4, 2cd52 <check_level_trigger_pins+0x3c>
}
   2cd4c:	4628      	mov	r0, r5
   2cd4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (level_pins & bit) {
   2cd52:	4234      	tst	r4, r6
   2cd54:	d00a      	beq.n	2cd6c <check_level_trigger_pins+0x56>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   2cd56:	f898 3004 	ldrb.w	r3, [r8, #4]
   2cd5a:	f007 001f 	and.w	r0, r7, #31
			nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
   2cd5e:	2100      	movs	r1, #0
   2cd60:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
   2cd64:	f7f8 faf8 	bl	25358 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   2cd68:	ea24 0406 	bic.w	r4, r4, r6
		++pin;
   2cd6c:	3701      	adds	r7, #1
		bit <<= 1;
   2cd6e:	0076      	lsls	r6, r6, #1
   2cd70:	e7eb      	b.n	2cd4a <check_level_trigger_pins+0x34>

0002cd72 <gpio_nrfx_pin_disable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
   2cd72:	2901      	cmp	r1, #1
{
   2cd74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
   2cd78:	bf18      	it	ne
   2cd7a:	b2d4      	uxtbne	r4, r2
	struct gpio_nrfx_data *data = get_port_data(port);
   2cd7c:	6887      	ldr	r7, [r0, #8]
{
   2cd7e:	4606      	mov	r6, r0
		to_pin   = pin;
   2cd80:	bf12      	itee	ne
   2cd82:	4625      	movne	r5, r4
		to_pin   = 31U;
   2cd84:	251f      	moveq	r5, #31
		from_pin = 0U;
   2cd86:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
   2cd88:	f04f 0801 	mov.w	r8, #1
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   2cd8c:	42ac      	cmp	r4, r5
   2cd8e:	d902      	bls.n	2cd96 <gpio_nrfx_pin_disable_callback+0x24>
	return res;
   2cd90:	2000      	movs	r0, #0
}
   2cd92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
   2cd96:	68fb      	ldr	r3, [r7, #12]
   2cd98:	fa08 f204 	lsl.w	r2, r8, r4
   2cd9c:	ea23 0302 	bic.w	r3, r3, r2
   2cda0:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
   2cda2:	4621      	mov	r1, r4
   2cda4:	4630      	mov	r0, r6
   2cda6:	f7f8 faeb 	bl	25380 <gpiote_pin_int_cfg>
		if (res != 0) {
   2cdaa:	2800      	cmp	r0, #0
   2cdac:	d1f1      	bne.n	2cd92 <gpio_nrfx_pin_disable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   2cdae:	3401      	adds	r4, #1
   2cdb0:	b2e4      	uxtb	r4, r4
   2cdb2:	e7eb      	b.n	2cd8c <gpio_nrfx_pin_disable_callback+0x1a>

0002cdb4 <cfg_level_pins>:
{
   2cdb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return port->config->config_info;
   2cdb8:	6803      	ldr	r3, [r0, #0]
	const struct gpio_nrfx_data *data = get_port_data(port);
   2cdba:	6885      	ldr	r5, [r0, #8]
	return port->config->config_info;
   2cdbc:	689e      	ldr	r6, [r3, #8]
	u32_t out = data->int_en & data->pin_int_en;
   2cdbe:	e9d5 3402 	ldrd	r3, r4, [r5, #8]
   2cdc2:	401c      	ands	r4, r3
	out &= ~data->trig_edge & ~data->double_edge;
   2cdc4:	e9d5 3205 	ldrd	r3, r2, [r5, #20]
   2cdc8:	4313      	orrs	r3, r2
   2cdca:	ea24 0403 	bic.w	r4, r4, r3
	u32_t bit = 1U << pin;
   2cdce:	f04f 0801 	mov.w	r8, #1
	u32_t pin = 0U;
   2cdd2:	2700      	movs	r7, #0
	while (level_pins) {
   2cdd4:	b90c      	cbnz	r4, 2cdda <cfg_level_pins+0x26>
}
   2cdd6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (level_pins & bit) {
   2cdda:	ea18 0f04 	tst.w	r8, r4
   2cdde:	d012      	beq.n	2ce06 <cfg_level_pins+0x52>
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   2cde0:	692b      	ldr	r3, [r5, #16]
   2cde2:	69ea      	ldr	r2, [r5, #28]
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   2cde4:	f896 c004 	ldrb.w	ip, [r6, #4]
	if ((BIT(pin) & (data->active_level ^ data->inverted)) != 0) {
   2cde8:	4053      	eors	r3, r2
   2cdea:	40fb      	lsrs	r3, r7
		return NRF_GPIO_PIN_SENSE_HIGH;
   2cdec:	f013 0f01 	tst.w	r3, #1
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   2cdf0:	f007 001f 	and.w	r0, r7, #31
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   2cdf4:	bf0c      	ite	eq
   2cdf6:	2103      	moveq	r1, #3
   2cdf8:	2102      	movne	r1, #2
   2cdfa:	ea40 104c 	orr.w	r0, r0, ip, lsl #5
   2cdfe:	f7f8 faab 	bl	25358 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   2ce02:	ea24 0408 	bic.w	r4, r4, r8
		++pin;
   2ce06:	3701      	adds	r7, #1
		bit <<= 1;
   2ce08:	ea4f 0848 	mov.w	r8, r8, lsl #1
   2ce0c:	e7e2      	b.n	2cdd4 <cfg_level_pins+0x20>

0002ce0e <gpio_nrfx_pin_enable_callback>:
	if (access_op == GPIO_ACCESS_BY_PORT) {
   2ce0e:	2901      	cmp	r1, #1
{
   2ce10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		from_pin = pin;
   2ce14:	bf18      	it	ne
   2ce16:	b2d4      	uxtbne	r4, r2
	struct gpio_nrfx_data *data = get_port_data(port);
   2ce18:	6887      	ldr	r7, [r0, #8]
{
   2ce1a:	4606      	mov	r6, r0
		to_pin   = pin;
   2ce1c:	bf12      	itee	ne
   2ce1e:	4625      	movne	r5, r4
		to_pin   = 31U;
   2ce20:	251f      	moveq	r5, #31
		from_pin = 0U;
   2ce22:	2400      	moveq	r4, #0
		WRITE_BIT(data->int_en, curr_pin, enable);
   2ce24:	f04f 0801 	mov.w	r8, #1
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   2ce28:	42ac      	cmp	r4, r5
   2ce2a:	d902      	bls.n	2ce32 <gpio_nrfx_pin_enable_callback+0x24>
	return res;
   2ce2c:	2000      	movs	r0, #0
}
   2ce2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		WRITE_BIT(data->int_en, curr_pin, enable);
   2ce32:	68fb      	ldr	r3, [r7, #12]
   2ce34:	fa08 f204 	lsl.w	r2, r8, r4
   2ce38:	4313      	orrs	r3, r2
   2ce3a:	60fb      	str	r3, [r7, #12]
		res = gpiote_pin_int_cfg(port, curr_pin);
   2ce3c:	4621      	mov	r1, r4
   2ce3e:	4630      	mov	r0, r6
   2ce40:	f7f8 fa9e 	bl	25380 <gpiote_pin_int_cfg>
		if (res != 0) {
   2ce44:	2800      	cmp	r0, #0
   2ce46:	d1f2      	bne.n	2ce2e <gpio_nrfx_pin_enable_callback+0x20>
	for (u8_t curr_pin = from_pin; curr_pin <= to_pin; ++curr_pin) {
   2ce48:	3401      	adds	r4, #1
   2ce4a:	b2e4      	uxtb	r4, r4
   2ce4c:	e7ec      	b.n	2ce28 <gpio_nrfx_pin_enable_callback+0x1a>

0002ce4e <is_regular_addr_valid>:
{
   2ce4e:	b538      	push	{r3, r4, r5, lr}
   2ce50:	4604      	mov	r4, r0
   2ce52:	460d      	mov	r5, r1
	size_t flash_size = nrfx_nvmc_flash_size_get();
   2ce54:	f000 f88a 	bl	2cf6c <nrfx_nvmc_flash_size_get>
	if (addr >= flash_size ||
   2ce58:	4284      	cmp	r4, r0
   2ce5a:	d209      	bcs.n	2ce70 <is_regular_addr_valid+0x22>
   2ce5c:	2c00      	cmp	r4, #0
   2ce5e:	db07      	blt.n	2ce70 <is_regular_addr_valid+0x22>
	    addr < 0 ||
   2ce60:	42a8      	cmp	r0, r5
   2ce62:	d305      	bcc.n	2ce70 <is_regular_addr_valid+0x22>
	    (addr) + len > flash_size) {
   2ce64:	442c      	add	r4, r5
	    len > flash_size ||
   2ce66:	4284      	cmp	r4, r0
   2ce68:	bf8c      	ite	hi
   2ce6a:	2000      	movhi	r0, #0
   2ce6c:	2001      	movls	r0, #1
}
   2ce6e:	bd38      	pop	{r3, r4, r5, pc}
		return false;
   2ce70:	2000      	movs	r0, #0
   2ce72:	e7fc      	b.n	2ce6e <is_regular_addr_valid+0x20>

0002ce74 <flash_nrf_read>:
{
   2ce74:	b570      	push	{r4, r5, r6, lr}
   2ce76:	460d      	mov	r5, r1
	if (is_regular_addr_valid(addr, len)) {
   2ce78:	4628      	mov	r0, r5
   2ce7a:	4619      	mov	r1, r3
{
   2ce7c:	4616      	mov	r6, r2
   2ce7e:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
   2ce80:	f7ff ffe5 	bl	2ce4e <is_regular_addr_valid>
   2ce84:	b138      	cbz	r0, 2ce96 <flash_nrf_read+0x22>
	if (!len) {
   2ce86:	b14c      	cbz	r4, 2ce9c <flash_nrf_read+0x28>
	memcpy(data, (void *)addr, len);
   2ce88:	4622      	mov	r2, r4
   2ce8a:	4629      	mov	r1, r5
   2ce8c:	4630      	mov	r0, r6
   2ce8e:	f7fd fade 	bl	2a44e <memcpy>
	return 0;
   2ce92:	2000      	movs	r0, #0
}
   2ce94:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   2ce96:	f06f 0015 	mvn.w	r0, #21
   2ce9a:	e7fb      	b.n	2ce94 <flash_nrf_read+0x20>
		return 0;
   2ce9c:	4620      	mov	r0, r4
   2ce9e:	e7f9      	b.n	2ce94 <flash_nrf_read+0x20>

0002cea0 <flash_get_page_info>:

#include <drivers/flash.h>

static int flash_get_page_info(struct device *dev, off_t offs,
				   bool use_addr, struct flash_pages_info *info)
{
   2cea0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   2cea4:	461d      	mov	r5, r3
	off_t group_offs = 0;
	u32_t num_in_group;
	off_t end = 0;
	size_t layout_size;

	api->page_layout(dev, &layout, &layout_size);
   2cea6:	6843      	ldr	r3, [r0, #4]
{
   2cea8:	460c      	mov	r4, r1
	api->page_layout(dev, &layout, &layout_size);
   2ceaa:	691b      	ldr	r3, [r3, #16]
   2ceac:	4669      	mov	r1, sp
{
   2ceae:	4616      	mov	r6, r2
	api->page_layout(dev, &layout, &layout_size);
   2ceb0:	aa01      	add	r2, sp, #4
   2ceb2:	4798      	blx	r3

	while (layout_size--) {
   2ceb4:	e9dd 1200 	ldrd	r1, r2, [sp]
   2ceb8:	2300      	movs	r3, #0
   2ceba:	3a01      	subs	r2, #1
	off_t end = 0;
   2cebc:	4618      	mov	r0, r3
	off_t group_offs = 0;
   2cebe:	469e      	mov	lr, r3
	size_t page_count = 0;
   2cec0:	469c      	mov	ip, r3
	while (layout_size--) {
   2cec2:	1c57      	adds	r7, r2, #1
   2cec4:	d102      	bne.n	2cecc <flash_get_page_info+0x2c>
		page_count += layout->pages_count;

		layout++;
	}

	return -EINVAL; /* page of the index doesn't exist */
   2cec6:	f06f 0015 	mvn.w	r0, #21
   2ceca:	e01a      	b.n	2cf02 <flash_get_page_info+0x62>
		if (use_addr) {
   2cecc:	f8d1 8000 	ldr.w	r8, [r1]
   2ced0:	b1d6      	cbz	r6, 2cf08 <flash_get_page_info+0x68>
			end += layout->pages_count * layout->pages_size;
   2ced2:	684f      	ldr	r7, [r1, #4]
   2ced4:	fb07 0008 	mla	r0, r7, r8, r0
		if (offs < end) {
   2ced8:	42a0      	cmp	r0, r4
   2ceda:	f102 37ff 	add.w	r7, r2, #4294967295	; 0xffffffff
   2cede:	dd18      	ble.n	2cf12 <flash_get_page_info+0x72>
   2cee0:	9201      	str	r2, [sp, #4]
   2cee2:	b103      	cbz	r3, 2cee6 <flash_get_page_info+0x46>
   2cee4:	9100      	str	r1, [sp, #0]
			info->size = layout->pages_size;
   2cee6:	9b00      	ldr	r3, [sp, #0]
   2cee8:	685b      	ldr	r3, [r3, #4]
   2ceea:	606b      	str	r3, [r5, #4]
			if (use_addr) {
   2ceec:	b176      	cbz	r6, 2cf0c <flash_get_page_info+0x6c>
				num_in_group = (offs - group_offs) /
   2ceee:	eba4 040e 	sub.w	r4, r4, lr
   2cef2:	fbb4 f4f3 	udiv	r4, r4, r3
			info->start_offset = group_offs +
   2cef6:	fb04 e303 	mla	r3, r4, r3, lr
			info->index = page_count + num_in_group;
   2cefa:	4464      	add	r4, ip
			info->start_offset = group_offs +
   2cefc:	602b      	str	r3, [r5, #0]
			info->index = page_count + num_in_group;
   2cefe:	60ac      	str	r4, [r5, #8]
			return 0;
   2cf00:	2000      	movs	r0, #0
}
   2cf02:	b002      	add	sp, #8
   2cf04:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			end += layout->pages_count;
   2cf08:	4440      	add	r0, r8
   2cf0a:	e7e5      	b.n	2ced8 <flash_get_page_info+0x38>
				num_in_group = offs - page_count;
   2cf0c:	eba4 040c 	sub.w	r4, r4, ip
   2cf10:	e7f1      	b.n	2cef6 <flash_get_page_info+0x56>
		group_offs += layout->pages_count * layout->pages_size;
   2cf12:	684b      	ldr	r3, [r1, #4]
		page_count += layout->pages_count;
   2cf14:	44c4      	add	ip, r8
		group_offs += layout->pages_count * layout->pages_size;
   2cf16:	fb03 ee08 	mla	lr, r3, r8, lr
		layout++;
   2cf1a:	3108      	adds	r1, #8
   2cf1c:	2301      	movs	r3, #1
   2cf1e:	463a      	mov	r2, r7
   2cf20:	e7cf      	b.n	2cec2 <flash_get_page_info+0x22>

0002cf22 <z_impl_flash_get_page_info_by_offs>:

int z_impl_flash_get_page_info_by_offs(struct device *dev, off_t offs,
				      struct flash_pages_info *info)
{
	return flash_get_page_info(dev, offs, true, info);
   2cf22:	4613      	mov	r3, r2
   2cf24:	2201      	movs	r2, #1
   2cf26:	f7ff bfbb 	b.w	2cea0 <flash_get_page_info>

0002cf2a <uart_nrfx_config_get>:
	*cfg = get_dev_data(dev)->uart_config;
   2cf2a:	6882      	ldr	r2, [r0, #8]
{
   2cf2c:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
   2cf2e:	e892 0003 	ldmia.w	r2, {r0, r1}
   2cf32:	e883 0003 	stmia.w	r3, {r0, r1}
}
   2cf36:	2000      	movs	r0, #0
   2cf38:	4770      	bx	lr

0002cf3a <uart_nrfx_irq_tx_ready_complete>:
{
   2cf3a:	b508      	push	{r3, lr}
	return event_txdrdy_check();
   2cf3c:	f7f8 fce8 	bl	25910 <event_txdrdy_check>
}
   2cf40:	bd08      	pop	{r3, pc}

0002cf42 <uart_nrfx_irq_update>:
}
   2cf42:	2001      	movs	r0, #1
   2cf44:	4770      	bx	lr

0002cf46 <partial_word_create>:
{
   2cf46:	b082      	sub	sp, #8
    value32 = 0xFFFFFFFF;
   2cf48:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2cf4c:	9301      	str	r3, [sp, #4]
    byte_shift = addr % NVMC_BYTES_IN_WORD;
   2cf4e:	f000 0003 	and.w	r0, r0, #3
   2cf52:	ab01      	add	r3, sp, #4
   2cf54:	4418      	add	r0, r3
   2cf56:	440a      	add	r2, r1
    for (uint32_t i = 0; i < bytes_count; i++)
   2cf58:	4291      	cmp	r1, r2
   2cf5a:	d102      	bne.n	2cf62 <partial_word_create+0x1c>
}
   2cf5c:	9801      	ldr	r0, [sp, #4]
   2cf5e:	b002      	add	sp, #8
   2cf60:	4770      	bx	lr
        ((uint8_t *)&value32)[byte_shift] = bytes[i];
   2cf62:	f811 3b01 	ldrb.w	r3, [r1], #1
   2cf66:	f800 3b01 	strb.w	r3, [r0], #1
        byte_shift++;
   2cf6a:	e7f5      	b.n	2cf58 <partial_word_create+0x12>

0002cf6c <nrfx_nvmc_flash_size_get>:
   2cf6c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   2cf70:	691a      	ldr	r2, [r3, #16]
NRF_STATIC_INLINE uint32_t nrf_ficr_codesize_get(NRF_FICR_Type const * p_reg)
{
#if defined(FICR_INFO_CODESIZE_CODESIZE_Msk)
    return p_reg->INFO.CODESIZE;
#else
    return p_reg->CODESIZE;
   2cf72:	6958      	ldr	r0, [r3, #20]
}

uint32_t nrfx_nvmc_flash_size_get(void)
{
    return flash_total_size_get();
}
   2cf74:	4350      	muls	r0, r2
   2cf76:	4770      	bx	lr

0002cf78 <nrfx_nvmc_flash_page_size_get>:
    return p_reg->CODEPAGESIZE;
   2cf78:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   2cf7c:	6918      	ldr	r0, [r3, #16]

uint32_t nrfx_nvmc_flash_page_size_get(void)
{
    return flash_page_size_get();
}
   2cf7e:	4770      	bx	lr

0002cf80 <nrfx_nvmc_flash_page_count_get>:
    return p_reg->CODESIZE;
   2cf80:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   2cf84:	6958      	ldr	r0, [r3, #20]

uint32_t nrfx_nvmc_flash_page_count_get(void)
{
    return flash_page_count_get();
}
   2cf86:	4770      	bx	lr

0002cf88 <device_busy_set>:
	atomic_set_bit((atomic_t *) __device_busy_start,
				 (busy_dev - __device_init_start));
#else
	ARG_UNUSED(busy_dev);
#endif
}
   2cf88:	4770      	bx	lr

0002cf8a <device_busy_clear>:
   2cf8a:	4770      	bx	lr

0002cf8c <arch_system_halt>:
	__asm__ volatile(
   2cf8c:	f04f 0220 	mov.w	r2, #32
   2cf90:	f3ef 8311 	mrs	r3, BASEPRI
   2cf94:	f382 8811 	msr	BASEPRI, r2
   2cf98:	f3bf 8f6f 	isb	sy
	}
   2cf9c:	e7fe      	b.n	2cf9c <arch_system_halt+0x10>

0002cf9e <z_sys_power_save_idle_exit>:
	z_clock_idle_exit();
   2cf9e:	f7fd b935 	b.w	2a20c <z_clock_idle_exit>

0002cfa2 <k_mem_slab_init>:
{
   2cfa2:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
   2cfa4:	2400      	movs	r4, #0
	slab->block_size = block_size;
   2cfa6:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->free_list = NULL;
   2cfaa:	e9c0 4405 	strd	r4, r4, [r0, #20]
	slab->buffer = buffer;
   2cfae:	6101      	str	r1, [r0, #16]
	for (j = 0U; j < slab->num_blocks; j++) {
   2cfb0:	42a3      	cmp	r3, r4
   2cfb2:	d102      	bne.n	2cfba <k_mem_slab_init+0x18>
   2cfb4:	e9c0 0000 	strd	r0, r0, [r0]
}
   2cfb8:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
   2cfba:	6945      	ldr	r5, [r0, #20]
   2cfbc:	600d      	str	r5, [r1, #0]
	for (j = 0U; j < slab->num_blocks; j++) {
   2cfbe:	3401      	adds	r4, #1
		slab->free_list = p;
   2cfc0:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
   2cfc2:	4411      	add	r1, r2
   2cfc4:	e7f4      	b.n	2cfb0 <k_mem_slab_init+0xe>

0002cfc6 <k_mem_pool_malloc>:
{
   2cfc6:	b513      	push	{r0, r1, r4, lr}
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
   2cfc8:	2404      	movs	r4, #4
   2cfca:	190a      	adds	r2, r1, r4
   2cfcc:	d204      	bcs.n	2cfd8 <k_mem_pool_malloc+0x12>
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
   2cfce:	2300      	movs	r3, #0
   2cfd0:	4669      	mov	r1, sp
   2cfd2:	f7f9 fbc9 	bl	26768 <k_mem_pool_alloc>
   2cfd6:	b110      	cbz	r0, 2cfde <k_mem_pool_malloc+0x18>
		return NULL;
   2cfd8:	2000      	movs	r0, #0
}
   2cfda:	b002      	add	sp, #8
   2cfdc:	bd10      	pop	{r4, pc}
	(void)memcpy(block.data, &block.id, sizeof(struct k_mem_block_id));
   2cfde:	4622      	mov	r2, r4
   2cfe0:	a901      	add	r1, sp, #4
   2cfe2:	9800      	ldr	r0, [sp, #0]
   2cfe4:	f7fd fa33 	bl	2a44e <memcpy>
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
   2cfe8:	9800      	ldr	r0, [sp, #0]
   2cfea:	3004      	adds	r0, #4
   2cfec:	e7f5      	b.n	2cfda <k_mem_pool_malloc+0x14>

0002cfee <k_free>:
	if (ptr != NULL) {
   2cfee:	b110      	cbz	r0, 2cff6 <k_free+0x8>
		k_mem_pool_free_id(ptr);
   2cff0:	3804      	subs	r0, #4
   2cff2:	f7f9 bc05 	b.w	26800 <k_mem_pool_free_id>
}
   2cff6:	4770      	bx	lr

0002cff8 <z_impl_k_msgq_peek>:
}
#include <syscalls/k_msgq_get_mrsh.c>
#endif

int z_impl_k_msgq_peek(struct k_msgq *msgq, void *data)
{
   2cff8:	4603      	mov	r3, r0
   2cffa:	b510      	push	{r4, lr}
   2cffc:	4608      	mov	r0, r1
   2cffe:	f04f 0220 	mov.w	r2, #32
   2d002:	f3ef 8411 	mrs	r4, BASEPRI
   2d006:	f382 8811 	msr	BASEPRI, r2
   2d00a:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);

	if (msgq->used_msgs > 0) {
   2d00e:	6a1a      	ldr	r2, [r3, #32]
   2d010:	b14a      	cbz	r2, 2d026 <z_impl_k_msgq_peek+0x2e>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
   2d012:	689a      	ldr	r2, [r3, #8]
   2d014:	6999      	ldr	r1, [r3, #24]
   2d016:	f7fd fa1a 	bl	2a44e <memcpy>
		result = 0;
   2d01a:	2000      	movs	r0, #0
	__asm__ volatile(
   2d01c:	f384 8811 	msr	BASEPRI, r4
   2d020:	f3bf 8f6f 	isb	sy
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   2d024:	bd10      	pop	{r4, pc}
		result = -ENOMSG;
   2d026:	f06f 004f 	mvn.w	r0, #79	; 0x4f
   2d02a:	e7f7      	b.n	2d01c <z_impl_k_msgq_peek+0x24>

0002d02c <z_impl_k_mutex_init>:
	mutex->owner = NULL;
   2d02c:	2300      	movs	r3, #0
	mutex->lock_count = 0U;
   2d02e:	e9c0 3302 	strd	r3, r3, [r0, #8]
   2d032:	e9c0 0000 	strd	r0, r0, [r0]
}
   2d036:	4770      	bx	lr

0002d038 <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static s32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			  bool alloc)
{
   2d038:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2d03c:	4604      	mov	r4, r0
   2d03e:	460f      	mov	r7, r1
   2d040:	4690      	mov	r8, r2
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   2d042:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
   2d046:	f04f 0220 	mov.w	r2, #32
   2d04a:	f3ef 8611 	mrs	r6, BASEPRI
   2d04e:	f382 8811 	msr	BASEPRI, r2
   2d052:	f3bf 8f6f 	isb	sy
		return 0;
	}
#endif /* !CONFIG_POLL */

	/* Only need to actually allocate if no threads are pending */
	if (alloc) {
   2d056:	b1db      	cbz	r3, 2d090 <queue_insert+0x58>
		struct alloc_node *anode;

		anode = z_thread_malloc(sizeof(*anode));
   2d058:	2008      	movs	r0, #8
   2d05a:	f7f9 fbfd 	bl	26858 <z_thread_malloc>
		if (anode == NULL) {
   2d05e:	b938      	cbnz	r0, 2d070 <queue_insert+0x38>
	__asm__ volatile(
   2d060:	f386 8811 	msr	BASEPRI, r6
   2d064:	f3bf 8f6f 	isb	sy
			k_spin_unlock(&queue->lock, key);
			return -ENOMEM;
   2d068:	f06f 000b 	mvn.w	r0, #11
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
#endif /* CONFIG_POLL */

	z_reschedule(&queue->lock, key);
	return 0;
}
   2d06c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, u8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
   2d070:	2301      	movs	r3, #1
		anode->data = data;
   2d072:	f8c0 8004 	str.w	r8, [r0, #4]
   2d076:	6003      	str	r3, [r0, #0]
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
   2d078:	6803      	ldr	r3, [r0, #0]
   2d07a:	f003 0203 	and.w	r2, r3, #3
   2d07e:	b95f      	cbnz	r7, 2d098 <queue_insert+0x60>
	parent->next_and_flags = cur_flags | (unative_t)child;
   2d080:	6823      	ldr	r3, [r4, #0]
   2d082:	4313      	orrs	r3, r2
   2d084:	6003      	str	r3, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   2d086:	6863      	ldr	r3, [r4, #4]
	list->head = node;
   2d088:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   2d08a:	b973      	cbnz	r3, 2d0aa <queue_insert+0x72>
	list->tail = node;
   2d08c:	6060      	str	r0, [r4, #4]
   2d08e:	e00c      	b.n	2d0aa <queue_insert+0x72>
	node->next_and_flags = flags;
   2d090:	f8c8 3000 	str.w	r3, [r8]
   2d094:	4640      	mov	r0, r8
   2d096:	e7ef      	b.n	2d078 <queue_insert+0x40>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   2d098:	683b      	ldr	r3, [r7, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   2d09a:	f033 0303 	bics.w	r3, r3, #3
   2d09e:	d114      	bne.n	2d0ca <queue_insert+0x92>
	parent->next_and_flags = cur_flags | (unative_t)child;
   2d0a0:	6002      	str	r2, [r0, #0]
Z_GENLIST_APPEND(sflist, sfnode)
   2d0a2:	6862      	ldr	r2, [r4, #4]
   2d0a4:	b95a      	cbnz	r2, 2d0be <queue_insert+0x86>
	list->head = node;
   2d0a6:	e9c4 0000 	strd	r0, r0, [r4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   2d0aa:	2104      	movs	r1, #4
   2d0ac:	4628      	mov	r0, r5
   2d0ae:	f000 fbe4 	bl	2d87a <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   2d0b2:	4628      	mov	r0, r5
   2d0b4:	4631      	mov	r1, r6
   2d0b6:	f000 f8ed 	bl	2d294 <z_reschedule>
	return 0;
   2d0ba:	2000      	movs	r0, #0
   2d0bc:	e7d6      	b.n	2d06c <queue_insert+0x34>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   2d0be:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   2d0c0:	f003 0303 	and.w	r3, r3, #3
   2d0c4:	4303      	orrs	r3, r0
   2d0c6:	6013      	str	r3, [r2, #0]
   2d0c8:	e7e0      	b.n	2d08c <queue_insert+0x54>
   2d0ca:	4313      	orrs	r3, r2
   2d0cc:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   2d0ce:	683b      	ldr	r3, [r7, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   2d0d0:	f003 0303 	and.w	r3, r3, #3
   2d0d4:	4318      	orrs	r0, r3
   2d0d6:	6038      	str	r0, [r7, #0]
   2d0d8:	e7e7      	b.n	2d0aa <queue_insert+0x72>

0002d0da <z_queue_node_peek>:
{
   2d0da:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (u8_t)0)) {
   2d0dc:	4604      	mov	r4, r0
   2d0de:	b130      	cbz	r0, 2d0ee <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   2d0e0:	6802      	ldr	r2, [r0, #0]
   2d0e2:	0793      	lsls	r3, r2, #30
   2d0e4:	d003      	beq.n	2d0ee <z_queue_node_peek+0x14>
		ret = anode->data;
   2d0e6:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   2d0e8:	b109      	cbz	r1, 2d0ee <z_queue_node_peek+0x14>
			k_free(anode);
   2d0ea:	f7ff ff80 	bl	2cfee <k_free>
}
   2d0ee:	4620      	mov	r0, r4
   2d0f0:	bd10      	pop	{r4, pc}

0002d0f2 <z_impl_k_queue_init>:
	list->head = NULL;
   2d0f2:	2300      	movs	r3, #0
	list->tail = NULL;
   2d0f4:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dlist_init(&queue->poll_events);
   2d0f8:	f100 0308 	add.w	r3, r0, #8
   2d0fc:	e9c0 3302 	strd	r3, r3, [r0, #8]
}
   2d100:	4770      	bx	lr

0002d102 <k_queue_append>:
	(void)queue_insert(queue, prev, data, false);
}

void k_queue_append(struct k_queue *queue, void *data)
{
	(void)queue_insert(queue, sys_sflist_peek_tail(&queue->data_q),
   2d102:	460a      	mov	r2, r1
   2d104:	2300      	movs	r3, #0
   2d106:	6841      	ldr	r1, [r0, #4]
   2d108:	f7ff bf96 	b.w	2d038 <queue_insert>

0002d10c <k_queue_prepend>:
			   data, false);
}

void k_queue_prepend(struct k_queue *queue, void *data)
{
	(void)queue_insert(queue, NULL, data, false);
   2d10c:	2300      	movs	r3, #0
   2d10e:	460a      	mov	r2, r1
   2d110:	4619      	mov	r1, r3
   2d112:	f7ff bf91 	b.w	2d038 <queue_insert>

0002d116 <k_queue_append_list>:
}
#include <syscalls/k_queue_alloc_prepend_mrsh.c>
#endif

void k_queue_append_list(struct k_queue *queue, void *head, void *tail)
{
   2d116:	b570      	push	{r4, r5, r6, lr}
	__ASSERT(head && tail, "invalid head or tail");

	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   2d118:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
   2d11c:	f04f 0320 	mov.w	r3, #32
   2d120:	f3ef 8611 	mrs	r6, BASEPRI
   2d124:	f383 8811 	msr	BASEPRI, r3
   2d128:	f3bf 8f6f 	isb	sy
Z_GENLIST_APPEND_LIST(sflist, sfnode)
   2d12c:	6843      	ldr	r3, [r0, #4]
   2d12e:	b95b      	cbnz	r3, 2d148 <k_queue_append_list+0x32>
	list->head = node;
   2d130:	6001      	str	r1, [r0, #0]
	list->tail = node;
   2d132:	6042      	str	r2, [r0, #4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   2d134:	2104      	movs	r1, #4
   2d136:	4628      	mov	r0, r5
   2d138:	f000 fb9f 	bl	2d87a <z_handle_obj_poll_events>
#else
	sys_sflist_append_list(&queue->data_q, head, tail);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
#endif /* !CONFIG_POLL */

	z_reschedule(&queue->lock, key);
   2d13c:	4631      	mov	r1, r6
   2d13e:	4628      	mov	r0, r5
}
   2d140:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&queue->lock, key);
   2d144:	f000 b8a6 	b.w	2d294 <z_reschedule>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   2d148:	681c      	ldr	r4, [r3, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   2d14a:	f004 0403 	and.w	r4, r4, #3
   2d14e:	4321      	orrs	r1, r4
   2d150:	6019      	str	r1, [r3, #0]
   2d152:	e7ee      	b.n	2d132 <k_queue_append_list+0x1c>

0002d154 <z_impl_k_queue_get>:
	return val;
}
#endif /* CONFIG_POLL */

void *z_impl_k_queue_get(struct k_queue *queue, s32_t timeout)
{
   2d154:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2d158:	4604      	mov	r4, r0
   2d15a:	b086      	sub	sp, #24
   2d15c:	460d      	mov	r5, r1
   2d15e:	f04f 0320 	mov.w	r3, #32
   2d162:	f3ef 8711 	mrs	r7, BASEPRI
   2d166:	f383 8811 	msr	BASEPRI, r3
   2d16a:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(sflist)
   2d16e:	6800      	ldr	r0, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   2d170:	b188      	cbz	r0, 2d196 <z_impl_k_queue_get+0x42>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   2d172:	6803      	ldr	r3, [r0, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   2d174:	6862      	ldr	r2, [r4, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   2d176:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   2d17a:	4290      	cmp	r0, r2
	list->head = node;
   2d17c:	6023      	str	r3, [r4, #0]
	list->tail = node;
   2d17e:	bf08      	it	eq
   2d180:	6063      	streq	r3, [r4, #4]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   2d182:	2101      	movs	r1, #1
   2d184:	f7ff ffa9 	bl	2d0da <z_queue_node_peek>
	__asm__ volatile(
   2d188:	f387 8811 	msr	BASEPRI, r7
   2d18c:	f3bf 8f6f 	isb	sy
#else
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);

	return (ret != 0) ? NULL : _current->base.swap_data;
#endif /* CONFIG_POLL */
}
   2d190:	b006      	add	sp, #24
   2d192:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (timeout == K_NO_WAIT) {
   2d196:	2900      	cmp	r1, #0
   2d198:	d0f6      	beq.n	2d188 <z_impl_k_queue_get+0x34>
   2d19a:	f387 8811 	msr	BASEPRI, r7
   2d19e:	f3bf 8f6f 	isb	sy
	k_poll_event_init(&event, K_POLL_TYPE_FIFO_DATA_AVAILABLE,
   2d1a2:	2104      	movs	r1, #4
   2d1a4:	4602      	mov	r2, r0
   2d1a6:	4623      	mov	r3, r4
   2d1a8:	eb0d 0001 	add.w	r0, sp, r1
   2d1ac:	f7fa faf6 	bl	2779c <k_poll_event_init>
	if (timeout != K_FOREVER) {
   2d1b0:	1c6a      	adds	r2, r5, #1
   2d1b2:	d002      	beq.n	2d1ba <z_impl_k_queue_get+0x66>
	return z_impl_k_uptime_get();
   2d1b4:	f000 fa2e 	bl	2d614 <z_impl_k_uptime_get>
   2d1b8:	4606      	mov	r6, r0
{
   2d1ba:	2700      	movs	r7, #0
		event.state = K_POLL_STATE_NOT_READY;
   2d1bc:	9b04      	ldr	r3, [sp, #16]
   2d1be:	f36f 3310 	bfc	r3, #12, #5
   2d1c2:	9304      	str	r3, [sp, #16]
	return z_impl_k_poll(events, num_events, timeout);
   2d1c4:	2101      	movs	r1, #1
   2d1c6:	1bea      	subs	r2, r5, r7
   2d1c8:	a801      	add	r0, sp, #4
   2d1ca:	f7fa fafb 	bl	277c4 <z_impl_k_poll>
		if (err && err != -EAGAIN) {
   2d1ce:	b118      	cbz	r0, 2d1d8 <z_impl_k_queue_get+0x84>
   2d1d0:	300b      	adds	r0, #11
   2d1d2:	d001      	beq.n	2d1d8 <z_impl_k_queue_get+0x84>
			return NULL;
   2d1d4:	2000      	movs	r0, #0
   2d1d6:	e7db      	b.n	2d190 <z_impl_k_queue_get+0x3c>
	__asm__ volatile(
   2d1d8:	f04f 0320 	mov.w	r3, #32
   2d1dc:	f3ef 8811 	mrs	r8, BASEPRI
   2d1e0:	f383 8811 	msr	BASEPRI, r3
   2d1e4:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(sflist)
   2d1e8:	6820      	ldr	r0, [r4, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_sfnode_t *sys_sflist_get(sys_sflist_t *list);

Z_GENLIST_GET(sflist, sfnode)
   2d1ea:	b138      	cbz	r0, 2d1fc <z_impl_k_queue_get+0xa8>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   2d1ec:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   2d1ee:	6862      	ldr	r2, [r4, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   2d1f0:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   2d1f4:	4290      	cmp	r0, r2
	list->head = node;
   2d1f6:	6023      	str	r3, [r4, #0]
	list->tail = node;
   2d1f8:	bf08      	it	eq
   2d1fa:	6063      	streq	r3, [r4, #4]
		val = z_queue_node_peek(sys_sflist_get(&queue->data_q), true);
   2d1fc:	2101      	movs	r1, #1
   2d1fe:	f7ff ff6c 	bl	2d0da <z_queue_node_peek>
	__asm__ volatile(
   2d202:	f388 8811 	msr	BASEPRI, r8
   2d206:	f3bf 8f6f 	isb	sy
		if ((val == NULL) && (timeout != K_FOREVER)) {
   2d20a:	2800      	cmp	r0, #0
   2d20c:	d1c0      	bne.n	2d190 <z_impl_k_queue_get+0x3c>
   2d20e:	1c6b      	adds	r3, r5, #1
   2d210:	d0d4      	beq.n	2d1bc <z_impl_k_queue_get+0x68>
	return z_impl_k_uptime_get();
   2d212:	f000 f9ff 	bl	2d614 <z_impl_k_uptime_get>
			elapsed = k_uptime_get_32() - start;
   2d216:	1b87      	subs	r7, r0, r6
	} while (!val && !done);
   2d218:	42bd      	cmp	r5, r7
   2d21a:	dacf      	bge.n	2d1bc <z_impl_k_queue_get+0x68>
   2d21c:	e7da      	b.n	2d1d4 <z_impl_k_queue_get+0x80>

0002d21e <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   2d21e:	7b43      	ldrb	r3, [r0, #13]
   2d220:	06db      	lsls	r3, r3, #27
   2d222:	bf03      	ittte	eq
   2d224:	6980      	ldreq	r0, [r0, #24]
   2d226:	fab0 f080 	clzeq	r0, r0
   2d22a:	0940      	lsreq	r0, r0, #5
   2d22c:	2000      	movne	r0, #0
}
   2d22e:	4770      	bx	lr

0002d230 <z_is_t1_higher_prio_than_t2>:
	if (t1->base.prio < t2->base.prio) {
   2d230:	f990 000e 	ldrsb.w	r0, [r0, #14]
   2d234:	f991 300e 	ldrsb.w	r3, [r1, #14]
}
   2d238:	4298      	cmp	r0, r3
   2d23a:	bfac      	ite	ge
   2d23c:	2000      	movge	r0, #0
   2d23e:	2001      	movlt	r0, #1
   2d240:	4770      	bx	lr

0002d242 <z_find_first_thread_to_unpend>:
{
   2d242:	b510      	push	{r4, lr}
	__asm__ volatile(
   2d244:	f04f 0320 	mov.w	r3, #32
   2d248:	f3ef 8411 	mrs	r4, BASEPRI
   2d24c:	f383 8811 	msr	BASEPRI, r3
   2d250:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
   2d254:	f000 f85d 	bl	2d312 <z_priq_dumb_best>
	__asm__ volatile(
   2d258:	f384 8811 	msr	BASEPRI, r4
   2d25c:	f3bf 8f6f 	isb	sy
}
   2d260:	bd10      	pop	{r4, pc}

0002d262 <z_unpend_thread_no_timeout>:
{
   2d262:	b538      	push	{r3, r4, r5, lr}
   2d264:	4604      	mov	r4, r0
	__asm__ volatile(
   2d266:	f04f 0320 	mov.w	r3, #32
   2d26a:	f3ef 8511 	mrs	r5, BASEPRI
   2d26e:	f383 8811 	msr	BASEPRI, r3
   2d272:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   2d276:	4601      	mov	r1, r0
   2d278:	6880      	ldr	r0, [r0, #8]
   2d27a:	f7f9 fcaf 	bl	26bdc <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   2d27e:	7b63      	ldrb	r3, [r4, #13]
   2d280:	f023 0302 	bic.w	r3, r3, #2
   2d284:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
   2d286:	f385 8811 	msr	BASEPRI, r5
   2d28a:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   2d28e:	2300      	movs	r3, #0
   2d290:	60a3      	str	r3, [r4, #8]
}
   2d292:	bd38      	pop	{r3, r4, r5, pc}

0002d294 <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   2d294:	b921      	cbnz	r1, 2d2a0 <z_reschedule+0xc>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   2d296:	f3ef 8005 	mrs	r0, IPSR
   2d29a:	b908      	cbnz	r0, 2d2a0 <z_reschedule+0xc>
   2d29c:	f7e6 bbbc 	b.w	13a18 <arch_swap>
   2d2a0:	f381 8811 	msr	BASEPRI, r1
   2d2a4:	f3bf 8f6f 	isb	sy
}
   2d2a8:	4770      	bx	lr

0002d2aa <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   2d2aa:	4603      	mov	r3, r0
   2d2ac:	b920      	cbnz	r0, 2d2b8 <z_reschedule_irqlock+0xe>
   2d2ae:	f3ef 8205 	mrs	r2, IPSR
   2d2b2:	b90a      	cbnz	r2, 2d2b8 <z_reschedule_irqlock+0xe>
   2d2b4:	f7e6 bbb0 	b.w	13a18 <arch_swap>
   2d2b8:	f383 8811 	msr	BASEPRI, r3
   2d2bc:	f3bf 8f6f 	isb	sy
}
   2d2c0:	4770      	bx	lr

0002d2c2 <z_reschedule_unlocked>:
	__asm__ volatile(
   2d2c2:	f04f 0320 	mov.w	r3, #32
   2d2c6:	f3ef 8011 	mrs	r0, BASEPRI
   2d2ca:	f383 8811 	msr	BASEPRI, r3
   2d2ce:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   2d2d2:	f7ff bfea 	b.w	2d2aa <z_reschedule_irqlock>

0002d2d6 <z_unpend_thread>:
{
   2d2d6:	b538      	push	{r3, r4, r5, lr}
   2d2d8:	4604      	mov	r4, r0
   2d2da:	f04f 0320 	mov.w	r3, #32
   2d2de:	f3ef 8511 	mrs	r5, BASEPRI
   2d2e2:	f383 8811 	msr	BASEPRI, r3
   2d2e6:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   2d2ea:	4601      	mov	r1, r0
   2d2ec:	6880      	ldr	r0, [r0, #8]
   2d2ee:	f7f9 fc75 	bl	26bdc <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   2d2f2:	7b63      	ldrb	r3, [r4, #13]
   2d2f4:	f023 0302 	bic.w	r3, r3, #2
   2d2f8:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
   2d2fa:	f385 8811 	msr	BASEPRI, r5
   2d2fe:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   2d302:	2300      	movs	r3, #0
   2d304:	60a3      	str	r3, [r4, #8]
	return z_abort_timeout(&thread->base.timeout);
   2d306:	f104 0018 	add.w	r0, r4, #24
}
   2d30a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   2d30e:	f000 b93d 	b.w	2d58c <z_abort_timeout>

0002d312 <z_priq_dumb_best>:
	return list->head == list;
   2d312:	6803      	ldr	r3, [r0, #0]
}
   2d314:	4298      	cmp	r0, r3
   2d316:	bf14      	ite	ne
   2d318:	4618      	movne	r0, r3
   2d31a:	2000      	moveq	r0, #0
   2d31c:	4770      	bx	lr

0002d31e <z_thread_timeout>:
	if (th->base.pended_on != NULL) {
   2d31e:	f850 3c10 	ldr.w	r3, [r0, #-16]
{
   2d322:	b570      	push	{r4, r5, r6, lr}
   2d324:	4604      	mov	r4, r0
	struct k_thread *th = CONTAINER_OF(to, struct k_thread, base.timeout);
   2d326:	f1a0 0518 	sub.w	r5, r0, #24
	if (th->base.pended_on != NULL) {
   2d32a:	b1cb      	cbz	r3, 2d360 <z_thread_timeout+0x42>
	__asm__ volatile(
   2d32c:	f04f 0320 	mov.w	r3, #32
   2d330:	f3ef 8611 	mrs	r6, BASEPRI
   2d334:	f383 8811 	msr	BASEPRI, r3
   2d338:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   2d33c:	4629      	mov	r1, r5
   2d33e:	f850 0c10 	ldr.w	r0, [r0, #-16]
   2d342:	f7f9 fc4b 	bl	26bdc <z_priq_dumb_remove>
   2d346:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
   2d34a:	f023 0302 	bic.w	r3, r3, #2
   2d34e:	f804 3c0b 	strb.w	r3, [r4, #-11]
	__asm__ volatile(
   2d352:	f386 8811 	msr	BASEPRI, r6
   2d356:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   2d35a:	2300      	movs	r3, #0
   2d35c:	f844 3c10 	str.w	r3, [r4, #-16]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   2d360:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
   2d364:	f023 0314 	bic.w	r3, r3, #20
   2d368:	f804 3c0b 	strb.w	r3, [r4, #-11]
	if (z_is_thread_ready(thread)) {
   2d36c:	4628      	mov	r0, r5
   2d36e:	f7ff ff56 	bl	2d21e <z_is_thread_ready>
   2d372:	b120      	cbz	r0, 2d37e <z_thread_timeout+0x60>
		z_add_thread_to_ready_q(thread);
   2d374:	4628      	mov	r0, r5
}
   2d376:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   2d37a:	f7f9 bc7f 	b.w	26c7c <z_add_thread_to_ready_q>
   2d37e:	bd70      	pop	{r4, r5, r6, pc}

0002d380 <z_unpend_first_thread>:
{
   2d380:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   2d382:	f04f 0320 	mov.w	r3, #32
   2d386:	f3ef 8211 	mrs	r2, BASEPRI
   2d38a:	f383 8811 	msr	BASEPRI, r3
   2d38e:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
   2d392:	f7ff ffbe 	bl	2d312 <z_priq_dumb_best>
   2d396:	4604      	mov	r4, r0
	__asm__ volatile(
   2d398:	f382 8811 	msr	BASEPRI, r2
   2d39c:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
   2d3a0:	b1c8      	cbz	r0, 2d3d6 <z_unpend_first_thread+0x56>
	__asm__ volatile(
   2d3a2:	f04f 0320 	mov.w	r3, #32
   2d3a6:	f3ef 8511 	mrs	r5, BASEPRI
   2d3aa:	f383 8811 	msr	BASEPRI, r3
   2d3ae:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   2d3b2:	4601      	mov	r1, r0
   2d3b4:	6880      	ldr	r0, [r0, #8]
   2d3b6:	f7f9 fc11 	bl	26bdc <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   2d3ba:	7b63      	ldrb	r3, [r4, #13]
   2d3bc:	f023 0302 	bic.w	r3, r3, #2
   2d3c0:	7363      	strb	r3, [r4, #13]
	__asm__ volatile(
   2d3c2:	f385 8811 	msr	BASEPRI, r5
   2d3c6:	f3bf 8f6f 	isb	sy
	thread->base.pended_on = NULL;
   2d3ca:	2300      	movs	r3, #0
   2d3cc:	60a3      	str	r3, [r4, #8]
   2d3ce:	f104 0018 	add.w	r0, r4, #24
   2d3d2:	f000 f8db 	bl	2d58c <z_abort_timeout>
}
   2d3d6:	4620      	mov	r0, r4
   2d3d8:	bd38      	pop	{r3, r4, r5, pc}

0002d3da <z_unpend_all>:
{
   2d3da:	b570      	push	{r4, r5, r6, lr}
   2d3dc:	4606      	mov	r6, r0
	int need_sched = 0;
   2d3de:	2500      	movs	r5, #0
   2d3e0:	6834      	ldr	r4, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2d3e2:	42a6      	cmp	r6, r4
   2d3e4:	d000      	beq.n	2d3e8 <z_unpend_all+0xe>
	while ((th = z_waitq_head(wait_q)) != NULL) {
   2d3e6:	b90c      	cbnz	r4, 2d3ec <z_unpend_all+0x12>
}
   2d3e8:	4628      	mov	r0, r5
   2d3ea:	bd70      	pop	{r4, r5, r6, pc}
		z_unpend_thread(th);
   2d3ec:	4620      	mov	r0, r4
   2d3ee:	f7ff ff72 	bl	2d2d6 <z_unpend_thread>
	if (z_is_thread_ready(thread)) {
   2d3f2:	4620      	mov	r0, r4
   2d3f4:	f7ff ff13 	bl	2d21e <z_is_thread_ready>
		need_sched = 1;
   2d3f8:	2501      	movs	r5, #1
   2d3fa:	2800      	cmp	r0, #0
   2d3fc:	d0f0      	beq.n	2d3e0 <z_unpend_all+0x6>
		z_add_thread_to_ready_q(thread);
   2d3fe:	4620      	mov	r0, r4
   2d400:	f7f9 fc3c 	bl	26c7c <z_add_thread_to_ready_q>
   2d404:	e7ec      	b.n	2d3e0 <z_unpend_all+0x6>

0002d406 <z_impl_k_sem_init>:
	sys_dlist_init(&sem->poll_events);
   2d406:	f100 0310 	add.w	r3, r0, #16
	sem->limit = limit;
   2d40a:	e9c0 1202 	strd	r1, r2, [r0, #8]
	list->tail = (sys_dnode_t *)list;
   2d40e:	e9c0 0000 	strd	r0, r0, [r0]
   2d412:	e9c0 3304 	strd	r3, r3, [r0, #16]
}
   2d416:	4770      	bx	lr

0002d418 <z_is_thread_ready>:
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   2d418:	7b43      	ldrb	r3, [r0, #13]
   2d41a:	06db      	lsls	r3, r3, #27
   2d41c:	bf03      	ittte	eq
   2d41e:	6980      	ldreq	r0, [r0, #24]
   2d420:	fab0 f080 	clzeq	r0, r0
   2d424:	0940      	lsreq	r0, r0, #5
   2d426:	2000      	movne	r0, #0
}
   2d428:	4770      	bx	lr

0002d42a <z_impl_k_busy_wait>:
	arch_busy_wait(usec_to_wait);
   2d42a:	f7e7 be1f 	b.w	1506c <arch_busy_wait>

0002d42e <z_impl_k_thread_name_set>:
}
   2d42e:	f06f 0046 	mvn.w	r0, #70	; 0x46
   2d432:	4770      	bx	lr

0002d434 <k_thread_name_get>:
}
   2d434:	2000      	movs	r0, #0
   2d436:	4770      	bx	lr

0002d438 <z_new_thread_init>:
{
   2d438:	b510      	push	{r4, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
   2d43a:	9c02      	ldr	r4, [sp, #8]
   2d43c:	7304      	strb	r4, [r0, #12]
	thread_base->thread_state = (u8_t)initial_state;

	thread_base->prio = priority;
   2d43e:	7383      	strb	r3, [r0, #14]
	thread_base->thread_state = (u8_t)initial_state;
   2d440:	2404      	movs	r4, #4

	thread_base->sched_locked = 0U;
   2d442:	2300      	movs	r3, #0
	thread_base->thread_state = (u8_t)initial_state;
   2d444:	7344      	strb	r4, [r0, #13]
	thread_base->sched_locked = 0U;
   2d446:	73c3      	strb	r3, [r0, #15]
	node->prev = NULL;
   2d448:	e9c0 3306 	strd	r3, r3, [r0, #24]
	thread->fn_abort = NULL;
   2d44c:	e9c0 3313 	strd	r3, r3, [r0, #76]	; 0x4c
	thread->stack_info.size = (u32_t)stackSize;
   2d450:	e9c0 1216 	strd	r1, r2, [r0, #88]	; 0x58
}
   2d454:	bd10      	pop	{r4, pc}

0002d456 <z_thread_single_abort>:
	if (thread->fn_abort != NULL) {
   2d456:	6d03      	ldr	r3, [r0, #80]	; 0x50
{
   2d458:	b510      	push	{r4, lr}
   2d45a:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
   2d45c:	b103      	cbz	r3, 2d460 <z_thread_single_abort+0xa>
		thread->fn_abort();
   2d45e:	4798      	blx	r3
	if (z_is_thread_ready(thread)) {
   2d460:	4620      	mov	r0, r4
   2d462:	f7ff ffd9 	bl	2d418 <z_is_thread_ready>
   2d466:	b138      	cbz	r0, 2d478 <z_thread_single_abort+0x22>
		z_remove_thread_from_ready_q(thread);
   2d468:	4620      	mov	r0, r4
   2d46a:	f7f9 fcb5 	bl	26dd8 <z_remove_thread_from_ready_q>
	thread->base.thread_state |= _THREAD_DEAD;
   2d46e:	7b63      	ldrb	r3, [r4, #13]
   2d470:	f043 0308 	orr.w	r3, r3, #8
   2d474:	7363      	strb	r3, [r4, #13]
}
   2d476:	bd10      	pop	{r4, pc}
		if (z_is_thread_pending(thread)) {
   2d478:	7b63      	ldrb	r3, [r4, #13]
   2d47a:	079b      	lsls	r3, r3, #30
   2d47c:	d502      	bpl.n	2d484 <z_thread_single_abort+0x2e>
			z_unpend_thread_no_timeout(thread);
   2d47e:	4620      	mov	r0, r4
   2d480:	f7ff feef 	bl	2d262 <z_unpend_thread_no_timeout>
		if (z_is_thread_timeout_active(thread)) {
   2d484:	69a3      	ldr	r3, [r4, #24]
   2d486:	2b00      	cmp	r3, #0
   2d488:	d0f1      	beq.n	2d46e <z_thread_single_abort+0x18>
   2d48a:	f104 0018 	add.w	r0, r4, #24
   2d48e:	f000 f87d 	bl	2d58c <z_abort_timeout>
   2d492:	e7ec      	b.n	2d46e <z_thread_single_abort+0x18>

0002d494 <k_work_submit_to_queue>:
{
   2d494:	b500      	push	{lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   2d496:	f101 0308 	add.w	r3, r1, #8
   2d49a:	f3bf 8f5b 	dmb	ish
   2d49e:	e853 2f00 	ldrex	r2, [r3]
   2d4a2:	f042 0c01 	orr.w	ip, r2, #1
   2d4a6:	e843 ce00 	strex	lr, ip, [r3]
   2d4aa:	f1be 0f00 	cmp.w	lr, #0
   2d4ae:	d1f6      	bne.n	2d49e <k_work_submit_to_queue+0xa>
   2d4b0:	f3bf 8f5b 	dmb	ish
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   2d4b4:	07d3      	lsls	r3, r2, #31
   2d4b6:	d403      	bmi.n	2d4c0 <k_work_submit_to_queue+0x2c>
}
   2d4b8:	f85d eb04 	ldr.w	lr, [sp], #4
		k_queue_append(&work_q->queue, work);
   2d4bc:	f7ff be21 	b.w	2d102 <k_queue_append>
}
   2d4c0:	f85d fb04 	ldr.w	pc, [sp], #4

0002d4c4 <work_timeout>:
	k_work_submit_to_queue(w->work_q, &w->work);
   2d4c4:	f1a0 010c 	sub.w	r1, r0, #12
   2d4c8:	6900      	ldr	r0, [r0, #16]
   2d4ca:	f7ff bfe3 	b.w	2d494 <k_work_submit_to_queue>

0002d4ce <work_cancel>:
{
   2d4ce:	b570      	push	{r4, r5, r6, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   2d4d0:	f3bf 8f5b 	dmb	ish
   2d4d4:	6883      	ldr	r3, [r0, #8]
   2d4d6:	f3bf 8f5b 	dmb	ish
	if (k_work_pending(&work->work)) {
   2d4da:	07db      	lsls	r3, r3, #31
{
   2d4dc:	4604      	mov	r4, r0
	return atomic_test_bit(work->flags, K_WORK_STATE_PENDING);
   2d4de:	f100 0508 	add.w	r5, r0, #8
	if (k_work_pending(&work->work)) {
   2d4e2:	d532      	bpl.n	2d54a <work_cancel+0x7c>
		if (!k_queue_remove(&work->work_q->queue, &work->work)) {
   2d4e4:	69c2      	ldr	r2, [r0, #28]
 * @return true if node was removed
 */
static inline bool sys_sflist_find_and_remove(sys_sflist_t *list,
					      sys_sfnode_t *node);

Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   2d4e6:	6813      	ldr	r3, [r2, #0]
   2d4e8:	2100      	movs	r1, #0
   2d4ea:	b913      	cbnz	r3, 2d4f2 <work_cancel+0x24>
			return -EINVAL;
   2d4ec:	f06f 0015 	mvn.w	r0, #21
}
   2d4f0:	bd70      	pop	{r4, r5, r6, pc}
   2d4f2:	429c      	cmp	r4, r3
   2d4f4:	d124      	bne.n	2d540 <work_cancel+0x72>
Z_GENLIST_REMOVE(sflist, sfnode)
   2d4f6:	6823      	ldr	r3, [r4, #0]
   2d4f8:	6856      	ldr	r6, [r2, #4]
   2d4fa:	f023 0003 	bic.w	r0, r3, #3
   2d4fe:	b9b1      	cbnz	r1, 2d52e <work_cancel+0x60>
   2d500:	42b4      	cmp	r4, r6
	list->head = node;
   2d502:	6010      	str	r0, [r2, #0]
Z_GENLIST_REMOVE(sflist, sfnode)
   2d504:	d100      	bne.n	2d508 <work_cancel+0x3a>
	list->tail = node;
   2d506:	6050      	str	r0, [r2, #4]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   2d508:	6823      	ldr	r3, [r4, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   2d50a:	f003 0303 	and.w	r3, r3, #3
   2d50e:	6023      	str	r3, [r4, #0]
	work->work_q = NULL;
   2d510:	2000      	movs	r0, #0
   2d512:	61e0      	str	r0, [r4, #28]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2d514:	f3bf 8f5b 	dmb	ish
   2d518:	e855 3f00 	ldrex	r3, [r5]
   2d51c:	f023 0301 	bic.w	r3, r3, #1
   2d520:	e845 3200 	strex	r2, r3, [r5]
   2d524:	2a00      	cmp	r2, #0
   2d526:	d1f7      	bne.n	2d518 <work_cancel+0x4a>
   2d528:	f3bf 8f5b 	dmb	ish
   2d52c:	e7e0      	b.n	2d4f0 <work_cancel+0x22>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   2d52e:	680b      	ldr	r3, [r1, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   2d530:	f003 0303 	and.w	r3, r3, #3
   2d534:	4303      	orrs	r3, r0
Z_GENLIST_REMOVE(sflist, sfnode)
   2d536:	42b4      	cmp	r4, r6
	parent->next_and_flags = cur_flags | (unative_t)child;
   2d538:	600b      	str	r3, [r1, #0]
	list->tail = node;
   2d53a:	bf08      	it	eq
   2d53c:	6051      	streq	r1, [r2, #4]
   2d53e:	e7e3      	b.n	2d508 <work_cancel+0x3a>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   2d540:	6818      	ldr	r0, [r3, #0]
Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   2d542:	4619      	mov	r1, r3
   2d544:	f020 0303 	bic.w	r3, r0, #3
   2d548:	e7cf      	b.n	2d4ea <work_cancel+0x1c>
		(void)z_abort_timeout(&work->timeout);
   2d54a:	300c      	adds	r0, #12
   2d54c:	f000 f81e 	bl	2d58c <z_abort_timeout>
   2d550:	e7de      	b.n	2d510 <work_cancel+0x42>

0002d552 <k_delayed_work_init>:
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   2d552:	2300      	movs	r3, #0
   2d554:	e9c0 3100 	strd	r3, r1, [r0]
	node->next = NULL;
   2d558:	e9c0 3302 	strd	r3, r3, [r0, #8]
	node->prev = NULL;
   2d55c:	6103      	str	r3, [r0, #16]
	work->work_q = NULL;
   2d55e:	61c3      	str	r3, [r0, #28]
}
   2d560:	4770      	bx	lr

0002d562 <k_delayed_work_cancel>:

int k_delayed_work_cancel(struct k_delayed_work *work)
{
	if (!work->work_q) {
   2d562:	69c3      	ldr	r3, [r0, #28]
{
   2d564:	b510      	push	{r4, lr}
	if (!work->work_q) {
   2d566:	b173      	cbz	r3, 2d586 <k_delayed_work_cancel+0x24>
	__asm__ volatile(
   2d568:	f04f 0320 	mov.w	r3, #32
   2d56c:	f3ef 8411 	mrs	r4, BASEPRI
   2d570:	f383 8811 	msr	BASEPRI, r3
   2d574:	f3bf 8f6f 	isb	sy
		return -EINVAL;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	int ret = work_cancel(work);
   2d578:	f7ff ffa9 	bl	2d4ce <work_cancel>
	__asm__ volatile(
   2d57c:	f384 8811 	msr	BASEPRI, r4
   2d580:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
   2d584:	bd10      	pop	{r4, pc}
		return -EINVAL;
   2d586:	f06f 0015 	mvn.w	r0, #21
   2d58a:	e7fb      	b.n	2d584 <k_delayed_work_cancel+0x22>

0002d58c <z_abort_timeout>:
{
   2d58c:	b510      	push	{r4, lr}
	__asm__ volatile(
   2d58e:	f04f 0220 	mov.w	r2, #32
   2d592:	f3ef 8411 	mrs	r4, BASEPRI
   2d596:	f382 8811 	msr	BASEPRI, r2
   2d59a:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   2d59e:	6803      	ldr	r3, [r0, #0]
   2d5a0:	b13b      	cbz	r3, 2d5b2 <z_abort_timeout+0x26>
			remove_timeout(to);
   2d5a2:	f7f9 ff99 	bl	274d8 <remove_timeout>
			ret = 0;
   2d5a6:	2000      	movs	r0, #0
	__asm__ volatile(
   2d5a8:	f384 8811 	msr	BASEPRI, r4
   2d5ac:	f3bf 8f6f 	isb	sy
}
   2d5b0:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   2d5b2:	f06f 0015 	mvn.w	r0, #21
   2d5b6:	e7f7      	b.n	2d5a8 <z_abort_timeout+0x1c>

0002d5b8 <z_get_next_timeout_expiry>:
{
   2d5b8:	b510      	push	{r4, lr}
	__asm__ volatile(
   2d5ba:	f04f 0320 	mov.w	r3, #32
   2d5be:	f3ef 8411 	mrs	r4, BASEPRI
   2d5c2:	f383 8811 	msr	BASEPRI, r3
   2d5c6:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   2d5ca:	f7f9 ff99 	bl	27500 <next_timeout>
	__asm__ volatile(
   2d5ce:	f384 8811 	msr	BASEPRI, r4
   2d5d2:	f3bf 8f6f 	isb	sy
}
   2d5d6:	bd10      	pop	{r4, pc}

0002d5d8 <z_set_timeout_expiry>:
{
   2d5d8:	b570      	push	{r4, r5, r6, lr}
   2d5da:	4604      	mov	r4, r0
   2d5dc:	460e      	mov	r6, r1
	__asm__ volatile(
   2d5de:	f04f 0320 	mov.w	r3, #32
   2d5e2:	f3ef 8511 	mrs	r5, BASEPRI
   2d5e6:	f383 8811 	msr	BASEPRI, r3
   2d5ea:	f3bf 8f6f 	isb	sy
		int next = next_timeout();
   2d5ee:	f7f9 ff87 	bl	27500 <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   2d5f2:	2801      	cmp	r0, #1
   2d5f4:	dd05      	ble.n	2d602 <z_set_timeout_expiry+0x2a>
   2d5f6:	42a0      	cmp	r0, r4
   2d5f8:	dd03      	ble.n	2d602 <z_set_timeout_expiry+0x2a>
			z_clock_set_timeout(ticks, idle);
   2d5fa:	4631      	mov	r1, r6
   2d5fc:	4620      	mov	r0, r4
   2d5fe:	f7e6 f973 	bl	138e8 <z_clock_set_timeout>
	__asm__ volatile(
   2d602:	f385 8811 	msr	BASEPRI, r5
   2d606:	f3bf 8f6f 	isb	sy
}
   2d60a:	bd70      	pop	{r4, r5, r6, pc}

0002d60c <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
   2d60c:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
   2d60e:	f7fa f855 	bl	276bc <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
   2d612:	bd08      	pop	{r3, pc}

0002d614 <z_impl_k_uptime_get>:

s64_t z_impl_k_uptime_get(void)
{
   2d614:	b510      	push	{r4, lr}
	return k_ticks_to_ms_floor64(z_tick_get());
   2d616:	f7fa f851 	bl	276bc <z_tick_get>
			return (t * to_hz + off) / from_hz;
   2d61a:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   2d61e:	fba0 2304 	umull	r2, r3, r0, r4
   2d622:	fb04 3301 	mla	r3, r4, r1, r3
   2d626:	0bd0      	lsrs	r0, r2, #15
}
   2d628:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
   2d62c:	0bd9      	lsrs	r1, r3, #15
   2d62e:	bd10      	pop	{r4, pc}

0002d630 <k_timer_init>:
	timer->status = 0U;
   2d630:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
   2d632:	e9c0 1206 	strd	r1, r2, [r0, #24]
   2d636:	f100 0210 	add.w	r2, r0, #16
	timer->status = 0U;
   2d63a:	6243      	str	r3, [r0, #36]	; 0x24
	list->tail = (sys_dnode_t *)list;
   2d63c:	e9c0 2204 	strd	r2, r2, [r0, #16]
	node->prev = NULL;
   2d640:	e9c0 3300 	strd	r3, r3, [r0]
	timer->user_data = NULL;
   2d644:	6283      	str	r3, [r0, #40]	; 0x28
}
   2d646:	4770      	bx	lr

0002d648 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   2d648:	b510      	push	{r4, lr}
   2d64a:	4604      	mov	r4, r0
	int inactive = z_abort_timeout(&timer->timeout) != 0;
   2d64c:	f7ff ff9e 	bl	2d58c <z_abort_timeout>

	if (inactive) {
   2d650:	bb00      	cbnz	r0, 2d694 <z_impl_k_timer_stop+0x4c>
		return;
	}

	if (timer->stop_fn != NULL) {
   2d652:	69e3      	ldr	r3, [r4, #28]
   2d654:	b10b      	cbz	r3, 2d65a <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   2d656:	4620      	mov	r0, r4
   2d658:	4798      	blx	r3
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
   2d65a:	f104 0010 	add.w	r0, r4, #16
   2d65e:	2100      	movs	r1, #0
   2d660:	f7ff fdef 	bl	2d242 <z_find_first_thread_to_unpend>
	if (thread != NULL) {
   2d664:	4604      	mov	r4, r0
   2d666:	b1a8      	cbz	r0, 2d694 <z_impl_k_timer_stop+0x4c>
		z_unpend_thread_no_timeout(thread);
   2d668:	f7ff fdfb 	bl	2d262 <z_unpend_thread_no_timeout>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   2d66c:	7b63      	ldrb	r3, [r4, #13]
   2d66e:	06db      	lsls	r3, r3, #27
   2d670:	d104      	bne.n	2d67c <z_impl_k_timer_stop+0x34>
	if (z_is_thread_ready(thread)) {
   2d672:	69a3      	ldr	r3, [r4, #24]
   2d674:	b913      	cbnz	r3, 2d67c <z_impl_k_timer_stop+0x34>
		z_add_thread_to_ready_q(thread);
   2d676:	4620      	mov	r0, r4
   2d678:	f7f9 fb00 	bl	26c7c <z_add_thread_to_ready_q>
	__asm__ volatile(
   2d67c:	f04f 0320 	mov.w	r3, #32
   2d680:	f3ef 8011 	mrs	r0, BASEPRI
   2d684:	f383 8811 	msr	BASEPRI, r3
   2d688:	f3bf 8f6f 	isb	sy

	if (pending_thread != NULL) {
		z_ready_thread(pending_thread);
		z_reschedule_unlocked();
	}
}
   2d68c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
   2d690:	f7ff be0b 	b.w	2d2aa <z_reschedule_irqlock>
   2d694:	bd10      	pop	{r4, pc}

0002d696 <clear_event_registrations>:
	while (num_events--) {
   2d696:	2314      	movs	r3, #20
{
   2d698:	b570      	push	{r4, r5, r6, lr}
   2d69a:	fb03 0101 	mla	r1, r3, r1, r0
	event->poller = NULL;
   2d69e:	2400      	movs	r4, #0
   2d6a0:	2601      	movs	r6, #1
	while (num_events--) {
   2d6a2:	4281      	cmp	r1, r0
   2d6a4:	d100      	bne.n	2d6a8 <clear_event_registrations+0x12>
}
   2d6a6:	bd70      	pop	{r4, r5, r6, pc}
	switch (event->type) {
   2d6a8:	f811 3c07 	ldrb.w	r3, [r1, #-7]
	event->poller = NULL;
   2d6ac:	f841 4c0c 	str.w	r4, [r1, #-12]
	switch (event->type) {
   2d6b0:	f003 030f 	and.w	r3, r3, #15
   2d6b4:	2b04      	cmp	r3, #4
   2d6b6:	d80d      	bhi.n	2d6d4 <clear_event_registrations+0x3e>
   2d6b8:	fa06 f303 	lsl.w	r3, r6, r3
   2d6bc:	f013 0f16 	tst.w	r3, #22
   2d6c0:	d008      	beq.n	2d6d4 <clear_event_registrations+0x3e>
	if (remove && sys_dnode_is_linked(&event->_node)) {
   2d6c2:	f851 3c14 	ldr.w	r3, [r1, #-20]
   2d6c6:	b12b      	cbz	r3, 2d6d4 <clear_event_registrations+0x3e>
	node->prev->next = node->next;
   2d6c8:	f851 5c10 	ldr.w	r5, [r1, #-16]
   2d6cc:	602b      	str	r3, [r5, #0]
	node->next->prev = node->prev;
   2d6ce:	605d      	str	r5, [r3, #4]
	node->prev = NULL;
   2d6d0:	e941 4405 	strd	r4, r4, [r1, #-20]
	__asm__ volatile(
   2d6d4:	f382 8811 	msr	BASEPRI, r2
   2d6d8:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   2d6dc:	f04f 0320 	mov.w	r3, #32
   2d6e0:	f3ef 8211 	mrs	r2, BASEPRI
   2d6e4:	f383 8811 	msr	BASEPRI, r3
   2d6e8:	f3bf 8f6f 	isb	sy
   2d6ec:	3914      	subs	r1, #20
   2d6ee:	e7d8      	b.n	2d6a2 <clear_event_registrations+0xc>

0002d6f0 <signal_poll_event>:
{
   2d6f0:	b570      	push	{r4, r5, r6, lr}
	struct _poller *poller = event->poller;
   2d6f2:	6884      	ldr	r4, [r0, #8]
{
   2d6f4:	4605      	mov	r5, r0
   2d6f6:	460e      	mov	r6, r1
	if (poller) {
   2d6f8:	b19c      	cbz	r4, 2d722 <signal_poll_event+0x32>
		if (poller->cb != NULL) {
   2d6fa:	68a3      	ldr	r3, [r4, #8]
   2d6fc:	b95b      	cbnz	r3, 2d716 <signal_poll_event+0x26>
		poller->is_polling = false;
   2d6fe:	7023      	strb	r3, [r4, #0]
	int retcode = 0;
   2d700:	4618      	mov	r0, r3
	event->poller = NULL;
   2d702:	2300      	movs	r3, #0
   2d704:	60ab      	str	r3, [r5, #8]
	event->state |= state;
   2d706:	68eb      	ldr	r3, [r5, #12]
   2d708:	f3c3 3204 	ubfx	r2, r3, #12, #5
   2d70c:	4316      	orrs	r6, r2
   2d70e:	f366 3310 	bfi	r3, r6, #12, #5
   2d712:	60eb      	str	r3, [r5, #12]
	return retcode;
   2d714:	e004      	b.n	2d720 <signal_poll_event+0x30>
			retcode = poller->cb(event, state);
   2d716:	4798      	blx	r3
		poller->is_polling = false;
   2d718:	2300      	movs	r3, #0
		if (retcode < 0) {
   2d71a:	2800      	cmp	r0, #0
		poller->is_polling = false;
   2d71c:	7023      	strb	r3, [r4, #0]
		if (retcode < 0) {
   2d71e:	daf0      	bge.n	2d702 <signal_poll_event+0x12>
}
   2d720:	bd70      	pop	{r4, r5, r6, pc}
	int retcode = 0;
   2d722:	4620      	mov	r0, r4
   2d724:	e7ed      	b.n	2d702 <signal_poll_event+0x12>

0002d726 <k_poll_poller_cb>:
{
   2d726:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = event->poller->thread;
   2d728:	6883      	ldr	r3, [r0, #8]
   2d72a:	685c      	ldr	r4, [r3, #4]
	if (!z_is_thread_pending(thread)) {
   2d72c:	7b63      	ldrb	r3, [r4, #13]
   2d72e:	079a      	lsls	r2, r3, #30
{
   2d730:	460d      	mov	r5, r1
	if (!z_is_thread_pending(thread)) {
   2d732:	d401      	bmi.n	2d738 <k_poll_poller_cb+0x12>
		return 0;
   2d734:	2000      	movs	r0, #0
}
   2d736:	bd38      	pop	{r3, r4, r5, pc}
	if (z_is_thread_timeout_expired(thread)) {
   2d738:	6a23      	ldr	r3, [r4, #32]
   2d73a:	3302      	adds	r3, #2
   2d73c:	d012      	beq.n	2d764 <k_poll_poller_cb+0x3e>
	z_unpend_thread(thread);
   2d73e:	4620      	mov	r0, r4
   2d740:	f7ff fdc9 	bl	2d2d6 <z_unpend_thread>
	arch_thread_return_value_set(thread,
   2d744:	2d08      	cmp	r5, #8
   2d746:	bf0c      	ite	eq
   2d748:	f06f 0303 	mvneq.w	r3, #3
   2d74c:	2300      	movne	r3, #0
   2d74e:	66a3      	str	r3, [r4, #104]	; 0x68
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   2d750:	7b63      	ldrb	r3, [r4, #13]
   2d752:	06db      	lsls	r3, r3, #27
   2d754:	d1ee      	bne.n	2d734 <k_poll_poller_cb+0xe>
	if (!z_is_thread_ready(thread)) {
   2d756:	69a5      	ldr	r5, [r4, #24]
   2d758:	2d00      	cmp	r5, #0
   2d75a:	d1eb      	bne.n	2d734 <k_poll_poller_cb+0xe>
		z_add_thread_to_ready_q(thread);
   2d75c:	4620      	mov	r0, r4
   2d75e:	f7f9 fa8d 	bl	26c7c <z_add_thread_to_ready_q>
	return 0;
   2d762:	e7e7      	b.n	2d734 <k_poll_poller_cb+0xe>
		return -EAGAIN;
   2d764:	f06f 000a 	mvn.w	r0, #10
   2d768:	e7e5      	b.n	2d736 <k_poll_poller_cb+0x10>

0002d76a <add_event>:
{
   2d76a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2d76c:	4617      	mov	r7, r2
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   2d76e:	e9d0 2300 	ldrd	r2, r3, [r0]
   2d772:	4290      	cmp	r0, r2
   2d774:	4604      	mov	r4, r0
   2d776:	460d      	mov	r5, r1
   2d778:	d106      	bne.n	2d788 <add_event+0x1e>
	node->prev = list->tail;
   2d77a:	6863      	ldr	r3, [r4, #4]
   2d77c:	606b      	str	r3, [r5, #4]
	list->tail->next = node;
   2d77e:	6863      	ldr	r3, [r4, #4]
	node->next = list;
   2d780:	602c      	str	r4, [r5, #0]
	list->tail->next = node;
   2d782:	601d      	str	r5, [r3, #0]
	list->tail = node;
   2d784:	6065      	str	r5, [r4, #4]
}
   2d786:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if ((pending == NULL) ||
   2d788:	2b00      	cmp	r3, #0
   2d78a:	d0f6      	beq.n	2d77a <add_event+0x10>
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
   2d78c:	689b      	ldr	r3, [r3, #8]
   2d78e:	6879      	ldr	r1, [r7, #4]
   2d790:	6858      	ldr	r0, [r3, #4]
   2d792:	f7ff fd4d 	bl	2d230 <z_is_t1_higher_prio_than_t2>
	if ((pending == NULL) ||
   2d796:	2800      	cmp	r0, #0
   2d798:	d1ef      	bne.n	2d77a <add_event+0x10>
	return list->head == list;
   2d79a:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2d79c:	42b4      	cmp	r4, r6
   2d79e:	d0ec      	beq.n	2d77a <add_event+0x10>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   2d7a0:	2e00      	cmp	r6, #0
   2d7a2:	d0ea      	beq.n	2d77a <add_event+0x10>
		if (z_is_t1_higher_prio_than_t2(poller->thread,
   2d7a4:	68b3      	ldr	r3, [r6, #8]
   2d7a6:	6878      	ldr	r0, [r7, #4]
   2d7a8:	6859      	ldr	r1, [r3, #4]
   2d7aa:	f7ff fd41 	bl	2d230 <z_is_t1_higher_prio_than_t2>
   2d7ae:	b128      	cbz	r0, 2d7bc <add_event+0x52>
	node->prev = successor->prev;
   2d7b0:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   2d7b2:	e9c5 6300 	strd	r6, r3, [r5]
	successor->prev->next = node;
   2d7b6:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   2d7b8:	6075      	str	r5, [r6, #4]
			return;
   2d7ba:	e7e4      	b.n	2d786 <add_event+0x1c>
	return (node == list->tail) ? NULL : node->next;
   2d7bc:	6863      	ldr	r3, [r4, #4]
   2d7be:	429e      	cmp	r6, r3
   2d7c0:	d0db      	beq.n	2d77a <add_event+0x10>
   2d7c2:	6836      	ldr	r6, [r6, #0]
   2d7c4:	e7ec      	b.n	2d7a0 <add_event+0x36>

0002d7c6 <register_events>:
{
   2d7c6:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int ii = 0; ii < num_events; ii++) {
   2d7ca:	f04f 0b00 	mov.w	fp, #0
{
   2d7ce:	4688      	mov	r8, r1
   2d7d0:	4615      	mov	r5, r2
   2d7d2:	4699      	mov	r9, r3
   2d7d4:	4604      	mov	r4, r0
	int events_registered = 0;
   2d7d6:	465e      	mov	r6, fp
	event->poller = NULL;
   2d7d8:	465f      	mov	r7, fp
	for (int ii = 0; ii < num_events; ii++) {
   2d7da:	45c3      	cmp	fp, r8
   2d7dc:	db02      	blt.n	2d7e4 <register_events+0x1e>
}
   2d7de:	4630      	mov	r0, r6
   2d7e0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2d7e4:	f04f 0320 	mov.w	r3, #32
   2d7e8:	f3ef 8a11 	mrs	sl, BASEPRI
   2d7ec:	f383 8811 	msr	BASEPRI, r3
   2d7f0:	f3bf 8f6f 	isb	sy
	switch (event->type) {
   2d7f4:	7b63      	ldrb	r3, [r4, #13]
   2d7f6:	f003 030f 	and.w	r3, r3, #15
   2d7fa:	2b02      	cmp	r3, #2
   2d7fc:	d005      	beq.n	2d80a <register_events+0x44>
   2d7fe:	2b04      	cmp	r3, #4
   2d800:	d006      	beq.n	2d810 <register_events+0x4a>
   2d802:	2b01      	cmp	r3, #1
   2d804:	d118      	bne.n	2d838 <register_events+0x72>
		if (event->signal->signaled != 0U) {
   2d806:	6922      	ldr	r2, [r4, #16]
   2d808:	e000      	b.n	2d80c <register_events+0x46>
		if (k_sem_count_get(event->sem) > 0) {
   2d80a:	6922      	ldr	r2, [r4, #16]
		if (event->signal->signaled != 0U) {
   2d80c:	6892      	ldr	r2, [r2, #8]
   2d80e:	e001      	b.n	2d814 <register_events+0x4e>
		if (!k_queue_is_empty(event->queue)) {
   2d810:	6922      	ldr	r2, [r4, #16]
   2d812:	6812      	ldr	r2, [r2, #0]
		if (event->signal->signaled != 0U) {
   2d814:	b182      	cbz	r2, 2d838 <register_events+0x72>
	event->state |= state;
   2d816:	68e2      	ldr	r2, [r4, #12]
	event->poller = NULL;
   2d818:	60a7      	str	r7, [r4, #8]
	event->state |= state;
   2d81a:	f3c2 3104 	ubfx	r1, r2, #12, #5
   2d81e:	430b      	orrs	r3, r1
   2d820:	f363 3210 	bfi	r2, r3, #12, #5
   2d824:	60e2      	str	r2, [r4, #12]
			poller->is_polling = false;
   2d826:	702f      	strb	r7, [r5, #0]
	__asm__ volatile(
   2d828:	f38a 8811 	msr	BASEPRI, sl
   2d82c:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
   2d830:	f10b 0b01 	add.w	fp, fp, #1
   2d834:	3414      	adds	r4, #20
   2d836:	e7d0      	b.n	2d7da <register_events+0x14>
		} else if (!just_check && poller->is_polling) {
   2d838:	f1b9 0f00 	cmp.w	r9, #0
   2d83c:	d1f4      	bne.n	2d828 <register_events+0x62>
   2d83e:	782b      	ldrb	r3, [r5, #0]
   2d840:	2b00      	cmp	r3, #0
   2d842:	d0f1      	beq.n	2d828 <register_events+0x62>
	switch (event->type) {
   2d844:	7b63      	ldrb	r3, [r4, #13]
   2d846:	f003 030f 	and.w	r3, r3, #15
   2d84a:	2b02      	cmp	r3, #2
   2d84c:	d007      	beq.n	2d85e <register_events+0x98>
   2d84e:	2b04      	cmp	r3, #4
   2d850:	d00e      	beq.n	2d870 <register_events+0xaa>
   2d852:	2b01      	cmp	r3, #1
   2d854:	d109      	bne.n	2d86a <register_events+0xa4>
		add_event(&event->signal->poll_events, event, poller);
   2d856:	462a      	mov	r2, r5
   2d858:	4621      	mov	r1, r4
   2d85a:	6920      	ldr	r0, [r4, #16]
   2d85c:	e003      	b.n	2d866 <register_events+0xa0>
		add_event(&event->sem->poll_events, event, poller);
   2d85e:	6920      	ldr	r0, [r4, #16]
   2d860:	462a      	mov	r2, r5
   2d862:	4621      	mov	r1, r4
   2d864:	3010      	adds	r0, #16
		add_event(&event->signal->poll_events, event, poller);
   2d866:	f7ff ff80 	bl	2d76a <add_event>
	event->poller = poller;
   2d86a:	60a5      	str	r5, [r4, #8]
				events_registered += 1;
   2d86c:	3601      	adds	r6, #1
   2d86e:	e7db      	b.n	2d828 <register_events+0x62>
		add_event(&event->queue->poll_events, event, poller);
   2d870:	6920      	ldr	r0, [r4, #16]
   2d872:	462a      	mov	r2, r5
   2d874:	4621      	mov	r1, r4
   2d876:	3008      	adds	r0, #8
   2d878:	e7f5      	b.n	2d866 <register_events+0xa0>

0002d87a <z_handle_obj_poll_events>:
	return list->head == list;
   2d87a:	6803      	ldr	r3, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
   2d87c:	4298      	cmp	r0, r3
   2d87e:	d009      	beq.n	2d894 <z_handle_obj_poll_events+0x1a>
	node->prev->next = node->next;
   2d880:	e9d3 2000 	ldrd	r2, r0, [r3]
   2d884:	6002      	str	r2, [r0, #0]
	node->next->prev = node->prev;
   2d886:	6050      	str	r0, [r2, #4]
	node->next = NULL;
   2d888:	2200      	movs	r2, #0
	node->prev = NULL;
   2d88a:	e9c3 2200 	strd	r2, r2, [r3]
		(void) signal_poll_event(poll_event, state);
   2d88e:	4618      	mov	r0, r3
   2d890:	f7ff bf2e 	b.w	2d6f0 <signal_poll_event>
}
   2d894:	4770      	bx	lr

0002d896 <z_impl_k_poll_signal_init>:
	signal->signaled = 0U;
   2d896:	2300      	movs	r3, #0
	list->tail = (sys_dnode_t *)list;
   2d898:	e9c0 0000 	strd	r0, r0, [r0]
   2d89c:	6083      	str	r3, [r0, #8]
}
   2d89e:	4770      	bx	lr

0002d8a0 <z_impl_k_poll_signal_check>:
	*signaled = signal->signaled;
   2d8a0:	6883      	ldr	r3, [r0, #8]
   2d8a2:	600b      	str	r3, [r1, #0]
	*result = signal->result;
   2d8a4:	68c3      	ldr	r3, [r0, #12]
   2d8a6:	6013      	str	r3, [r2, #0]
}
   2d8a8:	4770      	bx	lr

0002d8aa <_OffsetAbsSyms>:
					    sizeof(struct _preempt_float));
#else
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF, sizeof(struct k_thread));
#endif

GEN_ABS_SYM_END
   2d8aa:	4770      	bx	lr
